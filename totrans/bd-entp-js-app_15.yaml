- en: E2E Testing in React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our backend development, we vehemently followed **Test-Driven Development**
    (**TDD**) – we started development by writing E2E tests, and we wrote some implementation
    code to make these tests pass. After we implemented this feature, we added unit
    and integration tests to add more confidence to our underlying code, and also
    to help catch regression.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic understanding of React, we will, in this chapter,
    examine how we can implement TDD in React. Specifically, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using **Selenium** to automate interaction with the browser
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **React Router** to implement **client-side routing**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it turns out, TDD on the frontend follows a similar approach involving automated
    UI testing and Unit tests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Automated UI testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write E2E tests for our API, we first compose our request, send it,
    and assert that it returns what is expected. In other words, our E2E tests are
    mimicking how an end user would interact with our API. For the frontend, a user
    would interact with our application through the user interface (UI). Therefore,
    the equivalent to E2E testing would be automated UI testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'UI tests automate the actions that a user of the application would take. For
    example, if we want to test that an user can register, we''d write a test that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Navigates to the `/register` page
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types in the email
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types in the password
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presses the Register button
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserts that the user is registered
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tests can be written in Gherkin and run with Cucumber. The actual mimicking
    of the user action can automate these using Browser Automation Tools like Selenium.
    For example, when we run the test step "Press the Register button", we can instruct
    Selenium to select the button with the `id` value `register-button` and trigger
    a click event on it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the frontend, unit testing involves two different aspects—logical units
    and component units.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Logical units
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit can be a function or class that does not interact with the UI; functions
    like `validateInput` are a prime example. These logical units uses plain JavaScript
    and should work independently from the environment. Therefore, we can unit test
    them using Mocha, Chai, and Sinon in the same manner as we did for our backend
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Because logical units are the easiest to test. You should pull as much of that
    application logic as possible and test it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Component units
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit may also refer to a single component in React. For example, we can test
    that when the input has changed, that the state of the component is updated in
    an expected way; or for controlled components, that the right callback is called
    with the correct parameters
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Browser testing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to headless browsers—browsers that don't render to a display interface—both
    E2E and unit tests can be run from the server. However, we should also test these
    unit tests in a real browser, as there might be inconsistencies between NodeJS
    (which uses the V8 JavaScript Engine), and other browsers like Firefox (which
    uses the SpiderMonkey engine), Microsoft Edge (which uses the Chakra engine),
    and Safari (which uses the Nitro engine).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To test on real browsers and devices, we can use a different test runner called
    *Karma* ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Writing E2E tests with Gherkin, Cucumber, and Selenium
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to integrate with tools that can mimic user interaction with
    a browser. For our first test, let's test something very simple—a user will type
    in a valid email, but their password is too short. In this case, we want to assert
    that the Register button will be disabled.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Like our backend E2E tests, we will be writing our test cases in Gherkin, and
    using Cucumber to run our scenarios. So, let''s add these as development dependencies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we need to create feature files and step definition files. For our first
    scenario, I have opted to group the features and steps in the following structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Feel free to group them differently, as long as the features are separated from
    the step definitions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Adding test script
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we haven''t written any tests yet, we can simply copy the test script
    we wrote for our API and place it in `scripts/e2e.test.sh`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The only difference between our script and the backend test script is this
    line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With `> /dev/null`, we are directing `stdout` into the *null device* (`/dev/null`),
    which discards anything piped into it. With `2>&1`, we are directing `stderr`
    to `stdout`, which will end up at `/dev/null` eventually. Basically, this line
    is saying "I don't care about the output of `yarn run serve`, just throw it away".
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: We do this because, as Selenium is navigating between different pages, the output
    from the `http-server` will be sent to `stdout` and interspersed between the test
    results, making it hard to read.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, don''t forget to install the script''s dependencies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need to create a `.babelrc` file to instruct `babel-register` to use
    the `env` preset:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, update the `package.json` with the new script:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Specifying a feature
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to define our first feature. In `spec/cucumber/features/users/reigster/main.feature`,
    add the following specification:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding IDs to elements
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Selenium to automate the interaction with the UI elements of our
    application. However, we must provide some sort of selector for Selenium to select
    the element we want to interact with. The most precise selector we can have is
    an `id` attribute.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before we use Selenium, let''s add some ids to our elements. Open `src/components/registration-form/index.jsx` and
    add an `id` prop to each element:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, in `src/components/input/index.jsx` and `src/components/button/index.jsx`,
    pass the `id` prop into the element as an attribute. For instance, the `Button`
    component would become:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Selenium
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to use Selenium. Selenium was written by Jason Huggins in
    2004 while working at ThoughtWorks. It is not just a single tool, but a suite
    of tools, that allows you to automate browsers across multiple platforms. We will
    be using the JavaScript binding to Selenium WebDriver, but it''s beneficial for
    us to take a quick look at each part of the tool suite:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Selenium **Remote Control** (**RC**), also known as Selenium 1.0, is the first
    tool in the suite that allows you to automate browsers. It works by injecting
    JavaScript scripts into the browser when the page is first loaded. These scripts
    would simulate user interaction by clicking on buttons and inputting texts. Selenium
    RC has been deprecated and is superseded by Selenium WebDriver.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium WebDriver, also known as Selenium 2, is the successor of Selenium RC,
    and uses the standardized WebDriver API to mimic user interaction. Most browsers
    have built-in support for the WebDriver API, and so the tool doesn't need to inject
    scripts onto the page anymore.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium Server allows you to run your tests on a remote machine, such as when
    using Selenium Grid.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium Grid allows you to distribute your tests over multiple machines or
    virtual machines (VMs). These tests can then run in parallel. If your test suite
    is large, and/or you need to run tests on multiple browsers and/or operating systems,
    then test execution is likely to take a long time. By distributing these tests
    across multiple machines, you can run them in parallel and reduce the total execution
    time.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium IDE is a Chrome extension/Firefox plugin that provides a rapid prototyping
    tool for building test scripts. Essentially, it can record actions a user takes
    on a page, and exports them as a reusable script in many languages. A developer
    can then take this script and further customize it to their own needs.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For testing our application, we are going to be using Selenium WebDriver.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver API
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*WebDriver* is a standardized API that allows you to inspect and control a
    user agent (for example, a browser or mobile application). It was originally conceived
    in 2006 by Simon Stewart, a Google engineer at the time. It has now been defined
    by the World Wide Web Consortium (W3C), and its specification can be found at
    [https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/). The document
    is currently in the *Candidate Recommendation* stage.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Instead of injecting JavaScript scripts into the web page and using them to
    mimic user interaction, Selenium WebDriver uses the WebDriver API, which most
    browsers support. However, you may see variation in the level of support, as well
    as how the standard is implemented, between different browsers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: While the API is platform- and language-neutral, there have been many implementations
    of it. Specifically, we are going to be using the official JavaScript binding,
    which is available as the "selenium-webdriver" package on NPM.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Using Selenium WebDriver
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding the Selenium WebDriver JavaScript package to our project:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will use `selenium-webdriver` to define our Step Definitions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Selenium requires a browser to run tests on. This may be a real browser like
    Chrome, or a headless browser such a PhantomJS. You're likely familiar with the
    different real browsers, so let's spend some time taking a look at the headless
    browsers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Headless browsers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Headless browsers are browsers that do not render the page on an interface.
    A header browser would fetch the content of the page and then download images,
    stylesheets, scripts, and so on, and process them just like a real browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using a headless browser is that it is much faster. This is
    because the browser doesn''t have a Graphical User Interface (GUI), and thus there''s
    no need to wait for the display to actually render the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)) uses the WebKit web
    browser engine, which is the same one that is used by Safari. It is arguably the
    most popular headless browser today. However, activity on its repository has almost
    come to a halt since the middle of 2016.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SlimerJS ([https://slimerjs.org/](https://slimerjs.org/)) uses the Gecko web
    browser engine, and SpiderMonkey as the JavaScript engine, which is the same as
    Firefox. SlimerJS is not a headless browser by default, as it uses the X11 display
    server on the test machine. However, you can integrate it with *Xvfb* (short for
    *X virtual framebuffer*), which is an in-memory display server that does not require
    a display. Since Firefox 56, you can also enable headless mode with the `--headless`
    flag.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZombieJS ([http://zombie.js.org/](http://zombie.js.org/)) is a faster implementation
    of a headless browser because it does not use an actual web browser engine like
    PhantomJS or SlimerJS. Instead, it uses JSDOM, which is a pure-JavaScript implementation
    of the DOM and HTML. However, also because of this, the results may not be 100%
    accurate or as realistic as testing against an actual web browser engine.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HtmlUnit ([http://htmlunit.sourceforge.net/](http://htmlunit.sourceforge.net/))
    is a "GUI-less browser for Java programs". It uses the Rhino JavaScript engine,
    which, like Selenium, is written in Java. From experience, HtmlUnit is the quickest
    headless browser but also the most error-prone. It's ideal for simple static pages
    that do not involve heavy JavaScript usage.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more headless browsers out there. Asad Dhamani has curated a
    list which you can find at [https://github.com/dhamaniasad/HeadlessBrowsers](https://github.com/dhamaniasad/HeadlessBrowsers).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'However, purely-headless browsers might be a thing of the past soon, as many
    "real" browsers now support Headless Mode. The following browsers have Headless
    Mode support:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Chrome 59
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox 55 (on Linux) and 56 (on macOS and Windows)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For those that don't, we can use Xvfb to substitute for the X11 display server,
    and run the real browser on a CI server. However, this will lose the performance
    benefit of running a headless browser.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Browser drivers
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium WebDriver supports many browsers, both real and headless, and each
    one requires its own driver that implements WebDriver's wire protocol for that
    specific browser.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'For real browsers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Chrome and Chrome on Android uses the ChromeDriver ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/)),
    which is maintained by the Chromium project itself
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox uses the geckodriver ([https://github.com/mozilla/geckodriver/](https://github.com/mozilla/geckodriver/))
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet Explorer uses the Internet Explorer Driver
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge uses Microsoft WebDriver ([https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/))
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari uses SafariDriver ([https://webkit.org/blog/6900/webdriver-support-in-safari-10/](https://webkit.org/blog/6900/webdriver-support-in-safari-10/))
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opera uses Opera Driver
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS (native, hybrid, or mobile web application) uses ios-driver ([http://ios-driver.github.io/ios-driver/](http://ios-driver.github.io/ios-driver/))
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android (native, hybrid, or mobile web application) uses Selendroid
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For headless browsers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: HtmlUnit uses HtmlUnitDriver ([https://github.com/SeleniumHQ/htmlunit-driver](https://github.com/SeleniumHQ/htmlunit-driver))
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhantomJS uses GhostDriver ([https://github.com/detro/ghostdriver](https://github.com/detro/ghostdriver)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup and teardown
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can run any tests, we must tell Selenium which browser to use. Chrome
    is, by far, the most popular browser in use today, and so we will start with using
    ChromeDriver. Let''s install it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, inside `spec/cucumber/steps/index.js`, define `Before` and `After` hooks
    which are run before each scenario:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `Before` hook, we are creating a new instance of the driver. A driver
    is akin to an user session, and a session can have many windows opened (just like
    you can have multiple tabs opened at the same time).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `webdriver.Builder` constructor function returns with an instance that
    implements the `ThenableWebDriver` interface, which allows us to specify parameters
    for the driver by chaining methods together. Some popular methods include the
    following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`forBrowser`: Specify which browser to use.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withCapabilities`: Passes parameters to the browser command. Later on, we
    will use this to run Chrome in Headless Mode.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the parameters have been set, terminate the chain using the `build` method
    to return an instance of the driver.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In the `After` hook, we are disposing the driver using the `quit` method. This
    will close all windows and end the session.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We are storing the driver instance in Cucumber's World (the context) for other
    steps to use.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Implementing step definitions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to implement the step definitions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to a page
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that everything is set up, let''s implement our first step, which is `When
    user navigates to /`. Navigation can be done using the `.get` method on our driver
    object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This step takes the server host and port from the environment variables. `this.driver.get`
    returns a promise which is returned. Cucumber will wait for this promise to be
    resolved or rejected before moving on to the next step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Typing into input
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is our next step:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This involves finding the element with the `id` of `email`, and then sending
    keystroke events to it. In `spec/cucumber/steps/interactions/input.js`, add the
    following step definition:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `driver.findElement` returns an instance of `WebElementPromise`. We are
    using the `async`/`await` syntax to avoid callback hell or heavily chained promises.
    The same step definition would work for our next step, which types in a short
    password into the `#password` input element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Asserting a result
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to do the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As before, we need to find the element, but this time read its `disabled` attribute
    and assert that it is set to `"true"`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The HTML *content* attribute will always be a string, even when you'd expect
    a boolean or number.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In `spec/cucumber/steps/assertions/index.js`, add the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we use the `getAttribute` method from the `WebElement` instance to get
    the value of the `disabled` attribute. Again, this is an asynchronous operation,
    so we are using `async`/`await` syntax to keep things neat.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: If you have time, it's always a good idea to read the official documentation.
    The API of all classes and methods from `selenium-webdriver` can be found at [https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/](https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to run the tests:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will run the `./scripts/e2e.test.sh` script, which will build the project
    using Webpack (this may take some time). Then, a Google Chrome browser will pop
    up, and you''ll see the input fields being automatically populated with the text
    we specified. After Selenium has performed all actions required, the `driver.quit()`
    method call in our After hook will close the browser, and the results will be
    displayed in our terminal.:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding multiple testing browsers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest benefit of using Selenium is that you can use the same tests to
    test multiple browsers. If we are interested in just a single browser, like Chrome,
    we'd be better off using Puppeteer. So, let's add Firefox to our tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Firefox, like Chrome, requires a driver to work. Firefox''s driver is `geckodriver`,
    which uses the *Marionette* proxy to send instructions to Firefox (Marionette
    is similar to Chrome''s DevTools Protocol):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, all we need to do is change the `forBrowser` call to use `"firefox"`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we run our tests again, Firefox will be used instead of Chrome.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'However, instead of hard-coding the browser into our code, let''s update our
    scripts to allow us to specify the browsers we want to test. We can do this by
    passing arguments into the shell script. For instance, if we execute the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in our `scripts/e2e.test.sh`, we can access the arguments using `$1`
    for the first argument (`chrome`), `$2` for `firefox`, and so on. Alternatively,
    we can use the special argument `"$@"`, which is an array-like construct that
    contains all arguments. In `scripts/e2e.test.sh`, change the test block to the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will loop through our list of browsers, `export` it in the `TEST_BROWSER`
    variable, and run our tests. Then, in the `forBrowser` call inside `spec/cucumber/steps/index.js`,
    pass in the browser name from `process.env` instead of hard-coding it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, try running it with `$ yarn run test:e2e -- chrome firefox`, and you should
    see our tests being run first on Chrome, and then Firefox, and then the results
    neatly displayed in a standard output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, we should define NPM scripts to make it obvious to other developers
    what operations we can run. By adding it as an NPM script, all the user needs
    to do is look at the `package.json`, and won''t have to study the shell script
    to see how it works. So, in the `scripts` section of the `package.json`, change
    our `test:e2e` to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have now successfully written our first test and run it. Next, let''s make
    our scenario more generic by covering all the invalid cases:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running our backend API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to cater for the happy path scenario where a user fills in valid
    details and the Register button is clicked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will write a test that says "When a user submits valid details, after
    the server response is received, the UI will display a success message". This
    feature has not been implemented yet, which means this would be our first step
    toward TDD in frontend!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic string substitution with Webpack
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one minor improvement we must make before we can do E2E testing with
    the API backend. At the moment, we are hard-coding the URL for our production
    API endpoint (`localhost:8080`), even though during the test, the testing URL
    (`localhost:8888`) will be used. Therefore, we need to replace this with a placeholder
    that we can override during build time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in `src/components/registration-form/index.jsx`, replace the following
    line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using `%%` to mark our placeholder because it's a relatively uncommon
    sequence of characters. You may choose any placeholder syntax you like.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add a new loader to replace this placeholder at build time.
    `string-replace-loader` fits the bill perfectly. Let''s install it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in `.env` and `.env.example`, add the details of the API host and port
    for different environment:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, use the plugin inside `webpack.config.js`. We want the loader to transform
    all `.js` and `.jsx` files, and so we can use the same rules that we used for
    `babel-loader`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At the top, we are checking the `NODE_ENV` environment variable and using it
    to determine which port the API is using. Then, in the options for our loader,
    we are instructing it to do a global RegEx search for the string, and replacing
    it with the dynamically-derived host and port.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Serving the API from a submodule
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run our tests, we want to make sure that our backend API is running
    using the `NODE_ENV` environment variable set to `test`. At the moment, we are
    doing this manually. However, it''s more ideal to add it as part of our test script.
    Just as we did for our Swagger UI, we can use Git submodules to include the Hobnob
    API repository in the client''s repository without duplicating the code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, to make life easier for later, add the following NPM scripts to `package.json`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`api:init` will download the Hobnob API repository using the commit hash that''s
    been stored. `api:install` uses `--cwd` to change directory into the `api` directory
    before running `yarn install`. `api:serve` first runs the `build` script from
    our API repository, loads the environment variables, and then runs the API server.
    `api:update` will download but also update the API repository to the latest commit
    in the same branch.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, run the NPM scripts inside `scripts/e2e.test.sh`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Defining the happy scenario
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin defining our happy scenario by writing the feature file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generating random data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this scenario, we cannot hard-code a single email to test because it may
    lead to a `409 Conflict` error because an account with that email already exists.
    Therefore, we need to generate a random email each time the test is run. We need
    to define a new step definition where the data is randomly generated each time:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we create a generic step definition and use the yet-to-be-defined `generateSampleData`
    function to provide the random data. We will define the `generateSampleData` function
    in a new file at `spec/cucumber/steps/utils/index.js` and, just as we did for
    in our backend tests, use the `chance` package to generate the random data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `chance` package:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And then define `generateSampleData` as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Making step definitions more generic
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This scenario checks the `disabled` attribute as before, but this time testing
    that it is *not* set. Therefore, update our step definition at `spec/cucumber/steps/assertions/index.js`
    to take this into account:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Clicking
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final two step sees the WebDriver clicking on the Register button and waiting
    for the server to respond. For the click step, we just need to find the `WebElement`
    instance and invoke its `click` method. Define the following step definition at
    `spec/cucumber/steps/interactions/element.js`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Waiting
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step requires us to wait for the API server to respond to our request,
    after which we should display a success message.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive, but very common, approach would be to wait a few seconds before making
    an assertion. However, this has two disadvantages:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: If the time set is too short, it can lead to flaky tests where the tests would
    pass on some instances, and fail on others.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the time set is too long, it'll lengthen the test duration. In practice,
    lengthy tests means the tests are ran less often, and less useful in providing
    feedback to the developer.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luckily, Selenium provides the `driver.wait` method, which has the following
    signature:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`condition` can be a `Condition` instance, a function, or a promise-like thenable.
    `driver.wait` will repeatedly evaluate the value of `condition` until it returns
    a truthy value. If `condition` is a promise, it will wait until the promise is
    resolved and check the resolved value to see if it is truthy. `timeout` is the
    time (in milliseconds) for which `driver.wait` will keep trying.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In `spec/cucumber/steps/assertions/index.js`, add the following step definition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We are using `until.elementLocated` as the condition, which will resolve to
    a truthy value if the element is located. We are also using `chai` and `chai-as-promised`
    as our assertion library (instead of `assert`); they provide us with the `expect` and
    `.to.be.fulfilled` syntax which makes tests involving promises much more readable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests, and the last step should fail. This is because we haven''t implemented
    the `#registration-success` element yet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Render components based on state
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to display the `#registration-success` element at the opportune
    time, we must store the results of our request in our state. Currently, inside
    our `RegistrationForm` component, we are only logging the results onto the console:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Instead, when the server responds with the new user''s ID, we store it inside
    the state under the `userId` property:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, make sure that you are setting the initial state of the `userId` to `null`
    in the class'' constructor:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, in our `render` method, check whether the `userId` state is truthy, and
    if so, display an element with an ID of `registration-success` instead of the
    form:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run our tests again, and they should, once again, pass!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Routing with React Router
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will develop the Login page. This requires us to use a different path
    for each page. For instance, the Register page can be served under the path `/register`,
    and the Login page under the `/login` path. For this, we need a *router*. On the
    server, we use Express to route the request hitting our API; for the frontend,
    we need a client-side router to do the same. In the React ecosystem, the most
    mature router is *React Router*. Let''s install it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`react-router` provides the core functionality, and `react-router-dom` allows
    us to use the React Router on the web. It''s similar to how React on the web is
    split into `react` and `react-dom`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained previously, everything in React is a component. React Router is
    no different. React Router provides a set of *navigational components* that'll
    collect data from the URL, viewport, and device information, in order to display
    the appropriate component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of components in React Router:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Router components
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route matching components
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation components
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A router component is a wrapper around our application. The router component
    is responsible for keeping a history of the routes, so that you can "Go back"
    to the previous screen. There are two router components – `<BrowserRouter>` and
    `<HashRouter>`. `<HashRouter>` is purely used for serving static files; therefore,
    we'll use the `<BrowserRouter>` component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/index.jsx`, wrap our root component (currently `<RegistrationForm />`)
    with our `BrowserRouter` component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Route matching
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, if you serve the application, nothing would have changed – we''ve
    simply wrapped our app in `BrowserRouter` so that *inside* `<BrowserRouter>` we
    can define *route matching* components. Let''s suppose we want the `<RegistrationForm>`
    component to only render when the route is `/register`, we can use a `<Route>`
    component:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `<Route>` component usually uses two props – `path` and `component`. If
    a `<Route>` component has a `path` prop that matches the current URL's path name
    (such as `window.location.pathname`), the component specified in the `component
    prop` will be rendered.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Matching is done in an *inclusive* fashion. For instance, the pathnames `/register/user`,
    `/register/admin`, and `register` will all match the path `/register`. However,
    for our use case, we want this element to show only if the path matches exactly,
    and so we are using the `exact` prop.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: After making the change, let's serve the application again.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the History API
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But when we go to `http://localhost:8200/register`, we get a `404 Not Found`
    response. From the terminal, we can see that this is because the request is handled
    by `http-server`, and not by our application:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This makes sense because `http-server` is a very simple *static* server, whereas
    we want our routing done *dynamically* on the client. Therefore, we need to a
    use a server that supports this. `pushstate-server` is a static server that also
    works with HTML5 History API. Let''s install it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, in `scripts/serve.sh`, replace the `http-server` line with the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When we run `yarn run serve` and navigate to `localhost:8200/register`, everything
    works as expected!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, update our Cucumber test feature file so that the test navigates to
    the correct page:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Navigation
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last important component classes provided by React Router are the navigational
    components, of which there are three types:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`<Link>`: This will render an anchor (`<a>`) component, for example, `<Link
    to=''/''>Home</Link>`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<NavLink>`: This is a special type of `<Link>` that will add a class to the
    element if the pathname matches the `to` prop, for example, `<NavLink to=''/profile''
    activeClassName=''active''>Profile</NavLink>`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Redirect>`: This is a component that will navigate to the `to` prop, for
    example, `<Redirect to=''/login''/>`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we can update our `#registration-success` element to include links
    to the Home and Login page (which we haven''t implemented yet!):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: TDD
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we developed the Register page, we implemented the features before writing
    the test. We did this because we didn't know how E2E tests work with React. Now
    that we do, it's time to implement a proper TDD process.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: To implement TDD, we should look at the design of the UI, identify key elements
    that our tests would need interact with, and assign each of them an unique `id`.
    These ids then form the contract between our tests and the implementation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we developed our Registration Page using TDD, we would first
    assign the inputs to the IDs `#email`, `#password`, and `#register-button`, and
    write our test code using these IDs to select the element. Then, when we implement
    the feature, we will make sure to use the same IDs as specified in the test.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: By using an `id` field, we can change the implementation details but leave the
    tests untouched. Imagine if we used a different selector, say, `form > input[name="email"]`;
    then, if we add an inner wrapper within the `<form>` element, we'd have to update
    our tests.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Design and frontend is one of the most volatile endeavors in the software development
    stage; it's wise to write tests that can withstand this volatility. It's not uncommon
    for a project to change frameworks completely. Let's say in a few years time,
    another frontend framework came along and totally revolutionizes the frontend
    landscape. By using ids to select elements, we can switch our implementation to
    this new framework without having to rewrite our tests.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Login
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow a TDD process when developing the Login page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This means starting with composing the Cucumber features file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This introduces several new steps. The `When a random user is registered` step
    directly calls the API to register a user. We will use this user to test our login
    step. It is implemented inside a new module called `spec/cucumber/steps/auth/index.js`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are using the `generateSampleData` utility function we defined earlier to
    generate details for a new user. We are also storing these details within the
    context. Next, we use the Fetch API to send a Create User request to the API.
    However, the Fetch API is an API native to the browser. Therefore, in order to
    use the Fetch API in Node, we must install a polyfill, `node-fetch`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then, for the steps `And user types in his/her email in the "#email" element`
    and `And user types in his/her password in the "#password" element`, we are using
    the details stored in the context to fill out the Login form and submit it. If
    the request is successful, an element with an ID of `login-success` is expected
    to appear.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: If you forget the endpoint and parameters for any of the endpoints for the API,
    just refer to the Swagger Documentation, which you can serve by running `yarn
    run docs:serve`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Login
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the Login form is similar to the Register form, however, it involves
    two steps instead of one. The client must first retrieve the salt from the API,
    use it to hash the password, and then send a second request to the API to log
    in. Your implementation may look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have the form component ready, let''s add it to the router. In
    React Router versions prior to v4, you can simply add a new `<Route>` component
    to `<BrowserRouter>`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: However, with React Router v4, Router components can only have one child component.
    Therefore, we must encase the `<Route>` components inside a container.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The `react-router-dom` package provides a `<Switch>` component, which we will
    use as our container. The `<Switch>` component will render only the component
    specified in the *first* matching `<Route>`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding example, if we navigate to `/register`, the `<Switch>` component
    will see that there's a match in the first `<Route>` component, and will stop
    looking for any more matches and return `<RegistrationForm>`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Over to you
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already gone over how to write E2E tests in a previous chapter, and
    we have demonstrated how to apply TDD for our Register and Login pages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Now, we pass the baton to you so that you can improve on what we've done so
    that it conforms to the design, as well as complete the rest of the app in a TDD
    manner.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to focus on making things look pretty – that's not the focus
    here. Just make sure that all of the components are there and that the user flow
    is correct.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: After you've done this, take a look at our implementation and use it to improve
    yours. Then, we'll take a look at unit tests and other types of testing that can
    be applied to front-end code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have carried over what we did for our back-end API to the
    front-end code. We used Cucumber, Gherkin and Selenium to compose UI tests that
    runs directly on a real browser. We also implemented client-side routing using
    React Router.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为后端API所做的工作应用到前端代码中。我们使用了Cucumber、Gherkin和Selenium来编写直接在真实浏览器上运行的UI测试。我们还使用了React
    Router实现了客户端路由。
- en: In the next chapter, we will round off our excursion into the front-end world
    by learning about **Redux**, a powerful state management library.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习**Redux**，一个强大的状态管理库，来结束我们对前端世界的探索之旅。
