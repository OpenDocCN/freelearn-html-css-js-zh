- en: E2E Testing in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our backend development, we vehemently followed **Test-Driven Development**
    (**TDD**) – we started development by writing E2E tests, and we wrote some implementation
    code to make these tests pass. After we implemented this feature, we added unit
    and integration tests to add more confidence to our underlying code, and also
    to help catch regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic understanding of React, we will, in this chapter,
    examine how we can implement TDD in React. Specifically, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Selenium** to automate interaction with the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **React Router** to implement **client-side routing**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it turns out, TDD on the frontend follows a similar approach involving automated
    UI testing and Unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Automated UI testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write E2E tests for our API, we first compose our request, send it,
    and assert that it returns what is expected. In other words, our E2E tests are
    mimicking how an end user would interact with our API. For the frontend, a user
    would interact with our application through the user interface (UI). Therefore,
    the equivalent to E2E testing would be automated UI testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'UI tests automate the actions that a user of the application would take. For
    example, if we want to test that an user can register, we''d write a test that:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigates to the `/register` page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types in the email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types in the password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presses the Register button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserts that the user is registered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tests can be written in Gherkin and run with Cucumber. The actual mimicking
    of the user action can automate these using Browser Automation Tools like Selenium.
    For example, when we run the test step "Press the Register button", we can instruct
    Selenium to select the button with the `id` value `register-button` and trigger
    a click event on it.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the frontend, unit testing involves two different aspects—logical units
    and component units.
  prefs: []
  type: TYPE_NORMAL
- en: Logical units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit can be a function or class that does not interact with the UI; functions
    like `validateInput` are a prime example. These logical units uses plain JavaScript
    and should work independently from the environment. Therefore, we can unit test
    them using Mocha, Chai, and Sinon in the same manner as we did for our backend
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Because logical units are the easiest to test. You should pull as much of that
    application logic as possible and test it.
  prefs: []
  type: TYPE_NORMAL
- en: Component units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit may also refer to a single component in React. For example, we can test
    that when the input has changed, that the state of the component is updated in
    an expected way; or for controlled components, that the right callback is called
    with the correct parameters
  prefs: []
  type: TYPE_NORMAL
- en: Browser testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to headless browsers—browsers that don't render to a display interface—both
    E2E and unit tests can be run from the server. However, we should also test these
    unit tests in a real browser, as there might be inconsistencies between NodeJS
    (which uses the V8 JavaScript Engine), and other browsers like Firefox (which
    uses the SpiderMonkey engine), Microsoft Edge (which uses the Chakra engine),
    and Safari (which uses the Nitro engine).
  prefs: []
  type: TYPE_NORMAL
- en: To test on real browsers and devices, we can use a different test runner called
    *Karma* ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Writing E2E tests with Gherkin, Cucumber, and Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to integrate with tools that can mimic user interaction with
    a browser. For our first test, let's test something very simple—a user will type
    in a valid email, but their password is too short. In this case, we want to assert
    that the Register button will be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like our backend E2E tests, we will be writing our test cases in Gherkin, and
    using Cucumber to run our scenarios. So, let''s add these as development dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create feature files and step definition files. For our first
    scenario, I have opted to group the features and steps in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to group them differently, as long as the features are separated from
    the step definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we haven''t written any tests yet, we can simply copy the test script
    we wrote for our API and place it in `scripts/e2e.test.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between our script and the backend test script is this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With `> /dev/null`, we are directing `stdout` into the *null device* (`/dev/null`),
    which discards anything piped into it. With `2>&1`, we are directing `stderr`
    to `stdout`, which will end up at `/dev/null` eventually. Basically, this line
    is saying "I don't care about the output of `yarn run serve`, just throw it away".
  prefs: []
  type: TYPE_NORMAL
- en: We do this because, as Selenium is navigating between different pages, the output
    from the `http-server` will be sent to `stdout` and interspersed between the test
    results, making it hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, don''t forget to install the script''s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create a `.babelrc` file to instruct `babel-register` to use
    the `env` preset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the `package.json` with the new script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to define our first feature. In `spec/cucumber/features/users/reigster/main.feature`,
    add the following specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding IDs to elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Selenium to automate the interaction with the UI elements of our
    application. However, we must provide some sort of selector for Selenium to select
    the element we want to interact with. The most precise selector we can have is
    an `id` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before we use Selenium, let''s add some ids to our elements. Open `src/components/registration-form/index.jsx` and
    add an `id` prop to each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `src/components/input/index.jsx` and `src/components/button/index.jsx`,
    pass the `id` prop into the element as an attribute. For instance, the `Button`
    component would become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to use Selenium. Selenium was written by Jason Huggins in
    2004 while working at ThoughtWorks. It is not just a single tool, but a suite
    of tools, that allows you to automate browsers across multiple platforms. We will
    be using the JavaScript binding to Selenium WebDriver, but it''s beneficial for
    us to take a quick look at each part of the tool suite:'
  prefs: []
  type: TYPE_NORMAL
- en: Selenium **Remote Control** (**RC**), also known as Selenium 1.0, is the first
    tool in the suite that allows you to automate browsers. It works by injecting
    JavaScript scripts into the browser when the page is first loaded. These scripts
    would simulate user interaction by clicking on buttons and inputting texts. Selenium
    RC has been deprecated and is superseded by Selenium WebDriver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium WebDriver, also known as Selenium 2, is the successor of Selenium RC,
    and uses the standardized WebDriver API to mimic user interaction. Most browsers
    have built-in support for the WebDriver API, and so the tool doesn't need to inject
    scripts onto the page anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium Server allows you to run your tests on a remote machine, such as when
    using Selenium Grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium Grid allows you to distribute your tests over multiple machines or
    virtual machines (VMs). These tests can then run in parallel. If your test suite
    is large, and/or you need to run tests on multiple browsers and/or operating systems,
    then test execution is likely to take a long time. By distributing these tests
    across multiple machines, you can run them in parallel and reduce the total execution
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium IDE is a Chrome extension/Firefox plugin that provides a rapid prototyping
    tool for building test scripts. Essentially, it can record actions a user takes
    on a page, and exports them as a reusable script in many languages. A developer
    can then take this script and further customize it to their own needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For testing our application, we are going to be using Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*WebDriver* is a standardized API that allows you to inspect and control a
    user agent (for example, a browser or mobile application). It was originally conceived
    in 2006 by Simon Stewart, a Google engineer at the time. It has now been defined
    by the World Wide Web Consortium (W3C), and its specification can be found at
    [https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/). The document
    is currently in the *Candidate Recommendation* stage.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of injecting JavaScript scripts into the web page and using them to
    mimic user interaction, Selenium WebDriver uses the WebDriver API, which most
    browsers support. However, you may see variation in the level of support, as well
    as how the standard is implemented, between different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: While the API is platform- and language-neutral, there have been many implementations
    of it. Specifically, we are going to be using the official JavaScript binding,
    which is available as the "selenium-webdriver" package on NPM.
  prefs: []
  type: TYPE_NORMAL
- en: Using Selenium WebDriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding the Selenium WebDriver JavaScript package to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will use `selenium-webdriver` to define our Step Definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium requires a browser to run tests on. This may be a real browser like
    Chrome, or a headless browser such a PhantomJS. You're likely familiar with the
    different real browsers, so let's spend some time taking a look at the headless
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Headless browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Headless browsers are browsers that do not render the page on an interface.
    A header browser would fetch the content of the page and then download images,
    stylesheets, scripts, and so on, and process them just like a real browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using a headless browser is that it is much faster. This is
    because the browser doesn''t have a Graphical User Interface (GUI), and thus there''s
    no need to wait for the display to actually render the output:'
  prefs: []
  type: TYPE_NORMAL
- en: PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)) uses the WebKit web
    browser engine, which is the same one that is used by Safari. It is arguably the
    most popular headless browser today. However, activity on its repository has almost
    come to a halt since the middle of 2016.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SlimerJS ([https://slimerjs.org/](https://slimerjs.org/)) uses the Gecko web
    browser engine, and SpiderMonkey as the JavaScript engine, which is the same as
    Firefox. SlimerJS is not a headless browser by default, as it uses the X11 display
    server on the test machine. However, you can integrate it with *Xvfb* (short for
    *X virtual framebuffer*), which is an in-memory display server that does not require
    a display. Since Firefox 56, you can also enable headless mode with the `--headless`
    flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZombieJS ([http://zombie.js.org/](http://zombie.js.org/)) is a faster implementation
    of a headless browser because it does not use an actual web browser engine like
    PhantomJS or SlimerJS. Instead, it uses JSDOM, which is a pure-JavaScript implementation
    of the DOM and HTML. However, also because of this, the results may not be 100%
    accurate or as realistic as testing against an actual web browser engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HtmlUnit ([http://htmlunit.sourceforge.net/](http://htmlunit.sourceforge.net/))
    is a "GUI-less browser for Java programs". It uses the Rhino JavaScript engine,
    which, like Selenium, is written in Java. From experience, HtmlUnit is the quickest
    headless browser but also the most error-prone. It's ideal for simple static pages
    that do not involve heavy JavaScript usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more headless browsers out there. Asad Dhamani has curated a
    list which you can find at [https://github.com/dhamaniasad/HeadlessBrowsers](https://github.com/dhamaniasad/HeadlessBrowsers).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, purely-headless browsers might be a thing of the past soon, as many
    "real" browsers now support Headless Mode. The following browsers have Headless
    Mode support:'
  prefs: []
  type: TYPE_NORMAL
- en: Chrome 59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox 55 (on Linux) and 56 (on macOS and Windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For those that don't, we can use Xvfb to substitute for the X11 display server,
    and run the real browser on a CI server. However, this will lose the performance
    benefit of running a headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: Browser drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium WebDriver supports many browsers, both real and headless, and each
    one requires its own driver that implements WebDriver's wire protocol for that
    specific browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For real browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: Chrome and Chrome on Android uses the ChromeDriver ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/)),
    which is maintained by the Chromium project itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox uses the geckodriver ([https://github.com/mozilla/geckodriver/](https://github.com/mozilla/geckodriver/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet Explorer uses the Internet Explorer Driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge uses Microsoft WebDriver ([https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari uses SafariDriver ([https://webkit.org/blog/6900/webdriver-support-in-safari-10/](https://webkit.org/blog/6900/webdriver-support-in-safari-10/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opera uses Opera Driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS (native, hybrid, or mobile web application) uses ios-driver ([http://ios-driver.github.io/ios-driver/](http://ios-driver.github.io/ios-driver/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android (native, hybrid, or mobile web application) uses Selendroid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For headless browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: HtmlUnit uses HtmlUnitDriver ([https://github.com/SeleniumHQ/htmlunit-driver](https://github.com/SeleniumHQ/htmlunit-driver))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhantomJS uses GhostDriver ([https://github.com/detro/ghostdriver](https://github.com/detro/ghostdriver)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup and teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can run any tests, we must tell Selenium which browser to use. Chrome
    is, by far, the most popular browser in use today, and so we will start with using
    ChromeDriver. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside `spec/cucumber/steps/index.js`, define `Before` and `After` hooks
    which are run before each scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `Before` hook, we are creating a new instance of the driver. A driver
    is akin to an user session, and a session can have many windows opened (just like
    you can have multiple tabs opened at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `webdriver.Builder` constructor function returns with an instance that
    implements the `ThenableWebDriver` interface, which allows us to specify parameters
    for the driver by chaining methods together. Some popular methods include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forBrowser`: Specify which browser to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withCapabilities`: Passes parameters to the browser command. Later on, we
    will use this to run Chrome in Headless Mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the parameters have been set, terminate the chain using the `build` method
    to return an instance of the driver.
  prefs: []
  type: TYPE_NORMAL
- en: In the `After` hook, we are disposing the driver using the `quit` method. This
    will close all windows and end the session.
  prefs: []
  type: TYPE_NORMAL
- en: We are storing the driver instance in Cucumber's World (the context) for other
    steps to use.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing step definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to implement the step definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to a page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that everything is set up, let''s implement our first step, which is `When
    user navigates to /`. Navigation can be done using the `.get` method on our driver
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This step takes the server host and port from the environment variables. `this.driver.get`
    returns a promise which is returned. Cucumber will wait for this promise to be
    resolved or rejected before moving on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Typing into input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is our next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This involves finding the element with the `id` of `email`, and then sending
    keystroke events to it. In `spec/cucumber/steps/interactions/input.js`, add the
    following step definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `driver.findElement` returns an instance of `WebElementPromise`. We are
    using the `async`/`await` syntax to avoid callback hell or heavily chained promises.
    The same step definition would work for our next step, which types in a short
    password into the `#password` input element.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting a result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As before, we need to find the element, but this time read its `disabled` attribute
    and assert that it is set to `"true"`.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML *content* attribute will always be a string, even when you'd expect
    a boolean or number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `spec/cucumber/steps/assertions/index.js`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `getAttribute` method from the `WebElement` instance to get
    the value of the `disabled` attribute. Again, this is an asynchronous operation,
    so we are using `async`/`await` syntax to keep things neat.
  prefs: []
  type: TYPE_NORMAL
- en: If you have time, it's always a good idea to read the official documentation.
    The API of all classes and methods from `selenium-webdriver` can be found at [https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/](https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/).
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the `./scripts/e2e.test.sh` script, which will build the project
    using Webpack (this may take some time). Then, a Google Chrome browser will pop
    up, and you''ll see the input fields being automatically populated with the text
    we specified. After Selenium has performed all actions required, the `driver.quit()`
    method call in our After hook will close the browser, and the results will be
    displayed in our terminal.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Adding multiple testing browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest benefit of using Selenium is that you can use the same tests to
    test multiple browsers. If we are interested in just a single browser, like Chrome,
    we'd be better off using Puppeteer. So, let's add Firefox to our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firefox, like Chrome, requires a driver to work. Firefox''s driver is `geckodriver`,
    which uses the *Marionette* proxy to send instructions to Firefox (Marionette
    is similar to Chrome''s DevTools Protocol):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need to do is change the `forBrowser` call to use `"firefox"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we run our tests again, Firefox will be used instead of Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, instead of hard-coding the browser into our code, let''s update our
    scripts to allow us to specify the browsers we want to test. We can do this by
    passing arguments into the shell script. For instance, if we execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `scripts/e2e.test.sh`, we can access the arguments using `$1`
    for the first argument (`chrome`), `$2` for `firefox`, and so on. Alternatively,
    we can use the special argument `"$@"`, which is an array-like construct that
    contains all arguments. In `scripts/e2e.test.sh`, change the test block to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will loop through our list of browsers, `export` it in the `TEST_BROWSER`
    variable, and run our tests. Then, in the `forBrowser` call inside `spec/cucumber/steps/index.js`,
    pass in the browser name from `process.env` instead of hard-coding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try running it with `$ yarn run test:e2e -- chrome firefox`, and you should
    see our tests being run first on Chrome, and then Firefox, and then the results
    neatly displayed in a standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we should define NPM scripts to make it obvious to other developers
    what operations we can run. By adding it as an NPM script, all the user needs
    to do is look at the `package.json`, and won''t have to study the shell script
    to see how it works. So, in the `scripts` section of the `package.json`, change
    our `test:e2e` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now successfully written our first test and run it. Next, let''s make
    our scenario more generic by covering all the invalid cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Running our backend API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to cater for the happy path scenario where a user fills in valid
    details and the Register button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will write a test that says "When a user submits valid details, after
    the server response is received, the UI will display a success message". This
    feature has not been implemented yet, which means this would be our first step
    toward TDD in frontend!
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic string substitution with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one minor improvement we must make before we can do E2E testing with
    the API backend. At the moment, we are hard-coding the URL for our production
    API endpoint (`localhost:8080`), even though during the test, the testing URL
    (`localhost:8888`) will be used. Therefore, we need to replace this with a placeholder
    that we can override during build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in `src/components/registration-form/index.jsx`, replace the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using `%%` to mark our placeholder because it's a relatively uncommon
    sequence of characters. You may choose any placeholder syntax you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add a new loader to replace this placeholder at build time.
    `string-replace-loader` fits the bill perfectly. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `.env` and `.env.example`, add the details of the API host and port
    for different environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the plugin inside `webpack.config.js`. We want the loader to transform
    all `.js` and `.jsx` files, and so we can use the same rules that we used for
    `babel-loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At the top, we are checking the `NODE_ENV` environment variable and using it
    to determine which port the API is using. Then, in the options for our loader,
    we are instructing it to do a global RegEx search for the string, and replacing
    it with the dynamically-derived host and port.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the API from a submodule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run our tests, we want to make sure that our backend API is running
    using the `NODE_ENV` environment variable set to `test`. At the moment, we are
    doing this manually. However, it''s more ideal to add it as part of our test script.
    Just as we did for our Swagger UI, we can use Git submodules to include the Hobnob
    API repository in the client''s repository without duplicating the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make life easier for later, add the following NPM scripts to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`api:init` will download the Hobnob API repository using the commit hash that''s
    been stored. `api:install` uses `--cwd` to change directory into the `api` directory
    before running `yarn install`. `api:serve` first runs the `build` script from
    our API repository, loads the environment variables, and then runs the API server.
    `api:update` will download but also update the API repository to the latest commit
    in the same branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, run the NPM scripts inside `scripts/e2e.test.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Defining the happy scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin defining our happy scenario by writing the feature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generating random data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this scenario, we cannot hard-code a single email to test because it may
    lead to a `409 Conflict` error because an account with that email already exists.
    Therefore, we need to generate a random email each time the test is run. We need
    to define a new step definition where the data is randomly generated each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a generic step definition and use the yet-to-be-defined `generateSampleData`
    function to provide the random data. We will define the `generateSampleData` function
    in a new file at `spec/cucumber/steps/utils/index.js` and, just as we did for
    in our backend tests, use the `chance` package to generate the random data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `chance` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And then define `generateSampleData` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Making step definitions more generic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This scenario checks the `disabled` attribute as before, but this time testing
    that it is *not* set. Therefore, update our step definition at `spec/cucumber/steps/assertions/index.js`
    to take this into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Clicking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final two step sees the WebDriver clicking on the Register button and waiting
    for the server to respond. For the click step, we just need to find the `WebElement`
    instance and invoke its `click` method. Define the following step definition at
    `spec/cucumber/steps/interactions/element.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Waiting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step requires us to wait for the API server to respond to our request,
    after which we should display a success message.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive, but very common, approach would be to wait a few seconds before making
    an assertion. However, this has two disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: If the time set is too short, it can lead to flaky tests where the tests would
    pass on some instances, and fail on others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the time set is too long, it'll lengthen the test duration. In practice,
    lengthy tests means the tests are ran less often, and less useful in providing
    feedback to the developer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luckily, Selenium provides the `driver.wait` method, which has the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`condition` can be a `Condition` instance, a function, or a promise-like thenable.
    `driver.wait` will repeatedly evaluate the value of `condition` until it returns
    a truthy value. If `condition` is a promise, it will wait until the promise is
    resolved and check the resolved value to see if it is truthy. `timeout` is the
    time (in milliseconds) for which `driver.wait` will keep trying.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `spec/cucumber/steps/assertions/index.js`, add the following step definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We are using `until.elementLocated` as the condition, which will resolve to
    a truthy value if the element is located. We are also using `chai` and `chai-as-promised`
    as our assertion library (instead of `assert`); they provide us with the `expect` and
    `.to.be.fulfilled` syntax which makes tests involving promises much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests, and the last step should fail. This is because we haven''t implemented
    the `#registration-success` element yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Render components based on state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to display the `#registration-success` element at the opportune
    time, we must store the results of our request in our state. Currently, inside
    our `RegistrationForm` component, we are only logging the results onto the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, when the server responds with the new user''s ID, we store it inside
    the state under the `userId` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, make sure that you are setting the initial state of the `userId` to `null`
    in the class'' constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `render` method, check whether the `userId` state is truthy, and
    if so, display an element with an ID of `registration-success` instead of the
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Run our tests again, and they should, once again, pass!
  prefs: []
  type: TYPE_NORMAL
- en: Routing with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will develop the Login page. This requires us to use a different path
    for each page. For instance, the Register page can be served under the path `/register`,
    and the Login page under the `/login` path. For this, we need a *router*. On the
    server, we use Express to route the request hitting our API; for the frontend,
    we need a client-side router to do the same. In the React ecosystem, the most
    mature router is *React Router*. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`react-router` provides the core functionality, and `react-router-dom` allows
    us to use the React Router on the web. It''s similar to how React on the web is
    split into `react` and `react-dom`.'
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained previously, everything in React is a component. React Router is
    no different. React Router provides a set of *navigational components* that'll
    collect data from the URL, viewport, and device information, in order to display
    the appropriate component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of components in React Router:'
  prefs: []
  type: TYPE_NORMAL
- en: Router components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route matching components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A router component is a wrapper around our application. The router component
    is responsible for keeping a history of the routes, so that you can "Go back"
    to the previous screen. There are two router components – `<BrowserRouter>` and
    `<HashRouter>`. `<HashRouter>` is purely used for serving static files; therefore,
    we'll use the `<BrowserRouter>` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/index.jsx`, wrap our root component (currently `<RegistrationForm />`)
    with our `BrowserRouter` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Route matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, if you serve the application, nothing would have changed – we''ve
    simply wrapped our app in `BrowserRouter` so that *inside* `<BrowserRouter>` we
    can define *route matching* components. Let''s suppose we want the `<RegistrationForm>`
    component to only render when the route is `/register`, we can use a `<Route>`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `<Route>` component usually uses two props – `path` and `component`. If
    a `<Route>` component has a `path` prop that matches the current URL's path name
    (such as `window.location.pathname`), the component specified in the `component
    prop` will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Matching is done in an *inclusive* fashion. For instance, the pathnames `/register/user`,
    `/register/admin`, and `register` will all match the path `/register`. However,
    for our use case, we want this element to show only if the path matches exactly,
    and so we are using the `exact` prop.
  prefs: []
  type: TYPE_NORMAL
- en: After making the change, let's serve the application again.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the History API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But when we go to `http://localhost:8200/register`, we get a `404 Not Found`
    response. From the terminal, we can see that this is because the request is handled
    by `http-server`, and not by our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sense because `http-server` is a very simple *static* server, whereas
    we want our routing done *dynamically* on the client. Therefore, we need to a
    use a server that supports this. `pushstate-server` is a static server that also
    works with HTML5 History API. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `scripts/serve.sh`, replace the `http-server` line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When we run `yarn run serve` and navigate to `localhost:8200/register`, everything
    works as expected!
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, update our Cucumber test feature file so that the test navigates to
    the correct page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last important component classes provided by React Router are the navigational
    components, of which there are three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Link>`: This will render an anchor (`<a>`) component, for example, `<Link
    to=''/''>Home</Link>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<NavLink>`: This is a special type of `<Link>` that will add a class to the
    element if the pathname matches the `to` prop, for example, `<NavLink to=''/profile''
    activeClassName=''active''>Profile</NavLink>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Redirect>`: This is a component that will navigate to the `to` prop, for
    example, `<Redirect to=''/login''/>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we can update our `#registration-success` element to include links
    to the Home and Login page (which we haven''t implemented yet!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we developed the Register page, we implemented the features before writing
    the test. We did this because we didn't know how E2E tests work with React. Now
    that we do, it's time to implement a proper TDD process.
  prefs: []
  type: TYPE_NORMAL
- en: To implement TDD, we should look at the design of the UI, identify key elements
    that our tests would need interact with, and assign each of them an unique `id`.
    These ids then form the contract between our tests and the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we developed our Registration Page using TDD, we would first
    assign the inputs to the IDs `#email`, `#password`, and `#register-button`, and
    write our test code using these IDs to select the element. Then, when we implement
    the feature, we will make sure to use the same IDs as specified in the test.
  prefs: []
  type: TYPE_NORMAL
- en: By using an `id` field, we can change the implementation details but leave the
    tests untouched. Imagine if we used a different selector, say, `form > input[name="email"]`;
    then, if we add an inner wrapper within the `<form>` element, we'd have to update
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Design and frontend is one of the most volatile endeavors in the software development
    stage; it's wise to write tests that can withstand this volatility. It's not uncommon
    for a project to change frameworks completely. Let's say in a few years time,
    another frontend framework came along and totally revolutionizes the frontend
    landscape. By using ids to select elements, we can switch our implementation to
    this new framework without having to rewrite our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow a TDD process when developing the Login page.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This means starting with composing the Cucumber features file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This introduces several new steps. The `When a random user is registered` step
    directly calls the API to register a user. We will use this user to test our login
    step. It is implemented inside a new module called `spec/cucumber/steps/auth/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `generateSampleData` utility function we defined earlier to
    generate details for a new user. We are also storing these details within the
    context. Next, we use the Fetch API to send a Create User request to the API.
    However, the Fetch API is an API native to the browser. Therefore, in order to
    use the Fetch API in Node, we must install a polyfill, `node-fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Then, for the steps `And user types in his/her email in the "#email" element`
    and `And user types in his/her password in the "#password" element`, we are using
    the details stored in the context to fill out the Login form and submit it. If
    the request is successful, an element with an ID of `login-success` is expected
    to appear.
  prefs: []
  type: TYPE_NORMAL
- en: If you forget the endpoint and parameters for any of the endpoints for the API,
    just refer to the Swagger Documentation, which you can serve by running `yarn
    run docs:serve`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the Login form is similar to the Register form, however, it involves
    two steps instead of one. The client must first retrieve the salt from the API,
    use it to hash the password, and then send a second request to the API to log
    in. Your implementation may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the form component ready, let''s add it to the router. In
    React Router versions prior to v4, you can simply add a new `<Route>` component
    to `<BrowserRouter>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: However, with React Router v4, Router components can only have one child component.
    Therefore, we must encase the `<Route>` components inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `react-router-dom` package provides a `<Switch>` component, which we will
    use as our container. The `<Switch>` component will render only the component
    specified in the *first* matching `<Route>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if we navigate to `/register`, the `<Switch>` component
    will see that there's a match in the first `<Route>` component, and will stop
    looking for any more matches and return `<RegistrationForm>`.
  prefs: []
  type: TYPE_NORMAL
- en: Over to you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already gone over how to write E2E tests in a previous chapter, and
    we have demonstrated how to apply TDD for our Register and Login pages.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we pass the baton to you so that you can improve on what we've done so
    that it conforms to the design, as well as complete the rest of the app in a TDD
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to focus on making things look pretty – that's not the focus
    here. Just make sure that all of the components are there and that the user flow
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: After you've done this, take a look at our implementation and use it to improve
    yours. Then, we'll take a look at unit tests and other types of testing that can
    be applied to front-end code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have carried over what we did for our back-end API to the
    front-end code. We used Cucumber, Gherkin and Selenium to compose UI tests that
    runs directly on a real browser. We also implemented client-side routing using
    React Router.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will round off our excursion into the front-end world
    by learning about **Redux**, a powerful state management library.
  prefs: []
  type: TYPE_NORMAL
