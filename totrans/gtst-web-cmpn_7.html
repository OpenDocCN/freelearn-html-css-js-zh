<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Web Components using Polymer and Stencil</h1>
                </header>
            
            <article>
                
<p class="mce-root">Up until now, we have built components using vanilla JavaScript with no dependencies. But sometimes, companies make a decision to use libraries that can help ease the workflow. In this chapter, we will look into two different libraries: Polymer and Stencil. In the background, these two libraries use Web Components, but both of them come with their own features. Let's dive into these libraries. </p>
<p>In this chapter, we're going to cover the following topics:</p>
<ul>
<li class="h1">Polymer</li>
<li class="h1">Stencil</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Polymer</h1>
                </header>
            
            <article>
                
<p>Polymer is a library that lets you create custom elements in a really easy way. It comes with a set of features that can be used to create shadow DOM, add events, and use attributes and properties just like we have learned in previous chapters. </p>
<p>You can find the Polymer project at the following URL: <a href="https://polymer-library.polymer-project.org/" target="_blank">https://Polymer-library.Polymer-project.org/</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A major difference between the vanilla Web Components and Polymer is that Polymer comes with its own data system. That means you can make various computations and manipulations to the component based on this data. You can observe attribute and property changes, and you can even do two-way data binding, something that is missing from vanilla Web Components. The presence of these features helps with a lot of use cases, and helps with making the life of a developer easier. </p>
<p>We will now take a look at how to use Polymer in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello World in Polymer</h1>
                </header>
            
            <article>
                
<p class="mce-root">Unlike vanilla Web Components, Polymer is a library that needs to be installed. But before we even have the library installed, we will be needing Polymer's <strong>Command Line Interface</strong> (<strong>CLI</strong>) that come with its own server and testing framework. We can install it using the following command:</p>
<pre><strong>npm install -g Polymer-cli</strong></pre>
<p>And, once installed, you can check if it is installed by using the following command:</p>
<pre class="p1"><strong><span class="s1">Polymer --version</span></strong></pre>
<p>Now that Polymer is installed, let's try to create a <kbd>&lt;hello-world&gt;</kbd> component using this library. Let's create a folder called <kbd>HelloWorld</kbd> and then create a file called <kbd>index.html</kbd>. The contents of this file can be very basic, like the following:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/> &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;Hello World&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;p&gt;You stuff goes here.&lt;/p&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>In order to run this file, instead of using <kbd>SimpleHTTPServer</kbd>, we will use a server that is provided by <kbd>Polymer-cli</kbd> itself. We can run the server by using the following command:</p>
<pre><strong>Polymer serve</strong></pre>
<p>Once you run this command, you should get a console output this in the Terminal:</p>
<pre class="p1"><strong><span class="s1">info</span><span class="s2">:<span class="Apple-tab-span"> </span>Files in this directory are available under the following URLs<br/> </span><span class="s2">applications: http://127.0.0.1:8081<br/> </span><span class="s2">reusable components: http://127.0.0.1:8081/components/Polymer/</span></strong></pre>
<p class="p2">This shows that the server is running, and you can see the <kbd>index.html</kbd> file running on <kbd>http://127.0.0.1:8081/</kbd>.</p>
<p>Now that our server is running and Polymer is installed, let's start writing our <kbd>&lt;hello-world&gt;</kbd> Polymer component.</p>
<p>Since we are going to use the <kbd>Polymer</kbd> library, let's install the library for this project:</p>
<pre><strong><span>npm i </span><span>@Polymer/Polymer</span></strong></pre>
<p>Also, let's create a file called <kbd>hello-world.js</kbd>. The contents of this file are as follows:</p>
<pre>import { PolymerElement, html } from '@Polymer/Polymer/Polymer-element.js';<br/><br/>class HelloWorld extends PolymerElement {<br/>    ...<br/>    ...<br/>    ...<br/>}<br/><br/>customElements.define('hello-world', HelloWorld);</pre>
<p>Here, we are simply importing <kbd>Polymer</kbd> library that we just installed using <kbd>npm</kbd> command. Also, instead of using <kbd>HTMLElement</kbd>, we are using <kbd>PolymerElement</kbd>. And then, we are registering the class as a custom element. </p>
<p>The class definition will be a little bit different than vanilla Web Components:</p>
<pre>class HelloWorld extends PolymerElement {<br/>  constructor() {<br/>    super();<br/>  }<br/><br/>  static get template() {<br/>    return html`<br/>      &lt;p&gt;Hello World&lt;/p&gt;<br/>    `;<br/>  }<br/>}</pre>
<p>Here, we have the <kbd>constructor()</kbd> method, just like vanilla Web Components, but the <kbd>super()</kbd> method call doesn't have <kbd>props</kbd> in it. Also, we are not manually calling the <kbd>render()</kbd> method. Instead, the code is rendered automatically from the <kbd>template()</kbd> property. </p>
<p>We also need to keep in mind that unlike vanilla Web Components, we are not manually creating the shadow DOM for a Polymer element. Here, we use the <kbd>html</kbd> object from the <kbd>Polymer</kbd> library to stamp the <kbd>html</kbd> to the element's shadow DOM. </p>
<p>Now that the component is created, we can use it in our <kbd>index.html</kbd> file in the following way:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;Hello World&lt;/title&gt;<br/>    &lt;script type="module" src="hello-world.js"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;hello-world&gt;&lt;/hello-world&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Here, we are simply importing the <kbd>hello-world.js</kbd> file, and then using the <kbd>&lt;hello-world&gt;</kbd> element directly. </p>
<p>As you can see, the <kbd>Polymer</kbd> library helps a lot when it comes to saving the lines of code. And, with this example, you now know how to create a Polymer element. You can also try creating other elements that we have studied in the previous chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested elements in Polymer</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapters, we looked at how different Web Components are used inside other Web Components to create complex and nested components. This methodology is not just limited to vanilla Web Components. We can use it inside Polymer components as well.</p>
<p>Let's say we have another <kbd>PolymerElement</kbd> that looks like this:</p>
<pre>// second-element.js<br/><br/>import { PolymerElement, html } from '@Polymer/Polymer/Polymer-element.js';<br/><br/>class SecondElement extends PolymerElement {<br/>  constructor() {<br/>    super();<br/>  }<br/>  static get template() {<br/>    return html`<br/>      &lt;style&gt;<br/>        p {<br/>          color: red;<br/>        }<br/>      &lt;/style&gt;<br/>      &lt;p&gt;This is the second element&lt;/p&gt;<br/>    `;<br/>  }<br/>}<br/><br/>customElements.define('second-element', SecondElement);</pre>
<p>As you can see, it is not a complex element. In fact, it looks a lot like the <kbd>&lt;hello-world&gt;</kbd> element. Now, let's say we want to include this <kbd>&lt;second-element&gt;</kbd> in the <kbd>&lt;hello-world&gt;</kbd> element. We can do it by changing the <kbd>&lt;hello-world&gt;</kbd> code in the following way:</p>
<pre>import { PolymerElement, html } from '@Polymer/Polymer/Polymer-element.js';<br/>import './second-element.js';<br/><br/>class HelloWorld extends PolymerElement {<br/>  constructor() {<br/>    super();<br/>  }<br/>  static get template() {<br/>    return html`<br/>      &lt;p&gt;Hello World&lt;/p&gt;<br/>      &lt;second-element&gt;&lt;/second-element&gt;<br/>    `;<br/>  }<br/>}<br/><br/>customElements.define('hello-world', HelloWorld);</pre>
<p>Here, you can see that we are importing the code from the <kbd>./second-element.js</kbd> file. And we are simply using it with the help of the <kbd>&lt;second-element&gt;</kbd> HTML code. It is that simple.</p>
<p>Also, if you notice the definition of the <kbd>&lt;second-element&gt;</kbd> class, you can see that we have used a style tag as well. We can make use of all the styles that we have studied in the previous chapters.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attributes and properties in Polymer</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapters, we saw how attributes and properties help make our Web Components better. They help with passing data, as well as keep track of the element's state. Similarly, we can do the same for elements built using Polymer as well. </p>
<p>Let's take a look at how properties work in Polymer. Let's say we have an element that shows the text <span class="packt_screen">Hello, Prateek</span>, where the string <kbd>Prateek</kbd> is a variable. The code would look something like this:</p>
<pre>import { PolymerElement, html } from '@Polymer/Polymer/Polymer-element.js';<br/><br/>class HelloString extends PolymerElement {<br/>  constructor() {<br/>    super();<br/>  }<br/><br/>  static get properties() {<br/>    return {<br/>      name: {<br/>        type: String,<br/>        value: 'No Name Provided Yet'<br/>      }<br/>    };<br/>  }<br/><br/>  static get template() {<br/>    return html`<br/>      &lt;p&gt;Hello, [[name]]&lt;/p&gt;<br/>    `;<br/>  }<br/>}<br/><br/>customElements.define('hello-string', HelloString);</pre>
<p>Here, the only extra thing that we are adding is the <kbd>properties</kbd> getter function. The name of the property is <kbd>name</kbd>, and the default value is <kbd>'No Name Provided Yet'</kbd>. When you are using the element, you can either simply call the element, as follows:</p>
<pre>&lt;hello-string&gt;&lt;/hello-string&gt;</pre>
<p>This would display the text <span class="packt_screen">Hello, No Name Provided Yet</span>. Or, you can provide the name by adding an attribute like this:</p>
<pre>&lt;hello-string name="Prateek"&gt;&lt;/hello-string&gt;</pre>
<p class="mce-root"/>
<p>This would display the text <span class="packt_screen">Hello, Prateek</span>. You can add multiple properties as well. For example, you can add <kbd>lastname</kbd> or <kbd>age</kbd> as properties as well. </p>
<p>But what if you have nested components and this text is a variable coming from a parent component? Let's take a look at what this code <span>would</span> look like:</p>
<pre>import { PolymerElement, html } from '@Polymer/Polymer/Polymer-element.js';<br/>import './hello-string.js';<br/><br/>class StudentName extends PolymerElement {<br/>  constructor() {<br/>    super();<br/>  }<br/><br/>  static get properties() {<br/>    return {<br/>      name: {<br/>        type: String,<br/>        value: 'John Doe'<br/>      }<br/>    };<br/>  }<br/><br/>  static get template() {<br/>    return html`<br/>      &lt;hello-string name="[[name]]"&gt;&lt;/hello-string&gt;<br/>    `;<br/>  }<br/>}<br/><br/>customElements.define('student-name', StudentName);</pre>
<p>Here, we are passing the <kbd>name</kbd> property as a variable to the attribute in the <kbd>&lt;hello-string&gt;</kbd> element. This whole process is called <strong>data-bindin</strong><strong>g</strong>. If you would like to know more about data-binding in Polymer, you can visit the following link: <a href="https://polymer-library.polymer-project.org/3.0/docs/devguide/data-binding" target="_blank">https://Polymer-library.Polymer-project.org/3.0/docs/devguide/data-binding</a>.</p>
<p>With the help of these concepts, you should be able to create Polymer elements with ease.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stencil</h1>
                </header>
            
            <article>
                
<p class="mce-root">Stencil is a compiler for Web Components. It uses TypeScript and JSX to create Web Components. It even comes with a lot of features that are missing in the vanilla Web Components that can be used to make good single-page web apps. </p>
<p class="mce-root"/>
<p>Let's get a better idea of what Stencil can do with the help of a <kbd>&lt;hello-world&gt;</kbd> component. This component required a little understanding of TypeScript as well as JSX. If at any point in time you would like to take a look at the docs, you can find them here:</p>
<ul>
<li><strong>TypeScript</strong>: <a href="https://www.typescriptlang.org/" target="_blank">https://www.typescriptlang.org/</a>.</li>
<li><strong>JSX</strong>: <a href="https://reactjs.org/docs/introducing-jsx.html" target="_blank">https://reactjs.org/docs/introducing-jsx.html</a>.</li>
</ul>
<p>I will try to keep my code as simple as possible so that you don't have to look at the docs. Now that we have that out of the way, let's create a hello-world component using Stencil.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Hello World Stencil component</h1>
                </header>
            
            <article>
                
<p>Stencil comes with a lot of features to build components. Let's first set up our folder to write a component. You can do so by typing the following command in the Terminal:</p>
<pre class="p1"><strong><span class="s1">npm init stencil</span></strong></pre>
<p>You will be shown a bunch of options, from which you can select the component. On selecting the component option, feel free to enter a name for the project. I chose <kbd>stenciljs-app</kbd>. And this would print out an output that looks something like this:</p>
<pre><strong><img src="assets/eb068eaf-cd94-4c49-8498-674fbe55ad6d.png"/> Pick a starter › component</strong><br/><strong><img src="assets/eb068eaf-cd94-4c49-8498-674fbe55ad6d.png"/> Project name › <span>stenciljs-app</span></strong><br/><strong><img src="assets/eb068eaf-cd94-4c49-8498-674fbe55ad6d.png"/> All setup in 8.19 s</strong><br/><br/><strong>  Next steps:</strong><br/><strong>   $ cd <span>stenciljs-app</span></strong><br/><strong>   $ npm start</strong><br/><br/><strong>  Further reading:</strong><br/><strong>   - https://github.com/ionic-team/stencil-component-starter</strong></pre>
<p>This will create a starter project with a default component in it. You can run the project by typing the following command:</p>
<pre><strong>cd <span>stenciljs-app</span></strong><br/><strong>npm start</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This will run the <kbd><span>stenciljs-app</span></kbd> project on <kbd>localhost:3333</kbd> in the browser. It will also show the default component, <kbd>&lt;my-component&gt;</kbd>, as a part of the output. This is technically the <kbd>&lt;hello-world&gt;</kbd> component provided by default inside our project. But we will create our own <kbd>&lt;hello-world&gt;</kbd> component from scratch.</p>
<p>In order to create our <kbd>&lt;hello-world&gt;</kbd> component, we need to first complete some pre-requisites. These are as follows:</p>
<ol>
<li>Create a folder called <kbd>hello-world</kbd> inside the <kbd>src/components</kbd> folder.</li>
<li>Create a file called <kbd>hello-world.tsx</kbd> inside this <kbd>hello-world</kbd> folder. We are using the <kbd>.tsx</kbd> extension because it is a TypeScript file. Stencil will compile this file to a <kbd>.js</kbd> file. We do not have to worry about it.</li>
<li>Create another file called <kbd>hello-world.css</kbd> inside the <kbd>hello-world</kbd> folder. This is where we will be writing the CSS for this component.</li>
</ol>
<p>Now that we have the setup complete for the <kbd>&lt;hello-world&gt;</kbd> component, let's start writing the code for it. This is what <kbd>hello-world.tsx</kbd> looks like:</p>
<pre>import { Component, h } from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'hello-world',<br/>  styleUrl: 'hello-world.css',<br/>  shadow: true<br/>})<br/><br/>export class HelloWorld {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;Hello World&lt;/div&gt;<br/>    );<br/>  }<br/>}</pre>
<p>In the first line, we are importing the <kbd>Component</kbd> and <kbd>h</kbd> objects from the <kbd>stencil</kbd> library. When we talk about technical jargon, we will be calling this <kbd>@Component</kbd> as <kbd>@Component</kbd> decorator. As we can see, we are simply stating the tag for the component, the CSS it needs to use for styling, and whether the component needs to render in a shadow DOM or not. Inside the <kbd>HelloWorld</kbd> class, we are simply returning the JSX for this component. If you are from the React background, then it should be pretty straightforward. But if you are new to JSX, for the sake of simplicity, you can think of it as a way to write HTML inside JavaScript.</p>
<p> </p>
<p> </p>
<p><span>So, we have now created our first Stencil component. Now, to</span> see <span>it on the web page, you can simply add the</span> <kbd>&lt;hello-world&gt;</kbd> <span>tag in the</span> <kbd>index.html</kbd> <span>file inside the</span> <kbd>src</kbd> <span>directory. Stencil will pick it up automatically, create its include, and compile it for you. You just have to refresh the page.</span></p>
<p>Now that we know how to create a Stencil component, let's dive into the next section where we create nested Stencil Components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested Stencil components</h1>
                </header>
            
            <article>
                
<p>In the last section, we looked into the <kbd>@Component</kbd> decorator and how it helps create a Stencil component. In this section, we will use one more decorator called the <kbd>@Prop</kbd> decorator to declare the variables that will act as properties which can be passed onto other components. </p>
<p>Let's create an element that shows us a list of students, called <kbd>&lt;student-list&gt;</kbd>. In Stencil, it would look something like this:</p>
<pre>import { Component, h } from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'student-list',<br/>  styleUrl: 'student-list.css',<br/>  shadow: true<br/>})<br/><br/>export class StudentList {<br/>  render() {<br/>    return &lt;div&gt;<br/>      &lt;div&gt;Student List is as follows: &lt;/div&gt;<br/>      &lt;student-name class="student-list__student" first="John" last="Doe"&gt;&lt;/student-name&gt;<br/>      &lt;student-name class="student-list__student" first="Tom" last="Hanks"&gt;&lt;/student-name&gt;<br/>    &lt;/div&gt;;<br/>  }<br/>}</pre>
<p>Here, we are doing the same thing as we have done in the <kbd>&lt;hello-world&gt;</kbd> component. We are simply importing the <kbd>stencil</kbd> library, then setting the name of the component and CSS styles in the <kbd>@Component</kbd> decorator. And, in the class, we have a component called <kbd>&lt;student-name&gt;</kbd> that has the first and last name as attributes.</p>
<p>Let's take a look at the definition of this <kbd>&lt;student-name&gt;</kbd> component:</p>
<pre>import { Component, Prop, h } from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'student-name',<br/>  styleUrl: 'student-name.css',<br/>  shadow: true<br/>})<br/><br/>export class StudentName {<br/>  @Prop({reflectToAttr: true}) first: string;<br/>  @Prop() last: string;<br/><br/>  private getFullName(): string {<br/>    return `${this.first} ${this.last}`;<br/>  }<br/><br/>  render() {<br/>    return &lt;div&gt;Student Name: {this.getFullName()}&lt;/div&gt;;<br/>  }<br/>}</pre>
<p>Here, if we look inside the <kbd>StudentName</kbd> class, we can see that we are using the <kbd>@Prop</kbd> decorator. With the help of this <kbd>@Prop</kbd> decorator, we are defining two properties: <kbd>first</kbd> and <kbd>last</kbd>. The <kbd>first</kbd> property also has <kbd>reflectToAttr</kbd> set to <kbd>true</kbd>, which means that this property can be seen as an attribute when it gets called inside the <kbd>&lt;student-list&gt;</kbd> component:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/da615635-b5bb-4223-a360-b511f4424783.png" style="width:47.08em;height:11.83em;"/></p>
<p>Here, we can see the attribute first in the shadow DOM for this component. But since we did not set <kbd>reflectToAttr</kbd> to <kbd>true</kbd> for the <kbd>last</kbd> property, it doesn't get reflected in the attribute.</p>
<p>Also, if you notice the definition of the <kbd>&lt;student-list&gt;</kbd> component, we did not import the <kbd>&lt;student-name&gt;</kbd> component. We simply started using the element. Stencil is smart enough to pick up these changes and auto-include them in the files. This way, we can create nested elements without worrying about the imports.</p>
<p>Now that we know how to create nested components using Stencil, let's look at one of the ways to achieve performance on to the web page we are trying to create.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-rendering for Stencil components</h1>
                </header>
            
            <article>
                
<p>When we talk about rending a single page web app, we are basically sending all the resources onto the page and then letting the client do all the computations to build the page. This is a computational-heavy process, which may lead to longer times to first meaningful paint on the site. </p>
<p>To solve this problem, Stencil comes with pre-rendering on by default. Pre-rendering lets the server generate static HTML, CSS, and JavaScript files at build time, and can then be hydrated with the data for that page. This lets users see the page faster, lets the search engine crawlers browse the site for SEO faster, and lets the user see the page even when the JavaScript is disabled on the client side. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to create Polymer and Stencil components. We looked into how these components can be nested to form more complex elements. We also looked into how attributes and properties can be passed into child components in both Polymer and Stencil components. </p>
<p>We also looked into the pre-rendering feature of Stencil, and how it can be used to make a site perform better. </p>
<p>In the next chapter, we will look into how vanilla Web Components can be used in various other libraries and frameworks.</p>


            </article>

            
        </section>
    </body></html>