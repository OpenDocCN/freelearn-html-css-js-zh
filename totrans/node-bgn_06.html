<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-164" class="chapter-number"><a id="_idTextAnchor171"/>6</h1>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor172"/> External Modules and npm</h1>
			<p><strong class="bold">Node Package Manager</strong> (<strong class="bold">npm</strong>) is one of the most popular software registries around the world. There are more than two million packages available for us to use. In this chapter, we will explore how to use npm commands and NPX, as well as what the isomorphic libraries are and how to choose the correct dependencies for our project, so we can minimize the risks. As a final practice, you will publish a package <span class="No-Break">to npm.</span></p>
			<p>In this chapter, we will explore how to use external modules in our projects. This will allow us to reuse code from other developers and save time and effort. We will explore together the vast ecosystem of Node.js modules, and we will learn how to choose the correct modules for <span class="No-Break">our projects.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Managing the application <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">package.json</strong></span></li>
				<li>Choosing the correct dependencies for <span class="No-Break">your project</span></li>
				<li><span class="No-Break">Installing dependencies</span></li>
				<li><span class="No-Break">Removing dependencies</span></li>
				<li><span class="No-Break">Understanding </span><span class="No-Break"><strong class="source-inline">package-lock.json</strong></span></li>
				<li>Managing <span class="No-Break">dependencies versions</span></li>
				<li>Building <span class="No-Break">Isomorphic JavaScript</span></li>
				<li>Using <span class="No-Break">npm scripts</span></li>
				<li>Executing packages directly <span class="No-Break">with NPX</span></li>
				<li><span class="No-Break">npm alternatives</span></li>
				<li>Publishing your <span class="No-Break">first package</span></li>
			</ul>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor173"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/B-7vZyAfi2U"><span class="No-Break">https://youtu.be/B-7vZyAfi2U</span></a></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor174"/>Managing the application with package.json</h1>
			<p>When you install Node.js, npm is installed as well. npm is the package manager for Node.js. It is used to install, update, and remove packages from our projects. It also allows us to publish our <span class="No-Break">own packages.</span></p>
			<p>A package is a <a id="_idIndexMarker324"/>JavaScript library that we can use in our applications to speed up the process of developing our own projects. There are many different types of packages, from very simple ones such as a function that can tell us whether a number is odd or not (<a href="https://www.npmjs.com/package/is-odd">https://www.npmjs.com/package/is-odd</a>), to very complex libraries that can help us to use Firebase (<a href="https://firebase.google.com/?hl=es">https://firebase.google.com/?hl=es</a>) to store information from our users (<a href="https://www.npmjs.com/package/firebase">https://www.npmjs.com/package/firebase</a>). It is quite common to use many libraries in a single project, and some companies create their own private libraries to distribute utilities, configurations, and many more things across their many <span class="No-Break">code bases.</span></p>
			<p>The <strong class="source-inline">package.json</strong> file is the manifest file for our project. It contains the metadata of our project, such as the name, version, description, author, and license. It also contains the dependencies of our project, both the runtime dependencies and the development dependencies, and it contains the scripts that we can run <span class="No-Break">with npm.</span></p>
			<p>In order to create a <strong class="source-inline">package.json</strong> file, we can run the <span class="No-Break">following command:</span></p>
			<pre class="console">
npm init</pre>			<p>This command will ask us a few questions, and then it will create the <strong class="source-inline">package.json</strong> file. For an even faster creation, you can use <strong class="source-inline">npm init -y</strong> to automatically create the file with the default <span class="No-Break">values suggested.</span></p>
			<p>We can also create the <strong class="source-inline">package.json</strong> file manually, but it is recommended to use the <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> command.</span></p>
			<p>The <strong class="source-inline">package.json</strong> file can be very simple, like <span class="No-Break">this one:</span></p>
			<pre class="source-code">
{
  "name": "my-project",
  "version": "1.0.0",
  "description": "My project",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "John Doe",
  "license": "MIT"
}</pre>			<p>But it can also be a large file, with one or many dependencies, scripts, and additional metadata. Currently, there is no official standard for the <strong class="source-inline">package.json</strong> file, but there are efforts to create<a id="_idIndexMarker325"/> it in the Standards Working Group from the OpenJS <span class="No-Break">Foundation (</span><a href="https://github.com/openjs-foundation/standards/issues/233"><span class="No-Break">https://github.com/openjs-foundation/standards/issues/233</span></a><span class="No-Break">).</span></p>
			<p>Currently, we can use the npm documentation to know what fields we can use in the <strong class="source-inline">package.json</strong> file. The documentation is available <span class="No-Break">at </span><a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json"><span class="No-Break">https://docs.npmjs.com/cli/v7/configuring-npm/package-json</span></a><span class="No-Break">.</span></p>
			<p>In the next sections, we will see some of the most important fields in the <strong class="source-inline">package.json</strong> file and how to use them in <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor175"/>Choosing the correct dependencies for your project</h1>
			<p>It is true that the npm ecosystem is very<a id="_idIndexMarker326"/> solid and growing every day. But it is also true that many packages are not maintained anymore, or that include security vulnerabilities and <span class="No-Break">performance issues.</span></p>
			<p>The community is aware of this and there are plenty of jokes and memes about this topic. For example, the <span class="No-Break">following image:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B21678_06_01.jpg" alt="Figure 6.1 – npm Delivery by MonkeyUser – a classic meme that shows how many dependencies we tend to include in our projects (https://www.monkeyuser.com/2017/npm-delivery/)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – npm Delivery by MonkeyUser – a classic meme that shows how many dependencies we tend to include in our projects (https://www.monkeyuser.com/2017/npm-delivery/)</p>
			<p>While this is a joke based on the huge number of dependencies and sub-dependencies that we install on an average project, it is true that we need to be careful when choosing the <a id="_idIndexMarker327"/>dependencies for our projects. In this section, we will see how to choose the correct dependencies for <span class="No-Break">our projects.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Most modules depend on other modules, and those modules depend on other modules, and so on. This is<a id="_idIndexMarker328"/> called the <strong class="bold">dependency tree</strong>. When we install a module, we are installing all the dependencies of that module, and all the dependencies of the dependencies, and so on. This is why it is important to choose the correct dependencies for <span class="No-Break">our projects.</span></p>
			<p>Before choosing a<a id="_idIndexMarker329"/> dependency, we need to ask ourselves the <span class="No-Break">following questions:</span></p>
			<ul>
				<li>What are the risks associated with choosing a <span class="No-Break">bad dependency?</span></li>
				<li>What are the criteria that I should use to choose <span class="No-Break">a dependency?</span></li>
			</ul>
			<p>Let’s see the answers to <span class="No-Break">these questions!</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor176"/>Risks</h2>
			<p>In our modern world, we are used to<a id="_idIndexMarker330"/> using dependencies. It will be very hard or directly impossible to build modern web applications without <span class="No-Break">using dependencies.</span></p>
			<p>When we choose a dependency, we are taking a risk. Let’s see what the main risks associated with choosing a bad <span class="No-Break">dependency are:</span></p>
			<ul>
				<li><strong class="bold">Security vulnerabilities</strong>: A dependency can have security vulnerabilities or even be a malicious piece <span class="No-Break">of code.</span></li>
				<li><strong class="bold">Performance issues</strong>: A dependency can have performance issues and generate memory leaks that can affect the performance of our application and even <span class="No-Break">crash it.</span></li>
				<li><strong class="bold">Maintenance issues</strong>: A dependency cannot be maintained anymore, and it can be deprecated in the future. This can cause our application to stop working in the future or prevent us from upgrading other dependencies or <span class="No-Break">Node.js itself.</span></li>
			</ul>
			<p>In 2020, I published a controversial blog post called <em class="italic">What is a backdoor?</em> <em class="italic">Let’s build one with Node.js</em> (<a href="https://snyk.io/blog/what-is-a-backdoor/">https://snyk.io/blog/what-is-a-backdoor/</a>). In that blog post, I explained that a backdoor is a piece of code that<a id="_idIndexMarker331"/> allows us to access a system without going through the authentication process. I also explained how to build a backdoor with Node.js using a few lines of code and I demonstrated how easy was to publish and distribute a <span class="No-Break">malicious package.</span></p>
			<p>I know that security is a very sensitive topic, especially if you are starting your journey in web development. <a href="B21678_15.xhtml#_idTextAnchor394"><span class="No-Break"><em class="italic">Chapter 15</em></span></a> of this book is dedicated to security, and we will explore security in <span class="No-Break">depth there.</span></p>
			<p>In order to minimize the<a id="_idIndexMarker332"/> risks, we need to choose the correct dependencies for our projects. Let’s see how to <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor177"/>Good criteria</h2>
			<p>There are many criteria that we can use to choose the correct dependencies for our projects. In this section, we <a id="_idIndexMarker333"/>will see some of the most <span class="No-Break">important ones.</span></p>
			<h3>What are we trying to avoid?</h3>
			<p>We try to avoid the <span class="No-Break">following things:</span></p>
			<ul>
				<li>Packages that are not <span class="No-Break">maintained anymore</span></li>
				<li>Packages that have known security vulnerabilities and are <span class="No-Break">not patched</span></li>
				<li>Packages that depend on a lot of packages or have <span class="No-Break">low-quality dependencies</span></li>
				<li>Packages that are not popular or are <span class="No-Break">low quality</span></li>
				<li>Packages with <span class="No-Break">license issues</span></li>
			</ul>
			<h3>What evidence do we have?</h3>
			<p>We are going to do some basic OSINT before we install any package, and we are going to check two data sources in detail: the npm website and the GitHub or <span class="No-Break">code repository.</span></p>
			<p class="author-quote">OSINT is intelligence produced by collecting and analyzing public information with the purpose of answering a specific intelligence question. (Ritu Gill, <a href="https://www.sans.org/blog/what-is-open-source-intelligence/">https://www.sans.org/blog/what-is-open-source-intelligence/</a>.)</p>
			<h3>Real example</h3>
			<p>In this book, we are going to use the Express library. Express is a very popular library for Node.js, and it is used to build web applications and APIs. In this image, we can see in detail how the Express library is showcased on the <span class="No-Break">npm website:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B21678_06_02.jpg" alt="Figure 6.2 – Express library package in npm (https://www.npmjs.com/package/express)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Express library package in npm (https://www.npmjs.com/package/express)</p>
			<p>From the npm website, we<a id="_idIndexMarker334"/> can see the <span class="No-Break">following information:</span></p>
			<ul>
				<li>There are 31 dependencies, most of which are very popular and well-maintained by the same <span class="No-Break">Express maintainers</span></li>
				<li>There are +77k dependents, which means that many other package authors are using Express in <span class="No-Break">their projects</span></li>
				<li>There are 271 <span class="No-Break">versions published</span></li>
				<li>There are almost 31M weekly downloads, which means that Express is a very popular package for the <span class="No-Break">Node.js community</span></li>
				<li>An MIT license, which is a permissive license and valid as <span class="No-Break">open source</span></li>
				<li>Clear and <span class="No-Break">solid documentation</span></li>
				<li>It was last published few days ago, which means that the package is maintained and <span class="No-Break">updated regularly</span></li>
			</ul>
			<p>From npm, we can access the GitHub repository of the package. In the following image, we can see in<a id="_idIndexMarker335"/> detail how the Express library is showcased on the <span class="No-Break">GitHub website:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B21678_06_03.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Express library repository in GitHub (https://github.com/expressjs/express)</p>
			<p>From the GitHub website, we can see the <span class="No-Break">following information:</span></p>
			<ul>
				<li>It has +10k forks, which means that many other developers are contributing to <span class="No-Break">the project</span></li>
				<li>It has +60k stars, which means that the project is popular in <span class="No-Break">the community</span></li>
				<li>It has +5k commits, which means that the project has a <span class="No-Break">long history</span></li>
				<li>It has +3k issues closed, +120 issues open, +1k pull requests closed, and +60 pull requests open, which means that the project <span class="No-Break">is active</span></li>
				<li>It has almost 300 contributors, which means that many other developers are contributing to the project and <span class="No-Break">evolving it</span></li>
			</ul>
			<p>As we can see, we have a lot of information from the npm website and the GitHub repository at least to<a id="_idIndexMarker336"/> make a first decision, especially if we want to compare several packages. The offer is huge and sometimes it is difficult to choose the <span class="No-Break">correct package.</span></p>
			<h3>Exceptions to the rules</h3>
			<p>We need to be quite flexible with the rules that we have seen before because very often we can find exceptions to <span class="No-Break">the rules.</span></p>
			<p>For example, johnny-five (<a href="https://www.npmjs.com/package/johnny-five">https://www.npmjs.com/package/johnny-five</a>) is a great library to use when working with Arduino and Raspberry Pi in Node.js. But the total download per week is very low. In this case, we need to consider that there are much less developers working with Arduino and Raspberry Pi than developers working with Express, <span class="No-Break">for example.</span></p>
			<p>Another example is Lodash (<a href="https://www.npmjs.com/package/lodash">https://www.npmjs.com/package/lodash</a>), which is a very popular library and is used by many other packages. But the last version was published three years ago. In this case, we need to consider that the project is mostly completed, and it is not evolving anymore and only making new releases <span class="No-Break">when needed.</span></p>
			<h3>Deprecation notices</h3>
			<p>Sometimes, we can find a package that is deprecated. In this case, we should avoid using it. We can find a deprecation notice in the npm website, in the GitHub repository, or when we install <span class="No-Break">the package.</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21678_06_04.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Image from the npm documentation that shows how the deprecation warnings are shown in npm (https://docs.npmjs.com/packages-and-modules/updating-and-managing-your-published-packages/deprecate-package.png)</p>
			<p>Very often, in the<a id="_idIndexMarker337"/> deprecation notice, we can find a recommendation to use another package. In this case, we should follow <span class="No-Break">the recommendation.</span></p>
			<h3>Tooling</h3>
			<p>In the previous OSINT analysis, we answered most of our questions, but we didn’t answer questions <a id="_idIndexMarker338"/>regarding known vulnerabilities. These days, I use two tools to check known vulnerabilities: <em class="italic">Snyk</em> (<a href="https://snyk.io/">https://snyk.io/</a>) and <span class="No-Break"><em class="italic">socket.dev</em></span><span class="No-Break"> (</span><a href="https://socket.dev/"><span class="No-Break">https://socket.dev/</span></a><span class="No-Break">).</span></p>
			<p>In <a href="B21678_15.xhtml#_idTextAnchor394"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, we will see <a id="_idIndexMarker339"/>how they are used in detail. In order to use these tools properly, you will need to understand how the dependency tree works and how the vulnerabilities are classified. Otherwise, these tools can be very confusing <span class="No-Break">for beginners.</span></p>
			<p>I will suggest to say "In the next section, we will learn how to install the dependencies in <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor178"/>Installing dependencies</h1>
			<p>Now that we know how to <a id="_idIndexMarker340"/>choose the correct dependencies for our projects, and we have a <strong class="source-inline">package.json</strong> we can start installing <span class="No-Break">our dependencies.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor179"/>Locally or globally</h2>
			<p>We can install dependencies in two ways: locally <span class="No-Break">or globally:</span></p>
			<ul>
				<li><strong class="bold">Locally</strong>: These are dependencies <a id="_idIndexMarker341"/>that are installed in the <strong class="source-inline">node_modules</strong> folder of our project. For example, <strong class="source-inline">express</strong> is a local dependency of <span class="No-Break">our application.</span></li>
				<li><strong class="bold">Globally</strong>: These are dependencies that are installed in the global folder of our system, so they become available from anywhere in our system, such as Node.js binary, which is available as soon as we open <span class="No-Break">the terminal.</span></li>
			</ul>
			<p>We would prefer to install dependencies locally because it is easier to manage the dependencies of our project and to avoid conflicts between different projects. We will install dependencies globally only when it is <span class="No-Break">strictly necessary.</span></p>
			<p>One example of a dependency that we will install globally is <strong class="source-inline">yeoman</strong>, a scaffolding tool, which we will use to generate a <span class="No-Break">new project.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor180"/>Dependency or development dependency</h2>
			<p>We can install the local dependencies<a id="_idIndexMarker342"/> in two ways: as a dependency or as a <span class="No-Break">development dependency:</span></p>
			<ul>
				<li><strong class="bold">Dependency</strong>: Dependencies that are required to run the application. For example, <strong class="source-inline">express</strong> is a dependency of <span class="No-Break">our application.</span></li>
				<li><strong class="bold">Development dependency</strong>: Dependencies that are required to develop the application. For example, <strong class="source-inline">standard</strong>, which is a linter library, will be used only while developing the code but not <span class="No-Break">when running.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There is an additional mode to install <a id="_idIndexMarker343"/>dependencies: <strong class="bold">peer dependencies</strong>. We will not cover this mode in this book, but you can find more information and use cases in this blog <span class="No-Break">post: </span><a href="https://nodejs.org/en/blog/npm/peer-dependencies"><span class="No-Break">https://nodejs.org/en/blog/npm/peer-dependencies</span></a><span class="No-Break">.</span></p>
			<p>The segmentation of dependencies is very important because it allows us to install only the dependencies that we need in each environment and to reduce the size of our application and <span class="No-Break">attack surface.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor181"/>Adding new dependency</h2>
			<p>For example, if we want to<a id="_idIndexMarker344"/> install the <strong class="source-inline">express</strong> package, we can use the <span class="No-Break">following command:</span></p>
			<pre class="console">
# npm install &lt;package-name&gt;
npm install express</pre>			<p>We can install the <strong class="source-inline">standard</strong> package as a development dependency. Development dependencies are those dependencies that we need when we are actually coding the project, but they are not used when the project is being deployed or distributed as a library. As <strong class="source-inline">standard</strong> is a linting tool, we will use it only when adding or changing code, but we won’t use it while the application is running. This segmentation of the dependencies has a lot of benefits as our final applications will be smaller (ignoring the development dependencies) and more secure as we have less external code. We can use the <strong class="source-inline">-D</strong> or <strong class="source-inline">--save-dev</strong> for installing development <span class="No-Break">dependencies arguments:</span></p>
			<pre class="console">
# npm install --save-dev &lt;package-name&gt;
# npm install  -D &lt;package-name&gt;
npm install --save-dev standard</pre>			<p>We can see that the <strong class="source-inline">package.json</strong> file has been updated with the new dependencies in two different sections: <strong class="source-inline">dependencies</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">devDependencies</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
{
  "dependencies": {
    "express": "^4.18.3"
  },
  "devDependencies": {
    "standard": "^17.1.0"
  }
}</pre>			<p>One new file, <strong class="source-inline">package-lock.json</strong>, has also been added and the <strong class="source-inline">node_modules</strong> folder has been created with the dependencies structured in folders <span class="No-Break">and files.</span></p>
			<p>We will explore in the next<a id="_idIndexMarker345"/> section how the <strong class="source-inline">package-lock.json</strong> <span class="No-Break">file works.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">node_modules</strong> should not be included with the project source code if you are using Git or any other system to distribute your source code. It is good practice to include the <strong class="source-inline">node_modules</strong> folder in the <strong class="source-inline">.gitignore</strong> file to avoid including it in the repository. If you need a solid <strong class="source-inline">.gitignore</strong> file for Node.js, you can generate one (<a href="https://www.toptal.com/developers/gitignore/api/node">https://www.toptal.com/developers/gitignore/api/node</a>). We should ignore <strong class="source-inline">node_modules</strong> because the folder can be huge, and have many files and a heavy weight, but also because we can install the dependencies at any time, as soon as we keep our changes in <strong class="source-inline">package.log</strong>, we will be able to install the <span class="No-Break">correct dependencies</span></p>
			<p>Global dependencies are installed with the <strong class="source-inline">-g</strong> or <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">global</strong></span><span class="No-Break"> argument:</span></p>
			<pre class="console">
# npm install --global &lt;package-name&gt;
# npm install -g &lt;package-name&gt;
# Install yeoman globally
npm install --global yo</pre>			<p>You can see the list of global dependencies with the <strong class="source-inline">list</strong> or <span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
# npm list --global
# npm ls --global
npm list --global</pre>			<p>The output of this command will be something <span class="No-Break">like this:</span></p>
			<pre class="console">
/Users/ulises/.nvm/versions/node/v20.11.0/lib
├── corepack@0.23.0
├── npm@10.2.4
└── yo@5.0.0</pre>			<h2 id="_idParaDest-175"><a id="_idTextAnchor182"/>Installing all the dependencies</h2>
			<p>If we want to install all the dependencies <a id="_idIndexMarker346"/>that are listed in the <strong class="source-inline">package.json</strong> file, we can use the <strong class="source-inline">install</strong> or <strong class="source-inline">i</strong> command without <span class="No-Break">any argument:</span></p>
			<pre class="console">
npm install</pre>			<p>We can also use the <strong class="source-inline">--only</strong> argument to install only the dependencies or the <span class="No-Break">development dependencies:</span></p>
			<pre class="console">
# Prod Only
npm install --only=prod
npm install --only=production
# Dev Only
npm install --only=dev
npm install --only=development</pre>			<p>In the production environments, we want to avoid using development tools because, although this will make our applications smaller and more secure, in our development environments we will require all the dependencies to properly do <span class="No-Break">our job.</span></p>
			<p>In the next section, we will explore how to properly remove dependencies from <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor183"/>Removing dependencies</h1>
			<p>You can remove a dependency<a id="_idIndexMarker347"/> using the <span class="No-Break"><strong class="source-inline">uninstall</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
# npm uninstall &lt;package-name&gt;
npm uninstall express</pre>			<p>This command will remove the dependency from the <strong class="source-inline">package.json</strong> and <strong class="source-inline">package-lock.json</strong> files and the <span class="No-Break"><strong class="source-inline">node_modules</strong></span><span class="No-Break"> folder.</span></p>
			<p>Global dependencies are <a id="_idIndexMarker348"/>removed with the <strong class="source-inline">-g</strong> or <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">global</strong></span><span class="No-Break"> argument:</span></p>
			<pre class="console">
# npm uninstall --global &lt;package-name&gt;
# npm uninstall -g &lt;package-name&gt;
# Remove yeoman globally
npm uninstall --global yo</pre>			<p>In the next section we will explore how the <strong class="source-inline">package-lock.json</strong> file can help us to manage <span class="No-Break">our dependencies.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor184"/>Understanding the package-lock.json</h1>
			<p>Historically, the <strong class="source-inline">package.json</strong> file was the only file that we needed to manage the dependencies of our project. But this file has a problem: it doesn’t contain the exact version of each sub-dependency that we<a id="_idIndexMarker349"/> have installed in our project and was also quite slow to install <span class="No-Break">the dependencies.</span></p>
			<p>Not having the exact version of each sub-dependency can be a problem because if we install the same dependency in two different environments, we can end up with different versions of the same dependency. The lack of immutability in our dependencies can lead to unexpected errors and bugs that are quite complicated <span class="No-Break">to debug.</span></p>
			<p>Also, by default, when we install a dependency the version that is recorded in <strong class="source-inline">package.json</strong> includes a caret <strong class="source-inline">^</strong> symbol, such as <strong class="source-inline">"express": "^4.18.3"</strong>. This symbol means that we can install any version of the dependency that is compatible with the version that is recorded <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">package-lock.json</strong> file is a file that is automatically generated when we install a new dependency and also speeds up the installation of the dependencies because it contains the exact version of each dependency and the source where it <span class="No-Break">comes from.</span></p>
			<p>The file can be huge, but the structure per dependency is <span class="No-Break">quite simple:</span></p>
			<pre class="source-code">
{
    "node_modules/express/node_modules/debug": {
        "version": "2.6.9",
        "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
        "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
        "dependencies": {
            "ms": "2.0.0"
        }
    }
}</pre>			<p>As you can see, the exact <strong class="source-inline">version</strong> is included, as well as the <strong class="source-inline">resolved</strong> and <strong class="source-inline">integrity</strong> fields that are used to<a id="_idIndexMarker350"/> validate the origin of the dependency and to avoid manipulations with the data in transit as <strong class="source-inline">integrity</strong> provides a checksum. Also, the <strong class="source-inline">dependencies</strong> field is included to list the sub-dependencies with the <span class="No-Break">exact version.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">package-lock.json</strong> should be distributed with the source code of the project and should be committed to the repository; basically, it should be treated as <strong class="source-inline">package.json</strong> in terms <span class="No-Break">of distribution.</span></p>
			<p>Now that we know how to classify and organize the dependencies in our projects, it is time to explore how to install specific versions and notice <span class="No-Break">outdated dependencies.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor185"/>Managing dependencies versions</h1>
			<p>If we want to install a specific <a id="_idIndexMarker351"/>version of a package, we can use the @ symbol. You can be as specific as <span class="No-Break">you want:</span></p>
			<pre class="console">
# npm install &lt;package-name&gt;@&lt;version&gt;
npm install express@4
npm install express@4.17
npm install express@4.17.1</pre>			<h2 id="_idParaDest-179"><a id="_idTextAnchor186"/>Outdated dependencies</h2>
			<p>Eventually, the dependencies that<a id="_idIndexMarker352"/> we have installed in our project will be outdated, and we will need to update them. To check if we have any outdated dependencies, we can use the <span class="No-Break"><strong class="source-inline">outdated</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
npm outdated</pre>			<p>This command will list all the outdated dependencies, as well as the current version, the wanted version, and the <span class="No-Break">latest version:</span></p>
			<pre class="console">
Package  Current  Wanted  Latest  Location              Depended by
express   3.21.2  3.21.2  4.18.3  node_modules/express  my-project</pre>			<p>Now that we are clear on how to handle outdated dependencies it is time to explore in the next section how to create isomorphic JavaScript code that can be executed in all environments (browsers <span class="No-Break">and Node.js)</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor187"/>Building Isomorphic JavaScript</h1>
			<p>Isomorphic JavaScript is a<a id="_idIndexMarker353"/> term that is used to describe JavaScript code that can run both in the browser and in Node.js. In other words, it is a library that can be used in both environments. In order to do that, you will limit yourself to the features that are available in <span class="No-Break">both environments.</span></p>
			<p>For example, you can’t use the <strong class="source-inline">fs</strong> module in the browser, and you can’t use the <strong class="source-inline">window</strong> object <span class="No-Break">in Node.js.</span></p>
			<p>Sometimes, we install dependencies in our projects that are designed to be used in the browser and we try to <a id="_idIndexMarker354"/>use them in Node.js, and vice versa. This is a common mistake that we need <span class="No-Break">to avoid.</span></p>
			<p>Most of the projects will specify which environment they are designed for. Here is an example from <span class="No-Break">Lodash (</span><a href="https://lodash.com/"><span class="No-Break">https://lodash.com/</span></a><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21678_06_05.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Image from the Lodash documentation that explains in detail how to install the library in both environments (<a href="https://lodash.com/">https://lodash.com/</a>)</p>
			<p>It is quite clear that lodash is designed to be used in Node.js and in the browser, and from the figure you can see how to install it in <span class="No-Break">each environment.</span></p>
			<p>In the next section, we will learn how we can use npm scripts to improve our developer experience while<a id="_idIndexMarker355"/> building <span class="No-Break">Node.js projects.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor188"/>Using npm scripts</h1>
			<p>npm scripts are <a id="_idIndexMarker356"/>commands that we can define in the <strong class="source-inline">package.json</strong> file. These commands can be executed using the <span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
# npm run &lt;script-name&gt;
npm run lint</pre>			<p>This is great because we can define our own commands and we can use them to automate tasks. For example, we can define a command to run the linter in <span class="No-Break">our project:</span></p>
			<pre class="source-code">
{
    "scripts": {
        "lint": "standard",
        "lint:fix": "standard --fix"
    },
    "devDependencies": {
        "standard": "^12.0.1"
    }
}</pre>			<p>Then we can run the <span class="No-Break">following command:</span></p>
			<pre class="console">
npm run lint
npm run lint:fix</pre>			<p>npm scripts are basically shortcuts to run commands that we can run manually in the terminal. So, you can build quite complex things such as starting/stopping a server, running tests, preparing infrastructure, and deploying <span class="No-Break">your application.</span></p>
			<p>This is a very powerful feature that we can use to automate tasks in our projects, especially when we are<a id="_idIndexMarker357"/> working in a team, and we want to make sure that everyone is running the same commands or with continuous <span class="No-Break">integration tools.</span></p>
			<p>We will use npm scripts in the next chapters to automate tasks in <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor189"/>Executing packages directly with NPX</h1>
			<p>Since version 5.2.0, npm comes<a id="_idIndexMarker358"/> with a new tool called <strong class="source-inline">npx</strong>, which allows us to execute packages without installing them globally. This is great for <span class="No-Break">one-time commands.</span></p>
			<p>Let’s say that we have a project with outdated dependencies, and we want to <span class="No-Break">update them:</span></p>
			<pre class="source-code">
{
  "dependencies": {
    "express": "^3.21.2",
    "lodash": "^1.3.1"
  },
  "devDependencies": {
    "standard": "^17.1.0"
  }
}</pre>			<p>As we saw in the previous section, we can use the <strong class="source-inline">npm outdated</strong> command to check which dependencies are outdated, but the upgrade process is a bit more complex as we need to upgrade each dependency manually or modify the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> directly.</span></p>
			<p>Fortunately, there is a package called npm-check-updates (<a href="https://www.npmjs.com/package/npm-check-updates">https://www.npmjs.com/package/npm-check-updates</a>), which allows us to upgrade all the dependencies in our project. Let’s learn how to <span class="No-Break">use it:</span></p>
			<pre class="console">
npx npm-check-updates</pre>			<p>This command will list all the outdated dependencies, and will show the new version that <span class="No-Break">is available:</span></p>
			<pre class="console">
express  ^3.21.2  →   ^4.18.3
lodash    ^1.3.1  →  ^4.17.21</pre>			<p>Then we can use the <strong class="source-inline">-u</strong> flag to<a id="_idIndexMarker359"/> upgrade all <span class="No-Break">the dependencies:</span></p>
			<pre class="console">
npx npm-check-updates –u</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">npm-check-updates</strong> package offers a lot of options to customize the upgrade process, you can check the documentation at <a href="https://www.npmjs.com/package/npm-check-updates">https://www.npmjs.com/package/npm-check-updates</a> for <span class="No-Break">more information.</span></p>
			<p>The dependencies were upgraded in <strong class="source-inline">package.json</strong>, we just need to run <strong class="source-inline">npm install</strong> to make the changes <span class="No-Break">take effect:</span></p>
			<pre class="source-code">
{
  "dependencies": {
    "express": "^4.18.3",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "standard": "^17.1.0"
  }
}</pre>			<p>Now, we can take an extra step and automate this process using npm scripts, so in the future, we can speed up this process, and we do this just by adding the following scripts to your <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
{
    "scripts": {
        "deps:check": "npx npm-check-updates",
        "deps:upgrade": "npx npm-check-updates -u &amp;&amp; npm install"
    }
}</pre>			<p>This was a great example of<a id="_idIndexMarker360"/> how you can combine npm scripts and npx to automate tasks in your projects and increase the developer experience for other contributors as they can run the same command to upgrade the dependencies <span class="No-Break">when needed.</span></p>
			<p>Also, this combination is great for continuous integration tools, as you can run the same commands in your <span class="No-Break">CI pipeline.</span></p>
			<p>But the most important thing is that you don’t need to install any global or local packages, so you keep your dependencies to <span class="No-Break">a minimum.</span></p>
			<p>In the next section we are going to learn more about the current alternatives <span class="No-Break">to npm.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor190"/>npm alternatives</h1>
			<p>Over the years, npm has become the standard <a id="_idIndexMarker361"/>package manager for JavaScript, but there are other alternatives that you can use in <span class="No-Break">your projects.</span></p>
			<p>Most of the alternatives are compatible with the npm registry, so you can use the same packages that you use with npm and you can switch between them without <span class="No-Break">any problem.</span></p>
			<p>Each alternative has its own advantages and disadvantages, so you need to evaluate which one is the best for your project. Most of the time, npm will be the best option, but it is good to know that there are other alternatives designed to solve very <span class="No-Break">specific scenarios.</span></p>
			<p>Let’s introduce some <span class="No-Break">of them:</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor191"/>Yarn</h2>
			<p><strong class="bold">Yarn</strong> (<a href="https://yarnpkg.com/">https://yarnpkg.com/</a>) is a package <a id="_idIndexMarker362"/>manager created by Facebook and released<a id="_idIndexMarker363"/> in 2016. It was created to solve some specific problems that npm had at that time, but over the years, npm has improved a lot and it has solved most of the problems that Yarn <span class="No-Break">solved originally.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor192"/>PNPM</h2>
			<p><strong class="bold">PNPM</strong> (<a href="https://pnpm.js.org/">https://pnpm.js.org/</a>) is a package<a id="_idIndexMarker364"/> manager that uses a different approach to install dependencies. Instead of<a id="_idIndexMarker365"/> installing the dependencies in the <strong class="source-inline">node_modules</strong> folder, it creates a single folder for all the dependencies in the project. This approach has some advantages such as disk space usage and <span class="No-Break">network usage.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor193"/>Verdaccio</h2>
			<p><strong class="bold">Verdaccio</strong> (<a href="https://verdaccio.org/">https://verdaccio.org/</a>) is a private npm registry that you can use to host your own packages. This is great if you <a id="_idIndexMarker366"/>want to have a private registry for your <a id="_idIndexMarker367"/>company or if you want to have a mirror of the <span class="No-Break">npm registry.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Verdaccio is a great tool if you have connectivity issues or if you want to experiment with the npm registry before publishing <span class="No-Break">the packages.</span></p>
			<p>In the next section we will learn how to publish and distribute our own packages so we can re-use our code across projects. Also, other developers can use the libraries that <span class="No-Break">we built.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor194"/>Publishing your first package</h1>
			<p>We have seen how to install packages from the npm registry, but we can also publish our own packages. This is great if we want to share our code with other developers or if we want to reuse our code in <span class="No-Break">other projects.</span></p>
			<p>So, let’s see how to publish our first<a id="_idIndexMarker368"/> package in the <span class="No-Break">npm registry.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor195"/>Registries</h2>
			<p>Before we start, we need to understand how the npm registry works. The npm registry is a public repository where all the <a id="_idIndexMarker369"/>packages are stored. This is the default registry that npm uses, but you can also use other registries such as Verdaccio (<a href="https://verdaccio.org/">https://verdaccio.org/</a>) or GitHub <span class="No-Break">Packages (</span><a href="https://github.com/features/packages"><span class="No-Break">https://github.com/features/packages</span></a><span class="No-Break">).</span></p>
			<p>We will use the npm registry in this chapter, but the process is very similar for other registries. Some developers publish their packages in multiple registries, so you can choose the one that <span class="No-Break">you prefer.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to publish a private package, it is more common to use a private registry such as Verdaccio or GitHub <a id="_idIndexMarker370"/>Packages, but if you want to publish a public package, the npm registry is the <span class="No-Break">best option.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor196"/>npm account</h2>
			<p>Before we can publish our <a id="_idIndexMarker371"/>packages, we need to create an account in the npm registry. You can create an account on the npm website (<a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a>) by following the steps in the next <span class="No-Break">section (</span><a href="https://docs.npmjs.com/creating-a-new-npm-user-account"><span class="No-Break">https://docs.npmjs.com/creating-a-new-npm-user-account</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor197"/>Prepare the package</h2>
			<p>So, let’s start by creating a new folder for our <a id="_idIndexMarker372"/>package with the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">my-first-package</strong></span><span class="No-Break">.</span></p>
			<p>We will create a <strong class="source-inline">package.json</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
{
  "name": "@USERNAME/demo-package",
  "version": "1.0.0",
  "description": "Sample package: Node.js for beginners",
  "main": "index.mjs",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "YOUR NAME",
  "license": "MIT"
}</pre>			<p>You will need to replace <strong class="source-inline">@USERNAME</strong> with your npm username, which is <strong class="source-inline">@ulisesgascon</strong> in my case, and also change the <strong class="source-inline">author</strong> field with <span class="No-Break">your name.</span></p>
			<p>Then, we will create an <strong class="source-inline">index.mjs</strong> file with<a id="_idIndexMarker373"/> the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
function sum(a, b) {
  return a + b
}
export { sum }</pre>			<p>The last step is to include a <strong class="source-inline">README.md</strong> file with some information about <span class="No-Break">the package:</span></p>
			<pre class="source-code">
# Sample package: Node.js for beginners
This is a sample package to learn how to publish packages in npm.
## Installation
```bash
npm install @USERNAME/demo-package
```
## Usage
```js
import { sum } from '@USERNAME/demo-package'
console.log(sum(1, 2))
```</pre>			<p>Replace <strong class="source-inline">@USERNAME</strong> with your npm<a id="_idIndexMarker374"/> username as we did previously with <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break">.</span></p>
			<p>This is a very simple package, but it is enough to show how to publish a package in the <span class="No-Break">npm registry.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor198"/>Reviewing the package</h2>
			<p>Now that we have our package ready, we<a id="_idIndexMarker375"/> can publish it in the npm registry. To do that, we need to run the following command in <span class="No-Break">the terminal:</span></p>
			<pre class="console">
npm publish --dry-run</pre>			<p>The <strong class="source-inline">--dry-run</strong> flag is optional, but it is a good idea to use it the first time to see what is going to happen. This command will show you the files that are going to be published and some information about <span class="No-Break">the package.</span></p>
			<pre class="console">
npm notice
npm notice 📦  @ulisesgascon/demo-package@1.0.0
npm notice === Tarball Contents ===
npm notice 188B .vscode/settings.json
npm notice 267B README.md
npm notice 55B  index.mjs
npm notice 272B package.json
npm notice === Tarball Details ===
npm notice name:          @ulisesgascon/demo-package
npm notice version:       1.0.0
npm notice filename:      ulisesgascon-demo-package-1.0.0.tgz
npm notice package size:  617 B
npm notice unpacked size: 782 B
npm notice shasum:        cb55a05cdfb52f9dbd4b074d4940bfb5ad698d8f
npm notice integrity:     sha512-MDdDzLyysuWJS[...]H92x5C6Vvi0iA==
npm notice total files:   4
npm notice
npm notice Publishing to https: //registry. npmjs. org/ with tag latest and default access (dry-run)
+ @ulisesgascon/demo-package@1.0.0</pre>			<p>As you can see, there is a file that is not needed, the <strong class="source-inline">.vscode/settings.json</strong> file. This file is used by Visual <a id="_idIndexMarker376"/>Studio Code to configure the editor, but it is not needed in the package. We can remove it by adding a <strong class="source-inline">.npmignore</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
.vscode</pre>			<p>This file will tell npm to ignore the <strong class="source-inline">.vscode</strong> folder when publishing the package. If you run the command again, you will see that the file is not included in <span class="No-Break">the package:</span></p>
			<pre class="console">
npm notice === Tarball Contents ===
npm notice 267B README.md
npm notice 55B  index.mjs
npm notice 272B package.json
npm notice === Tarball Details ===</pre>			<h2 id="_idParaDest-192"><a id="_idTextAnchor199"/>Publish the package</h2>
			<p>Now that we have our package<a id="_idIndexMarker377"/> ready, we can publish it in the npm registry. To do that, we need to run the following command in <span class="No-Break">the terminal:</span></p>
			<pre class="console">
npm publish --access public</pre>			<p>The <strong class="source-inline">--access public</strong> flag makes this package available to the world, so anyone with internet access can download <span class="No-Break">your package.</span></p>
			<p>You can see in the output that the package is published in the <span class="No-Break">npm registry:</span></p>
			<pre class="console">
npm notice
npm notice Publishing to https: //registry. npmjs. org/ with tag latest and public access
+ @ulisesgascon/demo-package@1.0.0</pre>			<p>Now, if you go to the npm website (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>) and search for your package, you will see it in the search results. You can also access the package page directly using the following URL: <strong class="source-inline">https://www.npmjs.com/package/@USERNAME/demo-package</strong> (replace <strong class="source-inline">@USERNAME</strong> with your npm username, which is <strong class="source-inline">@ulisesgascon</strong> in <span class="No-Break">my case).</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21678_06_06.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The published package in the npm registry</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor200"/>Avoid the scoped packages</h2>
			<p>It is possible to publish packages without a scope in the npm registry, but it is difficult to find a name that is not already taken. For that reason, it is a good idea to use the scoped packages, such as <strong class="source-inline">@ulisesgascon/demo-package</strong> in <span class="No-Break">our case.</span></p>
			<p>But nothing stops you from publishing a <a id="_idIndexMarker378"/>package without a scope such as <strong class="source-inline">my-great-demo-package</strong> if the name is not already taken. But if you do that, you will need to be careful with the name, because once you publish a package, you can’t change the name. So, if you want to change the name, you will need to publish a new package with the new name and deprecate the <span class="No-Break">old one.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor201"/>Release new versions</h2>
			<p>Let’s make some changes to improve <a id="_idIndexMarker379"/>our package. We will add a new <strong class="source-inline">multiply</strong> function to the <span class="No-Break"><strong class="source-inline">index.mjs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
function sum(a, b) {
    return a + b
}
function multiply(a, b) {
    return a * b
}
export { sum, multiply }</pre>			<p>We will also include it in the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
## Usage
```js
import { sum, multiply } from '@ulisesgascon/demo-package'
console.log(sum(1, 2))
console.log(multiply(5, 2))
```</pre>			<p>Now, we are ready to <a id="_idIndexMarker380"/>publish again the package using <strong class="source-inline">npm publish --access public</strong> again, but there is <span class="No-Break">an error:</span></p>
			<pre class="console">
npm notice Publishing to https: //registry. npmjs. org/
npm ERR! code E403
npm ERR! 403 403 Forbidden - PUT https: //registry .npmjs. org/@ulisesgascon %2fdemo-package - You cannot publish over the previously published versions: 1.0.0.</pre>			<p>We forgot to change the version number in the <strong class="source-inline">package.json</strong> file, so we need to do that before publishing the package again. We should always follow semantic versioning (<a href="https://semver.org/">https://semver.org/</a>), so in this case we will change the version number to <strong class="source-inline">1.1.0</strong> as it is a minor change, we<a id="_idIndexMarker381"/> can make this change using the <strong class="source-inline">npm version minor </strong>command and as a result, we can see that <strong class="source-inline">package.json</strong> has been updated <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
{
  "version": "1.1.0",
}</pre>			<p>Now, we can publish the package again and we will see the new version on the npm website and in <span class="No-Break">the terminal:</span></p>
			<pre class="console">
npm notice
npm notice Publishing to https: //registry. npmjs. org/
+ @ulisesgascon /demo-package @1.1.0</pre>			<p>If we check the npm URL again, we can see the new version available and the changes <span class="No-Break">we made:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21678_06_07.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – The published package updated in npm</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor202"/>Prevent accidental publishing</h2>
			<p>While not very common, it is <a id="_idIndexMarker382"/>possible to publish a package by mistake, so it is a good idea to prevent that by adding the <strong class="source-inline">private</strong> flag to the <strong class="source-inline">package.json</strong> file if you don’t plan to publish <span class="No-Break">the package:</span></p>
			<pre class="source-code">
{
  "private": true
}</pre>			<h2 id="_idParaDest-196"><a id="_idTextAnchor203"/>Best practices</h2>
			<p>Now that we know how to create and publish a package, it is time to talk about quality. The best packages<a id="_idIndexMarker383"/> have a high-level standard and follow the <span class="No-Break">best practices.</span></p>
			<p>Some of the best practices are quite advanced, so we will not cover them in this book, but here are two great resources to learn more <span class="No-Break">about them:</span></p>
			<ul>
				<li>Best practices for creating a modern npm package with security in <span class="No-Break">mind (</span><a href="https://snyk.io/blog/best-practices-create-modern-npm-package/"><span class="No-Break">https://snyk.io/blog/best-practices-create-modern-npm-package/</span></a><span class="No-Break">)</span></li>
				<li>10 npm Security Best <span class="No-Break">Practices (</span><a href="https://snyk.io/blog/ten-npm-security-best-practices/"><span class="No-Break">https://snyk.io/blog/ten-npm-security-best-practices/</span></a><span class="No-Break">)</span></li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor204"/>Summary</h1>
			<p>In this chapter, we explored how to create a package from scratch, and how to install and maintain our dependencies over time. We learned how to use the <strong class="source-inline">package.json</strong> file to manage our dependencies, and how to use the <strong class="source-inline">package-lock.json</strong> file to lock the <span class="No-Break">dependencies versions.</span></p>
			<p>Additionally, we learned how to use npm scripts to automate tasks, and how to use global dependencies and <strong class="source-inline">npx</strong> to run commands without installing <span class="No-Break">them globally.</span></p>
			<p>Finally, we learned how to create our own packages and publish them in the npm registry, and how to update them <span class="No-Break">over time.</span></p>
			<p>In the next chapter, we will learn how to take advantage of the event-driven architecture in Node.js to create our own events and listen to them, and how core libraries such as HTTP use events to notify us about incoming requests and much more. We will build our first web server using the <span class="No-Break">HTTP library.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor205"/>Further reading</h1>
			<ul>
				<li><em class="italic">Happy Developers, Healthy Modules - Together We Can Do This - Michael Dawson, </em><span class="No-Break"><em class="italic">IBM</em></span><span class="No-Break"> (</span><a href="https://www.youtube.com/watch?v=e7tj_IbHEF4"><span class="No-Break">https://www.youtube.com/watch?v=e7tj_IbHEF4</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">What is npm, and why do we need it? | Tutorial for </em><span class="No-Break"><em class="italic">beginners</em></span><span class="No-Break"> (</span><a href="https://www.youtube.com/watch?v=P3aKRdUyr0s"><span class="No-Break">https://www.youtube.com/watch?v=P3aKRdUyr0s</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Package.json vs </em><span class="No-Break"><em class="italic">Package-lock.json</em></span><span class="No-Break"> (</span><a href="https://www.atatus.com/blog/package-json-vs-package-lock-json/"><span class="No-Break">https://www.atatus.com/blog/package-json-vs-package-lock-json/</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Best practices for creating a modern npm package with security in </em><span class="No-Break"><em class="italic">mind </em></span><span class="No-Break">(</span><a href="https://snyk.io/blog/best-practices-create-modern-npm-package/"><span class="No-Break">https://snyk.io/blog/best-practices-create-modern-npm-package/</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">What is a backdoor? Let’s build one with </em><span class="No-Break"><em class="italic">Node.js</em></span><span class="No-Break"> (</span><a href="https://snyk.io/blog/what-is-a-backdoor/"><span class="No-Break">https://snyk.io/blog/what-is-a-backdoor/</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Juan Picado @ NodeTLV 22 - Deep dive into Verdaccio, a lightweight Node.js </em><span class="No-Break"><em class="italic">registry</em></span><span class="No-Break"> (</span><a href="https://www.youtube.com/watch?v=qRMucS3i3kQ&amp;"><span class="No-Break">https://www.youtube.com/watch?v=qRMucS3i3kQ&amp;</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Isaac Schlueter: How npm </em><span class="No-Break"><em class="italic">Works</em></span><span class="No-Break"> (</span><a href="https://www.youtube.com/watch?v=ShRDgdvlZQ8"><span class="No-Break">https://www.youtube.com/watch?v=ShRDgdvlZQ8</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Leveling up Monorepos with npm Workspaces - Ruy Adorno, DevOps.js Conference </em><span class="No-Break"><em class="italic">2022</em></span><span class="No-Break"> (</span><a href="https://www.youtube.com/watch?v=A-pWrajferM"><span class="No-Break">https://www.youtube.com/watch?v=A-pWrajferM</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Ashley Williams | You don’t know </em><span class="No-Break"><em class="italic">npm</em></span><span class="No-Break"> (</span><a href="https://www.youtube.com/watch?v=g3_e5Sp9vd4"><span class="No-Break">https://www.youtube.com/watch?v=g3_e5Sp9vd4</span></a><span class="No-Break">)</span></li>
			</ul>
		</div>
	</body></html>