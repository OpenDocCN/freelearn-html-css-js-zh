<html><head></head><body>
		<div><h1 id="_idParaDest-164" class="chapter-number"><a id="_idTextAnchor171"/>6</h1>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor172"/> External Modules and npm</h1>
			<p><strong class="bold">Node Package Manager</strong> (<strong class="bold">npm</strong>) is one of the most popular software registries around the world. There are more than two million packages available for us to use. In this chapter, we will explore how to use npm commands and NPX, as well as what the isomorphic libraries are and how to choose the correct dependencies for our project, so we can minimize the risks. As a final practice, you will publish a package to npm.</p>
			<p>In this chapter, we will explore how to use external modules in our projects. This will allow us to reuse code from other developers and save time and effort. We will explore together the vast ecosystem of Node.js modules, and we will learn how to choose the correct modules for our projects.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>Managing the application with <code>package.json</code></li>
				<li>Choosing the correct dependencies for your project</li>
				<li>Installing dependencies</li>
				<li>Removing dependencies</li>
				<li>Understanding <code>package-lock.json</code></li>
				<li>Managing dependencies versions</li>
				<li>Building Isomorphic JavaScript</li>
				<li>Using npm scripts</li>
				<li>Executing packages directly with NPX</li>
				<li>npm alternatives</li>
				<li>Publishing your first package</li>
			</ul>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor173"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a></p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/B-7vZyAfi2U">https://youtu.be/B-7vZyAfi2U</a></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor174"/>Managing the application with package.json</h1>
			<p>When you install Node.js, npm is installed as well. npm is the package manager for Node.js. It is used to install, update, and remove packages from our projects. It also allows us to publish our own packages.</p>
			<p>A package is a <a id="_idIndexMarker324"/>JavaScript library that we can use in our applications to speed up the process of developing our own projects. There are many different types of packages, from very simple ones such as a function that can tell us whether a number is odd or not (<a href="https://www.npmjs.com/package/is-odd">https://www.npmjs.com/package/is-odd</a>), to very complex libraries that can help us to use Firebase (<a href="https://firebase.google.com/?hl=es">https://firebase.google.com/?hl=es</a>) to store information from our users (<a href="https://www.npmjs.com/package/firebase">https://www.npmjs.com/package/firebase</a>). It is quite common to use many libraries in a single project, and some companies create their own private libraries to distribute utilities, configurations, and many more things across their many code bases.</p>
			<p>The <code>package.json</code> file is the manifest file for our project. It contains the metadata of our project, such as the name, version, description, author, and license. It also contains the dependencies of our project, both the runtime dependencies and the development dependencies, and it contains the scripts that we can run with npm.</p>
			<p>In order to create a <code>package.json</code> file, we can run the following command:</p>
			<pre class="console">
npm init</pre>			<p>This command will ask us a few questions, and then it will create the <code>package.json</code> file. For an even faster creation, you can use <code>npm init -y</code> to automatically create the file with the default values suggested.</p>
			<p>We can also create the <code>package.json</code> file manually, but it is recommended to use the <code>npm </code><code>init</code> command.</p>
			<p>The <code>package.json</code> file can be very simple, like this one:</p>
			<pre class="source-code">
{
Â Â "name": "my-project",
Â Â "version": "1.0.0",
Â Â "description": "My project",
Â Â "main": "index.js",
Â Â "scripts": {
Â Â Â Â "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
Â Â },
Â Â "author": "John Doe",
Â Â "license": "MIT"
}</pre>			<p>But it can also be a large file, with one or many dependencies, scripts, and additional metadata. Currently, there is no official standard for the <code>package.json</code> file, but there are efforts to create<a id="_idIndexMarker325"/> it in the Standards Working Group from the OpenJS Foundation (<a href="https://github.com/openjs-foundation/standards/issues/233">https://github.com/openjs-foundation/standards/issues/233</a>).</p>
			<p>Currently, we can use the npm documentation to know what fields we can use in the <code>package.json</code> file. The documentation is available at <a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json">https://docs.npmjs.com/cli/v7/configuring-npm/package-json</a>.</p>
			<p>In the next sections, we will see some of the most important fields in the <code>package.json</code> file and how to use them in our projects.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor175"/>Choosing the correct dependencies for your project</h1>
			<p>It is true that the npm ecosystem is very<a id="_idIndexMarker326"/> solid and growing every day. But it is also true that many packages are not maintained anymore, or that include security vulnerabilities and performance issues.</p>
			<p>The community is aware of this and there are plenty of jokes and memes about this topic. For example, the following image:</p>
			<div><div><img src="img/B21678_06_01.jpg" alt="Figure 6.1 â€“ npm Delivery by MonkeyUser â€“ a classic meme that shows how many dependencies we tend to include in our projects (https://www.monkeyuser.com/2017/npm-delivery/)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 â€“ npm Delivery by MonkeyUser â€“ a classic meme that shows how many dependencies we tend to include in our projects (https://www.monkeyuser.com/2017/npm-delivery/)</p>
			<p>While this is a joke based on the huge number of dependencies and sub-dependencies that we install on an average project, it is true that we need to be careful when choosing the <a id="_idIndexMarker327"/>dependencies for our projects. In this section, we will see how to choose the correct dependencies for our projects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Most modules depend on other modules, and those modules depend on other modules, and so on. This is<a id="_idIndexMarker328"/> called the <strong class="bold">dependency tree</strong>. When we install a module, we are installing all the dependencies of that module, and all the dependencies of the dependencies, and so on. This is why it is important to choose the correct dependencies for our projects.</p>
			<p>Before choosing a<a id="_idIndexMarker329"/> dependency, we need to ask ourselves the following questions:</p>
			<ul>
				<li>What are the risks associated with choosing a bad dependency?</li>
				<li>What are the criteria that I should use to choose a dependency?</li>
			</ul>
			<p>Letâ€™s see the answers to these questions!</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor176"/>Risks</h2>
			<p>In our modern world, we are used to<a id="_idIndexMarker330"/> using dependencies. It will be very hard or directly impossible to build modern web applications without using dependencies.</p>
			<p>When we choose a dependency, we are taking a risk. Letâ€™s see what the main risks associated with choosing a bad dependency are:</p>
			<ul>
				<li><strong class="bold">Security vulnerabilities</strong>: A dependency can have security vulnerabilities or even be a malicious piece of code.</li>
				<li><strong class="bold">Performance issues</strong>: A dependency can have performance issues and generate memory leaks that can affect the performance of our application and even crash it.</li>
				<li><strong class="bold">Maintenance issues</strong>: A dependency cannot be maintained anymore, and it can be deprecated in the future. This can cause our application to stop working in the future or prevent us from upgrading other dependencies or Node.js itself.</li>
			</ul>
			<p>In 2020, I published a controversial blog post called <em class="italic">What is a backdoor?</em> <em class="italic">Letâ€™s build one with Node.js</em> (<a href="https://snyk.io/blog/what-is-a-backdoor/">https://snyk.io/blog/what-is-a-backdoor/</a>). In that blog post, I explained that a backdoor is a piece of code that<a id="_idIndexMarker331"/> allows us to access a system without going through the authentication process. I also explained how to build a backdoor with Node.js using a few lines of code and I demonstrated how easy was to publish and distribute a malicious package.</p>
			<p>I know that security is a very sensitive topic, especially if you are starting your journey in web development. <a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a> of this book is dedicated to security, and we will explore security in depth there.</p>
			<p>In order to minimize the<a id="_idIndexMarker332"/> risks, we need to choose the correct dependencies for our projects. Letâ€™s see how to do that.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor177"/>Good criteria</h2>
			<p>There are many criteria that we can use to choose the correct dependencies for our projects. In this section, we <a id="_idIndexMarker333"/>will see some of the most important ones.</p>
			<h3>What are we trying to avoid?</h3>
			<p>We try to avoid the following things:</p>
			<ul>
				<li>Packages that are not maintained anymore</li>
				<li>Packages that have known security vulnerabilities and are not patched</li>
				<li>Packages that depend on a lot of packages or have low-quality dependencies</li>
				<li>Packages that are not popular or are low quality</li>
				<li>Packages with license issues</li>
			</ul>
			<h3>What evidence do we have?</h3>
			<p>We are going to do some basic OSINT before we install any package, and we are going to check two data sources in detail: the npm website and the GitHub or code repository.</p>
			<p class="author-quote">OSINT is intelligence produced by collecting and analyzing public information with the purpose of answering a specific intelligence question. (Ritu Gill, <a href="https://www.sans.org/blog/what-is-open-source-intelligence/">https://www.sans.org/blog/what-is-open-source-intelligence/</a>.)</p>
			<h3>Real example</h3>
			<p>In this book, we are going to use the Express library. Express is a very popular library for Node.js, and it is used to build web applications and APIs. In this image, we can see in detail how the Express library is showcased on the npm website:</p>
			<div><div><img src="img/B21678_06_02.jpg" alt="Figure 6.2 â€“ Express library package in npm (https://www.npmjs.com/package/express)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 â€“ Express library package in npm (https://www.npmjs.com/package/express)</p>
			<p>From the npm website, we<a id="_idIndexMarker334"/> can see the following information:</p>
			<ul>
				<li>There are 31 dependencies, most of which are very popular and well-maintained by the same Express maintainers</li>
				<li>There are +77k dependents, which means that many other package authors are using Express in their projects</li>
				<li>There are 271 versions published</li>
				<li>There are almost 31M weekly downloads, which means that Express is a very popular package for the Node.js community</li>
				<li>An MIT license, which is a permissive license and valid as open source</li>
				<li>Clear and solid documentation</li>
				<li>It was last published few days ago, which means that the package is maintained and updated regularly</li>
			</ul>
			<p>From npm, we can access the GitHub repository of the package. In the following image, we can see in<a id="_idIndexMarker335"/> detail how the Express library is showcased on the GitHub website:</p>
			<div><div><img src="img/B21678_06_03.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 â€“ Express library repository in GitHub (https://github.com/expressjs/express)</p>
			<p>From the GitHub website, we can see the following information:</p>
			<ul>
				<li>It has +10k forks, which means that many other developers are contributing to the project</li>
				<li>It has +60k stars, which means that the project is popular in the community</li>
				<li>It has +5k commits, which means that the project has a long history</li>
				<li>It has +3k issues closed, +120 issues open, +1k pull requests closed, and +60 pull requests open, which means that the project is active</li>
				<li>It has almost 300 contributors, which means that many other developers are contributing to the project and evolving it</li>
			</ul>
			<p>As we can see, we have a lot of information from the npm website and the GitHub repository at least to<a id="_idIndexMarker336"/> make a first decision, especially if we want to compare several packages. The offer is huge and sometimes it is difficult to choose the correct package.</p>
			<h3>Exceptions to the rules</h3>
			<p>We need to be quite flexible with the rules that we have seen before because very often we can find exceptions to the rules.</p>
			<p>For example, johnny-five (<a href="https://www.npmjs.com/package/johnny-five">https://www.npmjs.com/package/johnny-five</a>) is a great library to use when working with Arduino and Raspberry Pi in Node.js. But the total download per week is very low. In this case, we need to consider that there are much less developers working with Arduino and Raspberry Pi than developers working with Express, for example.</p>
			<p>Another example is Lodash (<a href="https://www.npmjs.com/package/lodash">https://www.npmjs.com/package/lodash</a>), which is a very popular library and is used by many other packages. But the last version was published three years ago. In this case, we need to consider that the project is mostly completed, and it is not evolving anymore and only making new releases when needed.</p>
			<h3>Deprecation notices</h3>
			<p>Sometimes, we can find a package that is deprecated. In this case, we should avoid using it. We can find a deprecation notice in the npm website, in the GitHub repository, or when we install the package.</p>
			<div><div><img src="img/B21678_06_04.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 â€“ Image from the npm documentation that shows how the deprecation warnings are shown in npm (https://docs.npmjs.com/packages-and-modules/updating-and-managing-your-published-packages/deprecate-package.png)</p>
			<p>Very often, in the<a id="_idIndexMarker337"/> deprecation notice, we can find a recommendation to use another package. In this case, we should follow the recommendation.</p>
			<h3>Tooling</h3>
			<p>In the previous OSINT analysis, we answered most of our questions, but we didnâ€™t answer questions <a id="_idIndexMarker338"/>regarding known vulnerabilities. These days, I use two tools to check known vulnerabilities: <em class="italic">Snyk</em> (<a href="https://snyk.io/">https://snyk.io/</a>) and <em class="italic">socket.dev</em> (<a href="https://socket.dev/">https://socket.dev/</a>).</p>
			<p>In <a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>, we will see <a id="_idIndexMarker339"/>how they are used in detail. In order to use these tools properly, you will need to understand how the dependency tree works and how the vulnerabilities are classified. Otherwise, these tools can be very confusing for beginners.</p>
			<p>I will suggest to say "In the next section, we will learn how to install the dependencies in our projects.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor178"/>Installing dependencies</h1>
			<p>Now that we know how to <a id="_idIndexMarker340"/>choose the correct dependencies for our projects, and we have a <code>package.json</code> we can start installing our dependencies.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor179"/>Locally or globally</h2>
			<p>We can install dependencies in two ways: locally or globally:</p>
			<ul>
				<li><code>node_modules</code> folder of our project. For example, <code>express</code> is a local dependency of our application.</li>
				<li><strong class="bold">Globally</strong>: These are dependencies that are installed in the global folder of our system, so they become available from anywhere in our system, such as Node.js binary, which is available as soon as we open the terminal.</li>
			</ul>
			<p>We would prefer to install dependencies locally because it is easier to manage the dependencies of our project and to avoid conflicts between different projects. We will install dependencies globally only when it is strictly necessary.</p>
			<p>One example of a dependency that we will install globally is <code>yeoman</code>, a scaffolding tool, which we will use to generate a new project.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor180"/>Dependency or development dependency</h2>
			<p>We can install the local dependencies<a id="_idIndexMarker342"/> in two ways: as a dependency or as a development dependency:</p>
			<ul>
				<li><code>express</code> is a dependency of our application.</li>
				<li><code>standard</code>, which is a linter library, will be used only while developing the code but not when running.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There is an additional mode to install <a id="_idIndexMarker343"/>dependencies: <strong class="bold">peer dependencies</strong>. We will not cover this mode in this book, but you can find more information and use cases in this blog post: <a href="https://nodejs.org/en/blog/npm/peer-dependencies">https://nodejs.org/en/blog/npm/peer-dependencies</a>.</p>
			<p>The segmentation of dependencies is very important because it allows us to install only the dependencies that we need in each environment and to reduce the size of our application and attack surface.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor181"/>Adding new dependency</h2>
			<p>For example, if we want to<a id="_idIndexMarker344"/> install the <code>express</code> package, we can use the following command:</p>
			<pre class="console">
# npm install &lt;package-name&gt;
npm install express</pre>			<p>We can install the <code>standard</code> package as a development dependency. Development dependencies are those dependencies that we need when we are actually coding the project, but they are not used when the project is being deployed or distributed as a library. As <code>standard</code> is a linting tool, we will use it only when adding or changing code, but we wonâ€™t use it while the application is running. This segmentation of the dependencies has a lot of benefits as our final applications will be smaller (ignoring the development dependencies) and more secure as we have less external code. We can use the <code>-D</code> or <code>--save-dev</code> for installing development dependencies arguments:</p>
			<pre class="console">
# npm install --save-dev &lt;package-name&gt;
# npm installÂ Â -D &lt;package-name&gt;
npm install --save-dev standard</pre>			<p>We can see that the <code>package.json</code> file has been updated with the new dependencies in two different sections: <code>dependencies</code> and <code>devDependencies</code>:</p>
			<pre class="source-code">
{
Â Â "dependencies": {
Â Â Â Â "express": "^4.18.3"
Â Â },
Â Â "devDependencies": {
Â Â Â Â "standard": "^17.1.0"
Â Â }
}</pre>			<p>One new file, <code>package-lock.json</code>, has also been added and the <code>node_modules</code> folder has been created with the dependencies structured in folders and files.</p>
			<p>We will explore in the next<a id="_idIndexMarker345"/> section how the <code>package-lock.json</code> file works.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>node_modules</code> should not be included with the project source code if you are using Git or any other system to distribute your source code. It is good practice to include the <code>node_modules</code> folder in the <code>.gitignore</code> file to avoid including it in the repository. If you need a solid <code>.gitignore</code> file for Node.js, you can generate one (<a href="https://www.toptal.com/developers/gitignore/api/node">https://www.toptal.com/developers/gitignore/api/node</a>). We should ignore <code>node_modules</code> because the folder can be huge, and have many files and a heavy weight, but also because we can install the dependencies at any time, as soon as we keep our changes in <code>package.log</code>, we will be able to install the correct dependencies</p>
			<p>Global dependencies are installed with the <code>-g</code> or <code>â€“</code><code>global</code> argument:</p>
			<pre class="console">
# npm install --global &lt;package-name&gt;
# npm install -g &lt;package-name&gt;
# Install yeoman globally
npm install --global yo</pre>			<p>You can see the list of global dependencies with the <code>list</code> or <code>ls</code> command:</p>
			<pre class="console">
# npm list --global
# npm ls --global
npm list --global</pre>			<p>The output of this command will be something like this:</p>
			<pre class="console">
/Users/ulises/.nvm/versions/node/v20.11.0/lib
â”œâ”€â”€ corepack@0.23.0
â”œâ”€â”€ npm@10.2.4
â””â”€â”€ yo@5.0.0</pre>			<h2 id="_idParaDest-175"><a id="_idTextAnchor182"/>Installing all the dependencies</h2>
			<p>If we want to install all the dependencies <a id="_idIndexMarker346"/>that are listed in the <code>package.json</code> file, we can use the <code>install</code> or <code>i</code> command without any argument:</p>
			<pre class="console">
npm install</pre>			<p>We can also use the <code>--only</code> argument to install only the dependencies or the development dependencies:</p>
			<pre class="console">
# Prod Only
npm install --only=prod
npm install --only=production
# Dev Only
npm install --only=dev
npm install --only=development</pre>			<p>In the production environments, we want to avoid using development tools because, although this will make our applications smaller and more secure, in our development environments we will require all the dependencies to properly do our job.</p>
			<p>In the next section, we will explore how to properly remove dependencies from our projects.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor183"/>Removing dependencies</h1>
			<p>You can remove a dependency<a id="_idIndexMarker347"/> using the <code>uninstall</code> command:</p>
			<pre class="console">
# npm uninstall &lt;package-name&gt;
npm uninstall express</pre>			<p>This command will remove the dependency from the <code>package.json</code> and <code>package-lock.json</code> files and the <code>node_modules</code> folder.</p>
			<p>Global dependencies are <a id="_idIndexMarker348"/>removed with the <code>-g</code> or <code>--</code><code>global</code> argument:</p>
			<pre class="console">
# npm uninstall --global &lt;package-name&gt;
# npm uninstall -g &lt;package-name&gt;
# Remove yeoman globally
npm uninstall --global yo</pre>			<p>In the next section we will explore how the <code>package-lock.json</code> file can help us to manage our dependencies.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor184"/>Understanding the package-lock.json</h1>
			<p>Historically, the <code>package.json</code> file was the only file that we needed to manage the dependencies of our project. But this file has a problem: it doesnâ€™t contain the exact version of each sub-dependency that we<a id="_idIndexMarker349"/> have installed in our project and was also quite slow to install the dependencies.</p>
			<p>Not having the exact version of each sub-dependency can be a problem because if we install the same dependency in two different environments, we can end up with different versions of the same dependency. The lack of immutability in our dependencies can lead to unexpected errors and bugs that are quite complicated to debug.</p>
			<p>Also, by default, when we install a dependency the version that is recorded in <code>package.json</code> includes a caret <code>^</code> symbol, such as <code>"express": "^4.18.3"</code>. This symbol means that we can install any version of the dependency that is compatible with the version that is recorded in <code>package.json</code>.</p>
			<p>The <code>package-lock.json</code> file is a file that is automatically generated when we install a new dependency and also speeds up the installation of the dependencies because it contains the exact version of each dependency and the source where it comes from.</p>
			<p>The file can be huge, but the structure per dependency is quite simple:</p>
			<pre class="source-code">
{
Â Â Â Â "node_modules/express/node_modules/debug": {
Â Â Â Â Â Â Â Â "version": "2.6.9",
Â Â Â Â Â Â Â Â "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
Â Â Â Â Â Â Â Â "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
Â Â Â Â Â Â Â Â "dependencies": {
Â Â Â Â Â Â Â Â Â Â Â Â "ms": "2.0.0"
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>			<p>As you can see, the exact <code>version</code> is included, as well as the <code>resolved</code> and <code>integrity</code> fields that are used to<a id="_idIndexMarker350"/> validate the origin of the dependency and to avoid manipulations with the data in transit as <code>integrity</code> provides a checksum. Also, the <code>dependencies</code> field is included to list the sub-dependencies with the exact version.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>package-lock.json</code> should be distributed with the source code of the project and should be committed to the repository; basically, it should be treated as <code>package.json</code> in terms of distribution.</p>
			<p>Now that we know how to classify and organize the dependencies in our projects, it is time to explore how to install specific versions and notice outdated dependencies.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor185"/>Managing dependencies versions</h1>
			<p>If we want to install a specific <a id="_idIndexMarker351"/>version of a package, we can use the @ symbol. You can be as specific as you want:</p>
			<pre class="console">
# npm install &lt;package-name&gt;@&lt;version&gt;
npm install express@4
npm install express@4.17
npm install express@4.17.1</pre>			<h2 id="_idParaDest-179"><a id="_idTextAnchor186"/>Outdated dependencies</h2>
			<p>Eventually, the dependencies that<a id="_idIndexMarker352"/> we have installed in our project will be outdated, and we will need to update them. To check if we have any outdated dependencies, we can use the <code>outdated</code> command:</p>
			<pre class="console">
npm outdated</pre>			<p>This command will list all the outdated dependencies, as well as the current version, the wanted version, and the latest version:</p>
			<pre class="console">
PackageÂ Â CurrentÂ Â WantedÂ Â LatestÂ Â LocationÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Depended by
expressÂ Â Â 3.21.2Â Â 3.21.2Â Â 4.18.3Â Â node_modules/expressÂ Â my-project</pre>			<p>Now that we are clear on how to handle outdated dependencies it is time to explore in the next section how to create isomorphic JavaScript code that can be executed in all environments (browsers and Node.js)</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor187"/>Building Isomorphic JavaScript</h1>
			<p>Isomorphic JavaScript is a<a id="_idIndexMarker353"/> term that is used to describe JavaScript code that can run both in the browser and in Node.js. In other words, it is a library that can be used in both environments. In order to do that, you will limit yourself to the features that are available in both environments.</p>
			<p>For example, you canâ€™t use the <code>fs</code> module in the browser, and you canâ€™t use the <code>window</code> object in Node.js.</p>
			<p>Sometimes, we install dependencies in our projects that are designed to be used in the browser and we try to <a id="_idIndexMarker354"/>use them in Node.js, and vice versa. This is a common mistake that we need to avoid.</p>
			<p>Most of the projects will specify which environment they are designed for. Here is an example from Lodash (<a href="https://lodash.com/">https://lodash.com/</a>):</p>
			<div><div><img src="img/B21678_06_05.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 â€“ Image from the Lodash documentation that explains in detail how to install the library in both environments (<a href="https://lodash.com/">https://lodash.com/</a>)</p>
			<p>It is quite clear that lodash is designed to be used in Node.js and in the browser, and from the figure you can see how to install it in each environment.</p>
			<p>In the next section, we will learn how we can use npm scripts to improve our developer experience while<a id="_idIndexMarker355"/> building Node.js projects.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor188"/>Using npm scripts</h1>
			<p>npm scripts are <a id="_idIndexMarker356"/>commands that we can define in the <code>package.json</code> file. These commands can be executed using the <code>run</code> command:</p>
			<pre class="console">
# npm run &lt;script-name&gt;
npm run lint</pre>			<p>This is great because we can define our own commands and we can use them to automate tasks. For example, we can define a command to run the linter in our project:</p>
			<pre class="source-code">
{
Â Â Â Â "scripts": {
Â Â Â Â Â Â Â Â "lint": "standard",
Â Â Â Â Â Â Â Â "lint:fix": "standard --fix"
Â Â Â Â },
Â Â Â Â "devDependencies": {
Â Â Â Â Â Â Â Â "standard": "^12.0.1"
Â Â Â Â }
}</pre>			<p>Then we can run the following command:</p>
			<pre class="console">
npm run lint
npm run lint:fix</pre>			<p>npm scripts are basically shortcuts to run commands that we can run manually in the terminal. So, you can build quite complex things such as starting/stopping a server, running tests, preparing infrastructure, and deploying your application.</p>
			<p>This is a very powerful feature that we can use to automate tasks in our projects, especially when we are<a id="_idIndexMarker357"/> working in a team, and we want to make sure that everyone is running the same commands or with continuous integration tools.</p>
			<p>We will use npm scripts in the next chapters to automate tasks in our projects.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor189"/>Executing packages directly with NPX</h1>
			<p>Since version 5.2.0, npm comes<a id="_idIndexMarker358"/> with a new tool called <code>npx</code>, which allows us to execute packages without installing them globally. This is great for one-time commands.</p>
			<p>Letâ€™s say that we have a project with outdated dependencies, and we want to update them:</p>
			<pre class="source-code">
{
Â Â "dependencies": {
Â Â Â Â "express": "^3.21.2",
Â Â Â Â "lodash": "^1.3.1"
Â Â },
Â Â "devDependencies": {
Â Â Â Â "standard": "^17.1.0"
Â Â }
}</pre>			<p>As we saw in the previous section, we can use the <code>npm outdated</code> command to check which dependencies are outdated, but the upgrade process is a bit more complex as we need to upgrade each dependency manually or modify the <code>package.json</code> directly.</p>
			<p>Fortunately, there is a package called npm-check-updates (<a href="https://www.npmjs.com/package/npm-check-updates">https://www.npmjs.com/package/npm-check-updates</a>), which allows us to upgrade all the dependencies in our project. Letâ€™s learn how to use it:</p>
			<pre class="console">
npx npm-check-updates</pre>			<p>This command will list all the outdated dependencies, and will show the new version that is available:</p>
			<pre class="console">
expressÂ Â ^3.21.2Â Â â†’Â Â Â ^4.18.3
lodashÂ Â Â Â ^1.3.1Â Â â†’Â Â ^4.17.21</pre>			<p>Then we can use the <code>-u</code> flag to<a id="_idIndexMarker359"/> upgrade all the dependencies:</p>
			<pre class="console">
npx npm-check-updates â€“u</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The <code>npm-check-updates</code> package offers a lot of options to customize the upgrade process, you can check the documentation at <a href="https://www.npmjs.com/package/npm-check-updates">https://www.npmjs.com/package/npm-check-updates</a> for more information.</p>
			<p>The dependencies were upgraded in <code>package.json</code>, we just need to run <code>npm install</code> to make the changes take effect:</p>
			<pre class="source-code">
{
Â Â "dependencies": {
Â Â Â Â "express": "^4.18.3",
Â Â Â Â "lodash": "^4.17.21"
Â Â },
Â Â "devDependencies": {
Â Â Â Â "standard": "^17.1.0"
Â Â }
}</pre>			<p>Now, we can take an extra step and automate this process using npm scripts, so in the future, we can speed up this process, and we do this just by adding the following scripts to your <code>package.json</code> file:</p>
			<pre class="source-code">
{
Â Â Â Â "scripts": {
Â Â Â Â Â Â Â Â "deps:check": "npx npm-check-updates",
Â Â Â Â Â Â Â Â "deps:upgrade": "npx npm-check-updates -u &amp;&amp; npm install"
Â Â Â Â }
}</pre>			<p>This was a great example of<a id="_idIndexMarker360"/> how you can combine npm scripts and npx to automate tasks in your projects and increase the developer experience for other contributors as they can run the same command to upgrade the dependencies when needed.</p>
			<p>Also, this combination is great for continuous integration tools, as you can run the same commands in your CI pipeline.</p>
			<p>But the most important thing is that you donâ€™t need to install any global or local packages, so you keep your dependencies to a minimum.</p>
			<p>In the next section we are going to learn more about the current alternatives to npm.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor190"/>npm alternatives</h1>
			<p>Over the years, npm has become the standard <a id="_idIndexMarker361"/>package manager for JavaScript, but there are other alternatives that you can use in your projects.</p>
			<p>Most of the alternatives are compatible with the npm registry, so you can use the same packages that you use with npm and you can switch between them without any problem.</p>
			<p>Each alternative has its own advantages and disadvantages, so you need to evaluate which one is the best for your project. Most of the time, npm will be the best option, but it is good to know that there are other alternatives designed to solve very specific scenarios.</p>
			<p>Letâ€™s introduce some of them:</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor191"/>Yarn</h2>
			<p><strong class="bold">Yarn</strong> (<a href="https://yarnpkg.com/">https://yarnpkg.com/</a>) is a package <a id="_idIndexMarker362"/>manager created by Facebook and released<a id="_idIndexMarker363"/> in 2016. It was created to solve some specific problems that npm had at that time, but over the years, npm has improved a lot and it has solved most of the problems that Yarn solved originally.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor192"/>PNPM</h2>
			<p><code>node_modules</code> folder, it creates a single folder for all the dependencies in the project. This approach has some advantages such as disk space usage and network usage.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor193"/>Verdaccio</h2>
			<p><strong class="bold">Verdaccio</strong> (<a href="https://verdaccio.org/">https://verdaccio.org/</a>) is a private npm registry that you can use to host your own packages. This is great if you <a id="_idIndexMarker366"/>want to have a private registry for your <a id="_idIndexMarker367"/>company or if you want to have a mirror of the npm registry.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Verdaccio is a great tool if you have connectivity issues or if you want to experiment with the npm registry before publishing the packages.</p>
			<p>In the next section we will learn how to publish and distribute our own packages so we can re-use our code across projects. Also, other developers can use the libraries that we built.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor194"/>Publishing your first package</h1>
			<p>We have seen how to install packages from the npm registry, but we can also publish our own packages. This is great if we want to share our code with other developers or if we want to reuse our code in other projects.</p>
			<p>So, letâ€™s see how to publish our first<a id="_idIndexMarker368"/> package in the npm registry.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor195"/>Registries</h2>
			<p>Before we start, we need to understand how the npm registry works. The npm registry is a public repository where all the <a id="_idIndexMarker369"/>packages are stored. This is the default registry that npm uses, but you can also use other registries such as Verdaccio (<a href="https://verdaccio.org/">https://verdaccio.org/</a>) or GitHub Packages (<a href="https://github.com/features/packages">https://github.com/features/packages</a>).</p>
			<p>We will use the npm registry in this chapter, but the process is very similar for other registries. Some developers publish their packages in multiple registries, so you can choose the one that you prefer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to publish a private package, it is more common to use a private registry such as Verdaccio or GitHub <a id="_idIndexMarker370"/>Packages, but if you want to publish a public package, the npm registry is the best option.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor196"/>npm account</h2>
			<p>Before we can publish our <a id="_idIndexMarker371"/>packages, we need to create an account in the npm registry. You can create an account on the npm website (<a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a>) by following the steps in the next section (<a href="https://docs.npmjs.com/creating-a-new-npm-user-account">https://docs.npmjs.com/creating-a-new-npm-user-account</a>).</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor197"/>Prepare the package</h2>
			<p>So, letâ€™s start by creating a new folder for our <a id="_idIndexMarker372"/>package with the name <code>my-first-package</code>.</p>
			<p>We will create a <code>package.json</code> file with the following content:</p>
			<pre class="source-code">
{
Â Â "name": "@USERNAME/demo-package",
Â Â "version": "1.0.0",
Â Â "description": "Sample package: Node.js for beginners",
Â Â "main": "index.mjs",
Â Â "scripts": {
Â Â Â Â "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
Â Â },
Â Â "author": "YOUR NAME",
Â Â "license": "MIT"
}</pre>			<p>You will need to replace <code>@USERNAME</code> with your npm username, which is <code>@ulisesgascon</code> in my case, and also change the <code>author</code> field with your name.</p>
			<p>Then, we will create an <code>index.mjs</code> file with<a id="_idIndexMarker373"/> the following content:</p>
			<pre class="source-code">
function sum(a, b) {
Â Â return a + b
}
export { sum }</pre>			<p>The last step is to include a <code>README.md</code> file with some information about the package:</p>
			<pre class="source-code">
# Sample package: Node.js for beginners
This is a sample package to learn how to publish packages in npm.
## Installation
```bash
npm install @USERNAME/demo-package
```
## Usage
```js
import { sum } from '@USERNAME/demo-package'
console.log(sum(1, 2))
```</pre>			<p>Replace <code>@USERNAME</code> with your npm<a id="_idIndexMarker374"/> username as we did previously with the <code>package.json</code>.</p>
			<p>This is a very simple package, but it is enough to show how to publish a package in the npm registry.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor198"/>Reviewing the package</h2>
			<p>Now that we have our package ready, we<a id="_idIndexMarker375"/> can publish it in the npm registry. To do that, we need to run the following command in the terminal:</p>
			<pre class="console">
npm publish --dry-run</pre>			<p>The <code>--dry-run</code> flag is optional, but it is a good idea to use it the first time to see what is going to happen. This command will show you the files that are going to be published and some information about the package.</p>
			<pre class="console">
npm notice
npm notice ðŸ“¦Â Â @ulisesgascon/demo-package@1.0.0
npm notice === Tarball Contents ===
npm notice 188B .vscode/settings.json
npm notice 267B README.md
npm notice 55BÂ Â index.mjs
npm notice 272B package.json
npm notice === Tarball Details ===
npm notice name:Â Â Â Â Â Â Â Â Â Â @ulisesgascon/demo-package
npm notice version:Â Â Â Â Â Â Â 1.0.0
npm notice filename:Â Â Â Â Â Â ulisesgascon-demo-package-1.0.0.tgz
npm notice package size:Â Â 617 B
npm notice unpacked size: 782 B
npm notice shasum:Â Â Â Â Â Â Â Â cb55a05cdfb52f9dbd4b074d4940bfb5ad698d8f
npm notice integrity:Â Â Â Â Â sha512-MDdDzLyysuWJS[...]H92x5C6Vvi0iA==
npm notice total files:Â Â Â 4
npm notice
npm notice Publishing to https: //registry. npmjs. org/ with tag latest and default access (dry-run)
+ @ulisesgascon/demo-package@1.0.0</pre>			<p>As you can see, there is a file that is not needed, the <code>.vscode/settings.json</code> file. This file is used by Visual <a id="_idIndexMarker376"/>Studio Code to configure the editor, but it is not needed in the package. We can remove it by adding a <code>.npmignore</code> file with the following content:</p>
			<pre class="source-code">
.vscode</pre>			<p>This file will tell npm to ignore the <code>.vscode</code> folder when publishing the package. If you run the command again, you will see that the file is not included in the package:</p>
			<pre class="console">
npm notice === Tarball Contents ===
npm notice 267B README.md
npm notice 55BÂ Â index.mjs
npm notice 272B package.json
npm notice === Tarball Details ===</pre>			<h2 id="_idParaDest-192"><a id="_idTextAnchor199"/>Publish the package</h2>
			<p>Now that we have our package<a id="_idIndexMarker377"/> ready, we can publish it in the npm registry. To do that, we need to run the following command in the terminal:</p>
			<pre class="console">
npm publish --access public</pre>			<p>The <code>--access public</code> flag makes this package available to the world, so anyone with internet access can download your package.</p>
			<p>You can see in the output that the package is published in the npm registry:</p>
			<pre class="console">
npm notice
npm notice Publishing to https: //registry. npmjs. org/ with tag latest and public access
+ @ulisesgascon/demo-package@1.0.0</pre>			<p>Now, if you go to the npm website (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>) and search for your package, you will see it in the search results. You can also access the package page directly using the following URL: <code>https://www.npmjs.com/package/@USERNAME/demo-package</code> (replace <code>@USERNAME</code> with your npm username, which is <code>@ulisesgascon</code> in my case).</p>
			<div><div><img src="img/B21678_06_06.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 â€“ The published package in the npm registry</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor200"/>Avoid the scoped packages</h2>
			<p>It is possible to publish packages without a scope in the npm registry, but it is difficult to find a name that is not already taken. For that reason, it is a good idea to use the scoped packages, such as <code>@ulisesgascon/demo-package</code> in our case.</p>
			<p>But nothing stops you from publishing a <a id="_idIndexMarker378"/>package without a scope such as <code>my-great-demo-package</code> if the name is not already taken. But if you do that, you will need to be careful with the name, because once you publish a package, you canâ€™t change the name. So, if you want to change the name, you will need to publish a new package with the new name and deprecate the old one.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor201"/>Release new versions</h2>
			<p>Letâ€™s make some changes to improve <a id="_idIndexMarker379"/>our package. We will add a new <code>multiply</code> function to the <code>index.mjs</code> file:</p>
			<pre class="source-code">
function sum(a, b) {
Â Â Â Â return a + b
}
function multiply(a, b) {
Â Â Â Â return a * b
}
export { sum, multiply }</pre>			<p>We will also include it in the <code>README.md</code> file:</p>
			<pre class="source-code">
## Usage
```js
import { sum, multiply } from '@ulisesgascon/demo-package'
console.log(sum(1, 2))
console.log(multiply(5, 2))
```</pre>			<p>Now, we are ready to <a id="_idIndexMarker380"/>publish again the package using <code>npm publish --access public</code> again, but there is an error:</p>
			<pre class="console">
npm notice Publishing to https: //registry. npmjs. org/
npm ERR! code E403
npm ERR! 403 403 Forbidden - PUT https: //registry .npmjs. org/@ulisesgascon %2fdemo-package - You cannot publish over the previously published versions: 1.0.0.</pre>			<p>We forgot to change the version number in the <code>package.json</code> file, so we need to do that before publishing the package again. We should always follow semantic versioning (<a href="https://semver.org/">https://semver.org/</a>), so in this case we will change the version number to <code>1.1.0</code> as it is a minor change, we<a id="_idIndexMarker381"/> can make this change using the <code>npm version minor </code>command and as a result, we can see that <code>package.json</code> has been updated as expected:</p>
			<pre class="source-code">
{
Â Â "version": "1.1.0",
}</pre>			<p>Now, we can publish the package again and we will see the new version on the npm website and in the terminal:</p>
			<pre class="console">
npm notice
npm notice Publishing to https: //registry. npmjs. org/
+ @ulisesgascon /demo-package @1.1.0</pre>			<p>If we check the npm URL again, we can see the new version available and the changes we made:</p>
			<div><div><img src="img/B21678_06_07.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 â€“ The published package updated in npm</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor202"/>Prevent accidental publishing</h2>
			<p>While not very common, it is <a id="_idIndexMarker382"/>possible to publish a package by mistake, so it is a good idea to prevent that by adding the <code>private</code> flag to the <code>package.json</code> file if you donâ€™t plan to publish the package:</p>
			<pre class="source-code">
{
Â Â "private": true
}</pre>			<h2 id="_idParaDest-196"><a id="_idTextAnchor203"/>Best practices</h2>
			<p>Now that we know how to create and publish a package, it is time to talk about quality. The best packages<a id="_idIndexMarker383"/> have a high-level standard and follow the best practices.</p>
			<p>Some of the best practices are quite advanced, so we will not cover them in this book, but here are two great resources to learn more about them:</p>
			<ul>
				<li>Best practices for creating a modern npm package with security in mind (<a href="https://snyk.io/blog/best-practices-create-modern-npm-package/">https://snyk.io/blog/best-practices-create-modern-npm-package/</a>)</li>
				<li>10 npm Security Best Practices (<a href="https://snyk.io/blog/ten-npm-security-best-practices/">https://snyk.io/blog/ten-npm-security-best-practices/</a>)</li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor204"/>Summary</h1>
			<p>In this chapter, we explored how to create a package from scratch, and how to install and maintain our dependencies over time. We learned how to use the <code>package.json</code> file to manage our dependencies, and how to use the <code>package-lock.json</code> file to lock the dependencies versions.</p>
			<p>Additionally, we learned how to use npm scripts to automate tasks, and how to use global dependencies and <code>npx</code> to run commands without installing them globally.</p>
			<p>Finally, we learned how to create our own packages and publish them in the npm registry, and how to update them over time.</p>
			<p>In the next chapter, we will learn how to take advantage of the event-driven architecture in Node.js to create our own events and listen to them, and how core libraries such as HTTP use events to notify us about incoming requests and much more. We will build our first web server using the HTTP library.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor205"/>Further reading</h1>
			<ul>
				<li><em class="italic">Happy Developers, Healthy Modules - Together We Can Do This - Michael Dawson, </em><em class="italic">IBM</em> (<a href="https://www.youtube.com/watch?v=e7tj_IbHEF4">https://www.youtube.com/watch?v=e7tj_IbHEF4</a>)</li>
				<li><em class="italic">What is npm, and why do we need it? | Tutorial for </em><em class="italic">beginners</em> (<a href="https://www.youtube.com/watch?v=P3aKRdUyr0s">https://www.youtube.com/watch?v=P3aKRdUyr0s</a>)</li>
				<li><em class="italic">Package.json vs </em><em class="italic">Package-lock.json</em> (<a href="https://www.atatus.com/blog/package-json-vs-package-lock-json/">https://www.atatus.com/blog/package-json-vs-package-lock-json/</a>)</li>
				<li><em class="italic">Best practices for creating a modern npm package with security in </em><em class="italic">mind </em>(<a href="https://snyk.io/blog/best-practices-create-modern-npm-package/">https://snyk.io/blog/best-practices-create-modern-npm-package/</a>)</li>
				<li><em class="italic">What is a backdoor? Letâ€™s build one with </em><em class="italic">Node.js</em> (<a href="https://snyk.io/blog/what-is-a-backdoor/">https://snyk.io/blog/what-is-a-backdoor/</a>)</li>
				<li><em class="italic">Juan Picado @ NodeTLV 22 - Deep dive into Verdaccio, a lightweight Node.js </em><em class="italic">registry</em> (<a href="https://www.youtube.com/watch?v=qRMucS3i3kQ&amp;">https://www.youtube.com/watch?v=qRMucS3i3kQ&amp;</a>)</li>
				<li><em class="italic">Isaac Schlueter: How npm </em><em class="italic">Works</em> (<a href="https://www.youtube.com/watch?v=ShRDgdvlZQ8">https://www.youtube.com/watch?v=ShRDgdvlZQ8</a>)</li>
				<li><em class="italic">Leveling up Monorepos with npm Workspaces - Ruy Adorno, DevOps.js Conference </em><em class="italic">2022</em> (<a href="https://www.youtube.com/watch?v=A-pWrajferM">https://www.youtube.com/watch?v=A-pWrajferM</a>)</li>
				<li><em class="italic">Ashley Williams | You donâ€™t know </em><em class="italic">npm</em> (<a href="https://www.youtube.com/watch?v=g3_e5Sp9vd4">https://www.youtube.com/watch?v=g3_e5Sp9vd4</a>)</li>
			</ul>
		</div>
	</body></html>