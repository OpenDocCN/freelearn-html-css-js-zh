- en: Restful API Design Guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a catalog module that exposed functions
    for data manipulation for the items in the catalog application. These functions
    made use of the `express.js` **request** object to parse the incoming data in
    the body and then to carry out the appropriate database operation. Each function
    populated the **response** object with a relevant status code and response body
    payload, if needed. Finally, we bound each function to a route, accepting HTTP
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to look closer into the URLs of the routes and into the returned
    HTTP status codes per operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint URLs and HTTP status codes best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensibility and versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint URLs and HTTP status codes best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each RESTful API operation is a combination of an HTTP request against a URL
    and an appropriate HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: When executed, each operation will return a status code, indicating whether
    the invocation has been successful or not. Successful invocation is indicated
    by a HTTP 2XX status code, while operations that are not executed correctly indicate
    this with erroneous status code—4XX if the error is at client side, or 5xx when
    the server fails to process a valid request.
  prefs: []
  type: TYPE_NORMAL
- en: Having a well-specified API is vital for its adoption. Such specification should
    not only completely enumerate the status codes of each operation, but should also
    specify the expected data format, that is, its supported media types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table defines how the Express.js Router will expose the API operations,
    and it should serve as a reference specification for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | URI | Media type | Description | Status Code |'
  prefs: []
  type: TYPE_TB
- en: '| GET | /catalog | application/json | Returns all the items in the catalog.
    | 200 OK500 Internal Server Error |'
  prefs: []
  type: TYPE_TB
- en: '| GET | /catalog/{categoryId} | application/json | Returns all items for the
    selected category. If the category does not exist, it returns 404. | 200 OK,404
    NOT FOUND500 Internal Server Error |'
  prefs: []
  type: TYPE_TB
- en: '| GET | /item/{itemId} | application/json | Returns a single item for the selected
    itemId. If there is no such item, it returns 404. | 200 OK,404 NOT FOUND500 Internal
    Server Error |'
  prefs: []
  type: TYPE_TB
- en: '| POST | /item/ | application/json | Creates a new item; if an item with the
    same identifier exists, it will be updated. When an item is created, a **Location**
    header is returned. It provides the URL where the newly created item can be accessed.
    | 201 Created200 OK500 Internal Server Error |'
  prefs: []
  type: TYPE_TB
- en: '| PUT | /item/{itemId} | application/json | Updates an existing item; if an
    item with the provided identifier does not exist, it creates it. When an item
    is created, a **Location** header is returned. It provides the URL where the newly
    created item can be accessed. | 201 Created200 OK500 Internal Server Error |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | /item/{itemId} | application/json | Deletes an existing item; if
    an item with the provided identifier does not exist, it returns 404. | 200 OK,404
    NOT FOUND500 Internal Server Error |'
  prefs: []
  type: TYPE_TB
- en: 'The catalog application handles two types of entities: items and categories.
    Each item entity contains a collection of categories where it belongs. As you
    can see, the category is just a logical entity in our application; it will exist
    as long as there is at least one item referencing it, and will cease to exist
    when no items refer it. This is why the application exposes routes for exposing
    data manipulation functions only for resources of type items, while the operations
    for categories are more or less read only. Looking more carefully into the URLs
    exposing the data manipulation operations for the items, we can see a clear pattern
    aligning the URL to the REST fundamental principles—a resource is exposed by a
    single URL, and it supports resource manipulation actions that are determined
    by the HTTP method of the request. To sum up, listed here are the generally accepted
    rules that a well-defined API should follow. They are semantically related to
    each resource manipulation operation:'
  prefs: []
  type: TYPE_NORMAL
- en: When a **new** resource is created, the service makes use of the **201 Created** status
    code, followed by a location header that specifies the URL where the newly created
    resource can be accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation that creates resources may be implemented to gracefully reject creation
    of resources, which unique identifiers already use; in such cases, the operation
    should indicate a non-successful invocation with an appropriate status code **409
    Conflict**, or a more general **400 BAD REQUEST**. However, a general status code
    should always be followed by a meaningful explanation of what has gone wrong.
    In our implementation, we choose a different approach—we update the resource from
    the create operation, if it exists, and notify the caller that the resource was
    updated by returning the **200 OK** status code instead of **201 Created**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Update** operation resembles the create operation; however, it always
    expects a resource identifier as a parameter, if a resource with this identifier
    exists—it gets updated with a new state provided in the body of the HTTP PUT request.
    The **200 OK** status code indicates successful invocation. The implementation
    may decide to reject handling of non-existent resources with the **404 Not Found** status
    code or creating a new resource with the passed identifier. In that case, it would
    return the **201 Created** status code, followed by a location header that specifies
    the URL where the newly created resource can be accessed. Our API makes use of
    the second option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While successful **deletion **can be indicated with the **204 No Content** status and
    further payload, most user agents would expect the **2xx** HTTP status to be followed
    by a body. Thus, to stay compatible with most of the agents, our API will indicate
    successful deletion with the **200 OK** status code, followed by a JSON payload:`{''Status'':
    ''Successfully deleted''}`. Status code **404 Not found** will indicate that a
    resource with the provided identifier does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, **5XX** should not indicate application state errors but
    more severe errors, such as application server or database failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is best practice that `update` and `create` operations should return as a
    payload to the entire state of the resource. For instance, if a resource is created
    with a minimum set of attributes, all non specified attribute will get default
    values; the response body should contain the full state of the object. The same
    is valid for updates; even if an update operation updates the resource restate
    partially, the response should return the complete state. This may save the user-agent
    an additional GET request if they needed to check the new state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined some general recommendations on how operations should
    behave, it's time to implement them in a new version of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering and exploring RESTful services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of discovering RESTful services has a long and complicated history.
    The HTTP specification states that a resource should be self-descriptive and that
    it should be identified uniquely by a URI. Dependent resources should be linked
    by the dependency using their own unique URIs. Discovering a RESTful service means
    navigating from one service to another, following the links it provides.
  prefs: []
  type: TYPE_NORMAL
- en: In the year 2009, a specification called **Web Application Discovery Language**
    (**WADL**) was invented. It aims to document every URI exposed from a web application,
    along with the HTTP methods it supports and the parameter it expects. The response
    media type of the URI is also described. This is very useful for documenting purposes,
    and it's all that a WADL file can provide us in terms of RESTful service provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there is currently no Node.js module that can automatically generate
    a WADL file for a given express route. We will have to manually create a WADL
    file to demonstrate how it is used by other clients for discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows a sample WADL file describing the resources available
    at `/catalog, /catalog/v2/{categoryId}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the WADL format is very straightforward. It basically describes
    the URI of each resource, providing information about the media types it uses
    and the status codes that are expected at that URI. Many third-party RESTful clients
    understand the WADL language and can generate request messages out of a given
    WADL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the WADL file in Postman. Click on the Import button and select
    your WADL file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8accb0-6e40-4112-ac97-769cdac28d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Import a WADL in Postman to get a stub of the service. This is a screenshot
    for Postman. The individual settings are not important here. The purpose of the
    image is just to show how the window looks.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the result of importing the WADL file is that we have a project
    ready to test each aspect of a REST service in the nick of time. All the routes
    defined in the WADL file are now conveniently available as separate request entities
    on the right menu. That's not all; apart from the WADL standard, currently the
    swagger documentation format is heavily adopted and has become an informal standard
    for describing RESTful services, so we can also use it to ease the adoption and
    discovery of our service. In the next chapter, we will bind these description
    files to our service. This is an important step in the phase of production preparation.
  prefs: []
  type: TYPE_NORMAL
- en: Extensibility and versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already defined a few basic versioning rules in [Chapter 13](8e04f868-a684-41a0-aed1-bbff8b9c5c2e.xhtml),
    *Building a Typical Web API*. Let's apply them to the MongoDB database-aware module
    we implemented in the previous chapter. Our starting point would be to enable
    the current consumers of the API to continue using the same version on a different
    URL. This will keep them backward-compatible until they adopt and successfully
    test the new version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping a REST API stable is not a question of only moving one endpoint from
    one URI to another. It makes no sense to perform redirection and afterward have
    an API that behaves differently. Thus, we need to ensure that the behavior of
    the moved endpoint stays the same. To ensure that we don''t change the previously
    implemented behavior, let''s move the current behavior from the `catalog.js` module
    to a new module by renaming the file to `catalogV1.js`. Then, make a copy of it
    to the  `catalogV2.js` module, where we will introduce all new functionality;
    but before doing that, we have to reroute Version 1 from `/, /{categoryId}, /{itemId}`
    to `/v1, /v1/{categoryId}, /v1/{itemId}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since Version 2 of our API is not yet implemented, executing a `GET` request
    against `/` will result in receiving a `301 Moved Permanently` HTTP status, which
    will then redirect to `/v1/`. This will notify our consumers that the API is evolving
    and that they will soon need to decide whether to continue using Version 1 by
    explicitly requesting its new URI or prepare for adopting Version 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and give it a try! Start the modified node application and, from Postman,
    make a GET request to `http://localhost:3000/catalog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5c50d84-3651-4d71-a52a-95d01d81602c.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see that your request is redirected to the newly routed location at `http://localhost:3000/catalog/v1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finalized Version 1 of the catalog, it's time to think of further
    extensions that we can add in Version 2\. Currently, the catalog service supports
    listing of all items in a category and fetching an item by its ID. It's about
    time to take full advantage of MongoDB, being a document-oriented database, and
    implement a function that will enable our API consumer to query for items based
    on any of their attributes. For instance, list all items for a specific category
    with an attribute that matches a query parameter, such as price or color, or search
    by item name. RESTful services usually expose document-oriented data. However,
    their usage is not limited to documents only. In the next chapter, we will extend
    the catalog in a way that it also stores binary data—an image that can be linked
    to each item. For that purpose, we will use a MongoDB binary format called **Binary
    JSON** (**BSON**) in the *Working with arbitrary data* section in [Chapter 16](92c4bc26-7983-4f36-b220-055f81dca007.xhtml),
    *Implementing a Full Fledged RESTful Service*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to the searching extension, we''ve already used the `Mongoose.js`
    model''s `find()` and `findOne()` functions. So far, we used them to provide the
    name of the document attribute to be searched with, statically, in our JavaScript
    code. However, this filtering parameter of `find()` is just a JSON object where
    the key is the document attribute and the value is the attribute''s value to be
    used in the query. Here is the first new function we will add to Version 2\. It
    queries MongoDB by an arbitrary attribute and its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function calls find on the model with the provided attribute and value
    as parameters. We will bind this function to the router's `/v2/item/` GET handler.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, our aim is to have `/v2/item/?currency=USD` that returns only records
    for items that are sold in USD currency, as indicated by the value of the passed
    GET parameter. That way, if we modify the model with additional attributes, such
    as color and size, we can query for all items having the same color or any other
    attribute that an item can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will keep the old behavior of returning a list of all available items when
    no parameters are provided within the query string, but we will also parse the
    query string for the first provided `GET` parameter and use it as a filter in
    the `findItemsByAttribute()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps the most interesting part in this function is the URL parsing. As you
    can see, we keep using the same old strategy to check whether any `GET` parameters
    are supplied. We parse the URL in order to get the query string, and then we use
    the built-in `Object.keys` function to check whether the parsed key/value list
    contains elements. If it does, we take the first element and extract its value.
    Both the key and the value are passed to the `findByAttribute` function.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to improve Version 2 further by providing search support by multiple
    arguments that are provided by more than one `GET` parameters. I will leave that
    to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Linked data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every catalog application supports an image or set of images bound to this
    item. For that purpose, in the next chapter, we will see how to work with binary
    objects in MongoDB. However, now is the time to decide how to semantically link
    the binary data to an item document. Extending the model schema in such a way
    that it contains binary base64 representation of binary data in the document is
    anything but a good idea, as mixing literally encoded and binary data in one format
    is never a good idea. It increases the complexity of the application and makes
    it error-prone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Imagine how large a result for a non-filtered query can become just for a few
    hundred items, if all of them had an image binary representation as a value of
    a JSON attribute. To avoid that, we will return the image for each item at a URL
    that is logically linked to the resource's URL—`/catalog/v2/item/{itemId}/image`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That way, if there is an image assigned to an item, it will be served at a
    known location. This approach, however, does not semantically link the binary
    item to its corresponding resource, as when accessing the item at `/catalog/v2/item/{itemId}`,
    there would be no indication of whether it has an image assigned or not. To solve
    this, let''s use a custom HTTP header in response of the item route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When present in the response, the `Image-Url` header indicates that the item
    has an additional resource bound to it, and the header value provides the address
    where it is available. Using this approach, we linked a binary resource semantically to
    our document.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement the routes that will handle the manipulation
    of arbitrary items bound to the items in the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed in detail how resources should be exposed via
    a RESTful API; we paid close attention to URL best practices and looked into appropriate
    usage of the HTTP status codes indicating each state of our operations.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the topics of versioning and extensibility, where we used the `301
    Moved Permanently` status code to automatically redirect API calls to different
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we figured out how to semantically link our resource items to arbitrary
    binary represented data.
  prefs: []
  type: TYPE_NORMAL
