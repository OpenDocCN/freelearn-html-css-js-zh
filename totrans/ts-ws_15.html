<html><head></head><body>
		<div>
			<div id="_idContainer163" class="Content">
			</div>
		</div>
		<div id="_idContainer164" class="Content">
			<h1 id="_idParaDest-292">14. <a id="_idTextAnchor341"/>TypeScript and React</h1>
		</div>
		<div id="_idContainer174" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we'll cover the React library and how to build user interfaces enhanced with TypeScript. We'll look at state management solutions for React applications and styling solutions. Then, we will use Firebase, a serverless backend, to build a Hacker News-style application. By the end of this chapter, you will be able to bootstrap React applications using the Create React App command-line interface.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor342"/>Introduction</h1>
			<p>React is a dominant force in web and mobile user interface development. Although it bills itself as "<em class="italic">A JavaScript library for building user interfaces</em>," what we often think of as React goes well beyond the core library and includes a wide ecosystem of plugins, components, and other tools. Many developers have chosen to specialize in React and it's a popular topic for code academies. Unlike Angular, React was not developed to use TypeScript and in fact there are a few other typing systems that some developers use with React. However, the popularity of both React and TypeScript made it inevitable that someone would want to marry the two, and writing React with TypeScript has become a standard way to approach user interface development.</p>
			<p>React was developed internally by Facebook for their own use and was open sourced in 2013. In contrast to some of the more full-featured frameworks, React has always styled itself as a view library and it relies on other libraries for necessary functionality, such as state management, routing, and web requests.</p>
			<p>React uses a declarative, component-based approach. Developers build components that represent different UI elements. These components are typically reusable and can be assembled in different ways to construct web views. Components can be made up of other components and each individual component should be rather simple. Thinking in terms of small, reusable components helps React developers writeÂ clean, maintainable code and follow the <strong class="bold">Don't Repeat Yourself</strong> (<strong class="bold">DRY</strong>) principle.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor343"/>Typing React</h1>
			<p>Prior to the dramatic rise in the popularity of TypeScript, React programmers either went without any sort of type system or used libraries such as Flow or PropTypes.</p>
			<p>Flow is another library developed by Facebook with the intent of adding types to JavaScript. It has similar goals to TypeScript but takes a different route to achieve them. Instead of being a superset of JavaScript, Flow uses comments and type annotations checked by a language server, which are then removed by a transpiler such as Babel. Since both libraries were developed by Facebook, it was common to use them together, but the popularity of Flow has waned as TypeScript has emerged as the type system of choice for web developers.</p>
			<p>PropTypes is another library for enforcing type-checking. In this case, the library is specifically for use with React and has the narrow focus of checking types on React "props," or the parameters that are passed along with components.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor344"/>TypeScript in React</h2>
			<p>While it is technically feasible to use these libraries along with TypeScript, it's not a good idea as they are all essentially trying to solve the same thing. If you're using TypeScript, it's best to avoid Flow and PropTypes.</p>
			<p>TypeScript provides many benefits to React programmers. We can achieve all the same aims as the PropTypes library by typing our props using interfaces, and we also get the full IntelliSense experience, which will let us learn more about components and their lifecycles and even let us read developer comments, deprecation notices, and so forth.</p>
			<p>TypeScript will help ensure proper use of our components and give us that early feedback loop that makes development much easier.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor345"/>Hello, React</h1>
			<p>There are numerous books on React alone. This one chapter in a book on TypeScript cannot cover all the topics relating to React. Readers who aren't already familiar with React but wish to work with React professionally should seek sources beyond this book. That said, to give a very brief overview of how React works, components are written in some flavor of a compile-to-JavaScript language, such as TypeScript, ReasonML, or even JavaScript. The compiled script will be embedded on a web page, hooking into a page element such as a <strong class="source-inline">div</strong>:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import ReactDOM from 'react-dom';</p>
			<p class="source-code">export interface HelloProps {</p>
			<p class="source-code">Â Â name: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">class HelloComponent extends React.Component&lt;HelloProps, {}&gt; {</p>
			<p class="source-code">Â Â render() {</p>
			<p class="source-code">Â Â Â Â return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;</p>
			<p class="source-code">Â Â }</p>
			<p class="source-code">}</p>
			<p class="source-code">ReactDOM.render(</p>
			<p class="source-code">Â Â &lt;HelloTypeScript name="Matt" /&gt;,</p>
			<p class="source-code">Â Â document.getElementById('root')</p>
			<p class="source-code">);</p>
			<p>This script will be loaded into a page with an element that has an ID of <strong class="source-inline">root</strong> and will then print out <strong class="source-inline">Hello Matt</strong>. There are a lot of different ways to structure React applications. Usually, they will be composed of many, many components, each of which is put in a separate file.</p>
			<p>React works by keeping a copy of the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), the object tree that translates JavaScript code to a rendered browser page, in memory. This virtual DOM is updated frequently and changes are selectively applied to a render of the actual web page. The virtual DOM allows for performance optimizations and is designed to prevent slow renders or inefficient re-renders.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor346"/>The Component</h1>
			<p>Inheritance patterns have existed in JavaScript since the beginning, first in the form of prototypal inheritance and then class syntax since ES2015. Some programming paradigms have recommended leveraging inheritance as the primary tool for building complex applications. For example, if we were building a website that included a profile page for a pet kitten, you might think about setting up an inheritance chain such as <strong class="source-inline">KittenProfilePage extends FelineProfilePage extends PetProfilePage extends ProfilePage extends Page</strong>. Indeed, some UI frameworks have attempted to implement models like this. However, in practice, this kind of thinking is quickly revealed as overly rigid, resistant to changing requirements, and forcing you into strange patterns. For example, if we have implemented <strong class="source-inline">whiskerCount</strong> in <strong class="source-inline">FelineProfilePage</strong> and we're now implementing <strong class="source-inline">RodentProfilePage</strong>, do we copy and paste? Does <strong class="source-inline">RodentProfilePage</strong> inherit from <strong class="source-inline">FelineProfilePage</strong>? Should we introduce <strong class="source-inline">WhiskeredPetProfilePage</strong> to the chain in order to share <strong class="source-inline">whiskerCount</strong> according to our model?</p>
			<p>That's not to say that modern web frameworks and libraries don't use inheritance. They do! But generally, we are inheriting from a generic base component provided by the library and our inheritance chains are very short. Instead of inheritance, we focus on composition. Composition is the practice of building from many reusable components, most of which have a more general purpose. This doesn't mean that every component must be used more than once, but they are built in such a way that they could be.</p>
			<p>This approach is embraced wholeheartedly by React. The basic building block of any React application is the component. There are a few classifications of ReactÂ component.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor347"/>Stateful Components</h2>
			<p>Stateful components keep track of their own state. Consider a dropdown that tracks whether or not it is open and renders accordingly. Stateful components may use the <strong class="source-inline">this</strong> keyword or enclose other variables for the purpose of keeping the state. In React, the <strong class="source-inline">setState</strong> method may be used in stateful components. A stateful component's state may be set during lifecycle events.</p>
			<p>Typically, information about how a component should display can be kept within that component. However, more complex data, such as a user profile, will often require a state management solution that extends beyond the component. See <em class="italic">State Management in React</em> later in this chapter.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor348"/>Stateless Components</h2>
			<p>Stateless components never use the <strong class="source-inline">this</strong> keyword or call <strong class="source-inline">setState</strong>. They may re-render based on props passed in but do not track any data themselves. All normal lifecycle methods are available and stateless components are declared in the same way as stateful components, just without anything that may alter the state.</p>
			<p>A dropdown or accordion component could even be stateful if we decided to manage that state in a central location. We typically won't do that for simple components, but we might have some reason, such as an expand/collapse all feature.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor349"/>Pure Components</h2>
			<p>Pure components are a special optimization for React. They are much like stateless components in terms of how we use them, but they are declared differently (by extending <strong class="source-inline">PureComponent</strong>). Pure components will only re-render when there is a change to their state or props. This is in contrast to most components, which will re-render when a parent component re-renders.</p>
			<p>It's a good idea to experiment with pure components. They can dramatically speed up the rendering of a React application but may introduce some unexpected behaviors to those not used to working with them.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor350"/>Higher-Order Components</h2>
			<p><strong class="bold">Higher-order components</strong> (<strong class="bold">HOCs</strong>) are not a library structure but are rather a pattern of wrapping one component with another without mutating the wrapped component. A great example of an HOC is requiring users to authenticate prior to interacting with our components.</p>
			<p>Consider the case of a site with a single login page and 99 pages of sensitive information. Following a composition model, how can we implement this? We don't want to inject the details of our authentication into every component we build. Doing that would be sloppy and impractical. We don't want to have to wrap every render with <strong class="source-inline">isUserAuthenticated</strong>. It would be easy to miss one. A better solution to this problem is to use an HOC. Now our components can be written independently of our authentication model.</p>
			<p>HOCs are often described as <strong class="bold">pure functions</strong> â€“ functions without side effects. Pure functions make many appearances in React programming and are a good model to strive for in general. HOCs are considered to be pure functions because they must not alter the components they wrap. They are not, however, pure components; a pure function is a programming concept while <strong class="source-inline">PureComponent</strong> is an actual part of the React library.</p>
			<p>HOCs are a great example of the concept of composition over inheritance. Going back to the authentication example, an inheritance model would likely have us building components that inherit from <strong class="source-inline">RequiresAuthenticationComponent</strong>, a base component that has our auth model built in. However, with composition, we can build our components independently of our authentication system, then apply an HOC around them. Many programmers would see this as a better separation of concerns.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor351"/>JSX and TSX</h1>
			<p>JSX is another innovation from Facebook. It refers to JavaScript enhanced with XML and practically it is JavaScript with HTML templates embedded into it. The following is an example of its use:</p>
			<p class="source-code">render() {</p>
			<p class="source-code">Â Â return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;</p>
			<p class="source-code">}</p>
			<p>This is a function that returns an HTML template. We must use JSX to do this. Normally, this would result in a syntax error as this is not a quoted string nor is it any recognizable object or syntax in TypeScript. JSX allows us to mix our HTML templating in with our code. Some earlier view libraries would use one file for source code and another for templating. This was often confusing to programmers as they needed to flip back and forth between the two.</p>
			<p>It is possible to write React without using JSX but that is rarely done and won't be covered in this book. Some other languages, such as Vue, use JSX as well.</p>
			<p>When we want to write TypeScript in JSX, we use the <strong class="source-inline">.tsx</strong> file extension instead of <strong class="source-inline">.jsx</strong>. Technically, this is still JSX. To include TypeScript in JSX, all we need to do is set the file extension accordingly and set the <strong class="source-inline">jsx</strong> property in our <strong class="source-inline">tsconfig.json</strong> file to let TypeScript know we're using JSX. Valid values for that property are <strong class="source-inline">react</strong>, <strong class="source-inline">react-native</strong>, and <strong class="source-inline">preserve</strong>. The first two are for targeting a web browser or mobile app, respectively, and the last means that some other transpilation step will handle the JSX.</p>
			<p>JSX is not a part of the JavaScript or TypeScript language, but just a language extension that needs to be transpiled. You wouldn't be able to run JSX in most webÂ browsers.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor352"/>Exercise 14.01: Bootstrapping with Create React App</h2>
			<p>Create React App (<strong class="source-inline">create-react-app</strong>) is a library from Facebook that helps developers quickly bootstrap a new React application. It includes a library called <strong class="source-inline">react-scripts</strong> that helps abstract a lot of the tooling that has become standard in web development, like a linter, a test framework, and a bundler (webpack). All of those dependencies are managed by Create React App and <strong class="source-inline">react-scripts</strong>.</p>
			<p>In this exercise, we'll bootstrap a new React application using Create React App. We'll run the application, examine the developer experience, and make some minor edits, then see components reload. We'll look at the production build and how that's different from the development build. Then we'll check out the built-in tests:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code for this exercise can be found here: <a href="https://packt.link/hMs3v">https://packt.link/hMs3v</a>.</p>
			<ol>
				<li>Create React App ships with a few options and has included a TypeScript option since 2018. It's very easy to create a new application. We don't even need to install anything but can use <strong class="source-inline">npx</strong> to run the latest version of Create React App and start an application. Enter the command line and find a directory where you'd like to create your application and type this:<p class="source-code">npx create-react-app my-app --template typescript</p></li>
				<li>Create React App will download from the internet and set up your application, then install dependencies. Create React App will use the <strong class="source-inline">yarn</strong> package manager (also from Facebook) if you have it installed, otherwise it will use <strong class="source-inline">npm</strong>. It doesn't make very much difference which of these you use for the purposes of this book as they provide the same functionality. If you have an old version of <strong class="source-inline">yarn</strong> installed, you may need to update it (<strong class="source-inline">npm i -g yarn</strong>). If you prefer not to use <strong class="source-inline">yarn</strong>, all of these exercises should work fine without it:<p class="source-code">npx create-react-app my-app --template typescript</p><p class="source-code">npx: installed 67 in 4.26s</p><p class="source-code">Creating a new React app in /Users/mattmorgan/mine/The-TypeScript-Workshop/Chapter14/Exercise01/my-app. </p><p class="source-code">Installing packages. This might take a couple of minutes.</p><p class="source-code">Installing react, react-dom, and react-scripts with cra-template-typescript...</p><p class="source-code">yarn add v1.22.10</p><p class="source-code">[1/4] ğŸ”  Resolving packages...</p><p class="source-code">[2/4] ğŸšš  Fetching packages...</p><p class="source-code">// [â€¦]</p><p class="source-code">warning " &gt; @testing-library/user-event@12.6.2" has unmet peer dependency "@testing-library/dom@&gt;=7.21.4".</p><p class="source-code">success Uninstalled packages.</p><p class="source-code">âœ¨Â Â Done in 10.28s.</p><p class="source-code">Success! Created my-app at /Users/mattmorgan/mine/The-TypeScript-Workshop/Chapter15/Exercise15.01/my-app</p><p class="source-code">Inside that directory, you can run several commands:</p><p class="source-code">Â Â yarn start - Starts the development server.</p><p class="source-code">Â Â yarn build - Bundles the app into static files for production.</p><p class="source-code">Â Â yarn test -    Starts the test runner.</p><p class="source-code">Â Â yarn eject    Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can't go back!</p><p class="source-code">We suggest that you begin by typing:</p><p class="source-code">Â Â cd my-app</p><p class="source-code">Â Â yarn start</p><p class="source-code">Happy hacking!</p><p class="callout-heading">Note</p><p class="callout">For ease of presentation, only a section of the output is displayed here.</p></li>
				<li>The output of <strong class="source-inline">npx create-react-app</strong> will tell you what to do next. <strong class="source-inline">cd</strong> into the directory that was created, and type <strong class="source-inline">yarn start</strong> or <strong class="source-inline">npm start</strong>. Your application will automatically open in a browser window:<p class="source-code">cd my-app</p><p class="source-code">yarn start</p><p>You will see the following output:</p><p class="source-code">Compiled successfully! </p><p class="source-code">You can now view my-app in the browser.</p><p class="source-code">Local:            http://localhost:3000</p><p class="source-code">On Your Network:  http://192.168.7.92:3000</p><p class="source-code">Note that the development build is not optimized.</p><p class="source-code">To create a production build, use yarn build.</p></li>
				<li>If you navigate to <strong class="source-inline">http://localhost:3000</strong>, you will see the following:<div id="_idContainer165" class="IMG---Figure"><img src="image/B14508_14_01.jpg" alt="Figure 14.1: Screenshot of my-app in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 14.1: Screenshot of my-app in the browser</p></li>
				<li>Examine the source code that was generated in your favorite IDE. You can find an <strong class="source-inline">index.tsx</strong> file that attaches the React application to a <strong class="source-inline">dom</strong> node and an <strong class="source-inline">App.tsx</strong> file, which is the main component in your application so far. Try adding a new message or creating some new components as shown here:<div id="_idContainer166" class="IMG---Figure"><img src="image/B14508_14_02.jpg" alt="Figure 14.2: Screenshot of my-app after adding App.tsx&#13;&#10;"/></div><p class="figure-caption">Figure 14.2: Screenshot of my-app after adding App.tsx</p></li>
				<li>When you type <strong class="source-inline">npm start</strong>, your application will run in development mode with hot reloads (meaning your page refreshes when you make a change). For running in production, that's obviously not necessary. You can see what a production build looks like by running <strong class="source-inline">yarn build</strong> or <strong class="source-inline">npm run build</strong>. You'll see some output that tells you exactly what is happening and the transpiled JavaScript will be put in a <strong class="source-inline">build</strong> directory. Open the directory and look at the files there. That's what a production React application looks like.</li>
				<li>Use <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop your local server and try <strong class="source-inline">yarn build</strong> or <strong class="source-inline">npm run build</strong> to run the production build.</li>
				<li>Production React applications often run on static servers but they can also run on web servers. The concept of server-side rendering in React is beyond the scope of this book but is another topic you may be interested in. Your build should produce a shortened URL that will take you to an article that includes more information about deploying React applications to production:<p class="source-code">yarn build</p><p class="source-code">yarn run v1.22.10</p><p class="source-code">react-scripts build</p><p class="source-code">Creating an optimized production build...</p><p class="source-code">Compiled successfully.</p><p>File sizes after <strong class="source-inline">gzip</strong>:</p><p class="source-code">Â Â 41.2 KB  build/static/js/2.311d60e9.chunk.js</p><p class="source-code">Â Â 1.39 KB  build/static/js/3.73a1c5a5.chunk.js</p><p class="source-code">Â Â 1.17 KB  build/static/js/runtime-main.f12bc2d0.js</p><p class="source-code">Â Â 615 B    build/static/js/main.fe0fc6c6.chunk.js</p><p class="source-code">Â Â 531 B    build/static/css/main.8c8b27cf.chunk.css</p><p>The project was built assuming it is hosted at <strong class="source-inline">/</strong>. You can control this with the <strong class="source-inline">homepage</strong> field in your <strong class="source-inline">package.json</strong>. </p></li>
				<li>The <strong class="source-inline">build</strong> folder is ready to be deployed. You may serve it with a static server:<p class="source-code">yarn global add serve</p><p class="source-code">serve -s build</p><p class="source-code">Find out more about deployment here:https://cra.link/deployment</p><p class="source-code">âœ¨  Done in 7.88s.</p></li>
				<li>Type <strong class="source-inline">yarn test</strong> or <strong class="source-inline">npm t</strong> (short for <strong class="source-inline">npm test</strong>). The Jest framework will run a test against your application. The test is very simple but can get you started writing more tests. It's a good idea to write tests for your components as the tests will give you confidence that your application is working. Writing testable code builds strong programming habits:<p class="source-code">PASS  src/App.test.tsx</p><p class="source-code">Â Â âœ“ renders learn react link (23 ms)</p><p class="source-code">Test Suites: 1 passed, 1 total</p><p class="source-code">Tests:       1 passed, 1 total</p><p class="source-code">Snapshots:   0 total</p><p class="source-code">Time:        2.295 s</p><p class="source-code">Ran all test suites related to changed files.</p><p class="source-code">Watch Usage</p><p class="source-code">Â â€º Press a to run all tests.</p><p class="source-code">Â â€º Press f to run only failed tests.</p><p class="source-code">Â â€º Press q to quit watch mode.</p><p class="source-code">Â â€º Press p to filter by a filename regex pattern.</p><p class="source-code">Â â€º Press t to filter by a test name regex pattern.</p><p class="source-code">Â â€º Press Enter to trigger a test run.</p><p>And with that, we've covered the basics of Create React App. We've learned how we can quickly bootstrap a new application, looked at the developer experience with hot reloading, and also how to run production builds and tests.</p></li>
			</ol>
			<p>Although Create React App gives you a lot of stuff, it's actually just the tip of the iceberg of what we'll see in the coming sections. For example, our application has no way to handle different kinds of requests or different pages. We don't have any routing. We also have no place to store data and no way to interact with any kind of backend. We'll delve into those concepts in the coming sections.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor353"/>Routing</h1>
			<p>React doesn't include a solution for routing by default. That's because at its heart it is a view library. Some applications have no need for routing, but most will want the ability to render multiple pages at the very least. Some applications have complicated routing requirements that may involve "deep linking" or linking directly to a particular document. Request or query variables in a URL may contain some identifier that connects to a particular user's record.</p>
			<p>While there are some alternatives, most React applications that use routing use React-Router, which is the official Facebook solution.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor354"/>Exercise 14.02: React Router</h2>
			<p>In this exercise, we'll bootstrap another application with Create React App and then enhance it with React Router to be able to support multiple views and navigate between them: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code for this exercise can be found here: <a href="https://packt.link/EYBcF">https://packt.link/EYBcF</a>.</p>
			<ol>
				<li value="1">To start, go to the command line where you can create another application:<p class="source-code">npx create-react-app router-app --template typescript</p><p class="source-code">cd router-app</p></li>
				<li>To add React Router, let's install the library and typings. If you are not using <strong class="source-inline">yarn</strong>, <strong class="source-inline">yarn add</strong> commands can be replaced with <strong class="source-inline">npm install</strong>:<p class="source-code">yarn add react-router-dom</p><p class="source-code">yarn add -D @types/react-router-dom</p><p class="source-code">% yarn add react-router-dom</p><p class="source-code">yarn add v1.22.10</p><p class="source-code">[1/4] ğŸ”  Resolving packages...</p><p class="source-code">[2/4] ğŸšš  Fetching packages...</p><p class="source-code">[3/4] ğŸ”—  Linking dependencies...</p><p class="source-code">warning " &gt; @testing-library/user-event@12.6.2" has unmet peer dependency "@testing-library/dom@&gt;=7.21.4".</p><p class="source-code">[4/4] ğŸ”¨  Building fresh packages...</p><p class="source-code">success Saved lockfile.</p><p class="source-code">success Saved 8 new dependencies.</p><p class="source-code">info Direct dependencies</p><p class="source-code">â””â”€ react-router-dom@5.2.0</p><p class="source-code">info All dependencies</p><p class="source-code">â”œâ”€ hoist-non-react-statics@3.3.2</p><p class="source-code">â”œâ”€ mini-create-react-context@0.4.1</p><p class="source-code">â”œâ”€ path-to-regexp@1.8.0</p><p class="source-code">â”œâ”€ react-router-dom@5.2.0</p><p class="source-code">â”œâ”€ react-router@5.2.0</p><p class="source-code">â”œâ”€ resolve-pathname@3.0.0</p><p class="source-code">â”œâ”€ tiny-warning@1.0.3</p><p class="source-code">â””â”€ value-equal@1.0.1</p><p class="source-code">âœ¨  Done in 4.86s.</p><p class="source-code">% yarn add -D @types/react-router-dom</p><p class="source-code">yarn add v1.22.10</p><p class="source-code">[1/4] ğŸ”  Resolving packages...</p><p class="source-code">[2/4] ğŸšš  Fetching packages...</p><p class="source-code">[3/4] ğŸ”—  Linking dependencies...</p><p class="source-code">warning " &gt; @testing-library/user-event@12.6.2" has unmet peer dependency "@testing-library/dom@&gt;=7.21.4".</p><p class="source-code">[4/4] ğŸ”¨  Building fresh packages...</p><p class="source-code">success Saved lockfile.</p><p class="source-code">success Saved 2 new dependencies.</p><p class="source-code">info Direct dependencies</p><p class="source-code">â””â”€ @types/react-router-dom@5.1.7</p><p class="source-code">info All dependencies</p><p class="source-code">â”œâ”€ @types/react-router-dom@5.1.7</p><p class="source-code">â””â”€ @types/react-router@5.1.11</p><p class="source-code">âœ¨  Done in 4.59s.</p><p>Now we can start the application with <strong class="source-inline">yarn start</strong> or <strong class="source-inline">npm start</strong>. We'll be editing files as we add these routes and our application will just restart automatically, which makes for a nice developer experience.</p><p>We could begin by adding the router, but we currently have nothing to route to, so let's start by adding a few new components. Since components are the building blocks of a React application, a component can be a page. That same component could also be part of another page.</p></li>
				<li>Let's create a <strong class="source-inline">/src/pages</strong> subdirectory in our application to hold the new page components. In the <strong class="source-inline">pages</strong> subdirectory, create <strong class="source-inline">Add.tsx,Home.tsx</strong>, <strong class="source-inline">SignIn.tsx</strong>, and <strong class="source-inline">Signup.tsx</strong>.<p>To start, we'll create some very simple components to route between. In a later section in this chapter, we'll discuss the creation of function components.</p></li>
				<li>Create <strong class="source-inline">Add.tsx</strong> using the following code:<p class="source-code">import React from 'react';</p><p class="source-code">const Add = () =&gt; &lt;div&gt;Add a new story&lt;/div&gt;;</p><p class="source-code">export default Add;</p></li>
				<li>Create <strong class="source-inline">Home.tsx</strong> using the following code:<p class="source-code">import React from 'react';</p><p class="source-code">const Home = () =&gt; &lt;div&gt;You are home!&lt;/div&gt;;</p><p class="source-code">export default Home;</p></li>
				<li>Create <strong class="source-inline">SignIn.tsx</strong> using the following code:<p class="source-code">import React from 'react';</p><p class="source-code">const SignIn = () =&gt; &lt;div&gt;Sign in here&lt;/div&gt;;</p><p class="source-code">export default SignIn;</p></li>
				<li>Create <strong class="source-inline">SignUp.tsx</strong> using the following code:<p class="source-code">import React from 'react';</p><p class="source-code">const SignUp = () =&gt; &lt;div&gt;Sign up here&lt;/div&gt;;</p><p class="source-code">export default SignUp;</p><p>These basic components only return some JSX, but they are sufficient to route between. Note that without a router, we could include the components in our main <strong class="source-inline">App.tsx</strong>, but we cannot navigate between pages in a traditional web app sense. That is the responsibility of the router.</p></li>
				<li>So, at this point, we have components that we can't yet interact with. Let's add routing to our <strong class="source-inline">App.tsx</strong>.<p>React Router exposes a few different router types that have mostly narrow use cases. We will focus on <strong class="source-inline">BrowserRouter</strong>. To get started, we will add a few imports to <strong class="source-inline">App.tsx</strong>:</p><p class="source-code">import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';</p><p>By convention, we are renaming <strong class="source-inline">BrowserRouter</strong> to <strong class="source-inline">Router</strong> in our import. We will also use <strong class="source-inline">Switch</strong>, which gives us a declarative way to shift between different components based on the route, and <strong class="source-inline">Route</strong>, which lets us define the component route.</p><p>Adding our first (default) route is pretty simple. Before doing that, make sure your local dev environment is running with <strong class="source-inline">npm start</strong>. You should see the spinning React logo in a web browser running at <strong class="source-inline">http://localhost:3000</strong>.</p></li>
				<li>Now let's use the other components to build out the first route. We'll remove all the JSX that the <strong class="source-inline">App.tsx</strong> component is currently returning and replace it with the routing:<p class="source-code">function App() {</p><p class="source-code">Â Â return (</p><p class="source-code">Â Â Â Â &lt;Router&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Switch&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Route exact path="/" component={Home} /&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;/Switch&gt;</p><p class="source-code">Â Â Â Â &lt;/Router&gt;</p><p class="source-code">Â Â );</p><p class="source-code">}</p><p>You will need to import the <strong class="source-inline">Home</strong> component:</p><p class="source-code">import Home from './pages/Home';</p><p>Your IDE may prompt you to automatically import <strong class="source-inline">Home</strong> as you are typing.</p></li>
				<li>If you've got everything working correctly, your view will refresh and you'll see the React logo replaced with <strong class="source-inline">You are home!</strong>.<p>Let's add some additional routes:</p><p class="source-code">&lt;Route path="/add" component={Add} /&gt;</p><p class="source-code">&lt;Route path="/signin" component={SignIn} /&gt;</p><p class="source-code">&lt;Route path="/signup" component={SignUp} /&gt;</p></li>
				<li>Our <strong class="source-inline">Home</strong> route sets the <strong class="source-inline">exact</strong> property. Routing in React uses a regular expression to match the path starting from the leftmost part of the path. This allows for variable query and route parameters to be matched. The <strong class="source-inline">exact</strong> prop forces an exact match and ensures <strong class="source-inline">"/add"</strong> doesn't match to <strong class="source-inline">"/"</strong>.</li>
				<li>Now we can test the routing. Type <strong class="source-inline">http://localhost:3000/add</strong> in your browser. You should get the message <strong class="source-inline">Add a new story</strong>. Try visiting the otherÂ routes.</li>
				<li>Of course, it isn't very natural to expect users to manually type all the URLs in a browser to navigate your site. Let's add some links. We can import <strong class="source-inline">Link</strong> from <strong class="source-inline">react-router</strong>. This component will create navigation links that connect to your application routing. Because of this, <strong class="source-inline">Link</strong> must always be used withinÂ <strong class="source-inline">Router</strong>.<p><strong class="source-inline">Link</strong> wraps some text and has a <strong class="source-inline">to</strong> prop, which should have the route you want to link to:</p><p class="source-code">&lt;Link to="/"&gt;home&lt;/Link&gt;</p><p>With that, it's pretty easy to add some navigation elements:</p><p class="source-code">&lt;nav&gt;</p><p class="source-code">Â Â &lt;ul&gt;</p><p class="source-code">Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Link to="/"&gt;home&lt;/Link&gt;</p><p class="source-code">Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Link to="add"&gt;add&lt;/Link&gt;</p><p class="source-code">Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Link to="signin"&gt;signin&lt;/Link&gt;</p><p class="source-code">Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Link to="signup"&gt;signup&lt;/Link&gt;</p><p class="source-code">Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â &lt;/ul&gt;</p><p class="source-code">&lt;/nav&gt;</p><p>This should give us a nice way to move between our pages. However, pasting a bunch of extra JSX into <strong class="source-inline">App.tsx</strong> isn't a great way to write React, so let's write a <strong class="source-inline">NavBar</strong> component instead. </p></li>
				<li>Add a <strong class="source-inline">components</strong> directory under <strong class="source-inline">src</strong>. We'll use this directory to hold components that aren't tied to routes:<p class="source-code">import React from 'react';</p><p class="source-code">import { Link } from 'react-router-dom';</p><p class="source-code">const NavBar = () =&gt; (</p><p class="source-code">Â Â &lt;nav&gt;</p><p class="source-code">Â Â Â Â &lt;ul&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Link to="/"&gt;home&lt;/Link&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Link to="add"&gt;add&lt;/Link&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Link to="signin"&gt;signin&lt;/Link&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;li&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Link to="signup"&gt;signup&lt;/Link&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;/li&gt;</p><p class="source-code">Â Â Â Â &lt;/ul&gt;</p><p class="source-code">Â Â &lt;/nav&gt;</p><p class="source-code">);</p><p class="source-code">export default NavBar;</p></li>
				<li>Now we can simply use this component in <strong class="source-inline">App.tsx</strong>. Here's the finishedÂ component:<p class="source-code">import './App.css';</p><p class="source-code">import React from 'react';</p><p class="source-code">import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';</p><p class="source-code">import NavBar from './components/NavBar';</p><p class="source-code">import Add from './pages/Add';</p><p class="source-code">import Home from './pages/Home';</p><p class="source-code">import SignIn from './pages/SignIn';</p><p class="source-code">import SignUp from './pages/SignUp';</p><p class="source-code">function App() {</p><p class="source-code">Â Â return (</p><p class="source-code">Â Â Â Â &lt;Router&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;NavBar /&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Switch&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Route exact path="/" component={Home} /&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Route path="/add" component={Add} /&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Route path="/signin" component={SignIn} /&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;Route path="/signup" component={SignUp} /&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;/Switch&gt;</p><p class="source-code">Â Â Â Â &lt;/Router&gt;</p><p class="source-code">Â Â );</p><p class="source-code">}</p><p class="source-code">export default App;</p></li>
				<li>Check your browser now and you should see the simple navigation and be able to use it to shift between views:<div id="_idContainer167" class="IMG---Figure"><img src="image/B14508_14_03.jpg" alt="Figure 14.3: List of folders in the finished component&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.3: List of folders in the finished component</p>
			<p>Adding routing to a React application is easy to do. In this exercise, we showed how to add routes, navigate between them, and also how to share a common component across several routes. One of the real strengths of React is the ability to share components among other components and create reuse patterns that make putting together the building blocks of an application easy.</p>
			<p>Routing can also include path and query parameters. Be sure to read the React Router documentation for how to add parameters to your routes.</p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor355"/>React Components</h1>
			<p>Now let's dig into how these components work. There are several different ways to declare a component in React. You even have the choice to use JSX or not. This book will focus on creating components with function expressions, but we'll go over a few other patterns, so you'll know them when you see them.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor356"/>Class Components</h2>
			<p>This style of component follows a classical (that is, relating to the programming concept of classes) pattern of component declaration. Many older examples will use class components, but they have fallen largely out of fashion due to being more verbose than other patterns. To create a class component, we import the <strong class="source-inline">Component</strong> class from React and extend it while creating our own class:</p>
			<p class="source-code">import React, { Component } from 'react';</p>
			<p class="source-code">interface Comp1Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default class Comp1 extends Component&lt;Comp1Props&gt; {</p>
			<p class="source-code">Â Â render() {</p>
			<p class="source-code">Â Â Â Â const { text } = this.props;</p>
			<p class="source-code">Â Â Â Â return &lt;div&gt;{text}&lt;/div&gt;;</p>
			<p class="source-code">Â Â }</p>
			<p class="source-code">}</p>
			<p>It's a good idea to create your own interface for props and the same can be done for state â€“ for example:</p>
			<p class="source-code">import React, { Component } from 'react';</p>
			<p class="source-code">interface Comp1Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface Comp1State {</p>
			<p class="source-code">Â Â value: boolean</p>
			<p class="source-code">}</p>
			<p class="source-code">export default class Comp1 extends Component&lt;Comp1Props, Comp1State&gt; {</p>
			<p class="source-code">Â Â render() {</p>
			<p class="source-code">Â Â Â Â ...</p>
			<p class="source-code">}</p>
			<p>Props are accessed via <strong class="source-inline">this.props</strong> and state via <strong class="source-inline">this.state</strong> and <strong class="source-inline">this.setState</strong>. This style of programming may seem comfortable and familiar to those with a background in Java or C++, but the <strong class="source-inline">this</strong> keyword can be troubling to work with in TypeScript and the class-focused declaration style doesn't fit well with some of the functional programming concepts in React, so other patterns have gained popularity in recent years. For more information about the <strong class="source-inline">this</strong> keyword, see <em class="italic">Chapter 3</em>, <em class="italic">Functions</em>.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor357"/>Function Components (Function Declaration)</h2>
			<p>It's far more common for React components to be written as function components. The same simple component from the previous section, rewritten as a function component, could look like this:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">interface Comp2Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default function Comp2({ text }: Comp2Props) {</p>
			<p class="source-code">Â Â return &lt;div&gt;{text}&lt;/div&gt;;</p>
			<p class="source-code">}</p>
			<p>We've shaved off a couple of lines of code and come to something a bit more like a functional programming style. You won't use <strong class="source-inline">this</strong> very often when using function components, nor do you need to actually import the <strong class="source-inline">Component</strong> class. Props are simply the arguments passed into the function. State can't be handled directly here, but we will see how to manage that in the next section on React Hooks.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor358"/>Function Components (Function Expression with Arrow Functions)</h2>
			<p>This book prefers this pattern as a very intuitive and declarative way of creating components. You can even create pure function components as a one-liner. First, let'sÂ write the same component again:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">interface Comp3Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">const Comp3 = ({ text }: Comp3Props) =&gt; &lt;div&gt;{text}&lt;/div&gt;;</p>
			<p class="source-code">export default Comp3;</p>
			<p>Scoping rules do not allow the <strong class="source-inline">const</strong> and <strong class="source-inline">default</strong> keywords to be on the same line (avoiding absurd code such as <strong class="source-inline">export default const a=1, b=2, c=3;</strong>, which would otherwise be allowed), so we need to export the component on a separate line.</p>
			<p>If we really want to slim the code down, we could write it like this:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">export const Comp3 = ({ text }:{ text: string }) =&gt; &lt;div&gt;{text}&lt;/div&gt;;</p>
			<p>This is a pure function component that is stateless and has no other side effects. Most programmers prefer to use an interface for the props as it helps with readability, but that declaration can be done inline as in the preceding snippet (<strong class="source-inline">{ text: string }</strong>) if we really want to make the component small.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor359"/>No JSX</h2>
			<p>Any of the preceding methods can use <strong class="source-inline">createElement</strong>. Here's a quick example of why you probably don't want to use that:</p>
			<p class="source-code">import { createElement } from 'react';</p>
			<p class="source-code">interface Comp4Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">const Comp4 = ({ text }: Comp4Props) =&gt; createElement('div', null, text);</p>
			<p class="source-code">export default Comp4;</p>
			<p>The arguments to <strong class="source-inline">createElement</strong> are the element tag to create, its props, and its children. It doesn't take long to realize that creating nested elements with <strong class="source-inline">createElement</strong> would be <em class="italic">substantially</em> more difficult than using JSX, so JSX is almost always used. If we decide not to use JSX, we can use the <strong class="source-inline">.ts</strong> file extension instead of <strong class="source-inline">.tsx</strong>. This is a very small benefit!</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor360"/>State in Function Components</h2>
			<p>This book recommends function components over class components. We cannot access state directly in a function component, nor is there a <strong class="source-inline">setState</strong> method to call. However, we do have access to the excellent <strong class="source-inline">useState</strong> and so we hardly miss <strong class="source-inline">this</strong> or <strong class="source-inline">setState</strong> at all.</p>
			<p><strong class="source-inline">useState</strong> is part of React Hooks, available since React version 16.8. React Hooks introduced several functions that greatly enhance working with function components. Let's start by coming up with a simple component that uses the class constructor, <strong class="source-inline">this</strong>, and <strong class="source-inline">setState</strong>:</p>
			<p class="source-code">import React, { Component } from 'react';</p>
			<p class="source-code">interface Comp1Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface Comp1State {</p>
			<p class="source-code">Â Â clicks: number;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default class Comp1 extends Component&lt;Comp1Props, Comp1State&gt; {</p>
			<p class="source-code">Â Â constructor(props: Comp1Props) {</p>
			<p class="source-code">Â Â Â Â super(props);</p>
			<p class="source-code">Â Â Â Â this.state = { clicks: 0 };</p>
			<p class="source-code">Â Â }</p>
			<p class="source-code">Â Â handleClick = () =&gt; {</p>
			<p class="source-code">Â Â Â Â this.setState({ clicks: this.state.clicks + 1 });</p>
			<p class="source-code">Â Â };</p>
			<p class="source-code">Â Â render() {</p>
			<p class="source-code">Â Â Â Â const { text } = this.props;</p>
			<p class="source-code">Â Â Â Â return (</p>
			<p class="source-code">Â Â Â Â Â Â &lt;div&gt;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â {text}</p>
			<p class="source-code">Â Â Â Â Â Â Â Â &lt;div&gt;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â &lt;button onClick={this.handleClick}&gt;{this.state.clicks} clicks&lt;/button&gt;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â &lt;/div&gt;</p>
			<p class="source-code">Â Â Â Â Â Â &lt;/div&gt;</p>
			<p class="source-code">Â Â Â Â );</p>
			<p class="source-code">Â Â }</p>
			<p class="source-code">}</p>
			<p>We've defined interfaces for props and state as well as an event handler to count up the clicks. We are using <strong class="source-inline">setState</strong> to increment our counter in the state. It looks a bit weird that <strong class="source-inline">handleClick</strong> uses an arrow function while <strong class="source-inline">render</strong> does not, yet they both refer to <strong class="source-inline">this</strong>. This is due to the strangeness of interpreting <strong class="source-inline">this</strong> references in TypeScript. Without an arrow function, <strong class="source-inline">handleClick</strong> will not find our component when accessing <strong class="source-inline">this</strong> but will instead get an <strong class="source-inline">undefined</strong> reference. This sort of issue has cost a lot of developers a lot of time and so framework authors have sought after solutions that simply avoid language constructs that so many find confusing. Let's rewrite this component as a function component:</p>
			<p class="source-code">import React, { useState } from 'react';</p>
			<p class="source-code">interface Comp2Props {</p>
			<p class="source-code">Â Â text: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default function Comp2({ text }: Comp2Props) {</p>
			<p class="source-code">Â Â const [clicks, setClicks] = useState(0);</p>
			<p class="source-code">Â Â const handleClick = () =&gt; setClicks(clicks + 1);</p>
			<p class="source-code">Â Â return (</p>
			<p class="source-code">Â Â Â Â &lt;div&gt;</p>
			<p class="source-code">Â Â Â Â Â Â {text}</p>
			<p class="source-code">Â Â Â Â Â Â &lt;div&gt;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â &lt;button onClick={handleClick}&gt;{clicks} clicks&lt;/button&gt;</p>
			<p class="source-code">Â Â Â Â Â Â &lt;/div&gt;</p>
			<p class="source-code">Â Â Â Â &lt;/div&gt;</p>
			<p class="source-code">Â Â );</p>
			<p class="source-code">}</p>
			<p>This function component does exactly the same thing as the class component. Let's look at the differences. For one, we're starting to see substantial savings in terms of lines of code. The function component is 18 lines while the class component is 30.</p>
			<p>Next, we are avoiding the troublesome <strong class="source-inline">this</strong> keyword. We are also avoiding having to define an interface for the state. It may seem counterintuitive, but this is actually a good thing. In class components, state, as a single object, may often combine several unrelated things into one state. State is really just a place for any and all local variables. By declaring each of these variables independently from the others, we can establish much better programming paradigms.</p>
			<p>The <strong class="source-inline">useState</strong> function takes an argument, which is the default state, and returns an array of <strong class="source-inline">const</strong> pointing to the value and a method used to update the state. The stateful value is <strong class="source-inline">const</strong> because it cannot be updated without re-rendering our component. If we call <strong class="source-inline">setClicks</strong>, the component will re-render with a newly initialized <strong class="source-inline">const clicks</strong>. You can have several <strong class="source-inline">useState</strong> calls in a single function component. Each one manages its own part of the state independently.</p>
			<p>Your state can still be strongly typed when using <strong class="source-inline">useState</strong>. In our case, TypeScript infers the type of number for clicks, based on how we've initialized it with a number. However, if we wanted to, we could add a type hint such as <strong class="source-inline">useState&lt;number&gt;(0)</strong> or <strong class="source-inline">useState&lt;MyType&gt;(0)</strong> to handle more complexÂ types.</p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor361"/>State Management in React</h1>
			<p>State is a bit of an overloaded term in the UI development world. Thus far, the state we've been referring to is a local state inside of a component. Going back to the clicks example, while that value could be passed to a child component via the usual means (as a prop), there's no easy way to pass the value to a parent component or some distant "cousin" component elsewhere in the DOM tree.</p>
			<p>The management of global state is a problem much older than React. It's always been fairly simple to create some kind of widget that can internally manage its own data, but that widget gets extremely complicated when new requirements are introduced that connect the widget's data to other parts of an application. Often applications were written in an imperative fashion with hand-coded "events" to try to propagate data through some global scope. This approach can work, but bugs are common and managing change can be extremely difficult. A likely outcome of an ad hoc approach to state management is unmaintainable spaghetti code.</p>
			<p>React does have a "brute force" approach to state management, which is that all data is stored in some parent component and passed (along with any necessary methods to update the data) to all children and all of their descendants. Doing this in a complex application can be really challenging, with long lists of props that must always be passed through. For this reason, most developers choose another solution.</p>
			<p>Redux is a popular library introduced in 2015 that aimed to solve the problem of state management by introducing functional programming concepts such as the reducer. The concept behind Redux is that an immutable state is stored somewhere in the application. Different parts of the application can dispatch actions that will produce a new state to replace the old one. Because each version of the immutable state can be stored and is immutable (meaning nothing outside this framework can change it), it is possible to time-travel through different application states, something that can be very useful for development but may also have use in production applications, such as an "undo" feature. Redux can be used with almost any web application and is not tied to React, but it's very common to find the two of them together in an application.</p>
			<p>Redux is powerful but receives criticism for being overly complex and using a lot of boilerplate. It also typically requires additional libraries (such as <strong class="source-inline">redux-saga</strong> or <strong class="source-inline">redux-thunk</strong>) to make asynchronous calls to a backend server. All of these libraries can be very intimidating to newcomers and even challenging to use for experiencedÂ programmers.</p>
			<p>React Hooks provides a simpler way using React context. React context allows us to set root-level data stores and actions and make them available to components deep in the DOM tree without having to pass props all the way through (sometimes known as "prop drilling"). The difference between Redux and context is tantamount to going from class components and <strong class="source-inline">setState</strong> to function components and <strong class="source-inline">useState</strong>. Like the prior example, we are moving from a single state object and complexity managing it to multiple contexts that can be managed more simply.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor362"/>Exercise 14.03: React Context</h2>
			<p>Let's get some experience with context. For this exercise, you can either bootstrap a new <strong class="source-inline">create-react-app</strong> instance or use the one from the previous sections. In this exercise, we'll create two new components and one provider. Technically, providers are components too, but they are actually specialized HOCs:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code for this exercise can be found here: <a href="https://packt.link/rUfr4">https://packt.link/rUfr4</a>.</p>
			<ol>
				<li value="1">Let's start with the provider. Create <strong class="source-inline">/compo<a id="_idTextAnchor363"/>nents</strong> and <strong class="source-inline">/providers</strong> subdirectories under your <strong class="source-inline">/src</strong> directory. In the <strong class="source-inline">/providers</strong> directory, create a file called <strong class="source-inline">ClickProvider.tsx</strong>. This component will manage our clicks and provide its context to descendants.</li>
				<li>Unlike most components, a provider will export a context and a provider. Some guides will create <strong class="source-inline">Context</strong> and then export <strong class="source-inline">Consumer</strong> and <strong class="source-inline">Provider</strong>. Rather than using <strong class="source-inline">Consumer</strong>, we will use <strong class="source-inline">useContext</strong>, another React Hook. When using <strong class="source-inline">useContext</strong>, the <strong class="source-inline">Consumer</strong> object is not referenced directly:<p class="source-code">export const ClickContext = createContext();</p></li>
				<li>That's the basic signature for creating <strong class="source-inline">Context</strong>. We will need to add a type hint and a default value. Let's come to that in a moment after adding <strong class="source-inline">Provider</strong>:<p class="source-code">export const ClickProvider = ({ children }) =&gt; {</p><p class="source-code">Â Â const [clicks, setClicks] = useState(0);</p><p class="source-code">Â Â return (</p><p class="source-code">Â Â Â Â &lt;ClickContext.Provider value={{ clicks, setClicks }}&gt;</p><p class="source-code">Â Â Â Â Â Â {children}</p><p class="source-code">Â Â Â Â &lt;/ClickContext.Provider&gt;</p><p class="source-code">Â Â );</p><p class="source-code">};</p><p>This component takes some props, which are child nodes. It uses <strong class="source-inline">useState</strong> to create a <strong class="source-inline">clicks</strong> value and an <strong class="source-inline">update</strong> function, then it returns <strong class="source-inline">Provider</strong> with the value and the function.</p></li>
				<li>This is the basic provider we need, but it's not yet good TypeScript. We need to add some more types:<p class="source-code">interface Clicks {</p><p class="source-code">Â Â clicks: number;</p><p class="source-code">Â Â setClicks: Dispatch&lt;SetStateAction&lt;number&gt;&gt;;</p><p class="source-code">}</p><p class="source-code">interface ContextProps {</p><p class="source-code">Â Â children: ReactNode;</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">ClickContext</strong> will be the type for the value our <strong class="source-inline">Provider</strong> returns and <strong class="source-inline">ContextProps</strong> works as a basic prop type for any HOC with children. With these types, we can fill out the rest of <strong class="source-inline">Provider</strong>:<p class="source-code">import React, {</p><p class="source-code">Â Â createContext,</p><p class="source-code">Â Â Dispatch,</p><p class="source-code">Â Â ReactNode,</p><p class="source-code">Â Â SetStateAction,</p><p class="source-code">Â Â useState,</p><p class="source-code">} from 'react';</p><p class="source-code">interface Clicks {</p><p class="source-code">Â Â clicks: number;</p><p class="source-code">Â Â setClicks: Dispatch&lt;SetStateAction&lt;number&gt;&gt;;</p><p class="source-code">}</p><p class="source-code">interface ContextProps {</p><p class="source-code">Â Â children: ReactNode;</p><p class="source-code">}</p><p class="source-code">export const ClickContext = createContext&lt;Clicks&gt;({</p><p class="source-code">Â Â clicks: 0,</p><p class="source-code">Â Â setClicks: () =&gt; {},</p><p class="source-code">});</p><p class="source-code">export const ClickProvider = ({ children }: ContextProps) =&gt; {</p><p class="source-code">Â Â const [clicks, setClicks] = useState(0);</p><p class="source-code">Â Â return (</p><p class="source-code">Â Â Â Â &lt;ClickContext.Provider value={{ clicks, setClicks }}&gt;</p><p class="source-code">Â Â Â Â Â Â {children}</p><p class="source-code">Â Â Â Â &lt;/ClickContext.Provider&gt;</p><p class="source-code">Â Â );</p><p class="source-code">};</p></li>
				<li>Now let's add <strong class="source-inline">Clicker.tsx</strong> and <strong class="source-inline">Display.tsx</strong> in the <strong class="source-inline">components</strong>Â directory:<p class="source-code">import React, { useContext } from 'react';</p><p class="source-code">import { ClickContext } from '../providers/ClickProvider';</p><p class="source-code">const Clicker = () =&gt; {</p><p class="source-code">Â Â const { clicks, setClicks } = useContext(ClickContext);</p><p class="source-code">Â Â const handleClick = () =&gt; setClicks(clicks + 1);</p><p class="source-code">Â Â return &lt;button onClick={handleClick}&gt;Add a click&lt;/button&gt;;</p><p class="source-code">};</p><p class="source-code">export default Clicker;</p></li>
				<li>This component renders a button and uses the <strong class="source-inline">setClicks</strong> method fromÂ <strong class="source-inline">Provider</strong>:<p class="source-code">import React, { useContext } from 'react';</p><p class="source-code">import { ClickContext } from '../providers/ClickProvider';</p><p class="source-code">const Display = () =&gt; {</p><p class="source-code">Â Â const { clicks } = useContext(ClickContext);</p><p class="source-code">Â Â return &lt;div&gt;{clicks}&lt;/div&gt;;</p><p class="source-code">};</p><p class="source-code">export default Display;</p><p><strong class="source-inline">Display.tsx</strong> just grabs the <strong class="source-inline">clicks</strong> value from the context and displays it.</p></li>
				<li>Now that we have a couple of simple components that work with our provider, let's add them to <strong class="source-inline">App.tsx</strong> and see how our app looks.</li>
				<li>Delete the default code from <strong class="source-inline">App.tsx</strong> and replace it with <strong class="source-inline">Provider</strong> and the new components:<p class="source-code">import './App.css';</p><p class="source-code">import React from 'react';</p><p class="source-code">import Clicker from './components/Clicker';</p><p class="source-code">import Display from './components/Display';</p><p class="source-code">import { ClickProvider } from './providers/ClickProvider';</p><p class="source-code">function App() {</p><p class="source-code">Â Â return (</p><p class="source-code">Â Â Â Â &lt;ClickProvider&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Clicker /&gt;</p><p class="source-code">Â Â Â Â Â Â &lt;Display /&gt;</p><p class="source-code">Â Â Â Â &lt;/ClickProvider&gt;</p><p class="source-code">Â Â );</p><p class="source-code">}</p><p class="source-code">export default App;</p><p>Run the app and click the button several times. The counter will increment. It's not that amazing to make a counter increment on a website, but our components are nicely decoupled and this approach will scale well to much larger apps:</p><div id="_idContainer168" class="IMG---Figure"><img src="image/B14508_14_04.jpg" alt="Figure 14.4: App displaying the click counter&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.4: App displaying the click counter</p>
			<p>In this exercise, we used React context to manage state in an application. We showed how different components can interact with the state and how it can be passed to components without the need for nested props.</p>
			<p>React applications can contain multiple contexts or a single tree of data. React context will even keep the current state while a modified component reloads in development mode so you can keep coding without interrupting the application flow.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor364"/>Firebase</h1>
			<p>Firebase is a mobile and web development platform owned by Google. Firebase includes a web API so you can add authentication, analytics, a database, and more to a web application. Firebase can be used as the backend of a modern web application, allowing developers to focus on user experience. It includes a free tier that we will use for the following exercise.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor365"/>Exercise 14.04: Getting Started with Firebase</h2>
			<p>In this exercise, we'll set up a database and authentication using Firebase. We'll need to register a free account. We'll also get the required payload that we'll need to complete an activity using Firebase later in this chapter:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here:  <a href="https://packt.link/bNMr5">https://packt.link/bNMr5</a>.</p>
			<ol>
				<li value="1">Firebase requires a Google account, but using it doesn't require a credit card or any payment. To get started, navigate to <a href="https://firebase.google.com/">https://firebase.google.com/</a> and click <strong class="source-inline">GetÂ started</strong>. <p>You should find yourself at the Firebase console. Click <strong class="source-inline">Add project</strong> and work through the wizard. You can name your project whatever you like â€“ Firebase will make the name unique if you don't. </p></li>
				<li>Don't enable Google Analytics, unless you already have an account you want toÂ use.<p>You'll need to wait a minute and then you'll find yourself at your project dashboard. There you will find several services you can deploy to help build out your application. We will focus only on Authentication and Firestore.</p></li>
				<li>First, go to <strong class="source-inline">Authentication</strong> and click <strong class="source-inline">Get Started</strong>. Choose <strong class="source-inline">Email/Password</strong> and enable it. All the other authentication methods require additional setup steps. Go ahead and work through those steps if you like. The documentation on the Firebase website should be sufficient. Save your changes.</li>
				<li>Now click on <strong class="source-inline">Firestore Database</strong> and <strong class="source-inline">Create database</strong>. Choose the <strong class="source-inline">Start in test mode</strong> option and then choose a region to deploy to. The region doesn't really matter, but you probably want to choose something that is close to you for faster responses. Finish creating the database.</li>
				<li>One last thing we need to do in the Firebase console is find our app config. The way Firebase works is that a config object with a bunch of IDs will live in your app and manage connections to your Firebase backend; however, the security rules that govern which users can affect which data are all set up in the console (or the CLI, which this book doesn't cover). This config is not actually secret because if your app is set up correctly, there's nothing a malicious user can do that you haven't allowed.</li>
				<li>To get your app config, you first must register your app. You can add an app either from <strong class="source-inline">Project Overview</strong> (the <strong class="source-inline">&lt;/&gt;</strong> symbol) or via the gear next to <strong class="source-inline">Project Overview</strong>. Add a web app, name it anything you like, and skip the web hosting option. Go into your app config (gear icon) and find the config. Go with config over CDN (content delivery network) and you'll find something that looks like this:<p class="source-code">const firebaseConfig = {</p><p class="source-code">Â Â apiKey: "abc123",</p><p class="source-code">Â Â authDomain: "blog-xxx.firebaseapp.com",</p><p class="source-code">Â Â projectId: "blog-xxx",</p><p class="source-code">Â Â storageBucket: "blog-xxx.appspot.com",</p><p class="source-code">Â Â messagingSenderId: "999",</p><p class="source-code">Â Â appId: "1:123:web:123abc"</p><p class="source-code">};</p><p>Hang on to that config. We will need it later, but for now we are done in the Firebase console. You may wish to return to it later to view your database, manage your users, or even upgrade or delete your apps and projects, but you won't need to do so again in this chapter.</p></li>
			</ol>
			<p>Getting started with Firebase is easy. We'll be able to use Firebase to sign up, authenticate and track users, and store data, without having to write our own backend service.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor366"/>Styling React Applications</h1>
			<p>A modern UI developer has a lot of different options when it comes to styling applications. The traditional approach of creating a few <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) files and including them is not great for scaling or for building a unified presentation layer. Modern web applications and React in particular offer so many different options for styling that we can't hope to cover all of them. Here are a few popularÂ techniques.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor367"/>Master Stylesheet</h2>
			<p>We have a <strong class="source-inline">styles.css</strong> file with all the styles. Styles are global and will affect all components. This can work very well for a small application but has some serious scaling problems as you add more styles and components. When new styles are added, we may start to see existing components break as they are influenced by the new styles.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor368"/>Component-Scoped Styles</h2>
			<p>With this approach, we create a style for each component that needs styling and use the <strong class="source-inline">import</strong> keyword to add the style to your component. A build system such as webpack will prefix all of the style names so they don't "pollute" the global scope and wind up styling other components. This is the approach you get out of the box with Create React App, which uses webpack internally.</p>
			<p>This approach works well if you can effectively use plain CSS or a stylesheet compiler like Sass. Some developers don't like it because display elements are spread across CSS and JSX files.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor369"/>CSS-in-JS</h2>
			<p>CSS-in-JS is an approach that has produced popular libraries such as Styled Components and Emotion. The approach is simply that we write our CSS in our JavaScript (or TypeScript, in our case, as most of these libraries publish typings), thereby combining our styling with our display layer.</p>
			<p>This approach works well for teams that create lots of custom components. TheÂ downside is another build dependency to maintain.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor370"/>Component Libraries</h2>
			<p>Component libraries deliver fully usable components ready to be plugged into an application. Component libraries are great for building a nice-looking application very quickly. Many of them have been around for a lot of years. Some examples of component libraries are Twitter Bootstrap, Semantic UI, and Material-UI. All of these libraries publish versions designed to work with popular web systems such as Angular, Vue, and of course React.</p>
			<p>Working with a component library is a lot like working with your own components. You import the components and use them as you would any other component. Doing this can really speed up your development cycles as you have common components ready to go. Some teams find the components from the component library too inflexible and don't like to deal with the additional dependencies.</p>
			<p>The upcoming activity will use Material-UI for a quick and attractive build.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor371"/>Activity 14.01: The Blog</h2>
			<p>Now that we have some experience with <strong class="source-inline">create-react-app</strong> and Firebase, let's create a blog! In this activity, we will use all the tools and techniques covered earlier in this chapter. We will use <strong class="source-inline">create-react-app</strong> to quickly create a React project. We will use Material-UI to design an attractive app and write some of our own function components. We will use <strong class="source-inline">react-router</strong> to enable routing between the different pages of our application. We'll manage state with the React context API. Finally, we'll use Firebase to have a backend service we can use to authenticate users and save and share data between visits to the blog.</p>
			<p>Let's go through the high-level steps for creating this blog. It sounds like a lot, but it won't be all that challenging when we break it down into individual tasks:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found here: <a href="https://packt.link/qqIXz">https://packt.link/qqIXz</a>.</p>
			<ol>
				<li value="1">Create a new React application using <strong class="source-inline">create-react-app</strong>, as described earlier in this chapter. You could even reuse an application you began earlier in this chapter. Start your application so you can watch the implementation appear before your eyes.</li>
				<li>Refer back to your Firebase application from <em class="italic">Exercise 14.04, Getting Started with Firebase</em>, or complete that exercise if you haven't yet. Find your config data in Firebase and follow the instructions to add the <strong class="source-inline">firebase</strong> dependency to your React application, then add the app-specific config from the Firebase console.</li>
				<li>Implement the Firebase <strong class="source-inline">auth</strong> and <strong class="source-inline">firestore</strong> services, then add React context and providers for each to maintain state.<p>Install <strong class="source-inline">react-router</strong> and <strong class="source-inline">material-ui</strong> to build some UI components and create some routes. Start by creating a sign-up route and page:</p><div id="_idContainer169" class="IMG---Figure"><img src="image/B14508_14_05.jpg" alt="Figure 14.5: Landing page&#13;&#10;"/></div><p class="figure-caption">Figure 14.5: Landing page</p><div id="_idContainer170" class="IMG---Figure"><img src="image/B14508_14_06.jpg" alt="Figure 14.6: Sign-up page&#13;&#10;"/></div><p class="figure-caption">Figure 14.6: Sign-up page</p></li>
				<li>Create a route to add pages and add UI components to be able to set the title and link for a new story:<div id="_idContainer171" class="IMG---Figure"><img src="image/B14508_14_07.jpg" alt="Figure 14.7: Page for adding stories&#13;&#10;"/></div><p class="figure-caption">Figure 14.7: Page for adding stories</p></li>
				<li>Using your React context and provider and Firebase Firestore, persist your data to the cloud and implement other features such as comments:<div id="_idContainer172" class="IMG---Figure"><img src="image/B14508_14_08.jpg" alt="Figure 14.8: Commenting features&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.8: Commenting features</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B14508_14_09.jpg" alt="Figure 14.9: Posting a comment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9: Posting a comment</p>
			<p>If this activity took some time, don't worry. If you needed to check the solution on GitHub, don't worry about that either. This one was particularly challenging because it included so many different pieces, but if you managed to pull them all together into a working app, that's a great step forward. You've built a full-stack application with an attractive UI, authentication, and a database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor447">this link</a>.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor372"/>Summary</h1>
			<p>TypeScript is becoming a popular tool for writing web applications and while it wasn't always prevalent in React, it is now well supported. Developers no longer need to only add types to props but can gain the benefit of type safety and IntelliSense while working across all parts of an application.</p>
			<p>React has a very rich and varied ecosystem, but many TypeScript-friendly solutions such as React Hooks and React context are becoming go-to choices to keep an application simple but powerful. With TypeScript supported in <strong class="source-inline">create-react-app</strong>, it's simple to get started and you can be building your app in minutes.</p>
			<p>Developers who want to know more about React will need more than just this book, but this chapter serves to show why you want to stay with TypeScript when you write applications using React.</p>
		</div>
		<div>
			<div id="_idContainer175" class="Content">
			</div>
		</div>
	</body></html>