- en: Chapter 6. Working with Events, Sync, and Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed each Backbone component (view, model,
    collection, and router) separately and in detail. In this chapter, we are going
    to talk about the custom events, `Backbone.sync()` method and `Backbone.LocalStorage`.
    Though these topics are not exactly related to each other, we placed them in a
    single chapter as we need to cover each one of them before we move on to application
    architecture and patterns in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events are always considered as one of the most powerful concepts in JavaScript.
    They are a representation of the observer pattern (a well-known design pattern
    for loose coupling) and are used by most JavaScript libraries. In Backbone, `Backbone.Events`
    is a nontrivial module that can be used with any object to have event-related
    functionality. This is how `Backbone.Events` is defined in the Backbone documentation
    ([http://backbonejs.org/#Events](http://backbonejs.org/#Events)):'
  prefs: []
  type: TYPE_NORMAL
- en: Event is a module that can be mixed in to any object, giving the object the
    ability to bind and trigger custom named events.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss why events are important for Backbone application
    development and how we can use them to achieve higher reusability and a more structured
    application architecture. The main topics to be covered in this chapter are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom events**: Custom events are initialized by an application for a certain
    purpose that is not served by the base library we are using. We will learn how
    to create and use custom events in Backbone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event dispatcher**: Sometimes, we seek an application-level event manager
    that can work as the centralized tool for event-based communication. Different
    components of the application can interact with each other via this event manager,
    without directly communicating among themselves. In this section, we will learn
    how to create and use such an event dispatcher with our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method overriding**: In this topic, we will learn how overriding the `sync()`
    method of Backbone lets us create different persistent strategies for public REST
    APIs or `LocalStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offline storage**: The `Backbone.LocalStorage` adapter can be used with any
    Backbone model or collection to save the data onto a `LocalStorage` database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and using custom events are not a big deal in JavaScript—all of the
    major JavaScript libraries heavily depend on their own events to make their components
    loosely coupled. Each component possesses a set of custom events for better reusability
    and integration with the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a custom event in Backbone is quite simple—any object that extends
    the `Backbone.Events` class gets all of the event-related functionality, that
    is, listening to, triggering, and removing events. Backbone''s `View`, `Model`,
    `Collection`, and `Router` are the major components that extend the `Backbone.Events`
    class, and you can fire a custom event on any one of them when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a Backbone view instance, register a custom event to it, and
    fire the event. Once the event is fired, the registered function runs immediately
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Avoid callbacks, use custom events**'
  prefs: []
  type: TYPE_NORMAL
- en: This heading doesn't imply that you should always use events instead of callback
    methods. It depends on what the coder intends to achieve, it's absolutely an architectural
    choice. We intend to discuss this point to understand the cases in which events
    give much more flexibility than callbacks. Whenever there is a scenario when you
    need to notify others about a certain condition of any task, you will find that
    a custom event is a better choice than a callback function. Beginner-level developers
    often fall into this trap and end up using a callback method, which generally
    provides a more private and isolated approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will demonstrate the necessity of custom events
    with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: A simple case study on custom events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume we have a `Login` dialog box, and once the user inputs the username-password
    combination and clicks on the **Submit** button, a request is sent to the server
    to validate the login. On successful validation, the user closes the dialog box
    and does some other tasks, such as storing cookies, changing the page title, and
    so on. In such a case, we generally use a callback method and place all the post-login
    functionality in it. What if there are 10 different functions each to be called
    on separate objects once the login is successful? You may need all of these object
    references within that callback method to call the methods one by one. While this
    can be achieved without any issue, why not just fire a custom event `loggedin`
    once the user login is successful? The 10 objects that are already listening to
    the `loggedin` event can then call the related methods accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The other components that need to do those post-login tasks should already
    be listening to the `loggedin` event of that `loginView`, and the callback function
    will execute as soon as the event is fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass some parameters while triggering the event too; this data will
    be available in the event callback method as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using an event dispatcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice one thing in the previous scenario: to listen to the `loggedin` event,
    all the other components of the application should have a reference to that `loginView`.
    Is this really required? It may seem to a few components that keeping a reference
    to `loginView` is irrelevant, but they have to do so because they need to listen
    to the `loggedin` event on this `loginView` object. Dependency injection in such
    a way can be painful even when you are developing a simple application. Sometimes
    we may need a common object that will play the role of a central event manager
    and can be used throughout the application to trigger and listen to events. The
    simplest event dispatcher can be defined in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we make the `vent` variable available at the application-level, it can
    work as a centralized event dispatcher to publish and subscribe to events. This
    pattern is called PubSub pattern and is quite beneficial for use in a module-
    or widget-based application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should understand the context where this will be a good choice. An event
    dispatcher should be used when you either have too many components to listen to
    (as we saw in the case of the login example) or when you have some completely
    unrelated objects that need to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main problem that you may face while working with a common event dispatcher
    is that the number of publishers and subscribers may get out of control when too
    many events are registered through a single event dispatcher. For example, say
    we have two modules, `User` and `Company`, and both the modules are subscribed
    to an event named `addcomment` on the event dispatcher separately; they are defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the event name is the same, but the functions to be called are different.
    So, if you want another subscriber to be notified for the same event, you need
    to clear up all the other subscribers of that event first and then publish the
    event. However, there are a few other simple solutions to this issue, such as
    creating multiple event dispatchers or using different event namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple event dispatchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining a separate event dispatcher for individual modules or functionality
    can provide a solution to the problem we described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the same event names for different dispatchers will never clash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using different event namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is as simple as following a specific naming convention while using custom
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding a colon in the event name doesn't make the event special, but makes it
    different and unique because it now relates to some specific modules of the application.
    This is a convention heavily used by JavaScript developers and we encourage you
    to use it whenever required.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding memory leaks with the listenTo() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory management is a very important part of any application. Generally, for
    frontend development, developers do not bother much about memory leaks; however,
    this doesn''t hold true when we develop single page frontend-heavy applications.
    These types of applications deal with many frontend components and the lowest
    number of page refreshes, which can create several opportunities for memory leaks.
    While developing such applications, we should always be careful to clean up events
    when an object is destroyed. To understand this with an example, assume we have
    a view that displays its model''s data. The `render()` method of the view is called
    whenever the `change` event is fired on that model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, as you can see, we registered a `change` event on the model so that whenever
    any of its attributes change, the `render` method will be called. Then we created
    an instance of the view, changed the `name` attribute of the model, and destroyed
    the view. The `remove()` method destroys the `view` instance and removes the view
    from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole process works as expected, though with a slight problem. When you
    create a view in JavaScript, you create DOM nodes and bind event listeners to
    them. When you remove nodes from the DOM, their event listeners hold references
    to them. As a result, your JavaScript engine will not automatically garbage collect
    the nodes as there are still references to them in the scope. In our case too,
    even if the view is destroyed, the `change` event listener on the model persists
    and we need to take care of it explicitly. How can we do this? We can add a `close()`
    method to the view and unbind all such events in this method before destroying
    the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now everything is cleaned up properly. But do we need to keep doing this for
    all of our views? No, because Backbone V9.9 introduced a `listenTo()` method that
    tells an object to listen to an event of another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This works exactly the same way, but the advantage of this over the `on()` method
    is that it allows the object to keep track of events, and they can be removed
    all at once later on. So, we will not need an extra `close()` method to unbind
    all the events before destroying the view. Rather, the `remove()` method of Backbone
    view will now clean up any bound event by calling the `stopListening()` method.
  prefs: []
  type: TYPE_NORMAL
- en: So, use the `on()` method when you want to take care of the handler yourself
    and where scenarios like event cleanup or zombie handling will not arise. Otherwise,
    go for `listenTo()`, which we will mostly find useful in the context of Backbone
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the Backbone.sync() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone provides a single gateway for all its data communication. All the data
    requests are sent via the `sync()` method that gets called whenever any `CRUD`
    operation is processed. This `sync()` method does a number of jobs, such as setting
    the URL, parameters and content type, and mimicking HTTP requests for old browsers
    that do not support `PUT` and `DELETE` requests. Whenever we call a `fetch()`
    or `save()` method on a model or collection, the `sync()` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when do we need to override this method? Sometimes, you may need a separate
    implementation of the REST API method, which Backbone does not provide. This can
    be for a certain model or collection, or the implementation can persist for the
    complete project. This is how the method map is written in Backbone by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you may have a particular model or collection that will listen to a separate
    API other than the default one, say the Google or Twitter API, which you cannot
    change. Or, you may want to implement an offline storage that will use the browser''s
    local storage to operate on the data. In such cases, you need to override the
    `sync()` method of that collection or model, or if it is common throughout the
    application, you need to override the `Backbone.sync()` method. Let''s understand
    its importance with an example. Here we want our `User` module to interact directly
    with the public API `FooApi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Look how we used a `switch` case to call the `FooApi` method for each of the
    data operation methods. Now, when you call the `save()` method on the user instance,
    it will call the `FooApi.add()` method directly. You can use the other data operations
    similarly. So, this is the way in which Backbone's `sync()` method is overridden
    to create a wrapper that maps the models and methods of another API.
  prefs: []
  type: TYPE_NORMAL
- en: Offline storage using the Backbone.LocalStorage adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how overriding the `Backbone.sync()` method
    provides you with customized data operations, including models and collections.
    Most of the time, we use the HTML5 `LocalStorage` functionality to store our data
    in the browser for offline browsing. This is a pretty common requirement for storing
    small data in a browser while developing mobile websites and mobile web applications.
    The `LocalStorage` communication can also be done with the help of the `sync()`
    method in a way that is exactly the same as the technique used in the previous
    section by overriding the `sync()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than creating this solution ourselves, we will look into an excellent
    adapter, `Backbone.LocalStorage` ([http://documentup.com/jeromegn/backbone.localStorage](http://documentup.com/jeromegn/backbone.localStorage)),
    which was developed by Jerome Gravel-Niquet and widely used by the Backbone.js
    developer community for interacting with `LocalStorage`. This adapter can be plugged
    into any model or collection, and thus enables them to communicate with `LocalStorage`
    using the `save()` or `fetch()` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we defined a collection by passing an instance of `Backbone.LocalStorage`
    to the `LocalStorage` property. This is the only configuration that is requires
    to attach the collection to `LocalStorage` and perform all of the data operations
    on it. Also, this configuration works for both the model and the collection. If
    you want to know how the `sync()` functionality has been implemented within this
    adapter, go ahead and look into the adapter code—it's small and pretty well-written.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular `LocalStorage` adapter is `Backbone.dualStorage` ([https://github.com/nilbus/Backbone.dualStorage](https://github.com/nilbus/Backbone.dualStorage)).
    There are quite a few adapters available online and all of them provide a similar
    functionality. So, if you want to follow some tool other than the one we mentioned,
    you are free to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events in JavaScript are one of the most interesting concepts; lots of articles
    and books are available on this subject. We didn't try to look into all the details
    in this chapter, but we analyzed how using custom events and an event dispatcher
    in your Backbone application can provide enormous flexibility and scalability
    to the application architecture. We encourage you to explore JavaScript events,
    function scopes, and an event dispatcher or PubSub pattern if you need a more
    detailed idea about it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also learned about Backbone's `sync()` method and how we
    can override the `sync()` method to get custom data operations for public APIs
    or the HTML5 `LocalStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have looked at various components of Backbone and discussed their best
    practices, few plugins and extensions related to them, and some common issues.
    In the next chapter, we will see how we can organize Backbone applications with
    different design patterns and architecture.
  prefs: []
  type: TYPE_NORMAL
