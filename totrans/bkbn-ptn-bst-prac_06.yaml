- en: Chapter 6. Working with Events, Sync, and Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 与事件、同步和存储一起工作
- en: In the previous chapters, we discussed each Backbone component (view, model,
    collection, and router) separately and in detail. In this chapter, we are going
    to talk about the custom events, `Backbone.sync()` method and `Backbone.LocalStorage`.
    Though these topics are not exactly related to each other, we placed them in a
    single chapter as we need to cover each one of them before we move on to application
    architecture and patterns in the next chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们分别详细讨论了每个 Backbone 组件（视图、模型、集合和路由器）。在本章中，我们将讨论自定义事件、`Backbone.sync()`
    方法以及 `Backbone.LocalStorage`。尽管这些主题之间并不完全相关，但我们将它们放在一个章节中，因为我们需要在进入下一章的应用程序架构和模式之前涵盖它们。
- en: 'Events are always considered as one of the most powerful concepts in JavaScript.
    They are a representation of the observer pattern (a well-known design pattern
    for loose coupling) and are used by most JavaScript libraries. In Backbone, `Backbone.Events`
    is a nontrivial module that can be used with any object to have event-related
    functionality. This is how `Backbone.Events` is defined in the Backbone documentation
    ([http://backbonejs.org/#Events](http://backbonejs.org/#Events)):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事件始终被认为是 JavaScript 中最强大的概念之一。它们是观察者模式（一个著名的松散耦合设计模式）的表示，并被大多数 JavaScript 库使用。在
    Backbone 中，`Backbone.Events` 是一个非平凡的模块，可以与任何对象一起使用以具有事件相关功能。这是在 Backbone 文档中定义
    `Backbone.Events` 的方式（[http://backbonejs.org/#Events](http://backbonejs.org/#Events)）：
- en: Event is a module that can be mixed in to any object, giving the object the
    ability to bind and trigger custom named events.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 事件是一个可以混合到任何对象中的模块，它赋予对象绑定和触发自定义命名事件的能力。
- en: 'In this chapter, we will discuss why events are important for Backbone application
    development and how we can use them to achieve higher reusability and a more structured
    application architecture. The main topics to be covered in this chapter are as
    follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论为什么事件对于 Backbone 应用程序开发很重要，以及我们如何使用它们来实现更高的重用性和更结构化的应用程序架构。本章将涵盖的主要内容包括：
- en: '**Custom events**: Custom events are initialized by an application for a certain
    purpose that is not served by the base library we are using. We will learn how
    to create and use custom events in Backbone.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义事件**：自定义事件是由应用程序为了某个目的而初始化的，这个目的不是我们使用的基库所服务的。我们将学习如何在 Backbone 中创建和使用自定义事件。'
- en: '**Event dispatcher**: Sometimes, we seek an application-level event manager
    that can work as the centralized tool for event-based communication. Different
    components of the application can interact with each other via this event manager,
    without directly communicating among themselves. In this section, we will learn
    how to create and use such an event dispatcher with our application.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件分发器**：有时，我们寻求一个应用级的事件管理器，它可以作为一个基于事件通信的集中工具。应用程序的不同组件可以通过这个事件管理器相互交互，而无需直接相互通信。在本节中，我们将学习如何使用我们的应用程序创建和使用这样的事件分发器。'
- en: '**Method overriding**: In this topic, we will learn how overriding the `sync()`
    method of Backbone lets us create different persistent strategies for public REST
    APIs or `LocalStorage`.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法覆盖**：在本主题中，我们将学习如何通过覆盖 Backbone 的 `sync()` 方法来创建针对公共 REST API 或 `LocalStorage`
    的不同持久化策略。'
- en: '**Offline storage**: The `Backbone.LocalStorage` adapter can be used with any
    Backbone model or collection to save the data onto a `LocalStorage` database.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离线存储**：`Backbone.LocalStorage` 适配器可以与任何 Backbone 模型或集合一起使用，将数据保存到 `LocalStorage`
    数据库中。'
- en: Understanding custom events
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自定义事件
- en: Creating and using custom events are not a big deal in JavaScript—all of the
    major JavaScript libraries heavily depend on their own events to make their components
    loosely coupled. Each component possesses a set of custom events for better reusability
    and integration with the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，创建和使用自定义事件并不是什么大问题——所有主要的 JavaScript 库都严重依赖于它们自己的事件来实现组件的松散耦合。每个组件都有一组自定义事件，以实现更好的重用性和与应用程序的集成。
- en: 'Creating a custom event in Backbone is quite simple—any object that extends
    the `Backbone.Events` class gets all of the event-related functionality, that
    is, listening to, triggering, and removing events. Backbone''s `View`, `Model`,
    `Collection`, and `Router` are the major components that extend the `Backbone.Events`
    class, and you can fire a custom event on any one of them when needed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Backbone 中创建一个自定义事件相当简单——任何扩展了 `Backbone.Events` 类的对象都会获得所有与事件相关的功能，即监听、触发和删除事件。Backbone
    的 `View`、`Model`、`Collection` 和 `Router` 是扩展了 `Backbone.Events` 类的主要组件，并且当需要时，你可以在它们中的任何一个上触发一个自定义事件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we create a Backbone view instance, register a custom event to it, and
    fire the event. Once the event is fired, the registered function runs immediately
    as expected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 Backbone 视图实例，向其注册一个自定义事件，并触发该事件。一旦事件被触发，注册的函数就会立即按预期运行。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Avoid callbacks, use custom events**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免回调，使用自定义事件**'
- en: This heading doesn't imply that you should always use events instead of callback
    methods. It depends on what the coder intends to achieve, it's absolutely an architectural
    choice. We intend to discuss this point to understand the cases in which events
    give much more flexibility than callbacks. Whenever there is a scenario when you
    need to notify others about a certain condition of any task, you will find that
    a custom event is a better choice than a callback function. Beginner-level developers
    often fall into this trap and end up using a callback method, which generally
    provides a more private and isolated approach.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题并不意味着你应该总是使用事件而不是回调方法。这取决于程序员想要实现的目标，这绝对是一个架构选择。我们打算讨论这个点，以便理解在哪些情况下事件比回调提供了更多的灵活性。每当有需要通知他人关于任何任务特定条件的情况时，你会发现自定义事件比回调函数是一个更好的选择。入门级开发者常常陷入这个陷阱，最终使用回调方法，这通常提供了一种更私密和隔离的方法。
- en: In the following section, we will demonstrate the necessity of custom events
    with a simple example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将通过一个简单的示例来展示自定义事件必要性的例子。
- en: A simple case study on custom events
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件的一个简单案例研究
- en: 'Assume we have a `Login` dialog box, and once the user inputs the username-password
    combination and clicks on the **Submit** button, a request is sent to the server
    to validate the login. On successful validation, the user closes the dialog box
    and does some other tasks, such as storing cookies, changing the page title, and
    so on. In such a case, we generally use a callback method and place all the post-login
    functionality in it. What if there are 10 different functions each to be called
    on separate objects once the login is successful? You may need all of these object
    references within that callback method to call the methods one by one. While this
    can be achieved without any issue, why not just fire a custom event `loggedin`
    once the user login is successful? The 10 objects that are already listening to
    the `loggedin` event can then call the related methods accordingly:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `登录` 对话框，一旦用户输入用户名-密码组合并点击 **提交** 按钮，就会向服务器发送一个请求来验证登录。验证成功后，用户关闭对话框并执行一些其他任务，例如存储cookies、更改页面标题等。在这种情况下，我们通常使用回调方法，并将所有登录后的功能放在其中。如果登录成功后需要调用10个不同的函数，每个函数在单独的对象上执行，那会怎样？你可能需要在那个回调方法中包含所有这些对象引用来逐个调用方法。虽然这可以无问题地实现，但为什么不在用户登录成功后只触发一个自定义事件
    `loggedin` 呢？已经监听 `loggedin` 事件的10个对象就可以相应地调用相关方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The other components that need to do those post-login tasks should already
    be listening to the `loggedin` event of that `loginView`, and the callback function
    will execute as soon as the event is fired:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行那些登录后任务的其它组件应该已经监听了那个 `loginView` 的 `loggedin` 事件，并且回调函数将在事件触发时立即执行：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can pass some parameters while triggering the event too; this data will
    be available in the event callback method as arguments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在触发事件时，你也可以传递一些参数；这些数据将在事件回调方法中以参数的形式可用：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using an event dispatcher
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件分发器
- en: 'Notice one thing in the previous scenario: to listen to the `loggedin` event,
    all the other components of the application should have a reference to that `loginView`.
    Is this really required? It may seem to a few components that keeping a reference
    to `loginView` is irrelevant, but they have to do so because they need to listen
    to the `loggedin` event on this `loginView` object. Dependency injection in such
    a way can be painful even when you are developing a simple application. Sometimes
    we may need a common object that will play the role of a central event manager
    and can be used throughout the application to trigger and listen to events. The
    simplest event dispatcher can be defined in the following way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上一个场景中的一个细节：要监听 `loggedin` 事件，应用程序的所有其他组件都应该有对该 `loginView` 的引用。这真的是必需的吗？对于一些组件来说，保持对
    `loginView` 的引用可能看起来无关紧要，但它们必须这样做，因为它们需要在这个 `loginView` 对象上监听 `loggedin` 事件。即使在开发简单应用程序时，这种依赖注入也可能很痛苦。有时我们可能需要一个充当中央事件管理器的通用对象，并且可以在整个应用程序中用来触发和监听事件。最简单的事件分发器可以按以下方式定义：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we make the `vent` variable available at the application-level, it can
    work as a centralized event dispatcher to publish and subscribe to events. This
    pattern is called PubSub pattern and is quite beneficial for use in a module-
    or widget-based application architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `vent` 变量在应用程序级别公开时，它可以作为一个中央事件分发器来发布和订阅事件。这种模式被称为 Pub/Sub 模式，在基于模块或小部件的应用程序架构中使用时非常有益。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should understand the context where this will be a good choice. An event
    dispatcher should be used when you either have too many components to listen to
    (as we saw in the case of the login example) or when you have some completely
    unrelated objects that need to communicate with each other.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该理解在什么情况下这将是一个好的选择。当您有太多组件需要监听（正如我们在登录示例中看到的那样）或者当您有一些完全无关的对象需要相互通信时，应使用事件分发器。
- en: 'The main problem that you may face while working with a common event dispatcher
    is that the number of publishers and subscribers may get out of control when too
    many events are registered through a single event dispatcher. For example, say
    we have two modules, `User` and `Company`, and both the modules are subscribed
    to an event named `addcomment` on the event dispatcher separately; they are defined
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用通用事件分发器工作时，您可能会遇到的主要问题是，当通过单个事件分发器注册了太多事件时，发布者和订阅者的数量可能会失去控制。例如，假设我们有两个模块，`User`
    和 `Company`，并且这两个模块分别订阅了事件分发器上的名为 `addcomment` 的事件；它们被定义为如下：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the event name is the same, but the functions to be called are different.
    So, if you want another subscriber to be notified for the same event, you need
    to clear up all the other subscribers of that event first and then publish the
    event. However, there are a few other simple solutions to this issue, such as
    creating multiple event dispatchers or using different event namespaces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，事件名称相同，但要调用的函数不同。因此，如果您想通知另一个订阅者同一事件，您需要首先清除该事件的全部其他订阅者，然后发布该事件。然而，还有一些其他简单的解决方案可以解决这个问题，例如创建多个事件分发器或使用不同的事件命名空间。
- en: Creating multiple event dispatchers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多个事件分发器
- en: 'Defining a separate event dispatcher for individual modules or functionality
    can provide a solution to the problem we described previously:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为单个模块或功能定义单独的事件分发器可以为我们之前描述的问题提供一个解决方案：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, the same event names for different dispatchers will never clash:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不同分发器的相同事件名称永远不会冲突：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using different event namespaces
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不同的事件命名空间
- en: 'This is as simple as following a specific naming convention while using custom
    events:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在自定义事件中使用特定的命名约定一样简单：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding a colon in the event name doesn't make the event special, but makes it
    different and unique because it now relates to some specific modules of the application.
    This is a convention heavily used by JavaScript developers and we encourage you
    to use it whenever required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件名称中添加冒号并不会使事件变得特殊，但它确实使其不同且独特，因为它现在与应用程序的某些特定模块相关联。这是 JavaScript 开发者广泛使用的一种约定，我们鼓励您在需要时使用它。
- en: Avoiding memory leaks with the listenTo() method
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 listenTo() 方法避免内存泄漏
- en: 'Memory management is a very important part of any application. Generally, for
    frontend development, developers do not bother much about memory leaks; however,
    this doesn''t hold true when we develop single page frontend-heavy applications.
    These types of applications deal with many frontend components and the lowest
    number of page refreshes, which can create several opportunities for memory leaks.
    While developing such applications, we should always be careful to clean up events
    when an object is destroyed. To understand this with an example, assume we have
    a view that displays its model''s data. The `render()` method of the view is called
    whenever the `change` event is fired on that model:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是任何应用程序都非常重要的一部分。通常，对于前端开发，开发者不会太在意内存泄漏；然而，当我们开发单页前端密集型应用时，这一点并不成立。这类应用处理许多前端组件和最少的页面刷新次数，这可能会为内存泄漏创造几个机会。在开发这类应用时，我们应该始终小心地清理对象销毁时的事件。为了通过例子来理解这一点，假设我们有一个显示其模型数据的视图。每当在该模型上触发`change`事件时，视图的`render()`方法就会被调用：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, as you can see, we registered a `change` event on the model so that whenever
    any of its attributes change, the `render` method will be called. Then we created
    an instance of the view, changed the `name` attribute of the model, and destroyed
    the view. The `remove()` method destroys the `view` instance and removes the view
    from the DOM.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，我们在模型上注册了一个`change`事件，以便每当其任何属性发生变化时，`render`方法就会被调用。然后我们创建了一个视图实例，更改了模型的`name`属性，并销毁了视图。`remove()`方法销毁了`view`实例，并将视图从DOM中移除。
- en: 'The whole process works as expected, though with a slight problem. When you
    create a view in JavaScript, you create DOM nodes and bind event listeners to
    them. When you remove nodes from the DOM, their event listeners hold references
    to them. As a result, your JavaScript engine will not automatically garbage collect
    the nodes as there are still references to them in the scope. In our case too,
    even if the view is destroyed, the `change` event listener on the model persists
    and we need to take care of it explicitly. How can we do this? We can add a `close()`
    method to the view and unbind all such events in this method before destroying
    the view:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程按预期工作，尽管存在一个小问题。当你用JavaScript创建一个视图时，你创建了DOM节点并将事件监听器绑定到它们上。当你从DOM中移除节点时，它们的监听器仍然持有对它们的引用。结果，你的JavaScript引擎不会自动回收这些节点，因为作用域中仍然有对它们的引用。在我们的情况下，即使视图被销毁，模型上的`change`事件监听器仍然存在，我们需要明确处理它。我们如何做到这一点？我们可以在视图中添加一个`close()`方法，并在销毁视图之前在这个方法中解绑所有此类事件：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now everything is cleaned up properly. But do we need to keep doing this for
    all of our views? No, because Backbone V9.9 introduced a `listenTo()` method that
    tells an object to listen to an event of another object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都被正确清理了。但我们是否需要为所有视图都这样做？不，因为Backbone V9.9引入了一个`listenTo()`方法，它告诉一个对象去监听另一个对象的某个事件：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This works exactly the same way, but the advantage of this over the `on()` method
    is that it allows the object to keep track of events, and they can be removed
    all at once later on. So, we will not need an extra `close()` method to unbind
    all the events before destroying the view. Rather, the `remove()` method of Backbone
    view will now clean up any bound event by calling the `stopListening()` method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`on()`方法的工作方式完全相同，但它的优势在于它允许对象跟踪事件，并且可以在稍后一次性移除它们。因此，我们不需要额外的`close()`方法来在销毁视图之前解绑所有事件。相反，Backbone视图的`remove()`方法现在会通过调用`stopListening()`方法来清理任何已绑定的事件。
- en: So, use the `on()` method when you want to take care of the handler yourself
    and where scenarios like event cleanup or zombie handling will not arise. Otherwise,
    go for `listenTo()`, which we will mostly find useful in the context of Backbone
    views.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你想自己处理处理器，并且不会出现事件清理或僵尸处理等场景时，请使用`on()`方法。否则，选择`listenTo()`，我们将在Backbone视图的上下文中发现它非常有用。
- en: Overriding the Backbone.sync() method
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖Backbone的sync()方法
- en: Backbone provides a single gateway for all its data communication. All the data
    requests are sent via the `sync()` method that gets called whenever any `CRUD`
    operation is processed. This `sync()` method does a number of jobs, such as setting
    the URL, parameters and content type, and mimicking HTTP requests for old browsers
    that do not support `PUT` and `DELETE` requests. Whenever we call a `fetch()`
    or `save()` method on a model or collection, the `sync()` method is executed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 为所有数据通信提供了一个单一的网关。所有的数据请求都是通过 `sync()` 方法发送的，每当进行任何 `CRUD` 操作时都会调用这个方法。这个
    `sync()` 方法执行多项任务，例如设置 URL、参数和内容类型，以及模拟不支持 `PUT` 和 `DELETE` 请求的老式浏览器的 HTTP 请求。每当我们在模型或集合上调用
    `fetch()` 或 `save()` 方法时，都会执行 `sync()` 方法。
- en: 'But when do we need to override this method? Sometimes, you may need a separate
    implementation of the REST API method, which Backbone does not provide. This can
    be for a certain model or collection, or the implementation can persist for the
    complete project. This is how the method map is written in Backbone by default:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们何时需要覆盖这个方法呢？有时，你可能需要一个单独的 REST API 方法的实现，而 Backbone 并不提供。这可能适用于某个模型或集合，或者这种实现可能在整个项目中持续存在。这就是
    Backbone 默认如何编写方法映射的方式：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, you may have a particular model or collection that will listen to a separate
    API other than the default one, say the Google or Twitter API, which you cannot
    change. Or, you may want to implement an offline storage that will use the browser''s
    local storage to operate on the data. In such cases, you need to override the
    `sync()` method of that collection or model, or if it is common throughout the
    application, you need to override the `Backbone.sync()` method. Let''s understand
    its importance with an example. Here we want our `User` module to interact directly
    with the public API `FooApi`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能有一个特定的模型或集合，它将监听除默认之外的其他 API，比如 Google 或 Twitter API，而你无法更改它。或者，你可能想实现一个使用浏览器本地存储来操作数据的离线存储。在这种情况下，你需要覆盖该集合或模型的
    `sync()` 方法，或者如果它在整个应用程序中是通用的，你需要覆盖 `Backbone.sync()` 方法。让我们通过一个例子来理解其重要性。在这里，我们希望我们的
    `User` 模块直接与公共 API `FooApi` 交互：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Look how we used a `switch` case to call the `FooApi` method for each of the
    data operation methods. Now, when you call the `save()` method on the user instance,
    it will call the `FooApi.add()` method directly. You can use the other data operations
    similarly. So, this is the way in which Backbone's `sync()` method is overridden
    to create a wrapper that maps the models and methods of another API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是怎样使用 `switch` case 来调用每个数据操作方法的 `FooApi` 方法。现在，当你对用户实例调用 `save()` 方法时，它将直接调用
    `FooApi.add()` 方法。你可以用类似的方式使用其他数据操作。所以，这就是 Backbone 的 `sync()` 方法被覆盖以创建一个映射其他
    API 的模型和方法包装器的方式。
- en: Offline storage using the Backbone.LocalStorage adapter
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Backbone.LocalStorage 适配器的离线存储
- en: In the previous section, we saw how overriding the `Backbone.sync()` method
    provides you with customized data operations, including models and collections.
    Most of the time, we use the HTML5 `LocalStorage` functionality to store our data
    in the browser for offline browsing. This is a pretty common requirement for storing
    small data in a browser while developing mobile websites and mobile web applications.
    The `LocalStorage` communication can also be done with the help of the `sync()`
    method in a way that is exactly the same as the technique used in the previous
    section by overriding the `sync()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何通过覆盖 `Backbone.sync()` 方法来提供定制的数据操作，包括模型和集合。大多数时候，我们使用 HTML5 的
    `LocalStorage` 功能在浏览器中存储我们的数据以供离线浏览。这对于开发移动网站和移动网络应用时存储小数据来说是一个相当常见的需求。`LocalStorage`
    通信也可以通过使用 `sync()` 方法以与上一节中通过覆盖 `sync()` 方法所用的相同技术来完成。
- en: 'Rather than creating this solution ourselves, we will look into an excellent
    adapter, `Backbone.LocalStorage` ([http://documentup.com/jeromegn/backbone.localStorage](http://documentup.com/jeromegn/backbone.localStorage)),
    which was developed by Jerome Gravel-Niquet and widely used by the Backbone.js
    developer community for interacting with `LocalStorage`. This adapter can be plugged
    into any model or collection, and thus enables them to communicate with `LocalStorage`
    using the `save()` or `fetch()` methods as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会自己创建这个解决方案，而是会查看一个优秀的适配器，`Backbone.LocalStorage` ([http://documentup.com/jeromegn/backbone.localStorage](http://documentup.com/jeromegn/backbone.localStorage))，这是由
    Jerome Gravel-Niquet 开发的，并被 Backbone.js 开发者社区广泛用于与 `LocalStorage` 交互。这个适配器可以插入到任何模型或集合中，从而使得它们可以使用
    `save()` 或 `fetch()` 方法与 `LocalStorage` 通信，如下所示：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we defined a collection by passing an instance of `Backbone.LocalStorage`
    to the `LocalStorage` property. This is the only configuration that is requires
    to attach the collection to `LocalStorage` and perform all of the data operations
    on it. Also, this configuration works for both the model and the collection. If
    you want to know how the `sync()` functionality has been implemented within this
    adapter, go ahead and look into the adapter code—it's small and pretty well-written.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过将 `Backbone.LocalStorage` 的实例传递给 `LocalStorage` 属性来定义一个集合。这是将集合附加到 `LocalStorage`
    并在其上执行所有数据操作所需的唯一配置。此外，此配置适用于模型和集合。如果你想了解此适配器中 `sync()` 功能是如何实现的，请查看适配器代码——它很小，而且写得相当不错。
- en: Another popular `LocalStorage` adapter is `Backbone.dualStorage` ([https://github.com/nilbus/Backbone.dualStorage](https://github.com/nilbus/Backbone.dualStorage)).
    There are quite a few adapters available online and all of them provide a similar
    functionality. So, if you want to follow some tool other than the one we mentioned,
    you are free to do so.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的 `LocalStorage` 适配器是 `Backbone.dualStorage` ([https://github.com/nilbus/Backbone.dualStorage](https://github.com/nilbus/Backbone.dualStorage))。网上有相当多的适配器可供选择，并且它们都提供了类似的功能。因此，如果你想跟随我们未提及的工具，你完全自由地这样做。
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Events in JavaScript are one of the most interesting concepts; lots of articles
    and books are available on this subject. We didn't try to look into all the details
    in this chapter, but we analyzed how using custom events and an event dispatcher
    in your Backbone application can provide enormous flexibility and scalability
    to the application architecture. We encourage you to explore JavaScript events,
    function scopes, and an event dispatcher or PubSub pattern if you need a more
    detailed idea about it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的事件是其中最有趣的概念之一；关于这个主题有很多文章和书籍。我们并没有在本章中尝试查看所有细节，但我们分析了在 Backbone
    应用程序中使用自定义事件和事件分发器如何为应用架构提供巨大的灵活性和可扩展性。我们鼓励你探索 JavaScript 事件、函数作用域和事件分发器或 PubSub
    模式，如果你需要更详细的想法的话。
- en: In this chapter, we also learned about Backbone's `sync()` method and how we
    can override the `sync()` method to get custom data operations for public APIs
    or the HTML5 `LocalStorage`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们也学习了 Backbone 的 `sync()` 方法以及我们如何覆盖 `sync()` 方法以获取用于公共 API 或 HTML5 `LocalStorage`
    的自定义数据操作。
- en: Also, we have looked at various components of Backbone and discussed their best
    practices, few plugins and extensions related to them, and some common issues.
    In the next chapter, we will see how we can organize Backbone applications with
    different design patterns and architecture.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了 Backbone 的各种组件，讨论了它们的最佳实践，以及与它们相关的几个插件和扩展，以及一些常见问题。在下一章中，我们将看到如何使用不同的设计模式和架构来组织
    Backbone 应用程序。
