<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-159"><a id="_idTextAnchor168"/>8</h1>
<h1 id="_idParaDest-160"><a id="_idTextAnchor169"/>Logging and Monitoring Your Application</h1>
<p>Maintaining records and metrics provides us with many advantages during our development cycle. They can help us increase our application’s performance, observe issues before they become problems, and give us insights into the application’s state. Logging and monitoring your application can reduce the time your development (and debugging) takes, as well as the number of headaches you acquire throughout the project. Logging is something that is often overlooked or treated with minimal afterthought, but it could make the difference between losing an hour’s worth of uptime or an entire day’s worth.</p>
<p>Suppose we had an application that simply inserted the details of a registration form into a database table. One day, the team accidentally renamed the <code>first_name</code> column to <code>firstname</code> and now no new records were being inserted. With logging, we would see something along the lines of a “<code>first_name</code> column does not exist” type of error. This would help guide us into looking at the database’s schema and figuring out where the disconnection is occurring (in this case, our typo from removing the underscore).</p>
<p>What if the error was more complex than that though? Our application is now running in a cluster and each node within the cluster receives a unique message exclusively from the other nodes. Occasionally, we would notice our table was missing some records without a clear pattern from the data itself. Using a logging mechanism, we would occasionally see a <code>Could not establish connection</code> error. We can double-check our connection pooling management (if applicable) or test each node if we can successfully connect to the database. On a small cluster, this would not be a problem, but on a large system, this could become tedious and time-consuming.</p>
<p>A solution for helping manage applications in a larger cluster would be to customize (or add) additional context to your application’s logging records. Meta-information such as the machine’s identifier could have helped us in the previous example. Sequelize offers a way to customize our logging, using an <code>options.logging</code> parameter, with the ability to change the logging behavior with different method invocations.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Configuring logging with all of the available interfaces</li>
<li>Integrating third-party logging applications such as Pino or Bunyan</li>
<li>Collecting metrics and statistics for Sequelize with OpenTelemetry</li>
</ul>
<h1 id="_idParaDest-161"><a id="_idTextAnchor170"/>Technical requirements</h1>
<p>You can find the code files for this chapter at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8</a></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor171"/>Configuring logging with all of the available interfaces</h1>
<p>Sequelize offers a few overload signatures<a id="_idIndexMarker635"/> for incorporating logs<a id="_idIndexMarker636"/> into an application. The default behavior is to call <code>console.log</code> for each query. The following is a list of signatures that Sequelize will abide by:</p>
<ul>
<li><code>function (msg) {}</code></li>
<li><code>function (...msg) {}</code></li>
<li><code>true</code>/<code>false</code></li>
<li><code>msg =&gt; someLogger.debug(msg)</code></li>
<li><code>someLogger.debug.bind(someLogger)</code></li>
</ul>
<p>If we wanted to customize Sequelize’s logging behavior, the following example would be a quick introduction to how to do so:</p>
<pre class="source-code">
function customLog(msg) {
    // insert into db/logger app here
    // ...
    // and output to stdout
    console.log(msg);
}
const sequelize = new Sequelize('sqlite::memory:', {
    logging: customLog
});</pre>
<p>In addition to Sequelize sending<a id="_idIndexMarker637"/> the SQL queries into our <code>customLog</code> function, we<a id="_idIndexMarker638"/> are also given a helper method for when we need to log additional info beyond our queries. The Sequelize instance provides a <code>log</code> method and can be called as shown here:</p>
<pre class="source-code">
sequelize.log('this will send our message to customLog as 
well');</pre>
<p>If your Sequelize instance’s <code>benchmark</code> parameter is set to <code>true</code>, then Sequelize will add the total elapsed time for the query to complete at the end of the message. Using our previous example, a log entry might look something similar to this:</p>
<pre>Executed (default): SELECT * FROM ...; Elapsed time: 136ms</pre>
<p>Sometimes, we will want to log the log query, query objects, applicable parameters, or any other form of metadata. Sequelize will recognize the spread pattern for this type of support:</p>
<pre class="source-code">
function multiLog(...msgs) {
    msgs.forEach(function(msg) {
        console.log(msg);
    });
}
const sequelize = new Sequelize('sqlite::memory:', {
    logging: multiLog
});</pre>
<p>We can now call the Sequelize instance’s <code>log</code> method, which will send the parameters to our <code>multiLog</code> function as follows:</p>
<pre class="source-code">
sequelize.log('error', 'custom error message', Date.now(), { id: 100 });</pre>
<p>This would print each parameter onto its own newline due to the behavior of the <code>multiLog</code> function.</p>
<p>The logging parameter can also accept a Boolean value. The <code>true</code> value will coalesce into Sequelize’s default behavior (<code>console.log</code>). Setting the value to <code>false</code> would disable logging completely and nullify any log invocations. The following example would prevent Sequelize from logging queries:</p>
<pre class="source-code">
const sequelize = new Sequelize('sqlite::memory:', {
    logging: false
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">The <code>true</code> value for logging is considered deprecated and is not preferable to omitting the logging value for the default behavior or using <code>console.log</code> as the parameter’s value.</p>
<p>Sequelize can also limit logging<a id="_idIndexMarker639"/> to specific queries with the logging parameter<a id="_idIndexMarker640"/> on each queryable method (for example, <code>findAll</code>, <code>update</code>, and <code>create</code>). For instance, if we wanted to disable logging on a specific query, we can do so by setting the following query’s <code>logging</code> parameter to <code>false</code>:</p>
<pre class="source-code">
sequelize.findAll({
  where: {
    id: 1
  }
}, {
  logging: false
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can also see a log output <a id="_idIndexMarker641"/>of queries by taking advantage<a id="_idIndexMarker642"/> of Sequelize’s use of the debug NPM package. By setting the environment variable to <code>DEBUG=sequelize:sql*</code>, your terminal should show queries executed by Sequelize.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor172"/>Integrating third-party logging applications such as Pino or Bunyan</h1>
<p>If our application already utilizes a third-party application for logging, Sequelize can offer support for integrating with such systems. This section references two logging applications, Pino and Bunyan, but any logging library or framework should also be compatible with Sequelize.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor173"/>Integrating with Pino</h2>
<p>Pino is a low overhead<a id="_idIndexMarker643"/> Node.js logger that also offers redaction, transport, and asynchronous support. Presuming our project has Pino installed within our <code>node_modules</code> folder, we can simply integrate it with our Sequelize instance as follows:</p>
<pre class="source-code">
const logger = require('pino')();
const sequelize = new Sequelize('sqlite::memory:', {
    logging: (msg) =&gt; logger.debug(msg)
});</pre>
<p>Now, when we call <code>sequelize.log</code> manually or execute queries, the logs will be sent to the Pino logging library. The output would look similar to this:</p>
<pre>{"level":30,"time":1650118644700,"pid":5363,"hostname":"MacBook-Pro-4.local","msg":"Executing (default): SHOW INDEX FROM `Airplanes` FROM `airline`"}</pre>
<p>For more information<a id="_idIndexMarker644"/> on Pino, you can refer to the project’s repository at <a href="https://github.com/pinojs/pino">https://github.com/pinojs/pino</a>.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor174"/>Integrating with Bunyan</h2>
<p>Sometimes a logging framework<a id="_idIndexMarker645"/> requires an intermediary step before being able to bind the framework to Sequelize. An example of this would be the Bunyan framework. Bunyan is a logging framework that focuses on offering serialization and streaming methods. Integrating this framework would look similar to the following:</p>
<pre class="source-code">
const bunyan = require('bunyan');
const logger = bunyan.createLogger({name: 'app'});
const sequelize = new Sequelize('sqlite::memory:', {
    logging: (msg) =&gt; logger.info(msg)
});</pre>
<p>The preceding example shows the output of Bunyan’s logging with Sequelize:</p>
<pre>{"name":"app","hostname":"MacBook-Pro-4.local","pid":6014,"level":30,"msg":"Executing (default): SHOW INDEX FROM `Airplanes` FROM `airline`","time":"2022-04-16T14:33:13.083Z","v":0}</pre>
<p>For more information on Bunyan, you can refer to the project’s repository at <a href="https://github.com/trentm/node-bunyan">https://github.com/trentm/node-bunyan</a>.</p>
<p>From the Pino and Bunyan examples, we can see that adding a logging framework already resolves our unique machine identifier, the time of the error, and urgency research. By looking at the logs, it should now be easier to sift through wherever an error is occurring within clusters or applications.</p>
<p>We can now finish integrating a logging framework within the Avalon Airlines project. From the project’s root directory, we will need to install the necessary package:</p>
<pre>npm i pino</pre>
<p>Within <code>models/index.js</code>, see the following line:</p>
<pre class="source-code">
const Sequelize = require('sequelize/core');</pre>
<p>Export the Pino framework underneath with a constant:</p>
<pre class="source-code">
const logger = require('pino')();</pre>
<p>After exporting the constant, see this line:</p>
<pre class="source-code">
const db = {};</pre>
<p>Underneath, we can add the logging parameter to the <code>config</code> object as follows:</p>
<pre class="source-code">
config.logging = (msg) =&gt; logger.info(msg);</pre>
<p>Now, our application<a id="_idIndexMarker646"/> supports custom logs using the Pino logging framework.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor175"/>Collecting metrics and statistics for Sequelize with OpenTelemetry</h1>
<p>OpenTelemetry is a standardized specification<a id="_idIndexMarker647"/> for collecting, aggregating, and instrumenting<a id="_idIndexMarker648"/> various statistics, metrics, traces, and logs. OpenTelemetry<a id="_idIndexMarker649"/> can help us identify where bottlenecks<a id="_idIndexMarker650"/> may occur, categorize and apply topological<a id="_idIndexMarker651"/> filters on logs, and plug into third-party applications (for example, for alert monitoring). </p>
<p>To integrate OpenTelemetry with Sequelize, we would need to install the following packages within our Avalon Airlines project:</p>
<pre>npm i @opentelemetry/api @opentelemetry/sdk-trace-node @opentelemetry/instrumentation @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node opentelemetry-instrumentation-sequelize</pre>
<p>Within <code>models/index.js</code>, under the <code>'use strict';</code> line, we can now add our new packages:</p>
<pre class="source-code">
const { NodeTracerProvider } = 
    require(‹@opentelemetry/sdk-trace-node');
const { registerInstrumentations } = 
    require('@opentelemetry/instrumentation');
const { SequelizeInstrumentation } = 
    require(‹opentelemetry-instrumentation-sequelize');</pre>
<p>Just above the <code>let sequelize;</code> line, we can<a id="_idIndexMarker652"/> add the trace provider, which<a id="_idIndexMarker653"/> will register<a id="_idIndexMarker654"/> the correct Sequelize<a id="_idIndexMarker655"/> OpenTelemetry plugin:</p>
<pre class="source-code">
const tracerProvider = new NodeTracerProvider({
  plugins: {
    sequelize: {
      // disabling the default/old plugin is required
      enabled: false,
      path: ‹opentelemetry-plugin-sequelize'
    }
  }
});</pre>
<p>Below the <code>traceProvider</code> declaration block, we can associate the provider with the Sequelize instrument specifications:</p>
<pre class="source-code">
registerInstrumentations({
  tracerProvider,
  instrumentations: [
    new SequelizeInstrumentation({
      // any custom instrument options here
    })
  ]
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find additional references and option parameters for Sequelize instrumentation at <a href="https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize">https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize</a>.</p>
<p>At the root directory<a id="_idIndexMarker656"/> of the Avalon Airline<a id="_idIndexMarker657"/>s project, create<a id="_idIndexMarker658"/> a file called <code>tracing.js</code> with<a id="_idIndexMarker659"/> the following code:</p>
<pre class="source-code">
const opentelemetry = require("@opentelemetry/sdk-node");
const { getNodeAutoInstrumentations } = 
    require(«@opentelemetry/auto-instrumentations-node");
const sdk = new opentelemetry.NodeSDK({
  traceExporter: new opentelemetry.tracing.
      ConsoleSpanExporter(),
      instrumentations: [getNodeAutoInstrumentations()]
});
sdk.start();</pre>
<p>Now, we can call our application with the following command:</p>
<pre>node -r "./tracing.js" index.js</pre>
<p>After that, open a browser<a id="_idIndexMarker660"/> to the project’s URL (by default, <code>http://localhost:3000/</code>) and refresh the page<a id="_idIndexMarker661"/> a few times. After a few seconds, you should <a id="_idIndexMarker662"/>see some events within your terminal<a id="_idIndexMarker663"/> that look similar to this:</p>
<pre class="source-code">
{
  traceId: '7c25880d655f67e5d8e15b83129dc95e',
  parentId: '934dc0ed012f6e37',
  name: ‹SELECT›,
  id: ‹af16347a3fbbf923›,
  kind: 2,
  timestamp: 1650124004289597,
  duration: 1616,
  attributes: {
    ‹db.system': 'mysql',
    ‹net.peer.name›: ‹127.0.0.1›,
    ‹net.peer.port': 3306,
    ‹db.connection_string':'jdbc:mysql://127.0.0.1:3306/
         airline›,
    ‹db.name›: ‹airline›,
    ‹db.user': 'root',
    ‹db.statement': 'SELECT `id`, `planeModel`, 
        `totalSeats`, `createdAt`, `updatedAt` FROM 
        `Airplanes` AS `Airplane`;›
  },
  status: { code: 0 },
  events: []
}</pre>
<p>Traditionally, the application<a id="_idIndexMarker664"/> would export<a id="_idIndexMarker665"/> this data to a collector such as Zipkin (<a href="https://zipkin.io/">https://zipkin.io/</a>), Jaeger (<a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a>), or Prometheus (<a href="https://prometheus.io/">https://prometheus.io/</a>). For instructions<a id="_idIndexMarker666"/> on how to associate the application’s telemetry<a id="_idIndexMarker667"/> data, you can refer to this tutorial here: https://opentelemetry.io/docs/instrumentation/js/exporters/.</p>
<p>If you were to use Zipkin as your collector, then under the <code>const tracerProvider = new NodeTracerProvider({</code> block within <code>models/index.js</code>, we would replace this line:</p>
<pre class="source-code">
provider.addSpanProcessor(new BatchSpanProcessor(new 
    ZipkinExporter()))</pre>
<p>We need to replace it with the following:</p>
<pre class="source-code">
tracerProvider.addSpanProcessor(new BatchSpanProcessor(new 
    ZipkinExporter()));</pre>
<p>This will tell<a id="_idIndexMarker668"/> our trace provider<a id="_idIndexMarker669"/> to export the traces and logs<a id="_idIndexMarker670"/> to the Zipkin<a id="_idIndexMarker671"/> Exporter (multiple exporters can be used at the same time).</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor176"/>Summary</h1>
<p>In this chapter, we went through the different overload signatures for configuring logging with Sequelize. We also learned how to integrate third-party frameworks, such as OpenTelemetry, within our Node.js application. </p>
<p>In the next chapter, we will be covering how to integrate plugins, or adapters, into our Sequelize instance. The following chapter will also demonstrate how to create our own adapter.</p>
</div>
</div></body></html>