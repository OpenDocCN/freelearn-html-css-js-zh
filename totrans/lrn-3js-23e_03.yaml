- en: Chapter 3. Working with the Different Light Sources Available in Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter, you learned about the basics of Three.js, and in the
    previous chapter, we looked a bit deeper at the most important parts of the scene:
    the geometries, meshes, and cameras. You might have noticed that we skipped lights
    in that chapter even though they make up an important part of every Three.js scene.
    Without lights, we won''t see anything rendered. Since Three.js contains a large
    number of lights, each of which has a specific use, we''ll use this whole chapter
    to explain the various details of the lights and prepare you for the next chapter
    on material usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebGL itself doesn't have inherent support for lighting. Without Three.js, you
    would have to write specific WebGL shader programs to simulate these kinds of
    lights. A good introduction on simulating lighting in WebGL from scratch can be
    found at [https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL](https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: The light sources that are available in Three.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a specific light source should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can tune and configure the behavior of all these light sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a bonus, we'll also quickly look at how you can create lens flares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with all the chapters, we have a lot of examples that you can use to experiment
    with the lights' behavior. The examples shown in this chapter can be found in
    the `chapter-03` folder of the supplied sources.
  prefs: []
  type: TYPE_NORMAL
- en: Different kinds of lighting provided by Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of different lights available in Three.js that all have
    specific behavior and usages. In this chapter, we''ll discuss the following set
    of lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.AmbientLight` | This is a basic light, the color of which is added
    to the current color of the objects in the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.PointLight` | This is a single point in space from which light spreads
    in all directions. This light can''t be used to create shadows. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.SpotLight` | This light source has a cone-like effect like that of
    a desk lamp, a spot in the ceiling, or a torch. This light can cast shadows. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.DirectionalLight` | This is also called infinite light. The light
    rays from this light can be seen as parallel, like, for instance, the light from
    the sun. This light can also be used to create shadows. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.HemisphereLight` | This is a special light and can be used to create
    more natural-looking outdoors lighting by simulating a reflective surface and
    a faintly illuminating sky. This light also doesn''t provide any shadow-related
    functionality. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.AreaLight` | With this light source, instead of a single point in
    space, you can specify an area from which light emanates. `THREE.AreaLight` doesn''t
    cast any shadows. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.LensFlare` | This is not a light source, but with `THREE.LensFlare`,
    you can add a lens flare effect to the lights in your scene. |'
  prefs: []
  type: TYPE_TB
- en: 'This chapter is divided into two main parts. First, we''ll look at the basic
    lights: `THREE.AmbientLight`, `THREE.PointLight`, `THREE.SpotLight`, and `THREE.DirectionalLight`.
    All these lights extend the base `THREE.Light` object, which provides shared functionality.
    The lights mentioned here are simple lights that require little setting up and
    can be used to recreate most of the required lighting scenarios. In the second
    part, we will look at a couple of special-purpose lights and effects: `THREE.HemisphereLight`,
    `THREE.AreaLight`, and `THREE.LensFlare`. You''ll probably only need these lights
    in very specific cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with the most basic of the lights: `THREE.AmbientLight`.'
  prefs: []
  type: TYPE_NORMAL
- en: THREE.AmbientLight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create `THREE.AmbientLight`, the color is applied globally. There isn't
    a specific direction this light comes from, and `THREE.AmbientLight` doesn't contribute
    to any shadows. You would normally not use `THREE.AmbientLight` as the single
    source of light in a scene since it colors all the objects in the same color,
    regardless of shape. You use it together with other lighting sources, such as
    `THREE.SpotLight` or `THREE.DirectionalLight` to soften the shadows or add some
    additional color to the scene. The easiest way to understand this is by looking
    at the `01-ambient-light.html` example in the `chapter-03` folder. With this example,
    you get a simple user interface that can be used to modify `THREE.AmbientLight`
    that is available in this scene. Note that in this scene, we also have `THREE.SpotLight`,
    which adds additional lighting and provides shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that we used the scene from the first
    chapter and made the color of `THREE.AmbientLight` configurable. In this example,
    you can also turn off the spotlight to see what the effect of `THREE.AmbientLight`
    is on its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.AmbientLight](img/2215OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The standard color we use in this scene is `#0c0c0c`. This is a hexadecimal
    representation of a color. The first two values specify the red part of the color,
    the next two values specify the green part, and the last two values specify the
    blue part.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we use a very dimmed light-gray color that we mainly use to
    smoothen the hard shadows our meshes cast to the ground plane. You can change
    the color to a more prominent yellow/orange color (`#523318`) with the menu in
    the top-right corner, and then the objects will have a sun-like glow over them.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.AmbientLight](img/2215OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the preceding image shows, the yellow/orange color is applied to all the
    objects and casts a green glow over the complete scene. What you should remember
    when working with this light is that you should be very conservative with the
    color you specify. If the color you specify is too bright, you'll quickly get
    a completely oversaturated image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen what it does, let''s look at how you can create and use
    `THREE.AmbientLight`. The next couple of lines of code show you how to create
    `THREE.AmbientLight` and also show how to connect this to the GUI control menu,
    which we will introduce in [Chapter 11](ch11.html "Chapter 11. Custom Shaders
    and Render Postprocessing"), *Custom Shaders and Render Post Processing*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating `THREE.AmbientLight` is very simple and only takes a couple of steps.
    `THREE.AmbientLight` doesn''t have a position and is applied globally, so we only
    need to specify the color (in hex), `new THREE.AmbientLight(ambiColor)`, and add
    this light to the scene, `scene.add(ambientLight)`. In the example, we bind the
    color of `THREE.AmbientLight` to the control menu. To do this, you can use the
    same kind of configuration we used in the previous two chapters. The only change
    is that instead of using the `gui.add(...)` function, we use the `gui.addColor(...)`
    function. This creates an option in the control menu, with which we can directly
    change the color of the passed-in variable. In the code, you can see that we use
    the `onChange` feature of dat.GUI: `gui.addColor(...).onChange(function(e){...})`.
    With this function, we tell `dat.GUI` to call the passed-in function each time
    the color changes. In this specific case, we set the color of `THREE.AmbientLight`
    to a new value.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the THREE.Color object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we move on to the next light, here''s a quick note on using the `THREE.Color`
    object. In Three.js, when you construct an object, you can (usually) specify the
    color as either a hex string (`"#0c0c0c"`) or a hex value (`0x0c0c0c`), which
    is the preferred way of doing it, or by specifying the individual RGB values (`0.3`,
    `0.5`, `0.6`) on a scale of 0 to 1\. If you want to change the color after construction,
    you''ll have to create a new `THREE.Color` object or modify the internal properties
    of the current `THREE.Color` object. The `THREE.Color` object comes with the following
    functions to set and get information about the current object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `set(value)` | Set the value of this color to the supplied hex value. This
    hex value may be a string, a number, or an existing `THREE.Color` instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `setHex(value)` | Set the value of this color to the supplied numeric hex
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `setRGB(r,g,b)` | Set the value of this color based on the supplied RGB values.
    The values range from 0 to 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `setHSL(h,s,l)` | Set the value of this color on the supplied HSL values.
    The values range from 0 to 1\. A good explanation of how HSL works for configuring
    colors can be found at [http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL](http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setStyle(style)` | Set the value of this color based on the CSS way of specifying
    colors. For instance, you could use `"rgb(255,0,0)"`, `"#ff0000"`, `"#f00"`, or
    even `"red"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `copy(color)` | Copy the color values from the `THREE.Color` instance provided
    to this color. |'
  prefs: []
  type: TYPE_TB
- en: '| `copyGammaToLinear(color)` | This is mostly used internally.Set the color
    of this object based on the `THREE.Color` instance supplied. The color is first
    converted from the gamma color space to the linear color space. The gamma color
    space also uses RGB values, but uses an exponential scale instead of a linear
    one. |'
  prefs: []
  type: TYPE_TB
- en: '| `copyLinearToGamma(color)` | This is mostly used internally.Set the color
    of this object based on the `THREE.Color` instance supplied. The color is first
    converted from the linear color space to the gamma color space. |'
  prefs: []
  type: TYPE_TB
- en: '| `convertGammaToLinear()` | This converts the current color from the gamma
    color space to the linear color space. |'
  prefs: []
  type: TYPE_TB
- en: '| `convertLinearToGamma()` | This converts the current color from the linear
    color space to the gamma color space. |'
  prefs: []
  type: TYPE_TB
- en: '| `getHex()` | Return the value from this color object as a number: `435241`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getHexString()` | Return the value from this color object as a hex string:
    `"0c0c0c"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getStyle()` | Return the value from this color object as a CSS-based value:
    `"rgb(112,0,0)"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getHSL(optionalTarget)` | Return the value from this color object as a HSL
    value. If you provide the `optionalTarget` object, Three.js will set the `h`,
    `s`, and `l` properties on that object. |'
  prefs: []
  type: TYPE_TB
- en: '| `offsetHSL(h, s, l)` | Add the `h`, `s`, and `l` values provided to the `h`,
    `s`, and `l` values of the current color. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(color)` | This adds the `r`, `g`, and `b` values of the color supplied
    to the current color. |'
  prefs: []
  type: TYPE_TB
- en: '| `addColors(color1, color2)` | This is mostly used internally.Add `color1`
    and `color2`, and set the value of the current color to the result. |'
  prefs: []
  type: TYPE_TB
- en: '| `addScalar(s)` | This is mostly used internally.Add a value to the RGB components
    of the current color. Bear in mind that the internal values use a range from 0
    to 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply(color)` | This is mostly used internally.Multiply the current RGB
    values with the RGB values from `THREE.Color`. |'
  prefs: []
  type: TYPE_TB
- en: '| `multiplyScalar(s)` | This is mostly used internally.This multiplies the
    current RGB values with the value supplied. Bear in mind that the internal values
    use a range from 0 to 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `lerp(color, alpha)` | This is mostly used internally.This finds the color
    that is between the color of this object and the color supplied. The alpha property
    defines how far between the current color and the supplied color you want the
    result to be. |'
  prefs: []
  type: TYPE_TB
- en: '| `equals(color)` | This returns `true` if the RGB values of the `THREE.Color`
    instance supplied match the values of the current color. |'
  prefs: []
  type: TYPE_TB
- en: '| `fromArray(array)` | This has the same functionality as `setRGB`, but now
    the RGB values can be provided as an array of numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `toArray` | This returns an array with three elements, `[r, g, b]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `clone()` | This creates an exact copy of this color. |'
  prefs: []
  type: TYPE_TB
- en: In this table, you can see that there are many ways in which you can change
    the current color. A lot of these functions are used internally by Three.js, but
    they also provide a good way to easily change the color of lights and materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the discussion on `THREE.PointLight`, `THREE.SpotLight`,
    and `THREE.DirectionalLight`, let''s first highlight their main difference, that
    is, how they emit light. The following diagram shows how these three light sources
    emit light:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the THREE.Color object](img/2215OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the following from this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.PointLight` emits light from a specific point in all directions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.SpotLight` emits light from a specific point in a cone-like shape'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.DirectionalLight` doesn''t emit light from a single point, but emits
    light rays from a 2D plane, where the rays are parallel to each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at these light sources in more detail in the next couple of paragraphs;
    let's start with `THREE.Pointlight`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.PointLight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.PointLight` in Three.js is a light source that shines light in all directions
    emanating from a single point. A good example of a point light is a signal flare
    fired in the night sky. Just as with all the lights, we have a specific example
    you can use to play around with `THREE.PointLight`. If you look at `02-point-light.html`
    in the `chapter-03` folder, you can find an example where a `THREE.PointLight`
    light is moving around a simple Three.js scene. The following screenshot shows
    an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.PointLight](img/2215OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, `THREE.PointLight` moves around the scene we already saw in
    [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"),
    *Create Your First 3D Scene with Three.js*. To make it more clear where `THREE.PointLight`
    is, we move a small orange sphere along the same path. As this light moves around,
    you'll see the red cube and blue sphere being illuminated by this light on different
    sides.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might notice that we don't see any shadows in this example. In Three.js,
    `THREE.PointLight` doesn't cast shadows. Since `THREE.PointLight` emits light
    in all directions, calculating shadows is a very heavy process for the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `THREE.AmbientLight` we saw earlier, all you had to do was provide
    `THREE.Color` and add the light to the scene. With `THREE.PointLight`, however,
    we have a couple of additional configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color of the light. |'
  prefs: []
  type: TYPE_TB
- en: '| `distance` | This is the distance for which the light shines. The default
    value is `0`, which means that the light''s intensity doesn''t decrease based
    on distance. |'
  prefs: []
  type: TYPE_TB
- en: '| `intensity` | This is the intensity the light shines with. This defaults
    to `1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `position` | This is the position of the light in `THREE.Scene`. |'
  prefs: []
  type: TYPE_TB
- en: '| `visible` | If this property is set to `true` (the default), this light is
    turned on, and if set it to `false`, the light is turned off. |'
  prefs: []
  type: TYPE_TB
- en: 'In the next couple of examples and screenshots, we''ll explain these properties.
    First, let''s look at how you can create `THREE.PointLight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We create a light with a specific `color` property (here we use a string value;
    we could have also used a number or `THREE.Color`), set its `position` property,
    and add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first property we''ll look at is `intensity`. With this property, you can
    set how brightly the light shines. If you set this to `0`, you won''t see anything;
    set it to `1`, and you''ve got the default brightness; set it to `2`, and you
    get a light that shines twice as bright; and so on. In the following screenshot,
    for instance, we set the intensity of the light to `2.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.PointLight](img/2215OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All you have to do to change the intensity of the light is use the intensity
    property of `THREE.PointLight`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the dat.GUI listener, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distance` property of `PointLight` is a very interesting one and is best
    explained with an example. In the following screenshot, you see the same scene
    again, but this time with a very high `intensity` property (we have a very bright
    light), but with a small `distance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.PointLight](img/2215OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `distance` property of `SpotLight` determines how far the light travels
    from the source before its intensity property is 0\. You can set this property
    like this: `pointLight.distance = 14`. In the preceding screenshot, the light''s
    brightness slowly decreases to `0` at a distance of `14`. That''s why, in the
    example, you can still see a brightly lit cube, but the light won''t reach the
    blue sphere. The default value for the `distance` property is `0`, which means
    that the light won''t decay over a distance.'
  prefs: []
  type: TYPE_NORMAL
- en: THREE.SpotLight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.SpotLight` is one of the lights you''ll use most often (especially if
    you want to use shadows). `THREE.SpotLight` is a light source that has a cone-like
    effect. You can compare this with a flashlight or a lantern. This light has a
    direction and an angle at which it produces light. The following table lists all
    the properties that apply to `THREE.SpotLight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `angle` | This determines how wide the beam emerging from this light is.
    This is measured in radians and defaults to `Math.PI/3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `castShadow` | If set to `true`, this light will cast shadows. |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color of the light. |'
  prefs: []
  type: TYPE_TB
- en: '| `distance` | This is the distance up to which the light shines. The default
    value is `0`, which means that the light''s intensity doesn''t decrease based
    on distance. |'
  prefs: []
  type: TYPE_TB
- en: '| `exponent` | With `THREE.SpotLight`, the emitted light''s intensity decreases
    the further away you are from the source. The `exponent` property determines how
    quickly this intensity decreases. With a low value, the light emitted from this
    source will reach faraway objects, while with a high value, it will only reach
    objects that are very near to `THREE.SpotLight`. |'
  prefs: []
  type: TYPE_TB
- en: '| `intensity` | This is the intensity the light shines with. This defaults
    to 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `onlyShadow` | If this property is set to `true`, this light will only cast
    a shadow and won''t add any light to the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `position` | This is the position of the light in `THREE.Scene`. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowBias` | The shadow bias moves the cast shadow away or towards the
    object casting the shadow. You can use this to solve some strange effects when
    you work with very thin objects (a good example can be found at [http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias](http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias)).
    If you see strange shadow effects, small values (for example, `0.01`) for this
    property can often resolve the issue. The default value for this property is `0`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowCameraFar` | This determines what distance from the light shadows
    should be created. The default value is `5,000`. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowCameraFov` | This determines how large the field of view used to create
    shadows is (see the *Different cameras for different uses* section in [Chapter
    2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js Scene"), *Basic
    Components That Make Up a Three.js Scene*). The default value is `50`. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowCameraNear` | This determines what distance from the light shadows
    should be created. The default value is `50`. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowCameraVisible` | If this is set to `true`, you can see how and where
    this light source casts a shadow (see the example in the next section). The default
    value is `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowDarkness` | This defines how dark the shadow is rendered. This can''t
    be changed after the scene is rendered. The default value is `0.5`. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowMapWidth` and `shadowMapHeight` | This determines how many pixels
    are used to create the shadow. Increase this when the shadow has jagged edges
    or doesn''t look smooth. This can''t be changed after the scene is rendered. The
    default value for both is `512`. |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | With `THREE.SpotLight`, the direction it is pointed in is important.
    With the `target` property, you can point `THREE.SpotLight` to look at a specific
    object or position in the scene. Note that this property requires a `THREE.Object3D`
    object (like `THREE.Mesh`). This is in contrast to the cameras we saw in the previous
    chapter that use `THREE.Vector3` in their `lookAt` function. |'
  prefs: []
  type: TYPE_TB
- en: '| `visible` | If this is set to `true` (the default), this light is turned
    on, and if this is set to `false`, the light is turned off. |'
  prefs: []
  type: TYPE_TB
- en: 'Creating `THREE.SpotLight` is very easy. Just specify the color, set the properties
    you want, and add it to the scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`THREE.SpotLight` is not very different from `THREE.PointLight`. The only difference
    is that we set the `castShadow` property to `true` because we want shadows, and
    we need to set the `target` property for this `SpotLight`. The `target` property
    determines where the light is aimed at. In this case, we point it at the object
    named `plane`. When you run the example (`03-spot-light.html`), you''ll see a
    scene like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.SpotLight](img/2215OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you can set a number of properties specific to `THREE.SpotLight`.
    One of them is the `target` property. If we set this property to the blue sphere,
    the light will focus at the center of the sphere even if it moves around the scene.
    When we created the light, we aimed it at the ground plane, and in our example,
    we can also aim it at the other two objects. But what if you don''t want to aim
    the light at a specific object, but rather at an arbitrary point in space? You
    can do that by creating a `THREE.Object3D()` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set the target property of `THREE.SpotLight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the table at the beginning of this section, we showed a couple of properties
    that can be used to control how the light emanates from `THREE.SpotLight`. The
    `distance` and `angle` properties define the shape of the cone of light. The `angle`
    property defines the width of the cone, and with the `distance` property, we set
    the length of the cone. The following figure explains how these two values together
    define the area that will receive light from `THREE.SpotLight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.SpotLight](img/2215OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Usually, you won''t really need to set these values since they come with reasonable
    defaults, but you can use these properties, for instance, to create a `THREE.SpotLight`
    that has a very narrow beam or quickly decreases in light intensity. The last
    property you can use to change the way `THREE.SpotLight` produces light is the
    `exponent` property. With this property, you set how fast the light intensity
    decreases from the center of the light cone towards the edges of the cone. In
    the following image, you can see the result of the `exponent` property in action.
    We have a very bright light (high `intensity`) that rapidly decreases in intensity
    (high `exponent`) as it moves from the center towards the sides of the cone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.SpotLight](img/2215OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You could use this to highlight a specific object or simulate a small flashlight.
    We could also have created the same focused beam effect using a small `exponent`
    value and `angle`. On a cautionary note on this second approach, remember that
    a very small angle can quickly lead to all kinds of rendering artifacts (an artifact
    is a term used in graphics for unwanted distortions and strangely rendered parts
    of the screen).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the next light, we''ll quickly look at the shadow-related
    properties available to `THREE.SpotLight`. You''ve already learned that we can
    get shadows by setting the `castShadow` property of `THREE.SpotLight` to `true`
    (and, of course, making sure that we set the `castShadow` property for objects
    that should cast shadows, and that we cast the `receiveShadow` property, for objects
    that should show a shadow, on the `THREE.Mesh` objects in our scene). Three.js
    also allows you very fine-grained control on how the shadow is rendered. This
    is done by a couple of properties we explained in the table at the beginning of
    the section. With `shadowCameraNear`, `shadowCameraFar`, and `shadowCameraFov`,
    you can control how and where this light casts a shadow. This works in the same
    way as the perspective camera''s field of view we explained in the preceding chapter.
    The easiest way to see this in action is by setting `shadowCameraVisible` to `true`;
    you can do this by checking the menu''s debug checkbox. This shows, as you can
    see in the following screenshot, the area that is used to determine the shadows
    for this light:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.SpotLight](img/2215OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll end this section with a couple of pointers, just in case you run into
    issues with shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the `shadowCameraVisible` property. This shows the area that is affected
    by this light for shadow purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the shadow looks blocky, you can either increase the `shadowMapWidth` and
    `shadowMapHeight` properties or make sure the area that is used to calculate the
    shadow tightly wraps your object. You can use the `shadowCameraNear`, `shadowCameraFar`,
    and `shadowCameraFov` properties to configure this area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that you not only have to tell the light to cast shadows, but also
    have to tell each geometry whether it will receive and/or cast shadows by setting
    the `castShadow` and `receiveShadow` properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use thin objects in your scene, you might see strange artifacts when
    you render shadows. You can use the `shadowBias` property to slightly offset the
    shadows, which will often fix these kinds of issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change the darkness of the shadow cast by setting the `shadowDarkness`
    property. If your shadows are too dark or not dark enough, changing this property
    allows you to fine-tune how the shadows are rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to have softer shadows, you can set a different `shadowMapType value`
    on `THREE.WebGLRenderer`. By default, this property is set to `THREE.PCFShadowMap`;
    if you set this property to `PCFSoftShadowMap`, you get softer shadows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: THREE.DirectionalLight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last of the basic lights we will look at is `THREE.DirectionalLight`. This
    type of light can be considered as a light that is very far away. All the light
    rays it sends out are parallel to each other. A good example of this is the sun.
    The sun is so far away that the light rays we receive on earth are (almost) parallel
    to each other. The main difference between `THREE.DirectionalLight` and `THREE.SpotLight`
    (which we saw in the previous section) is that this light won't diminish the farther
    it gets from the target of `THREE.DirectionalLight` as it does with `THREE.SpotLight`
    (you can fine-tune this with the `distance` and `exponent` parameters). The complete
    area that is lit by `THREE.DirectionalLight` receives the same intensity of light.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, look at the `04-directional-light` example, which is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.DirectionalLight](img/2215OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding image, there isn't a cone of light that is applied
    to the scene. Everything receives the same amount of light. Only the direction,
    the color, and the intensity of the light is used to calculate the colors and
    shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with `THREE.SpotLight`, there are a couple of properties you can set
    that control the intensity of the light and the way it casts shadows. `THREE.DirectionalLight`
    has a lot of properties that are the same as those of `THREE.SpotLight`: `position`,
    `target`, `intensity`, `distance`, `castShadow`, `onlyShadow`, `shadowCameraNear`,
    `shadowCameraFar`, `shadowDarkness`, `shadowCameraVisible`, `shadowMapWidth`,
    `shadowMapHeight`, and `shadowBias`. For information on those properties, you
    can look at the preceding section on `THREE.SpotLight`. The few additional properties
    are discussed in the next couple of paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look back at the `THREE.SpotLight` examples, you can see that we had
    to define the cone of light where shadows were applied. Since, for `THREE.DirectionalLight`,
    all the rays are parallel to each other, we don''t have a cone of light, instead,
    we have a cuboid area, as you can see in the following screenshot (if you want
    to see this for yourself, move the camera further away from the scene):'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.DirectionalLight](img/2215OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything that falls within this cube can cast and receive shadows from the
    light. Just as for `THREE.SpotLight`, the tighter you define this area around
    the objects, the better your shadows will look. Define this cube using the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can compare this with the way we configured the orthographic camera in the
    section on cameras in [Chapter 2](ch02.html "Chapter 2. Basic Components That
    Make Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one property that is available to `THREE.DirectionalLight` that we
    haven''t addressed yet: `shadowCascade`. This property can be used to create better
    shadows when you want to use shadows on a large area with `THREE.DirectionalLight`.
    If you set the property to `true`, Three.js will use an alternative approach to
    generate the shadows. It splits the shadow generation up to the value specified
    by `shadowCascadeCount`. This will result in more detailed shadows close to the
    viewpoint of the camera and less detailed shadows far away. To use this, you''ll
    have to experiment with the settings for `shadowCascadeCount`, `shadowCascadeBias`,
    `shadowCascadeWidth`, `shadowCascadeHeight`, `shadowCascadeNearZ`, and `shadowCascadeFarZ`.
    You can find an example where this setup is used at [http://alteredqualia.com/three/examples/webgl_road.html](http://alteredqualia.com/three/examples/webgl_road.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Special lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section on special lights, we'll discuss two additional lights provided
    by Three.js. First, we'll discuss `THREE.HemisphereLight`, which helps in creating
    more natural lighting for outdoor scenes, then we'll look at `THREE.AreaLight`,
    which emits lights from a large area instead of a single point, and finally, we'll
    show you how you can add a lens flare effect to your scene.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.HemisphereLight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first special light we''re going to look at is `THREE.HemisphereLight`.
    With `THREE.HemisphereLight`, we can create more natural-looking outdoor lighting.
    Without this light, we could simulate the outdoors by creating `THREE.DirectionalLight`,
    which emulates the sun, and maybe add additional `THREE.AmbientLight` to provide
    some general color to the scene. This, however, won''t look really natural. When
    you''re outdoors, not all the light comes directly from above: much is diffused
    by the atmosphere and reflected by the ground and other objects. `THREE.HemisphereLight`
    in Three.js is created for this scenario. This is an easy way to get more natural-looking
    outdoor lighting. To see an example, look at `05-hemisphere-light.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.HemisphereLight](img/2215OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is the first example that loads additional resources and can't
    run directly from your local filesystem. So if you haven't done so, look at [Chapter
    1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"), *Create
    Your First 3D Scene with Three.js*, to find out how to set up a local web server
    or disable the security settings in your browser to make loading external resources
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you can turn `THREE.HemisphereLight` on and off and set the
    colors and intensity. Creating a hemisphere light is just as easy as creating
    any of the other lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You just specify the color that is received from the sky, the color received
    from the ground, and the intensity of these lights. If you want to change these
    values later on, you can access them through the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `groundColor` | This is the color that is emitted from the ground |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color that is emitted from the sky |'
  prefs: []
  type: TYPE_TB
- en: '| `intensity` | This is the intensity with which the light shines |'
  prefs: []
  type: TYPE_TB
- en: THREE.AreaLight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last real light source we''ll look at is `THREE.AreaLight`. With `THREE.AreaLight`,
    we can define a rectangular area that emits light. `THREE.AreaLight` isn''t included
    in the standard Three.js library, but in its extensions, so we have to take a
    couple of additional steps before we can use this light source. Before we look
    at the details, let''s first look at the result we''re aiming for (`06-area-light.html`
    opens this example); the following screenshot encapsulates the result we want
    to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.AreaLight](img/2215OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What you see in this screenshot is that we've defined three `THREE.AreaLight`
    objects, each with their own color. You can also see how these lights affect the
    whole area.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to use `THREE.AreaLight`, we can't use `THREE.WebGLRenderer`, which
    we used in our examples until now. The reason is that `THREE.AreaLight` is a very
    complex light source that would cause a very serious performance penalty in the
    normal `THREE.WebGLRenderer` object. It uses a different approach when rendering
    a scene (it breaks it up into multiple steps) and can handle complex lights (or
    a very high number of light sources for that matter) much better than the standard
    `THREE.WebGLRenderer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `THREE.WebGLDeferredRenderer`, we have to include a couple of additional
    JavaScript sources provided by Three.js. In the head of your HTML skeleton, make
    sure you have the following set of `<script>` sources defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With these libraries included, we can use `THREE.WebGLDeferredRenderer`. We
    can use this renderer in pretty much the same way as the one we discussed in the
    other examples. It just takes a couple of extra arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about what all these properties mean at the moment. In
    [Chapter 10](ch10.html "Chapter 10. Loading and Working with Textures"), *Loading
    and Working with Textures*, we'll dive deeper into `THREE.WebGLDeferredRenderer`
    and explain them to you. With the correct JavaScript libraries and a different
    renderer, we can start adding `Three.AreaLight`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this in pretty much the same way as all the other lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a new `THREE.AreaLight`. This light has a color
    value of `0xff0000` and an intensity value of `3`. Just like the other lights,
    we can use the `position` attribute to set its location in the scene. When you
    create `THREE.AreaLight`, it will be created as a horizontal plane. In our example,
    we created three `THREE.AreaLight` objects that are positioned vertically, so
    we need to rotate our lights `-Math.PI/2` around their *x* axis. Finally, we set
    the size of `THREE.AreaLight` using the `width` and `height` properties and add
    them to the scene. If you try this yourself for the first time, you might wonder
    why you don''t see anything where you positioned your light. This is because you
    can''t see the light source itself, only the light it emits, which you only see
    when it touches an object. If you want to recreate what I''ve shown in the example,
    you can add `THREE.PlaneGeometry` or `THREE.BoxGeometry` at the same position
    (`areaLight1.position`) to simulate the area emitting light, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create really beautiful effects with `THREE.AreaLight`, but you''ll
    probably have to experiment a bit to get the desired effect. If you pull down
    the control panel from the top-right corner, you''ve got some controls you can
    play around with to set the color and intensity of the three lights from this
    scene and immediately see the effect, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.AreaLight](img/2215OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: LensFlare
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last subject we'll explore in this chapter is **lens flares**. You are probably
    already familiar with lens flares. For instance, they appear when you take a photograph
    directly into the sun or another bright light source. In most cases, you want
    to avoid this, but for games and 3D-generated images, it provides a nice effect
    that makes scenes look a bit more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three.js also has support for lens flares and makes it very easy to add them
    to your scene. In this last section, we''re going to add a lens flare to a scene
    and create the output as you can see in the following screenshot; you can see
    this for yourself by opening `07-lensflares.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LensFlare](img/2215OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create a lens flare by instantiating the `THREE.LensFlare` object. The
    first thing we need to do is create this object. `THREE.LensFlare` takes the following
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These arguments are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `texture` | A texture is an image that determines the shape of the flare.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | We can specify how large the flare should be. This is the size in
    pixels. If you specify `-1`, the size of the texture itself is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `distance` | This is the distance from the light source (`0`) to the camera
    (`1`). Use this to position the lens flare in the right position. |'
  prefs: []
  type: TYPE_TB
- en: '| `blending` | We can specify multiple textures for the flares. The blending
    mode determines how these are blended together. The default to use with `LensFlare`
    is `THREE.AdditiveBlending`. There''s more on blending in the next chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color of the flare. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the code used to create this object (see `07-lensflares.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We first load a texture. For this example, I''ve used the lens flare texture
    provided by the Three.js examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LensFlare](img/2215OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you compare this image with the screenshot at the beginning of this section,
    you can see that it defines what the lens flare looks like. Next, we define the
    color of the lens flare using `new THREE.Color( 0xffaacc );`, which gives the
    lens flare a red glow. With these two objects, we can create the `THREE.LensFlare`
    object. For this example, we've set the size of the flare to `350` and the distance
    to `0.0` (directly at the light source).
  prefs: []
  type: TYPE_NORMAL
- en: 'After we''ve created the `LensFlare` object, we position it at the location
    of our light and add it to the scene, which can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LensFlare](img/2215OS_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It already looks nice, but if you compare this with the image from the beginning
    of this chapter you''ll notice that we''re missing the small round artifacts in
    the middle of the page. We create these in pretty much the same way as we did
    the main flare, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, though, we don''t create a new `THREE.LensFlare`, but use the `add`
    function provided by the `LensFlare` we just created. In this method, we need
    to specify the texture, size, distance, and blending mode, and that''s it. Note
    that the `add` function can take two additional parameters. You can also set the
    `color` and the `opacity` properties of the new flare to `add`. The texture we
    use for these new flares is a very light circle, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LensFlare](img/2215OS_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the scene again, you'll see the artifacts appearing at the positions
    you've specified with the `distance` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of information about the different kinds of
    lights that are available in Three.js. In this chapter, you learned that configuring
    lights, colors, and shadows is not an exact science. To get to the correct result,
    you should experiment with the different settings and use a dat.GUI control to
    fine-tune your configuration. The different lights behave in different manners.
    A `THREE.AmbientLight` color is added to each and every color in the scene and
    is often used to smooth hard colors and shadows. `THREE.PointLight` emits light
    in all directions but can't be used to create shadows. `THREE.SpotLight` is a
    light that resembles a flashlight. It has a conical shape, can be configured to
    fade over distance, and is able to cast shadows. We also looked at `THREE.DirectionalLight`.
    This light can be compared with a faraway light, such as the sun, whose light
    rays travel parallel to each other, the intensity of which doesn't decrease the
    farther away it gets from the configured target. Besides the standard lights,
    we also looked at a couple of more specialized lights. For a more natural outdoor
    effect, you can use `THREE.HemisphereLight`, which takes into account ground and
    sky reflections; `THREE.AreaLight` doesn't shine from a single point, but emits
    light from a large area. We showed you how to add a photographic lens flare with
    the `THREE.LenseFlare object`.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapters so far, we already introduced a couple of different materials,
    and in this chapter, you saw that not all materials respond in the same manner
    to the available lights. In the next chapter, we'll give an overview of the materials
    that are available in Three.js.
  prefs: []
  type: TYPE_NORMAL
