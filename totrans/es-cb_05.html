<html><head></head><body>
        

                            
                    <h1 class="header-title">Web Workers, Shared Memory, and Atomics</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Performing work on separate threads with Web Workers</li>
<li>Sending messages to and from Web Workers</li>
<li>Sending data to Web Workers</li>
<li>Stopping workers with terminate</li>
<li>Creating SharedArrayBuffer</li>
<li>Sending SharedArrayBuffer to a Web Worker</li>
<li>Reading SharedArray from multiple Web Workers</li>
<li>Using Atomics to coordinate use of shared memory</li>
<li>Using promises to provide a simple interface for a worker</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The capabilities and expectations of JavaScript and web applications are expanding every day. One of the most exciting areas this expansion has led to is parallel programming, which is related to, but not synonymous with, asynchronous and concurrent programming. Parallel programming allows for multiple operations to take place simultaneously rather than interleaving them.</p>
<p>This distinction may seem small, but it is quite significant. In this chapter, we will see how to use the facilities available on the web platform to create programs that execute in parallel. Web Workers will be used to create parallel jobs, <kbd>SharedMemoryBuffer</kbd> to share information, and the Atomic API to coordinate between them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enabling SharedArrayBuffers in Firefox</h1>
                
            
            
                
<p>In early 2018, the Spectre and Meltdown vulnerabilities were discovered. In response, browser manufacturers disabled <kbd>SharedArrayBuffer</kbd> by default. Some of the recipes in this chapter require this feature. This recipe demonstrates how to enable them in Firefox.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have an up to date version of Firefox installed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Firefox.</li>
<li>Navigate to <kbd>about:config</kbd>.</li>
<li>Click I accept the risk!</li>
<li>Search for shared.</li>
<li>Double-click javascript.options.shared_memory.</li>
<li>This option should now have the value true:</li>
</ol>
<p class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><img src="img/b8f71782-f2eb-4927-a140-519e6c163ff4.png" style="width:51.92em;height:32.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">By default, shared memory is disabled in Firefox, but the options let developers activate these (potentially insecure) features without exposing normal users to them. You can read more about Meltdown and Spectre at:<br/>
<a href="https://meltdownattack.com/">https://meltdownattack.com/</a>.</p>
<p class="mce-root">You should not leave this feature enabled after you finish experimenting with it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enabling SharedArrayBuffers in Chrome</h1>
                
            
            
                
<p>In early 2018, the Spectre and Meltdown vulnerabilities were discovered. In response, browser manufacturers disabled <kbd>SharedArrayBuffer</kbd> by default. Some of the recipes in this chapter require this feature. This recipe demonstrates how to enable them in Chrome.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have an up to date version of Chrome installed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Chrome.</li>
<li>Navigate to <kbd>chrome://flags/</kbd>.</li>
<li>Click I accept the risk!</li>
<li>Search for shared.</li>
<li>Select Enabled for the option Experimental enabled SharedArrayBuffer support in JavaScript.</li>
<li>Click RELAUNCH NOW:</li>
</ol>
<div><img src="img/c9d967a4-cd36-4049-ac03-e780b791fca2.png" style="width:55.08em;height:34.42em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">By default, shared memory is disabled in Firefox, but the options let developers activate these (potentially insecure) features without exposing normal users to them. You can read more about Meltdown and Spectre at:<br/>
<a href="https://meltdownattack.com/">https://meltdownattack.com/</a>.</p>
<p class="mce-root">You should not leave this feature enabled after you finish experimenting with it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing work on separate threads with Web Workers</h1>
                
            
            
                
<p>Web Workers allow browser operations to take place outside the main thread. Once created, communication between threads is made by passing messages. In this recipe, we'll see how to create a very simple worker, and send it a message from the main thread.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li> Create a new folder named <kbd>05-01-performing-work-with-web-workers</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file with a <kbd>main</kbd> function that creates a worker from a file named <kbd>worker.js</kbd>. Then post a message of type <kbd>hello-message</kbd> to the <kbd>worker</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() {  
  console.log('Hello, from main.'); 
  const worker = new Worker('./worker.js'); 
  worker.postMessage({ type: 'hello-message' }); 
}  </pre>
<ol start="5">
<li>Create a file named <kbd>worker.js</kbd> that logs a <kbd>Hello</kbd> message:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
console.log('Hello, from the worker.');  </pre>
<ol start="6">
<li>In the <kbd>worker.js</kbd> file, set the <kbd>onmessage</kbd> callback on the global scope. This function should log out the type of the message received:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
console.log('Hello, from the worker.'); 
 
<strong>this.onmessage = function (message) {<br/></strong><strong>    console.log('Message Recieved: (%s)', message.data.type);<br/></strong><strong>}</strong></pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output displayed:</li>
</ol>
<div><img src="img/3eef9de1-eb38-4516-8757-36b0d926476f.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Constructing the worker with the name of the worker file creates a worker on a new thread. By setting the <kbd>onmessage</kbd> event listener on the global context of the worker, we are able to receive messages from the main thread.</p>
<p>After creating the worker, the <kbd>main</kbd> function can use that reference to post messages to the new worker. The argument of the <kbd>postMessage</kbd> method is passed to the worker as the <kbd>data</kbd> attribute of the <kbd>message</kbd> property that is received.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending messages to and from Web Workers</h1>
                
            
            
                
<p>In the previous recipe, we saw how to create and send a message to a worker on a background thread. That's pretty great! Before Web Workers were introduced, it wasn't possible for JavaScript to work with anything but the main thread. However, it isn't very useful if we can't get any information back.</p>
<p>In this recipe, we'll see how to wait for, and send responses back from, a Web Worker.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-02-send-messages-to-and-from-web-workers</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> with a function named <kbd>onMessage</kbd> that takes an argument <kbd>message</kbd> and logs out the <kbd>type</kbd> and <kbd>index</kbd> properties:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
function onMessage(message) { 
  const { type, index } = message.data; 
  console.log('Main recieved a messge (%s) from index: (%s)',  
              type, index); 
}  </pre>
<ol start="5">
<li>Set a  <kbd>WORKER_COUNT</kbd> constant:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
const WORKER_COUNT = 5; </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates <kbd>WORKER_COUNT</kbd> workers, sets the <kbd>onMessage</kbd> property, and posts the <kbd>index</kbd> to the worker:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  for (let index = 0; index &lt; WORKER_COUNT; index++) { 
    const worker = new Worker('./worker.js'); 
 
    worker.onmessage = onMessage; 
    worker.postMessage({ type: 'ping', index }); 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>worker.js</kbd> file that assigns the current context as a <kbd>global</kbd> constant:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this;  </pre>
<ol start="8">
<li>Set the <kbd>onmessage</kbd> event listener on <kbd>global</kbd> to the global context. The function should take a message argument and log out the <kbd>index</kbd> and <kbd>type</kbd> properties. Then it should call <kbd>global.postMessage</kbd> with another message, passing back its <kbd>index</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
global.onmessage = (message) =&gt; { 
  const { type, index } = message.data; 
  console.log('Worker (%s) recieved a messge (%s)', index, type); 
 
  global.postMessage({ index, type: 'pong' }) 
  global.postMessage({ index, type: 'another-type' }) 
}; </pre>
<ol start="9">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output displayed:</li>
</ol>
<div><img src="img/c1fadc84-d802-4c07-99bc-d3a61c8aa365.png" style="width:49.33em;height:36.92em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We've seen how the <kbd>onmessage</kbd> listener can be used to listen for messages posted from the main thread. Now we can see that the same evenlistener, when binding on the worker reference in the <kbd>main</kbd> function, can listen to messages from the worker. We also can see that this listener is isolated from the individual worker being referenced. Each worker has a unique event listener; this is useful for organizing communication between workers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending data to a Web Worker</h1>
                
            
            
                
<p>Now that we've seen how to send messages back and forth, we can start to actually put these Web Workers to work. In this recipe, we'll see that you can send data to and from a Web Worker.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-03-send-data-to-and-from-web-workers</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> with a function named <kbd>onMessage</kbd> that takes an argument <kbd>message</kbd> and logs out the <kbd>type</kbd> and <kbd>index</kbd> properties:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
function onMessage(message) { 
  const { result, type } = message.data; 
  console.log('Result for operation (%s): (%s)', type, result); 
}  </pre>
<ol start="5">
<li>Create a <kbd>main</kbd> function that creates a worker, sets the <kbd>onMessage</kbd> property, creates an array of random numbers, and posts two messages to the worker, one to sum some of the numbers and another to average them:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  const worker = new Worker('./worker.js'); 
  worker.onmessage = onMessage; 
 
  const numbers = (new Array(100)).fill().map(Math.random) 
  worker.postMessage({ type: 'average', numbers}); 
}  </pre>
<ol start="6">
<li>Create a <kbd>worker.js</kbd> file that assigns the current context as a <kbd>global</kbd> constant:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this; </pre>
<ol start="7">
<li>Set the <kbd>onmessage</kbd> event listener on <kbd>global</kbd> to the context. The function should take a message argument and perform either a sum or average operation on the numbers property of <kbd>message.data</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
global.onmessage = (message) =&gt; { 
  const { type, numbers } = message.data; 
 
  switch (type) { 
    case 'sum': 
      const sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0); 
      global.postMessage({ result: sum, type }) 
      break; 
      case 'average': 
      const average = numbers.reduce((acc, curr) =&gt; acc + curr, <br/>       0) /numbers.length; 
      global.postMessage({ result: average, type }) 
      break; 
  } 
};  </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div><img src="img/d0174fd0-836d-47be-bc70-c9838d951be4.png" style="width:42.17em;height:18.42em;"/>x</div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We've seen a simple string posted to and from workers. Now we can see that more complex objects can be sent as well. In fact, a sizable number of types can be passed via <kbd>postMessage</kbd>.</p>
<p>To see a full list of valid types, visit the link:<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm</a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">.</a></p>
<p>By using <kbd>postMessage</kbd>, we have copied the data to the worker. This operation is costly, because whenever the message is posted to a new thread, the data must be duplicated in order to be available. For small datasets, this isn't a problem, but for larger sets it can be slow and memory-intensive. For future recipes in this chapter, we'll be using shared memory to avoid this copying.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stopping workers with terminate</h1>
                
            
            
                
<p>Not all problems are cumulative. Some have a desired goal state; once it is found, then the program can exit. We've seen that workers communicate their results by posting messages. Now our program is completed, it would be nice to prevent future messages from being received, possibly polluting our results.</p>
<p>In this recipe, we'll see how to use <kbd>Worker.terminate</kbd> to immediately stop a <kbd>Worker</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-04-stop-workers-with-terminate</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> with a function named <kbd>onMessage</kbd> that takes a <kbd>message</kbd> and <kbd>workers</kbd> argument<strong>,</strong> logs out the <kbd>type</kbd> and <kbd>timeout</kbd> properties of <kbd>message.data</kbd>, and calls <kbd>terminate</kbd> on all the <kbd>workers</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
function onComplete(message, workers) { 
  const { index, timeout } = message.data; 
  workers.map((w) =&gt; w.terminate()); 
 
  console.log( 
    'Result from worker (%s) after timeout (%s): %s', 
    index, 
    timeout 
  ); 
}  </pre>
<ol start="5">
<li>Create a <kbd>main</kbd> function that creates multiple workers, sets the <kbd>onMessage</kbd> property with a function that passes all the <kbd>workers</kbd> as the second argument, then posts a message to each with the <kbd>index</kbd>:</li>
</ol>
<pre style="padding-left: 90px">  export function main() { 
  const totalWorkers = 10; 
  const workers = []; 
 
  for (let i = 0; i &lt; totalWorkers; i++) { 
    const worker = new Worker('./worker.js'); 
    worker.onmessage = (msg) =&gt; onComplete(msg, workers); 
    workers.push(worker); 
  } 
 
  workers.map((worker, index) =&gt; { 
    workers[index].postMessage({ index }); 
  }); 
}  </pre>
<ol start="6">
<li>Create a <kbd>worker.js</kbd> file that assigns the current context as a <kbd>global</kbd> constant:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this;  </pre>
<ol start="7">
<li>Set a <kbd>timeout</kbd> constant to some random number between <em>0</em> and <em>10,000</em>:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const timeout = Math.floor(Math.random() * 10000); </pre>
<ol start="8">
<li>Set the <kbd>onmessage</kbd> event listener on <kbd>global</kbd> to the context. The function should take a <kbd>message</kbd> argument and post a response message with the <kbd>index</kbd> and <kbd>timeout</kbd> of this worker, after the given timeout:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
global.onmessage = (message) =&gt; { 
  const data = JSON.parse(message.data); 
  const data = { 
    index: data.index, 
    timeout: timeout 
  }; 
 
  setTimeout(() =&gt; global.postMessage(data), timeout) 
};   </pre>
<ol start="9">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output displayed:</li>
</ol>
<div><img src="img/d0a30777-8e34-498f-813f-e64cf0daaf5f.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>All 10 workers are instructed to post a message after their given timeout but, as you can see, only a single worker actually posts a message back to the main thread. This is because, after this first worker posts, we call <kbd>terminate</kbd> on all of the workers. This means that they will stop immediately, and unless another worker has already posted, it never will. So, we will almost always see a single message posted. It is possible that one or two other workers will post before being terminated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating SharedArrayBuffer</h1>
                
            
            
                
<p>So far, we've see how to send data between the main thread and workers. The downside of how we've done this so far is that the data is copied. This means that as the amount of data and number of workers increase, so does the amount of copying that has to be done. Luckily, there is a way to share data between threads with less overhead.</p>
<p><kbd>SharedArrayBuffer</kbd> can be shared between arrays without copying data. In this recipe, we'll see how to create, as well as read and write, data from a <kbd>SharedArrayBuffer</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application, and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-05-creating-shared-array-buffer</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file with a main method that defines constants for <kbd>NUM_COUNT</kbd>, <kbd>BYTES_FOR_32_BIT</kbd>, <kbd>ARRAY_SIZE</kbd>, and <kbd>MAX_NUMBER</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  const NUM_COUNT = 2048; 
  const BYTES_FOR_32_BIT = 4; 
  const ARRAY_SIZE = NUM_COUNT * BYTES_FOR_32_BIT; 
  const MAX_NUMBER = 1024; 
} </pre>
<ol start="5">
<li>Next, create a <kbd>SharedArrayBuffer</kbd> that is of size <kbd>ARRAY_SIZE</kbd>, and create an <kbd>Int32Array</kbd> casting of it:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  const sab = new SharedArrayBuffer(ARRAY_SIZE);</strong><br/><strong>  const intBuffer = new Int32Array(sab);</strong>
}  </pre>
<ol start="6">
<li>Fill the <kbd>intBuffer</kbd> with random numbers between <em>0</em> and <kbd>MAX_NUMBER</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  // fill with random numbers  // fill with random numbers<br/>  intBuffer.forEach((value, index) =&gt; {<br/>    intBuffer[index] = Math.random() * MAX_NUMBER;<br/>  })</strong><strong>;<br/></strong>} </pre>
<ol start="7">
<li>Calculate and print the sum of the values in the array:</li>
</ol>
<pre style="padding-left: 90px"> export function main() { 
  // ... 
<strong>  // sum the ints<br/>  const sum = intBuffer.reduce((acc, number) =&gt;<br/>    acc + number<br/>  , 0);</strong>
} </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="9">
<li>You should see the following output:</li>
</ol>
<div><img src="img/412ee83c-da6d-4432-89ba-faa8b60dd894.png" style="width:46.33em;height:20.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>It feels a little unnatural to be thinking about byte size when working in JavaScript, but it's necessary for working with <kbd>SharedArrayBuffer</kbd>. The preceding example creates an array of 2,048 32-bit integers. So in order to create a <kbd>SharedArray</kbd> buffer we have to calculate how much memory 2,048 32-bit integers will take up. This is done with simple multiplication. Once we have <kbd>ARRAY_SIZE</kbd> we can allocate the memory.</p>
<p>Now that we have the array, we need to cast it as some type in order to read and write from it. We're using <kbd>Int32Array</kbd>, so when we perform array access operations the values will be cast as 32-bit integers.</p>
<p>When filling the array, we simply loop over each number and multiply a random number by the <kbd>MAX_NUMBER</kbd>; the resulting value is cast as a 32-bit integer (the decimal value is lost). Next, summing is done with the array's <kbd>reduce</kbd> function, and we log out the results.</p>
<p>A nice feature of the <kbd>Int32Array</kbd> is that it has all of the Array methods as well. So we can perform map, join, index, includes, and so on with the new data type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending SharedArrayBuffer to a Web Worker</h1>
                
            
            
                
<p>Now that we know how to create and use a <kbd>SharedArrayBuffer</kbd>, we can use one to share data between the main thread and workers. As mentioned previously, this has an advantage over posting JavaScript objects, in that the data doesn't need to be copied; it is shared.</p>
<p>In this recipe, we'll see how to share a <kbd>SharedArrayBuffer</kbd> with a worker, and post the result back to the main thread.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters. It also assumes that you have enabled shared memory in your browser. If you haven't please see the recipes at the beginning of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application, and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-06-sending-shared-array-to-worker</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file with an <kbd>onMessage</kbd> function that logs out the <kbd>result</kbd> and <kbd>type</kbd> members of the received message data:</li>
</ol>
<pre style="padding-left: 90px">function onMessage(message) { 
  const { result, type } = message.data; 
  console.log('result from worker operation: %s', type, result); 
} </pre>
<ol start="5">
<li>Create a <kbd>main.js</kbd> file with a main method that defines constants for <kbd>NUM_COUNT</kbd>, <kbd>BYTES_FOR_32_BIT</kbd>, <kbd>ARRAY_SIZE</kbd>, and <kbd>MAX_NUMBER</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  const NUM_COUNT = 2048; 
  const BYTES_FOR_32_BIT = 4; 
  const ARRAY_SIZE = NUM_COUNT * BYTES_FOR_32_BIT; 
  const MAX_NUMBER = 1024; 
} </pre>
<ol start="6">
<li>Next, create a <kbd>SharedArrayBuffer</kbd> that is of size <kbd>ARRAY_SIZE</kbd>, and create a worker with the source in <kbd>worker.js</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  const sab = new SharedArrayBuffer(ARRAY_SIZE);<br/></strong><strong>  const worker = new Worker('./worker.js');</strong> 
} </pre>
<ol start="7">
<li>Set the worker on the message event listener to the <kbd>onMessage</kbd> function, and post a message to the worker with the array buffer:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  worker.onmessage = onMessage;<br/></strong><strong>  worker.postMessage({ type: 'load-array', array: sab });;</strong> 
} </pre>
<ol start="8">
<li>Fill the array buffer with 32-bit integers with random values between <em>0</em> and <kbd>MAX_NUMBER</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  const intBuffer = new Int32Array(sab);<br/></strong><strong>  // fill with random numbers<br/></strong><strong>  intBuffer.forEach((value, index) =&gt; {<br/></strong><strong>    intBuffer[index] = Math.random() * MAX_NUMBER;<br/></strong><strong>  });</strong> 
} </pre>
<ol start="9">
<li>Post messages to the worker, requesting calculations of <kbd>sum</kbd> and <kbd>average</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  worker.postMessage({ type: 'calculate-sum' });<br/></strong><strong>  worker.postMessage({ type: 'calculate-average'});</strong> 
} </pre>
<ol start="10">
<li>Create a <kbd>worker.js</kbd> file, assign the current context to a variable <kbd>global</kbd>, declare a variable named <kbd>sharedIntArray</kbd>, and assign a function to the <kbd>onmessage</kbd> event:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this; 
let sharedIntArray; 
 
global.onmessage = (message) =&gt; {};  </pre>
<ol start="11">
<li>In the <kbd>onmessage</kbd> listener get the data component of the <kbd>message</kbd> argument, and <kbd>switch</kbd> on the <kbd>type</kbd> attribute:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
<strong>  const { data } = message;<br/></strong><strong>  switch (data.type) {}</strong> 
};  </pre>
<ol start="12">
<li>Add a case for <kbd>'load-array'</kbd>, where we assign the array property of data to <kbd>sharedIntArray</kbd> after casting it as an <kbd>Int32Array</kbd>:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
<strong>    case 'load-array':<br/></strong><strong>      sharedIntArray = new Int32Array(data.array);<br/></strong><strong>      break;</strong> 
    } 
  }; </pre>
<ol start="13">
<li>Add a case for <kbd>'calculate-sum'</kbd> that sums all the numbers in the array and posts the result back to the main thread:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
    case 'load-array': 
      sharedIntArray = new Int32Array(data.array); 
      break; 
<strong>   case 'calculate-sum':<br/></strong><strong>      const sum = sharedIntArray.reduce((acc, number) =&gt; acc +<br/>      number, <br/>      0);<br/></strong><strong>      global.postMessage({ type: 'sum', result: sum });<br/></strong><strong>      break;    </strong> 
    } 
  };  </pre>
<ol start="14">
<li>Add a case for <kbd>'calculate-average'</kbd> that averages all the numbers in the array and posts the result back to the main thread:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
    case 'load-array': 
      sharedIntArray = new Int32Array(data.array); 
      break; 
    case 'calculate-sum': 
      const sum = sharedIntArray.reduce((acc, number) =&gt;  
        acc + number, 
      0); 
      global.postMessage({ type: 'sum', result: sum }); 
      break;     
 
<strong>    case 'calculate-average':<br/></strong><strong>      const total = sharedIntArray.reduce((acc, number) =&gt;<br/></strong><strong>        acc + number<br/></strong><strong>      , 0);<br/></strong><strong>      const average = total / sharedIntArray.length;<br/></strong><strong>      global.postMessage({ type: 'average', result: average });<br/></strong><strong>      break;    </strong> 
    } 
  }; </pre>
<ol start="15">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="16">
<li>You should see the following output:</li>
</ol>
<div><img src="img/9e09739c-db02-4442-af58-8437c5b2b86c.png" style="width:53.33em;height:23.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As mentioned previously, <kbd>SharedArrayBuffer</kbd> is not copied between threads. It is shared. So, when we create the shared array buffer and pass that reference to a worker, the values inserted into the array by the main thread are available in the worker.</p>
<p>After the worker receives messages to perform calculations, the values can be accumulated as they were in any other array, and the value sent back is a simple message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading SharedArray from multiple Web Workers</h1>
                
            
            
                
<p>In the previous recipe, we saw how data can be shared between the main thread and a single worker. This is helpful for move long-running operations on the main thread, which helps keep the UI responsive. However, it isn't taking full advantage of parallel processing. With very large datasets, breaking up the computation between many workers can be advantageous.</p>
<p>In this recipe, we'll see how to use multiple workers to produce portions of a result.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-07-reading-shared-buffer-from-multiple-workers</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file with an <kbd>onMessage</kbd> function that logs out the following members of the message data: <kbd>workenIndex</kbd>, <kbd>type</kbd>, <kbd>result</kbd>, <kbd>workerIndex</kbd>, <kbd>startIndex</kbd>, <kbd>endIndex</kbd>, and <kbd>windowSize</kbd>:<strong><strong><br/></strong></strong></li>
</ol>
<pre style="padding-left: 90px">// main.js<br/>function onMessage(message) {<br/>const { <br/>    type, <br/>    result, <br/>    workerIndex, <br/>    startIndex, <br/>    endIndex, <br/>    windowSize <br/>  } = message.data; <br/>  console.log(`Result from worker operation { <br/>    type: ${type}, <br/>    result: ${result}, <br/>    workerIndex: ${workerIndex}, <br/>    startIndex: ${startIndex}, <br/>    endIndex: ${endIndex}, <br/>    windowSize: ${windowSize} <br/>  }`); <br/>} </pre>
<ol start="5">
<li class="mce-root">Create a <kbd>main.js</kbd> file with a main method that defines constants for <kbd>NUM_COUNT</kbd>, <kbd>BYTES_FOR_32_BIT</kbd>, <kbd>ARRAY_SIZE</kbd>, <kbd>WORKER_COUNT</kbd>, and <kbd>MAX_NUMBER</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  console.log('Main function starting.'); 
  const NUM_COUNT = 2048; 
  const BYTES_FOR_32_BIT = 4; 
  const ARRAY_SIZE = NUM_COUNT * BYTES_FOR_32_BIT; 
  const MAX_NUMBER = 32; 
  const WORKER_COUNT = 10; 
  } </pre>
<ol start="6">
<li>Next, create an array of workers of size <kbd>WORKER_COUNT</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  // create workers<br/></strong><strong>  let workers = [];<br/></strong><strong>  console.log('Creating workers.');<br/></strong><strong>  for (let i = 0; i &lt; WORKER_COUNT; i++) {<br/></strong><strong>    const worker = new Worker('./worker.js');<br/></strong><strong>    worker.onmessage = onMessage;<br/></strong><strong>    workers = workers.concat(worker);<br/></strong><strong>  }</strong> 
} </pre>
<ol start="7">
<li>Next, create a <kbd>SharedArrayBuffer</kbd> that is of size <kbd>ARRAY_SIZE</kbd>, and fill it with random integers:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  // create buffer and add data<br/></strong><strong>  const sab = new SharedArrayBuffer(ARRAY_SIZE);<br/></strong><strong>  const intBuffer = new Int32Array(sab);<br/></strong><strong>  // fill with random numbers<br/></strong><strong>  console.log('Filling Int buffer');<br/></strong><strong>  intBuffer.forEach((value, index) =&gt; {<br/></strong><strong>    intBuffer[index] = (Math.random() * MAX_NUMBER) + 1;<br/></strong><strong>  });</strong> 
} </pre>
<ol start="8">
<li>Post these messages to each of the workers: <kbd>'load-array'</kbd>, <kbd>'load-indices'</kbd>, <kbd>'calculate-sum'</kbd>, and <kbd>'calculate-average'</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  workers.forEach((worker, workerIndex) =&gt; {<br/></strong><strong>    worker.postMessage({ type: 'load-array', array: sab });<br/></strong><strong>    worker.postMessage({ type: 'load-indices', workerIndex,<br/>    workerCount: WORKER_COUNT });<br/></strong><strong>    worker.postMessage({ type: 'calculate-sum' });<br/></strong><strong>    worker.postMessage({ type: 'calculate-average' });<br/></strong><strong>  });;</strong> 
} </pre>
<ol start="9">
<li>Create a <kbd>worker.js</kbd> file, assign the current context to a variable <kbd>global</kbd>, and declare variables named: <kbd>sharedIntArray</kbd>, <kbd>sharedInArraySlice</kbd>, <kbd>workerIndex</kbd>, <kbd>workerCount</kbd>, <kbd>startIndex</kbd>, and <kbd>endIndex</kbd>. Also, assign a function to the <kbd>onmessage</kbd> event:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this; 
let sharedIntArray; 
let sharedIntArraylSlice; 
let workerIndex; 
let workerCount; 
let startIndex; 
let endIndex; 
 
global.onmessage = (message) =&gt; {};  </pre>
<ol start="10">
<li>In the <kbd>onmessage</kbd> listener, get the data component of the <kbd>message</kbd> argument and switch on the <kbd>type</kbd> attribute:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
<strong>  const { data } = message;<br/></strong><strong>  switch (data.type) {}<br/></strong>};  </pre>
<ol start="11">
<li>Add a case for <kbd>'load-array'</kbd> where we assign the array property of data to <kbd>sharedIntArray</kbd> after casting it as an <kbd>Int32Array</kbd>:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
<strong>    case 'load-array':<br/></strong><strong>      sharedIntArray = new Int32Array(data.array);<br/></strong><strong>      break;</strong> 
    } 
  };  </pre>
<ol start="12">
<li>Add a case for <kbd>'load-indices'</kbd> that calculates the window of values that the current worker should work with, based on the current index and total number of workers:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
    case 'load-array': 
      sharedIntArray = new Int32Array(data.array); 
      break; 
<strong>    case 'load-indices':</strong><br/><strong>      workerIndex = data.workerIndex;</strong><br/><strong>      workerCount = data.workerCount;</strong><br/><br/><strong>      const windowSize = Math.floor(sharedIntArray.length /<br/>      workerCount)</strong><br/><strong>      startIndex = windowSize * workerIndex;</strong><br/><strong>      const isLastWorker = workerIndex === workerCount - 1;</strong><br/><strong>      endIndex = (isLastWorker) ? sharedIntArray.length : <br/>      startIndex+windowSize;</strong><br/><strong>      sharedIntArraySlice = sharedIntArray.slice(startIndex,<br/>      endIndex);</strong><br/><strong>      break;</strong><br/>  }; </pre>
<ol start="13">
<li>Add a case for <kbd>'calculate-sum'</kbd> that sums all the numbers in the array and posts the result back to the main thread:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
   // ... 
<strong><br/>    case 'calculate-sum':<br/>      const sum = sharedIntArraySlice.reduce((acc, number) =&gt;<br/>        acc + number<br/>      , 0);<br/>      sendResult('sum', sum);<br/>      break;   </strong> 
    } 
  };  </pre>
<ol start="14">
<li>Add a case for <kbd>'calculate-average'</kbd> that averages all the numbers in the array and posts the result back to the main thread:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
    //...     <strong>    </strong><strong><br/>    case 'calculate-average':<br/>      const total = sharedIntArraySlice.reduce((acc, number) =&gt;<br/>        acc + number<br/>      , 0);<br/>      const average = total / sharedIntArraySlice.length<br/>      sendResult('average', average);<br/>      break;    </strong> 
    } 
  };  </pre>
<ol start="15">
<li>Create a <kbd>sendResult</kbd> function that posts a <kbd>result</kbd>, a result type, and information about the current thread to the main thread:</li>
</ol>
<pre style="padding-left: 90px">function sendResult(type, result) { 
  global.postMessage({ 
    type, 
    result, 
    workerIndex, 
    startIndex, 
    endIndex, 
    windowSize: endIndex - startIndex - 1 
  }); 
} </pre>
<ol start="16">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="17">
<li>You should see the following output:</li>
</ol>
<div><img src="img/d5dc6810-c15a-4488-b3d3-d1421b9f2838.png" style="width:52.83em;height:40.42em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Shared array buffers can be shared across any number of worker threads. In order to calculate portions of the result, we need to divide the results equitably between the threads. That's what the <kbd>'load-indices'</kbd> case of the worker <kbd>onMessage</kbd> listener does.</p>
<p>We can use the size of the array and the total worker count to get the window size. We take the floor so that we don't go beyond the index of the array. This is also because you can't have a partial index: they are integers.</p>
<p>Next, we use the current worker index to get the <kbd>startIndex</kbd> (basically picking up where the previous worker left off). To get the end index, we need to know if this is the last worker. If not, we use the window size. If it is, we need to take all of the remaining values.</p>
<p>Once we have our array slice, each worker calculates the sums and averages of those portions as they would with the entire array. Then the results and the worker info are posted to the main thread.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Atomics to coordinate the use of shared memory</h1>
                
            
            
                
<p>In the previous recipe, we used multiple workers to produce portions of a result. We could merge these results in the main thread. While valid, this approach doesn't take full advantage of parallel processing. It would be preferable if the workers could accumulate the results themselves.</p>
<p>Mutating shared memory in multiple parallel threads exposes the possibility of race conditions. This is when several operations need to occur in a specific order that is not enforced. Luckily, we can use the Atomics API to coordinate these operations.</p>
<p>In this recipe, we'll see how to use the Atomics API to accumulate results while avoiding race conditions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-08-use-atomics-to-coordinate</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file. Create three shared array buffers: an input buffer and two output buffers (one <kbd>safe</kbd>, the other <kbd>unsafe</kbd>). The output buffers should be 32 bits in size:</li>
</ol>
<pre style="padding-left: 90px">// main.js<br/>const NUMBER_COUNT = Math.pow(2, 10); <br/>const BYTES_FOR_32_BIT = 4;<br/>const ARRAY_SIZE = NUMBER_COUNT * BYTES_FOR_32_BIT; <br/>const sab = new SharedArrayBuffer(ARRAY_SIZE); 
const intBuffer = new Int32Array(sab); 
const outSab = new SharedArrayBuffer(BYTES_FOR_32_BIT); 
const unsafeSab = new SharedArrayBuffer(BYTES_FOR_32_BIT); 
const workerCount = 256; </pre>
<ol start="5">
<li>Declare a variable <kbd>workersFinishedCount</kbd> and set it to <kbd>0</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js<br/>let workersFinishedCount = 0; </pre>
<ol start="6">
<li>Create a function named <kbd>onMessage</kbd>. This function increments <kbd>workersFinished</kbd>. If all the workers are finished, log the output of the two output arrays and log out a sum calculated locally:</li>
</ol>
<pre style="padding-left: 90px">//main.js<br/>function onMessage(message) { <br/>  workersFinishedCount++;  
  if (workersFinishedCount === WORKER_COUNT) { 
    const outIntBuffer = new Int32Array(outSab); 
    const unsafeIntBuffer = new Int32Array(unsafeSab); 
    console.log('Unsafe Sum: %s', unsafeIntBuffer[0]); 
    console.log('Merged sum: %s', outIntBuffer[0]); 
    const localSum = intBuffer.reduce((acc, curr) =&gt; acc + curr, <br/>    0); 
    console.log('Local sum: %s', localSum); 
  } 
} </pre>
<ol start="7">
<li>Create a main function that declares a <kbd>MAX_NUMBER</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  const MAX_NUMBER = 32; 
} </pre>
<ol start="8">
<li>Next, create an array of workers of size <kbd>WORKER_COUNT</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  // create workers<br/>&lt;/strong&gt;</strong>  let workers = [];<br/><strong>  console.log('Creating workers.');<br/></strong><strong>  for (let i = 0; i &lt; WORKER_COUNT; i++) {<br/></strong><strong>    const worker = new Worker('./worker.js');<br/></strong><strong>    worker.onmessage = onMessage;<br/></strong><strong>    workers = workers.concat(worker);<br/></strong><strong>  }</strong> 
} </pre>
<ol start="9">
<li>Next, fill the input shared array buffer with random integers:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  // fill with random numbers<br/></strong><strong>  console.log('Filling Int buffer');<br/></strong><strong>  intBuffer.forEach((value, index) =&gt; {<br/></strong><strong>    intBuffer[index] = (Math.random() * MAX_NUMBER) + 1;<br/></strong><strong>  });</strong> 
} </pre>
<ol start="10">
<li>Post these messages to each of the workers: <kbd>'load-shared-input'</kbd>, <kbd>'load-shared-output'</kbd>, <kbd>'load-indices'</kbd>, and <kbd>'calculate-sum'</kbd>:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  workers.forEach((worker, workerIndex) =&gt; {<br/></strong><strong>    worker.postMessage({ type: 'load-shared-input', input: sab <br/>    });<br/></strong><strong>    worker.postMessage({ type: 'load-shared-output', safe: <br/>    outSab,<br/>    unsafe: unsafeSab });<br/></strong><strong>    worker.postMessage({ type: 'load-indices', workerIndex, <br/>    workerCount: WORKER_COUNT });<br/></strong><strong>    worker.postMessage({ type: 'calculate-sum' });<br/></strong><strong>  });</strong> 
} </pre>
<ol start="11">
<li>Create a <kbd>worker.js</kbd> file, assign the current context to a <kbd>global</kbd> variable, declare variables named <kbd>sharedIntArray</kbd>, <kbd>resultArray</kbd>, <kbd>unsafeResultArray</kbd>, and <kbd>sharedInArraySlice</kbd>, and assign a function to the <kbd>onmessage</kbd> event:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this; 
let sharedIntArray; 
let resultArray; 
let unsafeResultArray; 
let sharedIntArraylSlice; 
 
global.onmessage = (message) =&gt; {};  </pre>
<ol start="12">
<li>In the <kbd>onmessage</kbd> listener, get the data component of the <kbd>message</kbd> argument and <kbd>switch</kbd> on the <kbd>type</kbd> attribute:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
<strong>  const { data } = message;<br/></strong><strong>  switch (data.type) {}</strong> 
};  </pre>
<ol start="13">
<li>Add a case for <kbd>'load-shared-input'</kbd>, where we assign the <kbd>input</kbd> property of data to <kbd>sharedIntArray</kbd> after casting it as an <kbd>Int32Array</kbd>:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
<strong>    case 'load-shared-input':<br/></strong><strong>      sharedIntArray = new Int32Array(data.input);<br/></strong><strong>      break;</strong> 
  } 
};  </pre>
<ol start="14">
<li>Add a case for <kbd>'load-shared-output'</kbd>, where we assign the <kbd>safe</kbd> and <kbd>unsafe</kbd> properties of data to the corresponding result arrays after casting them as a <kbd>Int32Array</kbd>:</li>
</ol>
<pre style="padding-left: 90px"> global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
<strong>    case 'load-shared-output':<br/></strong><strong>      resultArray = new Int32Array(data.safe);<br/></strong><strong>      unsafeResultArray = new Int32Array(data.unsafe);<br/></strong><strong>      break;</strong> 
    } 
  }; </pre>
<ol start="15">
<li>Add a case for <kbd>'load-indices'</kbd> that calculates the window of values that the current worker should work with based on the current index and total number of workers:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
    case 'load-array': 
      sharedIntArray = new Int32Array(data.array); 
      break; 
<strong>    case 'load-indices':<br/></strong><strong>      const { workerIndex, workerCount } = data;<br/></strong><strong>      const windowSize = Math.floor(sharedIntArray.length / <br/>      workerCount);<br/></strong><strong>      const startIndex = windowSize * workerIndex;<br/></strong><strong>      const lastWorker = workerIndex === workerCount - 1;<br/></strong><strong>      const endIndex = (lastWorker) ? sharedIntArray.length :<br/>      startIndex + windowSize;<br/></strong><strong>      sharedIntArraySlice = sharedIntArray.slice(startIndex,<br/>      endIndex);<br/></strong><strong>      break;<br/>    </strong><strong>}</strong> 
  }; </pre>
<ol start="16">
<li>Add a case for <kbd>'calculate-sum'</kbd> that sums all the numbers in the array, updates <kbd>unsafeResultArray</kbd> directly, uses <kbd>Atomics.add</kbd> to update <kbd>resultArray</kbd>, and posts the result back to the main thread:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
   // ... 
<strong>   case 'calculate-sum':<br/></strong><strong>      const sum = sharedIntArraySlice.reduce((acc, number) =&gt;<br/></strong><strong>        acc + number<br/></strong><strong>      , 0);<br/></strong><strong>      sendResult('sum', sum);<br/></strong><strong>      break;    </strong> 
    } 
  }; </pre>
<ol start="17">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="18">
<li>You should see the following output:</li>
</ol>
<div><img src="img/6403a2c9-a347-4da1-aaf1-975c8c46aa50.png" style="width:43.75em;height:22.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As we can see from the results, the value of <kbd>unsafeResultArray</kbd> has been corrupted by a race condition. It looks as if some of the values are missing. However, looking at the worker it appears as if we are adding the result as a single operation.</p>
<p>This isn't precisely true. The <kbd><em>+</em><em>=</em></kbd> operator is actually three separate operations, a read, an addition, and a write operation. If you imagine that multiple workers reach this segment at the same time (we have 256 operating at once), then you can imagine how a race condition can occur.</p>
<p>Atomics prevent these errors from happening. <kbd>Atomic.add</kbd>, for example, operates as if <em>+</em>, <em>=</em> were a single operation. When a worker uses <kbd>Atomics.add</kbd> or any other method in the API, they can be sure that the values will not be written or read by another thread until the operation has been completed. That's why the safe sum always matches the sum calculated on the main thread, and the unsafe sum may be less.</p>
<p>Because race conditions are non-deterministic, you may have to run this recipe several times in order to see a discrepancy between the safe and unsafe sums.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using promises to provide a simple interface for a worker</h1>
                
            
            
                
<p>So far, we've see how to use workers to perform a variety of tasks, but we've also seen that they can be cumbersome to use. This is unavoidable to some extent. However, we can provide nice interfaces to operations that are using workers with the tools we've already seen in in previous chapters.</p>
<p>In this recipe, we'll see how to use promises to create more familiar interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application, and navigate to your workspace.</li>
<li>Create a new folder named <kbd>05-09-using-promise-for-simple-interfaces</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file, with an <kbd>async</kbd> function named <kbd>sumOnWorker</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js<br/>async function sumOnWorker(array) {}</pre>
<ol start="5">
<li>Inside <kbd>sumOnWorker</kbd>, return a new promise, wherein you create a new worker and bind the <kbd>onmessage</kbd> event listener, and post a message to the worker to calculate the sum:</li>
</ol>
<pre style="padding-left: 90px">// main.jsfunction sumOnWorker(array) { <br/>  return new Promise(function (resolve) { <br/>    const worker = new Worker('./worker.js'); <br/><strong>    worker.onmessage = (message) =&gt; {};<br/></strong><strong>    worker.postMessage({ type: 'calculate-sum', array });</strong> <br/>  }); <br/>} </pre>
<ol start="6">
<li>Inside the <kbd>onmessage</kbd> listener, log out the <kbd>type</kbd> and <kbd>result</kbd> properties of the message data, and resolve the <kbd>result</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js<br/>async function sumOnWorker(array) { 
  return new Promise(function (resolve) { 
    const worker = new Worker('./worker.js'); 
    worker.onmessage = (message) =&gt; { 
<strong>      const { type, result } = message.data;<br/></strong><strong>      console.log('Completed operation (%s), result: %s',<br/></strong><strong>        type,<br/></strong><strong>        result<br/></strong><strong>      );<br/></strong><strong>      return resolve(result);</strong> 
    }; 
 
    worker.postMessage({ type: 'calculate-sum', array }); 
  }); 
} </pre>
<ol start="7">
<li>Create an <kbd>async</kbd> main function that creates three arrays of random numbers:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  const array0 = (new Array(10000)).fill().map(Math.random); 
  const array1 = (new Array(1000)).fill().map(Math.random); 
  const array2 = (new Array(100)).fill().map(Math.random); 
} </pre>
<ol start="8">
<li>Call <kbd>sumOnWorker</kbd> with each of the arrays, and log out the results:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  // ... 
<strong>  sumOnWorker(array0).then((sum) =&gt; console.log('Array 0 sum: <br/>  %s', sum));<br/></strong><strong>  sumOnWorker(array1).then((sum) =&gt; console.log('Array 1 sum: <br/>  %s', sum));<br/></strong><strong>  sumOnWorker(array2).then((sum) =&gt; console.log('Array 2 sum: <br/>  %s', sum));;</strong> 
} </pre>
<ol start="9">
<li>Create a <kbd>worker.js</kbd> file, assign the current context to a variable <kbd>global</kbd>, and assign a function to the <kbd>onmessage</kbd> event:</li>
</ol>
<pre style="padding-left: 90px">// worker.js 
const global = this;  
global.onmessage = (message) =&gt; {};  </pre>
<ol start="10">
<li>In the <kbd>onmessage</kbd> listener, get the data component of the <kbd>message</kbd> argument and <kbd>switch</kbd> on the <kbd>type</kbd> attribute:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
<strong>  const { data } = message;<br/></strong><strong>  switch (data.type) {}</strong> 
};  </pre>
<ol start="11">
<li>Add a case for <kbd>'calculate-sum'</kbd>, where you calculate the sum of a posted array. Respond with the type or operation, and the resulting value:</li>
</ol>
<pre style="padding-left: 90px">global.onmessage = (message) =&gt; { 
  const { data } = message; 
  switch (data.type) { 
<strong>    case 'calculate-sum':<br/></strong><strong>      const sum = data.array.reduce((acc, number) =&gt; acc + <br/>      number,0);<br/></strong><strong>      global.postMessage({ type: 'sum', result: sum });<br/></strong><strong>      break;<br/>  }</strong> 
}; </pre>
<ol start="12">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div><img src="img/bf22cdc4-ab6b-4506-aafc-ea6c5aa407e0.png" style="width:53.17em;height:25.67em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We've seen in previous chapters how flexible composing promises and <kbd>async</kbd> functions can be. Doing so with workers is a natural extension. Consider an asynchronous AJAX request. This could be thought of as taking place in a worker. After all, it is being performed in a different thread of execution, but managed by the browser.</p>
<p>As long as success error conditions are handled properly, promises and <kbd>async</kbd> functions can be used to provide familiar interfaces to Web Workers. Having familiar and simple interfaces is crucial when integrating new technology with an existing code base.</p>


            

            
        
    </body></html>