- en: Chapter 5. Module Augmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started creating simple modules for our fictitious
    **Images Inc.** web application. In this chapter, we will take one of the modules
    that we have already built and add more functionality to it using an approach
    known as **module augmentation**.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows us to extend our modules without the need to change the
    original implementation. There are different techniques which can be used to implement
    module augmentation, and we will cover a couple of them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Module augmentation can be very useful when working on projects that have many
    contributors to the code base. This type of projects usually require us to extend
    our modules by adding new code and functionality to what has been already developed
    by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts that we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind module augmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loose augmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tight augmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating our application's content area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module augmentation and script loading order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and disadvantage of different augmentation techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principles of module augmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, we created specialized modules to do some
    specific tasks for us. However, as we move forward and develop our application
    further, we are going to require more functionality from our modules, and we will
    also require additional specialized modules.
  prefs: []
  type: TYPE_NORMAL
- en: When you are working on a large project, it is quite normal to have many developers
    working on various pieces of the application. It is also possible to have many
    developers work on the same part of the application together which requires a
    seamless approach for combining their efforts and the functionality that they
    add to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider our `GlobalData` module from the previous chapter as an example.
    This module was responsible for storing and caching application-level data. However,
    in its current state, it holds a very limited amount of application-level data.
    It is quite feasible to assume that when different developers are working on other
    pieces of the application, they too need to store specific application-level data
    in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this, is by modifying the `GlobalData` module manually and adding
    more data and interfaces to it. But we need to keep in mind that the more people
    who modify the module, the higher possibility of something breaking in the module's
    code and for accidental modification to the important application-level data in
    an undesirable way.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the original module file may not be accessible to some developers
    for various reasons, which may hinder the cooperative development of our application.
  prefs: []
  type: TYPE_NORMAL
- en: What if we could come up with a way which would enable each developer to add
    the required functionality to the original module without the need to modify or
    require the original module's code?
  prefs: []
  type: TYPE_NORMAL
- en: Module augmentation allows us to do just that in a very robust way. As the name
    implies, this concept is about adding functionality (properties) to the original
    module, without changing the original module's code directly. The general idea
    is that we can create a namespace which imports the original module at runtime
    and then adds new functionality to it as required.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing module augmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that we have a module called `ModuleA` and, as a developer, you want
    to add more functionality to this module. However, for some reason, you decide
    to implement this new functionality in a completely separate module and then dynamically
    augment the original module with all the data and capabilities of this new module.
    You can achieve this as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are again using the module pattern here, as the intent is
    to add the new functionality in a modular fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In this IIFE, a reference to `coreModule` object is returned.. There is, however,
    one important thing to keep in mind here. We are passing `ModuleA` as a parameter
    to our anonymous container function. Also, the property `someMethod` is being
    added to the passed-in `coreModule`, which is in fact a reference to `ModuleA`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, at the end of this function execution, `ModuleA` has a new property
    method called `someMethod`, which has access to the value of `someData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: There is one assumption that we are making here. We are assuming that `ModuleA`
    does exist as an object, and if not, we will get an execution error when we run
    the preceding code. You will see shortly how we can fix this issue, but for now,
    let's take this augmentation concept and use it to extend `ImagesInc_GlobalData`
    module in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Module naming conventions**'
  prefs: []
  type: TYPE_NORMAL
- en: As we are getting more involved with module implementation in our application,
    it is best to use more specific naming for our modules. Generally speaking, it
    is a good idea to use names that are as specific as possible for our modules.
    This minimizes the chance of naming conflicts between our application modules
    and third-party modules that we might be loading in our application. For this
    reason, as we move forward, we will be adding `ImagesInc_` prefix to all of our
    module names, to make the names more specific to our application.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that some developers choose to use all capital lettering
    for the name of their modules in the code, as a convention. We will not be using
    this convention in our application. In your own coding practices, whether to use
    all capital lettering for your module names or not is something that you should
    decide on with your team. This is so you can establish a set of standards which
    all the members of the team would be required to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Simple augmentation of ImagesInc_GlobalData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may recall, we used our `ImagesInc_GlobalData` module (previously named
    `GlobalData`) to store application-level data for us. This module also provided
    a couple of interfaces, so other pieces of the application could have access to
    the private data that we had stored in this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another JavaScript file, which adds more data and a new interface
    to this module. We can call this file `Modules_2.js` and add it to the list of
    JavaScript files that our main page loads at runtime, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this file is added as any other JavaScript file would be in
    our `index.html`. However, one thing to notice in the preceding code is the order
    that the two module files have been added. This order is important and we will
    talk more about it shortly, but for now, keep in mind that our `ImageInc_GlobalData`
    module is loaded first in our application (as it resides in `Modules.js`). Then,
    the code residing in `Modules_2.js` will add more functionality to this module,
    as it is loaded afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the following lines of code to `Modules_2.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used an anonymous function to create a **namespace**, using an
    IIFE. We have also passed in a reference to the `ImagesInc_GlobalData` object
    (module) in the form of a parameter to this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this anonymous function, we have added two properties to the passed-in
    object reference, `coreModule`. This means that our `ImagesInc_GlobalData` now
    has two new properties added to it. Let''s verify this by running a test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we call `getExtendedModuleMsg` method on `ImagesInc_GlobalData` object,
    we see that the code runs properly and the expected message is shown in the console.
  prefs: []
  type: TYPE_NORMAL
- en: As the `ImagesInc_GlobalData` module did not originally have the method `getExtendedModuleMsg`,
    it now appears that it has been augmented with these new properties.
  prefs: []
  type: TYPE_NORMAL
- en: This simple example demonstrates how we can augment our original module without
    directly modifying the code in that module. We also saw that the augmentation
    can be done in a separate file, which means a different developer could add more
    functionality to our original module, without ever having direct access to the
    original module's code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this type of augmentation can just as easily be done when both the
    original module and the augmenting code are in the same file. It is good to have
    the flexibility to pick and choose which approach we would like to take: to either
    have the original module and its augmenting code in separate files or in the same
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: We will soon talk about this type of augmentation in greater depth, and will
    even give it a technical name.
  prefs: []
  type: TYPE_NORMAL
- en: The order of things in module augmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we added `Modules_2.js` file to our `index.html`, I mentioned that we need
    to load this file after we load `Modules.js` file for things to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is not hard to discover. If the order of loading these files
    is reversed, and subsequently the order of the code execution, we will be trying
    to add properties to an object (`ImagesInc_GlobalData`) that does not exist yet,
    which will result in a code execution error.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways that we can work around this, which brings us to our next topic,
    **loose augmentation**.
  prefs: []
  type: TYPE_NORMAL
- en: Loose augmentation of modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we try to enhance a module using the augmentation technique previously
    discussed, we pass a reference of the module to another part of our code which
    is responsible for doing the augmentation work.
  prefs: []
  type: TYPE_NORMAL
- en: How can we add functionality to an object that has not been loaded or created
    yet?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question becomes very important when our modules (files)
    are loaded in an asynchronous fashion, and we have no way of making sure that
    our original module is loaded before the augmentation code that enhances the module.
  prefs: []
  type: TYPE_NORMAL
- en: One of the beautiful and powerful aspects of JavaScript is its ability to add
    properties to objects dynamically, at any time during code execution. This allows
    us to add functionality or modify our original module's implementation even before
    the module is loaded, as long as we provide a temporary object in the absence
    of the module. This temporary object will be added to the original module after
    the module is loaded (or more accurately, it becomes one with the original module).
  prefs: []
  type: TYPE_NORMAL
- en: 'If it sounds complicated, it really is simpler than you think. Let''s revisit
    our previous augmenting code and examine it a little closer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I mentioned that for the augmentation to work properly, we needed to load this
    code, which is responsible for augmenting the `ImageInc_GlobalData` module, after
    the original module is loaded. Otherwise, a code execution error will be thrown.
    While that remains true, what if we compensate for when `ImagesInc_GlobalData`
    does not yet exist in the application by using an empty object?
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably know, we can call a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, we are telling the JavaScript interpreter to pass `someParameter`
    when calling `someFunc`, if it has a value; and if not, pass `someotherParameter`
    to the function. That is how the `||` operator works in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same technique and pass an empty object to our anonymous function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We tell the interpreter to pass a reference of our `ImagesInc_GlobalData` object
    when calling the function, if the object exists, or pass a reference of an empty
    object which will replace our original module for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: Loose augmentation of ImagesInc_GlobalData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rewrite our previous augmenting code for `ImagesInc_GlobalData` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are calling our anonymous function and passing a reference
    of `ImagesInc_GlobalData` to it, if `ImagesInc_GlobalData` does exist. Otherwise,
    we are passing a reference to an anonymous empty object into the function.
  prefs: []
  type: TYPE_NORMAL
- en: Our augmenting code still adds new properties to the passed-in object; however,
    this time it returns a reference to `coreModule` to the `ImagesInc_GlobalData`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For everything to work properly, we also need to modify our original `ImagesInc_GlobalData`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have made a few modifications to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, we used to create an anonymous object in our original module
    and return a reference to it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, in our new augmenting implementation we are adding our module interface
    methods directly to the module object that is passed into the anonymous function.
    Also, the module object passed into our anonymous function is either a reference
    to `ImagesInc_GlobalData` or a reference to an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other subtle point to notice here. Both the augmenting code and
    our original module code are returning an object reference to the `ImagesInc_GlobalData`
    variable, and this is very important.
  prefs: []
  type: TYPE_NORMAL
- en: To explain this point, we need to dig a little deeper. There are times in our
    applications that the module code and the code that is augmenting it are loaded
    asynchronously. This means that we cannot be sure ahead of time which code is
    executed first. When we return a reference to our object from both the original
    module and the augmenting code, we can be sure that regardless of the code execution
    order, our module is augmented properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, if there is an `ImagesInc_GlobalData` object that already exists
    in the global namespace, we augment it with the new properties, and if not, we
    create it and then add new properties to it. That is why in both instances (the
    original module code and the augmenting code), we execute our IIFE with the following
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This provides us with the ability to create or augment our module in a non-strict
    order, hence the term **loose augmentation**.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the main advantage of this technique is that we don't have to worry
    about which file is loaded first; either way, our module is created and augmented
    as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that in both cases, we need to make sure that we create the same
    global variable, `ImagesInc_GlobalData`, so that when we check for the existence
    of this object in the global namespace, the correct reference is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to put our code to the test. After making the modifications mentioned
    previously, we can run the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the correct message is shown in the console. Now, let's see
    what happens if we change the order in which our JavaScript module files are loaded
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the following change in our `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to make sure that our augmenting code is loaded first. Then we execute
    the same line of code as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that both our original module and our augmenting code are working
    as expected, regardless of which was loaded and executed first.
  prefs: []
  type: TYPE_NORMAL
- en: Testing ImagesInc_GlobalData data encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can test and see how encapsulation and privacy have been preserved in our
    module. This can be done by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code will display **could not access the property** in the console, which
    confirms our original module encapsulation is still in effect, as we would like
    it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A note about the project code**'
  prefs: []
  type: TYPE_NORMAL
- en: As always, I highly recommend that you download the related code for this chapter
    from the accompanying website for this book. In the code for this chapter, I have
    created a new file called `AppTester.js`, which is used to test the application
    as we modify and enhance it. I recommend this approach of testing our application
    every time we run it during the development phase. This is so we can be sure that
    our changes in one part do not cause any problems in other parts of the application.
    This is also aligned with **Test-Driven Development** (**TDD**) approach, but
    in a very rudimentary way.
  prefs: []
  type: TYPE_NORMAL
- en: Tight augmentation of modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have talked about what module augmentation is in
    general and have also covered the loose augmentation technique. It is time to
    explore a different technique used in augmenting modules, known as **tight augmentation**.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder if tight augmentation is the opposite of loose augmentation,
    and you are correct to think that, but with a couple of considerations which we
    will talk about a little later.
  prefs: []
  type: TYPE_NORMAL
- en: Tight augmentation is used for adding properties (functionality) to our modules
    when we do want to enforce a set order of file loading and code execution, and
    therefore it is less flexible. This type of augmentation is usually used when
    we need to make sure that a certain property from the original module is available
    for our augmenting code.
  prefs: []
  type: TYPE_NORMAL
- en: Tight augmentation of ImagesInc_GlobalData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider our augmenting code for `ImagesInc_GlobalData` module from the previous
    section, when loose augmentation was being used. As mentioned previously, since
    we are passing a reference to `ImagesInc_GlobalData` or an empty anonymous object
    into our IIFE, we can load our original module and our augmenting code in any
    order that we like.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, this also means that if we wanted to override one of the original module's
    properties, depending on what code gets loaded and executed first (the original
    module or the augmenting code), our "override" might be overridden by another
    piece of code, unintentionally and unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s create another file, `Modules_3.js`, and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s load this file in our application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we are loading two files (`Modules_3.js` and `Modules_2.js`), which augment
    our original module. `Modules_2.js` is being loaded before `Modules.js`, but `Modules_3.js`
    can be loaded in any order since we are using the `async` property on the `<script>`
    tag for this file. This property tells the browser to load the file in any order
    that it can.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these augmenting codes add the same property, `coreModule.someText`,
    to the original module. However, depending on which code is loaded and executed
    first, only one of two pieces of text will be printed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The console will display one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**this is a test for module augmentation** (from `Modules_2.js`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**this is a test for overriding module properties with loose augmentation**
    (from `Modules_3.js`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that in this scenario, we have no control over which one of the
    strings will be the value of the `coreModule.someText` property after all the
    code execution is completed. This is because we don't know which augmenter code
    will be loaded and executed last. This also means that by using loose augmentation
    technique and asynchronous loading, augmenter code precedence is determined dynamically
    at runtime and not necessarily in the order that we think or desire.
  prefs: []
  type: TYPE_NORMAL
- en: On such basis, if our intent was that the value of `coreModule.someText` should
    be overridden by the code in `Modules_3.js`, then we could not be sure of such
    an override taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simulating asynchronous script loading**'
  prefs: []
  type: TYPE_NORMAL
- en: To simulate the asynchronous loading of our augmenters, you can reload the `index.html`
    page a few times in a row (from the application code accompanying this chapter).
    You'll see that the message displayed in the console may change from time to time.
    The message displayed depends on which file, `Modules_2.js` or `Modules_3.js`,
    is loaded first by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tight augmentation, on the other hand, guarantees the order of code execution
    and therefore how our modules get augmented. By using this technique, we can be
    sure that when a module property is overridden, it will be in the order that we
    intended and the result will be as expected.
  prefs: []
  type: TYPE_NORMAL
- en: This guarantee is provided by the fact that we don't have any choice but to
    load our module and its augmenting code in the correct order, otherwise a code
    execution error will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine this by modifying the code in our `Moduels_3.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the augmenting code, we are no longer passing in a reference
    to an empty anonymous object to our IIFE. Therefore, if `ImagesInc_GlobalData`
    module has not been already loaded, we cannot augment it with any new properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at the start of the preceding code we are checking to see whether
    `coreModule` exists, and if not we are using our `ImagesInc_LoggingHandler` module
    to log an error to the console. We are also using an alert box in the browser
    to make sure that the situation really catches the user's attention (try not to
    use alert boxes in production code as it looks unprofessional; I'm just using
    it here for ease of demonstration).
  prefs: []
  type: TYPE_NORMAL
- en: Loading ImagesInc_GlobalData augmenting code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To examine how tight augmentation enforces a set order of script loading and
    code execution, we can change our `index.html` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are no longer loading the `Modules_3.js` file asynchronously
    and it will be the first module-related file that gets loaded. Considering that
    we have modified the augmenting code in this file to only augment the module when
    the module (`ImagesInc_GlobalData`) is already present in the global scope, an
    error message will be logged and an **alert box** will be displayed in the browser
    when we load the page.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are using the tight augmentation technique now, we need to load this
    augmenting code after either `Modules.js` or `Modules_2.js`. This is necessary
    so we can be sure that the `ImagesInc_GlobalData` module (object) is already present
    in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, since our intention is to override the value of `someText` by using the
    code in `Modules_3.js`, and this property was added to the module by the augmenting
    code in `Modules_2.js`, we need to load both `Modules.js` and `Modules_2.js` first.
    This is the only way we can guarantee that an override of the value of `someText`
    is taking place as intended.Therefore, to achieve the proper override, we need
    to modify the loading order of our scripts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This rearrangement of the order of scripts in our `index.html` file ensures
    that the override of the value of the `someText` property for the module will
    produce the expected result. This is of course, because our original module is
    loaded first, then it is augmented with the `someText` property, using the augmenting
    code in `Modules_2.js`. At the end, the value of this property is overridden by
    the tight augmenting code in `Module_3.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations in tight augmentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this section, I mentioned that there are a couple of considerations
    regarding tight augmentation that we need to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: First, we do not really need to create a global variable to store the returned
    value from the augmenting code that implements the tight augmentation technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is so since this type of augmentation can only take place if the module
    already exists in the global context. In fact, the following code will work just
    as well as the previous version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Second, before we override a property that already exists in the module, we
    can preserve the original value of the property by storing it in another property.
    This allows us to have access to both the original value of the property and its
    overridden value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do that in our `Modules_3.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the original value of the `someText` property by running the following
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, not only tight augmentation technique is a nice way to override
    our module properties, it also allows us to hold on to the original (previous)
    values of our properties, in case we ever need to use them again.
  prefs: []
  type: TYPE_NORMAL
- en: Generating our application's content area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have read the previous sections of this chapter, you have a pretty good
    grasp of what module augmentation is by now. You also know of a couple of techniques
    to add dynamic properties to our modules using augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands, our application (`Images Inc.`) has code that dynamically generates
    the header and footer sections of our pages. But we still have an empty space
    in the middle (the content area), which needs to be populated with content.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put the techniques that we have learned in this chapter to good use and
    add functionality to our application that will generate the content area dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the refactored augmenting code in `Modules_3.js` is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A few things have happened here. As you can see, we are using tight augmentation
    to augment our `ImagesInc_GlobalData` module. We have also created a new property
    for this module, `originalModule.mainContentContainerDef`, which holds the object
    definition for the content area of the page. Since the content area uses a repeated
    structure of rectangles to display the desired images on the page, we have used
    an inner IIFE, which creates that structure and stores it in `sectionHTML` property
    of the content area object definition as a string.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the external code to have access to this string, and to be able
    to render the content area of our `index.html` page, we have created `originalModule.getContentAreaHTMLTxt`
    method. This is added as an interface to our original `ImagesInc_GlobalData` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we load the application''s `index.html` page now, it is displayed as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating our application''s content area](img/B04910_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, for the time being, I'm using the previous color coding schema that
    you have seen before for our various page fragments. For ease of identification,
    the image boxes are shown in pink (if you are reading the book in color).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A caveat to keep in mind**'
  prefs: []
  type: TYPE_NORMAL
- en: In our augmenting code, we added the `mainContentContainerDef` property to our
    module without using a closure. Therefore, this property is not implemented with
    the same type of encapsulation and private access as `headerContainerDef` and
    `footerContainerDef`. These properties were defined in our original module as
    private variables, and access to them was only possible through the interfaces
    that we created for external use. Of course, we created that private access using
    a closure.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to restrict access to them in your modules, it is best to define
    the properties in the original modules (using closures) as opposed to adding them
    to the modules using the augmentation techniques (unless you use closures in your
    augmenting code too).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered what module augmentation is and explored a couple
    of different techniques, known as loose augmentation and tight augmentation, to
    implement module augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how each approach is used in different circumstances and for different
    application requirements, as well as the pros and cons related to each technique.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which scripts should be loaded was also discussed, based on the
    augmentation technique used.
  prefs: []
  type: TYPE_NORMAL
- en: Once we had a good grasp of these augmentation implementations, we refactored
    part of our application code to augment `ImagesInc_GlobalData` module. Subsequently,
    we generated the content area of `index.html` page and populated it with containers,
    which will host the images for our application in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some more techniques in modular design
    which will enable us to extend and clone our modules as needed.
  prefs: []
  type: TYPE_NORMAL
