- en: Chapter 5. Module Augmentation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 模块增强
- en: In the previous chapter, we started creating simple modules for our fictitious
    **Images Inc.** web application. In this chapter, we will take one of the modules
    that we have already built and add more functionality to it using an approach
    known as **module augmentation**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始为我们的虚构**Images Inc.**网络应用程序创建简单的模块。在这一章中，我们将使用一种称为**模块增强**的方法，对我们的一个已构建的模块添加更多功能。
- en: This approach allows us to extend our modules without the need to change the
    original implementation. There are different techniques which can be used to implement
    module augmentation, and we will cover a couple of them in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们在不改变原始实现的情况下扩展我们的模块。有几种不同的技术可以用来实现模块增强，我们将在本章中介绍其中的一些。
- en: Module augmentation can be very useful when working on projects that have many
    contributors to the code base. This type of projects usually require us to extend
    our modules by adding new code and functionality to what has been already developed
    by other developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在有许多代码库贡献者的项目上工作时，模块增强可以非常有用。这类项目通常要求我们通过添加新代码和功能来扩展我们的模块，这些代码和功能是其他开发者已经开发的。
- en: 'The concepts that we will cover in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的概念包括：
- en: The idea behind module augmentation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块增强背后的理念
- en: Loose augmentation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散增强
- en: Tight augmentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧密增强
- en: Generating our application's content area
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成我们应用程序的内容区域
- en: Module augmentation and script loading order
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块增强和脚本加载顺序
- en: Advantages and disadvantage of different augmentation techniques
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同增强技术的优缺点
- en: Principles of module augmentation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块增强的原则
- en: As you saw in the previous chapter, we created specialized modules to do some
    specific tasks for us. However, as we move forward and develop our application
    further, we are going to require more functionality from our modules, and we will
    also require additional specialized modules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，我们创建了专门的模块来为我们执行一些特定的任务。然而，随着我们继续前进并进一步开发我们的应用程序，我们将需要从我们的模块中获得更多功能，我们还将需要额外的专用模块。
- en: When you are working on a large project, it is quite normal to have many developers
    working on various pieces of the application. It is also possible to have many
    developers work on the same part of the application together which requires a
    seamless approach for combining their efforts and the functionality that they
    add to the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在处理一个大项目时，有许多开发者正在处理应用程序的不同部分是非常正常的。也有可能许多开发者一起工作在应用程序的同一部分，这需要一种无缝的方法来结合他们的努力以及他们添加到应用程序中的功能。
- en: Let's consider our `GlobalData` module from the previous chapter as an example.
    This module was responsible for storing and caching application-level data. However,
    in its current state, it holds a very limited amount of application-level data.
    It is quite feasible to assume that when different developers are working on other
    pieces of the application, they too need to store specific application-level data
    in the same module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前一章中的`GlobalData`模块为例。这个模块负责存储和缓存应用程序级别的数据。然而，在其当前状态下，它只包含非常有限的应用程序级别数据。我们可以合理地假设，当不同的开发者正在处理应用程序的其他部分时，他们也需要在同一个模块中存储特定的应用程序级别数据。
- en: One way to do this, is by modifying the `GlobalData` module manually and adding
    more data and interfaces to it. But we need to keep in mind that the more people
    who modify the module, the higher possibility of something breaking in the module's
    code and for accidental modification to the important application-level data in
    an undesirable way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是通过手动修改`GlobalData`模块并添加更多数据和接口。但我们需要记住，修改模块的人越多，模块代码中出问题的可能性就越高，以及意外地以不理想的方式修改重要的应用程序级别数据。
- en: On the other hand, the original module file may not be accessible to some developers
    for various reasons, which may hinder the cooperative development of our application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于各种原因，原始模块文件可能无法被一些开发者访问，这可能会阻碍我们应用程序的协作开发。
- en: What if we could come up with a way which would enable each developer to add
    the required functionality to the original module without the need to modify or
    require the original module's code?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能想出一个方法，让每个开发者都能在不修改或要求修改原始模块代码的情况下向原始模块添加所需的功能，那会怎么样呢？
- en: Module augmentation allows us to do just that in a very robust way. As the name
    implies, this concept is about adding functionality (properties) to the original
    module, without changing the original module's code directly. The general idea
    is that we can create a namespace which imports the original module at runtime
    and then adds new functionality to it as required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模块增强使我们能够以非常稳健的方式做到这一点。正如其名所示，这个概念是关于向原始模块添加功能（属性），而不直接更改原始模块的代码。一般思路是我们可以在运行时导入原始模块并按需向其添加新功能。
- en: Implementing module augmentation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模块增强
- en: 'Imagine that we have a module called `ModuleA` and, as a developer, you want
    to add more functionality to this module. However, for some reason, you decide
    to implement this new functionality in a completely separate module and then dynamically
    augment the original module with all the data and capabilities of this new module.
    You can achieve this as shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`ModuleA`的模块，作为一个开发者，你想要向这个模块添加更多功能。然而，由于某种原因，你决定在一个完全独立的模块中实现这个新功能，然后动态地用这个新模块的所有数据和功能增强原始模块。你可以像下面这样实现：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we are again using the module pattern here, as the intent is
    to add the new functionality in a modular fashion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在这里再次使用了模块模式，因为我们的意图是以模块化的方式添加新功能。
- en: In this IIFE, a reference to `coreModule` object is returned.. There is, however,
    one important thing to keep in mind here. We are passing `ModuleA` as a parameter
    to our anonymous container function. Also, the property `someMethod` is being
    added to the passed-in `coreModule`, which is in fact a reference to `ModuleA`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个立即执行函数表达式（IIFE）中，返回了对`coreModule`对象的引用。然而，这里有一个重要的事情需要记住。我们将`ModuleA`作为参数传递给我们的匿名容器函数。此外，属性`someMethod`被添加到传入的`coreModule`中，实际上这是一个对`ModuleA`的引用。
- en: Therefore, at the end of this function execution, `ModuleA` has a new property
    method called `someMethod`, which has access to the value of `someData` variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个函数执行结束时，`ModuleA`有一个新的属性方法`someMethod`，它可以访问`someData`变量的值。
- en: There is one assumption that we are making here. We are assuming that `ModuleA`
    does exist as an object, and if not, we will get an execution error when we run
    the preceding code. You will see shortly how we can fix this issue, but for now,
    let's take this augmentation concept and use it to extend `ImagesInc_GlobalData`
    module in our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个假设。我们假设`ModuleA`作为一个对象确实存在，如果不是这样，当我们运行前面的代码时，我们将得到一个执行错误。你很快就会看到我们如何解决这个问题，但就目前而言，让我们将这个增强概念应用到我们的应用程序中，以扩展`ImagesInc_GlobalData`模块。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Module naming conventions**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块命名约定**'
- en: As we are getting more involved with module implementation in our application,
    it is best to use more specific naming for our modules. Generally speaking, it
    is a good idea to use names that are as specific as possible for our modules.
    This minimizes the chance of naming conflicts between our application modules
    and third-party modules that we might be loading in our application. For this
    reason, as we move forward, we will be adding `ImagesInc_` prefix to all of our
    module names, to make the names more specific to our application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越多地参与到应用程序中的模块实现，最好为我们的模块使用更具体的命名。一般来说，为我们的模块使用尽可能具体的名称是一个好主意。这最小化了我们的应用程序模块和可能加载到应用程序中的第三方模块之间的命名冲突的可能性。因此，随着我们继续前进，我们将为所有模块名添加`ImagesInc_`前缀，使名称更具体地反映我们的应用程序。
- en: It is also worth mentioning that some developers choose to use all capital lettering
    for the name of their modules in the code, as a convention. We will not be using
    this convention in our application. In your own coding practices, whether to use
    all capital lettering for your module names or not is something that you should
    decide on with your team. This is so you can establish a set of standards which
    all the members of the team would be required to follow.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一些开发者选择在代码中用全大写字母命名他们的模块，作为一种约定。在我们的应用程序中，我们不会使用这种约定。在你的编码实践中，是否使用全大写字母为你的模块命名，应该由你和你的团队决定。这样，你可以建立一套标准，所有团队成员都必须遵守。
- en: Simple augmentation of ImagesInc_GlobalData
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单增强ImagesInc_GlobalData
- en: As you may recall, we used our `ImagesInc_GlobalData` module (previously named
    `GlobalData`) to store application-level data for us. This module also provided
    a couple of interfaces, so other pieces of the application could have access to
    the private data that we had stored in this module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，我们使用 `ImagesInc_GlobalData` 模块（之前命名为 `GlobalData`）为我们存储应用程序级别的数据。此模块还提供了一些接口，以便应用程序的其他部分可以访问我们存储在此模块中的私有数据。
- en: 'Let''s create another JavaScript file, which adds more data and a new interface
    to this module. We can call this file `Modules_2.js` and add it to the list of
    JavaScript files that our main page loads at runtime, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个 JavaScript 文件，为这个模块添加更多数据和新的接口。我们可以将此文件命名为 `Modules_2.js`，并将其添加到在运行时由主页面加载的
    JavaScript 文件列表中，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this file is added as any other JavaScript file would be in
    our `index.html`. However, one thing to notice in the preceding code is the order
    that the two module files have been added. This order is important and we will
    talk more about it shortly, but for now, keep in mind that our `ImageInc_GlobalData`
    module is loaded first in our application (as it resides in `Modules.js`). Then,
    the code residing in `Modules_2.js` will add more functionality to this module,
    as it is loaded afterwards.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此文件被添加的方式与我们在 `index.html` 中添加任何其他 JavaScript 文件的方式相同。然而，在前面代码中需要注意的一点是两个模块文件被添加的顺序。这个顺序很重要，我们将在稍后进行更多讨论，但到目前为止，请记住在我们的应用程序中，`ImageInc_GlobalData`
    模块（位于 `Modules.js` 中）首先被加载。然后，位于 `Modules_2.js` 中的代码将在之后加载，并为该模块添加更多功能。
- en: 'We need to add the following lines of code to `Modules_2.js`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Modules_2.js` 中添加以下代码行：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have used an anonymous function to create a **namespace**, using an
    IIFE. We have also passed in a reference to the `ImagesInc_GlobalData` object
    (module) in the form of a parameter to this function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用匿名函数通过 IIFE 创建了一个 **命名空间**。我们还通过参数将 `ImagesInc_GlobalData` 对象（模块）的引用传递给这个函数。
- en: 'Inside this anonymous function, we have added two properties to the passed-in
    object reference, `coreModule`. This means that our `ImagesInc_GlobalData` now
    has two new properties added to it. Let''s verify this by running a test, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个匿名函数内部，我们向传入的对象引用 `coreModule` 添加了两个属性。这意味着我们的 `ImagesInc_GlobalData` 现在增加了两个新属性。让我们通过以下测试来验证这一点：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we call `getExtendedModuleMsg` method on `ImagesInc_GlobalData` object,
    we see that the code runs properly and the expected message is shown in the console.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `ImagesInc_GlobalData` 对象上调用 `getExtendedModuleMsg` 方法时，我们看到代码运行正常，预期的消息显示在控制台。
- en: As the `ImagesInc_GlobalData` module did not originally have the method `getExtendedModuleMsg`,
    it now appears that it has been augmented with these new properties.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ImagesInc_GlobalData` 模块最初没有 `getExtendedModuleMsg` 方法，现在看起来它已经通过这些新属性进行了增强。
- en: This simple example demonstrates how we can augment our original module without
    directly modifying the code in that module. We also saw that the augmentation
    can be done in a separate file, which means a different developer could add more
    functionality to our original module, without ever having direct access to the
    original module's code file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子演示了我们可以如何在不直接修改该模块中的代码的情况下增强我们的原始模块。我们还看到，增强可以在一个单独的文件中进行，这意味着不同的开发者可以在不直接访问原始模块的代码文件的情况下，为我们原始模块添加更多功能。
- en: 'Of course, this type of augmentation can just as easily be done when both the
    original module and the augmenting code are in the same file. It is good to have
    the flexibility to pick and choose which approach we would like to take: to either
    have the original module and its augmenting code in separate files or in the same
    file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种类型的增强也可以在原始模块和增强代码都在同一文件中进行时完成。拥有选择我们想要采取的方法的灵活性是好的：要么将原始模块及其增强代码放在单独的文件中，要么放在同一文件中。
- en: We will soon talk about this type of augmentation in greater depth, and will
    even give it a technical name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快更深入地讨论这种增强类型，甚至给它一个技术名称。
- en: The order of things in module augmentation
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块增强中事物的顺序
- en: When we added `Modules_2.js` file to our `index.html`, I mentioned that we need
    to load this file after we load `Modules.js` file for things to work properly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `Modules_2.js` 文件添加到我们的 `index.html` 文件中时，我提到我们需要在加载 `Modules.js` 文件之后加载此文件，以确保一切正常工作。
- en: The reason for this is not hard to discover. If the order of loading these files
    is reversed, and subsequently the order of the code execution, we will be trying
    to add properties to an object (`ImagesInc_GlobalData`) that does not exist yet,
    which will result in a code execution error.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原因并不难发现。如果这些文件的加载顺序被颠倒，以及随后的代码执行顺序，我们将尝试向一个尚不存在的对象（`ImagesInc_GlobalData`）添加属性，这将导致代码执行错误。
- en: There are ways that we can work around this, which brings us to our next topic,
    **loose augmentation**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以解决这个问题，这把我们带到了下一个主题，**松散增强**。
- en: Loose augmentation of modules
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的松散增强
- en: When we try to enhance a module using the augmentation technique previously
    discussed, we pass a reference of the module to another part of our code which
    is responsible for doing the augmentation work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用之前讨论的增强技术增强一个模块时，我们将模块的引用传递给代码的另一个部分，该部分负责执行增强工作。
- en: How can we add functionality to an object that has not been loaded or created
    yet?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何向尚未加载或创建的对象添加功能？
- en: The answer to this question becomes very important when our modules (files)
    are loaded in an asynchronous fashion, and we have no way of making sure that
    our original module is loaded before the augmentation code that enhances the module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的模块（文件）以异步方式加载时，这个问题变得非常重要，我们无法确保在增强模块的代码之前加载我们的原始模块。
- en: One of the beautiful and powerful aspects of JavaScript is its ability to add
    properties to objects dynamically, at any time during code execution. This allows
    us to add functionality or modify our original module's implementation even before
    the module is loaded, as long as we provide a temporary object in the absence
    of the module. This temporary object will be added to the original module after
    the module is loaded (or more accurately, it becomes one with the original module).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 美丽而强大的一个方面是它能够在代码执行期间动态地向对象添加属性，任何时候都可以。这允许我们在模块加载之前添加功能或修改原始模块的实现，只要我们提供一个临时对象以替代模块。这个临时对象将在模块加载后（或者更准确地说，它变成了原始模块的一部分）被添加到原始模块中。
- en: 'If it sounds complicated, it really is simpler than you think. Let''s revisit
    our previous augmenting code and examine it a little closer:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果听起来很复杂，实际上它比你想象的要简单。让我们回顾一下之前的增强代码，并仔细检查一下：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I mentioned that for the augmentation to work properly, we needed to load this
    code, which is responsible for augmenting the `ImageInc_GlobalData` module, after
    the original module is loaded. Otherwise, a code execution error will be thrown.
    While that remains true, what if we compensate for when `ImagesInc_GlobalData`
    does not yet exist in the application by using an empty object?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到，为了使增强正常工作，我们需要在原始模块加载后加载这段代码，这段代码负责增强 `ImageInc_GlobalData` 模块。否则，将抛出一个代码执行错误。虽然这一点仍然是正确的，但如果我们使用一个空对象来补偿
    `ImagesInc_GlobalData` 在应用程序中尚未存在的情况，会怎样呢？
- en: 'As you probably know, we can call a function as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能所知，我们可以如下调用一个函数：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we do this, we are telling the JavaScript interpreter to pass `someParameter`
    when calling `someFunc`, if it has a value; and if not, pass `someotherParameter`
    to the function. That is how the `||` operator works in the preceding code snippet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们是在告诉 JavaScript 解释器在调用 `someFunc` 时传递 `someParameter`，如果它有值的话；如果没有，就传递
    `someotherParameter` 到函数中。这就是前面代码片段中 `||` 运算符的工作方式。
- en: 'We can use the same technique and pass an empty object to our anonymous function,
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的技巧，并将一个空对象传递给我们的匿名函数，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We tell the interpreter to pass a reference of our `ImagesInc_GlobalData` object
    when calling the function, if the object exists, or pass a reference of an empty
    object which will replace our original module for the time being.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉解释器在调用函数时传递我们的 `ImagesInc_GlobalData` 对象的引用，如果对象存在的话，或者传递一个空对象的引用，这个空对象将暂时替换我们的原始模块。
- en: Loose augmentation of ImagesInc_GlobalData
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImagesInc_GlobalData 的松散增强
- en: 'Let''s rewrite our previous augmenting code for `ImagesInc_GlobalData` as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新编写之前为 `ImagesInc_GlobalData` 编写的增强代码，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are calling our anonymous function and passing a reference
    of `ImagesInc_GlobalData` to it, if `ImagesInc_GlobalData` does exist. Otherwise,
    we are passing a reference to an anonymous empty object into the function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在调用我们的匿名函数，并将 `ImagesInc_GlobalData` 的引用传递给它，如果 `ImagesInc_GlobalData`
    存在的话。否则，我们将一个匿名空对象的引用传递到函数中。
- en: Our augmenting code still adds new properties to the passed-in object; however,
    this time it returns a reference to `coreModule` to the `ImagesInc_GlobalData`
    variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增强的代码仍然向传入的对象添加新属性；然而，这次它将`coreModule`的引用返回给`ImagesInc_GlobalData`变量。
- en: 'For everything to work properly, we also need to modify our original `ImagesInc_GlobalData`
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一切正常工作，我们还需要按照以下方式修改我们的原始`ImagesInc_GlobalData`：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we have made a few modifications to the code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们对代码做了一些修改。
- en: 'If you recall, we used to create an anonymous object in our original module
    and return a reference to it like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们以前在原始模块中创建了一个匿名对象，并像这样返回其引用：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, in our new augmenting implementation we are adding our module interface
    methods directly to the module object that is passed into the anonymous function.
    Also, the module object passed into our anonymous function is either a reference
    to `ImagesInc_GlobalData` or a reference to an empty object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的新增强实现中，我们直接将模块接口方法添加到传递给匿名函数的模块对象中。同时，传递给我们的匿名函数的模块对象要么是`ImagesInc_GlobalData`的引用，要么是空对象的引用。
- en: There is one other subtle point to notice here. Both the augmenting code and
    our original module code are returning an object reference to the `ImagesInc_GlobalData`
    variable, and this is very important.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要注意的微妙之处。增强代码和我们的原始模块代码都返回了`ImagesInc_GlobalData`变量的对象引用，这一点非常重要。
- en: To explain this point, we need to dig a little deeper. There are times in our
    applications that the module code and the code that is augmenting it are loaded
    asynchronously. This means that we cannot be sure ahead of time which code is
    executed first. When we return a reference to our object from both the original
    module and the augmenting code, we can be sure that regardless of the code execution
    order, our module is augmented properly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这一点，我们需要深入探讨。在我们的应用程序中，有时模块代码和增强它的代码是异步加载的。这意味着我们无法提前确定哪个代码先被执行。当我们从原始模块和增强代码中返回我们的对象引用时，我们可以确信，无论代码执行顺序如何，我们的模块都会被正确增强。
- en: 'In our example, if there is an `ImagesInc_GlobalData` object that already exists
    in the global namespace, we augment it with the new properties, and if not, we
    create it and then add new properties to it. That is why in both instances (the
    original module code and the augmenting code), we execute our IIFE with the following
    call:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果全局命名空间中已经存在一个`ImagesInc_GlobalData`对象，我们就用新属性增强它；如果没有，我们就创建它并添加新属性。这就是为什么在这两种情况下（原始模块代码和增强代码），我们都会用以下调用执行我们的IIFE：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This provides us with the ability to create or augment our module in a non-strict
    order, hence the term **loose augmentation**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够以非严格顺序创建或增强我们的模块，因此术语称为**松散增强**。
- en: Of course, the main advantage of this technique is that we don't have to worry
    about which file is loaded first; either way, our module is created and augmented
    as intended.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种技术的最大优点是我们不必担心哪个文件先被加载；无论哪种方式，我们的模块都会按照预期创建和增强。
- en: Keep in mind that in both cases, we need to make sure that we create the same
    global variable, `ImagesInc_GlobalData`, so that when we check for the existence
    of this object in the global namespace, the correct reference is passed in.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在这两种情况下，我们需要确保创建相同的全局变量`ImagesInc_GlobalData`，这样当我们检查全局命名空间中该对象的存在时，就能传入正确的引用。
- en: 'It is time to put our code to the test. After making the modifications mentioned
    previously, we can run the following line of code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候对我们的代码进行测试了。在做出之前提到的修改后，我们可以运行以下代码行：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the correct message is shown in the console. Now, let's see
    what happens if we change the order in which our JavaScript module files are loaded
    in the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，控制台显示了正确的消息。现在，让我们看看如果我们改变应用程序中JavaScript模块文件加载顺序会发生什么。
- en: 'First, we make the following change in our `index.html` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`index.html`文件中做出以下更改：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is to make sure that our augmenting code is loaded first. Then we execute
    the same line of code as before:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保我们的增强代码首先被加载。然后我们执行与之前相同的代码行：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that both our original module and our augmenting code are working
    as expected, regardless of which was loaded and executed first.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，无论哪个先加载和执行，我们的原始模块和增强代码都在按预期工作。
- en: Testing ImagesInc_GlobalData data encapsulation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试ImagesInc_GlobalData数据封装
- en: 'We can test and see how encapsulation and privacy have been preserved in our
    module. This can be done by running the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码来测试并查看封装和隐私在我们的模块中是如何被保留的。这可以通过以下代码实现：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code will display **could not access the property** in the console, which
    confirms our original module encapsulation is still in effect, as we would like
    it to be.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在控制台显示**无法访问属性**，这证实了我们的原始模块封装仍然有效，正如我们所期望的那样。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A note about the project code**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于项目代码的注意事项**'
- en: As always, I highly recommend that you download the related code for this chapter
    from the accompanying website for this book. In the code for this chapter, I have
    created a new file called `AppTester.js`, which is used to test the application
    as we modify and enhance it. I recommend this approach of testing our application
    every time we run it during the development phase. This is so we can be sure that
    our changes in one part do not cause any problems in other parts of the application.
    This is also aligned with **Test-Driven Development** (**TDD**) approach, but
    in a very rudimentary way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我强烈建议您从本书的配套网站上下载本章的相关代码。在本章的代码中，我创建了一个名为`AppTester.js`的新文件，用于测试我们在修改和增强应用程序时的应用程序。我建议在开发阶段每次运行应用程序时都进行这种测试方法。这样我们可以确保我们在一个部分中的更改不会对应用程序的其他部分造成任何问题。这也与**测试驱动开发**（**TDD**）方法相一致，但以一种非常基础的方式。
- en: Tight augmentation of modules
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的紧密增强
- en: So far in this chapter, we have talked about what module augmentation is in
    general and have also covered the loose augmentation technique. It is time to
    explore a different technique used in augmenting modules, known as **tight augmentation**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经讨论了模块增强的一般概念，并且也介绍了松散增强技术。现在是时候探索在模块增强中使用的另一种技术，称为**紧密增强**。
- en: You might wonder if tight augmentation is the opposite of loose augmentation,
    and you are correct to think that, but with a couple of considerations which we
    will talk about a little later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道紧密增强是否是松散增强的反面，你的想法是正确的，但有一些考虑因素，我们稍后会讨论。
- en: Tight augmentation is used for adding properties (functionality) to our modules
    when we do want to enforce a set order of file loading and code execution, and
    therefore it is less flexible. This type of augmentation is usually used when
    we need to make sure that a certain property from the original module is available
    for our augmenting code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在文件加载和代码执行中强制执行一个特定的顺序时，我们会使用紧密增强来为我们的模块添加属性（功能），因此它相对不太灵活。这种增强通常用于确保原始模块中某个特定的属性对我们增强的代码是可用的。
- en: Tight augmentation of ImagesInc_GlobalData
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImagesInc_GlobalData的紧密增强
- en: Consider our augmenting code for `ImagesInc_GlobalData` module from the previous
    section, when loose augmentation was being used. As mentioned previously, since
    we are passing a reference to `ImagesInc_GlobalData` or an empty anonymous object
    into our IIFE, we can load our original module and our augmenting code in any
    order that we like.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上一节中用于`ImagesInc_GlobalData`模块的增强代码，当时正在使用松散增强。如前所述，由于我们将`ImagesInc_GlobalData`或一个空的匿名对象传递到我们的IIFE中，我们可以以我们喜欢的任何顺序加载我们的原始模块和增强代码。
- en: 'This was shown as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, this also means that if we wanted to override one of the original module's
    properties, depending on what code gets loaded and executed first (the original
    module or the augmenting code), our "override" might be overridden by another
    piece of code, unintentionally and unexpectedly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着，如果我们想覆盖原始模块的一个属性，这取决于什么代码先被加载和执行（原始模块或增强代码），我们的“覆盖”可能会被另一段代码无意中意外地覆盖。
- en: 'To understand this better, let''s create another file, `Modules_3.js`, and
    add the following code to it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们创建另一个文件，`Modules_3.js`，并将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, let''s load this file in our application as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们按照以下方式在我们的应用程序中加载此文件：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we are loading two files (`Modules_3.js` and `Modules_2.js`), which augment
    our original module. `Modules_2.js` is being loaded before `Modules.js`, but `Modules_3.js`
    can be loaded in any order since we are using the `async` property on the `<script>`
    tag for this file. This property tells the browser to load the file in any order
    that it can.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在加载两个文件（`Modules_3.js`和`Modules_2.js`），它们增强了我们的原始模块。`Modules_2.js`在`Modules.js`之前被加载，但`Modules_3.js`可以以任何顺序加载，因为我们为这个文件使用了`<script>`标签上的`async`属性。这个属性告诉浏览器以它可以的任何顺序加载文件。
- en: Both of these augmenting codes add the same property, `coreModule.someText`,
    to the original module. However, depending on which code is loaded and executed
    first, only one of two pieces of text will be printed in the console.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个增强代码都向原始模块添加了相同的属性`coreModule.someText`。然而，根据哪个代码首先被加载和执行，控制台只会打印出两段文本中的一段。
- en: 'We can test this by executing the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下代码来测试这一点：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The console will display one of the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将显示以下之一：
- en: '**this is a test for module augmentation** (from `Modules_2.js`)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这是一个模块增强的测试**（来自`Modules_2.js`）'
- en: '**this is a test for overriding module properties with loose augmentation**
    (from `Modules_3.js`)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这是一个使用松散增强覆盖模块属性的测试**（来自`Modules_3.js`）'
- en: Keep in mind that in this scenario, we have no control over which one of the
    strings will be the value of the `coreModule.someText` property after all the
    code execution is completed. This is because we don't know which augmenter code
    will be loaded and executed last. This also means that by using loose augmentation
    technique and asynchronous loading, augmenter code precedence is determined dynamically
    at runtime and not necessarily in the order that we think or desire.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在这种情况下，我们无法控制代码执行完成后`coreModule.someText`属性将具有哪个字符串值。这是因为我们不知道哪个增强器代码将被最后加载和执行。这也意味着，通过使用松散增强技术和异步加载，增强器代码的优先级是在运行时动态确定的，而不一定是我们所认为或期望的顺序。
- en: On such basis, if our intent was that the value of `coreModule.someText` should
    be overridden by the code in `Modules_3.js`, then we could not be sure of such
    an override taking place.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，如果我们打算让`coreModule.someText`的值被`Modules_3.js`中的代码覆盖，那么我们无法确保这种覆盖会发生。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Simulating asynchronous script loading**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟异步脚本加载**'
- en: To simulate the asynchronous loading of our augmenters, you can reload the `index.html`
    page a few times in a row (from the application code accompanying this chapter).
    You'll see that the message displayed in the console may change from time to time.
    The message displayed depends on which file, `Modules_2.js` or `Modules_3.js`,
    is loaded first by the browser.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们的增强器的异步加载，您可以在应用本章节所附代码中连续几次重新加载`index.html`页面。您会看到控制台显示的消息可能会不时地发生变化。显示的消息取决于浏览器首先加载的是哪个文件，`Modules_2.js`还是`Modules_3.js`。
- en: Tight augmentation, on the other hand, guarantees the order of code execution
    and therefore how our modules get augmented. By using this technique, we can be
    sure that when a module property is overridden, it will be in the order that we
    intended and the result will be as expected.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，紧密增强保证了代码执行的顺序，因此我们的模块是如何被增强的。通过使用这种技术，我们可以确信当模块属性被覆盖时，它将按照我们期望的顺序进行，结果将符合预期。
- en: This guarantee is provided by the fact that we don't have any choice but to
    load our module and its augmenting code in the correct order, otherwise a code
    execution error will be generated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保证是由于我们没有选择，只能按正确的顺序加载我们的模块及其增强代码，否则将生成代码执行错误。
- en: 'Let''s examine this by modifying the code in our `Moduels_3.js` as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改`Moduels_3.js`中的代码来检查这一点：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this version of the augmenting code, we are no longer passing in a reference
    to an empty anonymous object to our IIFE. Therefore, if `ImagesInc_GlobalData`
    module has not been already loaded, we cannot augment it with any new properties.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的增强代码中，我们不再向IIFE传递一个空匿名对象的引用。因此，如果`ImagesInc_GlobalData`模块尚未被加载，我们无法使用任何新属性对其进行增强。
- en: Note that at the start of the preceding code we are checking to see whether
    `coreModule` exists, and if not we are using our `ImagesInc_LoggingHandler` module
    to log an error to the console. We are also using an alert box in the browser
    to make sure that the situation really catches the user's attention (try not to
    use alert boxes in production code as it looks unprofessional; I'm just using
    it here for ease of demonstration).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面代码的开始处，我们正在检查`coreModule`是否存在，如果不存在，我们使用我们的`ImagesInc_LoggingHandler`模块将错误记录到控制台。我们还在浏览器中使用一个警告框来确保情况确实引起了用户的注意（在生产代码中尽量不要使用警告框，因为它看起来不够专业；我只是在演示时使用它以便于展示）。
- en: Loading ImagesInc_GlobalData augmenting code
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载`ImagesInc_GlobalData`增强代码
- en: 'To examine how tight augmentation enforces a set order of script loading and
    code execution, we can change our `index.html` as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查紧密增强如何强制执行脚本加载和代码执行的顺序，我们可以按以下方式更改我们的`index.html`：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we are no longer loading the `Modules_3.js` file asynchronously
    and it will be the first module-related file that gets loaded. Considering that
    we have modified the augmenting code in this file to only augment the module when
    the module (`ImagesInc_GlobalData`) is already present in the global scope, an
    error message will be logged and an **alert box** will be displayed in the browser
    when we load the page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们不再异步加载`Modules_3.js`文件，它将成为第一个被加载的模块相关文件。考虑到我们已修改此文件中的增强代码，使其仅在模块（`ImagesInc_GlobalData`）已存在于全局作用域时增强模块，当我们加载页面时，将记录错误消息并在浏览器中显示一个**警告框**。
- en: Because we are using the tight augmentation technique now, we need to load this
    augmenting code after either `Modules.js` or `Modules_2.js`. This is necessary
    so we can be sure that the `ImagesInc_GlobalData` module (object) is already present
    in the global scope.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在使用的是紧密增强技术，我们需要在`Modules.js`或`Modules_2.js`之后加载这个增强代码。这是必要的，这样我们就可以确保`ImagesInc_GlobalData`模块（对象）已经存在于全局作用域中。
- en: 'Also, since our intention is to override the value of `someText` by using the
    code in `Modules_3.js`, and this property was added to the module by the augmenting
    code in `Modules_2.js`, we need to load both `Modules.js` and `Modules_2.js` first.
    This is the only way we can guarantee that an override of the value of `someText`
    is taking place as intended.Therefore, to achieve the proper override, we need
    to modify the loading order of our scripts as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们的意图是使用`Modules_3.js`中的代码覆盖`someText`的值，而这个属性是由`Modules_2.js`中的增强代码添加到模块中的，因此我们需要首先加载`Modules.js`和`Modules_2.js`。这是唯一能够保证`someText`的值按预期被覆盖的方法。因此，为了实现适当的覆盖，我们需要按照以下方式修改脚本的加载顺序：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This rearrangement of the order of scripts in our `index.html` file ensures
    that the override of the value of the `someText` property for the module will
    produce the expected result. This is of course, because our original module is
    loaded first, then it is augmented with the `someText` property, using the augmenting
    code in `Modules_2.js`. At the end, the value of this property is overridden by
    the tight augmenting code in `Module_3.js`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`index.html`文件中对脚本顺序的这种重新排列确保了覆盖模块的`someText`属性值将产生预期的结果。这当然是因为我们的原始模块首先被加载，然后使用`Modules_2.js`中的增强代码添加`someText`属性，最后，该属性的值被`Module_3.js`中的紧密增强代码覆盖。
- en: Considerations in tight augmentation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧密增强的注意事项
- en: At the beginning of this section, I mentioned that there are a couple of considerations
    regarding tight augmentation that we need to keep in mind.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我提到有几个关于紧密增强的注意事项我们需要记住。
- en: First, we do not really need to create a global variable to store the returned
    value from the augmenting code that implements the tight augmentation technique.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实际上并不需要创建一个全局变量来存储实现紧密增强技术的增强代码返回的值。
- en: 'This is so since this type of augmentation can only take place if the module
    already exists in the global context. In fact, the following code will work just
    as well as the previous version:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这种增强只能在模块已经存在于全局上下文的情况下发生。实际上，以下代码将和之前的版本一样工作得很好：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Second, before we override a property that already exists in the module, we
    can preserve the original value of the property by storing it in another property.
    This allows us to have access to both the original value of the property and its
    overridden value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在我们覆盖模块中已经存在的属性之前，我们可以通过将其存储在另一个属性中来保留属性的原始值。这使我们能够访问属性的原始值和覆盖值。
- en: 'Let''s do that in our `Modules_3.js` file, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Modules_3.js`文件中这样做，如下所示：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can get the original value of the `someText` property by running the following
    in the console:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制台中运行以下代码来获取`someText`属性的原始值：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, not only tight augmentation technique is a nice way to override
    our module properties, it also allows us to hold on to the original (previous)
    values of our properties, in case we ever need to use them again.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，不仅紧密增强技术是一种覆盖我们模块属性的好方法，它还允许我们保留我们属性的原始（先前）值，以防我们以后需要再次使用它们。
- en: Generating our application's content area
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成我们应用程序的内容区域
- en: If you have read the previous sections of this chapter, you have a pretty good
    grasp of what module augmentation is by now. You also know of a couple of techniques
    to add dynamic properties to our modules using augmentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了本章的前几节，你现在对模块增强应该有相当好的理解。你也知道一些使用增强技术向我们的模块添加动态属性的技术。
- en: As it stands, our application (`Images Inc.`) has code that dynamically generates
    the header and footer sections of our pages. But we still have an empty space
    in the middle (the content area), which needs to be populated with content.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序（`Images Inc.`）有代码可以动态生成我们页面头部和尾部部分。但中间仍然有一个空白区域（内容区域），需要填充内容。
- en: Let's put the techniques that we have learned in this chapter to good use and
    add functionality to our application that will generate the content area dynamically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们充分利用本章学到的技术，并为我们的应用程序添加动态生成内容区域的功能。
- en: 'Note that the refactored augmenting code in `Modules_3.js` is now as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Modules_3.js`中的重构增强代码现在如下所示：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A few things have happened here. As you can see, we are using tight augmentation
    to augment our `ImagesInc_GlobalData` module. We have also created a new property
    for this module, `originalModule.mainContentContainerDef`, which holds the object
    definition for the content area of the page. Since the content area uses a repeated
    structure of rectangles to display the desired images on the page, we have used
    an inner IIFE, which creates that structure and stores it in `sectionHTML` property
    of the content area object definition as a string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些事情。正如你所看到的，我们正在使用紧密增强来增强我们的`ImagesInc_GlobalData`模块。我们还为这个模块创建了一个新属性，`originalModule.mainContentContainerDef`，它包含页面内容区域的对象定义。由于内容区域使用重复的矩形结构来显示页面上的所需图像，我们使用了一个内部立即执行的函数表达式（IIFE），它创建了这个结构并将其存储在内容区域对象定义的`sectionHTML`属性中，作为一个字符串。
- en: In order for the external code to have access to this string, and to be able
    to render the content area of our `index.html` page, we have created `originalModule.getContentAreaHTMLTxt`
    method. This is added as an interface to our original `ImagesInc_GlobalData` module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让外部代码能够访问这个字符串，并能够渲染我们`index.html`页面的内容区域，我们创建了`originalModule.getContentAreaHTMLTxt`方法。这个方法被添加为我们的原始`ImagesInc_GlobalData`模块的接口。
- en: 'When we load the application''s `index.html` page now, it is displayed as shown
    here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在加载应用程序的`index.html`页面时，它显示如下：
- en: '![Generating our application''s content area](img/B04910_05_01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![生成我们应用程序的内容区域](img/B04910_05_01.jpg)'
- en: Of course, for the time being, I'm using the previous color coding schema that
    you have seen before for our various page fragments. For ease of identification,
    the image boxes are shown in pink (if you are reading the book in color).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，目前我还在使用之前看到的颜色编码方案来为我们的各种页面片段着色。为了便于识别，图像框显示为粉色（如果你是在彩色书中阅读）。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A caveat to keep in mind**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要注意的一个警告**'
- en: In our augmenting code, we added the `mainContentContainerDef` property to our
    module without using a closure. Therefore, this property is not implemented with
    the same type of encapsulation and private access as `headerContainerDef` and
    `footerContainerDef`. These properties were defined in our original module as
    private variables, and access to them was only possible through the interfaces
    that we created for external use. Of course, we created that private access using
    a closure.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的增强代码中，我们没有使用闭包，就在我们的模块中添加了`mainContentContainerDef`属性。因此，这个属性没有使用与`headerContainerDef`和`footerContainerDef`相同的封装和私有访问类型。这些属性在我们的原始模块中定义为私有变量，并且只能通过我们为外部使用创建的接口来访问。当然，我们使用闭包创建了这种私有访问。
- en: If you'd like to restrict access to them in your modules, it is best to define
    the properties in the original modules (using closures) as opposed to adding them
    to the modules using the augmentation techniques (unless you use closures in your
    augmenting code too).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望限制模块对这些内容的访问，最好在原始模块中定义属性（使用闭包），而不是使用增强技术将它们添加到模块中（除非你在增强代码中也使用闭包）。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered what module augmentation is and explored a couple
    of different techniques, known as loose augmentation and tight augmentation, to
    implement module augmentation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了模块增强是什么，并探讨了几个不同的技术，称为松散增强和紧密增强，来实现模块增强。
- en: We saw how each approach is used in different circumstances and for different
    application requirements, as well as the pros and cons related to each technique.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了每种方法在不同情况下以及针对不同应用需求的使用方式，以及与每种技术相关的优缺点。
- en: The order in which scripts should be loaded was also discussed, based on the
    augmentation technique used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所使用的增强技术，还讨论了脚本应加载的顺序。
- en: Once we had a good grasp of these augmentation implementations, we refactored
    part of our application code to augment `ImagesInc_GlobalData` module. Subsequently,
    we generated the content area of `index.html` page and populated it with containers,
    which will host the images for our application in the future.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们很好地掌握了这些增强实现，我们就重构了我们应用程序代码的一部分，以增强`ImagesInc_GlobalData`模块。随后，我们生成了`index.html`页面的内容区域，并用容器填充它，这些容器将未来托管我们应用程序中的图像。
- en: In the next chapter, we will look at some more techniques in modular design
    which will enable us to extend and clone our modules as needed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些模块化设计中的更多技术，这些技术将使我们能够根据需要扩展和克隆我们的模块。
