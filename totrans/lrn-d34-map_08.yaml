- en: Drawing with Canvas and D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far you have used D3 to render your visualizations with mostly SVG, and sometimes
    HTML, elements. In this section, you will learn how to use HTML5 Canvas to draw
    and animate your visualizations. Canvas can be used as an alternative to SVG,
    especially if you want to render more elements on screen. You will get an overview
    of what Canvas is and how it compares with SVG. You will learn how to draw and
    animate with Canvas and how you can use D3 with it.
  prefs: []
  type: TYPE_NORMAL
- en: After covering the foundations, we will visualize flight paths first with SVG
    and then with Canvas to contrast and compare the two rendering approaches hands
    on. First and foremost, this will give you a practical understanding of how Canvas
    works as an alternative to SVG. Secondly, it will showcase how Canvas can solve
    problems you might have when animating thousands of points at once with SVG, as
    browsers are significantly faster in drawing a single picture of thousands of
    elements than in building, storing, and maintaining a tree of thousands of elements
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overview of Canvas and its tools: the Canvas context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the tools to draw with Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to animate a drawing with Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply the D3 life cycle to individual parts of the Canvas drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start to draw with Canvas, let's have a brief look at its concept
    – the mental model that will help you approach, plan, and write your applications.
    Canvas in its material form is a single HTML5 element. It is literally a blank
    canvas that you can draw on. For the actual drawing, you use the **Canvas context**
    – the Canvas API. The context can be thought of as your toolbox that can be manipulated
    with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare the Canvas element with the root SVG element, as both contain
    all parts of the drawing. However, the key difference is that SVG (like HTML)
    operates in **retained mode**. The browser retains a list of all objects drawn
    onto the SVG (or HTML) canvas within the **Document Object Model** (**DOM**) –
    the scene-graph of your web application. This makes your drawing almost material.
    You produce a list of objects, change styles and properties through code, and
    you can refer to these elements any time you desire. You can change their position,
    move them up or down the DOM and – very important for interaction – you can attach
    and remove event listeners to them easily.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas, in contrast, operates in **immediate mode**. Anything you draw using
    Canvas occurs at once and remains on the canvas as an image. Images in Canvas
    are bitmaps, digital images composed of a matrix or grid of pixels. When you draw
    with Canvas you prepare the properties of each pixel (or rather specified regions
    of pixels) with your tools and then draw them on the canvas. If you want to change
    the color of one, a few, or all pixels on your image, you remove the whole image
    and produce a new image. Unlike SVG, you can't go back to the pixel you want to
    change, as it is not represented in memory in the form of a document tree or the
    like, but *burned* just once onto the screen. But fear not, you still have the
    Canvas context that represents the state of your tools, which indirectly represents
    the drawing itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of Canvas as a painting and SVG or HTML as a Lego structure.
    The former is static in its representation. If you paint a man standing on a bridge
    screaming, you can''t just turn his head around. You would have to draw a second
    painting to express this precisely. If you built the same scene with Lego, you
    could grab the head and turn it around, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18ca93ab-fcee-496c-9982-eddcfde75bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: A dramatization of the immediate Canvas and the retained SVG  (SVG Image courtesy
    of Marco Pece www.udronotto.it)
  prefs: []
  type: TYPE_NORMAL
- en: This might sound cumbersome, considering the potential work that has to go into
    animating with Canvas. Not just the mental strain of having to paint so many pictures,
    but the computational powers required to redraw everything in quick succession.
    But, as you will see in the coming sections, there are simple patterns that make
    Canvas animated and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we come back to a more thorough comparison of SVG and Canvas and see
    concrete scenarios of when to use what, let's learn to draw with Canvas. We will
    start with a very simple example to understand the three main steps involved when
    drawing with Canvas. Then you will draw a set of shapes to get used to its toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, when working along and viewing the code examples, I highly recommend
    you use a recent Chrome browser. All code is tested across modern browsers but
    has been written with Chrome in mind, which therefore will be the safest browser
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: The three drawing steps of every Canvas visual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can deconstruct a Canvas drawing into three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create** the canvas and its context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure** the context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Render** the resulting bitmap.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To mount the canvas within your DOM you create a `<canvas>` element in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It will look empty, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fbdd403-bb07-4971-9b23-ae025dadf1e0.png)'
  prefs: []
  type: TYPE_IMG
- en: An empty Canvas element
  prefs: []
  type: TYPE_NORMAL
- en: This will be all the DOM you will see of your canvas. All other operations will
    happen via the Canvas context in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to draw a rectangle in, say, `royalblue`, you would move onto
    JavaScript without looking back to the HTML and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can find all code to this chapter at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through our first steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you reference the canvas in a variable. We''ll use `d3.select()` to
    do so. As you will need a reference to the canvas element itself, not a selection,
    you should use D3''s `selection.node()` method to grab the element itself. The
    next line references the drawing context to this specific canvas element. The
    context includes all the tools you can use to draw. You can `console.log(‘context'')`
    to have a look at the context object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25d94e62-a290-404d-9f71-8eadfc083561.png)'
  prefs: []
  type: TYPE_IMG
- en: The context object showing all properties
  prefs: []
  type: TYPE_NORMAL
- en: The context is called `CanvasRenderingContext2D` internally, but we will refer
    to it just as `context`. It holds all the properties you can manipulate to draw
    your visual. If you feel inclined you can also expand the `__proto__` object,
    which will show all methods available to you. We'll explain the key properties
    and methods as we go without diving into each individually. The important point
    of the context object is to understand that there's an object helping you to build
    your drawing. It stays at your side all along allowing you to use its methods
    and change its properties.
  prefs: []
  type: TYPE_NORMAL
- en: A great place to learn more about the context API, its properties, and methods
    is the documentation on the Mozilla Developer Network at [https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have the canvas to draw on and the drawing tools, but you
    still haven't drawn anything.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step you prepare the drawing. You configure the context to produce
    the desired drawing. The example is purposefully simple in that the only configuration
    is to set the fill of our yet non-existent object to `royalblue`. Note that `context.fillStyle`
    is a property, not a method, of the Canvas context. It's like you are a painter
    telling your brush box what color you want to use for the object you paint next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This third step produces the following image. `context.fillRect()` takes four
    arguments: the *x* and the *y* position of the rectangle''s starting point as
    well as the `width` and the `height`. Canvas – like SVG – uses a Cartesian co-ordinate
    system with the origin 0, 0 at the top-left corner increasing to the right and
    to the bottom. All values are given in pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2a012ff-fec0-4d76-8143-815ef901f406.png)'
  prefs: []
  type: TYPE_IMG
- en: A very royal blue Canvas rectangle
  prefs: []
  type: TYPE_NORMAL
- en: This rectangle is not present in the DOM. You can see its configuration in JavaSript
    and the canvas its drawn to in the DOM, but there's no `<rect>` element or the
    like we could refer to. Again, don't grow worry lines; we will get clever about
    how to re-address it in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-1](https://larsvers.github.io/learning-d3-mapping-8-1). Code
    example [08_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_01.html).'
  prefs: []
  type: TYPE_NORMAL
- en: At the conclusion of each step you will find two links in an info box close
    to the the relevant image. The first link brings you to a working implementation
    of this step that you can view in the browser. The second *code example* link
    brings you to the full code. If you're reading the print version, you can find
    all code examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping) in
    their relevant chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen the basic steps to follow when producing pretty much any drawing
    with Canvas. These key conceptual steps will help you to approach any Canvas drawing.
    Now let's draw more.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing various shapes with Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some other basic geometric shapes or **graphical primitives** to
    our canvas. As they are the building blocks of all the visuals you draw, some
    exercise will do us good. Here''s what we will draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81bb3ffd-9c3a-4763-9265-ea6a6909eb7e.png)'
  prefs: []
  type: TYPE_IMG
- en: A house and a tree. Or three rectangles under a triangle next to a path and
    a circle.
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-2](https://larsvers.github.io/learning-d3-mapping-8-2). Code
    example [08_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_02.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the code to the right in the JavaScript console, and before we
    step through it, let''s note some general observations. First, every line starts
    with `context`. The Canvas context is really where our drawing comes to life.
    Second, Canvas code is written in a procedural style. This can be a benefit for
    beginners, as it is linear. No callbacks, no nested element structure, just a
    straight line of execution. This linearity will also extend to time, once you
    start animating the canvas. You write the first frame first, then you change the
    scene, then you write the second frame. Flip-book simple. Let''s step through
    the code and see how to create these elements in detail. The first thing I suggest
    is giving the canvas a border. As the canvas element is an HTML element, you can
    style it with CSS, but we use JavaScript here to show off two properties of the
    canvas itself: `width` and `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `width` and `height` are the only properties the canvas element has. We
    use them here to read the values of the element, however, they are readable and
    writable. This is nice, as you can change the canvas size programmatically when
    you want to resize your canvas during animation for example. Next, we build our
    flat-roofed blue house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Not much to see here, we''ve done that previously. The door won''t make you
    sweat either, as it''s the same as the house with a different color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we use a different method to describe the color. You can use all CSS
    color concepts like named color values and hex color values, as well as the `rgb()`,
    `rgba()`, `hsl()` and `hsla()` color methods. The window is placed a little differently
    with `context.translate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we don''t move the rectangle, we move the entire coordinate system!
    The `translate()` method takes two arguments: the *x* and the *y* position you
    want to move the coordinate system by. You know this concept already from the
    use of `transform, translate(x,y)` which is often used to move `svg:g` elements
    in D3 and create their own coordinate systems. However, when applied to an `svg:g`
    element the transformed coordinate system applies to all objects nested within
    the g element. As said above, the `g` element, as well as its children, is retained
    as a scene-graph representation in the DOM, including its coordinate system. In
    Canvas, we can''t move this information off to a representation of our drawing
    – there is no such thing. It''s up to you to make sure only elements you want
    to manifest on a different coordinate system will do so. Remember above when we
    talked about the procedural style of writing Canvas code? This is exactly what
    we have to keep in mind here. When we change something in the `context` it will
    persist through our code until we change it again. To change the coordinate system
    back we could alternatively move it to our desired position and move it back afterwards
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But we rather use the generally applicable `context.save()` and `context.restore()`
    methods. The `context.save()` saves the state at this point of the code and pushes
    it onto a **stack**, and  `context.restore()` pops the last saved state off the
    stack and restores the previous state of the context.  If you haven''t come across
    stacks so far, here''s an image explaining what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55c9677b-a0a1-480e-aa9c-44ba291f5745.png)'
  prefs: []
  type: TYPE_IMG
- en: The stacked tower of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, a stack is a datatype like an array or an object. However, a stack
    is limited to two operations: adding elements on top of the stack (push) and removing
    elements from the top of the stack (pop). It''s like a brick tower. This care-taking
    of our application''s state is a defining aspect of Canvas and a key difference
    to SVG.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we give the house a triangular roof. There''s no `triangle()` function
    in Canvas, so you draw a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw the tree. A tree has a brown stem, which you implement as
    a straight path, and a green treetop, which you draw as a green circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to note here. First, all path code blocks are bracketed
    by `beginPath()` and either `stroke()` (the stem) or `fill()` (the roof and treetop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`beginPath()` signifies the intent to draw a new path and removes all current
    path (or sub-path) implementations. `stroke()` and `fill()` signify the end of
    the path and will produce the path on the screen. `fill()` will fill the path
    body with the set `fillStyle` color, and `stroke()` will only draw the path contour
    in with the set `strokeStyle()` method. Whenever you draw a path, you will need
    these start and end methods. In fact, whenever you draw anything you will need
    them. `fillRect()` or `strokeRect()`, as used previously, are just wrappers for
    beginning a path, drawing a path, and filling or stroking a path.You might have
    noticed that we only drew two sides of the triangular roof and then used `closePath()`
    which connects the current endpoint of the path with the starting point. The `fill()`
    method will also close the path for you, but making this explicit is more thorough,
    more performant and a service to the reader of your code (including yourself).
    The second thing to note is that even a circle is a path. In fact, the only primitive
    shape beyond a path offered by the Canvas API is the rectangle. SVG facilitates
    the use of `<rect>`, `<circle>`, `<ellipse>`, `<line>`, `<polyline>`, `<polygon>`,
    and `<path>`, while Canvas only offers paths and rectangles. However, drawing
    shapes with paths quickly becomes routine. While there is no pre-defined circle,
    there''s the `arc()` and `arcTo()` methods, which pretty much do the circle drawing
    for you. You just need to add color to it and wrap it into the path start and
    end methods. `arc()` takes five arguments, the *x* and the *y* position, the *radius*,
    the *start* and the *end angle* of our arc. Both angles are being measured in
    radians.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A radian? One **radian** equals *57.3* degrees. Radians are an alternative
    unit of measurement for angles. They are beloved by mathematicians as they make
    a lot of sense in geometric calculations. To get a radian, you take the radius
    of a circle and wrap it around that circle – if you can imagine that the radius
    line is bendable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53c20cea-49e6-4796-a838-b1b48daf4bd3.png)'
  prefs: []
  type: TYPE_IMG
- en: How to get a radian
  prefs: []
  type: TYPE_NORMAL
- en: Their mathematical advantage is that they can be derived directly from the radius
    of a circle. The further beauty is that half a circle (as in 180 degrees) is exactly
    one *PI* radians. Hence, a full circle equals *2 * PI* radians.
  prefs: []
  type: TYPE_NORMAL
- en: 'Degrees probably make more sense to you. That''s fine. They also make more
    sense if you want to move objects around on the screen. You can easily convert
    between radians and degrees by using the following formula: *(**PI / 180) * degrees*.
    *PI* is half a circle in radians and 180 is half a circle in degrees. By dividing
    one by the other, you express one degree in radians, which equals 0.0175\. Multiply
    any degree number you desire with 0.0175 and use the result as radians.'
  prefs: []
  type: TYPE_NORMAL
- en: OK! We've drawn a landscape with a house – that's great. There is certainly
    more to Canvas, but by following these simple steps you have learned a lot. You
    have learned about the concept of drawing with Canvas and what it means to write
    your code procedurally. You have seen how to draw individual shapes with Canvas,
    how you can move individual objects around with a translate transformation, and
    how the atomic unit of each Canvas shape is the path. Now, let's step it up and
    animate our landscape the Canvas way before we do it the D3 way.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Canvas's key advantages is animation. While the browser must work hard
    to re-calculate and re-render many elements retained in a DOM, it is relatively
    unstressed re-drawing a bitmapped image. In the following section, you will learn
    how to animate with Canvas. Let's first look at how you do it in a pure, vanilla
    Canvas way. After that, let's see if we can use D3's transition and life cycle
    Enter-Update-Exit pattern to help us animate. Both ways will be immensely helpful
    when building visualizations with D3 and Canvas as you will be able to choose
    the right technique for your own ideas or complement the two.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the Canvas way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to our house and test its roof with rain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/340c42b9-f372-4ebb-9e18-70752f326cf3.png)'
  prefs: []
  type: TYPE_IMG
- en: It's really raining.
  prefs: []
  type: TYPE_NORMAL
- en: 'View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-3](https://larsvers.github.io/learning-d3-mapping-8-3).
    Code example [08_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_03.html).'
  prefs: []
  type: TYPE_NORMAL
- en: It's hard to see in a static image, but the blue dots are in fact moving down
    when viewed in the browser. They are also moving at different speeds, which makes
    the rain look a little more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a general overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the abstracted top level our code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After setting up the canvas, you will produce some data – the raindrops. Then
    you will enter a loop within which you will update the data for the next scene
    and then draw it. In our case, `update()` changes the raindrops' positions and `animate()`
    will clear the current image and draw a new image with the updated raindrop positions.
  prefs: []
  type: TYPE_NORMAL
- en: This loop (or at least a very similar incarnation) is called the **game loop**,
    as it is used in game programming with Canvas. You process the gamer's input,
    update the game data accordingly, and draw the new scene. We will get used to
    this pattern quickly. Now, let's look at the details.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the rain data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The elements you''re dealing with are raindrops. Before we update or animate
    a single raindrop, we produce them. We''re building out a so called *object literal
    module* called `rain`  (it''s an *object literal*) that knows how to produce raindrops
    and that keeps the individual drops save in an array called `items`. It will look
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `rain` object consists of this as yet empty array `items` that will hold
    all the raindrop objects we produce and a variable called `maxDrops`, confining
    the number of raindrops (the length of `items`) to 200 in this case. This can
    be considered light rain. Crank this up to a higher number if you want to drown
    the tree or test the app's performance. As we like the tree and shall test performance
    in an example to come, 200 will do for now.
  prefs: []
  type: TYPE_NORMAL
- en: Two functions will help to produce and update the drops. `getDrop()` assigns
    start positions out of sight above the canvas, as well as empty `x` and `y` positions
    which will be filled on update. You also define the speed of the drop, which can
    take on values between five and seven. The speed will be the number of pixels
    the raindrop will move forward on each update. A low number will produce slow
    rain and a higher number will produce fast rain.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateDrop()` function can be called in case we, well, want to update a
    drop's position. Let's do this now.
  prefs: []
  type: TYPE_NORMAL
- en: Updating each drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The site loads and things will kick off with the `d3.interval` function, which
    calls all functions it embraces every 10 milliseconds. First, it will call `update()`
    which returns an array of objects. Each object is a drop most notably characterized
    by an arbitrary `x` and `y` position. This is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first time `update()` is called it produces a drop, updates its position,
    and pushes it into the rain items array. Any other time, it just updates the drop's
    position. We use `d3.range` as a convenient method for this loop. It takes an
    integer as input and returns an array of integers starting at 0, and the length
    of the number you pass in. Here it helps create as many rain drops as we specified
    in `maxDrops`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then update the drop''s position with the `updateDrop()` function we started
    to describe previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the drop's `x` and `y` positions don't exist yet (if they are `null`) we
    assign the `xStart` or `yStart` values to it. If not, we leave the `x` position
    where it is as no drop will move to any side, and we move the `y` position downwards
    by speed. This will make the drop move down between five and seven pixels every
    10 milliseconds. The last line recycles each drop. Once it has reached the final
    border of the bottom canvas, we just set its `y` value to the initial `yStart`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing frame by frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in our `d3.interval` loop, `update()` has run and we have the positions
    of all our raindrops. Next, we will deal with drawing them. If we had a DOM, we
    would interact with our omnipresent 200 SVG circles and ask them kindly to move
    down a little. But we produce a static image and we can only draw and not change.
    So, we draw. Like in a flip book we dispose of the old image and draw a new one.
    Let's repeat this. Each time we want to move something on the canvas we **remove**
    **the old image** and **draw a new image** with changed positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`animate()` uses the context''s own `clearRect()` function, which does what
    it says on the tin. You pass it the area you want to clear – in our case the entire
    canvas – and it will clear it. You can also fill a white rectangle or change the
    `canvas.width` and `canvas.height` values, but `clearRect()` is faster than the
    first and clearer than the second method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you run the `drawScene()` function, which draws our scene: the house
    and the tree. It''s what you built in the previous section, just wrapped up in
    an aptly-named function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we draw each drop to the canvas. What is `circle()` you ask? It''s
    a helper function to build visual primitives – in our case a circle. It has been
    added at the top of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The two main functions `update()` and `animate()` are being run repeatedly until
    the end of your browser tab's session; which could mean bad weather for some time.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas and D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3 offers unmatched functionality for producing data visualizations on the web.
    You might be aware of this, reading this very book. One important part of what
    D3 offers is its model for how data-infused elements evolve on the screen. It
    has a certain way of thinking about the life cycle of each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you inject data into a yet non-existent DOM, and D3 creates new
    elements of your choice as per the data you inject, usually one element per data
    point. If you want to inject new data into the DOM you can do so and D3 identifies
    which elements have to be newly created, which elements are allowed to stay, and
    which elements should pack up and leave the screen. This way you can represent
    three distinct states of a common data-flow: **entering** data, **updating** data,
    and **exiting** data. You can then grab these selections, manipulate their visual
    properties as well as transition between them with D3''s built-in interpolators,
    leveraged by `d3.transition()`.'
  prefs: []
  type: TYPE_NORMAL
- en: This plays well with the retained SVG elements that are manifested in the DOM.
    However, we have no DOM elements in the canvas and must, therefore, be a little
    clever about producing them. Let's see how we can follow D3's life cycle model
    as well as using D3's transitions to interpolate between these three states.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of our experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will still let it rain over our little house and its tree, but now the rain
    will follow its natural course – the rain''s life cycle, as it were. It will **Enter**
    in the form of a cloud, it will **Update** as the rain moving into a big puddle
    on the ground, and it will **Exit** turning the puddle into a lush patch of grass:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/b3ca6039-2d84-45f6-bd58-393a6cb80d34.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Enter, Update and Exit the rain
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-4b](https://larsvers.github.io/learning-d3-mapping-8-4b).
    Code example [08_04b.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04b.html).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are buttons to the right allowing you to control the three
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the code will be similar to the previous pure Canvas animation.
    Conceptually, you calculate the elements' (the raindrops') positions first and
    then draw. However, the way we achieve this interaction is entirely via D3\. To
    lift the lid in advance, you will bind the data to virtual DOM elements. These
    DOM elements are ‘virtual'. As Canvas has no DOM, you create a basic DOM structure
    in memory, with which we can use D3's selections, the data join, and consequently
    the Enter-Update-Exit API. Additionally, the app will have button interactions
    to change the elements' state according to the changed data. We have discussed
    the Canvas setup as well as data preparation already, so let's focus on the core
    novelty of this section, the databind and the draw!
  prefs: []
  type: TYPE_NORMAL
- en: The data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having said that, we should have a brief look at the data we will produce with
    a function called `getRainData()`. It will give us 2,500 raindrops (heavy rain
    this time) that look a little different to our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4cc465b-c0ab-408e-8d50-5d1e0aee1ea2.png)'
  prefs: []
  type: TYPE_IMG
- en: A raindrop the Vanilla Canvas way versus a raindrop the D3-and-Canvas way
  prefs: []
  type: TYPE_NORMAL
- en: The key differences are that you don't need the speed for the D3 raindrop version,
    as we plan for D3's transition to implement the animation. Further, the **D3 and
    Canvas** raindrop has properties for a set of states included, while the **Vanilla
    Canvas** raindrop only has start and current positions.
  prefs: []
  type: TYPE_NORMAL
- en: Updating each drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the data in place, it's now time to make it move. In the pure Canvas example,
    you drew each point on the canvas, then calculated new points adding five pixels
    to the previous point's position, removed the old image, and drew the new one
    with the advanced drops. You transitioned the points yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Employing D3''s transition methods differs in that we won''t calculate the
    new position, but D3 will do it for us. You will bind the data to selections,
    ask D3 to transition the values, and while it transitions you will redraw the
    canvas for as long as the transition runs. On a top level, you only need two functions
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, D3 implements transitions on selections, and we don''t have selections
    yet. A single D3 selection is an element with bound data. With D3 you select a
    DOM element, usually SVG, join data to it, and you have a selection with all its
    wondrous methods: the explicit `enter()` and `exit()` methods, the implicit `update()`
    method triggered by `data()`, as well as `transition()` and their helpers `duration()`
    and `delay()` that control the transition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create selections, you just create DOM-like elements, and the great thing
    is, you don''t need the incarnated DOM to do so. You can create them in memory.
    Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can imagine `customBase` as a replacement of a root SVG element and `custom`
    to be a fully-fledged D3 selection. With your foundation in place you can go about
    the usual D3 business of binding data to your custom elements with the `databind()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we join the data passed into the `databind()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The key function passed in as the second argument to `data` isn't strictly necessary
    in this case, but is good practice as it makes the join unambiguous and can have
    performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you create your selection states. The `enter` selection is first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things of note about the two bottom lines setting the `fillStyle`
    attribute. When you work with SVG the last line would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But with Canvas you use `.attr()`. Why? Your main interest here is to find a
    pain-free way to transfer some element-specific information. Here you want to
    transfer a color string from the `databind()` to the `draw()` function. You use
    the element simply as a vessel to transport your data over to where it is being
    rendered to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a very important distinction: when working with SVG or HTML you can
    bind data to elements and draw or apply styles to the elements in one step. In
    Canvas, you need two steps. First, you bind the data then you draw the data. You
    can''t style the elements while binding. They only exist in memory and Canvas
    can''t be styled via CSS style properties, which is exactly what you access when
    using `.style()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at how the `customBase` element looks after we''ve
    created and appended the `enter` selection to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/090c66aa-0950-42d4-bdb3-be14185c7b10.png)'
  prefs: []
  type: TYPE_IMG
- en: Our custom root element showing 30 of our raindrops in enter-state
  prefs: []
  type: TYPE_NORMAL
- en: Looks familiar in structure, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you define the `update` selection, and finally the `exit` selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's all that goes into `databind()`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you need to write the `draw()` function to get the elements on screen. Let's
    just note here that nothing has happened yet. You haven't called `databind()` yet
    because you need to find a way to draw it to the canvas first. So, off we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `draw()` function takes the context you want to draw on as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It clears the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It draws the background scene, including the house and tree, as well as a cloud
    and a puddle drawn in `drawRainScene()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It loops through each of our virtual elements to draw it according to the attributes
    we specified in `databind()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! You can close the `draw()` function.
  prefs: []
  type: TYPE_NORMAL
- en: See the line `ctx.globalCompositeOperation = 'source-atop'`? The `globalCompositeOperation`
    allows us to fuse or blend-in shapes. It operates on a source shape, the shape
    we are about to draw, and a destination, the Canvas content *underneath* the source
    shape. You can apply a number of compositing effects, but we use `source-atop`
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Check [https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation)
    for all composite options.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the new shape is only drawn where it overlaps the existing canvas
    content. The shape will not be visible in canvas regions without any drawings.
    This is why we need all objects in `drawRainScene()`. They form the background
    to our raindrops which they can't escape. By the way, if you don't want to draw
    all complex shapes by hand, you can draw them with vector graphics software such
    as Illustrator, save them as SVG, and use apps such as the *SVG to HTML5 Canvas
    converter* at [http://www.professorcloud.com/svg-to-canvas/](http://www.professorcloud.com/svg-to-canvas/)
    to convert SVG paths into Canvas commands.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, no raindrop has shown itself, but you have the background scene in
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14a09a8a-eb4b-4e99-a3ea-2a0aafece9ba.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial scene
  prefs: []
  type: TYPE_NORMAL
- en: 'You have the means to animate the life cycle with the `databind()` and the
    `draw()` functions. You just call them in a sequence and wire this call-up with
    the buttons. Let''s play this through for the Enter case. The cloud is empty and
    we want raindrops to transition into play from 0 to 0.2 opacity, that''s how we
    specified it in the `databind()` function. We could just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will join the data to the custom elements and, as all elements are joined
    with new data, draw the enter selection – once! But we need to display the transition,
    so we need to draw repeatedly while the transition is happening. You achieve this
    with a continuous loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we bind the incoming data to our custom elements. Then we draw repeatedly.
    `d3.timer()` calls its callback repeatedly until you tell it to stop. The callback
    takes an argument we call `elapsed` here, which is the time in milliseconds the
    timer is running. The `draw()` function will be run many times drawing the background
    scene as well as each raindrop. At the same time a transition is running within
    `databind()`, changing each raindrop''s position slightly. The `draw()` function
    will pick up these slight position changes as it loops through each raindrop every
    time it''s called, drawing the raindrop at the very position the transition in `databind()`
    sets it to at this given moment. You can think of it as two processes happening
    at the same time: the transition in `databind()` delivering new raindrop positions
    and the repeated canvas drawing in `draw()` removing the previous canvas and drawing
    these new raindrop positions.'
  prefs: []
  type: TYPE_NORMAL
- en: After the transition is done, we want to stop the timer. Work done. The transition
    in `databind()` runs for 2000 milliseconds, as we set it in the `dur` variable.
    We shall use `dur` now to clear up after us. We can stop any timer from within
    calling the timer's `.stop()`-method. To be safe we call `t.stop()` after we're
    passed double our duration `dur` (*4000* milliseconds) to cater for delayed transitions.
  prefs: []
  type: TYPE_NORMAL
- en: This is how a D3 transition works in Canvas. You call the drawing function more
    or less parallel to the binding function repeatedly Whatever style or position
    properties your D3 elements are set up to transition (*x*, *y*, *color*, *width*,
    *height*, for example.), they will be re-drawn many times with small incremental
    changes for each draw.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it up to the buttons is a formality. Just wrap the `databind()` and `draw()`
    functions into a function (we shall call it `rainAnimation()`) that passes in
    the `raindata` when the enter or update button is pressed and an empty array when
    the exit button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The rain cloud will appear on the screen upon hitting the Enter button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fa57f3c-d8cf-4b3b-8c49-f520e046a311.png)'
  prefs: []
  type: TYPE_IMG
- en: Enter rain into cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'The Update button will update the rain''s position from the cloud to a puddle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b81b6df5-fb62-4bf2-a7c9-a47934e6fc74.png)'
  prefs: []
  type: TYPE_IMG
- en: Update rain to the ground
  prefs: []
  type: TYPE_NORMAL
- en: 'The Exit button will finally turn the rain into grass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ba74abc-fe1f-4eb9-a36d-3a9c06b8a475.png)'
  prefs: []
  type: TYPE_IMG
- en: Exit the rain to become grass
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-4a](https://larsvers.github.io/learning-d3-mapping-8-4a).
    Code example [08_04a.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04a.html).
  prefs: []
  type: TYPE_NORMAL
- en: A natural D3 life cycle demonstration!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've come a long way. You've learned how to draw with Canvas, how to animate
    the canvas in a pure Canvas way, as well as how to use D3 transitions and the
    Enter-Update-Exit pattern with Canvas. While the Vanilla Canvas way is perfectly
    reasonable for a great many applications, D3 offers seasoned functionality for
    data visualization you don't have to abandon. It requires a shift in thinking
    when building your application, but it can pay out specifically for drawing and
    animating a large number of points. It will expand your toolbox in a valuable
    way, especially at times where abundant data might require element-heavy representations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review a map visualization in SVG and then build
    one in Canvas. By doing so, you will not only be able to apply the learnings from
    this chapter, but you will also learn more about the differences and similarities
    between the two approaches, how Canvas can help with performance bottlenecks,
    and how D3 can help with some heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get to it!
  prefs: []
  type: TYPE_NORMAL
