- en: Drawing with Canvas and D3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Canvas 和 D3 绘图
- en: So far you have used D3 to render your visualizations with mostly SVG, and sometimes
    HTML, elements. In this section, you will learn how to use HTML5 Canvas to draw
    and animate your visualizations. Canvas can be used as an alternative to SVG,
    especially if you want to render more elements on screen. You will get an overview
    of what Canvas is and how it compares with SVG. You will learn how to draw and
    animate with Canvas and how you can use D3 with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您主要使用 D3 通过 SVG 和 HTML 元素来渲染您的可视化。在本节中，您将学习如何使用 HTML5 Canvas 来绘制和动画化您的可视化。Canvas
    可以作为 SVG 的替代品，尤其是在您想在屏幕上渲染更多元素时。您将了解 Canvas 是什么以及它与 SVG 的比较。您将学习如何使用 Canvas 绘制和动画化，以及如何与
    D3 一起使用。
- en: After covering the foundations, we will visualize flight paths first with SVG
    and then with Canvas to contrast and compare the two rendering approaches hands
    on. First and foremost, this will give you a practical understanding of how Canvas
    works as an alternative to SVG. Secondly, it will showcase how Canvas can solve
    problems you might have when animating thousands of points at once with SVG, as
    browsers are significantly faster in drawing a single picture of thousands of
    elements than in building, storing, and maintaining a tree of thousands of elements
    in memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了基础知识之后，我们将首先使用 SVG，然后使用 Canvas 来可视化飞行路径，以便实际对比和比较两种渲染方法。首先，这将让您对 Canvas
    作为 SVG 的替代品有实际的理解。其次，它将展示 Canvas 如何解决您在用 SVG 同时动画化数千个点时可能遇到的问题，因为浏览器在绘制数千个元素的单一图片方面比在内存中构建、存储和维护数千个元素的树结构要快得多。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: 'Overview of Canvas and its tools: the Canvas context'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas 及其工具概述：Canvas 上下文
- en: How to use the tools to draw with Canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用工具绘制 Canvas
- en: How to animate a drawing with Canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Canvas 动画化绘图
- en: How to apply the D3 life cycle to individual parts of the Canvas drawing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 D3 生命周期应用于 Canvas 绘图的各个部分
- en: Introducing Canvas
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Canvas
- en: Before you start to draw with Canvas, let's have a brief look at its concept
    – the mental model that will help you approach, plan, and write your applications.
    Canvas in its material form is a single HTML5 element. It is literally a blank
    canvas that you can draw on. For the actual drawing, you use the **Canvas context**
    – the Canvas API. The context can be thought of as your toolbox that can be manipulated
    with JavaScript.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Canvas 绘图之前，让我们简要地看一下其概念——这个心理模型将帮助您接近、规划和编写您的应用程序。Canvas 在其物质形式上是一个单一的
    HTML5 元素。它字面上是一个可以绘制的空白画布。对于实际的绘图，您使用**Canvas 上下文**——Canvas API。上下文可以被视为您的工具箱，可以使用
    JavaScript 进行操作。
- en: You can compare the Canvas element with the root SVG element, as both contain
    all parts of the drawing. However, the key difference is that SVG (like HTML)
    operates in **retained mode**. The browser retains a list of all objects drawn
    onto the SVG (or HTML) canvas within the **Document Object Model** (**DOM**) –
    the scene-graph of your web application. This makes your drawing almost material.
    You produce a list of objects, change styles and properties through code, and
    you can refer to these elements any time you desire. You can change their position,
    move them up or down the DOM and – very important for interaction – you can attach
    and remove event listeners to them easily.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Canvas 元素与根 SVG 元素进行比较，因为它们都包含绘图的全部部分。然而，关键的区别在于 SVG（像 HTML 一样）在**保留模式**下操作。浏览器保留了一个列表，其中包含在**文档对象模型**（**DOM**）中绘制到
    SVG（或 HTML）画布上的所有对象——您的 web 应用的场景图。这使得您的绘图几乎像物质一样。您产生一个对象列表，通过代码更改样式和属性，并且您可以在任何时候引用这些元素。您可以更改它们的位置，在
    DOM 中上下移动它们，并且对于交互来说非常重要——您可以轻松地附加和移除事件监听器。
- en: Canvas, in contrast, operates in **immediate mode**. Anything you draw using
    Canvas occurs at once and remains on the canvas as an image. Images in Canvas
    are bitmaps, digital images composed of a matrix or grid of pixels. When you draw
    with Canvas you prepare the properties of each pixel (or rather specified regions
    of pixels) with your tools and then draw them on the canvas. If you want to change
    the color of one, a few, or all pixels on your image, you remove the whole image
    and produce a new image. Unlike SVG, you can't go back to the pixel you want to
    change, as it is not represented in memory in the form of a document tree or the
    like, but *burned* just once onto the screen. But fear not, you still have the
    Canvas context that represents the state of your tools, which indirectly represents
    the drawing itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，Canvas以**立即模式**运行。你使用Canvas绘制的任何内容都会立即发生，并作为图像保留在画布上。Canvas中的图像是位图，由像素矩阵或网格组成的数字图像。当你使用Canvas绘制时，你使用工具准备每个像素（或更确切地说，指定像素区域）的属性，然后在画布上绘制它们。如果你想改变图像中一个、几个或所有像素的颜色，你需要移除整个图像并生成一个新的图像。与SVG不同，你不能回到你想更改的像素，因为它不是以文档树或类似的形式在内存中表示，而是**一次性**烧录到屏幕上。但别担心，你仍然有Canvas上下文，它代表了你工具的状态，间接地代表了绘图本身。
- en: 'You can think of Canvas as a painting and SVG or HTML as a Lego structure.
    The former is static in its representation. If you paint a man standing on a bridge
    screaming, you can''t just turn his head around. You would have to draw a second
    painting to express this precisely. If you built the same scene with Lego, you
    could grab the head and turn it around, like so:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Canvas想象成一幅画，而SVG或HTML则像乐高结构。前者在表示上是静态的。如果你画了一个站在桥上尖叫的人，你不能只是转动他的头。你需要画第二幅画来精确表达这一点。如果你用乐高搭建同样的场景，你可以抓起头部转动它，就像这样：
- en: '![](img/18ca93ab-fcee-496c-9982-eddcfde75bdd.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18ca93ab-fcee-496c-9982-eddcfde75bdd.png)'
- en: A dramatization of the immediate Canvas and the retained SVG  (SVG Image courtesy
    of Marco Pece www.udronotto.it)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 立即Canvas和保留的SVG的戏剧化对比（SVG图像由Marco Pece提供，www.udronotto.it）
- en: This might sound cumbersome, considering the potential work that has to go into
    animating with Canvas. Not just the mental strain of having to paint so many pictures,
    but the computational powers required to redraw everything in quick succession.
    But, as you will see in the coming sections, there are simple patterns that make
    Canvas animated and interactive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到使用Canvas进行动画可能需要投入的大量工作，这可能会显得有些繁琐。不仅需要承受绘制这么多图片的心理压力，还需要计算能力来快速连续地重绘一切。但是，正如你将在接下来的章节中看到的，有一些简单的模式可以使Canvas动画化和交互式。
- en: Drawing with Canvas
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas绘制
- en: Before we come back to a more thorough comparison of SVG and Canvas and see
    concrete scenarios of when to use what, let's learn to draw with Canvas. We will
    start with a very simple example to understand the three main steps involved when
    drawing with Canvas. Then you will draw a set of shapes to get used to its toolbox.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们回到SVG和Canvas的更详细比较，并看到具体的使用场景之前，让我们学习如何使用Canvas绘制。我们将从一个非常简单的例子开始，以了解绘制Canvas时涉及到的三个主要步骤。然后你将绘制一系列形状，以熟悉其工具箱。 '
- en: As a side note, when working along and viewing the code examples, I highly recommend
    you use a recent Chrome browser. All code is tested across modern browsers but
    has been written with Chrome in mind, which therefore will be the safest browser
    to work with.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，当你在查看代码示例时，我强烈建议你使用最新的Chrome浏览器。所有代码都在现代浏览器上进行了测试，但主要考虑了Chrome，因此它将是工作最安全的浏览器。
- en: The three drawing steps of every Canvas visual
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个Canvas视觉的三个绘图步骤
- en: 'We can deconstruct a Canvas drawing into three simple steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Canvas绘图分解为三个简单的步骤：
- en: '**Create** the canvas and its context.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**画布及其上下文。'
- en: '**Configure** the context.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置**上下文。'
- en: '**Render** the resulting bitmap.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**渲染**生成的位图。'
- en: 'To mount the canvas within your DOM you create a `<canvas>` element in HTML:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的DOM中挂载画布，你需要在HTML中创建一个`<canvas>`元素：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It will look empty, as expected:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来会空空如也，正如预期的那样：
- en: '![](img/6fbdd403-bb07-4971-9b23-ae025dadf1e0.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fbdd403-bb07-4971-9b23-ae025dadf1e0.png)'
- en: An empty Canvas element
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的Canvas元素
- en: This will be all the DOM you will see of your canvas. All other operations will
    happen via the Canvas context in JavaScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是你在DOM中看到的画布的全部内容。所有其他操作将通过JavaScript中的Canvas上下文来完成。
- en: 'If you wanted to draw a rectangle in, say, `royalblue`, you would move onto
    JavaScript without looking back to the HTML and write:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在画布上绘制一个矩形，比如使用`royalblue`颜色，你将直接进入JavaScript编写代码，而无需回到HTML：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can find all code to this chapter at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此章节的所有代码[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)中找到。
- en: 'Let''s go through our first steps one by one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地过一遍我们的第一步：
- en: 'First, you reference the canvas in a variable. We''ll use `d3.select()` to
    do so. As you will need a reference to the canvas element itself, not a selection,
    you should use D3''s `selection.node()` method to grab the element itself. The
    next line references the drawing context to this specific canvas element. The
    context includes all the tools you can use to draw. You can `console.log(‘context'')`
    to have a look at the context object:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要在变量中引用画布。我们将使用`d3.select()`来完成此操作。由于您需要引用画布元素本身，而不是选择，您应该使用D3的`selection.node()`方法来获取元素本身。下一行引用了绘制上下文到这个特定的画布元素。上下文包含了您可以使用来绘制的所有工具。您可以通过`console.log('context')`来查看上下文对象：
- en: '![](img/25d94e62-a290-404d-9f71-8eadfc083561.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25d94e62-a290-404d-9f71-8eadfc083561.png)'
- en: The context object showing all properties
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 显示所有属性的上下文对象
- en: The context is called `CanvasRenderingContext2D` internally, but we will refer
    to it just as `context`. It holds all the properties you can manipulate to draw
    your visual. If you feel inclined you can also expand the `__proto__` object,
    which will show all methods available to you. We'll explain the key properties
    and methods as we go without diving into each individually. The important point
    of the context object is to understand that there's an object helping you to build
    your drawing. It stays at your side all along allowing you to use its methods
    and change its properties.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文在内部被称为`CanvasRenderingContext2D`，但我们将简单地称之为`context`。它包含了您可以用来绘制视觉的所有属性。如果您愿意，也可以扩展`__proto__`对象，这将显示您可用的所有方法。我们将随着解释关键属性和方法，而不会逐个深入。上下文对象的重要之处在于理解有一个对象在帮助您构建绘图。它始终在您身边，允许您使用其方法和更改其属性。
- en: A great place to learn more about the context API, its properties, and methods
    is the documentation on the Mozilla Developer Network at [https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 了解上下文API、其属性和方法的一个好地方是Mozilla开发者网络上的文档，网址为[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)。
- en: At this point, you have the canvas to draw on and the drawing tools, but you
    still haven't drawn anything.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您已经有了可以绘制的画布和绘图工具，但您还没有绘制任何东西。
- en: In the second step you prepare the drawing. You configure the context to produce
    the desired drawing. The example is purposefully simple in that the only configuration
    is to set the fill of our yet non-existent object to `royalblue`. Note that `context.fillStyle`
    is a property, not a method, of the Canvas context. It's like you are a painter
    telling your brush box what color you want to use for the object you paint next.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，您准备绘图。您配置上下文以产生所需的绘图。示例故意很简单，因为唯一的配置是将我们尚未存在的对象的填充设置为`royalblue`。请注意，`context.fillStyle`是Canvas上下文的一个属性，而不是一个方法。就像您是一个画家，告诉您的画笔盒您想要为下一个绘制的对象使用什么颜色一样。
- en: 'This third step produces the following image. `context.fillRect()` takes four
    arguments: the *x* and the *y* position of the rectangle''s starting point as
    well as the `width` and the `height`. Canvas – like SVG – uses a Cartesian co-ordinate
    system with the origin 0, 0 at the top-left corner increasing to the right and
    to the bottom. All values are given in pixels:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步会产生以下图像。`context.fillRect()`接受四个参数：矩形的起始点的`x`和`y`位置以及`width`和`height`。Canvas
    - 类似于SVG - 使用一个以左上角为原点0,0的笛卡尔坐标系，向右和向下增加。所有值都是以像素为单位：
- en: '![](img/d2a012ff-fec0-4d76-8143-815ef901f406.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2a012ff-fec0-4d76-8143-815ef901f406.png)'
- en: A very royal blue Canvas rectangle
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常皇家蓝色的画布矩形。
- en: This rectangle is not present in the DOM. You can see its configuration in JavaSript
    and the canvas its drawn to in the DOM, but there's no `<rect>` element or the
    like we could refer to. Again, don't grow worry lines; we will get clever about
    how to re-address it in the next two chapters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩形不在DOM中。您可以在JavaScript中看到其配置以及绘制到DOM中的画布，但没有`<rect>`元素或类似的内容我们可以引用。再次提醒，不要担心，我们将在接下来的两章中巧妙地重新定位它。
- en: 'View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-1](https://larsvers.github.io/learning-d3-mapping-8-1). Code
    example [08_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_01.html).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-8-1](https://larsvers.github.io/learning-d3-mapping-8-1)。代码示例[08_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_01.html)。
- en: At the conclusion of each step you will find two links in an info box close
    to the the relevant image. The first link brings you to a working implementation
    of this step that you can view in the browser. The second *code example* link
    brings you to the full code. If you're reading the print version, you can find
    all code examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping) in
    their relevant chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤的结尾，你将在靠近相关图像的信息框中找到两个链接。第一个链接将带你到一个可以在浏览器中查看的此步骤的工作实现。第二个*代码示例*链接将带你到完整的代码。如果你在读印刷版，你可以在[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)的相关章节中找到所有代码示例。
- en: You have seen the basic steps to follow when producing pretty much any drawing
    with Canvas. These key conceptual steps will help you to approach any Canvas drawing.
    Now let's draw more.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在Canvas中制作几乎所有绘图的基本步骤。这些关键概念步骤将帮助你接近任何Canvas绘图。现在让我们继续绘制。
- en: Drawing various shapes with Canvas
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas绘制各种形状
- en: 'Let''s add some other basic geometric shapes or **graphical primitives** to
    our canvas. As they are the building blocks of all the visuals you draw, some
    exercise will do us good. Here''s what we will draw:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些其他基本几何形状或**图形原语**到我们的画布中。由于它们是所有可视绘制的构建块，一些练习将对我们有益。以下是我们要绘制的：
- en: '![](img/81bb3ffd-9c3a-4763-9265-ea6a6909eb7e.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81bb3ffd-9c3a-4763-9265-ea6a6909eb7e.png)'
- en: A house and a tree. Or three rectangles under a triangle next to a path and
    a circle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一座房子和一棵树。或者一个三角形旁边的路径和圆下的三个矩形。
- en: View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-2](https://larsvers.github.io/learning-d3-mapping-8-2). Code
    example [08_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_02.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-8-2](https://larsvers.github.io/learning-d3-mapping-8-2)。代码示例[08_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_02.html)。
- en: 'You can see the code to the right in the JavaScript console, and before we
    step through it, let''s note some general observations. First, every line starts
    with `context`. The Canvas context is really where our drawing comes to life.
    Second, Canvas code is written in a procedural style. This can be a benefit for
    beginners, as it is linear. No callbacks, no nested element structure, just a
    straight line of execution. This linearity will also extend to time, once you
    start animating the canvas. You write the first frame first, then you change the
    scene, then you write the second frame. Flip-book simple. Let''s step through
    the code and see how to create these elements in detail. The first thing I suggest
    is giving the canvas a border. As the canvas element is an HTML element, you can
    style it with CSS, but we use JavaScript here to show off two properties of the
    canvas itself: `width` and `height`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在JavaScript控制台右侧看到代码，在我们逐步执行它之前，让我们注意一些一般观察。首先，每一行都以`context`开头。Canvas上下文确实是我们的绘图开始的地方。其次，Canvas代码是以过程式风格编写的。这对初学者来说可能是一个好处，因为它是线性的。没有回调，没有嵌套元素结构，只有一条执行线。这种线性也将扩展到时间，一旦你开始动画画布。你首先写第一帧，然后改变场景，然后写第二帧。就像翻书一样简单。让我们逐步查看代码，看看如何详细创建这些元素。我建议的第一件事是给画布添加一个边框。由于画布元素是一个HTML元素，你可以用CSS来样式化它，但在这里我们使用JavaScript来展示画布本身的两个属性：`width`和`height`：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `width` and `height` are the only properties the canvas element has. We
    use them here to read the values of the element, however, they are readable and
    writable. This is nice, as you can change the canvas size programmatically when
    you want to resize your canvas during animation for example. Next, we build our
    flat-roofed blue house:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`和`height`是画布元素拥有的唯一属性。我们在这里使用它们来读取元素的值，然而，它们是可读和可写的。这很好，因为当你想要在动画过程中调整画布大小时，你可以通过编程方式更改画布大小。接下来，我们构建我们的平顶蓝色房子：'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Not much to see here, we''ve done that previously. The door won''t make you
    sweat either, as it''s the same as the house with a different color:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多可看的，我们之前已经做过。门也不会让你感到费劲，因为它和房子一样，只是颜色不同：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, we use a different method to describe the color. You can use all CSS
    color concepts like named color values and hex color values, as well as the `rgb()`,
    `rgba()`, `hsl()` and `hsla()` color methods. The window is placed a little differently
    with `context.translate()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们使用不同的方法来描述颜色。你可以使用所有 CSS 颜色概念，如命名颜色值和十六进制颜色值，以及 `rgb()`、`rgba()`、`hsl()`
    和 `hsla()` 颜色方法。窗口使用 `context.translate()` 放置得略有不同：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this case, we don''t move the rectangle, we move the entire coordinate system!
    The `translate()` method takes two arguments: the *x* and the *y* position you
    want to move the coordinate system by. You know this concept already from the
    use of `transform, translate(x,y)` which is often used to move `svg:g` elements
    in D3 and create their own coordinate systems. However, when applied to an `svg:g`
    element the transformed coordinate system applies to all objects nested within
    the g element. As said above, the `g` element, as well as its children, is retained
    as a scene-graph representation in the DOM, including its coordinate system. In
    Canvas, we can''t move this information off to a representation of our drawing
    – there is no such thing. It''s up to you to make sure only elements you want
    to manifest on a different coordinate system will do so. Remember above when we
    talked about the procedural style of writing Canvas code? This is exactly what
    we have to keep in mind here. When we change something in the `context` it will
    persist through our code until we change it again. To change the coordinate system
    back we could alternatively move it to our desired position and move it back afterwards
    like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们移动的不是矩形，而是整个坐标系！`translate()` 方法接受两个参数：你想要移动坐标系到的 *x* 和 *y* 位置。你已经从使用
    `transform, translate(x,y)` 的例子中知道了这个概念，这通常用于在 D3 中移动 `svg:g` 元素并创建它们自己的坐标系。然而，当应用于
    `svg:g` 元素时，变换后的坐标系适用于嵌套在 g 元素内的所有对象。如上所述，`g` 元素及其子元素，包括其坐标系，作为场景图表示保留在 DOM 中。在
    Canvas 中，我们不能将此信息移动到我们绘图的表示中——没有这样的东西。这取决于你确保只有你想在另一个坐标系上显示的元素才会这样做。记住，当我们谈论 Canvas
    代码的进程式风格时？这正是我们在这里必须牢记的。当我们更改 `context` 中的内容时，它将一直持续到我们再次更改它。要更改坐标系，我们可以选择将其移动到我们想要的位置，然后再移动回来，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But we rather use the generally applicable `context.save()` and `context.restore()`
    methods. The `context.save()` saves the state at this point of the code and pushes
    it onto a **stack**, and  `context.restore()` pops the last saved state off the
    stack and restores the previous state of the context.  If you haven''t come across
    stacks so far, here''s an image explaining what it does:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们更倾向于使用通用的 `context.save()` 和 `context.restore()` 方法。`context.save()` 在代码的这个点保存状态并将其推入
    **栈**，而 `context.restore()` 则从栈中弹出最后保存的状态并恢复上下文的先前状态。如果你之前没有遇到过栈，这里有一张图片解释了它是如何工作的：
- en: '![](img/55c9677b-a0a1-480e-aa9c-44ba291f5745.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55c9677b-a0a1-480e-aa9c-44ba291f5745.png)'
- en: The stacked tower of data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数据堆叠的塔楼。
- en: 'In short, a stack is a datatype like an array or an object. However, a stack
    is limited to two operations: adding elements on top of the stack (push) and removing
    elements from the top of the stack (pop). It''s like a brick tower. This care-taking
    of our application''s state is a defining aspect of Canvas and a key difference
    to SVG.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，栈是一种类似于数组或对象的数据类型。然而，栈仅限于两种操作：在栈顶添加元素（push）和从栈顶移除元素（pop）。它就像一座砖塔。这种对我们应用程序状态的维护是
    Canvas 的一个定义性特征，也是与 SVG 的一个关键区别。
- en: 'Next, we give the house a triangular roof. There''s no `triangle()` function
    in Canvas, so you draw a path:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给房子加上一个三角形的屋顶。Canvas 中没有 `triangle()` 函数，所以你需要绘制一个路径：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we draw the tree. A tree has a brown stem, which you implement as
    a straight path, and a green treetop, which you draw as a green circle:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制树。树有一个棕色的茎，你可以将其实现为直线路径，以及一个绿色的树顶，你可以将其绘制为绿色圆圈：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two things to note here. First, all path code blocks are bracketed
    by `beginPath()` and either `stroke()` (the stem) or `fill()` (the roof and treetop):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意。首先，所有路径代码块都由 `beginPath()` 和 `stroke()`（茎）或 `fill()`（屋顶和树顶）括起来：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`beginPath()` signifies the intent to draw a new path and removes all current
    path (or sub-path) implementations. `stroke()` and `fill()` signify the end of
    the path and will produce the path on the screen. `fill()` will fill the path
    body with the set `fillStyle` color, and `stroke()` will only draw the path contour
    in with the set `strokeStyle()` method. Whenever you draw a path, you will need
    these start and end methods. In fact, whenever you draw anything you will need
    them. `fillRect()` or `strokeRect()`, as used previously, are just wrappers for
    beginning a path, drawing a path, and filling or stroking a path.You might have
    noticed that we only drew two sides of the triangular roof and then used `closePath()`
    which connects the current endpoint of the path with the starting point. The `fill()`
    method will also close the path for you, but making this explicit is more thorough,
    more performant and a service to the reader of your code (including yourself).
    The second thing to note is that even a circle is a path. In fact, the only primitive
    shape beyond a path offered by the Canvas API is the rectangle. SVG facilitates
    the use of `<rect>`, `<circle>`, `<ellipse>`, `<line>`, `<polyline>`, `<polygon>`,
    and `<path>`, while Canvas only offers paths and rectangles. However, drawing
    shapes with paths quickly becomes routine. While there is no pre-defined circle,
    there''s the `arc()` and `arcTo()` methods, which pretty much do the circle drawing
    for you. You just need to add color to it and wrap it into the path start and
    end methods. `arc()` takes five arguments, the *x* and the *y* position, the *radius*,
    the *start* and the *end angle* of our arc. Both angles are being measured in
    radians.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`beginPath()`表示开始绘制新路径并移除所有当前路径（或子路径）实现。`stroke()`和`fill()`表示路径的结束，将在屏幕上生成路径。`fill()`将使用设置的`fillStyle`颜色填充路径主体，而`stroke()`将仅使用设置的`strokeStyle()`方法绘制路径轮廓。每次你绘制路径时，你都需要这些起始和结束方法。实际上，每次你绘制任何东西时，你都需要它们。`fillRect()`或`strokeRect()`，如之前所用的，只是开始路径、绘制路径和填充或描边路径的包装器。你可能已经注意到，我们只绘制了三角形屋顶的两边，然后使用了`closePath()`来连接路径的当前终点和起点。`fill()`方法也会为你关闭路径，但明确这样做更为彻底，性能更好，并且有助于你代码的读者（包括你自己）。第二件事要注意的是，即使是圆形也是一个路径。事实上，Canvas
    API提供的唯一超出路径的原始形状是矩形。SVG简化了`<rect>`、`<circle>`、`<ellipse>`、`<line>`、`<polyline>`、`<polygon>`和`<path>`的使用，而Canvas只提供路径和矩形。然而，使用路径绘制形状很快就会变得常规。虽然没有预定义的圆形，但有`arc()`和`arcTo()`方法，它们几乎为你完成了圆形绘制。你只需要给它添加颜色，并将其包裹在路径的起始和结束方法中。`arc()`接受五个参数，即*x*和*y*位置、*半径*、弧的*起始*和*结束*角度。这两个角度都是以弧度测量的。'
- en: 'A radian? One **radian** equals *57.3* degrees. Radians are an alternative
    unit of measurement for angles. They are beloved by mathematicians as they make
    a lot of sense in geometric calculations. To get a radian, you take the radius
    of a circle and wrap it around that circle – if you can imagine that the radius
    line is bendable:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度？一个**弧度**等于*57.3*度。弧度是角度的另一种度量单位。数学家们非常喜欢它，因为它们在几何计算中非常有意义。要得到一个弧度，你取圆的半径并将其绕圆周缠绕——如果你能想象半径线是可弯曲的：
- en: '![](img/53c20cea-49e6-4796-a838-b1b48daf4bd3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53c20cea-49e6-4796-a838-b1b48daf4bd3.png)'
- en: How to get a radian
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如何得到一个弧度
- en: Their mathematical advantage is that they can be derived directly from the radius
    of a circle. The further beauty is that half a circle (as in 180 degrees) is exactly
    one *PI* radians. Hence, a full circle equals *2 * PI* radians.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的数学优势是它们可以直接从圆的半径中导出。更美妙的是，半圆（如180度）正好是*PI*弧度。因此，一个完整的圆等于*2 * PI*弧度。
- en: 'Degrees probably make more sense to you. That''s fine. They also make more
    sense if you want to move objects around on the screen. You can easily convert
    between radians and degrees by using the following formula: *(**PI / 180) * degrees*.
    *PI* is half a circle in radians and 180 is half a circle in degrees. By dividing
    one by the other, you express one degree in radians, which equals 0.0175\. Multiply
    any degree number you desire with 0.0175 and use the result as radians.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 度数可能对你来说更有意义。那很好。如果你想在屏幕上移动对象，它们也更有意义。你可以通过使用以下公式轻松地在弧度和度之间进行转换：**(**PI / 180)
    * degrees**。*PI*是弧度的一半圆，180是度数的一半圆。通过将它们相除，你将一个度数表示为弧度，等于0.0175。将任何你想要的度数乘以0.0175，并将结果用作弧度。
- en: OK! We've drawn a landscape with a house – that's great. There is certainly
    more to Canvas, but by following these simple steps you have learned a lot. You
    have learned about the concept of drawing with Canvas and what it means to write
    your code procedurally. You have seen how to draw individual shapes with Canvas,
    how you can move individual objects around with a translate transformation, and
    how the atomic unit of each Canvas shape is the path. Now, let's step it up and
    animate our landscape the Canvas way before we do it the D3 way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们已经画出了一个带有房子的风景——那太棒了。Canvas 当然还有更多内容，但通过遵循这些简单的步骤，你已经学到了很多。你学习了使用 Canvas
    绘图的概念以及编写过程式代码的含义。你看到了如何使用 Canvas 绘制单个形状，如何使用平移变换移动单个对象，以及 Canvas 中每个形状的原子单位是路径。现在，让我们提高难度，在用
    D3 方法之前，先以 Canvas 方式动画化我们的风景。
- en: Animating the Canvas
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 Canvas 方式动画化
- en: One of Canvas's key advantages is animation. While the browser must work hard
    to re-calculate and re-render many elements retained in a DOM, it is relatively
    unstressed re-drawing a bitmapped image. In the following section, you will learn
    how to animate with Canvas. Let's first look at how you do it in a pure, vanilla
    Canvas way. After that, let's see if we can use D3's transition and life cycle
    Enter-Update-Exit pattern to help us animate. Both ways will be immensely helpful
    when building visualizations with D3 and Canvas as you will be able to choose
    the right technique for your own ideas or complement the two.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 的一个关键优势是动画。当浏览器必须努力重新计算和重新渲染 DOM 中保留的许多元素时，它相对轻松地重新绘制位图图像。在下一节中，你将学习如何使用
    Canvas 进行动画。让我们首先看看如何以纯、原生的 Canvas 方式做到这一点。之后，让我们看看我们是否可以使用 D3 的过渡和生命周期进入-更新-退出模式来帮助我们进行动画。这两种方法在用
    D3 和 Canvas 构建可视化时都将非常有帮助，因为你将能够为你的想法选择正确的技术或补充这两种方法。
- en: Animating the Canvas way
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 Canvas 方式动画化
- en: 'Let''s go back to our house and test its roof with rain:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的房子，并测试它的屋顶是否下雨：
- en: '![](img/340c42b9-f372-4ebb-9e18-70752f326cf3.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/340c42b9-f372-4ebb-9e18-70752f326cf3.png)'
- en: It's really raining.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 真的在下雨。
- en: 'View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-3](https://larsvers.github.io/learning-d3-mapping-8-3).
    Code example [08_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_03.html).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-8-3](https://larsvers.github.io/learning-d3-mapping-8-3)。代码示例
    [08_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_03.html)。
- en: It's hard to see in a static image, but the blue dots are in fact moving down
    when viewed in the browser. They are also moving at different speeds, which makes
    the rain look a little more realistic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态图像中很难看到，但在浏览器中查看时，蓝色的小点实际上是在向下移动。它们还以不同的速度移动，这使得雨看起来更加逼真。
- en: Getting a general overview
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得一般概述
- en: 'On the abstracted top level our code looks as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象的最高级别，我们的代码如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After setting up the canvas, you will produce some data – the raindrops. Then
    you will enter a loop within which you will update the data for the next scene
    and then draw it. In our case, `update()` changes the raindrops' positions and `animate()`
    will clear the current image and draw a new image with the updated raindrop positions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好画布之后，你将生成一些数据——雨滴。然后你将进入一个循环，在这个循环中，你将更新下一场景的数据，然后绘制它。在我们的例子中，`update()`
    函数会改变雨滴的位置，而 `animate()` 函数将清除当前图像并使用更新后的雨滴位置绘制一个新的图像。
- en: This loop (or at least a very similar incarnation) is called the **game loop**,
    as it is used in game programming with Canvas. You process the gamer's input,
    update the game data accordingly, and draw the new scene. We will get used to
    this pattern quickly. Now, let's look at the details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环（或者至少是一个非常相似的版本）被称为 **游戏循环**，因为它在 Canvas 游戏编程中被使用。你处理玩家的输入，相应地更新游戏数据，并绘制新的场景。我们将很快习惯这种模式。现在，让我们看看细节。
- en: Preparing the rain data
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备雨数据
- en: 'The elements you''re dealing with are raindrops. Before we update or animate
    a single raindrop, we produce them. We''re building out a so called *object literal
    module* called `rain`  (it''s an *object literal*) that knows how to produce raindrops
    and that keeps the individual drops save in an array called `items`. It will look
    like so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理的是雨滴元素。在我们更新或动画化单个雨滴之前，我们首先生成它们。我们正在构建一个所谓的 *对象字面量模块*，名为 `rain`（它是一个 *对象字面量*），它知道如何生成雨滴，并且将单个雨滴保存在一个名为
    `items` 的数组中。它看起来会是这样：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `rain` object consists of this as yet empty array `items` that will hold
    all the raindrop objects we produce and a variable called `maxDrops`, confining
    the number of raindrops (the length of `items`) to 200 in this case. This can
    be considered light rain. Crank this up to a higher number if you want to drown
    the tree or test the app's performance. As we like the tree and shall test performance
    in an example to come, 200 will do for now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`rain` 对象由这个目前为空的数组 `items` 组成，该数组将保存我们产生的所有雨滴对象，还有一个名为 `maxDrops` 的变量，将雨滴数量（`items`
    的长度）限制在本例中的 200 个。这可以被认为是小雨。如果你想淹没树木或测试应用程序的性能，可以将这个数字提高到更高的数值。由于我们喜欢这棵树，并且将在接下来的示例中测试性能，所以现在
    200 个就足够了。'
- en: Two functions will help to produce and update the drops. `getDrop()` assigns
    start positions out of sight above the canvas, as well as empty `x` and `y` positions
    which will be filled on update. You also define the speed of the drop, which can
    take on values between five and seven. The speed will be the number of pixels
    the raindrop will move forward on each update. A low number will produce slow
    rain and a higher number will produce fast rain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数将帮助生成和更新雨滴。`getDrop()` 将起始位置分配在画布上方看不见的地方，以及空的 `x` 和 `y` 位置，这些位置将在更新时被填充。你还定义了雨滴的速度，它可以取五到七之间的值。速度将是雨滴在每次更新中向前移动的像素数。一个较低的数值会产生慢雨，而一个较高的数值会产生快雨。
- en: The `updateDrop()` function can be called in case we, well, want to update a
    drop's position. Let's do this now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateDrop()` 函数可以在我们想要更新雨滴位置的情况下调用。现在让我们这样做。'
- en: Updating each drop
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新每个雨滴
- en: 'The site loads and things will kick off with the `d3.interval` function, which
    calls all functions it embraces every 10 milliseconds. First, it will call `update()`
    which returns an array of objects. Each object is a drop most notably characterized
    by an arbitrary `x` and `y` position. This is how it looks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网站加载后，将使用 `d3.interval` 函数启动操作，该函数每 10 毫秒调用它包含的所有函数。首先，它将调用 `update()`，该函数返回一个对象数组。每个对象都是一个雨滴，最显著的特征是任意的
    `x` 和 `y` 位置。这就是它的样子：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first time `update()` is called it produces a drop, updates its position,
    and pushes it into the rain items array. Any other time, it just updates the drop's
    position. We use `d3.range` as a convenient method for this loop. It takes an
    integer as input and returns an array of integers starting at 0, and the length
    of the number you pass in. Here it helps create as many rain drops as we specified
    in `maxDrops`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `update()` 时，它会生成一个雨滴，更新其位置，并将其推入雨滴项目数组。在其他任何情况下，它只是更新雨滴的位置。我们使用 `d3.range`
    作为这个循环的便捷方法。它接受一个整数作为输入，并返回一个从 0 开始的整数数组，长度等于你传入的数字。在这里，它帮助我们创建与 `maxDrops` 中指定的数量相等的雨滴。
- en: 'We then update the drop''s position with the `updateDrop()` function we started
    to describe previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用之前开始描述的 `updateDrop()` 函数更新雨滴的位置：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the drop's `x` and `y` positions don't exist yet (if they are `null`) we
    assign the `xStart` or `yStart` values to it. If not, we leave the `x` position
    where it is as no drop will move to any side, and we move the `y` position downwards
    by speed. This will make the drop move down between five and seven pixels every
    10 milliseconds. The last line recycles each drop. Once it has reached the final
    border of the bottom canvas, we just set its `y` value to the initial `yStart`
    value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果雨滴的 `x` 和 `y` 位置还不存在（如果它们是 `null`），我们将 `xStart` 或 `yStart` 的值分配给它。如果已经存在，我们保持
    `x` 位置不变，因为没有雨滴会移动到任何一边，我们将 `y` 位置向下移动一定的速度。这将使雨滴每 10 毫秒向下移动五到七像素。最后一行将每个雨滴回收。一旦它到达底部画布的最终边界，我们只需将其
    `y` 值设置为初始的 `yStart` 值。
- en: Drawing frame by frame
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一帧一帧地绘制
- en: Back in our `d3.interval` loop, `update()` has run and we have the positions
    of all our raindrops. Next, we will deal with drawing them. If we had a DOM, we
    would interact with our omnipresent 200 SVG circles and ask them kindly to move
    down a little. But we produce a static image and we can only draw and not change.
    So, we draw. Like in a flip book we dispose of the old image and draw a new one.
    Let's repeat this. Each time we want to move something on the canvas we **remove**
    **the old image** and **draw a new image** with changed positions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `d3.interval` 循环中，`update()` 已经运行，我们有了所有雨滴的位置。接下来，我们将处理它们的绘制。如果我们有一个 DOM，我们将与无处不在的
    200 个 SVG 圆圈交互，并请求它们友好地向下移动一点。但我们是生成一个静态图像，我们只能绘制而不能更改。所以，我们绘制。就像翻书一样，我们丢弃旧图像并绘制一个新图像。让我们重复这个过程。每次我们想在画布上移动某个东西时，我们**移除****旧图像**并**绘制**一个带有新位置的**新图像**。
- en: 'It''s straightforward:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`animate()` uses the context''s own `clearRect()` function, which does what
    it says on the tin. You pass it the area you want to clear – in our case the entire
    canvas – and it will clear it. You can also fill a white rectangle or change the
    `canvas.width` and `canvas.height` values, but `clearRect()` is faster than the
    first and clearer than the second method.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate()`使用上下文的`clearRect()`函数，正如其名。你传递给它你想清除的区域——在我们的案例中是整个画布——然后它会将其清除。你也可以填充一个白色矩形或更改`canvas.width`和`canvas.height`的值，但`clearRect()`比第一种方法更快，比第二种方法更清晰。'
- en: 'Next, you run the `drawScene()` function, which draws our scene: the house
    and the tree. It''s what you built in the previous section, just wrapped up in
    an aptly-named function.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你运行`drawScene()`函数，它绘制我们的场景：房子和树。这就是你在上一节中构建的内容，只是封装在一个恰如其分的函数中。
- en: 'Finally, we draw each drop to the canvas. What is `circle()` you ask? It''s
    a helper function to build visual primitives – in our case a circle. It has been
    added at the top of the code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将每个雨滴绘制到画布上。你问“`circle()`是什么？”？这是一个构建视觉原语的帮助函数——在我们的案例中是一个圆。它已经被添加到代码的顶部：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The two main functions `update()` and `animate()` are being run repeatedly until
    the end of your browser tab's session; which could mean bad weather for some time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要函数`update()`和`animate()`会一直运行，直到你的浏览器标签页的会话结束；这可能意味着一段时间内会有坏天气。
- en: Canvas and D3
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布和D3
- en: D3 offers unmatched functionality for producing data visualizations on the web.
    You might be aware of this, reading this very book. One important part of what
    D3 offers is its model for how data-infused elements evolve on the screen. It
    has a certain way of thinking about the life cycle of each element.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: D3为在网络上生成数据可视化提供了无与伦比的功能。你可能已经意识到了这一点，因为你正在阅读这本书。D3提供的一个重要部分是其数据注入元素在屏幕上如何演化的模型。它对每个元素的生命周期有特定的思考方式。
- en: 'In practice, you inject data into a yet non-existent DOM, and D3 creates new
    elements of your choice as per the data you inject, usually one element per data
    point. If you want to inject new data into the DOM you can do so and D3 identifies
    which elements have to be newly created, which elements are allowed to stay, and
    which elements should pack up and leave the screen. This way you can represent
    three distinct states of a common data-flow: **entering** data, **updating** data,
    and **exiting** data. You can then grab these selections, manipulate their visual
    properties as well as transition between them with D3''s built-in interpolators,
    leveraged by `d3.transition()`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你将数据注入到一个尚不存在的DOM中，D3会根据你注入的数据创建你选择的新元素，通常每个数据点一个元素。如果你想将新数据注入到DOM中，你可以这样做，D3会识别哪些元素需要新创建，哪些元素可以保留，以及哪些元素应该收拾行李离开屏幕。这样，你可以表示一个常见数据流的三个不同状态：**进入**数据，**更新**数据，和**退出**数据。然后你可以获取这些选择，使用D3内置的插值器操作它们的视觉属性，并在它们之间进行过渡。
- en: This plays well with the retained SVG elements that are manifested in the DOM.
    However, we have no DOM elements in the canvas and must, therefore, be a little
    clever about producing them. Let's see how we can follow D3's life cycle model
    as well as using D3's transitions to interpolate between these three states.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在DOM中表现出来的保留SVG元素很好地配合。然而，我们在画布中没有DOM元素，因此必须稍微聪明一点来生成它们。让我们看看我们如何遵循D3的生命周期模型，同时使用D3的过渡来在这三种状态之间进行插值。
- en: Getting an overview of our experiment
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概览我们的实验
- en: 'We will still let it rain over our little house and its tree, but now the rain
    will follow its natural course – the rain''s life cycle, as it were. It will **Enter**
    in the form of a cloud, it will **Update** as the rain moving into a big puddle
    on the ground, and it will **Exit** turning the puddle into a lush patch of grass:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会让雨在我们的小房子及其树上落下，但现在雨会遵循其自然过程——可以说是雨的生命周期。它将以云的形式**进入**，随着雨移动到地面上一个大水坑中而**更新**，最后它将**退出**，将水坑变成一片郁郁葱葱的草地：
- en: '**![](img/b3ca6039-2d84-45f6-bd58-393a6cb80d34.png)**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/b3ca6039-2d84-45f6-bd58-393a6cb80d34.png)**'
- en: Enter, Update and Exit the rain
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 雨的进入、更新和退出
- en: View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-4b](https://larsvers.github.io/learning-d3-mapping-8-4b).
    Code example [08_04b.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04b.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-8-4b](https://larsvers.github.io/learning-d3-mapping-8-4b)。代码示例[08_04b.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04b.html)。
- en: As you can see, there are buttons to the right allowing you to control the three
    state changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，右侧有按钮允许你控制三个状态变化。
- en: The structure of the code will be similar to the previous pure Canvas animation.
    Conceptually, you calculate the elements' (the raindrops') positions first and
    then draw. However, the way we achieve this interaction is entirely via D3\. To
    lift the lid in advance, you will bind the data to virtual DOM elements. These
    DOM elements are ‘virtual'. As Canvas has no DOM, you create a basic DOM structure
    in memory, with which we can use D3's selections, the data join, and consequently
    the Enter-Update-Exit API. Additionally, the app will have button interactions
    to change the elements' state according to the changed data. We have discussed
    the Canvas setup as well as data preparation already, so let's focus on the core
    novelty of this section, the databind and the draw!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结构将与之前的纯Canvas动画类似。从概念上讲，你首先计算元素（雨滴）的位置，然后绘制。然而，我们实现这种交互的方式完全是通过D3。为了提前揭开盖子，你将数据绑定到虚拟DOM元素上。这些DOM元素是“虚拟”的。由于Canvas没有DOM，你可以在内存中创建一个基本的DOM结构，这样我们就可以使用D3的选择、数据绑定以及随后的Enter-Update-Exit
    API。此外，应用程序还将有按钮交互，根据更改的数据更改元素的状态。我们已经讨论了Canvas设置以及数据准备，所以让我们专注于本节的核心新特性，即数据绑定和绘制！
- en: The data
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: 'Having said that, we should have a brief look at the data we will produce with
    a function called `getRainData()`. It will give us 2,500 raindrops (heavy rain
    this time) that look a little different to our previous example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们应该简要地看一下我们将使用名为`getRainData()`的函数生成的数据。它将给我们2,500个雨滴（这次是暴雨），这些雨滴与之前的示例略有不同：
- en: '![](img/f4cc465b-c0ab-408e-8d50-5d1e0aee1ea2.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4cc465b-c0ab-408e-8d50-5d1e0aee1ea2.png)'
- en: A raindrop the Vanilla Canvas way versus a raindrop the D3-and-Canvas way
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯Canvas方式与使用D3-and-Canvas方式创建的雨滴
- en: The key differences are that you don't need the speed for the D3 raindrop version,
    as we plan for D3's transition to implement the animation. Further, the **D3 and
    Canvas** raindrop has properties for a set of states included, while the **Vanilla
    Canvas** raindrop only has start and current positions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别在于，对于D3雨滴版本，你不需要速度，因为我们计划让D3的过渡实现动画。此外，**D3和Canvas**雨滴具有一组状态属性，而**纯Canvas**雨滴只有起始位置和当前位置。
- en: Updating each drop
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新每个雨滴
- en: With the data in place, it's now time to make it move. In the pure Canvas example,
    you drew each point on the canvas, then calculated new points adding five pixels
    to the previous point's position, removed the old image, and drew the new one
    with the advanced drops. You transitioned the points yourself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数据已经就绪，现在是时候让它动起来了。在纯Canvas示例中，你是在画布上绘制每个点，然后计算新点，将前一个点的位置增加五个像素，移除旧图像，并使用高级滴落绘制新图像。你自己转换了这些点。
- en: 'Employing D3''s transition methods differs in that we won''t calculate the
    new position, but D3 will do it for us. You will bind the data to selections,
    ask D3 to transition the values, and while it transitions you will redraw the
    canvas for as long as the transition runs. On a top level, you only need two functions
    to do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用D3的过渡方法不同之处在于我们不需要计算新位置，D3会为我们做这件事。你将数据绑定到选择上，请求D3过渡值，在过渡期间，你将重新绘制画布，直到过渡完成。在顶层，你只需要两个函数来完成这个任务：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's pretty straightforward.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。
- en: Binding the data
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定数据
- en: 'However, D3 implements transitions on selections, and we don''t have selections
    yet. A single D3 selection is an element with bound data. With D3 you select a
    DOM element, usually SVG, join data to it, and you have a selection with all its
    wondrous methods: the explicit `enter()` and `exit()` methods, the implicit `update()`
    method triggered by `data()`, as well as `transition()` and their helpers `duration()`
    and `delay()` that control the transition.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，D3在选择上实现过渡，而我们还没有选择。一个D3选择是一个绑定数据的元素。使用D3，你选择一个DOM元素，通常是SVG，将其数据绑定到它上面，你就有了具有所有奇妙方法的选择：显式的`enter()`和`exit()`方法，由`data()`触发的隐式`update()`方法，以及`transition()`及其辅助方法`duration()`和`delay()`，它们控制过渡。
- en: 'To create selections, you just create DOM-like elements, and the great thing
    is, you don''t need the incarnated DOM to do so. You can create them in memory.
    Here''s how:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建选择，你只需创建类似DOM的元素，而且很棒的是，你不需要实体的DOM来做这件事。你可以在内存中创建它们。下面是如何做的：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can imagine `customBase` as a replacement of a root SVG element and `custom`
    to be a fully-fledged D3 selection. With your foundation in place you can go about
    the usual D3 business of binding data to your custom elements with the `databind()`
    function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `customBase` 想象成一个根 SVG 元素的替代品，而 `custom` 则是一个完整的 D3 选择。在你的基础搭建好之后，你可以使用
    `databind()` 函数将数据绑定到你的自定义元素上：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we join the data passed into the `databind()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将传递给 `databind()` 函数的数据进行连接：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The key function passed in as the second argument to `data` isn't strictly necessary
    in this case, but is good practice as it makes the join unambiguous and can have
    performance benefits.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `data` 第二个参数传入的关键函数在这个情况下并不是必需的，但作为良好实践，它使得连接变得明确，并且可能带来性能上的好处。
- en: 'Now you create your selection states. The `enter` selection is first:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你创建你的选择状态。`enter` 选择是第一个：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are two things of note about the two bottom lines setting the `fillStyle`
    attribute. When you work with SVG the last line would be:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置 `fillStyle` 属性的最后一行，有两点需要注意。当你使用 SVG 时，最后一行会是：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But with Canvas you use `.attr()`. Why? Your main interest here is to find a
    pain-free way to transfer some element-specific information. Here you want to
    transfer a color string from the `databind()` to the `draw()` function. You use
    the element simply as a vessel to transport your data over to where it is being
    rendered to the canvas.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Canvas 中，你使用 `.attr()`。为什么？你在这里的主要兴趣是找到一种无痛苦的方式来传输一些元素特定的信息。在这里，你希望将颜色字符串从
    `databind()` 传输到 `draw()` 函数。你只是将元素作为一个容器，将你的数据传输到它被渲染到画布上的地方。
- en: 'That''s a very important distinction: when working with SVG or HTML you can
    bind data to elements and draw or apply styles to the elements in one step. In
    Canvas, you need two steps. First, you bind the data then you draw the data. You
    can''t style the elements while binding. They only exist in memory and Canvas
    can''t be styled via CSS style properties, which is exactly what you access when
    using `.style()`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的区别：当使用 SVG 或 HTML 时，你可以将数据绑定到元素上，并在一步中绘制或应用样式到元素。在 Canvas 中，你需要两步。首先，绑定数据，然后绘制数据。在绑定时不能对元素进行样式设置。它们只存在于内存中，Canvas
    不能通过 CSS 样式属性进行样式设置，这正是你使用 `.style()` 时访问的内容。
- en: 'Let''s have a quick look at how the `customBase` element looks after we''ve
    created and appended the `enter` selection to it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下在创建并将 `enter` 选择附加到 `customBase` 元素之后，`customBase` 元素看起来是什么样子：
- en: '![](img/090c66aa-0950-42d4-bdb3-be14185c7b10.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/090c66aa-0950-42d4-bdb3-be14185c7b10.png)'
- en: Our custom root element showing 30 of our raindrops in enter-state
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义根元素显示了 30 个雨滴的进入状态。
- en: Looks familiar in structure, doesn't it?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结构看起来很熟悉，不是吗？
- en: 'Next, you define the `update` selection, and finally the `exit` selection:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义 `update` 选择，最后是 `exit` 选择：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's all that goes into `databind()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是所有放入 `databind()` 中的内容。
- en: Drawing the data
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制数据
- en: Now you need to write the `draw()` function to get the elements on screen. Let's
    just note here that nothing has happened yet. You haven't called `databind()` yet
    because you need to find a way to draw it to the canvas first. So, off we go.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要编写 `draw()` 函数来获取屏幕上的元素。在这里我们只是做个笔记，目前还没有发生任何事情。你还没有调用 `databind()`，因为你需要先找到一种方法将它绘制到画布上。所以，我们继续前进。
- en: 'The `draw()` function takes the context you want to draw on as an argument:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 函数接受你想要绘制的上下文作为参数：'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then it does the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它执行以下操作：
- en: It clears the canvas.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它清除画布。
- en: It draws the background scene, including the house and tree, as well as a cloud
    and a puddle drawn in `drawRainScene()`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制背景场景，包括房屋和树木，以及 `drawRainScene()` 中绘制的云和积水。
- en: It loops through each of our virtual elements to draw it according to the attributes
    we specified in `databind()`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会遍历我们的每个虚拟元素，并根据我们在 `databind()` 中指定的属性来绘制它。
- en: That's it! You can close the `draw()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你可以关闭 `draw()` 函数了。
- en: See the line `ctx.globalCompositeOperation = 'source-atop'`? The `globalCompositeOperation`
    allows us to fuse or blend-in shapes. It operates on a source shape, the shape
    we are about to draw, and a destination, the Canvas content *underneath* the source
    shape. You can apply a number of compositing effects, but we use `source-atop`
    here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这一行 `ctx.globalCompositeOperation = 'source-atop'` 吗？`globalCompositeOperation`
    允许我们将形状融合或混合。它作用于源形状，即我们即将绘制的形状，以及目标，即源形状下方的画布内容。你可以应用多种合成效果，但我们在这里使用 `source-atop`。
- en: Check [https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation)
    for all composite options.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 检查[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation)以获取所有合成选项。
- en: As a result, the new shape is only drawn where it overlaps the existing canvas
    content. The shape will not be visible in canvas regions without any drawings.
    This is why we need all objects in `drawRainScene()`. They form the background
    to our raindrops which they can't escape. By the way, if you don't want to draw
    all complex shapes by hand, you can draw them with vector graphics software such
    as Illustrator, save them as SVG, and use apps such as the *SVG to HTML5 Canvas
    converter* at [http://www.professorcloud.com/svg-to-canvas/](http://www.professorcloud.com/svg-to-canvas/)
    to convert SVG paths into Canvas commands.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新形状仅在它与现有画布内容重叠的地方绘制。在没有绘制的画布区域中，形状将不可见。这就是为什么我们需要在`drawRainScene()`中的所有对象。它们构成了雨滴的背景，雨滴无法逃离。顺便说一句，如果你不想手动绘制所有复杂的形状，你可以使用如Illustrator这样的矢量图形软件绘制它们，将它们保存为SVG格式，然后使用诸如[http://www.professorcloud.com/svg-to-canvas/](http://www.professorcloud.com/svg-to-canvas/)的*SVG到HTML5
    Canvas转换器*应用将SVG路径转换为Canvas命令。
- en: Running the app
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用
- en: 'So far, no raindrop has shown itself, but you have the background scene in
    place:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有雨滴出现，但你已经设置了背景场景：
- en: '![](img/14a09a8a-eb4b-4e99-a3ea-2a0aafece9ba.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14a09a8a-eb4b-4e99-a3ea-2a0aafece9ba.png)'
- en: The initial scene
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 初始场景
- en: 'You have the means to animate the life cycle with the `databind()` and the
    `draw()` functions. You just call them in a sequence and wire this call-up with
    the buttons. Let''s play this through for the Enter case. The cloud is empty and
    we want raindrops to transition into play from 0 to 0.2 opacity, that''s how we
    specified it in the `databind()` function. We could just run:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你有使用`databind()`和`draw()`函数来动画化生命周期的手段。你只需按顺序调用它们，并将这些调用与按钮连接起来。让我们通过进入案例来运行这个。云层是空的，我们希望雨滴从0到0.2的不透明度过渡到活动状态，这就是我们在`databind()`函数中指定的。我们可以直接运行：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will join the data to the custom elements and, as all elements are joined
    with new data, draw the enter selection – once! But we need to display the transition,
    so we need to draw repeatedly while the transition is happening. You achieve this
    with a continuous loop:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把数据连接到自定义元素中，并且随着所有元素都连接了新数据，将绘制整个选择区域——只需一次！但是我们需要显示过渡效果，因此在过渡发生时需要重复绘制。你可以通过一个连续循环来实现这一点：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, we bind the incoming data to our custom elements. Then we draw repeatedly.
    `d3.timer()` calls its callback repeatedly until you tell it to stop. The callback
    takes an argument we call `elapsed` here, which is the time in milliseconds the
    timer is running. The `draw()` function will be run many times drawing the background
    scene as well as each raindrop. At the same time a transition is running within
    `databind()`, changing each raindrop''s position slightly. The `draw()` function
    will pick up these slight position changes as it loops through each raindrop every
    time it''s called, drawing the raindrop at the very position the transition in `databind()`
    sets it to at this given moment. You can think of it as two processes happening
    at the same time: the transition in `databind()` delivering new raindrop positions
    and the repeated canvas drawing in `draw()` removing the previous canvas and drawing
    these new raindrop positions.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将传入的数据绑定到我们的自定义元素上。然后我们重复绘制。`d3.timer()`会反复调用其回调函数，直到你告诉它停止。回调函数接受一个我们称之为`elapsed`的参数，它是计时器运行的时间（以毫秒为单位）。`draw()`函数将会多次运行，绘制背景场景以及每个雨滴。同时，在`databind()`中运行一个过渡，稍微改变每个雨滴的位置。`draw()`函数会在每次调用时，在循环中为每个雨滴选择这些微小的位置变化，并在`databind()`在这个特定时刻设置的非常位置绘制雨滴。你可以将其视为两个同时发生的过程：`databind()`中的过渡提供新的雨滴位置，以及`draw()`中的重复画布绘制移除之前的画布并绘制这些新的雨滴位置。
- en: After the transition is done, we want to stop the timer. Work done. The transition
    in `databind()` runs for 2000 milliseconds, as we set it in the `dur` variable.
    We shall use `dur` now to clear up after us. We can stop any timer from within
    calling the timer's `.stop()`-method. To be safe we call `t.stop()` after we're
    passed double our duration `dur` (*4000* milliseconds) to cater for delayed transitions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡完成后，我们想要停止计时器。工作完成。`databind()`中的过渡持续2000毫秒，正如我们在`dur`变量中设置的。我们现在将使用`dur`来清理我们的工作。我们可以从调用计时器的`.stop()`方法中停止任何计时器。为了安全起见，我们在超过双倍持续时间`dur`（*4000*毫秒）后调用`t.stop()`以适应延迟的过渡。
- en: This is how a D3 transition works in Canvas. You call the drawing function more
    or less parallel to the binding function repeatedly Whatever style or position
    properties your D3 elements are set up to transition (*x*, *y*, *color*, *width*,
    *height*, for example.), they will be re-drawn many times with small incremental
    changes for each draw.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是D3在Canvas中如何进行过渡。你反复调用绘图函数，与绑定函数大致并行。无论你的D3元素设置了哪些过渡样式或位置属性（例如*x*，*y*，*color*，*width*，*height*），它们都将被重新绘制多次，每次绘制都有微小的增量变化。
- en: Wiring it up to the buttons is a formality. Just wrap the `databind()` and `draw()`
    functions into a function (we shall call it `rainAnimation()`) that passes in
    the `raindata` when the enter or update button is pressed and an empty array when
    the exit button is pressed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将其连接到按钮是形式上的。只需将`databind()`和`draw()`函数包装到一个函数中（我们将称之为`rainAnimation()`），当按下进入或更新按钮时传递`raindata`，当按下退出按钮时传递一个空数组。
- en: That's it!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'The rain cloud will appear on the screen upon hitting the Enter button:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下Enter按钮时，雨云将出现在屏幕上：
- en: '![](img/8fa57f3c-d8cf-4b3b-8c49-f520e046a311.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fa57f3c-d8cf-4b3b-8c49-f520e046a311.png)'
- en: Enter rain into cloud
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将雨进入云中
- en: 'The Update button will update the rain''s position from the cloud to a puddle:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更新按钮将雨的位置从云更新到水坑：
- en: '![](img/b81b6df5-fb62-4bf2-a7c9-a47934e6fc74.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b81b6df5-fb62-4bf2-a7c9-a47934e6fc74.png)'
- en: Update rain to the ground
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更新雨到地面
- en: 'The Exit button will finally turn the rain into grass:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按下Exit按钮将雨变成草：
- en: '![](img/2ba74abc-fe1f-4eb9-a36d-3a9c06b8a475.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ba74abc-fe1f-4eb9-a36d-3a9c06b8a475.png)'
- en: Exit the rain to become grass
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让雨退出变成草
- en: View this step in the browser: [https://larsvers.github.io/learning-d3-mapping-8-4a](https://larsvers.github.io/learning-d3-mapping-8-4a).
    Code example [08_04a.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04a.html).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-8-4a](https://larsvers.github.io/learning-d3-mapping-8-4a)。代码示例[08_04a.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04a.html)。
- en: A natural D3 life cycle demonstration!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自然的D3生命周期演示！
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: You've come a long way. You've learned how to draw with Canvas, how to animate
    the canvas in a pure Canvas way, as well as how to use D3 transitions and the
    Enter-Update-Exit pattern with Canvas. While the Vanilla Canvas way is perfectly
    reasonable for a great many applications, D3 offers seasoned functionality for
    data visualization you don't have to abandon. It requires a shift in thinking
    when building your application, but it can pay out specifically for drawing and
    animating a large number of points. It will expand your toolbox in a valuable
    way, especially at times where abundant data might require element-heavy representations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经走得很远了。你已经学会了如何使用Canvas绘图，如何以纯Canvas方式对Canvas进行动画处理，以及如何使用D3过渡和Canvas的Enter-Update-Exit模式。虽然纯Canvas方式对于许多应用来说完全合理，但D3提供了用于数据可视化的成熟功能，你不必放弃。在构建你的应用程序时，这需要思维上的转变，但它可以特别有利于绘制和动画化大量点。它将以有价值的方式扩展你的工具箱，尤其是在大量数据可能需要元素密集型表示的时候。
- en: In the next chapter, we will review a map visualization in SVG and then build
    one in Canvas. By doing so, you will not only be able to apply the learnings from
    this chapter, but you will also learn more about the differences and similarities
    between the two approaches, how Canvas can help with performance bottlenecks,
    and how D3 can help with some heavy lifting.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾SVG中的地图可视化，然后在Canvas中构建一个。通过这样做，你不仅能够应用本章的学习内容，而且你还将了解更多关于两种方法之间的差异和相似之处，Canvas如何帮助解决性能瓶颈，以及D3如何帮助处理一些繁重的工作。
- en: Let's get to it!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
