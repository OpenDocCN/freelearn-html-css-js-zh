- en: Chapter 1. Foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Advanced Express Web Application Development* will guide you through the process
    of building a nontrivial, single-page application using **Express**.'
  prefs: []
  type: TYPE_NORMAL
- en: Express is a fast, unopinionated, minimalist, and flexible web application framework
    for **Node.js** written by TJ. Holowaychuk. It was inspired by **Sinatra** , a
    web framework for Ruby. Express provides a robust set of features for building
    single, multi-page, and hybrid web applications and has quickly become the most
    popular web development framework for node. Express is built on top of an extensible
    HTTP server framework—also developed by TJ. Holowaychuk—called **Connect**. Connect
    provides a set of high performance plugins known as middleware. Connect includes
    over 20 commonly used middleware, including a logger, session support, cookie
    parser, and more.
  prefs: []
  type: TYPE_NORMAL
- en: This book will guide you through the process of building a single-page application
    called Vision; a dashboard for software development projects that integrates with
    GitHub to give you a single-screen snapshot of your software development projects
    issues and commits. This project will allow us to demonstrate the advanced features
    Express has to offer and will give us the opportunity to explore the kind of issues
    encountered in a commercial development and production deployment of a node/Express
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Feature set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now begin the process of building a Vision application. We will start
    from scratch with a test-first approach. Along the way, we will explore some best
    practices and offer tips for when developing web applications with node and Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vision application will include the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is of our Vision application; it contains a list of
    projects, repositories, commits, and issues. The upper-right corner has a login
    link that we will use for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Feature set](img/2494OS_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have node installed, visit: [http://nodejs.org/download/](http://nodejs.org/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an installation guide on the node GitHub repository wiki if you
    prefer not to or cannot use an installer: [https://github.com/joyent/node/wiki/Installation](https://github.com/joyent/node/wiki/Installation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Express globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Download the source code for this book here: [https://github.com/AndrewKeig/advanced-express-application-development](https://github.com/AndrewKeig/advanced-express-application-development.).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have downloaded the source code, install its dependencies by running
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a root project folder called `vision` and add a `package.json`
    file to it: `./package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Express with Mocha and SuperTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Express installed and our `package.json` file in place, we
    can begin to drive out our application with a test-first approach. We will now
    install two modules to assist us: `mocha` and `supertest`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha is a testing framework for node; it''s flexible, has good async support,
    and allows you to run tests in both a TDD and BDD style. It can also be used on
    both the client and server side. Let''s install Mocha with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'SuperTest is an integration testing framework that will allow us to easily
    write tests against a RESTful HTTP server. Let''s install SuperTest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Feature: Heartbeat'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a test to `./test/heartbeat.js` for our `Heartbeat` feature. This
    resource will get a status from the route `/heartbeat` and return a `200 Ok` status
    code. Let's write our first integration test using Mocha and SuperTest. First
    off, create a folder named `/test` inside your `vision` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Our test describes `heartbeat`; it expects the response to have a `JSON` content
    type and a status code equal to `200 Ok`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `Heartbeat` feature; we start by creating a simple Express
    server, `./lib/express/index.js`. We include the `express` and `http` modules
    and create an Express application. We then add an application setting via `app.set`
    called `port` and set it to `3000`. We define a `/heartbeat` route via `app.get`
    withwhich we pass a request handler, `function`, that takes two parameters: `req`
    (request) and `res` (response). We use the response object to return a JSON response.
    We create an HTTP server with `http.createServer` by passing our Express application
    to it; we listen on port `3000` as defined in our application setting called `port`.
    We then export the application with `module.exports`; exporting the application
    allows us to test it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create `./app.js` in the root of our project and export the `express`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To run our test, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then receive the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, try running the application by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the app running, run the following `curl` command in a new terminal and
    you can see our `heartbeat` JSON response return a `200 Ok` status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Continuous testing with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great things about working with a dynamic language and one of the
    things that has drawn me to node is the ability to easily do **Test-Driven Development**
    and continuous testing. Simply run Mocha with the `-w` watch switch and Mocha
    will respond when changes to our codebase are made, and will automatically rerun
    the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Code coverage with Mocha and JSCoverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha is able to generate a code coverage report with a little help from **JSCoverage**
    . Install JSCoverage for your environment from [http://siliconforks.com/jscoverage/](http://siliconforks.com/jscoverage/).
    JSCoverage will parse source code and generate an instrumented version; this enables
    mocha to execute this generated code and create a report. We will need to update
    `./app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'JSCoverage takes as arguments an input directory, and an output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your version of JSCoverage, you may need to add the `–no-highlight`
    switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will generate the coverage report, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Code coverage with Mocha and JSCoverage](img/2494OS_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Express with Nconf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Nconf** is a configuration tool that we will use to create hierarchical/environment
    configuration files for our application. Let''s install Nconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we will do is to move the following hardcoded port number from
    our Express application into our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the module `./lib/configuration/index.js`, which will allow us
    to to read configuration data from JSON files. We import the `nconf` module and
    define a constructor function, `Config`. We then load a configuration file based
    on the current environment and load the default configuration that holds non-environmental
    configuration data. We also define a function `get(key)`, which accepts a key
    and returns a value. We will use this function to read configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write some configuration for our application. Add the following default
    configuration to `./config/default.json`; this will be shared amongst all environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the following configuration to the development, test, and coverage
    config files: `./config/development.json`, `./config/test.json`, and `./config/coverage.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change our Express server `./lib/express/index.js` so that it reads
    `express:port` from configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Extracting routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express supports multiple options for application structure. Extracting elements
    of an Express application into separate files is one option; a good candidate
    for this is routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extract our route heartbeat into `./lib/routes/heartbeat.js`; the following
    listing simply exports the route as a function called `index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a change to our Express server and remove the anonymous function
    we pass to `app.get` for our route and replace it with a call to the function
    in the following listing. We import the route `heartbeat` and pass in a callback
    function, `heartbeat.index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 404 handling middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to handle a `404 Not Found` response, let''s add a 404 not found middleware.
    Let''s write a test, `./test/heartbeat.js`; the content type returned should be
    JSON and the status code expected should be `404 Not Found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following middleware to `./lib/middleware/notFound.js`. Here we
    export a function called `index` and call `res.json`, which returns a 404 status
    code and the message `Not Found`. The next parameter is not called as our 404
    middleware ends the request by returning a response. Calling next would call the
    next middleware in our Express stack; we do not have any more middleware due to
    this, it''s customary to add error middleware and 404 middleware as the last middleware
    in your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the 404 not found middleware to `./lib/express/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Logging middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express comes with a logger middleware via Connect; it''s very useful for debugging
    an Express application. Let''s add it to our Express server `./lib/express/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `immediate` option will write a log line on request instead of on response.
    The `dev` option provides concise output colored by the response status. The logger
    middleware is placed high in the Express stack in order to log all requests.
  prefs: []
  type: TYPE_NORMAL
- en: Logging with Winston
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add logging to our application using **Winston**; let''s install
    Winston:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The 404 middleware will need to log 404 not found, so let's create a simple
    logger module, `./lib/logger/index.js`; the details of our logger will be configured
    with Nconf. We import Winston and the configuration modules. We define our `Logger`
    function, which constructs and returns a file logger—`winston.transports.File`—that
    we configure using values from our `config`. We default the loggers maximum size
    to 1 MB, with a maximum of three rotating files. We instantiate the `Logger` function,
    returning it as a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `Logger` configuration details to our config files `./config/development.json`
    and `./config/test.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s alter the `./lib/middleware/notFound.js` middleware to log errors. We
    import our `logger` and log an error message via `logger` when a `404 Not Found`
    response is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Task automation with Grunt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Grunt is a task runner and a great way to automate your node projects. Let''s
    add a simple grunt script to our project in order to automate running tests and
    code coverage. Let''s install Grunt and Grunt CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grunt-cafe-mocha` is a grunt module for running mocha; this module will
    also allow us to automate code coverage reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grunt-jscoverage` simply generates an instrumented version of our source
    code and writes it to `./lib-cov`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grunt-env` allows you to set the current node environment, `NODE_ENV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a grunt file `./gruntfile.js`. We load the `grunt` modules we
    just installed, and `grunt.initConfig` contains a configuration for each grunt
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration for `cafemocha` contains two sections; one for running our
    tests and one for generating a code coverage report. In order to run our tests
    from grunt, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line registers a task that sets the environment using `env` and
    runs both the `jscoverage` and `cafemocha:coverage` tasks in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run our coverage from grunt, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate the coverage report as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have put in place a fairly solid framework for developing our Vision project;
    we have implemented a simple feature, heartbeat, which when visited, simply informs
    us whether our Express server is up and running. We have automated various development
    tasks, such as running tests and creating code coverage reports. We also have
    in place some logging using Winston. In the next chapter, we will implement a
    web API.
  prefs: []
  type: TYPE_NORMAL
