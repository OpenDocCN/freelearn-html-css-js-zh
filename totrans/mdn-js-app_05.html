<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Bidirectional Communication in Real Time"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Bidirectional Communication in Real Time</h1></div></div></div><p>We have been using COMET techniques to implement bidirectional communication between a web browser and web server. Long polling is the most popular technique of achieving bidirectional communication between a web browser and web server because it works without compromising user experience and without any extra server configuration, and it works on all web browsers that support AJAX. Long polling can easily be implemented in any existing HTTP server. But the problem with long polling and other comet techniques is that none of them are suitable for building real-time apps because of HTTP overhead. This means that every time an HTTP request is made, a bunch of headers and cookie data is transferred to the server, which in turn increases the latency, therefore making it unsuitable for creating applications such as multiplayer games, chat apps, social networks, and live score websites, which require bidirectional communication in real time. Therefore, a new protocol <a id="id167" class="indexterm"/>called <span class="strong"><strong>WebSocket</strong></span> was introduced, which was designed to enable bidirectional communication in real time between a web browser and WebSocket server.</p><p>In this chapter, we'll cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of WebSocket</li><li class="listitem" style="list-style-type: disc">The relationship between WebSocket and HTTP</li><li class="listitem" style="list-style-type: disc">The interaction of WebSocket with proxy servers and firewalls</li><li class="listitem" style="list-style-type: disc">Implementing WebSocket using Socket.IO</li><li class="listitem" style="list-style-type: disc">The Socket.IO API in depth</li><li class="listitem" style="list-style-type: disc">Many other important things related to WebSocket and Socket.IO</li></ul></div><div class="section" title="Introducing WebSocket"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Introducing WebSocket</h1></div></div></div><p>
<span class="strong"><strong>WebSocket</strong></span> is an <a id="id168" class="indexterm"/>application-layer protocol designed to facilitate bidirectional (either the client or server can send a message to the other party whenever a message is available) and full-duplex communication (both the client and server can send messages to each other simultaneously) between a web browser and WebSocket server in real time.</p><p>WebSocket is a binary protocol; therefore, it is faster than the HTTP protocol, which is a text-based protocol.</p><p>WebSocket has gained popularity and is already being used by many websites due to its real-time and full-duplex features. Due to overhead caused by comet techniques, it was not suitable for real-time bidirectional message transfer, and it was also not possible to establish a full-duplex communication system between a web browser and web server using comet. That is, comet techniques let us achieve only half-duplex communication system (only the client or server can send messages to the other party at a given time).</p><p>WebSocket is designed to facilitate bidirectional communication between a web browser and WebSocket server, but it can be used by any client. In this chapter, we will only concentrate on how it's implemented in a web browser.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>What is the WebSocket API?</p><p>Web browsers provide an API for creating and managing a WebSocket connection to a WebSocket server as well as for sending and receiving data on the connection. We won't use this API for implementing WebSocket; instead, we will use the Socket.IO library.</p></div></div><div class="section" title="The relationship between WebSocket and HTTP"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>The relationship between WebSocket and HTTP</h2></div></div></div><p>The only relationship between <a id="id169" class="indexterm"/>WebSocket and HTTP is <a id="id170" class="indexterm"/>that a WebSocket handshake between a web browser and WebSocket server is done using HTTP. Therefore, a WebSocket server is also an HTTP server. Once the handshake is successful, the same TCP connection is used for WebSocket communication, that is, communication switches to the bidirectional binary protocol, which does not conform to the HTTP protocol. The default port number for WebSocket is 80, same as for HTTP.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Why is the default WebSocket port 80?</p><p>The main reason for integrating HTTP and WebSocket so tightly and making WebSocket share the HTTP port is to prevent firewalls from blocking non-web content.</p></div></div><p>Although you can implement your own WebSocket handshake mechanism if you are using WebSocket <a id="id171" class="indexterm"/>outside a web browser environment, the official <a id="id172" class="indexterm"/>WebSocket documentation only states the HTTP handshake mechanism because WebSocket is designed to enable bidirectional communication between web browsers and WebSocket servers.</p><p>You can integrate a WebSocket server into your main web server that serves your HTML pages, or you can use a separate web server for WebSocket communication.</p></div><div class="section" title="Sending and receiving data on a WebSocket connection"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Sending and receiving data on a WebSocket connection</h2></div></div></div><p>Data is <a id="id173" class="indexterm"/>transferred through a WebSocket connection as messages, each <a id="id174" class="indexterm"/>of which consists of one or more frames containing the data you are sending (called the payload). In order to ensure that the message can be properly reconstructed when it reaches the other party, each frame is prefixed with 4-12 bytes of data about the payload. Using this frame-based messaging system helps reduce the amount of non-payload data that is transferred, leading to significant reductions in latency, therefore making it possible to build real-time components.</p><p>We won't get into the exact data format and other details of the WebSocket handshake, data framing, and sending and receiving data as this is only required if you are planning to create your own WebSocket server. We will use Socket.IO JavaScript library to implement WebSocket in our application, which takes care of all the internal details of WebSocket and provides an easy-to-use API.</p></div><div class="section" title="WebSocket schemes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec31"/>WebSocket schemes</h2></div></div></div><p>WebSocket protocol <a id="id175" class="indexterm"/>specifications have introduced two new URL schemes, called <span class="strong"><strong>ws</strong></span> and <span class="strong"><strong>wss</strong></span>.</p><p>
<code class="literal">ws</code> represents <a id="id176" class="indexterm"/>an <a id="id177" class="indexterm"/>unencrypted connection whereas <code class="literal">wss</code> represents an encrypted connection. Encrypted connections use TLS to encrypt messages.</p><p>So, when making a WebSocket handshake request using HTTP, we need to use <code class="literal">ws</code> or <code class="literal">wss</code> instead of <code class="literal">http</code> or <code class="literal">https</code>, respectively.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Why <code class="literal">ws</code> and <code class="literal">wss</code> instead of <code class="literal">http</code> and <code class="literal">https</code>?</p><p>You must be wondering what the point of introducing a new scheme instead of just using <code class="literal">http</code>. Well, the reason behind this is that WebSocket can also be used outside a web browser environment, and a handshake can be negotiated via a non-HTTP server. Therefore, a different scheme is required when not using HTTP for the handshake.</p></div></div></div><div class="section" title="The interaction of WebSocket with proxy servers, load balancers, and firewalls"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>The interaction of WebSocket with proxy servers, load balancers, and firewalls</h2></div></div></div><p>The WebSocket <a id="id178" class="indexterm"/>protocol is unaware of proxy <a id="id179" class="indexterm"/>servers by itself. When a WebSocket connection <a id="id180" class="indexterm"/>is established behind a proxy server, the WebSocket connection can fail or work properly, depending on whether the proxy server is transparent or explicit and also whether we have established a secure or unsecure connection.</p><p>If the browser is configured to use an explicit proxy server, then it will first issue an <code class="literal">HTTP CONNECT</code> method to that proxy server when establishing the WebSocket connection. The <code class="literal">CONNECT</code> method is used to tell a proxy to make a connection to another host and simply reply with the content, without attempting to parse or cache it. A browser issues the <code class="literal">HTTP CONNECT</code> method regardless of whether the connection is encrypted or unencrypted.</p><p>If we are using a transparent proxy server (that is, a proxy server that the web browser is unaware of) and the connection is encrypted, then the browser doesn't issue an <code class="literal">HTTP CONNECT</code> method because it's unaware of the proxy server. But as the connection is encrypted, the proxy server will most probably let all the encrypted data through, therefore causing no problems to the WebSocket connection.</p><p>If we are using a transparent proxy server and the connection is unencrypted, then the browser doesn't issue an <code class="literal">HTTP CONNECT</code> method because it's unaware of the proxy server. But as the connection is unencrypted, the proxy server is likely to try to cache, parse, or block the data, therefore causing issues for the WebSocket connection. In this case, the proxy server should be upgraded or explicitly configured to support WebSocket connections.</p><p>The WebSocket protocol is unaware of load balancers by itself. If you are using a TCP load balancer, it is unlikely to cause any problems for a WebSocket connection. But if you are using an HTTP load balancer, it's likely to cause problems; therefore, it needs to be upgraded or explicitly configured to handle WebSocket connections.</p><p>The WebSocket protocol is unaware of firewalls by itself. Firewalls are unlikely to cause any problems for a WebSocket connection.</p></div><div class="section" title="The same-origin policy for WebSocket"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>The same-origin policy for WebSocket</h2></div></div></div><p>Browsers as <a id="id181" class="indexterm"/>well as WebSocket instances can perform cross-domain communication, that is, they are not restricted by any same-origin policy.</p><p>While making an HTTP request for a handshake, the browser sends an <code class="literal">Origin</code> header assigned to the webpage origin.</p><p>If a WebSocket server wants to restrict communication to a particular domain, it can read the <code class="literal">Origin</code> HTTP <a id="id182" class="indexterm"/>header of the handshake HTTP request and block or allow the handshake accordingly.</p></div></div></div>
<div class="section" title="Introduction to Socket.IO"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Introduction to Socket.IO</h1></div></div></div><p>Socket.IO is <a id="id183" class="indexterm"/>a combination of the client-side JavaScript library and Node.js library used to integrate bidirectional communication between a browser and Node.js backend.</p><p>The Socket.IO client-side library is used to create a Socket.IO client whereas the Socket.IO Node.js library is used to create a Socket.IO server. The Socker.IO client and server can communicate with each other bidirectionally. Socket.IO primarily uses WebSocket to achieve bidirectional communication.</p><p>The main reason for using the Socket.IO client-side library instead of using the WebSocket API is that WebSocket is a relatively new protocol at the time of writing and not all browsers support the API. If Socket.IO sees that the browser doesn't support WebSocket, then it jumps to one of the other mechanisms, such as Flash sockets, long polling, multipart streaming, iframes, or JSONP polling, to implement bidirectional communication between browsers and servers. Therefore, we can say that Socket.IO is guaranteed to work on every browser. The Socket.IO backend library provides APIs to create namespaces and rooms, broadcast messages, and so on, which are very useful in some cases. Therefore, Socket.IO is the best way to implement bidirectional communication between a browser and Node.js server.</p><div class="section" title="Setting up your project"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Setting up your project</h2></div></div></div><p>Before <a id="id184" class="indexterm"/>we start learning about the Socket.IO API, let's first set up our project directory and files. Create a directory named <code class="literal">SocketIO-Example</code>. Inside the directory, create files called <code class="literal">package.json</code>, <code class="literal">app.js</code>, and <code class="literal">socket.js</code>, and a directory called <code class="literal">public</code>. Inside the <code class="literal">public</code> directory, create two directories, <code class="literal">html</code> and <code class="literal">js</code>. Inside the <code class="literal">html</code> directory, create a file called <code class="literal">index.html</code>. Finally, in the <code class="literal">js </code>directory, download and place the Socket.IO library <a id="id185" class="indexterm"/>from <a class="ulink" href="https://cdn.socket.io/socket.io-1.3.7.js">https://cdn.socket.io/socket.io-1.3.7.js</a>. At the time of writing, the latest version of Socket.IO is 1.3.7; therefore, we will be using that version.</p><p>Inside the <code class="literal">app.js</code> file, we will write code for the web server, and inside the <code class="literal">socket.js</code> file, we will write code for the Socket.IO server. For now, we will run two different servers, that is, a separate web server serving the website, and another server for bidirectional communication. In the next chapter, we will learn how to integrate the Socket.IO server with the Express server.</p><p>Inside the <code class="literal">package.json</code> file, place this code:</p><div class="informalexample"><pre class="programlisting">{
  "name": "SocketIO-Example",
  "dependencies": {
    "express": "4.13.3",
    "socket.io": "1.3.7"
  }
}</pre></div><p>Now, run <a id="id186" class="indexterm"/>the <code class="literal">npm install</code> command inside the <code class="literal">SocketIO-Example</code> directory in order to download and install Express and the Socket.IO Node.js library.</p><p>Now, inside the <code class="literal">index.html</code> file, place this HTML code:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;SocketIO-Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/socket.io-1.3.7.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      //place JavaScript code here
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Inside the second <code class="literal">&lt;script&gt;</code> tag, you will be placing the Socket.IO client-side code.</p><p>Now, place this code in the <code class="literal">app.js</code> file to serve the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">var express = require("express");
var app = express();

app.use(express.static(__dirname + "/public"));

app.get("/", function(httpRequest, httpResponse, next){
  httpResponse.sendFile(__dirname + "/public/html/index.html");
})

app.listen(8080);</pre></div><p>Here, we are listening on port <code class="literal">8080</code>. Run the <code class="literal">app.js</code> file and visit the <code class="literal">http://localhost:8080/</code> URL to load the <code class="literal">index.html</code> page.</p><p>We are done with setting up the files and directories. Now, let's learn about the Socket.IO client-side and server-side APIs.</p></div><div class="section" title="Diving into the Socket.IO API"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Diving into the Socket.IO API</h2></div></div></div><p>Let's first look <a id="id187" class="indexterm"/>at an overview of the Socket.IO API. After that, we will get into the advanced features one by one.</p><p>Let's first build a Socket.IO server. The following is the code to create a Socket.IO server instance and listen to new Socket.IO client handshake requests. Place it in the <code class="literal">socket.js</code> file:</p><div class="informalexample"><pre class="programlisting">var Server = require("socket.io");
var io = new Server({path: "/websocket"});
io.listen(3000);</pre></div><p>Here is how the code works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we import the Socket.IO Node.js library.</li><li class="listitem">Then, we create a new instance of the Socket.IO server using the <code class="literal">Server</code> constructor.</li><li class="listitem">Then, while creating a new instance, we pass the HTTP path to which the Socket.IO client will make a handshake request. If we don't pass the path, it defaults to /<code class="literal">socket.io</code></li><li class="listitem">Finally, we listen on port <code class="literal">3000</code>.</li></ol></div><p>I created a single Socket.IO server in the code, but we have the freedom to create multiple servers listening on different ports.</p><p>Now, Socket.IO clients can send a handshake request, and the Socket.IO server can establish a Socket.IO connection with its clients. Let's write some code to do something on a Socket.IO server after a Socket.IO connection has been established. Place this code in the <code class="literal">socket.js</code> file:</p><div class="informalexample"><pre class="programlisting">io.on("connection", function(socket){

  socket.send("Hi, from server");

  socket.on("message", function(message){
    console.log(message);
  });

  socket.on("disconnect", function(){ 
    console.log("User Disconnected");
  });

  socket.emit("custom-event", "parameter1", "parameter2");

  socket.on("custom-event", function (parameter1, parameter2) {
    console.log(parameter1, parameter2);
  });
});</pre></div><p>Let's see <a id="id188" class="indexterm"/>how this code works and what the <code class="literal">send()</code>, <code class="literal">on()</code>, and <code class="literal">emit()</code> methods do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">on()</code> method of the <code class="literal">io</code> object is used to attach event handlers to events triggered on the Socket.IO server by itself.</li><li class="listitem" style="list-style-type: disc">We first attach an event handler for the <code class="literal">connection</code> event. As soon as a Socket.IO connection has been established, the <code class="literal">connection</code> event is fired. The event handler has a single parameter, which is an object representing the Socket.IO client. Here, we've named the parameter <code class="literal">socket</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">on()</code> method of the <code class="literal">socket</code> object is used to attach event handlers to the events emitted by the Socket.IO client to the server.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">send()</code> method of the <code class="literal">socket</code> object is used to send a message to the Socket.IO client. We are sending a string here, but you can also send an instance of <code class="literal">ArrayBuffer</code>, <code class="literal">Blob Node.js Buffer</code>, and even <code class="literal">File</code>. You can also send a simple JavaScript object.</li><li class="listitem" style="list-style-type: disc">Then, we attached an event handler for the <code class="literal">message</code> event, which is triggered when the Socket.IO client sends a message to the Socket.IO server.</li><li class="listitem" style="list-style-type: disc">After that, we attached an event handler to the <code class="literal">disconnect</code> event, which is triggered when the Socket.IO client disconnects from the Socket.IO server.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">emit</code> method of the <code class="literal">socket</code> object is used to send custom events to the Socket.IO client. It can take an infinite number of arguments. The first argument it takes is the event name, and the rest of the arguments are the parameters of the event handler, which is triggered on the Socket.IO client.</li><li class="listitem" style="list-style-type: disc">Finally, we use the <code class="literal">on()</code> method of the <code class="literal">socket</code> object to register an event handler for a custom event named <code class="literal">custom-event</code>.</li></ul></div><p>So now, we have finished creating a very simple Socket.IO server that lets Socket.IO clients establish a connection with it. It is also listening to <code class="literal">message</code> and <code class="literal">custom-event</code> events. It also sends a message and emits a custom event to the Socket.IO clients as soon as they are connected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>As every Socket.IO client gets a separate <code class="literal">socket</code> object on the Socket.IO server, if we want a <code class="literal">socket</code> object to be able to access the <code class="literal">socket</code> object of another Socket.IO client, then we can keep a reference to the <code class="literal">socket</code> objects of every Socket.IO client in a global array. This can be useful if we are creating a chat app in which a <code class="literal">socket</code> object needs to access another <code class="literal">socket</code> object to send messages to it.</p></div></div><p>You can now run the Socket.IO server using the <code class="literal">node socket.js</code> command.</p><p>Now, let's build the Socket.IO client. The following is the code to create a Socket.IO client <a id="id189" class="indexterm"/>instance and establish a Socket.IO connection with the Socker.IO server. Place this code in the <code class="literal">&lt;script&gt;</code> tag of the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">var socket = io("http://localhost:3000", {path: "/websocket"});</pre></div><p>Here, we are first creating a Socket.IO client instance and establishing a connection with the Socket.IO server using the <code class="literal">io</code> constructor. The first argument is the base URL of the Socket.IO server. The second argument is an optional object to which we have passed the URL path that the handshake request should be made to. If we don't pass the path, then the default path will be <code class="literal">/socket.io</code>.</p><p>We created a single Socket.IO client instance here, but we have the freedom to create multiple Socket.IO client instances if we want to connect to multiple Socket.IO servers.</p><p>We are using the <code class="literal">http</code> scheme instead of the <code class="literal">ws</code> scheme here because Socket.IO can use any technique or protocol other than WebSocket to achieve bidirectional communication. If Socket.IO chooses to use WebSocket, then it will automatically replace <code class="literal">http</code> with <code class="literal">ws</code>.</p><p>Let's write some code to do something on a Socket.IO client after a Socket.IO connection has been established. Place this code in the <code class="literal">&lt;script&gt;</code> tag of <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">socket.on("connect", function () {

  socket.send("Hi, from client");

  socket.on("message", function (msg) {
    console.log(msg)
  });

  socket.on("disconnect", function(){ 
    console.log("I am disconnected");
  });

  socket.on("custom-event", function (parameter1, parameter2) {
    console.log(parameter1, parameter2);
  });

  socket.emit("custom-event", "parameter1", "parameter2");
});</pre></div><p>Let's understand how this code works and what the <code class="literal">send()</code>, <code class="literal">on()</code>, and <code class="literal">emit()</code> methods do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">on()</code> method of the <code class="literal">socket</code> object is used to attach event handlers to the events triggered on the Socket.IO client by itself.</li><li class="listitem" style="list-style-type: disc">We first attach an event handler to the <code class="literal">connect</code> event. As soon as a Socket.IO connection has been established, the <code class="literal">connect</code> event is fired.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">send()</code> method's <code class="literal">socket</code> object is used to send a message to the Socket.IO server. We are sending a string here, but you can also send an instance of <code class="literal">ArrayBuffer</code>, <code class="literal">Blob</code>, or even <code class="literal">File</code>. You can also send a simple JavaScript object.</li><li class="listitem" style="list-style-type: disc">Then, we attached an event handler to the <code class="literal">message</code> event, which is triggered when the Socket.IO server sends a message to the Socket.IO client.</li><li class="listitem" style="list-style-type: disc">We then attached an event handler to the <code class="literal">disconnect</code> event, which is triggered when the Socket.IO client disconnects from the Socket.IO server. As soon as a Socket.IO connection breaks, the Socket.IO client keeps trying to connect again automatically.</li><li class="listitem" style="list-style-type: disc">After that, we use the <code class="literal">on()</code> method of the <code class="literal">socket</code> object to register an event handler for a custom event named <code class="literal">custom-event</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">emit</code> method of the <code class="literal">socket</code> object is used to send custom events to the Socket.IO server. It can take an infinite number of arguments. The first argument it takes is the event name, and the rest of the arguments are the parameters of the event handler, which is triggered in the Socket.IO client.</li></ul></div><p>Now, open the URL <code class="literal">http://localhost:8080/</code> in your browser, and you should see the following console output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi, from server</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
</pre></div><p>And you will see the following output in the shell running the Socket.IO server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi, from client</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
</pre></div><div class="section" title="Restricting connections based on origin"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Restricting connections based on origin</h3></div></div></div><p>By default, a <a id="id190" class="indexterm"/>Socket.IO server lets Socket.IO clients from any origin establish a Socket.IO connection with it. Socket.IO provides a way to restrict connections to a particular origin.</p><p>To restrict connections to a particular origin or set of origins, we can use the <code class="literal">origins</code> method of the <code class="literal">Server</code> instance.</p><p>Place this code in the <code class="literal">socket.js</code> file to only allow Socket.IO clients running on the <code class="literal">localhost</code> domain and port number <code class="literal">8080</code> to connect to the Socket.IO server:</p><div class="informalexample"><pre class="programlisting">io.origins("localhost:8080");</pre></div><p>We cannot simply pass any <code class="literal">origin</code> to the <code class="literal">origins</code> method. Here are examples of some valid <code class="literal">origins</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testsite.com:80</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">http://testsite.com:80</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">http://*:8080</code> (* is a wildcard)</li><li class="listitem" style="list-style-type: disc"><code class="literal">*:8080</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">testsite.com:* http://someotherdomain.com:8080</code> (multiple origins separated by spaces)</li><li class="listitem" style="list-style-type: disc"><code class="literal">testsite.com:*/somepath</code> (Socket.IO will ignore /somepath)</li><li class="listitem" style="list-style-type: disc"><code class="literal">*:*</code></li></ul></div><p>In the <a id="id191" class="indexterm"/>previous list, every origin has a port number associated with it because it is compulsory to provide a port number or * in place of the port number, indicating any port.</p><p>Here are some examples of invalid origins:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testsite.com</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">http://testsite.com</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">http://testsite.com/somepath</code></li></ul></div><p>These are invalid because they don't have port numbers associated with them.</p><p>Also note that if you specify <code class="literal">sub.testsite.com</code> as the <code class="literal">origins</code> value, <code class="literal">testsite.com</code> will be a valid origin.</p></div><div class="section" title="Namespaces in Socket.IO"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Namespaces in Socket.IO</h3></div></div></div><p>A Socket.IO <a id="id192" class="indexterm"/>server is actually <a id="id193" class="indexterm"/>divided into child servers called <span class="strong"><strong>namespaces</strong></span>. A Socket.IO client always connects to a namespace. Every namespace has a name, which looks like an HTTP path.</p><p>In the previous code, when we created a Socket.IO server, a default namespace was created. The default namespace is identified by the <code class="literal">/</code> path. If we don't mention a namespace when creating a Socket.IO client, then it connects to the default namespace. So, the <code class="literal">connection</code> event is specific to a particular namespace, that is, for every namespace, we have to register a different <code class="literal">connection</code> event handler.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>
<span class="strong"><strong>What is the benefit of namespaces?</strong></span>
</p><p>You must be wondering what the point of introducing namespaces is. Well, namespaces make writing complex code easier. Let's look at an example to understand this.</p><p>Suppose you have a web page that has multiple components that update in real time. You <a id="id194" class="indexterm"/>would then either create multiple Socket.IO servers for a component or use a single Socket.IO server and rely on the data <a id="id195" class="indexterm"/>format of a message or custom event to find which data belongs to which component. Both of these techniques have demerits, that is, creating multiple Socket.IO servers occupies multiple ports, so it's not suitable for a large number of components, and relying on the data formats of messages and custom events make it difficult to move frontend components to a separate application, as the new application will get a lot of unnecessary messages and events, causing bandwidth issues on both sides. Therefore, namespaces were introduced, which combine the benefits of both techniques while omitting their demerits.</p></div></div><p>Here is how to create a custom namespace. Place this code in the <code class="literal">socket.js</code> file:</p><div class="informalexample"><pre class="programlisting">var nsp = io.of("/custom-namespace");

nsp.on("connection", function(socket){
  socket.send("Hi, from custom-namespace");

  socket.on("message", function(message){
    console.log(message);
  });

  socket.on("disconnect", function(){ 
    console.log("User Disconnected");
  });

  socket.on("custom-event", function (parameter1, parameter2) {
    console.log(parameter1, parameter2);
  });

  socket.emit("custom-event", "parameter1", "parameter2");
});</pre></div><p>On adding this code to the <code class="literal">socket.js</code> file, we will have two namespaces, that is, the default one, which we created earlier, and this one, called <code class="literal">/custom-namespace</code>. Here, you can see that we registered a new connection event handler for this namespace.</p><p>Now, let's create another Socket.IO client, one which connects to the <code class="literal">/custom-namespace</code> namespace. Place this code in the <code class="literal">&lt;script&gt;</code> tag of <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">var socket1 = io("http://localhost:3000/custom-namespace", {path: "/websocket"});

socket1.on("connect", function () {

  socket1.send("Hi, from client");

  socket1.on("message", function (msg) {
    console.log(msg)
  });

  socket1.on("disconnect", function(){ 
    console.log("I am disconnected");
  });

  socket1.on("custom-event", function (parameter1, parameter2) {
    console.log(parameter1, parameter2);
  });

  socket1.emit("custom-event", "parameter1", "parameter2");
});</pre></div><p>Here, we <a id="id196" class="indexterm"/>are creating another Socket.IO client; this one connects to the <code class="literal">/custom-namespace</code> namespace.</p><p>Now, rerun <a id="id197" class="indexterm"/>the <code class="literal">socket.js</code> file and visit <code class="literal">http://localhost:8080/</code>. This will be the browser console output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi, from server</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
<span class="strong"><strong>Hi, from custom-namespace</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
</pre></div><p>And this will be the new shell output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi, from client</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
<span class="strong"><strong>Hi, from client</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>When we restrict access based on origin using the <code class="literal">origins()</code> method, it is applied to all namespaces.</p></div></div><div class="section" title="Referring to all connected Socket.IO clients"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec01"/>Referring to all connected Socket.IO clients</h4></div></div></div><p>The Socket.IO <a id="id198" class="indexterm"/>server API also provides us with a way of sending a message or custom event to everyone in a namespace.</p><p>Let's look at an example of how to do this. Place the following code in the <code class="literal">socket.js</code> file:</p><div class="informalexample"><pre class="programlisting">setInterval(function(){
  //sending message and custom-event-2 to all clients of default namespace
  io.emit("custom-event-2");
  io.send("Hello Everyone. What's up!!!");

  //sending message and custom-event-2 to all clients of /custom-namespace namespace
  nsp.emit("custom-event-2");
  nsp.send("Hello Everyone. What's up!!!");
}, 5000)</pre></div><p>Here, to send a message or custom event to all the Socket.IO clients connected to the default <a id="id199" class="indexterm"/>namespace, we use the <code class="literal">io</code> object. And to send to Socker.IO clients connected to a custom namespace, we use the object returned by the <code class="literal">of()</code> method.</p><p>Here, we are simply sending a message and custom event to everyone in both the namespaces every <code class="literal">5</code> seconds.</p></div></div><div class="section" title="Rooms in Socket.IO"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Rooms in Socket.IO</h3></div></div></div><p>A <span class="strong"><strong>room</strong></span> simply <a id="id200" class="indexterm"/>represents a group of Socket.IO clients connected <a id="id201" class="indexterm"/>to a particular namespace. A room belongs to a particular namespace.</p><p>A namespace cannot have two rooms with the same name, but two different namespaces can have rooms with the same name. Rooms with the same name on different namespaces are different rooms entirely.</p><p>Every Socket.IO client connected to a namespace must belong to one or more groups. By default, when a Socket.IO client is connected, a new group is created and the client is added to it. Therefore, every Socket.IO client belongs to a unique group by default.</p><p>Here is the code that prints the unique group name of a Socket.IO client after it has connected. Place it inside the default and <code class="literal">/custom-namespace</code> namespaces' <code class="literal">connection</code> event handlers:</p><div class="informalexample"><pre class="programlisting">console.log(socket.id);</pre></div><p>The <code class="literal">id</code> property of the <code class="literal">socket</code> object holds the unique room name.</p><div class="section" title="Joining and leaving a room"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec02"/>Joining and leaving a room</h4></div></div></div><p>To add a <a id="id202" class="indexterm"/>Socket.IO client to a custom room, we need to <a id="id203" class="indexterm"/>use the <code class="literal">socket.use()</code> method. To remove a Socket.IO client from a custom room, we need to use the <code class="literal">socket.leave()</code> method.</p><p>The following code adds every Socket.IO client connected to the default and <code class="literal">/custom-namespace</code> servers <a id="id204" class="indexterm"/>to a room called <code class="literal">my-custom-room</code>. Place it <a id="id205" class="indexterm"/>inside the default and <code class="literal">/custom-namespace</code> namespaces' <code class="literal">connection</code> event handlers:</p><div class="informalexample"><pre class="programlisting">socket.join("my-custom-room");</pre></div><p>Similarly, to remove a user from <code class="literal">my-custom-room</code>, you can use this code:</p><div class="informalexample"><pre class="programlisting">socket.leave("my-custom-room");</pre></div></div><div class="section" title="Referring to all connected Socket.IO clients in a room"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec03"/>Referring to all connected Socket.IO clients in a room</h4></div></div></div><p>The <a id="id206" class="indexterm"/>Socket.IO server API also provides us with a way to send a message or custom event to everyone in a room.</p><p>Let's look at an example of how to do this. Place the following code in the <code class="literal">socket.js</code> file:</p><div class="informalexample"><pre class="programlisting">setInterval(function(){
  //sending message and custom-event-3 to all clients in my-custom-room room of default namespace
  io.to("my-custom-room").send("Hello to everyone in this group");
  io.to("my-custom-room").emit("custom-event-3");

  //sending message and custom-event-3 to all clients in my-custom-room room of /custom-namespace namespace
  nsp.to("my-custom-room").send("Hello to everyone in this group");
  nsp.to("my-custom-room").emit("custom-event-3");
}, 5000)</pre></div><p>Here, to send a message or custom event to all the Socket.IO clients in the <code class="literal">my-custom-room</code> room of the default namespace, we need to use the <code class="literal">io.to().send()</code> method. And to send a message or custom event to all the Socket.IO clients in the <code class="literal">my-custom-room</code> room of the <code class="literal">/custom-namespace</code> namespace, we need to use the <code class="literal">nsp.to().send()</code> method.</p></div></div><div class="section" title="Broadcasting messages and custom events to namespaces and rooms"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>Broadcasting messages and custom events to namespaces and rooms</h3></div></div></div><p>Broadcasting <a id="id207" class="indexterm"/>is a feature of the Socket.IO <a id="id208" class="indexterm"/>server API that lets a <code class="literal">socket</code> object <a id="id209" class="indexterm"/>send a message or custom event to everyone in the namespace or room except itself.</p><div class="section" title="Broadcasting to a namespace"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec04"/>Broadcasting to a namespace</h4></div></div></div><p>To broadcast a message to all Socket.IO clients in a namespace, we need to use the <code class="literal">socket.broadcast.send()</code> method, and to broadcast a custom event, we need to use the <code class="literal">socket.broadcast.emit()</code> method.</p><p>Let's look <a id="id210" class="indexterm"/>at an example. Place the following code in the <code class="literal">connection</code> event handler of the default namespace to broadcast a message every time a new Socket.IO client joins:</p><div class="informalexample"><pre class="programlisting">socket.broadcast.send("A new user have joined");</pre></div><p>Now, open <code class="literal">http://localhost:8080/</code> in two different tabs. In the first tab's console, you will see this output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi, from server</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
<span class="strong"><strong>Hi, from custom-namespace</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
<span class="strong"><strong>A new user have joined</strong></span>
</pre></div><p>In the second tab's console, you will see this output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi, from server</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
<span class="strong"><strong>Hi, from custom-namespace</strong></span>
<span class="strong"><strong>parameter1 parameter2</strong></span>
</pre></div></div><div class="section" title="Broadcasting to a room"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec05"/>Broadcasting to a room</h4></div></div></div><p>To broadcast a <a id="id211" class="indexterm"/>message to all Socket.IO clients in a room, we need to use the <code class="literal">socket.broadcast.to().send()</code> method, and to broadcast a custom event, we need to use the <code class="literal">socket.broadcast.to.emit()</code> method.</p><p>Place this code inside the default and <code class="literal">/custom-namespace</code> namespaces' <code class="literal">connection</code> event handlers:</p><div class="informalexample"><pre class="programlisting">socket.broadcast.to("my-custom-room").send("Hi everyone. I just joined this group");</pre></div><p>Here, as soon as a Socket.IO client is connected, it sends a message to everyone else in the room.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Remember that a Socket.IO client doesn't have to be a member of a room to broadcast a message to its Socket.IO clients.</p></div></div></div></div><div class="section" title="Middleware in Socket.IO"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Middleware in Socket.IO</h3></div></div></div><p>Middleware in <a id="id212" class="indexterm"/>Socket.IO server is a callback that's executed when a Socket.IO client makes a handshake request, before the Socket.IO server replies to it. Middleware allows us to allow or reject handshakes.</p><p>The middleware concept of Socket.IO is similar to that of Express, but the difference is that the middleware doesn't get access to the HTTP response object; also, the <code class="literal">parameter</code> signature is different. Therefore, Express middleware cannot be used in Socket.IO.</p><p>An instance of middleware is attached to a specific namespace. Here is a basic example that demonstrates how to register a middleware instance with all namespaces. Place this code in the <code class="literal">Socket.IO</code> file:</p><div class="informalexample"><pre class="programlisting">io.use(function(socket, next) {  
  //request object
  //socket.request
  
  //to reject
  //next(new Error("Reason for reject"));
  
  //to continue
  next();
});</pre></div><p>Here, we can see that we need to use the <code class="literal">io.use()</code> method to register a middleware instance with all namespaces. To attach middleware to the <code class="literal">/custom-namespace</code> namespace, we can use the <code class="literal">nsp.use()</code> method.</p></div><div class="section" title="Disconnecting manually"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Disconnecting manually</h3></div></div></div><p>You can <a id="id213" class="indexterm"/>also manually disconnect a Socket.IO connection. To disconnect from the client side, you need to use the <code class="literal">disconnect()</code> method of the <code class="literal">io</code> instance. To disconnect from the server side, you need to use the <code class="literal">socket.disconnect()</code> method.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we learned the fundamentals of the WebSocket protocol. We learned about its relationship with HTTP and how it behaves with proxies, load balancers, and firewalls. Then, we jumped into the Socket.IO library, which primarily uses WebSocket to achieve bidirectional full-duplex communication in real time. You should be comfortable with implementing bidirectional communication between a browser and a Node.js server.</p><p>In the next chapter, we will build a real-world application using Socket.IO. You will learn more advanced things, such as integrating a Socket.IO server with an Express server and checking authentication before connecting to a WebSocket server.</p></div></body></html>