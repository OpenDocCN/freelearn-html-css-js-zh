- en: Chapter 3. Templating Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。模板引擎
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Rendering Jade templates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 Jade 模板
- en: Using data in a Jade template
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jade 模板中使用数据
- en: Using custom filters in a Jade template
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jade 模板中使用自定义过滤器
- en: Compiling Jade templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 Jade 模板
- en: Compiling Handlebars templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 Handlebars 模板
- en: Compiling Underscore templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 Underscore 模板
- en: Using partials in Handlebars templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Handlebars 模板中使用部分模板
- en: Wrapping Jade templates in AMD modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AMD 模块中包装 Jade 模板
- en: Wrapping Handlebars templates in AMD modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AMD 模块中包装 Handlebars 模板
- en: Wrapping Underscore templates in AMD modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AMD 模块中包装 Underscore 模板
- en: Wrapping Handlebars templates in CommonJS modules
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CommonJS 模块中包装 Handlebars 模板
- en: Altering Jade templates before compilation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译前修改 Jade 模板
- en: Altering Handlebars templates before compilation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译前修改 Handlebars 模板
- en: Altering Underscore templates before compilation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译前修改 Underscore 模板
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The generation of content by combining logic and data poses a unique set of
    problems, and template engines are specifically designed to solve them. In this
    chapter, we'll mostly be focusing on generating HTML using various template engines,
    even though some of them are designed in such a way as to allow for the generation
    of pretty much any type of readable file format.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合逻辑和数据生成内容提出了一系列独特的问题，模板引擎专门设计来解决这些问题。在本章中，我们将主要关注使用各种模板引擎生成 HTML，尽管其中一些设计成允许生成几乎任何类型的可读文件格式。
- en: Even though many of the more feature-rich web application frameworks available
    in the JavaScript community provide for the on-demand compilation, rendering and
    caching of templates, doing so using Grunt provides for the flexibility required
    in building a highly optimized and specialized solution. Templates can be rendered
    directly to HTML or compiled to JSTs that can be used directly without any extra
    processing. The products of these templates can also be packaged to be made available
    in pretty much any environment you might want to use them in.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多功能丰富的 JavaScript 社区中的 Web 应用程序框架都提供了模板的按需编译、渲染和缓存，但使用 Grunt 做到这一点提供了构建高度优化和专用解决方案所需的灵活性。模板可以直接渲染到
    HTML 或编译为 JST，可以直接使用而无需任何额外处理。这些模板的产物也可以打包，以便在几乎任何环境中使用。
- en: At the time of writing, there are many great templating engines available, and
    the majority of them support Grunt by way of plugins, but in this chapter, we'll
    focus on the ones most widely used by the Grunt community.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有许多优秀的模板引擎可供选择，其中大多数都通过插件支持 Grunt，但本章我们将重点关注 Grunt 社区最广泛使用的那些。
- en: Rendering Jade templates
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 Jade 模板
- en: The Jade template engine allows us to easily build and maintain HTML templates
    using its minimal yet familiar syntax. In this recipe, we'll make use of the `contrib-jade
    (0.12.0)` plugin to compile a template that renders a simple HTML page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 模板引擎允许我们使用其最小化且熟悉的语法轻松构建和维护 HTML 模板。在本菜谱中，我们将使用 `contrib-jade (0.12.0)`
    插件来编译一个渲染简单 HTML 页面的模板。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Installing Grunt on a project* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Getting Started with Grunt"), *Getting Started with Grunt*. Be sure
    to refer to it if you are not yet familiar with its contents.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用我们在 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。开始使用 Grunt") 中创建的基本项目结构，即
    *在项目中安装 Grunt* 菜谱，*开始使用 Grunt*。如果您还不熟悉其内容，请务必参考。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following steps will take us through creating a simple Jade template and
    rendering it to an HTML file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们创建一个简单的 Jade 模板并将其渲染为 HTML 文件。
- en: We'll start by installing the package that contains the `contrib-jade` plugin
    as per the instructions provided in the *Installing a plugin* recipe in [Chapter
    1](part0015.xhtml#aid-E9OE1 "Chapter 1. Getting Started with Grunt"), *Getting
    Started with Grunt*.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先按照 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。开始使用 Grunt") 中提供的 *安装插件* 菜谱说明安装包含
    `contrib-jade` 插件的包，*开始使用 Grunt*。
- en: 'Let''s create a simple Jade template called `index.jade` in our project directory,
    and add the following contents:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目目录中创建一个简单的 Jade 模板，命名为 `index.jade`，并添加以下内容：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can add the following `jade` task to our configuration, which will
    compile the `index.jade` file we just created to the `index.html` file in our
    project directory:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在配置中添加以下 `jade` 任务，它将编译我们刚刚创建的 `index.jade` 文件到项目目录中的 `index.html` 文件：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We set the `pretty` option to `true` in this example so that the HTML generated
    from the template can be more readable. This is usually preferred when your project
    is still in development, but is usually not used in production, as enabling this
    option increases the size of the generated files.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `pretty` 选项设置为 `true`，以便从模板生成的 HTML 更易于阅读。当项目仍在开发阶段时，这通常是首选的，但在生产环境中通常不使用此选项，因为启用此选项会增加生成文件的大小。
- en: 'Finally, we can run the task using the `grunt jade` command, which should produce
    output similar to the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt jade` 命令运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we now take a look at our project directory, we should see the new `index.html`
    file with the following contents:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看我们的项目目录，我们应该看到包含以下内容的新的 `index.html` 文件：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using data in a Jade template
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jade 模板中使用数据
- en: Once we've got a Jade template, we can use it to render the same page structure
    with a variety of data. In this recipe, we'll make use of the `contrib-jade (0.12.0)`
    plugin in conjunction with the `data` option to send data that should be used
    in the rendering of the template.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 Jade 模板，我们就可以使用它以各种数据渲染相同的页面结构。在这个食谱中，我们将使用 `contrib-jade (0.12.0)` 插件与
    `data` 选项结合使用，以发送应在模板渲染中使用的数据。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Rendering Jade templates* recipe in this chapter. Be sure to refer to it if you
    are not yet familiar with its contents.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们在本章中 *渲染 Jade 模板* 食谱中创建的基本项目结构。如果您还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through providing data when rendering our template,
    and altering our `index.jade` template to make use of the provided data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导我们在渲染模板时提供数据，并修改我们的 `index.jade` 模板以使用提供的数据。
- en: 'First, we''ll alter our `index.jade` template to make use of the variables
    provided by its context:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修改我们的 `index.jade` 模板，以便使用其上下文提供的变量：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can provide values for the `title` and `body` variables that are to
    be used by the template. This is done by specifying them in the `data` option
    that we''ll add to the configuration of our `jade` task:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为 `title` 和 `body` 变量提供值，这些值将由模板使用。这是通过在配置中添加的 `data` 选项中指定它们来完成的：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can run the task using the `grunt jade` command, which should produce
    output similar to the following:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt jade` 命令运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we now take a look at the `index.html` file that was generated by running
    the task, we''ll find that the variables indicated in the template were replaced
    by the values specified in the `data` option:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看运行任务生成的 `index.html` 文件，我们会发现模板中指示的变量已被 `data` 选项中指定的值所替换：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's usually not a very good idea to keep the data used in a template hardcoded
    in the Grunt configuration, but rather to have it imported from an external data
    source.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，将模板中使用的数据硬编码在 Grunt 配置中并不是一个好主意，而是应该从外部数据源导入。
- en: The following steps take us through creating an external data source and altering
    our configuration so that the data used in rendering our template is loaded from
    it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导我们创建外部数据源并修改我们的配置，以便在渲染模板时使用的数据从中加载。
- en: 'First, we''ll create a file called `data.json` in our project directory, which
    contains the data we wish to use in the rendering of our template:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在项目目录中创建一个名为 `data.json` 的文件，其中包含我们希望在模板渲染中使用的所有数据：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can alter our `jade` task''s configuration to import the data from
    the external source by making use of the `grunt.file.readJSON` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以修改我们的 `jade` 任务配置，通过使用 `grunt.file.readJSON` 方法从外部源导入数据：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we now run the task using the `grunt jade` command, we should have the exact
    same result as in the main recipe.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在使用 `grunt jade` 命令运行任务，我们应该得到与主食谱中完全相同的结果。
- en: Using custom filters in a Jade template
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jade 模板中使用自定义过滤器
- en: The filters provided by the Jade template engine enable us to indicate the method
    that should be used when processing a specific block in a template. This is usually
    used for blocks of content that are written in a format other than the Jade language
    itself. As an example, the `coffee` and `markdown` filters provided by the Jade
    library provide the rendering of **CoffeeScript** code into JavaScript and **Markdown**
    content into HTML.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Jade模板引擎提供的过滤器使我们能够指定在处理模板中的特定块时应使用的方法。这通常用于以Jade语言本身之外的其他格式编写的块内容。例如，Jade库提供的`coffee`和`markdown`过滤器可以将**CoffeeScript**代码渲染成JavaScript，将**Markdown**内容渲染成HTML。
- en: In this recipe, we'll make use of the `contrib-jade (0.12.0)` plugin in conjunction
    with its `filters` option to make a custom filter called `link` available to us
    in our templates. This filter will use a simplistic algorithm to find URLs and
    surround them with an anchor tag, turning them into links.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`contrib-jade (0.12.0)`插件及其`filters`选项，使我们能够在模板中访问一个名为`link`的自定义过滤器。此过滤器将使用一个简单的算法来查找URL并将它们包裹在锚标签中，从而将它们转换为链接。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Rendering Jade templates* recipe of this chapter. Be sure to refer to it if you
    are not yet familiar with its contents.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们在本章*渲染Jade模板*菜谱中创建的基本项目结构。如果您还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through adding the `link` custom filter and altering
    our `index.jade` template to make use of it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导我们添加`link`自定义过滤器并修改我们的`index.jade`模板以使用它。
- en: 'First, we''ll add the `link` custom filter to our configuration by using the
    `filters` option in the `jade` task we configured before:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过使用之前配置的`jade`任务中的`filters`选项来添加`link`自定义过滤器到我们的配置中：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can alter the contents of our `index.jade` template to make use of
    our `link` custom filter:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以修改我们的`index.jade`模板的内容，以使用我们的`link`自定义过滤器：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we can run the task using the `grunt jade` command, which should produce
    output similar to the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`grunt jade`命令运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we now take a look at the `index.html` file that was generated by running
    the task, we''ll find that it has surrounded the link we had inside the block
    provided to the `link` filter with an anchor tag:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看由运行任务生成的`index.html`文件，我们会发现它已经用锚标签包围了我们提供给`link`过滤器的块内的链接：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compiling Jade templates
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译Jade模板
- en: When building a web application that needs to render HTML templates on the frontend
    in as little time as possible, the compiling templates become essential. The Jade
    templating engine allows us to compile our templates to **JavaScript Templates**
    (**JSTs**) for use on the frontend.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个需要在尽可能短的时间内在前端渲染HTML模板的Web应用程序时，编译模板变得至关重要。Jade模板引擎允许我们将模板编译成用于前端的**JavaScript模板**（**JSTs**）。
- en: In this recipe, we'll make use of the `contrib-jade (0.12.0)` plugin to compile
    a template that renders a minimalistic blog.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`contrib-jade (0.12.0)`插件来编译一个渲染简约博客的模板。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Installing Grunt on a project* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Getting Started with Grunt"), *Getting Started with Grunt*. Be sure
    to refer to it if you are not yet familiar with its contents.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们在[第1章](part0015.xhtml#aid-E9OE1 "第1章。开始使用Grunt")中*在项目中安装Grunt*菜谱中创建的基本项目结构。如果您还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through creating a simple Jade template and compiling
    it to a JST contained in another file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导我们创建一个简单的Jade模板并将其编译成包含在其他文件中的JST。
- en: We'll start by installing the package that contains the `contrib-jade` plugin
    as per the instructions provided in the *Installing a plugin* recipe in [Chapter
    1](part0015.xhtml#aid-E9OE1 "Chapter 1. Getting Started with Grunt"), *Getting
    Started with Grunt*.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按照[第1章](part0015.xhtml#aid-E9OE1 "第1章。开始使用Grunt")中*安装插件*菜谱中提供的说明来安装包含`contrib-jade`插件的包，该菜谱位于*开始使用Grunt*。
- en: 'Let''s create a simple Jade template file called `blog.jade` in our project
    directory and give it the following contents:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目目录中创建一个名为`blog.jade`的简单Jade模板文件，并给它以下内容：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can add the following `jade` task to our configuration, which will
    compile the `blog.jade` template into a JST contained inside the `templates.js`
    file of our project directory:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将以下 `jade` 任务添加到我们的配置中，它将 `blog.jade` 模板编译成包含在我们项目目录的 `templates.js`
    文件中的 JST：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can run the task using the `grunt jade` command, which should produce
    output similar to the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt jade` 命令来运行任务，它应该会产生类似于以下内容的输出：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We should now have a new file called `templates.js` in our project directory
    that contains the JST code for our compiled template.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该在项目目录中有一个名为 `templates.js` 的新文件，其中包含我们编译模板的 JST 代码。
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following steps demonstrate the usage template of the compiled and display
    an example of the rendered result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了编译模板的使用示例，并展示了一个渲染结果的示例。
- en: First, you'll need to include the Jade runtime library in the application or
    page in which you'd like to make use of the compiled templates.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要将 Jade 运行时库包含到您希望使用编译模板的应用程序或页面中。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At the time of writing, the Jade runtime library was available at the root
    of the official Jade repository and could be downloaded from the following URL:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，Jade 运行时库位于官方 Jade 仓库的根目录，可以通过以下网址下载：
- en: '[https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js](https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js](https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js)'
- en: Then, you'll need to include the `templates.js` file that was generated by the
    `jade` task in the application or page to make the `JST` global variable that
    contains the templates available.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要将 `jade` 任务生成的 `templates.js` 文件包含到应用程序或页面中，以便使包含模板的 `JST` 全局变量可用。
- en: 'The following example code will render the compiled template, using some sample
    data and store the result in the `result` variable:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例代码将渲染编译后的模板，使用一些样本数据并将结果存储在 `result` 变量中：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result` 变量现在应该包含以下 HTML：'
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `jade` task provides some useful options in conjunction with the basic compilation
    of templates that allows us to specify the namespace of compiled templates, indicate
    how template names should be derived from their filenames, and compile templates
    with debug support.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`jade` 任务在基本模板编译的基础上提供了一些有用的选项，允许我们指定编译模板的命名空间，指示模板名称应该如何从文件名中派生，以及带有调试支持的模板编译。'
- en: Specifying the namespace of compiled templates
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定编译模板的命名空间
- en: 'By default, compiled templates are stored in the `JST` namespace, but this
    can be changed to anything we like, by using the `namespace` option. In the following
    example, we configure the task to store templates in the `Templates` namespace:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译后的模板存储在 `JST` 命名空间中，但可以通过使用 `namespace` 选项将其更改为任何我们喜欢的名称。在以下示例中，我们配置任务将模板存储在
    `Templates` 命名空间中：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Indicating how template names should be derived from filenames
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指示模板名称应该如何从文件名中派生
- en: 'The `processName` option can be used to indicate how the names under which
    templates are to be stored in the namespace should be derived from their filenames.
    The default behavior of the `jade` task is to use everything before the file''s
    extension. In the following example, we indicate that the entire filename should
    be in uppercase:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `processName` 选项来指示模板在命名空间中存储的名称应该如何从文件名中派生。`jade` 任务的默认行为是使用文件扩展名之前的所有内容。在以下示例中，我们指示整个文件名应该全部大写：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compiling templates with debug support
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有调试支持的模板编译
- en: 'The Jade template engine provides extra debug support for compiled templates,
    which can be enabled by way of the `compileDebug` option, as it is in the following
    example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 模板引擎为编译后的模板提供了额外的调试支持，可以通过 `compileDebug` 选项启用，如下例所示：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compiling Handlebars templates
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Handlebars 模板
- en: The Handlebars template engine simplifies the building and maintaining of any
    markup or other readable files. Its familiar syntax, extensibility, and logic-less
    approach provides a great all-round template building experience. The engine is
    focused mainly on compiling templates to JSTs that are mostly used in the frontend
    of a web application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 模板引擎简化了任何标记或其他可读文件的构建和维护。它熟悉的语法、可扩展性和无逻辑的方法提供了一个全面的模板构建体验。该引擎主要关注将模板编译成在
    Web 应用程序前端广泛使用的 JST。
- en: In this recipe, we'll make use of the `contrib-handlebars (0.8.0)` plugin to
    compile a template that renders a minimalistic blog.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `contrib-handlebars (0.8.0)` 插件来编译一个渲染简约博客的模板。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Installing Grunt on a project* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Getting Started with Grunt"), *Getting Started with Grunt*. Be sure
    to refer to it if you are not yet familiar with its contents.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们在 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。使用 Grunt 开始") 中创建的基本项目结构，即
    [在项目中安装 Grunt](part0015.xhtml#aid-E9OE1 "第 1 章。使用 Grunt 开始") 菜谱。如果您还不熟悉其内容，请务必参考。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through creating a simple Handlebars template and
    setting up Grunt to compile it to a JST contained in another file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们创建一个简单的 Handlebars 模板，并设置 Grunt 以将其编译到另一个文件中包含的 JST。
- en: We'll start by installing the package that contains the `contrib-handlebars`
    plugin as per the instructions provided in the *Installing a plugin* recipe in
    [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Getting Started with Grunt"),
    *Getting Started with Grunt*.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按照 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。使用 Grunt 开始") 中提供的 *安装插件* 菜谱中的说明安装包含
    `contrib-handlebars` 插件的包。
- en: 'Let''s create a simple Handlebars template file called `blog.hbs` in our project
    directory and give it the following contents:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目目录中创建一个简单的 Handlebars 模板文件，命名为 `blog.hbs`，并给它以下内容：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can add the following `handlebars` task to our configuration, which
    will compile the `post.hbs` template into a JST contained inside the `templates.js`
    file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在配置中添加以下 `handlebars` 任务，该任务将 `post.hbs` 模板编译到 `templates.js` 文件中的 JST
    内：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can run the task using the `grunt handlebars` command, which should
    produce output similar to the following:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt handlebars` 命令运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We should now have a new file called `templates.js` in our project directory
    that contains the JST code for our compiled template.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该在项目目录中有一个名为 `templates.js` 的新文件，其中包含编译模板的 JST 代码。
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following steps demonstrate the usage of the compiled template and display
    an example of the rendered result.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了编译模板的使用方法，并显示了渲染结果的示例。
- en: First, you'll need to include the Handlebars runtime library in the application
    or page in which you'd like to make use of the compiled templates.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要将 Handlebars 运行时库包含到您想要使用编译模板的应用程序或页面中。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At the time of writing, the Handlebars runtime library could be downloaded
    from the following URL:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，Handlebars 运行时库可以从以下 URL 下载：
- en: '[http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js)'
- en: Then, you'll need to include the `templates.js` file that was generated by the
    `handlebars` task in the application or page to create the `JST` global variable
    that contains the templates available.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要将由 `handlebars` 任务生成的 `templates.js` 文件包含到应用程序或页面中，以创建包含模板的 `JST` 全局变量。
- en: 'The following example code will render the compiled template, using some sample
    data and store the result in the `result` variable:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例代码将使用一些样本数据渲染编译后的模板，并将结果存储在 `result` 变量中：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result` 变量现在应该包含以下 HTML：'
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `handlebars` task provides some useful options in conjunction with the basic
    compilation of templates which allows us to specify the namespace for compiled
    templates and indicate how template names should be derived from their filenames.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlebars` 任务在基本模板编译的同时提供了一些有用的选项，允许我们指定编译模板的命名空间，并指示模板名称应该如何从它们的文件名中派生。'
- en: Specifying the namespace for compiled templates
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定编译模板的命名空间
- en: 'By default, compiled templates are stored in the `JST` namespace, but this
    can be changed to anything we like, by using the `namespace` option. In the following
    example, we configure the task to store templates in the `Templates` namespace:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译后的模板存储在 `JST` 命名空间中，但可以通过使用 `namespace` 选项将其更改为任何我们喜欢的名称。在以下示例中，我们配置任务以将模板存储在
    `Templates` 命名空间中：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Indicating how template names should be derived from file names
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指示模板名称应该如何从文件名中派生
- en: 'The `processName` option can be used to indicate how the names under which
    templates are to be stored in the namespace should be derived from their file
    names. The default behavior of the `handlebars` task is to use the entire filename.
    In the following example, we indicate that it should still use the file name,
    but in uppercase letters:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`processName` 选项可用于指示模板在命名空间中存储的名称应如何从其文件名派生。`handlebars` 任务的默认行为是使用整个文件名。在以下示例中，我们指示它仍然使用文件名，但以大写字母形式：'
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Compiling Underscore templates
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Underscore 模板
- en: Along with the many utilities it provides, the Underscore library also includes
    a simple, fast, and flexible templating engine. These templates are most commonly
    compiled to JSTs for use in the frontend of a web application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供的许多实用工具外，Underscore 库还包括一个简单、快速且灵活的模板引擎。这些模板通常编译为 JST 以在 Web 应用程序的前端使用。
- en: In this recipe, we'll make use of the `contrib-jst (0.6.0)` plugin to compile
    a template that renders a minimalistic blog.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `contrib-jst (0.6.0)` 插件来编译一个渲染简约博客的模板。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Installing Grunt on a project* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Getting Started with Grunt"), *Getting Started with Grunt*. Be sure
    to refer to it if you are not yet familiar with its contents.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用我们在 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。使用 Grunt 入门") 中 *在项目中安装
    Grunt* 菜谱中创建的基本项目结构。如果您还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through creating a simple Underscore template and
    compiling it to a JST contained in another file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们创建一个简单的 Underscore 模板并将其编译到另一个文件中的 JST 中。
- en: We'll start by installing the package that contains the `contrib-jst` plugin
    as per the instructions provided in the *Installing a plugin* recipe in [Chapter
    1](part0015.xhtml#aid-E9OE1 "Chapter 1. Getting Started with Grunt"), *Getting
    Started with Grunt*.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按照 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。使用 Grunt 入门") 中 *安装插件* 菜谱提供的说明，安装包含
    `contrib-jst` 插件的包。
- en: 'Let''s create a simple Underscore template file called `blog.html` in our project
    directory and give it the following contents:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目目录中创建一个简单的 Underscore 模板文件，命名为 `blog.html`，并给它以下内容：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can add the following `jst` task to our configuration, which will compile
    the `blog.html` template into a JST contained inside the `templates.js` file in
    our project directory:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将以下 `jst` 任务添加到我们的配置中，该任务将 `blog.html` 模板编译到我们项目目录中的 `templates.js` 文件中：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we can run the task using the `grunt jst` command, which should produce
    output similar to the following:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt jst` 命令运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We should now have a new file called `templates.js` in our project directory,
    which contains the JST code for our compiled template.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在我们的项目目录中有一个名为 `templates.js` 的新文件，其中包含我们编译模板的 JST 代码。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following steps demonstrate the usage of the compiled template and display
    an example of the rendered result.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了编译模板的使用，并显示了一个渲染结果的示例。
- en: First, you'll need to include the Underscore runtime library in the application
    or page in which you'd like to make use of the compiled templates.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要在希望使用编译模板的应用程序或页面中包含 Underscore 运行时库。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'At the time of writing, the Underscore runtime library could be downloaded
    from the following URL:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，可以从以下 URL 下载 Underscore 运行时库：
- en: '[http://underscorejs.org/underscore-min.js](http://underscorejs.org/underscore-min.js)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://underscorejs.org/underscore-min.js](http://underscorejs.org/underscore-min.js)'
- en: Then, you'll need to include the `templates.js` file that was generated by the
    `jst` task in the application or page to make the `JST` global variable that contains
    the templates available.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要将 `jst` 任务生成的 `templates.js` 文件包含到应用程序或页面中，以便使包含模板的 `JST` 全局变量可用。
- en: 'The following example code will render the compiled template, using some sample
    data and store the result in the `result` variable:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例代码将渲染编译后的模板，使用一些示例数据并将结果存储在 `result` 变量中：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result` 变量现在应包含以下 HTML：'
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `jst` task provides some useful options in conjunction with the basic compilation
    of templates which allows us to specify the namespace for compiled templates and
    indicate how template names should be derived from their file names.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`jst` 任务在基本模板编译的同时提供了一些有用的选项，允许我们指定编译模板的命名空间并指示模板名称应如何从其文件名派生。'
- en: Specifying the namespace for compiled templates
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定编译模板的命名空间
- en: 'By default, compiled templates are stored in the `JST` namespace, but this
    can be changed to anything we like, by using the `namespace` option. In the following
    example, we configure the task to store templates in the `Templates` namespace:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译后的模板存储在 `JST` 命名空间中，但可以通过使用 `namespace` 选项将其更改为我们喜欢的任何内容。在以下示例中，我们配置任务将模板存储在
    `Templates` 命名空间中：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Indicating how template names should be derived from file names
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指示模板名称应如何从文件名派生
- en: 'The `processName` option can be used to indicate how the names under which
    templates are to be stored in the namespace should be derived from their file
    names. The default behavior of the `jst` task is to use the entire file name.
    In the following example, we indicate that it should still use the file name,
    but in uppercase letters:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `processName` 选项来指示模板在命名空间中存储时应使用的名称应如何从其文件名派生。`jst` 任务的默认行为是使用整个文件名。在以下示例中，我们指示它仍然使用文件名，但使用大写字母：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using partials in Handlebars templates
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Handlebars 模板中使用部分
- en: The partials system provided by the Handlebars templating engine allows us to
    reuse smaller bits of template code in varying contexts. Whenever you see a pattern
    repeated at different points in your template, it's probably a good opportunity
    to make use of a partial.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 模板引擎提供的部分系统允许我们在不同的上下文中重用较小的模板代码片段。每当你在模板的不同位置看到重复的模式时，这可能是一个使用部分的好机会。
- en: In this recipe, we'll make use of the `contrib-handlebars (0.8.0)` plugin and
    its partial template loading functionality to render posts with a similar structure
    in two different sections of a blog.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用 `contrib-handlebars (0.8.0)` 插件及其部分模板加载功能，在博客的两个不同部分中渲染具有类似结构的帖子。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Handlebars templates* recipe of this chapter. Be sure to refer to it
    if you are not yet familiar with its contents.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用本章中 *编译 Handlebars 模板* 菜单中创建的基本项目结构。如果你还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through creating a post partial template and altering
    our blog template so that it renders a new and old section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导我们创建一个帖子部分模板并修改我们的博客模板，以便渲染新的和旧的章节。
- en: 'By default, the `handlebars` task identifies a template starting with an underscore
    as a partial template and loads it. Let''s create a file called `_post.hbs` in
    our project directory, which will contain our partial post template:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`handlebars` 任务将以下划线开头的模板识别为部分模板并加载。让我们在我们的项目目录中创建一个名为 `_post.hbs` 的文件，它将包含我们的部分帖子模板：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we''ll alter the configuration of the task by adding the new partial template''s
    filename to the list of templates that should be included in the task:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过将新部分模板的文件名添加到任务应包含的模板列表中来修改任务的配置：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the partial template is set up to be included, we can alter our `blog.hbs`
    template to make use of it. Let''s change it so that it renders a new and old
    section:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置好部分模板以便包含，我们就可以修改我们的 `blog.hbs` 模板以使用它。让我们修改它以渲染新的和旧的章节：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we can run the task using the `grunt handlebars` command, which should
    produce output similar to the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt handlebars` 命令运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We should now have a modified version of the `templates.js` file in our project
    directory, which contains the JST code for our latest blog template.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在我们的项目目录中有一个修改后的 `templates.js` 文件版本，其中包含我们最新博客模板的 JST 代码。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following steps demonstrate the usage of the compiled template and display
    an example of the rendered result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了编译模板的使用并显示了一个渲染结果的示例。
- en: First, you'll need to include the Handlebars runtime library in the application
    or page in which you'd like to make use of the compiled templates.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要在希望使用编译模板的应用程序或页面中包含 Handlebars 运行时库。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At the time of writing, the Handlebars runtime library could be downloaded
    from the following URL:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，Handlebars运行时库可以从以下URL下载：
- en: '[http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js)'
- en: Then, you'll need to include the `templates.js` file that was generated by the
    `handlebars` task in the application or page to make the `JST` global variable
    that contains the templates available.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要将`handlebars`任务生成的`templates.js`文件包含在应用程序或页面中，以便使包含模板的`JST`全局变量可用。
- en: 'The following example code will render the compiled template, using some sample
    data and store the result in the `result` variable:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例代码将渲染编译后的模板，使用一些示例数据并将结果存储在`result`变量中：
- en: '[PRE40]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result`变量现在应包含以下HTML：'
- en: '[PRE41]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `handlebars` task provides some useful options in conjunction with the loading
    of partial templates that allow us to make partials available in the namespace,
    indicate how partial templates should be identified, and also indicate how partial
    template names should be derived.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlebars`任务提供了一些有用的选项，与部分模板的加载结合使用，允许我们在命名空间中使部分模板可用，指示部分模板应该如何识别，以及指示部分模板名称应该如何推导。'
- en: Making partials available in the namespace
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在命名空间中使部分模板可用
- en: 'In the case that we''d like to make use of partial templates directly in our
    code and not just in our other templates, we can make them available in the namespace
    along with the other templates by using the `partialsUseNamespace` option as we
    do in the following example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在代码中直接使用部分模板，而不仅仅是其他模板中，我们可以通过使用`partialsUseNamespace`选项，就像以下示例中那样，在命名空间中使它们与其他模板一起可用：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Indicating how partial templates should be identified
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指示如何识别部分模板
- en: 'We''ll probably reach the point where we would like to change the way partial
    templates are identified. This can be done using a combination of the `partialRegex`
    and `partialsPathRegex` options. The following example indicates that all templates
    found in the `partials` directory should be loaded as partials:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会达到想要更改部分模板识别方式的地步。这可以通过组合使用`partialRegex`和`partialsPathRegex`选项来完成。以下示例表明，所有在`partials`目录中找到的模板都应该被加载为部分模板：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Indicating how partial template names should be derived
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指示如何推导部分模板的名称
- en: 'By default, the `handlebars` task removes the preceding underscore and file
    extension from partial file names to determine their names. The following example
    makes use of the `processPartialName` option to indicate that the entire file
    name should be uppercased before use:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`handlebars`任务会从部分文件名中移除前导下划线和文件扩展名，以确定其名称。以下示例使用`processPartialName`选项来指示在使用之前应将整个文件名转换为大写：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wrapping Jade templates in AMD modules
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Jade模板包裹在AMD模块中
- en: In this recipe, we'll make use of the `contrib-jade (0.12.0)` plugin and its
    `amd` option to wrap our compiled blog template in an **Asynchronous Module Definition**
    (**AMD**) module.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用`contrib-jade (0.12.0)`插件及其`amd`选项来将我们的编译后的博客模板包裹在一个**异步模块定义**（**AMD**）模块中。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Jade templates* recipe of this chapter. Be sure to refer to it if you
    are not yet familiar with its contents.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用本章中“编译Jade模板”食谱中创建的基本项目结构。如果你还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following steps take us through altering our configuration so that it wraps
    our compiled templates in an AMD module.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们修改配置，以便它将编译后的模板包裹在一个AMD模块中。
- en: 'First, we''ll alter the configuration by adding the `amd` option to indicate
    that the compiled templates should be wrapped in an AMD module:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过添加`amd`选项来修改配置，以指示编译后的模板应该被包裹在一个AMD模块中：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using the `namespace` option, we can now also specify that we no longer want
    the compiled templates to be contained within the `JST` namespace, since they
    will now be contained within their own module:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`namespace`选项，我们现在也可以指定不再希望编译后的模板包含在`JST`命名空间中，因为它们现在将包含在自己的模块中：
- en: '[PRE46]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can now also compile the template to a different file name, as each template
    will now be represented by its own file:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还可以将模板编译为不同的文件名，因为每个模板现在将代表其自己的文件：
- en: '[PRE47]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we can run the task using the `grunt jade` command, which should produce
    output similar to the following:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt jade` 命令来运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE48]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There should now be a `blog.js` file located in the project directory that contains
    the compiled template wrapped in an AMD module.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该在项目目录中有一个名为 `blog.js` 的文件，该文件包含了一个用 AMD 模块包裹的编译后的模板。
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following steps demonstrate the usage of the compiled and wrapped template
    and display an example of the rendered result.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了编译后包裹的模板的使用方法，并显示了渲染结果的示例。
- en: First, you'll need to ensure that the AMD framework you have in place has access
    to the Jade runtime library under the name `jade`. This may require the configuration
    of the AMD framework to be altered.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要确保你现有的 AMD 框架能够访问名为 `jade` 的 Jade 运行时库。这可能需要修改 AMD 框架的配置。
- en: Tip
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At the time of writing, the Jade runtime library was available in the root
    of the official Jade repository and could be downloaded from the following URL:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，Jade 运行时库可在官方 Jade 仓库的根目录下找到，并且可以从以下 URL 下载：
- en: '[https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js](https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js](https://raw.githubusercontent.com/jadejs/jade/1.11.0/runtime.js)'
- en: Then, you'll need to make sure that the `blog.js` file that was generated by
    the `jade` task is accessible to the AMD framework under whichever name or path
    you prefer.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要确保由 `jade` 任务生成的 `blog.js` 文件能够被 AMD 框架访问，无论你更喜欢哪个名称或路径。
- en: 'The following example code will fetch the compiled template as a dependency,
    render the compiled template using some sample data, and then proceed to store
    the result in the `result` variable:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例代码将获取编译后的模板作为依赖项，使用一些示例数据渲染编译后的模板，然后将结果存储在 `result` 变量中：
- en: '[PRE49]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result` 变量现在应该包含以下 HTML：'
- en: '[PRE50]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Wrapping Handlebars templates in AMD modules
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AMD 模块中包裹 Handlebars 模板
- en: In this recipe, we'll make use of the `contrib-handlebars (0.8.0)` plugin and
    its `amd` option to wrap our compiled blog template in an AMD module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `contrib-handlebars (0.8.0)` 插件及其 `amd` 选项来将编译后的博客模板包裹在 AMD 模块中。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Handlebars templates* recipe of this chapter. Be sure to refer to it
    if you are not yet familiar with its contents.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用本章中 *编译 Handlebars 模板* 菜谱中创建的基本项目结构。如果你还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The following steps take us through altering our configuration so that it wraps
    our compiled templates in an AMD module.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们修改配置，以便将编译后的模板包裹在 AMD 模块中。
- en: 'First, we''ll alter the configuration by adding the `amd` option to indicate
    that the compiled templates should be wrapped in an AMD module:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过添加 `amd` 选项来修改配置，以指示编译后的模板应该被包裹在 AMD 模块中：
- en: '[PRE51]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the `namespace` option, we can now also specify that we no longer want
    the compiled templates to be contained within the `JST` namespace, since they
    will now be contained within their own module:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `namespace` 选项，我们现在也可以指定我们不再希望编译后的模板包含在 `JST` 命名空间中，因为它们现在将包含在自己的模块中：
- en: '[PRE52]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can now also compile the template to a different file name, as each template
    will now be represented by its own file:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在也可以将模板编译到不同的文件名中，因为每个模板现在都将由其自己的文件表示：
- en: '[PRE53]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we can run the task using the `grunt handlebars` command, which should
    produce output similar to the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt handlebars` 命令来运行任务，它应该产生类似于以下内容的输出：
- en: '[PRE54]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There should now be a `blog.js` file located in the project directory, which
    contains the compiled template wrapped in an AMD module.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该在项目目录中有一个名为 `blog.js` 的文件，该文件包含了一个用 AMD 模块包裹的编译后的模板。
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following steps demonstrate the usage of the compiled and wrapped template
    and display an example of the rendered result.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了编译后包裹的模板的使用方法，并显示了渲染结果的示例。
- en: First, you'll need to ensure that the AMD framework you have in place has access
    to the Handlebars runtime library under the `handlebars` name. This may require
    the configuration of the AMD framework to be altered.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要确保你现有的 AMD 框架能够访问名为 `handlebars` 的 Handlebars 运行时库。这可能需要修改 AMD 框架的配置。
- en: Tip
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At the time of writing, the Handlebars runtime library could be downloaded
    from the following URL:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v1.3.0.js)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the case of the runtime library mentioned in this tip, you will have to
    make use of a shim as the library is not prepared for use with AMD modules. You
    can read more about shimming using the RequireJS framework at the following URL:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://requirejs.org/docs/api.html#config-shim](http://requirejs.org/docs/api.html#config-shim)'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, you'll need to make sure that the `blog.js` file that was generated by
    the `handlebars` task is accessible to the AMD framework under whichever name
    or path you prefer.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example code will fetch the compiled template as a dependency,
    render the compiled template using some sample data, and then proceed to store
    the result in the `result` variable:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Wrapping Underscore templates in AMD modules
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll make use of the `contrib-jst (0.6.0)` plugin and its `amd`
    option to wrap our compiled blog template in an AMD module.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Underscore templates* recipe of this chapter. Be sure to refer to it
    if you are not yet familiar with its contents.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps take us through altering our configuration so that it wraps
    our compiled template in an AMD module.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll alter the configuration by adding the `amd` option to indicate
    that the compiled templates should be wrapped in an AMD module:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using the `namespace` option, we can now also specify that we no longer want
    the compiled templates to be contained within the `JST` namespace, since they
    will now be contained within their own module:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can now also compile the template to a different filename, as each template
    will now be located inside its own file:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we can run the task using the `grunt jst` command, which should produce
    output similar to the following:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There should now be a `blog.js` file located in the project directory that contains
    the compiled template wrapped in an AMD module.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps demonstrate the usage of the compiled and wrapped template
    and display an example of the rendered result.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need to ensure that the AMD framework you have in place loads
    the Underscore library on startup, since the wrappers created by this plugin don't
    reference it as a dependency.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing, the Underscore runtime library could be downloaded
    from the following URL:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://underscorejs.org/underscore-min.js](http://underscorejs.org/underscore-min.js)'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can read more about specifying startup dependencies on the RequireJS framework
    at the following URL:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://requirejs.org/docs/api.html#config-deps](http://requirejs.org/docs/api.html#config-deps)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, you'll need to make sure that the `blog.js` file that was generated by
    the `jst` task is accessible to the AMD framework under whichever name or path
    you prefer.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要确保由 `jst` 任务生成的 `blog.js` 文件可以在你喜欢的任何名称或路径下被 AMD 框架访问。
- en: 'The following example code will fetch the compiled template as a dependency,
    render the compiled template using some sample data, and then proceed to store
    the result in the `result` variable:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例代码将获取编译后的模板作为依赖项，使用一些示例数据渲染编译后的模板，然后将结果存储在 `result` 变量中：
- en: '[PRE61]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result` 变量现在应包含以下 HTML：'
- en: '[PRE62]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Wrapping Handlebars templates in CommonJS modules
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CommonJS 模块中包装 Handlebars 模板
- en: In this recipe, we'll make use of the `contrib-handlebars (0.8.0)` plugin to
    wrap our compiled blog template in a **CommonJS** module.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `contrib-handlebars (0.8.0)` 插件将编译后的博客模板包装在一个 **CommonJS** 模块中。
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Handlebars templates* recipe of this chapter. Be sure to refer to it
    if you are not yet familiar with its contents.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用本章中 *编译 Handlebars 模板* 菜谱中创建的基本项目结构。如果你还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through altering our configuration so that it wraps
    our compiled template in a CommonJS module.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们修改配置，以便将编译后的模板包装在 CommonJS 模块中。
- en: First, we'll alter the configuration by adding the `amd` option to indicate
    that the compiled templates should be wrapped in a CommonJS module.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过添加 `amd` 选项来修改配置，表示编译后的模板应该被包装在 CommonJS 模块中。
- en: '[PRE63]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using the `namespace` option, we can now also specify that we no longer want
    the compiled templates to be contained within the `JST` namespace, since they
    will now be contained within a module:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `namespace` 选项，我们现在也可以指定不再希望编译后的模板包含在 `JST` 命名空间中，因为它们现在将包含在一个模块中：
- en: '[PRE64]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we can run the task using the `grunt handlebars` command, which should
    produce output similar to the following:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `grunt handlebars` 命令运行任务，它应该产生类似以下输出：
- en: '[PRE65]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: There should now be a `templates.js` file located in the project directory that
    contains the compiled template wrapped in a CommonJS module.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在项目目录中应该有一个 `templates.js` 文件，其中包含包装在 CommonJS 模块中的编译后的模板。
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 他是如何工作的...
- en: The following steps demonstrate the usage of the compiled and wrapped template
    and display an example of the rendered result.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了编译和包装模板的使用方法，并显示了渲染结果的示例。
- en: First, we'll have to ensure that the Handlebars library is installed in the
    current CommonJS supporting environment. Using Node.js as an example, the module
    will have to be installed using the `npm install handlebars` command.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须确保 Handlebars 库已安装在本地的 CommonJS 支持环境中。以 Node.js 为例，模块必须使用 `npm install
    handlebars` 命令安装。
- en: 'Next, we will have to make it available in the piece of code that we''ll be
    importing the templates into, by using code similar to the following:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用类似以下代码的方式，使代码片段中的模板可用，我们将导入模板：
- en: '[PRE66]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we''ll need to import the templates into our code and pass it to the
    Handlebars library by using code similar to the following:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要将模板导入到我们的代码中，并通过使用类似以下代码的方式将其传递给 Handlebars 库：
- en: '[PRE67]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Tip
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This bit of code assumes that the generated `templates.js` file is on the same
    path as the file containing the piece of code we're currently working on.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码假设生成的 `templates.js` 文件与当前正在工作的代码文件位于同一路径上。
- en: 'Now that we''ve imported the templates, we can make use of them. The following
    example renders the `blog.hbs` templates and stores the results in the `result`
    variable:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了模板，我们可以使用它们。以下示例渲染了 `blog.hbs` 模板，并将结果存储在 `result` 变量中：
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `result` variable should now contain the following HTML:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result` 变量现在应包含以下 HTML：'
- en: '[PRE69]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Altering Jade templates before compilation
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译前修改 Jade 模板
- en: There might come a time that you would want to alter the contents of a template
    before compiling or rendering it. This is most commonly required when you would
    like to remove excessive white space from templates, or if you'd like to remove
    or replace parts of a template you have no control over.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想在编译或渲染模板之前修改模板的内容。这通常是在你想要从模板中移除过多的空白空间，或者如果你想移除或替换你无法控制的模板部分时所需的。
- en: In this recipe, we'll make use of the `contrib-jade (0.12.0)` plugin and the
    `processContent` option provided by its `jade` task to remove whitespace from
    our templates before rendering them to HTML.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将利用 `contrib-jade (0.12.0)` 插件及其 `jade` 任务提供的 `processContent` 选项，在将模板渲染为
    HTML 之前从我们的模板中移除空白字符。
- en: Getting ready
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Jade templates* recipe of this chapter. Be sure to refer to it if you
    are not yet familiar with its contents.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用本章中 *编译 Jade 模板* 菜谱中创建的基本项目结构。如果您还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through altering our configuration so that excessive
    whitespace is removed from our templates before rendering them to HTML.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们修改配置，以便在将模板渲染为 HTML 之前从模板中移除过多的空白字符。
- en: 'First, we can provide an empty function to the `processContent` option that
    receives the content of the template and passes it through without altering it:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以向 `processContent` 选项提供一个空函数，该函数接收模板的内容并将其传递而不进行修改：
- en: '[PRE70]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we can alter the code of the function provided to `processContent` so
    that it removes all of the trailing whitespace from the template''s content:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以修改提供给 `processContent` 的函数的代码，以便从模板的内容中移除所有尾随空白字符：
- en: '[PRE71]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we now run the task using the `grunt jade` command, we will see output similar
    to the following:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在使用 `grunt jade` 命令运行任务，我们将看到以下类似的输出：
- en: '[PRE72]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The rendered result in the `index.html` file should now display no signs of
    any of the trailing whitespace that was present in the original template.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index.html` 文件中显示的渲染结果现在不应显示任何原始模板中存在的尾随空白字符的迹象。
- en: Altering Handlebars templates before compilation
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译 Handlebars 模板之前进行修改
- en: Although not very common, there might come a time that you would want to alter
    the contents of a template before compiling or rendering it. This is most commonly
    required when you would like to remove excessive whitespace from templates, or
    if you'd like to remove or replace certain parts of a template you have no control
    over.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种情况并不常见，但可能会有这样的时候，您希望在编译或渲染模板之前修改模板的内容。这通常是在您希望从模板中移除过多的空白字符，或者如果您想移除或替换您无法控制的模板的某些部分时所需的。
- en: In this recipe, we'll make use of the `contrib-handlebars (0.8.0)` plugin and
    the `processContent` option provided by its `handlebars` task to remove whitespace
    from our templates before compiling them.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将利用 `contrib-handlebars (0.8.0)` 插件及其 `handlebars` 任务提供的 `processContent`
    选项，在编译模板之前从我们的模板中移除空白字符。
- en: Getting ready
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Handlebars templates* recipe of this chapter. Be sure to refer to it
    if you are not yet familiar with its contents.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用本章中 *编译 Handlebars 模板* 菜谱中创建的基本项目结构。如果您还不熟悉其内容，请务必参考它。
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps take us through altering our configuration so that excessive
    whitespace is removed from our templates before compiling them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导我们修改配置，以便在编译模板之前从模板中移除过多的空白字符。
- en: 'First, we can provide an empty function to the `processContent` option that
    receives the content of the template and passes it through without altering it:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以向 `processContent` 选项提供一个空函数，该函数接收模板的内容并将其传递而不进行修改：
- en: '[PRE73]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we can alter the code of the function provided to `processContent` so
    that it removes all of the leading and trailing whitespace from the template''s
    content:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以修改提供给 `processContent` 的函数的代码，以便从模板的内容中移除所有前导和尾随空白字符：
- en: '[PRE74]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we now run the task using the `grunt handlebars` command, we should see
    output similar to the following:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在使用 `grunt handlebars` 命令运行任务，我们应该看到以下类似的输出：
- en: '[PRE75]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The compiled result in the `templates.js` file should now display no signs of
    any of the trailing whitespace that was present in the original template.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `templates.js` 文件中显示的编译结果现在不应显示任何原始模板中存在的尾随空白字符的迹象。
- en: Altering Underscore templates before compilation
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译 Underscore 模板之前进行修改
- en: Although not very common, there might come a time that you would want to alter
    the contents of a template before compiling or rendering it. This is most commonly
    required when you would like to remove excessive whitespace from templates, or
    if you'd like to remove or replace certain parts of a template you have no control
    over.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种情况并不常见，但可能会有这样的时候，你希望在编译或渲染模板之前修改模板的内容。这通常是在你希望从模板中移除过多空白字符，或者如果你想移除或替换你无法控制的模板的某些部分时所需的。
- en: In this recipe, we'll make use of the `contrib-jst (0.6.0)` plugin and the `processContent`
    option provided by its `jst` task to remove whitespace from our templates before
    compiling them.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将利用`contrib-jst (0.6.0)`插件及其`jst`任务提供的`processContent`选项，在编译模板之前从模板中移除空白字符。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll work with the basic project structure we created in the
    *Compiling Underscore templates* recipe of this chapter. Be sure to refer to it
    if you are not yet familiar with its contents.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用本章“编译Underscore模板”菜谱中创建的基本项目结构。如果你还不熟悉其内容，请务必参考。
- en: How to do it...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following steps take us through altering our configuration so that excessive
    whitespace is removed from our templates before compiling them.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导我们修改配置，以便在编译模板之前移除模板中的过多空白字符。
- en: 'First, we can provide an empty function to the `processContent` option that
    receives the content of the template and passes it through without altering it:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以向`processContent`选项提供一个空函数，该函数接收模板的内容并将其传递而不做任何修改：
- en: '[PRE76]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, we can alter the code of the function provided to `processContent` so
    that it removes all leading and trailing whitespace from the template''s content:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以修改提供给`processContent`的函数代码，以便从模板内容中移除所有前导和尾随空白字符：
- en: '[PRE77]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we now run the task using the `grunt jst` command, we should see output
    similar to the following:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在使用`grunt jst`命令运行任务，我们应该看到以下类似的输出：
- en: '[PRE78]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The compiled result in the `templates.js` file should now display no signs of
    any of the trailing whitespace that was present in the original template.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`templates.js`文件中编译的结果应该不再显示原始模板中存在的任何尾随空白字符的迹象。
