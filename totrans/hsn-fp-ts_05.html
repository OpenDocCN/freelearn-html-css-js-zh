<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Runtime &amp;#x2013; Closures and Prototypes</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned about certain aspects of the TypeScript/JavaScript runtime that will help us to understand the implementation of some functional programming techniques in upcoming chapters. In this chapter, we are going to explore two more aspects of the <span>TypeScript/JavaScript runtime</span>:</p>
<ul>
<li>Prototypes</li>
<li>Closures</li>
</ul>
<p>After exploring these two concepts, we will finally be ready to delve into the implementation and application of the main functional programming techniques.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prototypes</h1>
                </header>
            
            <article>
                
<p>When we compile a TypeScript program, all classes and objects become JavaScript objects. Occasionally, however, we may encounter an unexpected behavior at runtime even if the compilation was completed without errors. To be able to identify and understand the cause of this behavior, we need a good understanding of the JavaScript runtime. One of the main concepts that we need to understand is how classes and inheritance work at runtime.</p>
<p>The runtime inheritance system uses a prototypal inheritance model. In a prototypal inheritance model, objects inherit from objects, and there are no classes available. However, we can use prototypes to simulate classes. Let's see how this works.</p>
<p>At runtime, objects have an internal property called <kbd>prototype</kbd>. The values of the <kbd>prototype</kbd> property is an object that contains some properties (data) and methods (behavior).</p>
<p>In TypeScript, we can use a class-based inheritance system:</p>
<pre>class Person {<br/><br/>    public name: string;<br/>    public surname: string;<br/>    public age: number = 0;<br/><br/>    public constructor(name: string, surname: string) {<br/>        this.name = name;<br/>        this.surname = surname;<br/>    }<br/><br/>    public greet() {<br/>        let msg = 'Hi! my name is ${this.name} ${this.surname}';<br/>        msg += 'I'm ${this.age}';<br/>    }<br/><br/>}</pre>
<p>We have defined a class named <kbd>Person</kbd>. At runtime, this class is declared using prototypes instead of classes:</p>
<pre>var Person = (function() {<br/><br/>    function Person(name, surname) {<br/>        this.age = 0;<br/>        this.name = name;<br/>        this.surname = surname;<br/>    }<br/><br/>    Person.prototype.greet = function() {<br/>        let msg = "Hi! my name is " + this.name +<br/>                    " " + this.surname;<br/>        msg += "I'm " + this.age;<br/>    };<br/><br/>    return Person;<br/><br/>})();</pre>
<p>The preceding code is emitted by TypeScript when we target ES5. The <kbd>class</kbd> keyword is supported by ES6 at runtime, but it is only syntactic sugar.</p>
<div class="packt_infobox">Syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express. This means that the class keyword is just a helper to make our lives as software engineers easier; internally, prototypes are always used.</div>
<p>The TypeScript compiler wraps the object definition (we will not refer to it as a class definition because technically, it is not a class) with an <strong>immediately-invoked function expression</strong> (<strong>IIFE</strong>). Inside the IIFE, we can find a function named <kbd>Person</kbd>. If we examine the function and compare it with the TypeScript class, we will notice that it takes the same parameters that the class constructor takes in the TypeScript class. This function is used to create new instances of the <kbd>Person</kbd> class.</p>
<p>After the constructor, we can see the definition of the <kbd>greet</kbd> method. As we can see, the <kbd>prototype</kbd> property is used to attach the <kbd>greet</kbd> method to the <kbd>Person</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instance properties versus class properties</h1>
                </header>
            
            <article>
                
<p>Because JavaScript is a dynamic programming language, we can add properties and methods to an instance of an object at runtime; and they don't need to be part of the object (class) itself:</p>
<pre>const name = "Remo";<br/>const surname = "Jansen";<br/><br/>function Person(name, surname) {<br/>      // instance properties<br/>      this.name = name;<br/>      this.surname = surname;<br/>}<br/><br/>const person1 = new Person(name, surname);<br/>person1.age = 27;</pre>
<p>We have defined a constructor function for an object named <kbd>Person</kbd>, which takes two variables (<kbd>name</kbd> and <kbd>surname</kbd>) as arguments. Then we have created an instance of the <kbd>Person</kbd> object and added a new property named <kbd>age</kbd> to it. We can use a <kbd>for…in</kbd> statement to check the properties of <kbd>person1</kbd> at runtime:</p>
<pre>for(let property in person1) {<br/>  console.log("property: " + property + ", value: '" +<br/>  person1[property] + "'");<br/>}</pre>
<p>The following will be displayed in the console output:</p>
<pre>property: name, value: 'Remo'<br/>property: surname, value: 'Jansen'<br/>property: age, value: 27<br/>property: greet, value: 'function (city, country) {<br/>    let msg = "Hi, my name is " + this.name + " " + this.surname;<br/>    msg += "\nI'm from " + city + " " + country;<br/>    console.log(msg);<br/>}'</pre>
<p>As we can see, <kbd>age</kbd> has been added as a property. All these properties are instance properties because they hold a value for each new instance. If, for example, we create a new instance of <kbd>Person</kbd>, both instances will hold their own values:</p>
<pre>let person2 = new Person("John", "Wick");<br/>person2.name; // "John"<br/>person1.name; // "Remo"</pre>
<p>We have defined these instance properties using the <kbd>this</kbd> operator because, when a function is used as a constructor (with the <kbd>new</kbd> keyword), the <kbd>this</kbd> operator is bound to the object instance constructed. The preceding also explains why we can alternatively define instance properties through the object's prototype:</p>
<pre>Person.prototype.name = name; // instance property<br/>Person.prototype.surname = surname; // instance property</pre>
<p>We can also declare class properties and methods (also known as static properties). The main difference between instance properties and class properties is that the value of class properties and methods are shared between all instances of an object. Class properties are often used to store static values:</p>
<pre>function MathHelper() {<br/>  //...<br/>}<br/><br/>// class property<br/>MathHelper.PI = 3.14159265359;</pre>
<p>Class methods are also often used as utility functions that perform calculations on supplied parameters and return a result:</p>
<pre>function MathHelper() {<br/>    // ...<br/>}<br/><br/>// class property<br/>MathHelper.PI = 3.14159265359;<br/><br/>// class method<br/>MathHelper.areaOfCircle = function(radius) {<br/>  return radius * radius * MathHelper.PI;<br/>}</pre>
<div class="packt_infobox">Please note that the preceding code snippet is valid in JavaScript, but will throw a compilation error in TypeScript.</div>
<p>In the preceding example, we accessed a class attribute (<kbd>PI</kbd>) from a class method (<kbd>areaOfCircle</kbd>). We can access class properties from instance methods, but we cannot access instance properties or methods from class properties or methods. We can demonstrate this by declaring <kbd>PI</kbd> as an instance property instead of a class property:</p>
<pre>function MathHelper() {<br/>  // instance property<br/>  this.PI = 3.14159265359;<br/>}</pre>
<p>If we then attempt to access <kbd>PI</kbd> from a class method, it will be undefined:</p>
<pre class="mce-root">// class method<br/>MathHelper.areaOfCircle = function(radius) {<br/>  return radius * radius * this.PI; // this.PI is undefined<br/>}<br/><br/>MathHelper.areaOfCircle(5); // NaN</pre>
<p>We are not supposed to access class methods or properties from instance methods, but there is a way to do it. We can do this by using the prototype's <kbd>constructor</kbd> property, as demonstrated in the following example:</p>
<pre>function MathHelper () { /* ... */ }<br/><br/>// class property<br/>MathHelper.PI = 3.14159265359;<br/><br/>// instance method<br/>MathHelper.prototype.areaOfCircle = function(radius) {<br/> return radius * radius * this.constructor.PI;<br/>}<br/><br/>const math = new MathHelper ();<br/>console.log(MathHelper.areaOfCircle(5)); // 78.53981633975</pre>
<p>We can access the <kbd>PI</kbd> class property from the <kbd>areaOfCircle</kbd> instance method using the prototype's <kbd>constructor</kbd> property because this property returns a reference to the object's constructor.</p>
<p>Inside <kbd>areaOfCircle</kbd>, the <kbd>this</kbd> operator returns a reference to the object's prototype:</p>
<pre>this === MathHelper.prototype; // true</pre>
<p>We may deduce that <kbd>this.constructor</kbd> is equal to <kbd>MathHelper.prototype.constructor</kbd> and, therefore, <kbd>MathHelper.prototype.constructor</kbd> is equal to <kbd>MathHelper</kbd>.</p>
<p>In TypeScript, we can define class properties using the <kbd>static</kbd> keyword:</p>
<pre>class MathHelper {<br/><br/>    // class property<br/>    public static PI = 3.14159265359;<br/><br/>    // class method<br/>    public static areaOfCircle(radius: number) {<br/>        return radius * radius * MathHelper.PI;<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prototypal inheritance</h1>
                </header>
            
            <article>
                
<p>You might be wondering how the <kbd>extends</kbd> keyword works. Let's create a new TypeScript class, which inherits from the <kbd>Person</kbd> class, to understand it:</p>
<pre>class SuperHero extends Person {<br/><br/>    public superpower: string;<br/><br/>    public constructor(<br/>        name: string,<br/>        surname: string,<br/>        superpower: string<br/>    ) {<br/>        super(name, surname);<br/>        this.superpower = superpower;<br/>    }<br/><br/>    public userSuperPower() {<br/>        return 'I'm using my ${this.superpower}';<br/>    }<br/><br/>}</pre>
<p>The preceding class is named <kbd>SuperHero</kbd> and extends the <kbd>Person</kbd> class. It has one additional attribute (<kbd>superpower</kbd>) and method (<kbd>useSuperPower</kbd>). </p>
<p>We need to compile the previous code snippet into JavaScript code so we can examine how inheritance is implemented at runtime. The compiler will generate a polyfill function named <kbd>__extends</kbd> which is meant to be a replacement for the extends keyword compatible with the older versions of JavaScript:</p>
<pre>var __extends = this.__extends || function (d, b) {<br/>    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];<br/>    function __() { this.constructor = d; }<br/>    __.prototype = b.prototype;<br/>    d.prototype = new __();<br/>};</pre>
<div class="packt_infobox">
<p>Please note that the preceding code snippet is slightly more complicated in the latest version of TypeScript. We will use the code from previous versions here because it contains fewer conditions and is easier to understand.</p>
</div>
<p>This piece of code is generated by TypeScript. Even though it is a small piece of code, it showcases almost every concept contained in this chapter, and understanding it can be quite challenging.</p>
<p>Before the function expression is evaluated for the first time, the <kbd>this</kbd> operator points to the global object, which does not contain a method named <kbd>__extends</kbd>. This means that the <kbd>__extends</kbd> variable is undefined.</p>
<p>When the function expression is evaluated for the first time, the value of the function expression (an anonymous function) is assigned to the <kbd>__extends</kbd> property in the global scope.</p>
<p>TypeScript generates the function expression on one occasion for each TypeScript file containing the <kbd>extends</kbd> keyword. However, the function expression is only evaluated once (when the <kbd>__extends</kbd> variable is undefined). This behavior is implemented by the conditional statement in the first line:</p>
<pre>var __extends = this.__extends || function (d, b) { // ...</pre>
<p>The first time the preceding line of code is executed, the function expression is evaluated. The value of the function expression is an anonymous function, which is assigned to the <kbd>__extends</kbd> variable in the global scope. Because we are in the global scope, <kbd>var __extends</kbd> and <kbd>this. __extends</kbd> refer to the same variable at this point.</p>
<p>When a new file is executed, the <kbd>__extends</kbd> variable is already available in the global scope, and the function expression is not evaluated. This means that the value of the function expression is only assigned to the <kbd>__extends</kbd> variable once, even if the snippet is executed multiple times.</p>
<p>Let's focus now on the <kbd>__extends</kbd> variable (the anonymous function):</p>
<pre>function (d, b) {<br/>    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];<br/>    function __() { this.constructor = d; }<br/>    __.prototype = b.prototype;<br/>    d.prototype = new __();<br/>}</pre>
<p>This function takes two arguments named <kbd>d</kbd> and <kbd>b</kbd>. When we invoke it, we should pass a derived object constructor (<kbd>d</kbd>) and a base object constructor (<kbd>b</kbd>).</p>
<p>The first line inside the anonymous function iterates each class property and method from the base class and creates their copy in the derived class:</p>
<pre>for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];</pre>
<div class="packt_infobox">
<p>When we use a <kbd>for…in</kbd> statement to iterate an instance of an object to <kbd>a</kbd>, it will iterate the object's instance properties. However, if we use a <kbd>for…in</kbd> statement to iterate the properties of an object's constructor, the statement will iterate its class properties. In the preceding example, the <kbd>for…in</kbd> statement is used to inherit the object's class properties and methods. To inherit the instance properties, we will copy the object's prototype.</p>
</div>
<p>The second line declares a new constructor function named <kbd>__</kbd> and, inside it, the <kbd>this</kbd> operator is used to access its prototype.</p>
<pre>function __() { this.constructor = d; }</pre>
<p>The prototype contains a special property named <kbd>constructor</kbd>, which returns a reference to the object's constructor. The function named <kbd>__</kbd> and <kbd>this.constructor</kbd> are pointing to the same variable at this point. The value of the derived object constructor (<kbd>d</kbd>) is then assigned to the <kbd>__</kbd> constructor.</p>
<p>In the third line, the value of the prototype object from the base object constructor is assigned to the prototype of the <kbd>__</kbd> object constructor:</p>
<pre>__.prototype = b.prototype;</pre>
<p>In the last line, the <kbd>__</kbd> <span>function </span>is invoked as a constructor with the <kbd>new</kbd><span> keyword,</span> and the result is assigned to the derived class (<kbd>d</kbd>) prototype. By performing all these steps, we have achieved what we need to in order to invoke the following:</p>
<pre>var instance = new d():</pre>
<p>Upon doing so, we will get an object that contains all the properties from both the derived class (<kbd>d</kbd>) and the base class (<kbd>b</kbd>). Furthermore, any instance objects constructed by the derived constructor (<kbd>d</kbd>) will be instances of the derived class, while inheriting the class and instance properties and methods from the base class (<kbd>b</kbd>).</p>
<p>We can see the function in action by examining the runtime code that defines the <kbd>SuperHero</kbd> class:</p>
<pre>var SuperHero = (function (_super) {<br/><br/>    __extends(SuperHero, _super);<br/><br/>    function SuperHero(name, surname, superpower) {<br/>        _super.call(this, name, surname);<br/>        this.superpower = superpower;<br/>    }<br/><br/>    SuperHero.prototype.userSuperPower = function () {<br/>        return "I'm using my " + superpower;<br/>    };<br/><br/>    return SuperHero;<br/><br/>})(Person);</pre>
<p>We can see an IIFE here again. This time, the IIFE takes the <kbd>Person</kbd> object constructor as the argument. Inside the function, we will refer to this argument using the name <kbd>_super</kbd>. Inside the IIFE, the <kbd>__extends</kbd> function is invoked and the <kbd>SuperHero</kbd> (derived class) and <kbd>_super</kbd> (base class) arguments are passed to it.</p>
<p>In the next line, we can find the declaration of the <kbd>SuperHero</kbd> object constructor and the <kbd>useSuperPower</kbd> function. We can use <kbd>SuperHero</kbd> as an argument of <kbd>__extend</kbd> before it is declared because function declarations are hoisted to the top of the scope.</p>
<div class="packt_infobox">
<p>Function expressions are not hoisted. When we assign a function to a variable in a function expression, the variable is hoisted, but its value (the function itself) is not hoisted.</p>
</div>
<p>Inside the <kbd>SuperHero</kbd> constructor, the base class (<kbd>Person</kbd>) constructor is invoked using the <kbd>call</kbd> method:</p>
<pre>_super.call(this, name, surname);</pre>
<p>As we discovered in the <span>previous</span> chapter, we can use <kbd>call</kbd> to set the value of the <kbd>this</kbd> operator in a function context. In this case, we are passing the <kbd>this</kbd> operator, which points to the instance of <kbd>SuperHero</kbd> being created:</p>
<pre>function Person(name, surname) {<br/>    // this points to the instance of SuperHero being created<br/>    this.name = name;<br/>    this.surname = surname;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prototype chains and property shadowing</h1>
                </header>
            
            <article>
                
<p>When we try to access a property or a method of an object, the runtime will search for that property or method in the object's own properties and methods. If it is not found, the runtime will continue searching through the object's inherited properties by navigating the entire inheritance tree. Because a derived object is linked to its base object through the <kbd>prototype</kbd> property, we refer to this inheritance tree as the <strong>prototype chain</strong>.</p>
<p>Let's look at an example. We will declare two simple TypeScript classes, named <kbd>Base</kbd> and <kbd>Derived</kbd>:</p>
<pre>class Base {<br/>    public method1() { return 1; }<br/>    public method2() { return 2; }<br/>}<br/><br/>class Derived extends Base {<br/>    public method2() { return 3; }<br/>    public method3() { return 4; }<br/>}</pre>
<p>Now we will examine the JavaScript code generated by TypeScript:</p>
<pre>var Base = (function () {<br/>    function Base() {<br/>    }<br/>    Base.prototype.method1 = function () { return 1; };<br/>    Base.prototype.method2 = function () { return 2; };<br/>    return Base;<br/>})();<br/><br/>var Derived = (function (_super) {<br/>    __extends(Derived, _super);<br/>    function Derived() {<br/>        _super.apply(this, arguments);<br/>    }<br/>    Derived.prototype.method2 = function () { return 3; };<br/>    Derived.prototype.method3 = function () { return 4; };<br/>    return Derived;<br/>})(Base);</pre>
<p>We can then create an instance of the <kbd>Derived</kbd> class:</p>
<pre>const derived = new Derived();</pre>
<p><span>The </span><kbd>new</kbd><span> operator creates an object instance that inherits from the </span><kbd>Base</kbd><span> class.</span></p>
<p>If we try to access the method named <kbd>method1</kbd>, the runtime will find it in the instance's properties:</p>
<pre>console.log(derived.method1()); // 1</pre>
<p>The instance also has its own property named <kbd>method2</kbd> (with a value of <kbd>2</kbd>), but there is also an inherited property named <kbd>method2</kbd> (with a value of <kbd>3</kbd>). The object's property (<kbd>method2</kbd> with a value of <kbd>3</kbd>) prevents access to the prototype property (<kbd>method2</kbd> with a value of <kbd>2</kbd>). This is known as <strong>property shadowing</strong>:</p>
<pre>console.log(derived.method2()); // 3</pre>
<p>The instance does not have its own property named <kbd>method3</kbd>, but it does have a property named <kbd>method3</kbd> in its prototype chain:</p>
<pre>console.log(derived.method3()); // 4</pre>
<p>Neither the instance nor the objects in the prototype chain (the <kbd>Base</kbd> class) have a property named <kbd>method4</kbd>:</p>
<pre>console.log(derived.method4()); // error</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the prototype of an object</h1>
                </header>
            
            <article>
                
<p>Prototypes can be accessed in three different ways:</p>
<ul>
<li><kbd>Person.prototype</kbd></li>
<li><kbd>Object.getPrototypeOf(person)</kbd></li>
<li><kbd>person.__proto__</kbd></li>
</ul>
<div class="packt_infobox">
<p>The use of <kbd>__proto__</kbd> is controversial and has been discouraged by many experienced software engineers. It was never originally included in the ECMAScript language specification, but modern browsers decided to implement it in any case. Today, the <kbd>__proto__</kbd> property has been standardized in the ECMAScript 6 language specification and will be supported in future, but it is still a slow operation that should be avoided if performance is a concern.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closures</h1>
                </header>
            
            <article>
                
<p>Closures are one of the most powerful features in JavaScript and TypeScript, but they are also one of the most misunderstood. The <em>Mozilla developer network</em> defines closures as follows:</p>
<div class="packt_quote">Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure 'remembers' the environment in which it was created.</div>
<p>We understand independent (free) variables as variables that persist beyond the lexical scope from which they were created. Let's look at an example:</p>
<pre>function makeArmy() {<br/>    const shooters = [];<br/>    for (let i = 0; i &lt; 10; i++) {<br/>        const shooter = () =&gt; { // a shooter is a function<br/>            console.log(i); // which should display it's number<br/>        };<br/>        shooters.push(shooter);<br/>    }<br/>    return shooters;<br/>}</pre>
<div class="packt_infobox">Please note that the preceding example is meant to be a JavaScript example.</div>
<p>We have declared a function named <kbd>makeArmy</kbd>. Inside the function, we have created an array of functions named <kbd>shooters</kbd>. Each function in the <kbd>shooters</kbd> array will display a number, the value of which was set from the variable <kbd>i</kbd> inside a <kbd>for</kbd> statement. We will now invoke the <kbd>makeArmy</kbd> function:</p>
<pre>const army = makeArmy();</pre>
<p>The <kbd>army</kbd> <span>variable </span>should now contain the array of the function's <kbd>shooters</kbd>. However, we will notice a problem if we execute the following piece of code:</p>
<pre>army[0](); // 10 (expected 0)<br/>army[5](); // 10 (expected 5)</pre>
<p>The preceding code snippet does not work as expected because we made one of the most common mistakes related to closures. When we declared the <kbd>shooter</kbd> function inside the <kbd>makeArmy</kbd> function, we created a closure without being aware of it.</p>
<p>This is because the functions assigned to <kbd>shooter</kbd> are closures. A closure has access to variables in the environment that encloses them (the <kbd>makeArmy</kbd> function's scope). Ten closure functions have been created, but each one shares the same single environment. By the time the <kbd>shooter</kbd> functions are executed, the loop has run its course and the <kbd>i</kbd> variable (shared by all the closure functions) has been left pointing to the last entry (<kbd>10</kbd>).</p>
<p>One solution, in this case, is to use more closures:</p>
<pre>function makeArmy() {<br/>    const shooters = [];<br/>    for (let i = 0; i &lt; 10; i++) {<br/>        ((index: number) =&gt; {<br/>            const shooter = () =&gt; {<br/>                console.log(index);<br/>            };<br/>            shooters.push(shooter);<br/>        })(i);<br/>    }<br/>    return shooters;<br/>}<br/><br/>const army = makeArmy();<br/>army[0](); // 0<br/>army[5](); // 5</pre>
<div class="packt_infobox">
<p>Please <span>note that the preceding example is meant to be a</span> TypeScript example.</p>
</div>
<p>This works as expected. Rather than the <kbd>shooter</kbd> functions sharing a single environment, the immediately-invoked function creates a new environment for each one in which <kbd>i</kbd> refers to the corresponding value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static variables powered by closures</h1>
                </header>
            
            <article>
                
<p>In the previous section, we learned that, when a variable in a closure context can be shared between multiple instances of a class, this means that the variable behaves like a static variable. We will now see how we can create variables and methods that behave like a static variable using closures. Let's start by declaring a TypeScript class named <kbd>Counter</kbd>:</p>
<pre>class Counter {<br/><br/> private static _COUNTER = 0;<br/><br/> public increment() {<br/> this._changeBy(1);<br/> }<br/><br/> public decrement() {<br/> this._changeBy(-1);<br/> }<br/><br/> public value() {<br/> return Counter._COUNTER;<br/> }<br/><br/> private _changeBy(val: number) {<br/> Counter._COUNTER += val;<br/> }<br/><br/>}</pre>
<div class="packt_infobox">
<p>Please note that the preceding example is meant to be a TypeScript example.</p>
</div>
<p>The preceding class contains a static member named <kbd>_COUNTER</kbd>. The TypeScript compiler transforms it into the following code:</p>
<pre>var Counter = (function () {<br/><br/>    function Counter() {<br/>    }<br/><br/>    Counter.prototype._changeBy = function (val) {<br/>        Counter._COUNTER += val;<br/>    };<br/><br/>    Counter.prototype.increment = function () {<br/>        this._changeBy(1);<br/>    };<br/><br/>    Counter.prototype.decrement = function () {<br/>        this._changeBy(-1);<br/>    };<br/><br/>    Counter.prototype.value = function () {<br/>        return Counter._COUNTER;<br/>    };<br/><br/>    Counter._COUNTER = 0;<br/>    return Counter;<br/><br/>})();</pre>
<div class="packt_infobox">
<p>Please note that the preceding code snippet is the compilation output generated by the TypeScript compiler.</p>
</div>
<p>As we can observe, the static variable is declared by the TypeScript compiler as a class property (as opposed to an instance property). The compiler uses a class property because class properties are shared across all instances of a class. The problem is that the private variable is not private at runtime.</p>
<p>Alternatively, we could write some JavaScript (remember that all valid JavaScript is valid TypeScript) code to emulate static properties using closures:</p>
<pre>var Counter = (function() {<br/><br/>    // closure context<br/><br/>    let _COUNTER = 0;<br/><br/>    function changeBy(val: number) {<br/>        _COUNTER += val;<br/>    }<br/><br/>    interface Counter {<br/>        increment: () =&gt; void;<br/>        decrement: () =&gt; void;<br/>        value: () =&gt; number;<br/>    }<br/><br/>    interface CounterConstructor {<br/>        new(): Counter;<br/>    }<br/><br/>    function Counter() {};<br/><br/>    // closure functions<br/><br/>    Counter.prototype.increment = function() {<br/>      changeBy(1);<br/>    };<br/><br/>    Counter.prototype.decrement = function() {<br/>      changeBy(-1);<br/>    };<br/><br/>    Counter.prototype.value = function() {<br/>      return _COUNTER;<br/>    };<br/><br/>    return (Counter as unknown) as CounterConstructor;<br/><br/>})();</pre>
<div class="packt_infobox">
<p><span>Please note that the preceding example is meant to be a TypeScript example.</span></p>
</div>
<p>The preceding code snippet declares a class named <kbd>Counter</kbd>. The class has some methods used to increment, decrement, and read the variable named <kbd>_COUNTER</kbd>. The <kbd>_COUNTER</kbd> variable itself is not part of the object prototype.</p>
<p>All the instances of the <kbd>Counter</kbd> class will share the same context, which means that the context (the <kbd>_COUNTER</kbd> <span>variable </span>and the <kbd>changeBy</kbd> <span>function)</span> will behave as a singleton.</p>
<div class="packt_infobox">
<p>The singleton pattern requires an object to be declared as a static variable to avoid the need to create its instance whenever it is required. The object instance is, therefore, shared by all the components in the application. The singleton pattern is frequently used in scenarios where it is not beneficial, thereby introducing unnecessary restrictions in situations where a unique instance of a class is not required, and introduces global state into an application.</p>
</div>
<p>So now we know that it is possible to use closures to emulate static variables:</p>
<pre>let counter1 = new Counter();<br/>let counter2 = new Counter();<br/>console.log(counter1.value()); // 0<br/>console.log(counter2.value()); // 0<br/>counter1.increment();<br/>counter1.increment();<br/>console.log(counter1.value()); // 2<br/>console.log(counter2.value()); // 2 (expected 0)<br/>counter1.decrement();<br/>console.log(counter1.value()); // 1<br/>console.log(counter2.value()); // 1 (expected 0)</pre>
<p>As we can see, the preceding example doesn't work as expected because both instances of <kbd>Counter</kbd> share the internal counter. We will learn how to fix this problem in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Private members powered by closures</h1>
                </header>
            
            <article>
                
<p>In the previous section, we learned that closures can access variables that persist beyond the lexical scope from which they were created. These variables are not part of the function's prototype or body, but they are part of the function's context.</p>
<p>Because there is no way we can directly invoke the function's context, context variables and methods can be used to emulate private members. The main advantage of using closures to emulate private members (instead of the TypeScript private access modifier) is that closures will prevent access to private members at runtime.</p>
<p>TypeScript avoids emulating private properties at runtime because the compiler will throw an error at compilation time if we attempt to access a private member. TypeScript avoids using closures to emulate private members so as to improve application performance. If we add or remove an access modifier to or from one of our classes, the resulting JavaScript code will not change at all. This means that private members of a class become public members at runtime.</p>
<p>However, it is possible to use closures to emulate private properties at runtime. Let's look at an example:</p>
<pre>function makeCounter() {<br/><br/>    // closure context<br/>    let _COUNTER = 0;<br/><br/>    function changeBy(val: number) {<br/>        _COUNTER += val;<br/>    }<br/><br/>    class Counter {<br/><br/>        public increment() {<br/>            changeBy(1);<br/>        }<br/><br/>        public decrement() {<br/>            changeBy(-1);<br/>        }<br/><br/>        public value() {<br/>            return _COUNTER;<br/>        }<br/><br/>    }<br/><br/>    return new Counter();<br/><br/>}</pre>
<div class="packt_infobox">
<p>Please note that the preceding example is meant to be a TypeScript example.</p>
</div>
<p>The preceding class is almost identical to the class that we previously declared in order to demonstrate how to emulate static variables at runtime using closures.</p>
<p>This time, a new closure context is created every time we invoke the <kbd>makeCounter</kbd> function, so each new instance of <kbd>Counter</kbd> will remember an independent context (<kbd>_COUNTER</kbd> and <kbd>changeBy</kbd>):</p>
<pre>let counter1 = makeCounter();<br/>let counter2 = makeCounter();<br/>console.log(counter1.value()); // 0<br/>console.log(counter2.value()); // 0<br/>counter1.increment();<br/>counter1.increment();<br/>console.log(counter1.value()); // 2<br/>console.log(counter2.value()); // 0 (expected 0)<br/>counter1.decrement();<br/>console.log(counter1.value()); // 1<br/>console.log(counter2.value()); // 0 (expected 0)</pre>
<p>Since the context cannot be accessed directly, we can say that the <kbd>_COUNTER</kbd> <span>variable </span>and the <kbd>changeBy</kbd> function are private members even at runtime:</p>
<pre>console.log(counter1.counter); // Error<br/>console.log(counter1.changeBy(2)); // Error</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have acquired a better understanding of the runtime, which allows us to not only resolve runtime issues easily, but also to write better TypeScript code. An in-depth understanding of closures and prototypes will allow us to understand the implementation of some functional programming techniques in upcoming chapters.</p>
<p>In the next chapter, we will learn how to implement a number of fundamental functional programming techniques.</p>


            </article>

            
        </section>
    </body></html>