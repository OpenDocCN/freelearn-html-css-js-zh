- en: Chapter 2. Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 模型
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating a model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型
- en: Operating with model attributes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作模型属性
- en: Operating with model identifier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作模型标识符
- en: Validating model attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模型属性
- en: Overriding getters and setters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖获取器和设置器
- en: Creating undo points to store/restore a model's state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建撤销点以存储/恢复模型的状态
- en: Implementing workflow for a model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模型的工作流程
- en: Using advanced validation in a model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型中使用高级验证
- en: Validating an HTML form
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 HTML 表单
- en: Working with nested attributes in a model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型中处理嵌套属性
- en: Implementing a one-to-one relationship
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一对一关系
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we are going to learn what a Backbone model is and how can we
    use it. We are also going to consider various Backbone extensions, which provide
    lots of improvement and bring amazing features to our models.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Backbone 模型的概念以及如何使用它。我们还将考虑各种 Backbone 扩展，它们提供了许多改进，并为我们的模型带来了惊人的功能。
- en: The first three recipes of the current chapter contain information for beginners
    who are not familiar with Backbone yet; and other recipes bring additional value
    and cover more advanced topics.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前三个菜谱包含了对 Backbone 不熟悉的初学者的信息；其他菜谱提供了额外的价值，并涵盖了更多高级主题。
- en: Creating a model
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: A model is a building brick of any MVC application, which contains data, provides
    validation, performs access control, and implements specific business logic required
    by an application. In `Backbone.js`, a model is defined by extending its instance
    from the `Backbone.Model` object. In this recipe, we are going to learn how to
    work with models in `Backbone.js`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是任何 MVC 应用程序的基本构建块，它包含数据、提供验证、执行访问控制和实现应用程序所需的具体业务逻辑。在 `Backbone.js` 中，模型通过从
    `Backbone.Model` 对象扩展其实例来定义。在本菜谱中，我们将学习如何在 `Backbone.js` 中处理模型。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to define a new model object and create its instance:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以定义新的模型对象并创建其实例：
- en: Define a model by extending `Backbone.Model`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展 `Backbone.Model` 定义模型。
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There is no need to define a data structure inside the model object, because
    Backbone allows it to be defined dynamically when the model is initialized.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模型对象内部不需要定义数据结构，因为 Backbone 允许在初始化模型时动态定义。
- en: Create a `Backbone.Model` instance and initialize it with attribute values.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Backbone.Model` 实例，并用属性值初始化它。
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's more...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this section, we are going to learn how to clone a model and how to initialize
    a model with default values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何克隆模型以及如何使用默认值初始化模型。
- en: Cloning a model
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型的克隆
- en: When you assign a model to another variable, it makes one model reflect changes
    in another model. If you need an independent copy of a model, use the `clone()`
    method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个模型分配给另一个变量时，它使得一个模型反映另一个模型的变化。如果你需要一个模型的独立副本，请使用 `clone()` 方法。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting default attribute values
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认属性值
- en: 'Sometimes, you may want your model to have attributes that are initialized
    with default values when a new model instance is created, so you don''t need to
    set them manually. Here is how default attributes are defined:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望模型在创建新的模型实例时具有默认值初始化的属性，这样你就不需要手动设置它们。以下是定义默认属性的方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following example shows that the `quantity` and `date` attributes are initialized
    by default:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示 `quantity` 和 `date` 属性默认被初始化：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting default attribute values with a multiline expression
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多行表达式设置默认属性值
- en: If you want to set default values with a multiline expression you can wrap it
    into a function and call it when setting default attributes in `defaults`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用多行表达式设置默认值，你可以将其包装在一个函数中，并在设置 `defaults` 中的默认属性时调用它。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is also a way to do the same in the `initialize()` method, which is called
    right after the model object is created and initialized with values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也可以在 `initialize()` 方法中实现相同的功能，该方法在模型对象创建并初始化后立即调用。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `initialize()` method we set the `date` attribute to today's date using
    JavaScript's `Date` object. Before doing this, we need to check that the `date`
    attribute is not initialized yet, so we do not override it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize()` 方法中，我们使用 JavaScript 的 `Date` 对象将 `date` 属性设置为今天的日期。在这样做之前，我们需要检查
    `date` 属性尚未初始化，这样我们就不覆盖它了。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the default attributes are defined, then they can override the attributes
    defined in the `initialize()` method, and so we need to remove such attributes
    from the `default` values, otherwise they are initialized as defaults instead.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认属性被定义，那么它们可以覆盖在 `initialize()` 方法中定义的属性，因此我们需要从 `default` 值中删除这些属性，否则它们将作为默认值初始化。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In the current recipe examples, we used the `has()` and `set()` methods, which
    are described in the following recipe: *Operating with model attributes*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前的食谱示例中，我们使用了 `has()` 和 `set()` 方法，这些方法在以下食谱中有描述：*操作模型属性*
- en: Operating with model attributes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作模型属性
- en: Attributes are where a model stores all its data. Unlike model properties, which
    are used for storing internal object information, attributes cannot be accessed
    via the `.` operator. There are special methods to work with them, which we are
    going to learn in this recipe.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是模型存储所有数据的地方。与用于存储内部对象信息的模型属性不同，属性不能通过 `.` 操作符访问。有一些特殊的方法可以用来操作它们，我们将在本食谱中学习。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The main methods to work with model attributes are `get()`, `set()`, `unset()`,and
    `clear()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型属性一起工作的主要方法有 `get()`、`set()`、`unset()` 和 `clear()`。
- en: Use the `get()` method to get an attribute value.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `get()` 方法获取属性值。
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the attribute is not found, `undefined` is returned.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果找不到属性，则返回 `undefined`。
- en: Use the `set()` method to update/create a single attribute value.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `set()` 方法来更新/创建单个属性值。
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To update multiple attributes use key-value format.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更新多个属性，请使用键值格式。
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When setting an attribute if it does not exist, one is created. The `set()`
    method returns a reference with the value `true` to the model, if validation does
    not fail; otherwise returns the value `false`. We will learn more about validation
    in the recipe, *Validating model attributes*.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当设置一个属性如果它不存在时，会创建一个。如果验证没有失败，`set()` 方法返回一个值 `true` 的引用到模型；否则返回值 `false`。我们将在食谱中了解更多关于验证的信息，*验证模型属性*。
- en: Use the `unset()` method to delete an attribute from a model.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `unset()` 方法从模型中删除一个属性。
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use the `clear()` method to delete all attributes from a model.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `clear()` 方法从模型中删除所有属性。
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Attributes are stored in the `attributes` property. It is better not to access
    attributes directly and to use methods we have learned previously; otherwise,
    it can break the event triggering mechanism or integration with other Backbone
    extensions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 属性存储在 `attributes` 属性中。最好不要直接访问属性，而应使用我们之前学过的方法；否则，可能会破坏事件触发机制或与其他 Backbone
    扩展的集成。
- en: When a new module is initialized, values from the `defaults` property are assigned
    to the `attributes` one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的模块初始化时，`defaults` 属性的值被分配给 `attributes`。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this section we are going to learn some useful methods with the model attributes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些与模型属性一起使用的有用方法。
- en: Checking if a model has an attribute
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查模型是否有属性
- en: To check if a model has an attribute, use the `has()` method. It returns `true`
    if the attribute exists, otherwise `false`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查模型是否有属性，请使用 `has()` 方法。如果属性存在，则返回 `true`，否则返回 `false`。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting HTML escaped attribute value
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 HTML 转义属性值
- en: 'If you are going to display user-entered text, which you assume is in plain
    text format, you should worry about security issues. The best way to prevent vulnerability
    which may lead to possible XSS attacks is to use the `escape()` method before
    outputting any user entered text. This disallows the browser to parse any HTML
    code by escaping HTML characters. Let''s figure out how it works:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算显示用户输入的文本，你假设它是纯文本格式，你应该担心安全问题。防止可能导致可能的 XSS 攻击的最佳方式是在输出任何用户输入的文本之前使用 `escape()`
    方法。这阻止浏览器通过转义 HTML 字符来解析任何 HTML 代码。让我们看看它是如何工作的：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Operating with the model identifier
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作模型标识符
- en: Each model has a unique identifier property ID, which allows distinguishing
    one model from another. When developing a Backbone application it is often required
    to operate with an identifier.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型都有一个唯一的标识符属性 ID，这允许区分一个模型和另一个模型。当开发 Backbone 应用程序时，通常需要操作标识符。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps explains how to set and get the `id` property:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了如何设置和获取 `id` 属性：
- en: Setting and getting the `id` property is really easy.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置和获取 `id` 属性非常简单。
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Getting the id property looks as follows:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取 id 属性如下所示：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `id` property provides direct access to an attribute where the identifier
    is stored. By default it is `id`; however, you can override it by setting `idAttribute`
    when extending a model.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 属性提供了直接访问存储标识符的属性。默认情况下它是 `id`；然而，在扩展模型时，你可以通过设置 `idAttribute` 来覆盖它。'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When a new model is created, the identifier is empty unless it is manually assigned.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新的模型时，除非手动分配，否则标识符为空。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If `id` is not initialized yet in your model, then you can use a client identifier,
    which can be accessed using the `cid` property. The value of `cid` is unique and
    assigned automatically when a new model instance is created. Client IDs can take
    forms, such as `c0`, `c1`, `c2`, and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模型中 `id` 尚未初始化，则可以使用客户端标识符，该标识符可以通过 `cid` 属性访问。`cid` 的值是唯一的，并在创建新的模型实例时自动分配。客户端标识符可以采用如
    `c0`、`c1`、`c2` 等形式。
- en: Validating model attributes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证模型属性
- en: To prevent unexpected behavior, we often need to validate model attributes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止意外行为，我们通常需要验证模型属性。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to set up an attribute validation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以设置属性验证：
- en: Validation can be done by defining the `validate()` method.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过定义 `validate()` 方法来进行验证。
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `attrs` parameter contains the attribute values that were changed. The `validate()`
    method will return an error message if they do not validate.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`attrs` 参数包含已更改的属性值。如果它们未通过验证，`validate()` 方法将返回错误信息。'
- en: 'Attribute validation is triggered on the `save()` method. It can also trigger
    on the `set()` method if you pass `{validate: true}` as the last parameter.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '属性验证在 `save()` 方法上触发。如果传递 `{validate: true}` 作为最后一个参数，它也可以在 `set()` 方法上触发。'
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When validating a model you can still access old attribute values with the help
    of `this.get()` or `this.attributes`.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当验证模型时，你可以通过 `this.get()` 或 `this.attributes` 的帮助访问旧属性值。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`validate` is called before `save()`, and accepts the updated model attributes,
    which are passed from `save()`. If `validate()` returns an error string, `save()`
    will not continue, and the model attributes will not be modified. Failed validation
    triggers the `invalid` event. If you want validation to be triggered in the `set()`
    method, pass `{validate: true}` as the last parameter.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate` 在 `save()` 之前被调用，并接受从 `save()` 传递的更新后的模型属性。如果 `validate()` 返回错误字符串，`save()`
    将不会继续，并且模型属性将不会被修改。失败的验证会触发 `invalid` 事件。如果你想在 `set()` 方法中触发验证，请将 `{validate:
    true}` 作为最后一个参数传递。'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this section, we are going to investigate more details about validation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地研究验证的细节。
- en: Handling validation errors
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理验证错误
- en: If a model does not validate, we often need to continue running an application
    and provide a custom code for handling events. Let's check out how it is done.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型没有通过验证，我们通常需要继续运行应用程序并提供自定义代码来处理事件。让我们看看它是如何完成的。
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Such an error handler should be bound before the validation event is triggered.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的错误处理程序应该在触发验证事件之前绑定。
- en: There is also another way of handling events, which allows us to pass an error
    handling function as an option to the `set()`, `fetch()`, `save()`, or `destroy()`
    methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理事件的方法允许我们将错误处理函数作为选项传递给 `set()`、`fetch()`、`save()` 或 `destroy()` 方法。
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Triggering validation manually
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动触发验证
- en: Though validation is performed every time a model is updated or saved to the
    storage, sometimes you may want to check manually if the model validates. Let's
    figure out how to do it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然验证在每次模型更新或保存到存储时都会执行，但有时你可能想手动检查模型是否通过验证。让我们弄清楚如何做到这一点。
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`isValid()` returns true or false, but does not trigger the `invalid` event.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`isValid()` 返回 true 或 false，但不会触发 `invalid` 事件。'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。事件和绑定")中处理 Backbone 对象的事件*，*事件和绑定*'
- en: Overriding getters and setters
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖获取器和设置器
- en: 'Sometimes it is required to override getters or setters in your application.
    There can be different reasons to do so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要覆盖应用程序中的获取器或设置器。这样做可能有不同的原因：
- en: An attribute is stored in a different format rather than a format for input
    or output
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个属性以不同于输入或输出的格式存储
- en: You have a virtual attribute that is not stored in the model, but depends on
    other attributes
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个虚拟属性，它不在模型中存储，但依赖于其他属性
- en: Prevent illegal values to be assigned to an attribute
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止将非法值分配给属性
- en: By default, Backbone does not allow users to override getters or setters, but
    there is an extension named `Backbone.Mutators`, which allows you to do so.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Backbone 不允许用户覆盖获取器或设置器，但有一个名为 `Backbone.Mutators` 的扩展，允许这样做。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is a link to download `Backbone.Mutators` from the **GitHub** page [https://github.com/asciidisco/Backbone.Mutators](https://github.com/asciidisco/Backbone.Mutators).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **GitHub** 页面 [https://github.com/asciidisco/Backbone.Mutators](https://github.com/asciidisco/Backbone.Mutators)
    可以下载 `Backbone.Mutators`。
- en: To include this extension into your project, save the `backbone.mutators.js`
    file into the `lib` folder and include a reference to it in `index.html`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此扩展包含到项目中，将 `backbone.mutators.js` 文件保存到 `lib` 文件夹，并在 `index.html` 中包含对其的引用。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章](ch01.html "第1章。理解 Backbone") 的 *使用插件扩展应用程序* 菜单中，详细描述了如何在项目中包含 Backbone
    扩展。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can specify a getter or setter for a virtual attribute that does not exist.
    This can be helpful in some cases, for example, if a virtual attribute depends
    on other attributes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为不存在的虚拟属性指定获取器或设置器。在某些情况下这可能很有用，例如，如果虚拟属性依赖于其他属性。
- en: Introduce a new virtual attribute by overriding getter for it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过覆盖获取器来引入一个新的虚拟属性。
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the model object, we defined a new `mutators` attribute, which provides our
    model with a getter for the new virtual attribute named `fullName`. This attribute
    is not assumed to be stored in the model, because it contains values of existing
    attributes `firstName` and `lastName`. Now, let's see how we can use an overridden
    getter.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模型对象中，我们定义了一个新的 `mutators` 属性，为名为 `fullName` 的新虚拟属性提供了获取器。这个属性不假定存储在模型中，因为它包含现有属性
    `firstName` 和 `lastName` 的值。现在，让我们看看我们如何使用覆盖的获取器。
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Override setter, so the virtual attribute is not actually saved in the model,
    but other attributes are updated instead.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖设置器，这样虚拟属性实际上不会在模型中保存，而是更新其他属性。
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the setter for the `fullName` attribute, we split a value into an array
    and then assign the `firstName` and `lastName` attributes with its parts. Here
    is an example which demonstrates how it can be used:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `fullName` 属性的设置器中，我们将值分割成一个数组，然后将 `firstName` 和 `lastName` 属性分配给它的部分。以下是一个示例，演示了如何使用它：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Initialize attributes using the set() method**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 set() 方法初始化属性**'
- en: If you use setter mutator for an attribute, the only way to trigger it is to
    call the `set()` method. Setter mutator won't work if you assign attributes when
    creating a new model, because in this case the `change` event is not triggered.
    Otherwise, you need to trigger the `change` event for a specific property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为属性使用设置器突变器，触发它的唯一方法是调用 `set()` 方法。如果你在创建新模型时分配属性，设置器突变器将不会工作，因为在这种情况下不会触发
    `change` 事件。否则，你需要为特定属性触发 `change` 事件。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Backbone.Mutators` extension overrides the `get()` and `set()` methods
    of `Bakcbone.Model`. New methods try to call overridden getters and setters. If
    not, run the original `get()` or `set()` methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.Mutators` 扩展覆盖了 `Bakcbone.Model` 的 `get()` 和 `set()` 方法。新方法尝试调用被覆盖的获取器和设置器。如果没有，则运行原始的
    `get()` 或 `set()` 方法。'
- en: It also overrides the `toJSON()` method and replaces attributes which have overridden
    getter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它还覆盖了 `toJSON()` 方法，并替换了被覆盖获取器的属性。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this section, we are going to learn the advanced usage of the `Backbone.Mutators`
    extension.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 `Backbone.Mutators` 扩展的高级用法。
- en: Overriding getter and setter of an existing attribute
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖现有属性的获取器和设置器
- en: 'Overriding setter of an existing attribute may be done if you need the attribute
    to be stored in a different format rather than the one in which it is outputted
    or inputted. You can override getter and setter for this attribute and solve this
    problem. Let''s see how to use `Backbone.Mutators` for existing attributes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将属性以不同于输出或输入的格式存储，可以覆盖现有属性的设置器。可以覆盖此属性的获取器和设置器以解决这个问题。让我们看看如何使用 `Backbone.Mutators`
    为现有属性：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this model, there is the `vip` attribute, which is `boolean`. We want this
    attribute to be represented as a string to the user, so we are going to override
    getter and setter for it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，存在一个 `vip` 属性，它是 `boolean` 类型的。我们希望这个属性以字符串形式呈现给用户，因此我们将覆盖它的获取器和设置器。
- en: The usage syntax stays the same as for a regular attribute.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法与常规属性相同。
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Mutators aim to override setters or getters, but they do not modify attribute
    values itself. You can always get the original attributes by accessing the `attributes`
    property of a model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Mutators旨在覆盖设置器或获取器，但它们本身不修改属性值。您可以通过访问模型的`attributes`属性来始终获取原始属性。
- en: Handling mutators events
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理mutators事件
- en: 'You can bind callback to the `mutators:set:*` event. Here is how it is done:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将回调绑定到`mutators:set:*`事件。以下是实现方式：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。事件和绑定")中*处理Backbone对象的事件*，*事件和绑定*
- en: Creating undo points to store/restore a model's state
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建撤销点以存储/恢复模型的状态
- en: 'Sometimes, you may need to manage the states of a model in your application.
    This can be useful in one of the following cases:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要在应用程序中管理模型的状态。在以下情况下这可能很有用：
- en: Your application requires an undo/redo feature
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用需要撤销/重做功能
- en: You want to implement transactions
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想实现事务
- en: Your application emulates some process
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用模拟某些过程
- en: You want to change a model temporarily and then restore it
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想临时更改模型然后恢复它
- en: Typically for all of the previous cases developers often use the `Memento` pattern.
    There is an implementation of this pattern in Backbone, which is available in
    the `Backbone.Memento` extension. This extension allows developers to store or
    restore a model's state and provides a stack for operating with multiple states.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于所有上述情况，开发者经常使用`Memento`模式。在Backbone中有一个此模式的实现，可在`Backbone.Memento`扩展中找到。此扩展允许开发者存储或恢复模型的状态，并提供一个用于操作多个状态的栈。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the `Backbone.Memento` extension from the **GitHub** page [https://github.com/derickbailey/backbone.memento](https://github.com/derickbailey/backbone.memento).
    To include this extension into your project, save the `backbone.memento.js` file
    into the `lib` folder and include a reference to it in `index.html`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从**GitHub**页面[https://github.com/derickbailey/backbone.memento](https://github.com/derickbailey/backbone.memento)下载`Backbone.Memento`扩展。要将此扩展包含到您的项目中，请将`backbone.memento.js`文件保存到`lib`文件夹中，并在`index.html`中包含对其的引用。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。理解Backbone")中详细描述了将Backbone扩展包含到您的项目中，*理解Backbone*的*扩展应用程序与插件*配方。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps to operate model states:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以操作模型状态：
- en: Extend a model with the `Backbone.Memento` extension in the `initialize()` method.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中扩展模型以使用`Backbone.Memento`扩展。
- en: '[PRE29]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create the model instance and initialize it with values.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模型实例并用值初始化它。
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Use the `store()` method to save a state.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`store()`方法保存状态。
- en: '[PRE31]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Update the model with temporary values.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模型以使用临时值。
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Use the `restore()` method to retrieve a previously saved state.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`restore()`方法检索之前保存的状态。
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Retrieve model values of the saved state.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取保存状态中的模型值。
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Memento uses the **LIFO** (**last in, first out**) data structure, also known
    as stack, for storing model states. So it is possible to save model states multiple
    times, and then restore them in a backward direction. The following diagram shows
    how it works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Memento使用**LIFO**（**后进先出**）数据结构，也称为栈，用于存储模型状态。因此，可以多次保存模型状态，然后以反向顺序恢复它们。以下图表显示了它是如何工作的：
- en: '![How it works...](img/2728OS_02_01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/2728OS_02_01.jpg)'
- en: Each time you call the `store()` method, the state is saved on top of the stack.
    Each time you call the `restore()` method, the state that was saved last is restored
    and deleted from the top of the stack.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`store()`方法时，状态都会被保存在栈顶。每次调用`restore()`方法时，最后保存的状态将被恢复并从栈顶删除。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this section, we are going to understand the advanced features of Memento.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解Memento的高级功能。
- en: Working with the Memento stack
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Memento栈工作
- en: 'Here is an example which demonstrates how to work with such stack of states:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何处理这样的状态栈：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we can see in the preceding code, dealing with stacks is quite easy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，处理栈相当简单。
- en: Restoring from the first state in the stack
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从栈中的第一个状态恢复
- en: Sometimes, it is required to reset a model to the state in which it was first
    saved in the stack, no matter how many states were saved after. This can be done
    using the `restart()` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，需要将模型重置为最初在堆栈中保存的状态，无论之后保存了多少状态。这可以通过使用`restart()`方法来完成。
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Ignoring attributes from being restored
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略被恢复的属性
- en: There is an interesting feature in `Backbone.Memento`, which allows you to ignore
    some model attributes from being saved or restored. It is very useful if a model
    contains some technical properties, which is not intended to be used as part of
    the state. When extending a model in the `initialize()` method, pass the properties
    to be ignored in the `ignore` option.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Backbone.Memento`中有一个有趣的功能，允许你忽略一些模型属性不被保存或恢复。如果一个模型包含一些技术属性，这些属性不是作为状态的一部分使用，这个功能就非常有用。当在`initialize()`方法中扩展模型时，将需要忽略的属性传递给`ignore`选项。
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Working with collections
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与集合一起工作
- en: The Memento extension also allows to extend a collection with Memento functionality.
    It provides the same methods when working with collections `store()`, `restore()`,
    and `restart()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Memento扩展还允许扩展集合以具有Memento功能。它在处理集合时提供相同的方法：`store()`、`restore()`和`restart()`。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is also another extension named `Backbone.actAs.Mementoable`, which implements
    the Memento pattern in a more accurate way, because it uses separate objects for
    storing states. It is more flexible, but does not provide stack out of the box
    and cannot ignore specific attributes from being saved/restored.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个名为`Backbone.actAs.Mementoable`的扩展，它以更准确的方式实现了Memento模式，因为它使用单独的对象来存储状态。它更灵活，但默认不提供堆栈，并且不能忽略特定属性被保存/恢复。
- en: '`Backbone.actAs.Mementoable` can be downloaded from the **GitHub** page [https://github.com/iVariable/Backbone.actAs.Mementoable](https://github.com/iVariable/Backbone.actAs.Mementoable).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.actAs.Mementoable`可以从**GitHub**页面[https://github.com/iVariable/Backbone.actAs.Mementoable](https://github.com/iVariable/Backbone.actAs.Mementoable)下载。'
- en: You can learn more about working with collections in [Chapter 3](ch03.html "Chapter 3. Collections"),
    *Collections*.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[第3章](ch03.html "第3章。集合") *集合* 中了解更多关于与集合一起工作的内容。
- en: Implementing workflow for a model
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模型的流程
- en: If you are implementing a business logic, which assumes that a model can be
    in different states and there are special rules applied to a state change, you
    should use the `workflow.js` extension, which is very helpful for building such
    kind of functionality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个业务逻辑，该逻辑假设模型可以处于不同的状态，并且对状态变化有特殊的规则，你应该使用`workflow.js`扩展，这对于构建此类功能非常有帮助。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the `workflow.js` extension from the GitHub page [https://github.com/kendagriff/workflow.js](https://github.com/kendagriff/workflow.js).
    To include this extension into your project, save the `workflow.js` file into
    the `lib` folder and include a reference to it in `index.html`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub页面[https://github.com/kendagriff/workflow.js](https://github.com/kendagriff/workflow.js)下载`workflow.js`扩展。要将此扩展包含到你的项目中，将`workflow.js`文件保存到`lib`文件夹中，并在`index.html`中包含对其的引用。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。理解Backbone") *理解Backbone* 的“通过插件扩展应用程序”配方中详细描述了如何将Backbone扩展包含到你的项目中。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's create a workflow for `InvoiceModel`, because it has a `status` attribute,
    which represents the model state and is well suited for a workflow example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`InvoiceModel`创建一个流程，因为它有一个`status`属性，它表示模型状态，非常适合作为流程示例。
- en: Draw a graph of the states and possible transitions.![How to do it...](img/2728OS_02_02.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制状态和可能转换的图。![如何做...](img/2728OS_02_02.jpg)
- en: Available states are draft, issued, paid, and canceled. There are also a few
    transitions available that allow one state to be changed into another. If there
    is no appropriate transition, then such a change is not possible.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可用的状态有草稿、已发行、已支付和已取消。还有一些允许一个状态变为另一个状态的转换。如果没有合适的转换，则这种变化是不可能的。
- en: Define `workflow` in code.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中定义`workflow`。
- en: '[PRE38]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we can see, there is a new `workflow` property which describes our workflow.
    Transitions are defined in an array, which is assigned to the `events` property.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，有一个新的`workflow`属性，它描述了我们的流程。转换定义在一个数组中，该数组被分配给`events`属性。
- en: Each element of the transitions array should contain the name of the transition,
    from state, and to state. Initial state of the model should be defined in the
    `initial` property.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转换数组中的每个元素都应该包含转换名称、起始状态和目标状态。模型初始状态应在 `initial` 属性中定义。
- en: In the previous example, in the `initialize()` method, we extend our model object
    with an instance of the `Backbone.Workflow` object and pass the state attribute
    name (`attrName`) as an option, which contains `'status'` instead of the default
    value `'workflow_state'`.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，在 `initialize()` 方法中，我们通过 `Backbone.Workflow` 对象的实例扩展了我们的模型对象，并将状态属性名称
    (`attrName`) 作为选项传递，其中包含 `'status'` 而不是默认值 `'workflow_state'`。
- en: Trigger workflow transition by calling the `triggerEvent()` method.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `triggerEvent()` 方法触发工作流转换。
- en: '[PRE39]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see in the preceding code, `triggerEvent()` accepts a single parameter,
    which is the transition name. In case if an inappropriate transition is triggered,
    then an exception is thrown.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前述代码所示，`triggerEvent()` 接受一个参数，即转换名称。如果触发了不适当的转换，则会抛出异常。
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Workflow.js` extension is written on **CoffeeScript** and is quite easy
    to understand. It just provides the `triggerEvent()` method, which switches the
    `workflow` property and triggers an event.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workflow.js` 扩展是用 **CoffeeScript** 编写的，并且很容易理解。它只提供了 `triggerEvent()` 方法，该方法切换
    `workflow` 属性并触发事件。'
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this section, we are going to learn how to handle transition events.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何处理转换事件。
- en: Binding callbacks to transition events
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定回调到转换事件
- en: Sometimes, you may want to execute a code when a specific transition is triggered.
    In this case, you need to bind a callback function to a transition event. This
    callback is executed if an event is being triggered.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想在特定转换被触发时执行代码。在这种情况下，你需要将回调函数绑定到转换事件。如果正在触发事件，则执行此回调。
- en: '`Workflow.js` provides two types of events `transition:from:*` and `transition:to:*`.
    The first one is triggered when a workflow loses a specific state, and the second
    one is triggered when a workflow reaches a specific state. Let''s define event
    bindings for our model.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workflow.js` 提供了两种类型的事件 `transition:from:*` 和 `transition:to:*`。第一种事件在工作流失去特定状态时触发，第二种事件在工作流达到特定状态时触发。让我们为我们的模型定义事件绑定。'
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, we bind a couple of callbacks, which update date attributes
    when appropriate events are triggered.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们绑定了一些回调函数，当适当的事件被触发时，这些回调函数会更新日期属性。
- en: The next code snippet is an example which demonstrates what happens when workflow
    events are triggered.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段是一个示例，演示了当工作流事件被触发时会发生什么。
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Always use the triggerEvent() method when changing state**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终在改变状态时使用 triggerEvent() 方法**'
- en: Event callback is executed if an event is triggered by the `triggerEvent()`
    method only. That is why an event callback is not executed when an object is initialized
    or if you use the `set()` method to update the workflow state.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当事件由 `triggerEvent()` 方法触发时，事件回调才会执行。这就是为什么当对象被初始化或者使用 `set()` 方法更新工作流状态时，事件回调不会执行。
- en: See also
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。事件和绑定") *事件和绑定* 中 *处理 Backbone 对象的事件*
- en: Using advanced validation in a model
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型中使用高级验证
- en: By default, Backbone provides a simple way for validating model attributes using
    the `validate()` method, which allows to create your own validating function,
    but this can take more developer's time compared to the usage of existing solutions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Backbone 提供了一种简单的方法来使用 `validate()` 方法验证模型属性，这允许你创建自己的验证函数，但与使用现有解决方案相比，这可能会花费开发者更多的时间。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Why don't you save time with another Backbone extension named `Backbone.Validation`,
    which provides lots of features and allows to reuse existing validators. It is
    available to download from the **GitHub** page [https://github.com/thedersen/backbone.validation](https://github.com/thedersen/backbone.validation).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么不使用另一个名为 `Backbone.Validation` 的 Backbone 扩展来节省时间，它提供了许多功能，并允许重用现有的验证器。它可以从
    **GitHub** 页面 [https://github.com/thedersen/backbone.validation](https://github.com/thedersen/backbone.validation)
    下载。
- en: To include this extension into your project, save the `backbone-validation.js`
    file in the `lib` folder and include a reference to it in `index.html`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此扩展包含到你的项目中，将 `backbone-validation.js` 文件保存到 `lib` 文件夹中，并在 `index.html` 中包含对其的引用。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。理解Backbone")的*通过插件扩展应用*食谱中详细描述了将Backbone扩展包含到你的项目中。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to set the validation criteria for a model:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以设置模型的验证标准：
- en: Extend `Backbone.object()` with `Backbone.Validation.mixin`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Backbone.Validation.mixin`扩展`Backbone.object()`。
- en: '[PRE42]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is more information about mixins in the *Using mixins with Backbone objects*
    recipe in [Chapter 8](ch08.html "Chapter 8. Special Techniques"), *Special Techniques*.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。特殊技术")的*使用mixins与Backbone对象*食谱中可以找到更多关于mixins的信息，*特殊技术*。
- en: Define the validation criteria in the `validation` property.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`validation`属性中定义验证标准。
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Backbone.Validation` extension overrides the `validate()` method of `Backbone.Model`,
    so we can still call the `validate()` and `isValid()` methods as usual, and validation
    is performed automatically when a model is updated. Let's check this out.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.Validation`扩展覆盖了`Backbone.Model`的`validate()`方法，因此我们仍然可以像往常一样调用`validate()`和`isValid()`方法，并且当模型更新时，验证会自动执行。让我们看看这个例子。'
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this section, we are going to learn more about built-in validators.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习更多关于内置验证器的知识。
- en: Using built-in validators
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置验证器
- en: In the previous example, we reused existing validators, such as `required` and
    `pattern`. They are named built-in validators. In this recipe, we are going to
    learn how to use all of them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们重用了现有的验证器，例如`required`和`pattern`。它们被称为内置验证器。在本食谱中，我们将学习如何使用它们的所有功能。
- en: '**required**: It validates if the attribute is required or not. It can be equal
    to true or false.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**required**: 它验证属性是否必需。它可以等于true或false。'
- en: '[PRE45]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**acceptance**: It validates if something has to be accepted, for example,
    terms of use. It checks whether the attribute value is true or false. It works
    with `boolean` attributes.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**acceptance**: 它验证是否必须接受某些内容，例如使用条款。它检查属性值是否为true或false。它与`boolean`属性一起工作。'
- en: '[PRE46]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**min**: It validates that the attribute value has to be a number and equal
    to or greater than the min value specified.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**min**: 它验证属性值必须是一个数字，并且等于或大于指定的最小值。'
- en: '[PRE47]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**max**: It validates that the attribute value has to be a number and equal
    to or less than the max value specified.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max**: 它验证属性值必须是一个数字，并且等于或小于指定的最大值。'
- en: '[PRE48]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**range**: It validates that the attribute value has to be a number and equal
    to or between the two numbers specified.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**range**: 它验证属性值必须是一个数字，并且等于或介于指定的两个数字之间。'
- en: '[PRE49]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**length**: It validates that the attribute value has to be a string with length
    equal to the length value specified.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**: 它验证属性值必须是一个字符串，其长度等于指定的长度值。'
- en: '[PRE50]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**minLength**: It validates that the attribute value has to be a string with
    length equal to or greater than the min length value specified.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minLength**: 它验证属性值必须是一个字符串，其长度等于或大于指定的最小长度值。'
- en: '[PRE51]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**maxLength**: It validates that the attribute value has to be a string with
    length equal to or less than the max length value specified.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxLength**: 它验证属性值必须是一个字符串，其长度等于或小于指定的最大长度值。'
- en: '[PRE52]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**rangeLength**: It validates that the attribute value has to be a string and
    equal to or between the two numbers specified.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rangeLength**: 它验证属性值必须是一个字符串，并且等于或介于指定的两个数字之间。'
- en: '[PRE53]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**oneOf**: It validates that the attribute value has to be equal to one of
    the elements in the specified array. It uses case-sensitive matching.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oneOf**: 它验证属性值必须等于指定数组中的某个元素。它使用区分大小写的匹配。'
- en: '[PRE54]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**equalTo**: It validates that the attribute value has to be equal to the value
    of the attribute with the name specified.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**equalTo**: 它验证属性值必须等于指定名称的属性的值。'
- en: '[PRE55]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**pattern**: It validates that the attribute value has to match the pattern
    specified. It can be a regular expression or the name of one of the built-in patterns.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pattern**: 它验证属性值必须匹配指定的模式。它可以是一个正则表达式，或者内置模式之一的名字。'
- en: '[PRE56]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Pattern can accept one of the following attribute values:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模式可以接受以下属性值之一：
- en: '**number**: matches any decimal number'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**number**: 匹配任何十进制数字'
- en: '**digits**: matches any digit sequence'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**digits**: 匹配任何数字序列'
- en: '**email**: matches a valid email address'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**email**: 匹配有效的电子邮件地址'
- en: '**url**: matches any valid URL'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**url**: 匹配任何有效的URL'
- en: You can also specify any regular expression instead.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以指定任何正则表达式。
- en: '[PRE57]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In this recipe, we learned the basics of the `Backbone.Validation` extension,
    though there are even more techniques that you can find on the **GitHub** documentation
    page [https://github.com/thedersen/backbone.validation](https://github.com/thedersen/backbone.validation).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了`Backbone.Validation`扩展的基础知识，尽管还有更多技术可以在**GitHub**文档页面[https://github.com/thedersen/backbone.validation](https://github.com/thedersen/backbone.validation)上找到。
- en: There are also a couple of alternatives to `Backbone.Validation`. They are `Backbone.validations`
    and `Backbone.Validator` extensions. They are all very similar, but `Backbone.Validation`
    has better documentation and provides more methods and events.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.Validation`还有一些替代方案。它们是`Backbone.validations`和`Backbone.Validator`扩展。它们都非常相似，但`Backbone.Validation`有更好的文档，并提供更多方法和事件。'
- en: Validating an HTML form
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证HTML表单
- en: Most of the web applications use HTML forms for data input, and Backbone is
    not an exception. An application should let the user know about any validation
    errors. Implementation of such functionality could fall on the developers' shoulders,
    but not in Backbone!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序使用HTML表单进行数据输入，Backbone也不例外。应用程序应该让用户了解任何验证错误。此类功能的实现可能落在开发者的肩上，但不是在Backbone中！
- en: Fortunately, `Backbone.Validation` provides integration with a view and works
    well with HTML forms.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Backbone.Validation`提供了与视图的集成，并且与HTML表单配合良好。
- en: Getting ready
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have the `Backbone.Validation` extension installed. Installation
    is described in the previous recipe *Using advanced validation in a model*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装`Backbone.Validation`扩展。安装方法在之前的菜谱*在模型中使用高级验证*中描述。
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following step to validate a form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以验证表单：
- en: To allow form validation, we need to bind a view to a `Backbone.Validation`
    object in the `initialize()` method of the view.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许表单验证，我们需要在视图的`initialize()`方法中将视图绑定到`Backbone.Validation`对象。
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`Backbone.Validation` assumes that your model is stored in `this.model` and
    you have implemented getting data from the form elements and updating model values
    with it.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.Validation`假设您的模型存储在`this.model`中，并且您已经实现了从表单元素获取数据并使用它更新模型值。'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If a user enters information that does not validate, then `Backbone.Validation`
    adds the `invalid` class to an appropriate form element and sets the `data-error`
    attribute with an error message.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的信息无法验证，那么`Backbone.Validation`会将`invalid`类添加到适当的表单元素中，并使用错误消息设置`data-error`属性。
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`data-*` attributes are an HTML5 feature. They can be easily displayed with
    the help of CSS3 or custom JavaScript. They are also supported by major web frontend
    frameworks, such as jQueryMobile or Twitter Bootstrap.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-*`属性是HTML5的一个特性。它们可以通过CSS3或自定义JavaScript轻松显示。它们也受到主要前端框架的支持，如jQueryMobile或Twitter
    Bootstrap。'
- en: 'The following screenshot illustrates how `Backbone.Validation` validates wrong
    data entered into the HTML form:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了`Backbone.Validation`如何验证HTML表单中输入的错误数据：
- en: '![How it works...](img/2728OS_02_03.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/2728OS_02_03.jpg)'
- en: There's more...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following code snippet is a full listing of the example for this recipe:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是此菜谱示例的完整列表：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Working with nested attributes in a model
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型中处理嵌套属性
- en: Sometimes nested attributes are required to operate with complex hierarchical
    structures stored in the model. This is typically done by using JavaScript objects
    as nested attributes; however, it is not a Backbone way. Fortunately, there is
    the `Backbone-Nested` extension, which provides various improvements when working
    with nested attributes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要嵌套属性来操作存储在模型中的复杂层次结构。这通常是通过使用JavaScript对象作为嵌套属性来完成的；然而，这不是Backbone的方式。幸运的是，有`Backbone-Nested`扩展，它在使用嵌套属性时提供了各种改进。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the `Backbone-Nested` extension from the **GitHub** page [https://github.com/afeld/backbone-nested](https://github.com/afeld/backbone-nested).
    To include this extension into your project, save the `backbone-nested.js` file
    into the `lib` folder and include a reference to it in `index.html`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从**GitHub**页面[https://github.com/afeld/backbone-nested](https://github.com/afeld/backbone-nested)下载`Backbone-Nested`扩展。要将此扩展包含到您的项目中，将`backbone-nested.js`文件保存到`lib`文件夹中，并在`index.html`中包含对其的引用。
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Including Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。理解 Backbone") 的 *使用插件扩展应用程序* 菜谱中描述了将 Backbone 扩展添加到您的项目中，*详细理解
    Backbone*。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to use nested attributes in a model:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模型中使用嵌套属性，请执行以下步骤：
- en: Use `Backnone.NestedModel` as the base object when extending a new model.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在扩展新模型时，使用 `Backnone.NestedModel` 作为基础对象。
- en: '[PRE60]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Set the nested attribute value with the help of dot syntax provided by the `Backbone-Nested`
    extension.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Backbone-Nested` 扩展提供的点语法设置嵌套属性值。
- en: '[PRE61]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can still use object syntax, which is typical to JavaScript, to set multiple
    values.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您仍然可以使用典型的 JavaScript 对象语法来设置多个值。
- en: '[PRE62]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Get the attribute value with the dot syntax.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点语法获取属性值。
- en: '[PRE63]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Backbone-Nested` extension provides a new model object `Backbone.NestedModel`
    based on `Backbone.Model`. It overrides existing methods, such as `get()`, `set()`,
    `has()`, `toJSON`, and so on. It also provides new `add()` and `remove()` methods.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone-Nested` 扩展基于 `Backbone.Model` 提供了一个新的模型对象 `Backbone.NestedModel`。它覆盖了现有方法，如
    `get()`、`set()`、`has()`、`toJSON` 等。它还提供了新的 `add()` 和 `remove()` 方法。'
- en: There's more...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This section describes advanced usage of the `Backbone-Nested` extension.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 `Backbone-Nested` 扩展的高级用法。
- en: Working with a nested array of attributes
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用嵌套属性数组进行操作
- en: Of course, there is a way of working with a bit more complex structures, such
    as nested array of attributes. You can set it using the object syntax as well.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有处理更复杂结构（如嵌套属性数组）的方法。您也可以使用对象语法来设置它。
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Or you can set attributes in the nested array with a dot and bracket syntax,
    as shown in following example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用点和中括号语法在嵌套数组中设置属性，如下面的示例所示：
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: And the same syntax is used for getting attributes from the nested array.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 并且相同的语法也用于从嵌套数组中获取属性。
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Adding/removing elements to/from a nested array
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向/从嵌套数组中添加/删除元素
- en: '`Backbone-Nested` provides additional methods to work with nested arrays. The
    `add` method adds a new element to a nested array. Here is how it works.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone-Nested` 提供了处理嵌套数组的一些额外方法。`add` 方法可以向嵌套数组中添加新元素。以下是它的工作方式。'
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `remove()` method removes desired elements from a nested array. Let's see
    how it is done.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()` 方法从嵌套数组中删除所需的元素。让我们看看它是如何完成的。'
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Binding callbacks to an events
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将回调绑定到事件
- en: 'When binding a callback to an event, you can use the same dot and bracket syntax
    as described previously. Let''s check out the following example of binding a callback
    to an event:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当将回调绑定到事件时，您可以使用之前描述的相同的点和中括号语法。让我们看看以下将回调绑定到事件的示例：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Moreover, `Backbone-Nested` provides additional `add:*` and `remove:*` events
    for handling array update events.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Backbone-Nested` 还提供了额外的 `add:*` 和 `remove:*` 事件来处理数组更新事件。
- en: See also
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is more information about event handling available in the recipe *Handling
    events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events and Bindings"),
    *Events and Bindings*.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。事件和绑定") 的 *处理 Backbone 对象的事件* 菜谱中可以找到更多关于事件处理的信息，*事件和绑定*。
- en: There are a couple of alternatives to the `Backbone-Nested` extension, such
    as `Backbone-deep-model` and `Backbone-dotattr`. They are all very similar, but
    `Backbone-Nested` provides more features, and is better maintained.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone-Nested` 扩展有一些替代方案，例如 `Backbone-deep-model` 和 `Backbone-dotattr`。它们都非常相似，但
    `Backbone-Nested` 提供了更多功能，并且维护得更好。'
- en: Implementing a one-to-one relationship
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一对一关系
- en: Mostly in any application, we may need to have models that are related to each
    other. For example, a blog post model can have a relationship with a model of
    its author or have a connection to a comment model.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，我们可能都需要具有相互关联的模型。例如，博客文章模型可以与其作者的模型或评论模型相关联。
- en: We may also need to access comments quickly when dealing with a blog post, or
    list all blog posts of a specific author. Moreover, we may want to export blog
    posts with author info and comments in a single JSON format.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理博客文章时，我们可能还需要快速访问评论，或者列出特定作者的博客文章列表。此外，我们可能希望以单个 JSON 格式导出包含作者信息和评论的博客文章。
- en: In a Backbone app, this can be implemented with the help of the `Backbone-relational`
    extension.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Backbone 应用程序中，这可以通过 `Backbone-relational` 扩展来实现。
- en: Getting ready
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the `Backbone-relational` extension from the **GitHub** page
    [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational).
    To include `Backbone-relational` into your project, save the `backbone-relational.js`
    file into the `lib` folder and include a reference to it in `index.html`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 **GitHub** 页面 [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational)
    下载 `Backbone-relational` 扩展。要将 `Backbone-relational` 包含到您的项目中，将 `backbone-relational.js`
    文件保存到 `lib` 文件夹，并在 `index.html` 中包含对其的引用。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。理解 Backbone") 的 *使用插件扩展应用程序* 菜单中详细描述了将 Backbone 扩展包含到您的项目中。
- en: How to do it...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's recall our Invoice application and try to find out how we can apply a
    one-to-one relationship there. Let's say we want buyers to log in to the application
    and view all invoices assigned to them.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾我们的发票应用程序，并尝试找出我们如何在其中应用一对一关系。假设我们希望买家登录应用程序并查看分配给他们的所有发票。
- en: In this case, we need to store buyer credentials somewhere. It can be a new
    `UserModel` associated with an existing `BuyerModel`. We know that for each user
    there is a single buyer and vice versa, so we are dealing with a one-to-one relationship.
    Let's implement one such one-to-one relationship.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要将买家凭证存储在某个地方。这可以是一个与现有 `BuyerModel` 关联的新 `UserModel`。我们知道每个用户对应一个买家，反之亦然，所以我们处理的是一对一关系。让我们实现这样一个一对一关系。
- en: Extend models from `Backbone.RelationalModel` and pass the `relations` property
    with a relationship definition.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Backbone.RelationalModel` 扩展模型，并传递带有关系定义的 `relations` 属性。
- en: '[PRE70]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As we see from the previous example, the `relations` property takes an array,
    so multiple relationships are possible.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前例所示，`relations` 属性接受一个数组，因此可能存在多个关系。
- en: Tip
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that `UserModel` should be defined before `BuyerModel`, because it is referenced
    afterwards in the code (in the `relations` property of `BuyerModel`).
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`UserModel` 应该在 `BuyerModel` 之前定义，因为它在代码中之后被引用（在 `BuyerModel` 的 `relations`
    属性中）。
- en: Initialize a one-to-one relationship by referencing the `UserModel` instance
    in the `BuyerModel` instance or vice versa.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `BuyerModel` 实例中引用 `UserModel` 实例或反之亦然来初始化一对一关系。
- en: '[PRE71]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There is also a way to do the same by passing a single input JSON when creating
    both `BuyerModel` and `UserModel`.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建 `BuyerModel` 和 `UserModel` 时，也可以通过传递单个输入 JSON 来实现相同的效果。
- en: '[PRE72]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If a reversed relation is defined, pass a `BuyerModel` array when initializing
    `UserModel`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果定义了反向关系，则在初始化 `UserModel` 时传递一个 `BuyerModel` 数组。
- en: '[PRE73]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Optionally, access the related model with the help of the `get()` method.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，使用 `get()` 方法帮助访问相关模型。
- en: '[PRE74]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each `Backbone.RelationalModel` registers itself with `Backbone.Store` upon
    creation (and is removed from the `Store` when destroyed). When creating or updating
    an attribute that is a key in a relation, removed related objects are notified
    of their removal, and new related objects are looked up in the `Store`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Backbone.RelationalModel` 在创建时会将自己注册到 `Backbone.Store`（在销毁时从 `Store` 中移除）。当创建或更新一个关系中的键属性时，被移除的相关对象会收到移除通知，而新的相关对象会在
    `Store` 中查找。
- en: See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: One-to-many relationships and many-to-many relationships are described in the
    recipe *Implementing a one-to-many relationship* in [Chapter 3](ch03.html "Chapter 3. Collections"),
    *Collections*.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多关系和多对多关系在 [第 3 章](ch03.html "第 3 章。集合") 的 *实现一对一关系* 菜单中描述，*集合*。
- en: Complete documentation to the `Backbone-relational` extension can be found on
    the **GitHub** page [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational).
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone-relational` 扩展的完整文档可以在 **GitHub** 页面 [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational)
    上找到。'
- en: Also, there are a couple of alternatives to `Backbone-relational`, which are
    very similar and known as `Backbone-associations` and `ligament.js`. However,
    they do not provide one-to-many and many-to-many relationships.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一些与 `Backbone-relational` 非常相似但称为 `Backbone-associations` 和 `ligament.js`
    的替代方案。然而，它们不提供一对一和多对多关系。
