- en: Chapter 2. Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating with model attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating with model identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating model attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating undo points to store/restore a model's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing workflow for a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced validation in a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating an HTML form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with nested attributes in a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a one-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we are going to learn what a Backbone model is and how can we
    use it. We are also going to consider various Backbone extensions, which provide
    lots of improvement and bring amazing features to our models.
  prefs: []
  type: TYPE_NORMAL
- en: The first three recipes of the current chapter contain information for beginners
    who are not familiar with Backbone yet; and other recipes bring additional value
    and cover more advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A model is a building brick of any MVC application, which contains data, provides
    validation, performs access control, and implements specific business logic required
    by an application. In `Backbone.js`, a model is defined by extending its instance
    from the `Backbone.Model` object. In this recipe, we are going to learn how to
    work with models in `Backbone.js`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to define a new model object and create its instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a model by extending `Backbone.Model`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no need to define a data structure inside the model object, because
    Backbone allows it to be defined dynamically when the model is initialized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a `Backbone.Model` instance and initialize it with attribute values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to clone a model and how to initialize
    a model with default values.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you assign a model to another variable, it makes one model reflect changes
    in another model. If you need an independent copy of a model, use the `clone()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting default attribute values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you may want your model to have attributes that are initialized
    with default values when a new model instance is created, so you don''t need to
    set them manually. Here is how default attributes are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows that the `quantity` and `date` attributes are initialized
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting default attribute values with a multiline expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to set default values with a multiline expression you can wrap it
    into a function and call it when setting default attributes in `defaults`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is also a way to do the same in the `initialize()` method, which is called
    right after the model object is created and initialized with values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `initialize()` method we set the `date` attribute to today's date using
    JavaScript's `Date` object. Before doing this, we need to check that the `date`
    attribute is not initialized yet, so we do not override it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the default attributes are defined, then they can override the attributes
    defined in the `initialize()` method, and so we need to remove such attributes
    from the `default` values, otherwise they are initialized as defaults instead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the current recipe examples, we used the `has()` and `set()` methods, which
    are described in the following recipe: *Operating with model attributes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating with model attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes are where a model stores all its data. Unlike model properties, which
    are used for storing internal object information, attributes cannot be accessed
    via the `.` operator. There are special methods to work with them, which we are
    going to learn in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main methods to work with model attributes are `get()`, `set()`, `unset()`,and
    `clear()`.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `get()` method to get an attribute value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the attribute is not found, `undefined` is returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the `set()` method to update/create a single attribute value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To update multiple attributes use key-value format.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: When setting an attribute if it does not exist, one is created. The `set()`
    method returns a reference with the value `true` to the model, if validation does
    not fail; otherwise returns the value `false`. We will learn more about validation
    in the recipe, *Validating model attributes*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the `unset()` method to delete an attribute from a model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `clear()` method to delete all attributes from a model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes are stored in the `attributes` property. It is better not to access
    attributes directly and to use methods we have learned previously; otherwise,
    it can break the event triggering mechanism or integration with other Backbone
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: When a new module is initialized, values from the `defaults` property are assigned
    to the `attributes` one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we are going to learn some useful methods with the model attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if a model has an attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check if a model has an attribute, use the `has()` method. It returns `true`
    if the attribute exists, otherwise `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Getting HTML escaped attribute value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are going to display user-entered text, which you assume is in plain
    text format, you should worry about security issues. The best way to prevent vulnerability
    which may lead to possible XSS attacks is to use the `escape()` method before
    outputting any user entered text. This disallows the browser to parse any HTML
    code by escaping HTML characters. Let''s figure out how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Operating with the model identifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each model has a unique identifier property ID, which allows distinguishing
    one model from another. When developing a Backbone application it is often required
    to operate with an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps explains how to set and get the `id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and getting the `id` property is really easy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Getting the id property looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `id` property provides direct access to an attribute where the identifier
    is stored. By default it is `id`; however, you can override it by setting `idAttribute`
    when extending a model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When a new model is created, the identifier is empty unless it is manually assigned.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `id` is not initialized yet in your model, then you can use a client identifier,
    which can be accessed using the `cid` property. The value of `cid` is unique and
    assigned automatically when a new model instance is created. Client IDs can take
    forms, such as `c0`, `c1`, `c2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Validating model attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prevent unexpected behavior, we often need to validate model attributes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to set up an attribute validation:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation can be done by defining the `validate()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `attrs` parameter contains the attribute values that were changed. The `validate()`
    method will return an error message if they do not validate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Attribute validation is triggered on the `save()` method. It can also trigger
    on the `set()` method if you pass `{validate: true}` as the last parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When validating a model you can still access old attribute values with the help
    of `this.get()` or `this.attributes`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`validate` is called before `save()`, and accepts the updated model attributes,
    which are passed from `save()`. If `validate()` returns an error string, `save()`
    will not continue, and the model attributes will not be modified. Failed validation
    triggers the `invalid` event. If you want validation to be triggered in the `set()`
    method, pass `{validate: true}` as the last parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to investigate more details about validation.
  prefs: []
  type: TYPE_NORMAL
- en: Handling validation errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a model does not validate, we often need to continue running an application
    and provide a custom code for handling events. Let's check out how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Such an error handler should be bound before the validation event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another way of handling events, which allows us to pass an error
    handling function as an option to the `set()`, `fetch()`, `save()`, or `destroy()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Triggering validation manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though validation is performed every time a model is updated or saved to the
    storage, sometimes you may want to check manually if the model validates. Let's
    figure out how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`isValid()` returns true or false, but does not trigger the `invalid` event.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it is required to override getters or setters in your application.
    There can be different reasons to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: An attribute is stored in a different format rather than a format for input
    or output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a virtual attribute that is not stored in the model, but depends on
    other attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent illegal values to be assigned to an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Backbone does not allow users to override getters or setters, but
    there is an extension named `Backbone.Mutators`, which allows you to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a link to download `Backbone.Mutators` from the **GitHub** page [https://github.com/asciidisco/Backbone.Mutators](https://github.com/asciidisco/Backbone.Mutators).
  prefs: []
  type: TYPE_NORMAL
- en: To include this extension into your project, save the `backbone.mutators.js`
    file into the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can specify a getter or setter for a virtual attribute that does not exist.
    This can be helpful in some cases, for example, if a virtual attribute depends
    on other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Introduce a new virtual attribute by overriding getter for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the model object, we defined a new `mutators` attribute, which provides our
    model with a getter for the new virtual attribute named `fullName`. This attribute
    is not assumed to be stored in the model, because it contains values of existing
    attributes `firstName` and `lastName`. Now, let's see how we can use an overridden
    getter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Override setter, so the virtual attribute is not actually saved in the model,
    but other attributes are updated instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the setter for the `fullName` attribute, we split a value into an array
    and then assign the `firstName` and `lastName` attributes with its parts. Here
    is an example which demonstrates how it can be used:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Initialize attributes using the set() method**'
  prefs: []
  type: TYPE_NORMAL
- en: If you use setter mutator for an attribute, the only way to trigger it is to
    call the `set()` method. Setter mutator won't work if you assign attributes when
    creating a new model, because in this case the `change` event is not triggered.
    Otherwise, you need to trigger the `change` event for a specific property.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Backbone.Mutators` extension overrides the `get()` and `set()` methods
    of `Bakcbone.Model`. New methods try to call overridden getters and setters. If
    not, run the original `get()` or `set()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: It also overrides the `toJSON()` method and replaces attributes which have overridden
    getter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn the advanced usage of the `Backbone.Mutators`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding getter and setter of an existing attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Overriding setter of an existing attribute may be done if you need the attribute
    to be stored in a different format rather than the one in which it is outputted
    or inputted. You can override getter and setter for this attribute and solve this
    problem. Let''s see how to use `Backbone.Mutators` for existing attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this model, there is the `vip` attribute, which is `boolean`. We want this
    attribute to be represented as a string to the user, so we are going to override
    getter and setter for it.
  prefs: []
  type: TYPE_NORMAL
- en: The usage syntax stays the same as for a regular attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mutators aim to override setters or getters, but they do not modify attribute
    values itself. You can always get the original attributes by accessing the `attributes`
    property of a model.
  prefs: []
  type: TYPE_NORMAL
- en: Handling mutators events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can bind callback to the `mutators:set:*` event. Here is how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating undo points to store/restore a model's state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to manage the states of a model in your application.
    This can be useful in one of the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application requires an undo/redo feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to implement transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application emulates some process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to change a model temporarily and then restore it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically for all of the previous cases developers often use the `Memento` pattern.
    There is an implementation of this pattern in Backbone, which is available in
    the `Backbone.Memento` extension. This extension allows developers to store or
    restore a model's state and provides a stack for operating with multiple states.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the `Backbone.Memento` extension from the **GitHub** page [https://github.com/derickbailey/backbone.memento](https://github.com/derickbailey/backbone.memento).
    To include this extension into your project, save the `backbone.memento.js` file
    into the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to operate model states:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend a model with the `Backbone.Memento` extension in the `initialize()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the model instance and initialize it with values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `store()` method to save a state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the model with temporary values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `restore()` method to retrieve a previously saved state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Retrieve model values of the saved state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Memento uses the **LIFO** (**last in, first out**) data structure, also known
    as stack, for storing model states. So it is possible to save model states multiple
    times, and then restore them in a backward direction. The following diagram shows
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2728OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each time you call the `store()` method, the state is saved on top of the stack.
    Each time you call the `restore()` method, the state that was saved last is restored
    and deleted from the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to understand the advanced features of Memento.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Memento stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example which demonstrates how to work with such stack of states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, dealing with stacks is quite easy.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring from the first state in the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it is required to reset a model to the state in which it was first
    saved in the stack, no matter how many states were saved after. This can be done
    using the `restart()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring attributes from being restored
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an interesting feature in `Backbone.Memento`, which allows you to ignore
    some model attributes from being saved or restored. It is very useful if a model
    contains some technical properties, which is not intended to be used as part of
    the state. When extending a model in the `initialize()` method, pass the properties
    to be ignored in the `ignore` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Working with collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Memento extension also allows to extend a collection with Memento functionality.
    It provides the same methods when working with collections `store()`, `restore()`,
    and `restart()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also another extension named `Backbone.actAs.Mementoable`, which implements
    the Memento pattern in a more accurate way, because it uses separate objects for
    storing states. It is more flexible, but does not provide stack out of the box
    and cannot ignore specific attributes from being saved/restored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Backbone.actAs.Mementoable` can be downloaded from the **GitHub** page [https://github.com/iVariable/Backbone.actAs.Mementoable](https://github.com/iVariable/Backbone.actAs.Mementoable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about working with collections in [Chapter 3](ch03.html "Chapter 3. Collections"),
    *Collections*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing workflow for a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are implementing a business logic, which assumes that a model can be
    in different states and there are special rules applied to a state change, you
    should use the `workflow.js` extension, which is very helpful for building such
    kind of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the `workflow.js` extension from the GitHub page [https://github.com/kendagriff/workflow.js](https://github.com/kendagriff/workflow.js).
    To include this extension into your project, save the `workflow.js` file into
    the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a workflow for `InvoiceModel`, because it has a `status` attribute,
    which represents the model state and is well suited for a workflow example.
  prefs: []
  type: TYPE_NORMAL
- en: Draw a graph of the states and possible transitions.![How to do it...](img/2728OS_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Available states are draft, issued, paid, and canceled. There are also a few
    transitions available that allow one state to be changed into another. If there
    is no appropriate transition, then such a change is not possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define `workflow` in code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, there is a new `workflow` property which describes our workflow.
    Transitions are defined in an array, which is assigned to the `events` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each element of the transitions array should contain the name of the transition,
    from state, and to state. Initial state of the model should be defined in the
    `initial` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the previous example, in the `initialize()` method, we extend our model object
    with an instance of the `Backbone.Workflow` object and pass the state attribute
    name (`attrName`) as an option, which contains `'status'` instead of the default
    value `'workflow_state'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Trigger workflow transition by calling the `triggerEvent()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see in the preceding code, `triggerEvent()` accepts a single parameter,
    which is the transition name. In case if an inappropriate transition is triggered,
    then an exception is thrown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Workflow.js` extension is written on **CoffeeScript** and is quite easy
    to understand. It just provides the `triggerEvent()` method, which switches the
    `workflow` property and triggers an event.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to handle transition events.
  prefs: []
  type: TYPE_NORMAL
- en: Binding callbacks to transition events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you may want to execute a code when a specific transition is triggered.
    In this case, you need to bind a callback function to a transition event. This
    callback is executed if an event is being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '`Workflow.js` provides two types of events `transition:from:*` and `transition:to:*`.
    The first one is triggered when a workflow loses a specific state, and the second
    one is triggered when a workflow reaches a specific state. Let''s define event
    bindings for our model.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we bind a couple of callbacks, which update date attributes
    when appropriate events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: The next code snippet is an example which demonstrates what happens when workflow
    events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Always use the triggerEvent() method when changing state**'
  prefs: []
  type: TYPE_NORMAL
- en: Event callback is executed if an event is triggered by the `triggerEvent()`
    method only. That is why an event callback is not executed when an object is initialized
    or if you use the `set()` method to update the workflow state.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced validation in a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Backbone provides a simple way for validating model attributes using
    the `validate()` method, which allows to create your own validating function,
    but this can take more developer's time compared to the usage of existing solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why don't you save time with another Backbone extension named `Backbone.Validation`,
    which provides lots of features and allows to reuse existing validators. It is
    available to download from the **GitHub** page [https://github.com/thedersen/backbone.validation](https://github.com/thedersen/backbone.validation).
  prefs: []
  type: TYPE_NORMAL
- en: To include this extension into your project, save the `backbone-validation.js`
    file in the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to set the validation criteria for a model:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `Backbone.object()` with `Backbone.Validation.mixin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is more information about mixins in the *Using mixins with Backbone objects*
    recipe in [Chapter 8](ch08.html "Chapter 8. Special Techniques"), *Special Techniques*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define the validation criteria in the `validation` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Backbone.Validation` extension overrides the `validate()` method of `Backbone.Model`,
    so we can still call the `validate()` and `isValid()` methods as usual, and validation
    is performed automatically when a model is updated. Let's check this out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn more about built-in validators.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in validators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, we reused existing validators, such as `required` and
    `pattern`. They are named built-in validators. In this recipe, we are going to
    learn how to use all of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**required**: It validates if the attribute is required or not. It can be equal
    to true or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**acceptance**: It validates if something has to be accepted, for example,
    terms of use. It checks whether the attribute value is true or false. It works
    with `boolean` attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**min**: It validates that the attribute value has to be a number and equal
    to or greater than the min value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**max**: It validates that the attribute value has to be a number and equal
    to or less than the max value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**range**: It validates that the attribute value has to be a number and equal
    to or between the two numbers specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**length**: It validates that the attribute value has to be a string with length
    equal to the length value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**minLength**: It validates that the attribute value has to be a string with
    length equal to or greater than the min length value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**maxLength**: It validates that the attribute value has to be a string with
    length equal to or less than the max length value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**rangeLength**: It validates that the attribute value has to be a string and
    equal to or between the two numbers specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**oneOf**: It validates that the attribute value has to be equal to one of
    the elements in the specified array. It uses case-sensitive matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**equalTo**: It validates that the attribute value has to be equal to the value
    of the attribute with the name specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**pattern**: It validates that the attribute value has to match the pattern
    specified. It can be a regular expression or the name of one of the built-in patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pattern can accept one of the following attribute values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**number**: matches any decimal number'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**digits**: matches any digit sequence'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**email**: matches a valid email address'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**url**: matches any valid URL'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also specify any regular expression instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned the basics of the `Backbone.Validation` extension,
    though there are even more techniques that you can find on the **GitHub** documentation
    page [https://github.com/thedersen/backbone.validation](https://github.com/thedersen/backbone.validation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also a couple of alternatives to `Backbone.Validation`. They are `Backbone.validations`
    and `Backbone.Validator` extensions. They are all very similar, but `Backbone.Validation`
    has better documentation and provides more methods and events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating an HTML form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the web applications use HTML forms for data input, and Backbone is
    not an exception. An application should let the user know about any validation
    errors. Implementation of such functionality could fall on the developers' shoulders,
    but not in Backbone!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, `Backbone.Validation` provides integration with a view and works
    well with HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have the `Backbone.Validation` extension installed. Installation
    is described in the previous recipe *Using advanced validation in a model*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following step to validate a form:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow form validation, we need to bind a view to a `Backbone.Validation`
    object in the `initialize()` method of the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`Backbone.Validation` assumes that your model is stored in `this.model` and
    you have implemented getting data from the form elements and updating model values
    with it.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a user enters information that does not validate, then `Backbone.Validation`
    adds the `invalid` class to an appropriate form element and sets the `data-error`
    attribute with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`data-*` attributes are an HTML5 feature. They can be easily displayed with
    the help of CSS3 or custom JavaScript. They are also supported by major web frontend
    frameworks, such as jQueryMobile or Twitter Bootstrap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates how `Backbone.Validation` validates wrong
    data entered into the HTML form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2728OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code snippet is a full listing of the example for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Working with nested attributes in a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes nested attributes are required to operate with complex hierarchical
    structures stored in the model. This is typically done by using JavaScript objects
    as nested attributes; however, it is not a Backbone way. Fortunately, there is
    the `Backbone-Nested` extension, which provides various improvements when working
    with nested attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the `Backbone-Nested` extension from the **GitHub** page [https://github.com/afeld/backbone-nested](https://github.com/afeld/backbone-nested).
    To include this extension into your project, save the `backbone-nested.js` file
    into the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to use nested attributes in a model:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `Backnone.NestedModel` as the base object when extending a new model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the nested attribute value with the help of dot syntax provided by the `Backbone-Nested`
    extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can still use object syntax, which is typical to JavaScript, to set multiple
    values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get the attribute value with the dot syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Backbone-Nested` extension provides a new model object `Backbone.NestedModel`
    based on `Backbone.Model`. It overrides existing methods, such as `get()`, `set()`,
    `has()`, `toJSON`, and so on. It also provides new `add()` and `remove()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes advanced usage of the `Backbone-Nested` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a nested array of attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, there is a way of working with a bit more complex structures, such
    as nested array of attributes. You can set it using the object syntax as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can set attributes in the nested array with a dot and bracket syntax,
    as shown in following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: And the same syntax is used for getting attributes from the nested array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Adding/removing elements to/from a nested array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Backbone-Nested` provides additional methods to work with nested arrays. The
    `add` method adds a new element to a nested array. Here is how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `remove()` method removes desired elements from a nested array. Let's see
    how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Binding callbacks to an events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When binding a callback to an event, you can use the same dot and bracket syntax
    as described previously. Let''s check out the following example of binding a callback
    to an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, `Backbone-Nested` provides additional `add:*` and `remove:*` events
    for handling array update events.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more information about event handling available in the recipe *Handling
    events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events and Bindings"),
    *Events and Bindings*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of alternatives to the `Backbone-Nested` extension, such
    as `Backbone-deep-model` and `Backbone-dotattr`. They are all very similar, but
    `Backbone-Nested` provides more features, and is better maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a one-to-one relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mostly in any application, we may need to have models that are related to each
    other. For example, a blog post model can have a relationship with a model of
    its author or have a connection to a comment model.
  prefs: []
  type: TYPE_NORMAL
- en: We may also need to access comments quickly when dealing with a blog post, or
    list all blog posts of a specific author. Moreover, we may want to export blog
    posts with author info and comments in a single JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: In a Backbone app, this can be implemented with the help of the `Backbone-relational`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the `Backbone-relational` extension from the **GitHub** page
    [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational).
    To include `Backbone-relational` into your project, save the `backbone-relational.js`
    file into the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including a Backbone extension into your project is described in the *Extending
    application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's recall our Invoice application and try to find out how we can apply a
    one-to-one relationship there. Let's say we want buyers to log in to the application
    and view all invoices assigned to them.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to store buyer credentials somewhere. It can be a new
    `UserModel` associated with an existing `BuyerModel`. We know that for each user
    there is a single buyer and vice versa, so we are dealing with a one-to-one relationship.
    Let's implement one such one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Extend models from `Backbone.RelationalModel` and pass the `relations` property
    with a relationship definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we see from the previous example, the `relations` property takes an array,
    so multiple relationships are possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `UserModel` should be defined before `BuyerModel`, because it is referenced
    afterwards in the code (in the `relations` property of `BuyerModel`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initialize a one-to-one relationship by referencing the `UserModel` instance
    in the `BuyerModel` instance or vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is also a way to do the same by passing a single input JSON when creating
    both `BuyerModel` and `UserModel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If a reversed relation is defined, pass a `BuyerModel` array when initializing
    `UserModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, access the related model with the help of the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each `Backbone.RelationalModel` registers itself with `Backbone.Store` upon
    creation (and is removed from the `Store` when destroyed). When creating or updating
    an attribute that is a key in a relation, removed related objects are notified
    of their removal, and new related objects are looked up in the `Store`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-to-many relationships and many-to-many relationships are described in the
    recipe *Implementing a one-to-many relationship* in [Chapter 3](ch03.html "Chapter 3. Collections"),
    *Collections*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete documentation to the `Backbone-relational` extension can be found on
    the **GitHub** page [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, there are a couple of alternatives to `Backbone-relational`, which are
    very similar and known as `Backbone-associations` and `ligament.js`. However,
    they do not provide one-to-many and many-to-many relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
