- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context versus Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Svelte application can be composed of one or many Svelte components. A Svelte
    component can be seen as a standalone unit, encapsulating its own reactive data
    and logic. In the previous chapter, we learned how two Svelte components – in
    particular, components in a parent and child relationship – communicate and pass
    data between each other. In this chapter, however, we are going to explore communication
    and passing data between components beyond the parent and child relationship.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Svelte provides two primitives to pass data across Svelte components – Svelte
    context and Svelte stores. Svelte context allows you to pass data from an ancestor
    to all children, while Svelte stores use the observer pattern to allow you to
    access reactive data across multiple unrelated Svelte components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the coming five chapters, we are going to explore the different use cases
    of Svelte context and Svelte stores. In this chapter, we will cover what Svelte
    context and Svelte stores are.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about when to use Svelte context and/or Svelte stores and the considerations
    for choosing them. We will then proceed with an example of a combination of both
    Svelte context and Svelte stores – a Svelte context store.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be proficient in using Svelte stores and
    Svelte context in your Svelte application. You will also understand when to use
    them effectively.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Defining Svelte context and Svelte stores
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use Svelte context and Svelte stores
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic context using Svelte stores
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Svelte context
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to pass data from a parent component to a child component, the
    first thing you should think of is using props:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What if you need to pass data from a parent component to a grandchild component?
    You could pass data as props from the parent component to the child component,
    and then from the child component to the grandchild component:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What if you need to pass data from a parent component to a great-grandchild
    component?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You could follow a process similar to what we did in the preceding code, passing
    the data through layers of components to reach the great-grandchild component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is called *prop drilling*. It is akin to drilling a hole through
    layers of components via props. This is frowned upon in most cases due to the
    following reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to trace where the data comes from.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you want to trace where the data comes from in the child component,
    you may endlessly trace up through layers of the parent component, jumping through
    different Svelte component files.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This slows you down and makes it harder to reason with the data flow.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is hard to trace where the data leads to.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that’s passed down through props into the child component is not to
    be used by the child component directly, but to be passed through it to its child
    component. You would have to step through the layer of components to find out
    where the data is finally being used.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may lose sight of where the data goes and have less confidence in making
    changes to the data that’s passed down.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is hard to restructure the component hierarchy.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you add a new component in between the layers, you need to make sure to
    still pass the props through the new component from its parent to its children.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you move the components around, you need to make sure the child component
    still gets the props it needs by checking the chain of parent components.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind, when the component tree is small and simple, even with
    its drawback, passing props around may still be the simplest way to pass data
    from a parent to its child components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the alternative to *prop drilling*? Svelte context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Svelte context is a method that provides data to all child components, no matter
    how many levels down the component tree they are.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'A component tree is like a family tree for components. You have a parent component
    at the top, and one level down its child components, and one more level down is
    the child components of the child components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Component tree diagram](img/B18887_08_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Component tree diagram'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding component tree diagram, the top-left node represents where
    `setContext` is called, and all shaded nodes under the node can access the context
    value using `getContext`. To set a context value in a component, you can use `setContext()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All its child components and child components’ child components will be able
    to read the context value through `getContext()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you paid attention to the preceding snippets, you may have noticed that we
    have been using strings as the context key when setting and reading context. However,
    you might wonder whether it is possible to use other data types as the context
    key. Let’s look into this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Using an object as a context key
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the underlying mechanism of Svelte context?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Svelte context is implemented using a JavaScript `Map`, which means you can
    set values and read values out of Svelte context using a key, the same way you
    would with a JavaScript map.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'This also means that you can set more than one key to Svelte context:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You just need to make sure you read them out using the same key you set the
    context with.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, Svelte context is implemented using a JavaScript `Map`,
    and the keys of a `Map` can be of any type, including functions, objects, or any
    primitives; you are not constrained to using just a `String` key value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And just as how JavaScript `Map` works, if you set a context using an object,
    then you would need to use the same object instance to read the value out of the
    Svelte context.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Changing the context value
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to take note of when using `setContext` and `getContext` is that these
    functions need to be called during component initialization. Read[*Chapter 1*](B18887_01.xhtml#_idTextAnchor015)
    to recap on what component initialization is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: If we can call `setContext` after component initialization, then this leads
    us to the next question – how would we change the context value?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When calling `setContext` in line 3, we are passing the value of the `itemId`
    variable to the `setContext` function. Reassigning the `itemId` variable in line
    5 would not make the context value change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This is how JavaScript works. If you call a function with a primitive-type variable,
    then the value of the variable is being passed in, and reassigning the variable
    outside of the function would not change the value of the variable that’s read
    from inside the function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'How about passing an object as a context value? Let’s see how that works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In JavaScript, objects are passed by reference. This means that the Svelte
    context and the `item` variable outside of the `setContext` function are referring
    to the same object. Mutating the object modifies the same referenced object and
    thus the changes can be seen when reading the Svelte context:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, you may have noticed that after you render `{item.id}` onto the DOM,
    the value shown in the DOM does not change when you mutate it in the parent component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not mean `item.id` has not changed. If you try to print out `item.id`
    on an interval, you will notice that `item.id` has changed, but the value in the
    DOM remains the same:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why would this happen?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Svelte tracks variable mutations and reassignments within a Svelte component
    and instruments operations to update the DOM to reflect the changes. However,
    what this means is that changes that happen outside of the component are not tracked,
    and therefore the DOM does not reflect such changes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: So, what should we do to make Svelte aware of changes to a variable outside
    of the component?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: This is where the Svelte store comes in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Svelte store
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand why Svelte reactivity is limited within a Svelte component, we
    must first understand how Svelte’s reactivity works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other frameworks, Svelte reactivity works during build time. As
    Svelte compiles a Svelte component into JavaScript, Svelte looks at each variable
    and tracks the variable to see when the variable changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Instead of tracking all the variables throughout the application, Svelte limits
    itself to only analyzing and compiling one file at a time. This allows Svelte
    to compile multiple Svelte component files in parallel but also means that a Svelte
    component would not be aware of variable changes that happen in other files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: A common situation where a variable change is not tracked is when the variable
    is defined in a separate file and imported into the current component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `quantity` variable is imported from a separate
    file. Svelte will not track any changes to the `quantity` variable that may have
    occurred in that file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you attempt to modify the variable outside of the Svelte component, then
    Svelte is not able to track that. So, Svelte has no idea when you modify the variable
    and therefore will not be able to update the DOM when that happens.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: To make Svelte aware of the changes outside of the component and update the
    DOM accordingly, we will need to design a mechanism at runtime that will notify
    Svelte whenever a variable changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: For this, we can draw inspiration from the **observer pattern**. The observer
    pattern is a design pattern that lets you define a subscription mechanism to notify
    multiple objects when an event happens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Using the observer pattern
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, instead of just importing the `quantity` variable, I am also importing
    a `subscribe` function, which we will define later:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The idea of the `subscribe` function is such that we can subscribe to know when
    `quantity` changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we assume that `subscribe` takes in a callback function, which will be
    called whenever `quantity` changes. The callback function takes in a parameter
    that gives us the latest value of `quantity`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, now, although Svelte still cannot track changes to the `quantity` variable
    outside of the component, we can use the `subscribe` function to tell Svelte when
    that happens.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how to tell Svelte this, we can define another variable called
    `_quantity` that initializes to be the same value as `quantity`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever `quantity` changes, the callback function that’s passed into the `subscribe`
    function should be called with the new `quantity` value. We will use this as an
    opportunity to update `_quantity` to the new `quantity` value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the `_quantity` variable is defined within the component, and we update
    the value of the variable within the component (in the `_quantity = newQuantity`
    statement), Svelte can track the update of `_quantity`. And since the `_quantity`
    variable tracks the changes of the `quantity` variable itself, you can see that
    the DOM updates whenever `quantity` changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: However, all of this depends on the `subscribe` function, which would call the
    callback function whenever the value of `quantity` changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see how we can define the `subscribe` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Defining the subscribe function
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways of defining the `subscribe` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are going to use an array and name it `subscribers` so that we can
    keep track of all the functions being called with `subscribe`. Then, when we attempt
    to update the value of `quantity`, we will iterate through the `subscribers` array
    to get each of the subscriber functions and call them one by one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As an example, here, we want to update `quantity` to `20`. To make sure that
    the subscribers are notified of the changes, we call `notifySubscribers` with
    the updated value at the same time so that each `subscribers` is notified with
    the latest value for `quantity`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take your time when connecting the implementation of the `subscribe` and `notifySubscribers`
    functions in the preceding code back to the Svelte component code in the previous
    section. You will see that whenever we call `notifySubscribers`, the callback
    function that’s passed into the `subscribe` function will be called. `_quantity`
    will be updated, and the value in the DOM will be updated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: So, it doesn’t matter if you are modifying `quantity` outside the Svelte component,
    so long as you call the `notifySubscribers` function. With the new value of `quantity`,
    Svelte will update the DOM elements to reflect the latest value of `quantity`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: With the observer pattern, we are now able to define and update variables across
    Svelte components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: You will see this pattern a lot in Svelte. Svelte encapsulates the idea of `subscribe`
    and `notifySubscribers` into a concept called a Svelte store. So, let’s explore
    what it means to be a Svelte store and explore what first-class support Svelte
    is providing for Svelte stores.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Svelte store
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Svelte store is any object that follows the Svelte store contract.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This means that any object that follows the Svelte store contract can be referred
    to as a Svelte store. As a Svelte store, there are a few syntactic sugars and
    built-in functions that come with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Before we get ahead of ourselves, let’s take a look at what a Svelte store contract
    is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The Svelte store contract requires an object to have a `subscribe` method and
    an optional `set` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I have not told you about the specific requirements for the `subscribe` and
    `set` methods, but I hope you can see the similarity in the `subscribe` and `set`
    methods in the Svelte store contract to the `subscribe` and `notifySubscribers`
    functions illustrated in the previous section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: But something is missing here. Where do we place the store value, or the corresponding
    `quantity` variable from the previous section?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Well, the store value is not part of the Svelte store contract, and we will
    soon explain why.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with our requirements for the `subscribe` and `set` methods:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The `subscribe` method has to return a function to unsubscribe from the store.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the subscriber to stop receiving updates of the latest store value.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, if we use an array to keep track of the subscriber functions being
    called with the `subscribe` function, then we can use the returned function from
    `subscribe` to remove the subscriber function from the array since the `subscriber`
    function is no longer needed to receive any new updates from the store:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the `subscribe` method is being called with a function, the function must
    be called immediately and synchronously with the store value.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the function is not called immediately, the store value is assumed to be
    `undefined`:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This requirement means that to read the store value out from the Svelte store,
    you will need to use the `subscribe` method:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `set` method of a Svelte store takes in a new store value and returns nothing:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `set` method is supposed to update the value of the store. Naturally, we
    would implement the `set` method such that it will notify all the store subscribers
    of the latest store value:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, we’ve gone through the requirements of a Svelte store contract. Along
    the way, we’ve also seen snippets of code on implementing each requirement of
    a Svelte store. By putting them together, we will have a Svelte store.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Svelte store is such a common use case that Svelte has provided a
    few built-in functions to help us with creating one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Creating Svelte stores with built-in functions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Svelte provides a sub-package that exports a few built-in functions for Svelte
    stores. You can import them from the `'``svelte/store'` package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of built-in Svelte store functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`readable()` helps create a readable Svelte store. Since the `set` method in
    a Svelte contract is optional, a readable store is a store that does not implement
    the `set` method.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To update the store value, the `readable()` function takes in a callback function
    that will be called when the store is being subscribed, and the callback function
    is called with a `set` function that can be used to update the store value:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `set` function in the callback function can be called numerous times. In
    the following example, we are calling the `set` function every second to update
    the store value to the latest timestamp:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`writable()` helps create a writable Svelte store. This is similar to the readable
    store, except it implements the `set` method:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`derived()` creates a new Svelte store, deriving from existing stores.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore `derived()` in more detail in the next chapter when we talk
    about creating custom stores.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With `readable()`, `writable()`, and `derived()`, you can easily create a new
    Svelte store without having to implement the Svelte store contract yourself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: So, we have built-in methods to create a Svelte store, but do we have any built-in
    methods for using Svelte stores? Let’s find out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Auto-subscribing to a Svelte store
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since all Svelte stores follow the Svelte store contract, all Svelte stores
    have the `subscribe` method and, optionally, the `set` method. We can use the
    `store.subscribe()` method to subscribe to the latest store value, and `store.set()`
    to update the store value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When using a Svelte store in a Svelte component, we only subscribe to the Svelte
    store when needed (usually as we mount the Svelte component). In the preceding
    snippet, we subscribe to the store exactly after the Svelte component is mounted
    by calling the `store.subscribe` method inside an `onMount` callback.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: It is important to unsubscribe from new store value changes when it is no longer
    necessary. This is usually when we unmount and destroy the Svelte component. In
    the preceding snippet, we return a function in an `onMount` callback, which will
    be called when the component is unmounted. In the function, we call the `unsubscribe`
    function return from the `store.subscribe` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This is in accordance with the Svelte store contract, where the `store.subscribe`
    method has to return a function to unsubscribe from the store.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In a Svelte component, we need to remember to call `store.subscribe` during
    `onMount`, and remember to clean up by calling `unsubscribe` during `onDestroy`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: This can become verbose, so Svelte provides a way to auto-subscribe to a Svelte
    store in a Svelte component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When you have a variable that references a store in a Svelte component, you
    can auto-subscribe to the store and access the value of the store through the
    `$` prefixed variable name of the store variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you have a Svelte store variable named `count`, as shown
    here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, you can auto-subscribe to the `count` Svelte store and access
    the store value through `$count`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is equivalent to subscribing to the store and assigning the latest store
    value to the `$count` variable, However, when doing it this way, you no longer
    need to explicitly call the `count.subscribe` method to subscribe to the store
    and call the `unsubscribe` function to unsubscribe from it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If you paid attention to the code, you may have noticed that we did not declare
    the `$count` variable at all. However, it is magically available, automatically
    declared by Svelte as Svelte builds the Svelte component code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This also assumes that whenever you are using the variable that starts with
    `$`, the variable without the `$` prefix is assumed to be a Svelte store.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Also, because of how Svelte auto declares the `$` prefixed variable, it disallows
    any declaration of any variable with a variable name starting with the `$` sign.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if I assign a new value to the `$` prefixed variable? Doing so
    is equivalent to calling the `set` method of the store:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, now that we’ve learned about the Svelte context and Svelte store, let’s
    discuss when we should use a Svelte context and/or a Svelte store.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between a Svelte context and a Svelte store
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Svelte context and Svelte store are designed for very different use cases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a recap: the Svelte context helps pass data from a parent component
    to all descendent components, while a Svelte store helps make data reactive across
    multiple Svelte components.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Although both the Svelte context and Svelte store are meant to pass data across
    Svelte components, they are designed for different use cases. So, choosing when
    to use a Svelte context and Svelte store is never an either-or situation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: You can use either a Svelte context, a Svelte store, or both to pass the same
    data across Svelte components.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide which one to use, I’ve come up with a 2x2 decision matrix:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context,
    or both](img/B18887_08_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context,
    or both'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In this 2x2 decision matrix, there are two dimensions: local-global and static-reactive.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the kind of data you are passing, the data should fall into one
    of the four quadrants. Then, we can decide on the best way of passing the data
    across components.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s take a closer look at what each dimension means.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In the local-global dimension, we determine whether the data should have the
    same value globally across the entire application or have separate local versions
    among components that are close to each other.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: For example, language preference data falls into being global instead of local.
    There tends to be only one piece of language preference data throughout the entire
    application so that the language preference is consistent in the application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, chart settings in a dashboard of charts could be local data.
    Multiple Svelte components, such as chart axis, chart data, and chart grid, within
    the same chart share the same data, yet different charts could have different
    chart settings. There’s no one single piece of data throughout the entire application.
    So, in this case, it is more toward local in the local-global dimension.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is going to be global throughout the entire application, the data
    can be declared in a JavaScript module and imported from anywhere within the application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the other hand, if the data is going to be local, the data can be declared
    as a Svelte context. This allows the child component to get different values,
    depending on where the component lives in the component tree hierarchy:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the static-reactive dimension, we determine whether the data should be static,
    meaning it wouldn’t change through the life cycle of the application, or should
    be dynamic, where the value of the data will change as the user interacts with
    the application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: An example of static data would be the theme of an application. The value of
    the data could be determined based on dynamic conditions, but once the value is
    determined at the start of the application, the value does not change throughout
    the application life cycle. The application theme is a good example of such a
    scenario. Usually, the theme of an application is determined at the start as the
    application loads, and the theme stays throughout the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, an example of dynamic data would be chart data. Chart data
    is dynamic and can be changed throughout the application’s life cycle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is going to be static throughout the application’s life cycle,
    then the data can be declared using a normal JavaScript variable:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, if the data is going to be dynamic, and needs to be reactive across
    multiple components, the data should be declared as a Svelte store:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we combine the two dimensions, we get the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Static global**: The data is declared as a normal JavaScript variable in
    a JavaScript module and exported for Svelte components to import'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic global**: The data is declared as a Svelte store in a JavaScript
    module and exported for Svelte components to import'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static local**: The data is declared as a Svelte context with a normal JavaScript
    variable as the Svelte context value'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic local**: The data is declared as a Svelte context with the Svelte
    store as the Svelte context value'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we’ve seen how we can use a Svelte context and a Svelte store individually,
    but when we pass dynamic local data across Svelte components, we use both a Svelte
    context and Svelte store together.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you combine both a Svelte context and a Svelte store? Let’s find
    out.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Passing dynamic context using a Svelte store
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make Svelte context data dynamic and reactive across components, we need
    to pass a Svelte store as the Svelte context data instead of a normal JavaScript
    variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to importing a Svelte store from a JavaScript module, except
    we are not importing the Svelte store; instead, we are sending the Svelte store
    through the Svelte context.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we are creating a Svelte store, and passing the Svelte store into
    the context:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we are passing the store into the Svelte context directly, instead
    of passing the store value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In the child component, we can read the value out from the context through
    `getContext()`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since `data` is a Svelte store, we can reference the Svelte store value using
    the `$` prefixed variable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To test whether the reactivity works, we can set a new value to the `data`
    store in the parent component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This goes both ways. If you attempt to update the store value from the child
    component, the store value in the parent component will be updated too. Since
    you are getting the same store value through the context in all the children components,
    any component using the same store will be updated as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what Svelte context and Svelte store are.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Although both Svelte context and Svelte store are meant for sharing data across
    multiple Svelte components, they are designed and used for different reasons.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Svelte context is meant for sharing the same data across all descendant components
    in the component tree, while Svelte store is meant for sharing reactivity across
    Svelte components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored the decision matrix on when to use a Svelte context, when
    to use a Svelte store, and when to use both.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: This chapter served as an introduction to the Svelte context and the Svelte
    store. By now, you should have a good understanding of what they are and how they
    work, and feel confident in knowing when to use them. As we move forward, we will
    explore practical use cases that involve Svelte context and Svelte store, allowing
    you to apply these powerful concepts effectively in real-world scenarios.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into the topic of the Svelte store
    and look at how to create a custom one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨 Svelte store 主题，并查看如何创建一个自定义的 store。
