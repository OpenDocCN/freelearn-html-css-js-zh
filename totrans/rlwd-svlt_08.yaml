- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context versus Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Svelte application can be composed of one or many Svelte components. A Svelte
    component can be seen as a standalone unit, encapsulating its own reactive data
    and logic. In the previous chapter, we learned how two Svelte components – in
    particular, components in a parent and child relationship – communicate and pass
    data between each other. In this chapter, however, we are going to explore communication
    and passing data between components beyond the parent and child relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte provides two primitives to pass data across Svelte components – Svelte
    context and Svelte stores. Svelte context allows you to pass data from an ancestor
    to all children, while Svelte stores use the observer pattern to allow you to
    access reactive data across multiple unrelated Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming five chapters, we are going to explore the different use cases
    of Svelte context and Svelte stores. In this chapter, we will cover what Svelte
    context and Svelte stores are.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about when to use Svelte context and/or Svelte stores and the considerations
    for choosing them. We will then proceed with an example of a combination of both
    Svelte context and Svelte stores – a Svelte context store.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be proficient in using Svelte stores and
    Svelte context in your Svelte application. You will also understand when to use
    them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Svelte context and Svelte stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use Svelte context and Svelte stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic context using Svelte stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Svelte context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to pass data from a parent component to a child component, the
    first thing you should think of is using props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you need to pass data from a parent component to a grandchild component?
    You could pass data as props from the parent component to the child component,
    and then from the child component to the grandchild component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What if you need to pass data from a parent component to a great-grandchild
    component?
  prefs: []
  type: TYPE_NORMAL
- en: You could follow a process similar to what we did in the preceding code, passing
    the data through layers of components to reach the great-grandchild component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is called *prop drilling*. It is akin to drilling a hole through
    layers of components via props. This is frowned upon in most cases due to the
    following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to trace where the data comes from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you want to trace where the data comes from in the child component,
    you may endlessly trace up through layers of the parent component, jumping through
    different Svelte component files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This slows you down and makes it harder to reason with the data flow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is hard to trace where the data leads to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that’s passed down through props into the child component is not to
    be used by the child component directly, but to be passed through it to its child
    component. You would have to step through the layer of components to find out
    where the data is finally being used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may lose sight of where the data goes and have less confidence in making
    changes to the data that’s passed down.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is hard to restructure the component hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you add a new component in between the layers, you need to make sure to
    still pass the props through the new component from its parent to its children.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you move the components around, you need to make sure the child component
    still gets the props it needs by checking the chain of parent components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind, when the component tree is small and simple, even with
    its drawback, passing props around may still be the simplest way to pass data
    from a parent to its child components.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the alternative to *prop drilling*? Svelte context.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte context is a method that provides data to all child components, no matter
    how many levels down the component tree they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'A component tree is like a family tree for components. You have a parent component
    at the top, and one level down its child components, and one more level down is
    the child components of the child components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Component tree diagram](img/B18887_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Component tree diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding component tree diagram, the top-left node represents where
    `setContext` is called, and all shaded nodes under the node can access the context
    value using `getContext`. To set a context value in a component, you can use `setContext()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All its child components and child components’ child components will be able
    to read the context value through `getContext()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you paid attention to the preceding snippets, you may have noticed that we
    have been using strings as the context key when setting and reading context. However,
    you might wonder whether it is possible to use other data types as the context
    key. Let’s look into this.
  prefs: []
  type: TYPE_NORMAL
- en: Using an object as a context key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the underlying mechanism of Svelte context?
  prefs: []
  type: TYPE_NORMAL
- en: Svelte context is implemented using a JavaScript `Map`, which means you can
    set values and read values out of Svelte context using a key, the same way you
    would with a JavaScript map.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also means that you can set more than one key to Svelte context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You just need to make sure you read them out using the same key you set the
    context with.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, Svelte context is implemented using a JavaScript `Map`,
    and the keys of a `Map` can be of any type, including functions, objects, or any
    primitives; you are not constrained to using just a `String` key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And just as how JavaScript `Map` works, if you set a context using an object,
    then you would need to use the same object instance to read the value out of the
    Svelte context.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the context value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to take note of when using `setContext` and `getContext` is that these
    functions need to be called during component initialization. Read[*Chapter 1*](B18887_01.xhtml#_idTextAnchor015)
    to recap on what component initialization is.
  prefs: []
  type: TYPE_NORMAL
- en: If we can call `setContext` after component initialization, then this leads
    us to the next question – how would we change the context value?
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When calling `setContext` in line 3, we are passing the value of the `itemId`
    variable to the `setContext` function. Reassigning the `itemId` variable in line
    5 would not make the context value change.
  prefs: []
  type: TYPE_NORMAL
- en: This is how JavaScript works. If you call a function with a primitive-type variable,
    then the value of the variable is being passed in, and reassigning the variable
    outside of the function would not change the value of the variable that’s read
    from inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about passing an object as a context value? Let’s see how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, objects are passed by reference. This means that the Svelte
    context and the `item` variable outside of the `setContext` function are referring
    to the same object. Mutating the object modifies the same referenced object and
    thus the changes can be seen when reading the Svelte context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, you may have noticed that after you render `{item.id}` onto the DOM,
    the value shown in the DOM does not change when you mutate it in the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not mean `item.id` has not changed. If you try to print out `item.id`
    on an interval, you will notice that `item.id` has changed, but the value in the
    DOM remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Why would this happen?
  prefs: []
  type: TYPE_NORMAL
- en: Svelte tracks variable mutations and reassignments within a Svelte component
    and instruments operations to update the DOM to reflect the changes. However,
    what this means is that changes that happen outside of the component are not tracked,
    and therefore the DOM does not reflect such changes.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should we do to make Svelte aware of changes to a variable outside
    of the component?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the Svelte store comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Svelte store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand why Svelte reactivity is limited within a Svelte component, we
    must first understand how Svelte’s reactivity works.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other frameworks, Svelte reactivity works during build time. As
    Svelte compiles a Svelte component into JavaScript, Svelte looks at each variable
    and tracks the variable to see when the variable changes.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of tracking all the variables throughout the application, Svelte limits
    itself to only analyzing and compiling one file at a time. This allows Svelte
    to compile multiple Svelte component files in parallel but also means that a Svelte
    component would not be aware of variable changes that happen in other files.
  prefs: []
  type: TYPE_NORMAL
- en: A common situation where a variable change is not tracked is when the variable
    is defined in a separate file and imported into the current component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `quantity` variable is imported from a separate
    file. Svelte will not track any changes to the `quantity` variable that may have
    occurred in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you attempt to modify the variable outside of the Svelte component, then
    Svelte is not able to track that. So, Svelte has no idea when you modify the variable
    and therefore will not be able to update the DOM when that happens.
  prefs: []
  type: TYPE_NORMAL
- en: To make Svelte aware of the changes outside of the component and update the
    DOM accordingly, we will need to design a mechanism at runtime that will notify
    Svelte whenever a variable changes.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we can draw inspiration from the **observer pattern**. The observer
    pattern is a design pattern that lets you define a subscription mechanism to notify
    multiple objects when an event happens.
  prefs: []
  type: TYPE_NORMAL
- en: Using the observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, instead of just importing the `quantity` variable, I am also importing
    a `subscribe` function, which we will define later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The idea of the `subscribe` function is such that we can subscribe to know when
    `quantity` changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we assume that `subscribe` takes in a callback function, which will be
    called whenever `quantity` changes. The callback function takes in a parameter
    that gives us the latest value of `quantity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, now, although Svelte still cannot track changes to the `quantity` variable
    outside of the component, we can use the `subscribe` function to tell Svelte when
    that happens.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how to tell Svelte this, we can define another variable called
    `_quantity` that initializes to be the same value as `quantity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever `quantity` changes, the callback function that’s passed into the `subscribe`
    function should be called with the new `quantity` value. We will use this as an
    opportunity to update `_quantity` to the new `quantity` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since the `_quantity` variable is defined within the component, and we update
    the value of the variable within the component (in the `_quantity = newQuantity`
    statement), Svelte can track the update of `_quantity`. And since the `_quantity`
    variable tracks the changes of the `quantity` variable itself, you can see that
    the DOM updates whenever `quantity` changes.
  prefs: []
  type: TYPE_NORMAL
- en: However, all of this depends on the `subscribe` function, which would call the
    callback function whenever the value of `quantity` changes.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see how we can define the `subscribe` function.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the subscribe function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways of defining the `subscribe` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are going to use an array and name it `subscribers` so that we can
    keep track of all the functions being called with `subscribe`. Then, when we attempt
    to update the value of `quantity`, we will iterate through the `subscribers` array
    to get each of the subscriber functions and call them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, here, we want to update `quantity` to `20`. To make sure that
    the subscribers are notified of the changes, we call `notifySubscribers` with
    the updated value at the same time so that each `subscribers` is notified with
    the latest value for `quantity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Take your time when connecting the implementation of the `subscribe` and `notifySubscribers`
    functions in the preceding code back to the Svelte component code in the previous
    section. You will see that whenever we call `notifySubscribers`, the callback
    function that’s passed into the `subscribe` function will be called. `_quantity`
    will be updated, and the value in the DOM will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: So, it doesn’t matter if you are modifying `quantity` outside the Svelte component,
    so long as you call the `notifySubscribers` function. With the new value of `quantity`,
    Svelte will update the DOM elements to reflect the latest value of `quantity`.
  prefs: []
  type: TYPE_NORMAL
- en: With the observer pattern, we are now able to define and update variables across
    Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: You will see this pattern a lot in Svelte. Svelte encapsulates the idea of `subscribe`
    and `notifySubscribers` into a concept called a Svelte store. So, let’s explore
    what it means to be a Svelte store and explore what first-class support Svelte
    is providing for Svelte stores.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Svelte store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Svelte store is any object that follows the Svelte store contract.
  prefs: []
  type: TYPE_NORMAL
- en: This means that any object that follows the Svelte store contract can be referred
    to as a Svelte store. As a Svelte store, there are a few syntactic sugars and
    built-in functions that come with it.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get ahead of ourselves, let’s take a look at what a Svelte store contract
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Svelte store contract requires an object to have a `subscribe` method and
    an optional `set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I have not told you about the specific requirements for the `subscribe` and
    `set` methods, but I hope you can see the similarity in the `subscribe` and `set`
    methods in the Svelte store contract to the `subscribe` and `notifySubscribers`
    functions illustrated in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: But something is missing here. Where do we place the store value, or the corresponding
    `quantity` variable from the previous section?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the store value is not part of the Svelte store contract, and we will
    soon explain why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with our requirements for the `subscribe` and `set` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `subscribe` method has to return a function to unsubscribe from the store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the subscriber to stop receiving updates of the latest store value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, if we use an array to keep track of the subscriber functions being
    called with the `subscribe` function, then we can use the returned function from
    `subscribe` to remove the subscriber function from the array since the `subscriber`
    function is no longer needed to receive any new updates from the store:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the `subscribe` method is being called with a function, the function must
    be called immediately and synchronously with the store value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the function is not called immediately, the store value is assumed to be
    `undefined`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This requirement means that to read the store value out from the Svelte store,
    you will need to use the `subscribe` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `set` method of a Svelte store takes in a new store value and returns nothing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `set` method is supposed to update the value of the store. Naturally, we
    would implement the `set` method such that it will notify all the store subscribers
    of the latest store value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve gone through the requirements of a Svelte store contract. Along
    the way, we’ve also seen snippets of code on implementing each requirement of
    a Svelte store. By putting them together, we will have a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Svelte store is such a common use case that Svelte has provided a
    few built-in functions to help us with creating one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Svelte stores with built-in functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Svelte provides a sub-package that exports a few built-in functions for Svelte
    stores. You can import them from the `'``svelte/store'` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of built-in Svelte store functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`readable()` helps create a readable Svelte store. Since the `set` method in
    a Svelte contract is optional, a readable store is a store that does not implement
    the `set` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To update the store value, the `readable()` function takes in a callback function
    that will be called when the store is being subscribed, and the callback function
    is called with a `set` function that can be used to update the store value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `set` function in the callback function can be called numerous times. In
    the following example, we are calling the `set` function every second to update
    the store value to the latest timestamp:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`writable()` helps create a writable Svelte store. This is similar to the readable
    store, except it implements the `set` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`derived()` creates a new Svelte store, deriving from existing stores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore `derived()` in more detail in the next chapter when we talk
    about creating custom stores.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With `readable()`, `writable()`, and `derived()`, you can easily create a new
    Svelte store without having to implement the Svelte store contract yourself.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have built-in methods to create a Svelte store, but do we have any built-in
    methods for using Svelte stores? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-subscribing to a Svelte store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since all Svelte stores follow the Svelte store contract, all Svelte stores
    have the `subscribe` method and, optionally, the `set` method. We can use the
    `store.subscribe()` method to subscribe to the latest store value, and `store.set()`
    to update the store value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When using a Svelte store in a Svelte component, we only subscribe to the Svelte
    store when needed (usually as we mount the Svelte component). In the preceding
    snippet, we subscribe to the store exactly after the Svelte component is mounted
    by calling the `store.subscribe` method inside an `onMount` callback.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to unsubscribe from new store value changes when it is no longer
    necessary. This is usually when we unmount and destroy the Svelte component. In
    the preceding snippet, we return a function in an `onMount` callback, which will
    be called when the component is unmounted. In the function, we call the `unsubscribe`
    function return from the `store.subscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: This is in accordance with the Svelte store contract, where the `store.subscribe`
    method has to return a function to unsubscribe from the store.
  prefs: []
  type: TYPE_NORMAL
- en: In a Svelte component, we need to remember to call `store.subscribe` during
    `onMount`, and remember to clean up by calling `unsubscribe` during `onDestroy`.
  prefs: []
  type: TYPE_NORMAL
- en: This can become verbose, so Svelte provides a way to auto-subscribe to a Svelte
    store in a Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a variable that references a store in a Svelte component, you
    can auto-subscribe to the store and access the value of the store through the
    `$` prefixed variable name of the store variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you have a Svelte store variable named `count`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you can auto-subscribe to the `count` Svelte store and access
    the store value through `$count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to subscribing to the store and assigning the latest store
    value to the `$count` variable, However, when doing it this way, you no longer
    need to explicitly call the `count.subscribe` method to subscribe to the store
    and call the `unsubscribe` function to unsubscribe from it.
  prefs: []
  type: TYPE_NORMAL
- en: If you paid attention to the code, you may have noticed that we did not declare
    the `$count` variable at all. However, it is magically available, automatically
    declared by Svelte as Svelte builds the Svelte component code.
  prefs: []
  type: TYPE_NORMAL
- en: This also assumes that whenever you are using the variable that starts with
    `$`, the variable without the `$` prefix is assumed to be a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Also, because of how Svelte auto declares the `$` prefixed variable, it disallows
    any declaration of any variable with a variable name starting with the `$` sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if I assign a new value to the `$` prefixed variable? Doing so
    is equivalent to calling the `set` method of the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we’ve learned about the Svelte context and Svelte store, let’s
    discuss when we should use a Svelte context and/or a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between a Svelte context and a Svelte store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Svelte context and Svelte store are designed for very different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a recap: the Svelte context helps pass data from a parent component
    to all descendent components, while a Svelte store helps make data reactive across
    multiple Svelte components.'
  prefs: []
  type: TYPE_NORMAL
- en: Although both the Svelte context and Svelte store are meant to pass data across
    Svelte components, they are designed for different use cases. So, choosing when
    to use a Svelte context and Svelte store is never an either-or situation.
  prefs: []
  type: TYPE_NORMAL
- en: You can use either a Svelte context, a Svelte store, or both to pass the same
    data across Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide which one to use, I’ve come up with a 2x2 decision matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context,
    or both](img/B18887_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context,
    or both'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this 2x2 decision matrix, there are two dimensions: local-global and static-reactive.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the kind of data you are passing, the data should fall into one
    of the four quadrants. Then, we can decide on the best way of passing the data
    across components.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s take a closer look at what each dimension means.
  prefs: []
  type: TYPE_NORMAL
- en: In the local-global dimension, we determine whether the data should have the
    same value globally across the entire application or have separate local versions
    among components that are close to each other.
  prefs: []
  type: TYPE_NORMAL
- en: For example, language preference data falls into being global instead of local.
    There tends to be only one piece of language preference data throughout the entire
    application so that the language preference is consistent in the application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, chart settings in a dashboard of charts could be local data.
    Multiple Svelte components, such as chart axis, chart data, and chart grid, within
    the same chart share the same data, yet different charts could have different
    chart settings. There’s no one single piece of data throughout the entire application.
    So, in this case, it is more toward local in the local-global dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is going to be global throughout the entire application, the data
    can be declared in a JavaScript module and imported from anywhere within the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if the data is going to be local, the data can be declared
    as a Svelte context. This allows the child component to get different values,
    depending on where the component lives in the component tree hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the static-reactive dimension, we determine whether the data should be static,
    meaning it wouldn’t change through the life cycle of the application, or should
    be dynamic, where the value of the data will change as the user interacts with
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: An example of static data would be the theme of an application. The value of
    the data could be determined based on dynamic conditions, but once the value is
    determined at the start of the application, the value does not change throughout
    the application life cycle. The application theme is a good example of such a
    scenario. Usually, the theme of an application is determined at the start as the
    application loads, and the theme stays throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, an example of dynamic data would be chart data. Chart data
    is dynamic and can be changed throughout the application’s life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is going to be static throughout the application’s life cycle,
    then the data can be declared using a normal JavaScript variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the data is going to be dynamic, and needs to be reactive across
    multiple components, the data should be declared as a Svelte store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we combine the two dimensions, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static global**: The data is declared as a normal JavaScript variable in
    a JavaScript module and exported for Svelte components to import'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic global**: The data is declared as a Svelte store in a JavaScript
    module and exported for Svelte components to import'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static local**: The data is declared as a Svelte context with a normal JavaScript
    variable as the Svelte context value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic local**: The data is declared as a Svelte context with the Svelte
    store as the Svelte context value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we’ve seen how we can use a Svelte context and a Svelte store individually,
    but when we pass dynamic local data across Svelte components, we use both a Svelte
    context and Svelte store together.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you combine both a Svelte context and a Svelte store? Let’s find
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Passing dynamic context using a Svelte store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make Svelte context data dynamic and reactive across components, we need
    to pass a Svelte store as the Svelte context data instead of a normal JavaScript
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to importing a Svelte store from a JavaScript module, except
    we are not importing the Svelte store; instead, we are sending the Svelte store
    through the Svelte context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we are creating a Svelte store, and passing the Svelte store into
    the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are passing the store into the Svelte context directly, instead
    of passing the store value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the child component, we can read the value out from the context through
    `getContext()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `data` is a Svelte store, we can reference the Svelte store value using
    the `$` prefixed variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether the reactivity works, we can set a new value to the `data`
    store in the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This goes both ways. If you attempt to update the store value from the child
    component, the store value in the parent component will be updated too. Since
    you are getting the same store value through the context in all the children components,
    any component using the same store will be updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what Svelte context and Svelte store are.
  prefs: []
  type: TYPE_NORMAL
- en: Although both Svelte context and Svelte store are meant for sharing data across
    multiple Svelte components, they are designed and used for different reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte context is meant for sharing the same data across all descendant components
    in the component tree, while Svelte store is meant for sharing reactivity across
    Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored the decision matrix on when to use a Svelte context, when
    to use a Svelte store, and when to use both.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter served as an introduction to the Svelte context and the Svelte
    store. By now, you should have a good understanding of what they are and how they
    work, and feel confident in knowing when to use them. As we move forward, we will
    explore practical use cases that involve Svelte context and Svelte store, allowing
    you to apply these powerful concepts effectively in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into the topic of the Svelte store
    and look at how to create a custom one.
  prefs: []
  type: TYPE_NORMAL
