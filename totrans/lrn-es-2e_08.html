<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p class="mce-root">JavaScript has classes that provide a much simpler and clearer syntax for creating constructors and dealing with inheritance. Until now, JavaScript never had the concept of classes, although it's an object-oriented programming language. Programmers from other programming language backgrounds often found it difficult to understand JavaScript's object-oriented model and inheritance due to the lack of classes.</p>
<p class="mce-root">In this chapter, we will learn about object-oriented JavaScript using classes:</p>
<ul>
<li class="mce-root">JavaScript data types</li>
<li class="mce-root">Creating objects the classical way</li>
<li class="mce-root">The constructors of the primitive types</li>
<li class="mce-root">What are classes?</li>
<li class="mce-root">Creating objects using classes</li>
<li class="mce-root">Inheritance in classes</li>
<li class="mce-root">The features of classes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding object-oriented JavaScript</h1>
                </header>
            
            <article>
                
<p>Before we proceed with ES6 classes, let's refresh our knowledge of JavaScript data types, constructors, and inheritance. While learning classes, we will be comparing the syntax of  constructors and prototype-based inheritance with the syntax of classes. Therefore, it is important to have a good grasp of these topics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JavaScript data types</h1>
                </header>
            
            <article>
                
<p>JavaScript variables hold (or store) data (or values). The type of data variables that they hold is called the data type. In JavaScript, there are seven different data types: number, string, Boolean, null, undefined, symbol, and object.</p>
<p>When it comes to holding objects, variables hold the object reference (that is, the memory address) instead of the object itself. If you're coming from a C/C++ background, you can relate them to pointers, but not exactly.</p>
<p>All data types other than objects are called primitive data types.</p>
<div class="packt_tip packt_infobox">The arrays and functions are actually the JavaScript objects. A lot of things are objects under the hood.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating objects</h1>
                </header>
            
            <article>
                
<p>There are two ways of creating an object in JavaScript: using the <kbd>object</kbd> literal, or using a <kbd>constructor</kbd>. The <kbd>object</kbd> literal is used when we want to create fixed objects, whereas a <kbd>constructor</kbd> is used when we want to create objects dynamically at runtime.</p>
<p>Let's consider a case where we may need to use the <kbd>constructor</kbd> instead of the <kbd>object</kbd> literal. Here is a code example:</p>
<pre>const student = {  <br/>    name: "Eden",  <br/>    printName() {  <br/>        console.log(this.name);  <br/>    } <br/>} <br/>student.printName(); //Output "Eden"</pre>
<p>Here, we created a <kbd>student</kbd> object using the <kbd>object</kbd> literal, that is, the <kbd>{}</kbd> notation. This works well when you just want to create a single <kbd>student</kbd> object.</p>
<p>But the problem arises when you want to create multiple <kbd>student</kbd> objects. Obviously, you don't want to write the previous code multiple times to create multiple <kbd>student</kbd> objects. This is where <kbd>constructor</kbd> comes into use.</p>
<p>A <kbd>function</kbd> acts like a <kbd>constructor</kbd> when invoked using the <kbd>new</kbd> keyword. A <kbd>constructor</kbd> creates and returns an object. The <kbd>this</kbd> keyword inside a <kbd>function</kbd>, when invoked as a <kbd>constructor</kbd>, points to the new object instance, and once the <kbd>constructor</kbd> execution is finished, the new object is automatically returned. Consider this example:</p>
<pre>function Student(name) {  <br/>    this.name = name; <br/>} <br/><br/>Student.prototype.printName = function(){  <br/>    console.log(this.name); <br/>}<br/><br/>const student1 = new Student("Eden"); <br/>const student2 = new Student("John"); <br/>student1.printName(); //Output "Eden" <br/>student2.printName(); //Output "John"</pre>
<p>Here, to create multiple <kbd>student</kbd> objects, we invoked the <kbd>constructor</kbd> multiple times instead of creating multiple <kbd>student</kbd> objects using the <kbd>object</kbd> literals.</p>
<p>To add methods to the instances of the <kbd>constructor</kbd>, we didn't use the <kbd>this</kbd> keyword; instead, we used the <kbd>prototype</kbd> property of <kbd>constructor</kbd>. We will learn more about why we did it this way, and what the <kbd>prototype</kbd> property is, in the next section.</p>
<p>Actually, every object must belong to a <kbd>constructor</kbd>. Every object has an inherited property named <kbd>constructor</kbd>, pointing to the object's <kbd>constructor</kbd>. When we create objects using the <kbd>object</kbd> literal, the <kbd>constructor</kbd> property points to the global <kbd>Object</kbd> of the <kbd>constructor</kbd>. Consider this example to understand this behavior:</p>
<pre>var student = {} <br/>console.log(student.constructor == Object); //Output "true"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the prototypal inheritance model</h1>
                </header>
            
            <article>
                
<p>Each JavaScript object has an internal <kbd>[[prototype]]</kbd> property pointing to another object called its prototype. This prototype object has a prototype of its own, and so on, until an object is reached with null as its prototype. null has no prototype, and it acts as a final link in the prototype chain.</p>
<p>When trying to access a property of an object, and if the property is not found in the object, then the property is searched for in the object's prototype. If still not found, then it's searched for in the prototype of the prototype object. It keeps on going until null is encountered in the prototype chain. This is how inheritance works in JavaScript.</p>
<p>As a JavaScript object can have only one prototype, JavaScript supports only a single inheritance.</p>
<p>While creating objects using the <kbd>object</kbd> literal, we can use the special <kbd>__proto__</kbd> property or the <kbd>Object.setPrototypeOf()</kbd> method to assign a prototype of an object. JavaScript also provides an <kbd>Object.create()</kbd> method, with which we can create a new object with a specified prototype, as <kbd>__proto__</kbd> lacks browser support, and the <kbd>Object.setPrototypeOf()</kbd> method seems a little odd.</p>
<p>Here is a code example that demonstrates different ways to set the prototype of an object while creating that particular object using the O<kbd>bject</kbd> literal:</p>
<pre>const object1 = { name: "Eden", __proto__: {age: 24} } <br/>const object2 = {name: "Eden" } <br/><br/>Object.setPrototypeOf(object2, {age: 24}); <br/><br/>const object3 = Object.create({age: 24}, {<br/>    name: {value: "Eden"}<br/>}); <br/><br/>console.log(object1.name + " " + object1.age); <br/>console.log(object2.name + " " + object2.age); <br/>console.log(object3.name + " " + object3.age);</pre>
<p>The output is as follows:</p>
<pre><strong>Eden 24</strong><br/><strong>Eden 24</strong><br/><strong>Eden 24</strong></pre>
<p>Here, the <kbd>{age:24}</kbd> object is referred to as a base object, super object, or parent object as it's being inherited. And the <kbd>{name:"Eden"}</kbd> object is referred to as the derived object, subobject, or the child object, as it inherits another object.</p>
<p>If you don't assign a prototype to an object while creating it using the <kbd>object</kbd> literal, then the prototype points to the <kbd>Object.prototype</kbd> property. The prototype of <kbd>Object.prototype</kbd> is null, therefore leading to the end of the prototype chain. Here is an example to demonstrate this:</p>
<pre>const obj = { name: "Eden" } <br/>console.log(obj.__proto__ == Object.prototype); //Output "true"</pre>
<p>While creating objects using a <kbd>constructor</kbd>, the prototype of the new objects always points to a property named prototype of the <kbd>function</kbd> object. By default, the <kbd>prototype</kbd> property is an object with one property named the <kbd>constructor</kbd>. The <kbd>constructor</kbd> property points to the <kbd>function</kbd> itself. Consider this example to understand this model:</p>
<pre>function Student() { <br/>    this.name = "Eden"; <br/>} <br/>const obj = new Student(); <br/>console.log(obj.__proto__.constructor == Student); //Output "true" <br/>console.log(obj.__proto__ == Student.prototype); //Output "true"</pre>
<p>To add new methods to the instances of a <kbd>constructor</kbd>, we should add them to the <kbd>prototype</kbd> property of the <kbd>constructor</kbd>, as we did earlier.</p>
<p>The reason why we didn't add the methods to the <kbd>constructor</kbd> using <kbd>this</kbd> previously is that every instance of the <kbd>constructor</kbd> will have a copy of the methods, and this isn't very memory-efficient. By attaching methods to the <kbd>prototype</kbd> property of a <kbd>constructor</kbd>, there is only one copy of each function that all the instances share. To understand this, consider this example:</p>
<pre>function Student(name) { <br/>    this.name = name; <br/>} <br/>Student.prototype.printName = function() { <br/>    console.log(this.name); <br/>} <br/><br/>const s1 = new Student("Eden"); <br/>const s2 = new Student("John"); <br/><br/>function School(name) { <br/>    this.name = name; <br/>    this.printName = function() { <br/>        console.log(this.name); <br/>    } <br/>} <br/><br/>const s3 = new School("ABC");<br/>const s4 = new School("XYZ"); <br/>console.log(s1.printName == s2.printName); <br/>console.log(s3.printName == s4.printName);</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>false</strong></pre>
<p>Here, <kbd>s1</kbd> and <kbd>s2</kbd> share the same <kbd>printName</kbd> function that reduces the use of memory, whereas <kbd>s3</kbd> and <kbd>s4</kbd> contain two different functions called <kbd>printName</kbd> that make the program use more memory. This is unnecessary, as both the functions do the same thing. Therefore, we add methods for the instances to the <kbd>prototype</kbd> property of the <kbd>constructor</kbd>.</p>
<p>Implementing the inheritance hierarchy in the <kbd>constructor</kbd> is not as straightforward as for <kbd>object</kbd> literals. This is because the child <kbd>constructor</kbd> needs to invoke the parent <kbd>constructor</kbd> for the parent constructor's initialization logic to take place, and we need to add the methods of the <kbd>prototype</kbd> property of the parent <kbd>constructor</kbd> to the <kbd>prototype</kbd> property of the child <kbd>constructor</kbd> so that we can use them with the objects of the child <kbd>constructor</kbd>. There is no predefined way to do all this. Developers and JavaScript libraries have their own ways of doing this. I will show you the most common way of doing it.</p>
<p>Here is an example to demonstrate how to implement inheritance while creating objects using the constructors:</p>
<pre>function School(schoolName) { <br/>    this.schoolName = schoolName; <br/>} <br/><br/>School.prototype.printSchoolName = function(){ <br/>    console.log(this.schoolName); <br/>} <br/><br/>function Student(studentName, schoolName) { <br/>    this.studentName = studentName; <br/>    School.call(this, schoolName); <br/>} <br/><br/>Student.prototype = new School(); <br/>Student.prototype.printStudentName = function() { <br/>    console.log(this.studentName); <br/>}<br/><br/>const s = new Student("Eden", "ABC School"); <br/>s.printStudentName(); <br/>s.printSchoolName();</pre>
<p>The output is as follows:</p>
<pre><strong>Eden</strong><br/><strong>ABC School</strong></pre>
<p>Here, we invoked the parent <kbd>constructor</kbd> using the <kbd>call</kbd> method of the <kbd>function</kbd> object. To inherit the methods, we created an instance of the parent <kbd>constructor</kbd> and assigned it to the child constructor's <kbd>prototype</kbd> property.</p>
<p>This is not a foolproof way of implementing inheritance in the constructors, as there are lots of potential problems. For example, if the parent <kbd>constructor</kbd> does something other than just initialize properties, such as DOM manipulation, then assigning a new instance of the parent <kbd>constructor</kbd> to the <kbd>prototype</kbd> property of the child <kbd>constructor</kbd> can cause problems.</p>
<p>Therefore, classes provide a better and easier way to inherit existing constructors and classes. We will see more on this later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The constructors of primitive data types</h1>
                </header>
            
            <article>
                
<p>Primitive data types, such as Boolean, string, and number, have their constructor counterparts. These counterpart constructors behave like wrappers for these primitive types. For example, the <kbd>String</kbd> constructor is used to create a string object that contains an internal <kbd>[[PrimitiveValue]]</kbd> property that holds the actual primitive value.</p>
<p>At runtime, wherever necessary, the primitive values are wrapped with their <kbd>constructor</kbd> counterparts, and the counterpart objects are treated as primitive values so that the code works as expected. Consider this example code to understand how it works:</p>
<pre>const s1 = "String"; <br/>const s2 = new String("String"); <br/>console.log(typeof s1); <br/>console.log(typeof s2); <br/>console.log(s1 == s2); <br/>console.log(s1.length);</pre>
<p>The output is as follows:</p>
<pre><strong>string</strong><br/><strong>object</strong><br/><strong>true</strong><br/><strong>6</strong></pre>
<p>Here, <kbd>s1</kbd> is a primitive type, and <kbd>s2</kbd> is an object although applying the <kbd>==</kbd> operator on them gives us a true result. s1 is a primitive type but still we are able to access the length property even though primitive types shouldn't have any properties.</p>
<p>All this is happening because the previous code was converted into this at run-time:</p>
<pre>const s1 = "String"; <br/>const s2 = new String("String");<br/> <br/>console.log(typeof s1); <br/>console.log(typeof s2); <br/>console.log(s1 == s2.valueOf()); <br/>console.log((new String(s1)).length);</pre>
<p>Here, we can see how the primitive value was wrapped with its <kbd>constructor</kbd> counterpart, and how the object counterpart was treated as a primitive value where necessary. Therefore, the code works as expected.</p>
<p>Primitive types introduced from ES6 onwards won't allow their counterpart functions to be invoked as constructors, that is, we can't explicitly wrap them using their object counterparts. We saw this behavior while learning symbols.</p>
<p>The null and undefined primitive types don't have any counterpart constructors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using classes</h1>
                </header>
            
            <article>
                
<p>We saw that JavaScript's object-oriented model is based on constructors and prototype-based inheritance. Well, ES6 classes are just a new syntax for the existing model. Classes do not introduce a new object-oriented model to JavaScript.</p>
<p>ES6 classes aim to provide a much simpler and clearer syntax for dealing with the constructors and inheritance.</p>
<p>In fact, classes are functions. Classes are just a new syntax for creating functions that are used as constructors. Creating functions using classes that aren't used as constructors doesn't make any sense, and offers no benefits.</p>
<p>Rather, it makes your code difficult to read, as it becomes confusing. Therefore, use classes only if you want to use them to construct objects. Let's have a look at classes in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a class</h1>
                </header>
            
            <article>
                
<p>Just as there are two ways of defining functions, function declarations and function expressions, there are two ways to define a class: using the class declaration and the class expression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The class declaration</h1>
                </header>
            
            <article>
                
<p>To define a class using the <kbd>class</kbd> declaration, you need to use the <kbd>class</kbd> keyword and a name for the <kbd>class</kbd>.</p>
<p>Here is a code example to demonstrate how to define a class using the <kbd>class</kbd> declaration:</p>
<pre>class Student { <br/>    constructor(name) { <br/>        this.name = name; <br/>    } <br/>} <br/><br/>const s1 = new Student("Eden"); <br/>console.log(s1.name); //Output "Eden" </pre>
<p>Here, we created a <kbd>class</kbd> named <kbd>Student</kbd>. Then, we defined a <kbd>constructor</kbd> method in it. Finally, we created a new instance of the class—an object, and logged the name property of the object.</p>
<p>The body of a <kbd>class</kbd> is in the curly brackets, that is, <kbd>{}</kbd>. This is where we need to define methods. Methods are defined without the <kbd>function</kbd> keyword, and a comma is not used in between the methods.</p>
<p>Classes are treated as functions; internally the class name is treated as the function name, and the body of the <kbd>constructor</kbd> method is treated as the body of the function.</p>
<p>There can only be one <kbd>constructor</kbd> method in a <kbd>class</kbd>. Defining more than one <kbd>constructor</kbd> will throw the <kbd>SyntaxError</kbd> exception.</p>
<p>All the code inside a class body is executed in strict mode, by default.</p>
<p>The previous code is the same as this code when written using a <kbd>function</kbd>:</p>
<pre>function Student(name) { <br/>    this.name = name; <br/>} <br/><br/>const s1 = new Student("Eden"); <br/>console.log(s1.name); //Output "Eden"</pre>
<p>To prove that a <kbd>class</kbd> is a <kbd>function</kbd>, consider this code:</p>
<pre>class Student { <br/>    constructor(name) { <br/>        this.name = name; <br/>    } <br/>} <br/><br/>function School(name) { <br/>    this.name = name; <br/>} <br/><br/>console.log(typeof Student); <br/>console.log(typeof School == typeof Student);</pre>
<p>The output is as follows:</p>
<pre><strong>function</strong><br/><strong>true</strong></pre>
<p>Here, we can see that a <kbd>class</kbd> is a <kbd>function</kbd>. It's just a new syntax for creating a function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The class expression</h1>
                </header>
            
            <article>
                
<p>A class expression has a similar syntax to a <kbd>class</kbd> declaration. However, with <kbd>class</kbd> expressions, you are able to omit the class name. The body and behavior remain the same both ways.</p>
<p>Here is a code example to demonstrate how to define a <kbd>class</kbd> using a <kbd>class</kbd> expression:</p>
<pre>const Student = class { <br/>    constructor(name) { <br/>        this.name = name; <br/>    } <br/>} <br/><br/>const s1 = new Student("Eden"); <br/>console.log(s1.name); //Output "Eden"</pre>
<p>Here, we stored a reference of the <kbd>class</kbd> in a variable and used it to construct the objects.</p>
<p>The previous code is the same as this code when written using a <kbd>function</kbd>:</p>
<pre>const Student = function(name) { <br/>    this.name = name; <br/>}; <br/>const s1 = new Student("Eden"); <br/>console.log(s1.name); //Output "Eden"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The prototype methods</h1>
                </header>
            
            <article>
                
<p>All the methods in the body of the <kbd>class</kbd> are added to the <kbd>prototype</kbd> property of the class. The <kbd>prototype</kbd> property is the prototype of the objects created using <kbd>class</kbd>.</p>
<p>Here is an example that shows how to add methods to the <kbd>prototype</kbd> property of a <kbd>class</kbd>:</p>
<pre>class Person { <br/>    constructor(name, age) { <br/>        this.name = name; <br/>        this.age = age; <br/>    } <br/>    printProfile() { <br/>        console.log("Name is: " + this.name + " and Age is: " + this.age); <br/>    } <br/>} <br/><br/>const p = new Person("Eden", 12);<br/>p.printProfile(); <br/>console.log("printProfile" in p.__proto__); <br/>console.log("printProfile" in Person.prototype);</pre>
<p>The output is as follows:</p>
<pre><strong>Name is: Eden and Age is: 12</strong><br/><strong>true</strong><br/><strong>true</strong></pre>
<p>Here, we can see that the <kbd>printProfile</kbd> method was added to the <kbd>prototype</kbd> property of the <kbd>class</kbd>.</p>
<p>The previous code is the same as this code when written using a <kbd>function</kbd>:</p>
<pre>function Person(name, age) { <br/>    this.name = name; <br/>    this.age = age; <br/>} <br/><br/>Person.prototype.printProfile = function() { <br/>    console.log("Name is: " + this.name + " and Age is: " + this.age); <br/>} <br/><br/>const p = new Person("Eden", 12);<br/>p.printProfile(); <br/>console.log("printProfile" in p.__proto__); <br/>console.log("printProfile" in Person.prototype);</pre>
<p>The output is as follows:</p>
<pre><strong>Name is: Eden and Age is: 12</strong><br/><strong>true</strong><br/><strong>true</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getters and setters</h1>
                </header>
            
            <article>
                
<p>Earlier, to add accessor properties to objects we had to use the <kbd>Object. defineProperty()</kbd> method. From ES6 onwards, there are get and set prefixes for methods. These methods can be added to <kbd>object</kbd> literals and classes to define the get and set attributes of the accessor properties.</p>
<p>When get and <kbd>set</kbd> methods are used in a <kbd>class</kbd> body, they are added to the <kbd>prototype</kbd> property of the class.</p>
<p>Here is an example to demonstrate how to define the <kbd>get</kbd> and <kbd>set</kbd> methods in a <kbd>class</kbd>:</p>
<pre>class Person { <br/>    constructor(name) { <br/>        this._name_ = name; <br/>    } <br/>    get name() { <br/>        return this._name_; <br/>    } <br/>    set name(name) {<br/>        this.someOtherCustomProp = true;<br/>        this._name_ = name; <br/>    } <br/>} <br/><br/>const p = new Person("Eden"); <br/>console.log(p.name); // Outputs: "Eden"<br/>p.name = "John"; <br/>console.log(p.name); // Outputs: "John"<br/>console.log(p.someOtherCustomProp); // Outputs: "true"</pre>
<p>Here, we created an accessor property to encapsulate the <kbd>_name_</kbd> property. We also logged some other information to prove that <kbd>name</kbd> is an accessor property that is added to the <kbd>prototype</kbd> property of the <kbd>class</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The generator method</h1>
                </header>
            
            <article>
                
<p>To treat a concise method of an <kbd>object</kbd> literal as the <kbd>generator</kbd> method, or to treat a method of a <kbd>class</kbd> as the <kbd>generator</kbd> method, we can simply prefix it with the <kbd>*</kbd> character.</p>
<p>The <kbd>generator</kbd> method of a class is added to the <kbd>prototype</kbd> property of the class.</p>
<p>Here is an example to demonstrate how to define a <kbd>generator</kbd> method in the <kbd>class</kbd>:</p>
<pre>class myClass {  <br/>    * generator_function()  {  <br/>        yield 1;  <br/>        yield 2;  <br/>        yield 3;  <br/>        yield 4;  <br/>        yield 5;  <br/>    } <br/>} <br/><br/>const obj = new myClass(); <br/>let generator = obj.generator_function(); <br/>console.log(generator.next().value); <br/>console.log(generator.next().value); <br/>console.log(generator.next().value); <br/>console.log(generator.next().value); <br/>console.log(generator.next().value); <br/>console.log(generator.next().done); <br/>console.log("generator_function" in myClass.prototype);</pre>
<p>The output is as follows:</p>
<pre><strong> 1</strong><br/><strong> 2</strong><br/><strong> 3</strong><br/><strong> 4</strong><br/><strong> 5</strong><br/><strong> true</strong><br/><strong> true</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static methods</h1>
                </header>
            
            <article>
                
<p>The methods that are added to the body of the <kbd>class</kbd> with the <kbd>static</kbd> prefix are called <kbd>static</kbd> methods. The <kbd>static</kbd> methods are the class' own methods; that is, they are added to the class itself rather than the <kbd>prototype</kbd> property of the <kbd>class</kbd>. For example, the <kbd>String.fromCharCode()</kbd> method is a <kbd>static</kbd> method of the string <kbd>constructor</kbd>, that is, <kbd>fromCharCode</kbd> is the property of the <kbd>String</kbd> function itself.</p>
<p>The <kbd>static</kbd> methods are often used to create utility functions for an application.</p>
<p>Here is an example to demonstrate how to define and use a <kbd>static</kbd> method in a <kbd>class</kbd>:</p>
<pre>class Student {  <br/>    constructor(name)  {  <br/>        this.name = name;  <br/>    }  <br/>    static findName(student)  {  <br/>        return student.name;  <br/>    } <br/>} <br/><br/>const s = new Student("Eden"); <br/>const name = Student.findName(s); <br/>console.log(name); //Output "Eden"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing inheritance in classes</h1>
                </header>
            
            <article>
                
<p>Earlier in this chapter, we saw how difficult it was to implement inheritance hierarchies in functions. Therefore, ES6 aims to make it easy by introducing the <kbd>extends</kbd> clause and the <kbd>super</kbd> keyword for classes.</p>
<p>By using the <kbd>extends</kbd> clause, a <kbd>class</kbd> can inherit static and non-static properties from another <kbd>constructor</kbd> (which may or may not be defined using a class).</p>
<p>The super keyword is used in two ways:</p>
<ul>
<li>It's used in a class <kbd>constructor</kbd> method to call the parent <kbd>constructor</kbd></li>
<li>When used inside the methods of a <kbd>class</kbd>, it references the static and non-static methods of the parent <kbd>constructor</kbd></li>
</ul>
<p>Here is an example to demonstrate how to implement an inheritance hierarchy in constructors using the <kbd>extends</kbd> clause, and the <kbd>super</kbd> keyword:</p>
<pre>function A(a) { <br/>    this.a = a; <br/>} <br/><br/>A.prototype.printA = function(){ <br/>    console.log(this.a); <br/>}<br/><br/>class B extends A {  <br/>    constructor(a, b)  {  <br/>        super(a);  <br/>        this.b = b;  <br/>    }  <br/>    <br/>    printB()  {  <br/>        console.log(this.b);  <br/>    }  <br/><br/>    static sayHello()  {  <br/>        console.log("Hello");  <br/>    } <br/>} <br/><br/>class C extends B {  <br/>    constructor(a, b, c)  {  <br/>        super(a, b);  <br/>        this.c = c;  <br/>    }  <br/><br/>    printC()  {  <br/>        console.log(this.c);  <br/>    }  <br/><br/>    printAll()  {  <br/>        this.printC();  <br/>        super.printB();  <br/>        super.printA();  <br/>    } <br/>} <br/><br/>const obj = new C(1, 2, 3); <br/>obj.printAll(); <br/>C.sayHello();</pre>
<p>The output is as follows:</p>
<pre><strong> 3</strong><br/><strong> 2</strong><br/><strong> 1</strong><br/><strong> Hello</strong></pre>
<p>Here, <kbd>A</kbd> is a function <kbd>constructor</kbd>; <kbd>B</kbd> is a <kbd>class</kbd> that inherits <kbd>A</kbd>; <kbd>C</kbd> is a <kbd>class</kbd> that inherits <kbd>B</kbd>; and as <kbd>B</kbd> inherits <kbd>A</kbd>, therefore <kbd>C</kbd> also inherits <kbd>A</kbd>.</p>
<p>As a class can inherit a function <kbd>constructor</kbd>, we can also inherit prebuilt function constructors, such as string and array, and also custom function constructors using the classes instead of the alternative hacky ways that we used to use.</p>
<p>The previous example also shows how and where to use the <kbd>super</kbd> keyword. Remember that, inside the <kbd>constructor</kbd> method, you need to use the <kbd>super</kbd> keyword before using the <kbd>this</kbd> keyword. Otherwise, an exception is thrown.</p>
<p>If a child class doesn't have a <kbd>constructor</kbd> method, then the default behavior will invoke the <kbd>constructor</kbd> method of the parent class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computed method names</h1>
                </header>
            
            <article>
                
<p>You can also decide the name of static and non-static methods of a <kbd>class</kbd> and concise methods of an <kbd>object</kbd> literal at run-time; that is, you can define method name via expressions. Here is an example to demonstrate this:</p>
<pre>class myClass { <br/>    static ["my" + "Method"]() { <br/>        console.log("Hello"); <br/>    } <br/>} <br/><br/>myClass["my" + "Method"](); //Output "Hello"</pre>
<p>Computed property names also allow you to use symbols as keys for the methods. Here is an example to demonstrate this:</p>
<pre>var s = Symbol("Sample"); <br/><br/>class myClass { <br/>    static [s]() { <br/>        console.log("Hello"); <br/>    } <br/>} <br/><br/>myClass[s](); //Output "Hello"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The attributes of properties</h1>
                </header>
            
            <article>
                
<p>When using a class, the attributes of the static and non-static properties of the <kbd>constructor</kbd> are different from when declared using a function:</p>
<ul>
<li>The <kbd>static</kbd> methods are writable and configurable, but not enumerable</li>
<li>The <kbd>prototype</kbd> property and the <kbd>prototype.constructor</kbd> property of a <kbd>class</kbd> are not writable, enumerable, or configurable</li>
<li>The properties of the <kbd>prototype</kbd> property are writable and configurable, but not enumerable</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classes are not hoisted!</h1>
                </header>
            
            <article>
                
<p>You can call a function before it's defined; that is, function calls can be made before the function definition. But, you cannot use a <kbd>class</kbd> before it's defined. Trying to do so in classes will throw the <kbd>ReferenceError</kbd> exception.</p>
<p>Here is an example to demonstrate this:</p>
<pre>myFunc(); // fine<br/>function myFunc(){} <br/>var obj = new myClass(); // throws error<br/>class myClass {}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding the result of the constructor method</h1>
                </header>
            
            <article>
                
<p>The <kbd>constructor</kbd> method, by default, returns the new instance if there is no return statement in it. If there is a return statement, then any value in the return statement is returned. This might seem a little weird if you're coming from a language like C++ as you cannot usually return any value from the <kbd>constructor</kbd> there.</p>
<p>Here is an example to demonstrate this:</p>
<pre>class myClass { <br/>    constructor() { <br/>        return Object.create(null); <br/>    } <br/>} <br/><br/>console.log(new myClass() instanceof myClass); //Output "false"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Symbol.species static accessor property</h1>
                </header>
            
            <article>
                
<p>The <kbd>@@species</kbd> static accessor property is optionally added to a child <kbd>constructor</kbd> in order to notify the methods of the parent <kbd>constructor</kbd> about what the <kbd>constructor</kbd> should use if the parent constructor's methods are returning new instances. If the <kbd>@@species</kbd> static accessor property is not defined on a child <kbd>constructor</kbd>, then the methods of the parent <kbd>constructor</kbd> can use the default <kbd>constructor</kbd>.</p>
<p>Consider this example to understand the use of <kbd>@@species</kbd>—the <kbd>map()</kbd> method of the array objects returns a new Array instance. If we call the <kbd>map()</kbd> method of an object that inherits an <kbd>Array</kbd> object, then the <kbd>map()</kbd> method returns a new instance of the child <kbd>constructor</kbd> instead of the <kbd>Array</kbd> constructor, which is not what we always want. The <kbd>@@species</kbd> property, which provides a way to signal such kinds of functions, uses a different <kbd>constructor</kbd> instead of the default <kbd>constructor</kbd>.</p>
<p>Here is a code example to demonstrate how to use the <kbd>@@species</kbd> static accessor property:</p>
<pre>class myCustomArray1 extends Array {  <br/>    static get [Symbol.species]()  {  <br/>        return Array;  <br/>    } <br/>} <br/><br/>class myCustomArray2 extends Array{} <br/><br/>var arr1 = new myCustomArray1(0, 1, 2, 3, 4); <br/>var arr2 = new myCustomArray2(0, 1, 2, 3, 4); <br/><br/>console.log(arr1 instanceof myCustomArray1); // Outputs "true"<br/>console.log(arr2 instanceof myCustomArray2); // Outputs "true"<br/>arr1 = arr1.map(value =&gt; value + 1); <br/>arr2 = arr2.map(value =&gt; value + 1); <br/><br/>console.log(arr1 instanceof myCustomArray1);  // Outputs "false"<br/>console.log(arr2 instanceof myCustomArray2);  // Outputs "true"<br/>console.log(arr1 instanceof Array); // Outputs "true"<br/>console.log(arr2 instanceof Array); // Outputs "true"</pre>
<p>It is recommended that, if you are creating a JavaScript library, then the methods of the constructors in your library should always look for the <kbd>@@species</kbd> property while returning new instances. Here is an example to demonstrate this:</p>
<pre>//Assume myArray1 is part of library <br/>class myArray1 { <br/>//default @@species. Child class will inherit this property <br/>    static get [Symbol.species]() { <br/>        //default constructor <br/>        return this; <br/>    } <br/>    mapping() { <br/>        return new this.constructor[Symbol.species](); <br/>    } <br/>} <br/><br/>class myArray2 extends myArray1 { <br/>    static get [Symbol.species]() { <br/>        return myArray1; <br/>    } <br/>}<br/> <br/>let arr = new myArray2(); <br/>console.log(arr instanceof myArray2); //Output "true" <br/>arr = arr.mapping(); <br/>console.log(arr instanceof myArray1); //Output "true"</pre>
<p>If you don't want to define a default <kbd>@@species</kbd> property in parent constructors, then you can use the <kbd>if…else</kbd> conditional to check whether the <kbd>@@species</kbd> property is defined or not, but the previous pattern is preferred. The built-in <kbd>map()</kbd> method also uses the previous pattern.</p>
<p>All the built-in methods of the JavaScript constructors from ES6 look for a <kbd>@@species</kbd> property if they return a new instance. For example, the methods of <kbd>Array</kbd>, <kbd>Map</kbd>, <kbd>ArrayBuffer</kbd>, <kbd>Promise</kbd>, and other such constructors look for the <kbd>@@species</kbd> property if they return new instances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The new.target implicit parameter</h1>
                </header>
            
            <article>
                
<p>The default value of new.target is undefined, but when a function is invoked as a constructor, the value of the new.target parameter depends on the following conditions:</p>
<ul>
<li>If a constructor is invoked using a new operator, then new.target points to this constructor</li>
<li>If a constructor is invoked via the super keyword, then the value of new.target in it is the same as the value of new.target of the constructor that is called super.</li>
</ul>
<p>Inside an arrow function, the value of new.target is the same as the value for the <kbd>new.target</kbd> of the surrounding non-arrow function.</p>
<p>Here is example code to demonstrate this:</p>
<pre>function myConstructor() { <br/>    console.log(new.target.name); <br/>} <br/><br/>class myClass extends myConstructor { <br/>    constructor() { <br/>        super(); <br/>    } <br/>} <br/><br/>const obj1 = new myClass(); <br/>const obj2 = new myConstructor();</pre>
<p>The output is as follows:</p>
<pre><strong>myClass</strong><br/><strong>myConstructor</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using super in object literals</h1>
                </header>
            
            <article>
                
<p>The super keyword can also be used in concise methods of object literals. The super keyword in concise methods of the object literals has the same value as the <kbd>[[prototype]]</kbd> property of the object defined by the object literal.</p>
<p>In object literals, super is used to access overridden properties by the child object.</p>
<p>Here is an example to demonstrate how to use super in object literals:</p>
<pre>const obj1 = { <br/>    print() { <br/>        console.log("Hello"); <br/>    } <br/>} <br/><br/>const obj2 = { <br/>    print() {<br/>        super.print(); <br/>    } <br/>} <br/><br/>Object.setPrototypeOf(obj2, obj1); <br/>obj2.print(); //Output "Hello"</pre>
<div class="packt_infobox">ES.next proposal includes adding support for truly private properties in classes using the hash (#) symbol. #myProp inside a class will be private to that class.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we first learned the basics of Object-Oriented Programming using a traditional function approach. Then, we jumped to classes and learned how they make it easy for us to read and write object-oriented JavaScript code. We also learned about some miscellaneous features such as the <kbd>new.target</kbd> and accessor methods. Let us now move on to the web, a place where we can implement what we've learned so far!</p>


            </article>

            
        </section>
    </body></html>