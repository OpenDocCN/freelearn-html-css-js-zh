<html><head></head><body><div><p>&#13;
    <h1 class="chapterNumber">2</h1>&#13;
    <h1 id="_idParaDest-40" class="chapterTitle">JavaScript Essentials</h1>&#13;
    <p class="normal">In this chapter, we will be dealing with some essential building blocks of JavaScript: variables and operators. We will start with variables, what they are, and which different variable data types exist. We need these basic building blocks to store and work with variable values in our scripts, making them dynamic.</p>&#13;
    <p class="normal">Once we've got the variables covered, we will be ready to deal with operators. Arithmetic, assignment, and conditional and logical operators will be discussed at this stage. We need operators to modify our variables or to tell us something about these variables. This way we can do basic calculations based on factors such as user input.</p>&#13;
    <p class="normal">Along the way, we'll cover the following topics:</p>&#13;
    <ul>&#13;
      <li class="bullet">Variables</li>&#13;
      <li class="bullet">Primitive data types</li>&#13;
      <li class="bullet">Analyzing and modifying data types</li>&#13;
      <li class="bullet">Operators<div>&#13;
          <p class="Information-Box--PACKT-">Note: exercise, project, and self-check quiz answers can be found in the <em class="italic">Appendix</em>.</p>&#13;
        </p>&#13;
      </li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-41" class="title">Variables</h1>&#13;
    <p class="normal">Variables are the first building block you will be introduced to when learning most languages. Variables are values <a id="_idIndexMarker041"/>in your code that can represent different values each time the code runs. Here is an example of two variables in a script:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">firstname = "Maaike";&#13;
x = 2;&#13;
</code></pre>&#13;
    <p class="normal">And they can be assigned a new value while the code is running:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">firstname = "Edward";&#13;
x = 7;&#13;
</code></pre>&#13;
    <p class="normal">Without variables, a piece <a id="_idIndexMarker042"/>of code would do the exact same thing every single time it was run. Even though that could still be helpful in some cases, it can be made much more powerful by working with variables to allow our code to do something different every time we run it.</p>&#13;
    <h2 id="_idParaDest-42" class="title">Declaring variables</h2>&#13;
    <p class="normal">The first time you create a variable, you declare it. And you need a special word for that: <code class="Code-In-Text--PACKT-">let</code>, <code class="Code-In-Text--PACKT-">var</code>, or <code class="Code-In-Text--PACKT-">const</code>. We'll discuss <a id="_idIndexMarker043"/>the use of these three arguments shortly. The second time you call a variable, you only use the name of the existing variable to assign it a new value:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let firstname = "Maria";&#13;
firstname = "Jacky";&#13;
</code></pre>&#13;
    <p class="normal">In our examples, we will be assigning a value to our variables in the code. This is called "hardcoded" since the value of your variable is defined in your script instead of coming dynamically from some external input. This is something you won't be doing that often in actual code, as more commonly the value comes from an external source, such as an input box on a website that a user filled out, a database, or some other code that calls your code. The use of variables coming from external sources instead of being hardcoded into a script is actually the reason that scripts are adaptable to new information, without having to rewrite the code. </p>&#13;
    <p class="normal">We have just established how powerful the variable building block is in code. Right now, we are going to hardcode variables into our scripts, and they therefore will not vary until a coder changes the program. However, we will soon learn how to make our variables take in values from outside sources.</p>&#13;
    <h3 id="_idParaDest-43" class="title">let, var, and const</h3>&#13;
    <p class="normal">A variable definition <a id="_idIndexMarker044"/>consists of three parts: a variable-defining keyword (<code class="Code-In-Text--PACKT-">let</code>, <code class="Code-In-Text--PACKT-">var</code>, or <code class="Code-In-Text--PACKT-">const</code>), a name, and <a id="_idIndexMarker045"/>a value. Let's start with the difference between <code class="Code-In-Text--PACKT-">let</code>, <code class="Code-In-Text--PACKT-">var</code>, or <code class="Code-In-Text--PACKT-">const</code>. Here you can see some examples of variables using <a id="_idIndexMarker046"/>the different keywords:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 12;&#13;
var nr2 = 8;&#13;
const PI = 3.14159;&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">let</code> and <code class="Code-In-Text--PACKT-">var</code> are both used for variables that might have a new value assigned to them somewhere in the program. The difference between <code class="Code-In-Text--PACKT-">let</code> and <code class="Code-In-Text--PACKT-">var</code> is complex. It is related to scope. </p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">If you understand the following sentences on scope, that is great, but it is totally fine if you do not get it. You will understand it soon enough as you keep working your way through the book. </p>&#13;
    </p>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">var</code> has <strong class="keyword">global scope</strong> and <code class="Code-In-Text--PACKT-">let</code> has <strong class="keyword">block scope</strong>. <code class="Code-In-Text--PACKT-">var</code>'s global scope means that you can use the variables defined with <code class="Code-In-Text--PACKT-">var</code> in the entire script. On the other hand, <code class="Code-In-Text--PACKT-">let</code>'s block scope means <a id="_idIndexMarker047"/>you can only use variables defined with <code class="Code-In-Text--PACKT-">let</code> in the specific block of code in which they were defined. Remember, a block of code will always <a id="_idIndexMarker048"/>start with <code class="Code-In-Text--PACKT-">{</code> and end with <code class="Code-In-Text--PACKT-">}</code>, which is how you can recognize them.</p>&#13;
    <p class="normal">On the other hand, <code class="Code-In-Text--PACKT-">const</code> is used for variables that only get a value assigned once—for example, the value of pi, which will not change. If you try reassigning a value declared with <code class="Code-In-Text--PACKT-">const</code>, you will get an error:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">const someConstant = 3;&#13;
someConstant = 4;&#13;
</code></pre>&#13;
    <p class="normal">This will result in the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Uncaught TypeError: Assignment to constant variable.&#13;
</code></pre>&#13;
    <p class="normal">We will be using <code class="Code-In-Text--PACKT-">let</code> in most of our examples—for now, trust us that you should use <code class="Code-In-Text--PACKT-">let</code> in most cases.</p>&#13;
    <h3 id="_idParaDest-44" class="title">Naming variables </h3>&#13;
    <p class="normal">When it comes to naming variables, there are some conventions in place:</p>&#13;
    <ul>&#13;
      <li class="bullet">Variables start with a lowercase letter, and they should be descriptive. If something holds <a id="_idIndexMarker049"/>an age, do not call it <code class="Code-In-Text--PACKT-">x</code>, but <code class="Code-In-Text--PACKT-">age</code>. This way, when you read your script later, you can easily understand what you did by just reading your code.</li>&#13;
      <li class="bullet">Variables cannot contain spaces, but they can use underscores. If you use a space, JavaScript doesn't recognize it as a single variable.</li>&#13;
    </ul>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">We will be using camel case here. This means that when we want to use multiple words to describe a variable, we will start with a lowercase word, then use a capital for every new word after the first word—for example: <code class="Code-In-Text--PACKT-">ageOfBuyer</code>.</p>&#13;
      <p class="Information-Box--PACKT-">Whatever the convention is in the place you are working, the key is consistency. If all naming is done in a similar format, the code will look cleaner and more readable, which makes it a lot easier to make a small change later.</p>&#13;
    </p>&#13;
    <p class="normal">The value of your variable can be anything. Let's start with the easiest thing variables can be: primitives. </p>&#13;
    <h1 id="_idParaDest-45" class="title">Primitive data types</h1>&#13;
    <p class="normal">Now you know what variables are and why we need them in our code, it is time to look at the different types of values we can store in variables. Variables get a value assigned. And these values can be of different types. JavaScript is a loosely typed language. This means that JavaScript determines the type based on the value. The type does not need to be named explicitly. For example, if you declared a value of 5, JavaScript will automatically define it as a number type.</p>&#13;
    <p class="normal">A distinction exists between primitive data types and other, more complex data types. In this chapter, we will <a id="_idIndexMarker050"/>cover the primitive type, which is a relatively simple data structure. Let's say for now that they just contain a value and have a type. JavaScript has seven primitives: String, Number, BigInt, Boolean, Symbol, undefined, and null. We'll discuss each of them in more detail below.</p>&#13;
    <h2 id="_idParaDest-46" class="title">String</h2>&#13;
    <p class="normal">A string is used <a id="_idIndexMarker051"/>to store a text value. It is a sequence of characters. There <a id="_idIndexMarker052"/>are different ways to declare a string:</p>&#13;
    <ul>&#13;
      <li class="bullet">Double quotes</li>&#13;
      <li class="bullet">Single quotes</li>&#13;
      <li class="bullet">Backticks: special template strings in which you can use variables directly</li>&#13;
    </ul>&#13;
    <p class="normal">The single and double quotes can both be used like so:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let singleString = 'Hi there!';&#13;
let doubleString = "How are you?";&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">You can use the option you prefer, unless you are working on code in which one of these options has already been chosen. Again, consistency is key.</p>&#13;
    </p>&#13;
    <p class="normal">The main difference between single quotes and double quotes is that you can use single quotes as literal characters in double-quoted strings, and vice versa. If you declare a string with single <a id="_idIndexMarker053"/>quotes, the string will end as soon as a second quote is detected, even if it's in the middle of a word. So for example, the following will <a id="_idIndexMarker054"/>result in an error, because the string will be ended at the second single quote within <code class="Code-In-Text--PACKT-">let's</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let funActivity = 'Let's learn JavaScript';&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">Let</code> will be recognized as a string, but after that, the bunch of characters that follow cannot be interpreted by JavaScript. However, if you declare the string using double quotes, it will not end the string as soon as it hits the single quote, because it is looking for another double quote. Therefore, this alternative will work fine:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let funActivity = "Let's learn JavaScript";&#13;
</code></pre>&#13;
    <p class="normal">In the same way with double quotes, the following would not work:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let question = "Do you want to learn JavaScript? "Yes!"";&#13;
</code></pre>&#13;
    <p class="normal">Again, the compiler will not distinguish between double quotes used in different contexts, and will output an error.</p>&#13;
    <p class="normal">In a string using backticks, you can point to variables and the variable's value will be substituted into the line. You can see this in the following code snippet:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let language = "JavaScript";&#13;
let message = `Let's learn ${language}`;&#13;
console.log(message);&#13;
</code></pre>&#13;
    <p class="normal">As you can see, you will have to specify these variables with a rather funky syntax—don't be intimidated! Variables in these template strings are specified between <code class="Code-In-Text--PACKT-">${nameOfVariable}</code>. The reason that it's such an intense syntax is that they want to avoid it being something you would normally use, which would make it unnecessarily difficult to do so. In our case, the console output would be as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Let's learn JavaScript&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the <code class="Code-In-Text--PACKT-">language</code> variable gets replaced with its value: <code class="Code-In-Text--PACKT-">JavaScript</code>. </p>&#13;
    <h3 id="_idParaDest-47" class="title">Escape characters</h3>&#13;
    <p class="normal">Say we want to have double quotes, single quotes, and backticks in our string. We would have a problem, as this cannot be done with just the ingredients we have now. There is an elegant <a id="_idIndexMarker055"/>solution to this problem. There is a special character that can be used to tell JavaScript, "do not take the next character as you normally would." This is the escape character, a backslash. </p>&#13;
    <p class="normal">In this example, the backslash can be used to ensure your interpreter doesn't see the single or double quote marks and end either string too early:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let str = "Hello, what's your name? Is it \"Mike\"?";&#13;
console.log(str);&#13;
let str2 = 'Hello, what\'s your name? Is it "Mike"?';&#13;
console.log(str2);&#13;
</code></pre>&#13;
    <p class="normal">This logs the following to the console:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hello, what's your name? Is it "Mike"?&#13;
Hello, what's your name? Is it "Mike"?&#13;
</code></pre>&#13;
    <p class="normal">As you can see, both types of quote marks inside the strings have been logged without throwing an error. This is because the backslash before the quote character gives the quote character a different meaning. In this case, the meaning is that it should be a literal character instead of an indicator to end the string.</p>&#13;
    <p class="normal">The escape character has even more purposes. You can use it to create a line break with <code class="Code-In-Text--PACKT-">\n</code>, or to include a backslash character in the text with <code class="Code-In-Text--PACKT-">\\</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let str3 = "New \nline.";&#13;
let str4 = "I'm containing a backslash: \\!";&#13;
console.log(str3);&#13;
console.log(str4);&#13;
</code></pre>&#13;
    <p class="normal">The output of these lines is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">New &#13;
line.&#13;
I'm containing a backslash: \!&#13;
</code></pre>&#13;
    <p class="normal">There are some more options, but we will leave them for now. Let's get back to primitive data types by looking at the number type.</p>&#13;
    <h2 id="_idParaDest-48" class="title">Number</h2>&#13;
    <p class="normal">The number data type is used to represent, well, numbers. In many languages, there is a very clear difference between different types of numbers. The developers of JavaScript decided to go for <a id="_idIndexMarker056"/>one data type for all these numbers: number. To be more precise, they decided to go for a 64-bit floating-point number. This means <a id="_idIndexMarker057"/>that it can store rather large numbers and both signed and unsigned numbers, numbers with decimals, and more. </p>&#13;
    <p class="normal">However, there are different kinds of numbers it can represent. First of all, integers, for example: 4 or 89. But the number data type can also be used to represent decimals, exponentials, octal, hexadecimal, and binary numbers. The following code sample should speak for itself:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let intNr = 1;&#13;
let decNr = 1.5;&#13;
let expNr = 1.4e15;&#13;
let octNr = 0o10; //decimal version would be 8&#13;
let hexNr = 0x3E8; //decimal version would be 1000&#13;
let binNr = 0b101; //decimal version would be 5&#13;
</code></pre>&#13;
    <p class="normal">You don't need to worry about these last three if you're not familiar with them. These are just different ways to represent numbers that you may encounter in the broader field of computer science. The takeaway here is that all the above numbers are of the number data type. So integers are numbers, like these ones:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let intNr2 = 3434;&#13;
let intNr3 = -111;&#13;
</code></pre>&#13;
    <p class="normal">And the floating points are numbers as well, like this one:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let decNr2 = 45.78;&#13;
</code></pre>&#13;
    <p class="normal">And binary numbers are of the number data type as well, for example, this one:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let binNr2 = 0b100; //decimal version would be 4&#13;
</code></pre>&#13;
    <p class="normal">We have just seen the number data type, which is very commonly used. But in some special cases, you will need an even bigger number. </p>&#13;
    <h2 id="_idParaDest-49" class="title">BigInt</h2>&#13;
    <p class="normal">The limits of the number <a id="_idIndexMarker058"/>data type are between 2<sup class="Superscript--PACKT-">53</sup>-1 and -(2<sup class="Superscript--PACKT-">53</sup>-1). In case you <a id="_idIndexMarker059"/>were to need a bigger (or smaller) number, BigInt comes into play. A BigInt data type can be recognized by the postfix <code class="Code-In-Text--PACKT-">n</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let bigNr = 90071992547409920n;&#13;
</code></pre>&#13;
    <p class="normal">Let's see what happens when we start to do some calculations between our previously made integer Number, <code class="Code-In-Text--PACKT-">intNr</code>, and BigInt, <code class="Code-In-Text--PACKT-">bigNr</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let result = bigNr + intNr;&#13;
</code></pre>&#13;
    <p class="normal">The output will be as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions&#13;
</code></pre>&#13;
    <p class="normal">Uh-oh, a <code class="Code-In-Text--PACKT-">TypeError</code>! It is very clear about what is going wrong. We cannot mix BigInt with the Number data type to perform operations. This is something to keep in mind for later when actually working with BigInt—you can only operate on BigInt with other BigInts.</p>&#13;
    <h2 id="_idParaDest-50" class="title">Boolean</h2>&#13;
    <p class="normal">The Boolean data type can hold two values: <code class="Code-In-Text--PACKT-">true</code> and <code class="Code-In-Text--PACKT-">false</code>. There is nothing in between. This Boolean is <a id="_idIndexMarker060"/>used a lot in code, especially <a id="_idIndexMarker061"/>expressions that evaluate to a Boolean:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let bool1 = false;&#13;
let bool2 = true;&#13;
</code></pre>&#13;
    <p class="normal">In the preceding example, you can see the options we have for the Boolean data type. It is used for situations in which you want to store a <code class="Code-In-Text--PACKT-">true</code> or a <code class="Code-In-Text--PACKT-">false</code> value (which can indicate on/off or yes/no). For example, whether an element is deleted: </p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let objectIsDeleted = false;&#13;
</code></pre>&#13;
    <p class="normal">Or, whether the light is on or off:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let lightIsOn = true;&#13;
</code></pre>&#13;
    <p class="normal">These variables suggest respectively that the specified object is not deleted, and that the specific light is on.</p>&#13;
    <h2 id="_idParaDest-51" class="title">Symbol</h2>&#13;
    <p class="normal">Symbol is a brand new data type introduced in ES6 (we mentioned ECMA Script 6, or ES6, in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting Started with JavaScript</em>). Symbol can be used when it is important that <a id="_idIndexMarker062"/>variables are not equal, even though their value and type are the same (in this case, they would <a id="_idIndexMarker063"/>both be of the symbol type). Compare the following string declarations to the symbol declarations, all of equal value:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let str1 = "JavaScript is fun!";&#13;
let str2 = "JavaScript is fun!";&#13;
console.log("These two strings are the same:", str1 === str2);&#13;
 &#13;
let sym1 = Symbol("JavaScript is fun!");&#13;
let sym2 = Symbol("JavaScript is fun!");&#13;
console.log("These two Symbols are the same:", sym1 === sym2);&#13;
</code></pre>&#13;
    <p class="normal">And the output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">These two strings are the same: true&#13;
These two Symbols are the same: false&#13;
</code></pre>&#13;
    <p class="normal">In the first half, JavaScript concludes that the strings are the same. They have the same value, and the same type. However, in the second part, each symbol is unique. Therefore, although they contain the same string, they are not the same, and output <code class="Code-In-Text--PACKT-">false</code> when compared. These symbol data types can be very handy as properties of objects, which we will see in <em class="chapterRef">Chapter 3</em>, <em class="italic">JavaScript Multiple Values</em>.</p>&#13;
    <h2 id="_idParaDest-52" class="title">Undefined</h2>&#13;
    <p class="normal">JavaScript is a very <a id="_idIndexMarker064"/>special language. It has a special data type <a id="_idIndexMarker065"/>for a variable that has not been assigned a value. And this data type is undefined:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let unassigned;&#13;
console.log(unassigned);&#13;
</code></pre>&#13;
    <p class="normal">The output here will be:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Undefined&#13;
</code></pre>&#13;
    <p class="normal">We can also purposefully assign an <code class="Code-In-Text--PACKT-">undefined</code> value. It is important you know that it is possible, but it is even more important that you know that manually assigning undefined is a bad practice:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let terribleThingToDo = undefined;&#13;
</code></pre>&#13;
    <p class="normal">Alright, this can be done, but it is recommended to not do this. This is for a number of reasons—for example, checking <a id="_idIndexMarker066"/>whether two variables are the same. If one variable is undefined, and your own variable is manually set to undefined, they will be <a id="_idIndexMarker067"/>considered equal. This is an issue because if you are checking for equality, you would want to know whether two values are actually equal, not just that they are both undefined. This way, someone's pet and their last name might be considered equal, whereas they are actually both just empty values.</p>&#13;
    <h2 id="_idParaDest-53" class="title">null</h2>&#13;
    <p class="normal">In the last example, we saw an issue that can be solved with a final primitive type, null. null is a special value for <a id="_idIndexMarker068"/>saying that a variable is empty or has an <a id="_idIndexMarker069"/>unknown value. This is case sensitive. You should use lowercase for null:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let empty = null;&#13;
</code></pre>&#13;
    <p class="normal">To solve the issue we encountered with setting a variable as undefined, note that if you set it to null, you will not have the same problem. This is one of the reasons it is better to assign null to a variable when you want to say it is empty and unknown at first:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let terribleThingToDo = undefined;&#13;
let lastName;&#13;
console.log("Same undefined:", lastName === terribleThingToDo);&#13;
 &#13;
let betterOption = null;&#13;
console.log("Same null:", lastName === betterOption);&#13;
</code></pre>&#13;
    <p class="normal">This outputs the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Same undefined: true&#13;
Same null: false&#13;
</code></pre>&#13;
    <p class="normal">This shows that an automatically undefined variable, <code class="Code-In-Text--PACKT-">lastName</code>, and a deliberately undefined variable, <code class="Code-In-Text--PACKT-">terribleThingToDo</code>, are considered equal, which is problematic. On the other hand, <code class="Code-In-Text--PACKT-">lastName</code> and <code class="Code-In-Text--PACKT-">betterOption</code>, which was explicitly declared with a value of null, are not equal.</p>&#13;
    <h1 id="_idParaDest-54" class="title">Analyzing and modifying data types</h1>&#13;
    <p class="normal">We have seen the primitive data types. There are some built-in JavaScript methods that will help us deal <a id="_idIndexMarker070"/>with common problems related to primitives. Built-in methods <a id="_idIndexMarker071"/>are pieces of logic that can be used without having to write JavaScript logic yourself. </p>&#13;
    <p>&#13;
      <p class="Tip--PACKT-">We've seen one built-in method already: <code class="Code-In-Text--PACKT-">console.log()</code>. </p>&#13;
    </p>&#13;
    <p class="normal">There are many of these built-in methods, and the ones you will be meeting in this chapter are just the first few you will encounter.</p>&#13;
    <h2 id="_idParaDest-55" class="title">Working out the type of a variable</h2>&#13;
    <p class="normal">Especially with null <a id="_idIndexMarker072"/>and undefined, it can be hard to determine what kind of data type you are dealing with. Let's have a look at <code class="Code-In-Text--PACKT-">typeof</code>. This returns the type of the variable. You can check the type of a variable by entering <code class="Code-In-Text--PACKT-">typeof</code>, then either a space followed by the variable in question, or the variable in question in brackets:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">testVariable = 1;&#13;
variableTypeTest1 = typeof testVariable;&#13;
variableTypeTest2 = typeof(testVariable);&#13;
console.log(variableTypeTest1);&#13;
console.log(variableTypeTest2);&#13;
</code></pre>&#13;
    <p class="normal">As you might assume, both methods will output <code class="Code-In-Text--PACKT-">number</code>. Brackets aren't required because technically, <code class="Code-In-Text--PACKT-">typeof</code> is an operator, not a method, unlike <code class="Code-In-Text--PACKT-">console.log</code>. But, sometimes you may find that using brackets makes your code easier to read. Here you can see it in action:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let str = "Hello";&#13;
let nr = 7;&#13;
let bigNr = 12345678901234n;&#13;
let bool = true;&#13;
let sym = Symbol("unique");&#13;
let undef = undefined;&#13;
let unknown = null;&#13;
 &#13;
console.log("str", typeof str);&#13;
console.log("nr", typeof nr);&#13;
console.log("bigNr", typeof bigNr);&#13;
console.log("bool", typeof bool);&#13;
console.log("sym", typeof sym);&#13;
console.log("undef", typeof undef);&#13;
console.log("unknown", typeof unknown);&#13;
</code></pre>&#13;
    <p class="normal">Here, in the same <code class="Code-In-Text--PACKT-">console.log()</code> print command, we are printing the name of each variable (as a string, declared <a id="_idIndexMarker073"/>with double quotes), then its type (using <code class="Code-In-Text--PACKT-">typeof</code>). This will produce the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">str string&#13;
nr number&#13;
bigNr bigint&#13;
bool boolean&#13;
sym symbol&#13;
undef undefined&#13;
unknown object&#13;
</code></pre>&#13;
    <p class="normal">There is an odd one out, and that is the null type. In the output you can see that <code class="Code-In-Text--PACKT-">typeof null</code> returns <code class="Code-In-Text--PACKT-">object</code>, while in fact, null truly is a primitive and not an object. This is a bug that has been there since forever and now cannot be removed due to backward compatibility problems. Don't worry about this bug, as it won't affect our programs—just be aware of it, since it will go nowhere anytime soon, and it has the potential to break applications.</p>&#13;
    <h2 id="_idParaDest-56" class="title">Converting data types</h2>&#13;
    <p class="normal">The variables in JavaScript can <a id="_idIndexMarker074"/>change types. Sometimes JavaScript does this automatically. What do you think the result of running the following code snippet will be?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 2;&#13;
let nr2 = "2";&#13;
console.log(nr1 * nr2);&#13;
</code></pre>&#13;
    <p class="normal">We try to multiply a variable of type Number with a variable of type String. JavaScript does not just throw an error (as many languages would), but first tries to convert the string value to a number. If that can be done, it can execute without any problem as if two numbers were declared. In this case, <code class="Code-In-Text--PACKT-">console.log()</code> will write <code class="Code-In-Text--PACKT-">4</code> to the console.</p>&#13;
    <p class="normal">But this is dangerous! Guess what this code snippet does:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 2;&#13;
let nr2 = "2";&#13;
console.log(nr1 + nr2);&#13;
</code></pre>&#13;
    <p class="normal">This one will log <code class="Code-In-Text--PACKT-">22</code>. The plus sign can be used to concatenate strings. Therefore, instead of converting a string to a number, it is converting a number to a string in this example, and clubbing the <a id="_idIndexMarker075"/>two strings together—"<code class="Code-In-Text--PACKT-">2</code>" and "<code class="Code-In-Text--PACKT-">2</code>" make "<code class="Code-In-Text--PACKT-">22</code>". Luckily, we do not need to rely on JavaScript's behavior when converting data types. There are built-in functions we can use to convert the data type of our variable.</p>&#13;
    <p class="normal">There are three conversion methods: <code class="Code-In-Text--PACKT-">String()</code>, <code class="Code-In-Text--PACKT-">Number()</code>, and <code class="Code-In-Text--PACKT-">Boolean()</code>. The first one converts a variable to type String. It pretty much takes any value, including undefined and null, and puts quotes around it. </p>&#13;
    <p class="normal">The second one tries to convert a variable to a number. If that cannot be done logically, it will change the value into NaN (not a number). <code class="Code-In-Text--PACKT-">Boolean()</code> converts a variable to a Boolean. This will be true for everything except for null, undefined, 0 (number), an empty string, and NaN. Let's see them in action:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nrToStr = 6;&#13;
nrToStr = String(nrToStr);&#13;
console.log(nrToStr, typeof nrToStr);&#13;
 &#13;
let strToNr = "12";&#13;
strToNr = Number(strToNr);&#13;
console.log(strToNr, typeof strToNr);&#13;
 &#13;
let strToBool = "any string will return true";&#13;
strToBool = Boolean(strToBool);&#13;
console.log(strToBool, typeof strToBool);&#13;
</code></pre>&#13;
    <p class="normal">This will log the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">6 string&#13;
12 number&#13;
true boolean&#13;
</code></pre>&#13;
    <p class="normal">This might seem pretty straightforward, but not all of the options are equally obvious. These, for example, are not what you might think:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nullToNr = null;&#13;
nullToNr = Number(nullToNr);&#13;
console.log("null", nullToNr, typeof nullToNr);&#13;
 &#13;
let strToNr = "";&#13;
strToNr = Number(strToNr);&#13;
console.log("empty string", strToNr, typeof strToNr);&#13;
</code></pre>&#13;
    <p class="normal">The preceding code snippet will log the following to the console:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">null 0 number&#13;
empty string 0 number&#13;
</code></pre>&#13;
    <p class="normal">As you can see, an empty string and null will both result in the number 0. This is a choice that the makers <a id="_idIndexMarker076"/>of JavaScript made, which you will have to know—it can come in handy at times when you want to convert a string to 0 when it is empty or null.</p>&#13;
    <p class="normal">Next, enter the following snippet:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let strToNr2 = "hello";&#13;
strToNr2 = Number(strToNr2);&#13;
console.log(strToNr2, typeof strToNr2);&#13;
</code></pre>&#13;
    <p class="normal">The result that will be logged to the console is:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">NaN number&#13;
</code></pre>&#13;
    <p class="normal">Here, we can see that anything that can't be interpreted as a number by simply removing the quotes will evaluate as <code class="Code-In-Text--PACKT-">NaN</code> (not a number).</p>&#13;
    <p class="normal">Let's continue with the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let strToBool2 = "false";&#13;
strToBool2 = Boolean(strToBool2);&#13;
console.log(strToBool2, typeof strToBool2);&#13;
let strToBool = "";&#13;
strToBool = Boolean(strToBool);&#13;
console.log(strToBool, typeof strToBool);&#13;
</code></pre>&#13;
    <p class="normal">Finally, this one will log the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">true boolean&#13;
false boolean&#13;
</code></pre>&#13;
    <p class="normal">This output shows that any string will return <code class="Code-In-Text--PACKT-">true</code> when converted to a Boolean, even the string <code class="Code-In-Text--PACKT-">"false"</code>! Only an empty string, null, and undefined will lead to a Boolean value of <code class="Code-In-Text--PACKT-">false</code>. </p>&#13;
    <p class="normal">Let's tease your brain a little bit more. What do you think this one will log?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 2;&#13;
let nr2 = "2";&#13;
console.log(nr1 + Number(nr2));&#13;
</code></pre>&#13;
    <p class="normal">This one logs <code class="Code-In-Text--PACKT-">4</code>! The string gets converted to a number before it executes the plus operation, and therefore <a id="_idIndexMarker077"/>it is a mathematical operation and not a string concatenation. In the next sections of this chapter, we will discuss operators in more depth.</p>&#13;
    <h2 id="_idParaDest-57" class="title">Practice exercise 2.1</h2>&#13;
    <p class="normal">What are the types of these variables listed below? Verify this with <code class="Code-In-Text--PACKT-">typeof</code> and output the result to the console:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let str1 = 'Laurence'; &#13;
let str2 = "Svekis"; &#13;
let val1 = undefined;&#13;
let val2 = null;&#13;
let myNum = 1000;&#13;
</code></pre>&#13;
    <h1 id="_idParaDest-58" class="title">Operators</h1>&#13;
    <p class="normal">After seeing quite <a id="_idIndexMarker078"/>a few data types and some ways to convert them, it is time for the next major building block: operators. These come in handy whenever we want to work with the variables, modify them, perform calculations on them, and compare them. They are called operators because we use them to operate on our variables.</p>&#13;
    <h2 id="_idParaDest-59" class="title">Arithmetic operators</h2>&#13;
    <p class="normal">Arithmetic <a id="_idIndexMarker079"/>operators can be used to perform operations with numbers. Most of these operations will feel <a id="_idIndexMarker080"/>very natural to you because they are the basic mathematics you will have come across earlier in life already.</p>&#13;
    <h3 id="_idParaDest-60" class="title">Addition</h3>&#13;
    <p class="normal">Addition in JavaScript is <a id="_idIndexMarker081"/>very simple, we have seen it already. We use <code class="Code-In-Text--PACKT-">+</code> for this operation:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 12;&#13;
let nr2 = 14;&#13;
let result1 = nr1 + nr2;&#13;
</code></pre>&#13;
    <p class="normal">However, this <a id="_idIndexMarker082"/>operator can also come in very handy for concatenating strings. Note the added space after <code class="Code-In-Text--PACKT-">"Hello"</code> to ensure the end result contains space characters:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let str1 = "Hello ";&#13;
let str2 = "addition";&#13;
let result2 = str1 + str2;&#13;
</code></pre>&#13;
    <p class="normal">The output of printing <code class="Code-In-Text--PACKT-">result1</code> and <code class="Code-In-Text--PACKT-">result2</code> will be as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">26&#13;
Hello addition&#13;
</code></pre>&#13;
    <p class="normal">As you can see, adding numbers and strings lead to different results. If we add two different strings, it will concatenate them into a single string.</p>&#13;
    <h4 class="title">Practice exercise 2.2</h4>&#13;
    <p class="normal">Create a variable for your name, another one for your age, and another one for whether you can code JavaScript or not.</p>&#13;
    <p class="normal">Log to the console the following sentence, where <code class="Code-In-Text--PACKT-">name</code>, <code class="Code-In-Text--PACKT-">age</code> and <code class="Code-In-Text--PACKT-">true</code>/<code class="Code-In-Text--PACKT-">false</code> are variables: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hello, my name is Maaike, I am 29 years old and I can code JavaScript: true.&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-61" class="title">Subtraction</h3>&#13;
    <p class="normal">Subtraction works as we <a id="_idIndexMarker083"/>would expect it as well. We use <code class="Code-In-Text--PACKT-">-</code> for this operation. What do you think gets <a id="_idIndexMarker084"/>stored in the variable in this second example?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 20;&#13;
let nr2 = 4;&#13;
let str1 = "Hi";&#13;
let nr3 = 3;&#13;
let result1 = nr1 - nr2;&#13;
let result2 = str1 - nr3;&#13;
console.log(result1, result2);&#13;
</code></pre>&#13;
    <p class="normal">The output is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">16 NaN&#13;
</code></pre>&#13;
    <p class="normal">The first result is <code class="Code-In-Text--PACKT-">16</code>. And the second <a id="_idIndexMarker085"/>result is more interesting. It gives <code class="Code-In-Text--PACKT-">NaN</code>, not an error, but just simply <a id="_idIndexMarker086"/>the conclusion that a word and a number subtracted is not a number. Thanks for not crashing, JavaScript!</p>&#13;
    <h3 id="_idParaDest-62" class="title">Multiplication</h3>&#13;
    <p class="normal">We can multiply two numeric values with the <code class="Code-In-Text--PACKT-">*</code> character. Unlike some other languages, we cannot successfully <a id="_idIndexMarker087"/>multiply a number and a string in <a id="_idIndexMarker088"/>JavaScript. </p>&#13;
    <p class="normal">The result of multiplying a numeric and a non-numeric value is NaN:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 15;&#13;
let nr2 = 10;&#13;
let str1 = "Hi";&#13;
let nr3 = 3;&#13;
let result1 = nr1 * nr2;&#13;
let result2 = str1 * nr3;&#13;
console.log(result1, result2);&#13;
</code></pre>&#13;
    <p class="normal">Output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">150 NaN&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-63" class="title">Division</h3>&#13;
    <p class="normal">Another straightforward <a id="_idIndexMarker089"/>operator is division. We can divide <a id="_idIndexMarker090"/>two numbers with the <code class="Code-In-Text--PACKT-">/</code> character:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 30;&#13;
let nr2 = 5;&#13;
let result1 = nr1 / nr2;&#13;
console.log(result1);&#13;
</code></pre>&#13;
    <p class="normal">The output is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">6&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-64" class="title">Exponentiation</h3>&#13;
    <p class="normal">Exponentiation means raising a certain base number to the power of the exponent, for example, <em class="italic">x</em><sup class="" style="font-style: italic;">y</sup>. This can <a id="_idIndexMarker091"/>be read as <em class="italic">x</em> to the power of <em class="italic">y</em>. It means that we will multiply <em class="italic">x</em> by itself <em class="italic">y</em> number of times. Here is <a id="_idIndexMarker092"/>an example of how to do this in JavaScript—we use <code class="Code-In-Text--PACKT-">**</code> for this operator:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 2;&#13;
let nr2 = 3;&#13;
let result1 = nr1 ** nr2;&#13;
console.log(result1);&#13;
</code></pre>&#13;
    <p class="normal">We get the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">8&#13;
</code></pre>&#13;
    <p class="normal">The result of this operation is 2 to the power of 3 (2 * 2 * 2), which is <code class="Code-In-Text--PACKT-">8</code>. We're going to avoid going into a mathematics lesson here, but we can also find the root of a number by using fractional exponents: for example, the square root of a value is the same as raising it to the power of 0.5.</p>&#13;
    <h3 id="_idParaDest-65" class="title">Modulus</h3>&#13;
    <p class="normal">This is one that often requires a little explanation. Modulus is the operation in which you determine how much <a id="_idIndexMarker093"/>is left after dividing a number by another number in its entirety. The amount of times the number can fit in the other number <a id="_idIndexMarker094"/>does not matter here. The outcome will be the remainder, or what is left over. The character we use for this operation is the <code class="Code-In-Text--PACKT-">%</code> character. Here are some examples:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 10;&#13;
let nr2 = 3;&#13;
let result1 = nr1 % nr2;&#13;
console.log(`${nr1} % ${nr2} = ${result1}`);&#13;
 &#13;
let nr3 = 8;&#13;
let nr4 = 2;&#13;
let result2 = nr3 % nr4;&#13;
console.log(`${nr3} % ${nr4} = ${result2}`);&#13;
 &#13;
let nr5 = 15;&#13;
let nr6 = 4;&#13;
let result3 = nr5 % nr6;&#13;
console.log(`${nr5} % ${nr6} = ${result3}`);&#13;
</code></pre>&#13;
    <p class="normal">And the output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">10 % 3 = 1&#13;
8 % 2 = 0&#13;
15 % 4 = 3&#13;
</code></pre>&#13;
    <p class="normal">The first one is <code class="Code-In-Text--PACKT-">10 % 3</code>, where 3 fits 3 times into 10, and then 1 is left. The second one is <code class="Code-In-Text--PACKT-">8 % 2</code>. This results in 0, because 2 can fit 4 times into 8 without having anything left. The last one is <code class="Code-In-Text--PACKT-">15 % 4</code>, where 4 fits 3 times into 15. And then we have 3 left as a result.</p>&#13;
    <p class="normal">This is something <a id="_idIndexMarker095"/>that would happen in your head automatically if I asked you to add 125 minutes to the current time. You will probably do two things: integer <a id="_idIndexMarker096"/>division to determine how many whole hours fit into 125 minutes, and then 125 modulo 60 (in JavaScript terms, <code class="Code-In-Text--PACKT-">125 % 60</code>) to conclude that you'll have to add 5 more minutes to the current time. Say our current time is 09:59, you will probably start by adding 2 hours, and get to 11:59, and then add 5 minutes, and then you will perform another modulus operation with 59 and 5, adding 1 more hour to the total and having 4 minutes left: 12:04.</p>&#13;
    <h3 id="_idParaDest-66" class="title">Unary operators: increment and decrement</h3>&#13;
    <p class="normal">The last two operators <a id="_idIndexMarker097"/>of our arithmetic operator section are probably new to you, if you are new to <a id="_idIndexMarker098"/>programming (or only familiar with another programming language). These are the increment and decrement operators. A term we use <a id="_idIndexMarker099"/>here is <strong class="keyword">operand</strong>. Operands are <a id="_idIndexMarker100"/>subject to the operator. So, if we say <code class="Code-In-Text--PACKT-">x + y</code>, <em class="italic">x</em> and <em class="italic">y</em> are operands.</p>&#13;
    <p class="normal">We only need <a id="_idIndexMarker101"/>one operand for these operators, and therefore we also call them unary operators. If we see <code class="Code-In-Text--PACKT-">x++</code>, we can read this as <em class="italic">x</em> = <em class="italic">x</em> + 1. The same is true for the decrement operators: <code class="Code-In-Text--PACKT-">x--</code> can be read as <em class="italic">x</em> = <em class="italic">x</em> – 1:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 4;&#13;
nr1++;&#13;
console.log(nr1);&#13;
let nr2 = 4;&#13;
nr2--;&#13;
console.log(nr2);&#13;
</code></pre>&#13;
    <p class="normal">The output is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">5&#13;
3&#13;
</code></pre>&#13;
    <h4 class="title">Prefix and postfix operators </h4>&#13;
    <p class="normal">We can have the increment operator after the operand (<code class="Code-In-Text--PACKT-">x++</code>), in which case we call this the <strong class="keyword">postfix unary operator</strong>. We can also have it before <code class="Code-In-Text--PACKT-">(++x</code>), which is the <strong class="keyword">prefix unary operator</strong>. This does <a id="_idIndexMarker102"/>something different though—the next few lines might be complicated, so do not worry if you need to read it a few times and have a good <a id="_idIndexMarker103"/>look at the examples here.</p>&#13;
    <p class="normal">The postfix gets executed after sending the variable through, and then after that, the operation gets executed. In the following example, <code class="Code-In-Text--PACKT-">nr</code> gets incremented by 1 <em class="italic">after</em> logging. So the first logging statement is still logging the old value because it has not been updated yet. It has been updated for the second log statement:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr = 2;&#13;
console.log(nr++);&#13;
console.log(nr);&#13;
</code></pre>&#13;
    <p class="normal">The output is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">2&#13;
3&#13;
</code></pre>&#13;
    <p class="normal">The prefix gets executed <em class="italic">before</em> sending the variable through, and often this is the one you will need. Have a look at the following example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr = 2;&#13;
console.log(++nr);&#13;
</code></pre>&#13;
    <p class="normal">We get the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">3&#13;
</code></pre>&#13;
    <p class="normal">Alright, if you can figure out what the next code snippets logs to the console, you should really have a handle on it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let nr1 = 4;&#13;
let nr2 = 5;&#13;
let nr3 = 2;&#13;
console.log(nr1++ + ++nr2 * nr3++);&#13;
</code></pre>&#13;
    <p class="normal">It outputs <code class="Code-In-Text--PACKT-">16</code>. It will do the multiplication first, according to the basic mathematical order of operations. For <a id="_idIndexMarker104"/>multiplying, it uses 6 (prefix, so 5 is incremented before multiplying) and 2 (postfix, so 2 is only incremented after execution, meaning <a id="_idIndexMarker105"/>it won't affect our current calculation). This comes down to 12. And then <code class="Code-In-Text--PACKT-">nr1 </code>is a postfix operator, so this one will execute after the addition. Therefore, it will add 12 to 4 and become 16.</p>&#13;
    <h3 id="_idParaDest-67" class="title">Combining the operators</h3>&#13;
    <p class="normal">These operators can be combined, and it works just as it does in math. They get executed in a certain order, and not necessarily from left to right. This is due to a phenomenon called operator precedence. </p>&#13;
    <p class="normal">There is one more thing to take into account here, and that is <a id="_idIndexMarker106"/>grouping. You can group using <code class="Code-In-Text--PACKT-">(</code> and <code class="Code-In-Text--PACKT-">)</code>. The operations between the parentheses have the highest precedence. After that, the order of the operations takes place based on the type of operation (highest precedence first) and if they are of equal precedence, they take place from left to right:</p>&#13;
    <table id="table001" class="No-Table-Style _idGenTablePara-1">&#13;
      <colgroup>&#13;
        <col/>&#13;
        <col/>&#13;
        <col/>&#13;
      </colgroup>&#13;
      <tbody>&#13;
        <tr class="No-Table-Style">&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Heading--PACKT-">Name</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Heading--PACKT-">Symbol</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Heading--PACKT-">Example</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr class="No-Table-Style">&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-">Grouping</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">(...)</code></p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">(x + y)</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr class="No-Table-Style">&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-">Exponentiation</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">**</code></p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">x ** y</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr class="No-Table-Style">&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-">Prefix increment and decrement</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">--</code>,<code class="Code-In-Text--PACKT-"> ++</code></p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">--x</code>, <code class="Code-In-Text--PACKT-">++y</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr class="No-Table-Style">&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-">Multiplication, division, modulus</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">*</code>, <code class="Code-In-Text--PACKT-">/</code>,<code class="Code-In-Text--PACKT-"> %</code></p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">x * y</code>, <code class="Code-In-Text--PACKT-">x / y</code>, <code class="Code-In-Text--PACKT-">x % y</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr class="No-Table-Style">&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-">Addition and subtraction</p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">+</code>,<code class="Code-In-Text--PACKT-"> -</code></p>&#13;
          </td>&#13;
          <td class="No-Table-Style">&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">x + y</code>, <code class="Code-In-Text--PACKT-">x - y</code></p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <h3 id="_idParaDest-68" class="title">Practice exercise 2.3</h3>&#13;
    <p class="normal">Write some code to calculate the hypotenuse of a triangle using the Pythagorean theorem when given the values of the other two sides. The theorem specifies that the relation between the sides of a right-angled triangle is a<sup class="Superscript--PACKT-">2</sup> + b<sup class="Superscript--PACKT-">2</sup> = c<sup class="Superscript--PACKT-">2</sup>.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">The Pythagorean theorem only applies to right-angled triangles. The sides connected to the 90-degree angle are called the adjacent and opposite sides, represented by a and b in the formula. The longest side, not connected to the 90-degree angle, is called the hypotenuse, represented by c. </p>&#13;
    </p>&#13;
    <p class="normal">You can use <code class="Code-In-Text--PACKT-">prompt()</code> to get the value for a and b. Write code to get the value from the user for <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code>. Then square the values of both <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code> before adding them together and finding the square root. Print your answer to the console.</p>&#13;
    <h2 id="_idParaDest-69" class="title">Assignment operators</h2>&#13;
    <p class="normal">We have <a id="_idIndexMarker107"/>seen one assignment operator already when we were assigning values to variables. The character for this basic assignment operation is <code class="Code-In-Text--PACKT-">=</code>. There are a few others available. Every binary <a id="_idIndexMarker108"/>arithmetic operator has a corresponding assignment operator to write a shorter piece of code. For example, <em class="italic">x</em> += 5 means <em class="italic">x</em> = <em class="italic">x</em> + 5, and <em class="italic">x</em> **= 3 means <em class="italic">x</em> = <em class="italic">x</em> ** 3 (x to the power of 3).</p>&#13;
    <p class="normal">In this first example we declare a variable <code class="Code-In-Text--PACKT-">x</code>, and set it to <code class="Code-In-Text--PACKT-">2</code> as an initial value:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = 2;&#13;
x += 2;&#13;
</code></pre>&#13;
    <p class="normal">After this assignment operation, the value of <code class="Code-In-Text--PACKT-">x</code> becomes 4, because <em class="italic">x</em> += 2 is the same as <em class="italic">x</em> = <em class="italic">x</em> + 2:</p>&#13;
    <p class="normal">In the next assignment operation, we will subtract <code class="Code-In-Text--PACKT-">2</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">x -= 2;&#13;
</code></pre>&#13;
    <p class="normal">So, after this operation the value of <code class="Code-In-Text--PACKT-">x</code> becomes <code class="Code-In-Text--PACKT-">2</code> again (<em class="italic">x</em> = <em class="italic">x</em> – 2). In the next operation, we are going to multiply the value by 6:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">x *= 6;&#13;
</code></pre>&#13;
    <p class="normal">When this line has been executed, the value of <code class="Code-In-Text--PACKT-">x</code> is no longer 2, but becomes 12 (<em class="italic">x</em> = <em class="italic">x</em> * 6). In the next line, we are going to use an assignment operator to perform a division:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">x /= 3;&#13;
</code></pre>&#13;
    <p class="normal">After dividing <code class="Code-In-Text--PACKT-">x</code> by <code class="Code-In-Text--PACKT-">3</code>, the <a id="_idIndexMarker109"/>new value becomes 4. The next assignment operator we will use is exponentiation: </p>&#13;
    <pre class="programlisting code"><code class="hljs-code">x **= 2;&#13;
</code></pre>&#13;
    <p class="normal">The value of <code class="Code-In-Text--PACKT-">x</code> becomes 16, because the old value was 4, and 4 to the power of 2 equals 16 (4 * 4). The last <a id="_idIndexMarker110"/>assignment operator we will talk about is the modulus assignment operator:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">x %= 3;&#13;
</code></pre>&#13;
    <p class="normal">After this assignment operation, the value of <code class="Code-In-Text--PACKT-">x</code> is 1, because 3 can fit 5 times into 16 and then leaves 1.</p>&#13;
    <h3 id="_idParaDest-70" class="title">Practice exercise 2.4</h3>&#13;
    <p class="normal">Create variables for three numbers: <em class="italic">a</em>, <em class="italic">b</em>, and <em class="italic">c</em>. Update these variables with the following actions using the assignment operators:</p>&#13;
    <ul>&#13;
      <li class="bullet">Add <em class="italic">b</em> to <em class="italic">a</em></li>&#13;
      <li class="bullet">Divide <em class="italic">a</em> by <em class="italic">c</em></li>&#13;
      <li class="bullet">Replace the value of c with the modulus of <em class="italic">c</em> and <em class="italic">b</em></li>&#13;
      <li class="bullet">Print all three numbers to the console</li>&#13;
    </ul>&#13;
    <h2 id="_idParaDest-71" class="title">Comparison operators</h2>&#13;
    <p class="normal">Comparison operators <a id="_idIndexMarker111"/>are different from the operators we have seen so far. The <a id="_idIndexMarker112"/>outcome of the comparison operators is always a Boolean, true, or false. </p>&#13;
    <h3 id="_idParaDest-72" class="title">Equal</h3>&#13;
    <p class="normal">There are a few <a id="_idIndexMarker113"/>equality operators that determine whether two values are <a id="_idIndexMarker114"/>equal. They come in two flavors: equal value only, or equal value and data type. The first one returns true when the values are equal, even though the type is different, while the second returns true only when the value and the type are the same:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = 5;&#13;
let y = "5";&#13;
console.log(x == y);&#13;
</code></pre>&#13;
    <p class="normal">The double equals operator, two equal signs, means that it will only check for equal value and not <a id="_idIndexMarker115"/>for data type. Both have the value <code class="Code-In-Text--PACKT-">5</code>, so it will log <code class="Code-In-Text--PACKT-">true</code> to the <a id="_idIndexMarker116"/>console. This type of equality is sometimes called loose equality.</p>&#13;
    <p class="normal">The triple equals operator, written as three equal signs, means that it will evaluate both the value and the data type to determine whether both sides are equal or not. They both need to be equal in order for this statement to be true, but they are not and therefore the following statement outputs <code class="Code-In-Text--PACKT-">false</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x === y);&#13;
</code></pre>&#13;
    <p class="normal">This is sometimes also called strict equality. This triple equals operator is the one you should most commonly be using when you need to check for equality, as only with this one can you be sure that both variables are really equal.</p>&#13;
    <h3 id="_idParaDest-73" class="title">Not equal</h3>&#13;
    <p class="normal">Not equal is very similar to equal, except it does the opposite—it returns true when two variables are not equal, and <a id="_idIndexMarker117"/>false when they are equal. We use the exclamation mark for not equal:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = 5;&#13;
let y = "5";&#13;
console.log(x != y);&#13;
</code></pre>&#13;
    <p class="normal">This will log <code class="Code-In-Text--PACKT-">false </code>to the console. If you are wondering what is going on here, take a look again at the double and triple <a id="_idIndexMarker118"/>equals operators, because it is the same here. However, when there is only one equals sign in a not-equal operator, it is comparing loosely for non-equality. Therefore, it concludes that they are equal and therefore not equal should result in false. The one with two equals signs is checking for strict non-equality:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x !== y);&#13;
</code></pre>&#13;
    <p class="normal">This will conclude that since <code class="Code-In-Text--PACKT-">x </code>and <code class="Code-In-Text--PACKT-">y </code>have different data types, they are not the same, and will log <code class="Code-In-Text--PACKT-">true</code> to the console.</p>&#13;
    <h3 id="_idParaDest-74" class="title">Greater than and smaller than</h3>&#13;
    <p class="normal">The greater than <a id="_idIndexMarker119"/>operator returns true if the left-hand side is greater than the right-hand side of the operation. We use the <code class="Code-In-Text--PACKT-">&gt; </code>character for this. We also have a greater than or<a id="_idIndexMarker120"/> equal to operator, <code class="Code-In-Text--PACKT-">&gt;=</code>, which returns <code class="Code-In-Text--PACKT-">true</code> if the left-hand side is greater than or equal to the right-hand side. </p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = 5;&#13;
let y = 6;&#13;
console.log(y &gt; x); &#13;
</code></pre>&#13;
    <p class="normal">This one will log <code class="Code-In-Text--PACKT-">true</code>, because <code class="Code-In-Text--PACKT-">y</code> is greater than <code class="Code-In-Text--PACKT-">x</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x &gt; y);&#13;
</code></pre>&#13;
    <p class="normal">Since <code class="Code-In-Text--PACKT-">x</code> is not greater than <code class="Code-In-Text--PACKT-">y</code>, this one will log <code class="Code-In-Text--PACKT-">false</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(y &gt; y);&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">y</code> is not greater than <code class="Code-In-Text--PACKT-">y</code>, so this one will log <code class="Code-In-Text--PACKT-">false</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(y &gt;= y);&#13;
</code></pre>&#13;
    <p class="normal">This last one is looking at whether <code class="Code-In-Text--PACKT-">y</code> is greater than or equal to <code class="Code-In-Text--PACKT-">y</code>, and since it is equal to itself, it will log <code class="Code-In-Text--PACKT-">true</code>.</p>&#13;
    <p class="normal">It might not surprise you that we<a id="_idIndexMarker121"/> also have smaller than (<code class="Code-In-Text--PACKT-">&lt;</code>) and smaller than or equal to operators (<code class="Code-In-Text--PACKT-">&lt;=</code>). Let's have <a id="_idIndexMarker122"/>a look at the smaller than operator, as it is very similar to the previous ones.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(y &lt; x); &#13;
</code></pre>&#13;
    <p class="normal">This first one will be <code class="Code-In-Text--PACKT-">false</code>, since <code class="Code-In-Text--PACKT-">y</code> is not smaller than <code class="Code-In-Text--PACKT-">x</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x &lt; y);&#13;
</code></pre>&#13;
    <p class="normal">So, this second one will log <code class="Code-In-Text--PACKT-">true</code>, because <code class="Code-In-Text--PACKT-">x</code> is smaller than <code class="Code-In-Text--PACKT-">y</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(y &lt; y);&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">y</code> is not smaller than <code class="Code-In-Text--PACKT-">y</code>, so this one will log <code class="Code-In-Text--PACKT-">false</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(y &lt;= y);&#13;
</code></pre>&#13;
    <p class="normal">This last one looks at whether <code class="Code-In-Text--PACKT-">y</code> is smaller than or equal to <code class="Code-In-Text--PACKT-">y</code>. It is equal to <code class="Code-In-Text--PACKT-">y</code>, so it will log <code class="Code-In-Text--PACKT-">true</code>.</p>&#13;
    <h2 id="_idParaDest-75" class="title">Logical operators</h2>&#13;
    <p class="normal">Whenever you want<a id="_idIndexMarker123"/> to check two conditions in one, or you need to negate a condition, the logical operators come <a id="_idIndexMarker124"/>in handy. You can use and, or, and not. </p>&#13;
    <h3 id="_idParaDest-76" class="title">And</h3>&#13;
    <p class="normal">The first one we <a id="_idIndexMarker125"/>will have a look at is and. If you want to check whether <code class="Code-In-Text--PACKT-">x</code> is<a id="_idIndexMarker126"/> greater than <code class="Code-In-Text--PACKT-">y</code> and <code class="Code-In-Text--PACKT-">y</code> is greater than <code class="Code-In-Text--PACKT-">z</code>, you would need to be able to combine two expressions. This can be done with the <code class="Code-In-Text--PACKT-">&amp;&amp;</code> operator. It will only return <code class="Code-In-Text--PACKT-">true</code> if both expressions are true:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = 1;&#13;
let y = 2;&#13;
let z = 3;&#13;
</code></pre>&#13;
    <p class="normal">With these variables in mind, we are going to have a look at the logical operators:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x &lt; y &amp;&amp; y &lt; z);&#13;
</code></pre>&#13;
    <p class="normal">This will log <code class="Code-In-Text--PACKT-">true</code>, you can read it like this: if <code class="Code-In-Text--PACKT-">x</code> is smaller than <code class="Code-In-Text--PACKT-">y</code> and y is smaller than <code class="Code-In-Text--PACKT-">z</code>, it will log <code class="Code-In-Text--PACKT-">true</code>. That is the case, so it will log <code class="Code-In-Text--PACKT-">true</code>. The next example will log <code class="Code-In-Text--PACKT-">false</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x &gt; y &amp;&amp; y &lt; z);&#13;
</code></pre>&#13;
    <p class="normal">Since <code class="Code-In-Text--PACKT-">x</code> is not greater than <code class="Code-In-Text--PACKT-">y</code>, one part of the expression is not true, and therefore it will result in <code class="Code-In-Text--PACKT-">false</code>.</p>&#13;
    <h3 id="_idParaDest-77" class="title">Or</h3>&#13;
    <p class="normal">If you want to get true if either one of the expressions is true, you use or. The operator for this is <code class="Code-In-Text--PACKT-">||</code>. These pipes <a id="_idIndexMarker127"/>are used to see if either one of these two is true, in which <a id="_idIndexMarker128"/>case the whole expression evaluates to <code class="Code-In-Text--PACKT-">true</code>. Let's have a look at the or operator in action:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x &gt; y || y &lt; z);&#13;
</code></pre>&#13;
    <p class="normal">This will result in <code class="Code-In-Text--PACKT-">true</code>, whereas it was <code class="Code-In-Text--PACKT-">false</code> with <code class="Code-In-Text--PACKT-">&amp;&amp;.</code> This is because only one of the two sides needs to be true in order for the whole expression to evaluate to <code class="Code-In-Text--PACKT-">true</code>. This is the case because <code class="Code-In-Text--PACKT-">y</code> is smaller than <code class="Code-In-Text--PACKT-">z</code>.</p>&#13;
    <p class="normal">When both sides are false, it will log <code class="Code-In-Text--PACKT-">false</code>, which is the case in the next example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(x &gt; y || y &gt; z);&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-78" class="title">Not</h3>&#13;
    <p class="normal">In some cases you will<a id="_idIndexMarker129"/> have to<a id="_idIndexMarker130"/> negate a Boolean. This will make it the opposite value. It can be done with the exclamation mark, which reads as not:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = false;&#13;
console.log(!x);&#13;
</code></pre>&#13;
    <p class="normal">This will log true, since it will simply flip the value of the Boolean. You can also negate an expression that evaluates to a Boolean, but you would have to make sure that the expression gets evaluated first by grouping it.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let x = 1;&#13;
let y = 2;&#13;
console.log(!(x &lt; y));&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">x</code> is smaller than <code class="Code-In-Text--PACKT-">y</code>, so the expression evaluates to <code class="Code-In-Text--PACKT-">true</code>. But, it gets negated due to the exclamation mark and prints <code class="Code-In-Text--PACKT-">false</code> to the console.</p>&#13;
    <h1 id="_idParaDest-79" class="title">Chapter project</h1>&#13;
    <h2 id="_idParaDest-80" class="title">Miles-to-kilometers converter</h2>&#13;
    <p class="normal">Create a variable that contains a value in miles, convert it to kilometers, and log the value in kilometers in the following format: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con">The distance of 130 kms is equal to 209.2142 miles&#13;
</code></pre>&#13;
    <p class="normal">For reference, 1 mile equals 1.60934 kilometers.</p>&#13;
    <h2 id="_idParaDest-81" class="title">BMI calculator</h2>&#13;
    <p class="normal">Set values for height in inches and weight in pounds, then convert the values to centimeters and kilos, outputting the results to the console:</p>&#13;
    <ul>&#13;
      <li class="bullet">1 inch is equal to 2.54 cm</li>&#13;
      <li class="bullet">2.2046 pounds is equal to 1 kilo</li>&#13;
    </ul>&#13;
    <p class="normal">Output the results. Then, calculate and log the BMI: this is equal to weight (in kilos) divided by squared height (in meters). Output the results to the console.</p>&#13;
    <h1 id="_idParaDest-82" class="title">Self-check quiz</h1>&#13;
    <ol>&#13;
      <li class="numbered">What data type is the following variable?&#13;
        <pre class="programlisting code"><code class="hljs-code">const c = "5";&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What data type is the following variable?&#13;
        <pre class="programlisting code"><code class="hljs-code">const c = 91;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Which one is generally better, line 1 or line 2?&#13;
        <pre class="programlisting code"><code class="hljs-code">let empty1 = undefined; //line 1&#13;
let empty2 = null; //line 2&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What is the console output for the following?&#13;
        <pre class="programlisting code"><code class="hljs-code">let a = "Hello";&#13;
a = "world";&#13;
console.log(a);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What will be logged to the console?&#13;
        <pre class="programlisting code"><code class="hljs-code">let a = "world";&#13;
let b = `Hello ${a}!`;&#13;
console.log(b);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What is the value of <code class="Code-In-Text--PACKT-">a</code>?&#13;
        <pre class="programlisting code"><code class="hljs-code">let a = "Hello";&#13;
a = prompt("world");&#13;
console.log(a);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What is the value of <code class="Code-In-Text--PACKT-">b</code> output to the console?&#13;
        <pre class="programlisting code"><code class="hljs-code">let a = 5;&#13;
let b = 70;&#13;
let c = "5";&#13;
b++;&#13;
console.log(b);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What is the value of <code class="Code-In-Text--PACKT-">result</code>?&#13;
        <pre class="programlisting code"><code class="hljs-code">let result = 3 + 4 * 2 / 8; &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What is the value of <code class="Code-In-Text--PACKT-">total</code> and <code class="Code-In-Text--PACKT-">total2</code>?&#13;
        <pre class="programlisting code"><code class="hljs-code">let firstNum = 5;&#13;
let secondNum = 10;&#13;
firstNum++;&#13;
secondNum--;&#13;
let total = ++firstNum + secondNum;&#13;
console.log(total);&#13;
let total2 = 500 + 100 / 5 + total--;&#13;
console.log(total2);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What is logged to the console here?&#13;
        <pre class="programlisting code"><code class="hljs-code">const a = 5;&#13;
const b = 10;&#13;
console.log(a &gt; 0 &amp;&amp; b &gt; 0); &#13;
console.log(a == 5 &amp;&amp; b == 4); &#13;
console.log(true ||false); &#13;
console.log(a == 3 || b == 10); &#13;
console.log(a == 3 || b == 7); &#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-83" class="title">Summary</h1>&#13;
    <p class="normal">In this chapter, we dealt with the first two programming building blocks: variables and operators. Variables are special fields that have a name and contain values. We declare a variable by using one of the special variable-defining words: <code class="Code-In-Text--PACKT-">let</code>, <code class="Code-In-Text--PACKT-">var</code>, or <code class="Code-In-Text--PACKT-">const</code>. Variables enable us to make our scripts dynamic, store values, access them later, and change them later. We discussed some primitive data types, including strings, numbers, Booleans, and Symbols, as well as more abstract types such as undefined and null. You learned how to determine the type of a variable using the <code class="Code-In-Text--PACKT-">typeof </code>word. And you saw how you can convert the data type by using the built-in JavaScript methods <code class="Code-In-Text--PACKT-">Number()</code>, <code class="Code-In-Text--PACKT-">String()</code>, and <code class="Code-In-Text--PACKT-">Boolean()</code>.</p>&#13;
    <p class="normal">Then we moved on and discussed operators. Operators enable us to work with our variables. They can be used to perform calculations, compare variables, and more. The operators we discussed included arithmetic operators, assignment operators, comparison operators, and logical operators. </p>&#13;
    <p class="normal">After this chapter, you are ready to deal with more complex data types, such as arrays and objects. We'll cover these in the next chapter.</p>&#13;
  </div>&#13;
</div></body></html>