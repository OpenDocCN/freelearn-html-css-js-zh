- en: Chapter 5. Monitoring Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 监控应用程序
- en: Distributed systems fail often. Worse, they often fail partially. When failures
    occur during operations responsible for altering a system's state (for instance,
    a write or delete operation), how can the correct state be recovered, especially
    when these operations are concurrent? To make matters even worse, some operations
    fail silently. Partial failures, then, can put applications in an indeterminate
    state. It is difficult to predict how an opaque system will behave.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统经常出现故障。更糟糕的是，它们经常部分故障。当操作发生故障，负责改变系统状态（例如，写入或删除操作）时，如何恢复正确的状态，尤其是当这些操作是并发时？更糟糕的是，一些操作会静默失败。因此，部分故障可能会使应用程序处于不确定的状态。预测一个不透明的系统将如何表现是困难的。
- en: 'Consider this quote from *The Datacenter as a Computer: An Introduction to
    the Design of Warehouse-Scale Machines*:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自《数据中心作为计算机：仓库规模机器设计导论》的引言：
- en: '*"Suppose a cluster has ultra-reliable server nodes with a stellar mean time
    between failures (MTBF) of 30 years (10,000 days)—well beyond what is typically
    possible to achieve at a realistic cost. Even with these ideally reliable servers,
    a cluster of 10,000 servers will see an average of one server failure per day.
    Thus, any application that needs the entire cluster to be up to work will see
    an MTBF of no better than 1 day."*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"假设一个集群拥有超可靠的服务器节点，其平均故障间隔时间（MTBF）为30年（10,000天）——远远超出在现实成本下通常能够实现的范围。即使有这些理想化的可靠服务器，一个由10,000个服务器组成的集群每天平均仍会看到一台服务器故障。因此，任何需要整个集群正常运行的应用程序，其MTBF都不会超过1天。"*'
- en: Failure, especially on a large scale, is indifferent to the quality of your
    staff or your hardware. The point is that numerical ratios that seem large in
    common usage are less so in network environments where billions of transactions
    can happen in a matter of minutes or seconds and where hundreds or more separate
    systems are interacting. How failure evolves is often counterintuitive. It is
    a good idea, then, to prepare for failure, and, among other things, this means
    reducing the ability of any one failure to take down an entire system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 失败，尤其是在大规模上，对员工的质量或硬件的质量都是无所谓的。关键在于，在常规使用中看似很大的数值，在网络环境中却相对较小，因为在几分钟或几秒钟内可能发生数十亿笔交易，并且数百或更多独立的系统正在交互。失败的演变往往是反直觉的。因此，为失败做好准备是个好主意，而且，在其他方面，这意味着减少任何单一失败导致整个系统崩溃的能力。
- en: Typically, distributing the workload for a single user also requires distributing
    user data across many independent processes. Also, when a piece of the system
    fails, it must be restored in order to maintain two characteristics of the system—its
    capacity and any data or transactions that were in flight when the failure occurred.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为单个用户分配工作负载也需要将用户数据分布到许多独立进程中。此外，当系统的一部分发生故障时，必须将其恢复，以保持系统的两个特性——其容量以及当故障发生时处于飞行中的任何数据或事务。
- en: 'In this chapter, I''ll outline certain tools and tricks used to monitor what
    is going on across your application. We''ll look at ways in which you can build
    your own monitoring and logging tools and discuss third-party tools. Along the
    way, you''ll learn about the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将概述一些用于监控应用程序中发生情况的工具和技巧。我们将探讨您可以构建自己的监控和日志记录工具的方法，并讨论第三方工具。在这个过程中，您将了解以下内容：
- en: Remotely controlling Node processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程控制Node进程
- en: Using New Relic to monitor servers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用New Relic监控服务器
- en: Catching errors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获错误
- en: Other options for tracking and logging activity in your application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中跟踪和记录活动的其他选项
- en: Dealing with failure
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理失败
- en: As we outlined in [Chapter 4](ch04.html "Chapter 4. Managing Memory and Space"),
    *Managing Memory and Space*, isolating operations and intelligently monitoring
    an applications help to minimize the chances of one failed subsystem taking down
    the larger system. In this section, we'll look at how to catch errors and exceptions
    within a Node program and how to gracefully shut down and/or restart a process
    that has become unstable individually and within clusters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](ch04.html "第4章. 管理内存和空间")中概述的，“管理内存和空间”，隔离操作和智能监控应用程序有助于最大限度地减少单个失败子系统导致更大系统崩溃的可能性。在本节中，我们将探讨如何在Node程序中捕获错误和异常，以及如何优雅地关闭和/或重启变得不稳定的过程，无论是单个进程还是集群中的进程。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following comprehensive article on handling errors with Node.js is recommended:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一篇关于使用Node.js处理错误的全面文章，推荐阅读：
- en: '[http://www.joyent.com/developers/node/design/errors](http://www.joyent.com/developers/node/design/errors)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.joyent.com/developers/node/design/errors](http://www.joyent.com/developers/node/design/errors)'
- en: Peppering a codebase with try/catch blocks and trying to anticipate all errors
    can become unmanageable and unwieldy. Additionally, what if an exception you didn't
    anticipate occurs? How do you *pick up where you left off*?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库中添加try/catch块并试图预测所有错误可能会变得难以管理且难以控制。此外，如果你没有预料到的异常发生了？你如何*继续你离开的地方*？
- en: Node does not yet have a good built-in way to handle uncaught critical exceptions.
    This is a weakness of the platform. An exception that is uncaught will continue
    to bubble up through the execution stack until it hits the event loop where, like
    a wrench in the gears of a machine, it will take down the entire process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node还没有一个很好的内置方式来处理未捕获的关键异常。这是该平台的一个弱点。一个未捕获的异常将继续在执行栈中冒泡，直到它击中事件循环，就像机器齿轮中的扳手，它将使整个进程崩溃。
- en: 'One option is to attach an `uncaughtException` handler to the process itself,
    as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将`uncaughtException`处理器附加到进程本身，以下代码展示了这一点：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While nothing that follows our exception code will execute, the timeout will
    still fire as the process managed to catch the exception, thus saving itself.
    However, this is a very clumsy way of handling exceptions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在异常代码之后的任何内容都不会执行，但超时仍然会触发，因为进程成功捕获了异常，从而拯救了自己。然而，这是一种处理异常非常笨拙的方式。
- en: The `domain` module makes a good attempt at fixing this hole in Node's design.
    We will discuss the domain module next as a better tool to handle exceptions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain`模块试图修复Node设计中这个漏洞。我们将接下来讨论域模块，作为一个更好的工具来处理异常。'
- en: The 'domain' module
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '''domain''模块'
- en: 'Error handling in asynchronous code is also difficult to trace:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步代码中的错误处理也难以追踪：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Which function caused the error? It is difficult to say. It is also difficult
    to intelligently insert exception management tools. It is difficult to know what
    to do next. Node's `domain` module attempts to help with this and other exception
    localization issues. In this way, code can be tested and errors can be handled
    with more precision.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个函数导致了错误？很难说。也很难智能地插入异常管理工具。很难知道下一步该做什么。Node的`domain`模块试图帮助解决这些问题和其他异常定位问题。这样，代码可以更精确地进行测试，错误可以更有效地处理。
- en: 'At its simplest, a **domain** sets up a context within which a function or
    other "chunk" of code can be run such that any errors occurring within that implicit
    domain binding will be routed to a specific domain error handler. Take the following
    code as an example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，一个**域**设置了一个上下文，在这个上下文中可以运行一个函数或其他“代码块”，使得在该隐式域绑定中发生的任何错误都会被路由到特定的域错误处理器。以下代码作为例子：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we establish a domain and execute code within that domain via the `run`
    command within the context of that domain. This enables us to intelligently catch
    those exceptions, implicitly binding all event emitters, timers, and other requests
    created within that context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个域，并通过该域上下文中的`run`命令在该域内执行代码。这使得我们能够智能地捕获那些异常，隐式绑定在该上下文中创建的所有事件发射器、计时器和其他请求。
- en: 'Sometimes, a method might be created elsewhere (not within the implicit context
    of a given `domain.run` function call) but is nevertheless best associated with
    an external domain. The `add` method exists for just such explicit binding, as
    shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个方法可能是在其他地方创建的（不是在给定的`domain.run`函数调用隐式上下文中），但仍然最好与外部域相关联。`add`方法就是为了这样的显式绑定而存在的，以下代码展示了这一点：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we see how a function that is not implicitly bound within the `run` context
    can still be added to that context explicitly. To remove an execution context
    from a domain, use `domain.remove`. An array of all timers, functions, and other
    emitters added explicitly or implicitly to a domain is accessible via `domain.members`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到一个未在`run`上下文中隐式绑定的函数仍然可以显式地添加到该上下文中。要从域中移除执行上下文，请使用`domain.remove`。所有显式或隐式添加到域中的计时器、函数和其他发射器的数组可以通过`domain.members`访问。
- en: 'In the same way that JavaScript''s `bind` method binds a function to a context,
    the `domain.bind` method similarly allows an independent function to be bound
    to a domain. This is shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JavaScript的`bind`方法将函数绑定到上下文一样，`domain.bind`方法同样允许将一个独立的函数绑定到域。以下代码展示了这一点：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we see how any function can be wrapped by a particular error domain *inline*,
    a feature especially useful to manage exceptions in callbacks. Error objects emitted
    from a domain have the following special properties
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到任何函数都可以通过特定的错误域*内联*包装，这是一个特别有用的功能，可以用来管理回调中的异常。从域发出的错误对象具有以下特殊属性
- en: '`error.domain`: This is the domain that handled the error.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error.domain`：这是处理错误的域。'
- en: '`error.domainEmitter`: If `EventEmitter` fires an `error` event within a domain,
    this will be flagged.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error.domainEmitter`：如果`EventEmitter`在某个域内触发一个`error`事件，这将被标记。'
- en: '`error.domainBound`: This is the callback that passed an error as its first
    argument.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error.domainBound`：这是将错误作为其第一个参数传递的回调。'
- en: '`error.domainThrown`: This is a Boolean indicating whether the error was thrown
    or not. For example, the following callback will pass an ENOENT error as its first
    argument, so `domainThrown` would be false:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error.domainThrown`：这是一个布尔值，表示错误是否被抛出。例如，以下回调将传递一个ENOENT错误作为其第一个参数，因此`domainThrown`将为false：'
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another method, `domain.intercept`, functions similarly to `domain.bind` but
    simplifies error handling in callbacks such that the developer will no longer
    need to repetitively check (or even set) the first argument of every callback,
    `cb(err, data)`, for errors. An example can be found in the `js/domainintercept.js`
    file in your code bundle.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，`domain.intercept`，与`domain.bind`功能相似，但简化了回调中的错误处理，使得开发者不再需要重复检查（甚至设置）每个回调的第一个参数`cb(err,
    data)`以查找错误。一个例子可以在你的代码包中的`js/domainintercept.js`文件中找到。
- en: 'You may also need to move between domains, entering and exiting them as needed.
    For this, we use the `domain.enter` and `domain.exit` methods. Assuming that we
    have set up two domains, `dom1` and `dom2`, the first emitting `domain 1 error`
    and the second `domain 2 error`, we can move between domain contexts, as shown
    here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要在域之间移动，根据需要进入和退出它们。为此，我们使用`domain.enter`和`domain.exit`方法。假设我们已经设置了两个域，`dom1`和`dom2`，第一个发出`domain
    1 error`，第二个发出`domain 2 error`，我们可以像下面这样在域上下文中移动：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Any number of `enter` and `exit` events can be used. Note that no changes are
    made to the domain objects themselves—`exit` does not close the domain or do any
    such thing. If a domain needs to be destroyed, you should use the `domain.dispose`
    method, which will also try to clean up any inflight domain I/O—aborting streams,
    clearing timers, ignoring callbacks, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任意数量的`enter`和`exit`事件。请注意，域对象本身没有发生变化——`exit`不会关闭域或执行任何此类操作。如果需要销毁域，你应该使用`domain.dispose`方法，这将尝试清理任何正在进行的域I/O——中断流、清除定时器、忽略回调等。
- en: Catching process errors
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获进程错误
- en: Process-oriented designs are common in Node.js applications, where independent
    processes communicate with each other through evented streams. Errors in these
    channels, and in the processes themselves, must be tracked. In this section, we'll
    look at how to track and how to properly throw errors related to process events.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以进程为导向的设计在Node.js应用程序中很常见，其中独立进程通过事件流相互通信。这些通道以及进程本身的错误必须被跟踪。在本节中，我们将探讨如何跟踪以及如何正确地抛出与进程事件相关的错误。
- en: We covered the `child_process` module in [Chapter 3](ch03.html "Chapter 3. Scaling
    Node"), *Scaling Node*. Here, we will go into a little more detail about how to
    handle errors in child processes and their parents.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。扩展Node")中介绍了`child_process`模块，*扩展Node*。在这里，我们将更详细地介绍如何处理子进程及其父进程中的错误。
- en: 'To spawn a Node program, use the `fork` method of the `child_process` module.
    This creates a new child process under the calling parent. Also, an IPC channel
    is automatically set up between the two processes, where the child calls `process.send`
    to send messages to its parent, and the parent can listen to `child.on(''message'')`.
    Create two files, the first named `parent.js` and the other named `child.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Node程序，请使用`child_process`模块的`fork`方法。这将创建一个在调用父进程下的新子进程。此外，两个进程之间将自动设置一个IPC通道，其中子进程调用`process.send`向其父进程发送消息，父进程可以监听`child.on('message')`。创建两个文件，第一个命名为`parent.js`，另一个命名为`child.js`：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The child process upon which fork has been used by the parent will increment
    and emit a value at a 1-second interval, which the parent will listen for and
    echo to your console. How do we catch an error in the child process from the parent
    process?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程使用`fork`创建的子进程将在每秒间隔增加并发出一个值，父进程将监听并回显到你的控制台。我们如何从父进程中捕获子进程的错误？
- en: 'Let''s cause an error in our child process by making it `throw`. Add the following
    line to `child.js`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在子进程中引发一个错误，通过使其`throw`。将以下行添加到`child.js`中：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the parent process again will result in an error, and the message we
    set will be displayed. Typically, the parent will want to act when a child dies—such
    as using `fork` on a new child or logging the error, or both. To catch child errors
    in the parent, add the following line to `parent.js`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行父进程将导致错误，并显示我们设置的消息。通常，父进程会在子进程死亡时采取行动——例如在新的子进程中使用`fork`或记录错误，或者两者都做。为了在父进程中捕获子进程错误，请将以下行添加到`parent.js`中：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running the parent script again will result in the following being displayed
    in addition to the original error:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行父脚本将导致除了原始错误外，还会显示以下内容：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first argument received is the exit code passed by the child process when
    it is terminated (if the parent had sent a kill signal, for example, `child.kill('SIGTERM')`,
    the second argument here would contain `'SIGTERM'`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的第一个参数是子进程在终止时传递的退出代码（如果父进程发送了终止信号，例如`child.kill('SIGTERM')`，这里的第二个参数将包含`'SIGTERM'`）。
- en: In addition to handling child errors from within a parent process, using the
    `Domain` module to catch and handle errors within the child process itself is
    recommended. In this way, you properly clean up after a child error and use `process.send()`
    to broadcast any additional error information to the parent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在父进程中处理子进程的错误之外，建议使用`Domain`模块来捕获和处理子进程本身内的错误。这样，你可以在子进程错误发生后正确地清理，并使用`process.send()`将任何额外的错误信息广播给父进程。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The exit codes that Node will return when a process exits abnormally can be
    found at [https://github.com/joyent/node/blob/master/doc/api/process.markdown#exit-codes](https://github.com/joyent/node/blob/master/doc/api/process.markdown#exit-codes).
    (Note that this is for Node 0.11.x—earlier versions always return exit code 8.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程异常退出时，Node将返回的退出代码可以在[https://github.com/joyent/node/blob/master/doc/api/process.markdown#exit-codes](https://github.com/joyent/node/blob/master/doc/api/process.markdown#exit-codes)找到。（注意，这是针对Node
    0.11.x的——更早的版本总是返回退出代码8。）
- en: 'A child process can also be created via `spawn`, which differs from `fork`
    in that it is not Node-specific; any OS process can be started by using `spawn`.
    For example, this is a roundabout way of executing the `ls` command; you should
    receive a directory listing when this runs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程也可以通过`spawn`创建，这与`fork`不同，因为它不是Node特定的；可以使用`spawn`启动任何操作系统进程。例如，这是执行`ls`命令的一种迂回方式；当你运行它时，你应该会收到目录列表：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note the differences from `fork`. The first argument is an OS command, and
    the second argument is an array of options passed to that command—the equivalent
    of `> ls -l`. Secondly, we do not have access to a custom IPC (as with `fork`—no
    `send` or `on(''message'')`), but we do have access to the standard process pipes:
    `stdin`, `stdout`, and `stderr`. Because pipes will default to speaking in buffers,
    we have set the desired encoding and simply display any data that the spawned
    process writes to `stdout`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与`fork`的不同之处。第一个参数是一个操作系统命令，第二个参数是传递给该命令的选项数组——相当于`> ls -l`。其次，我们没有访问自定义的IPC（与`fork`一样——没有`send`或`on('message')`），但我们确实可以访问标准进程管道：`stdin`、`stdout`和`stderr`。因为管道默认以缓冲区形式进行通信，所以我们设置了所需的编码，并简单地显示任何被启动进程写入`stdout`的数据。
- en: 'Another way to catch subprocess errors should be clear to you. Modify the preceding
    code with the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种捕获子进程错误的方法应该对你来说很清楚。使用以下代码修改前面的代码：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When this attempt to list the contents of a nonexistent directory is executed,
    you should see the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行列出不存在目录内容这一尝试时，你应该看到以下内容：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By listening on the `stderr` pipe, errors in child processes can be caught.
    We can also change the `stdio` settings such that errors are automatically logged
    to a file. Rather than catching the child output in the parent, we use `spawn`
    on the child using a customized `stdio` option, redirecting the child''s `stdout`
    directly to a file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过监听`stderr`管道，可以捕获子进程中的错误。我们还可以更改`stdio`设置，使错误自动记录到文件。而不是在父进程中捕获子输出，我们使用具有自定义`stdio`选项的`spawn`在子进程中，将子进程的`stdout`直接重定向到文件：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we'll go a little deeper into logging strategies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更深入地探讨日志记录策略。
- en: Logging
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: Why log data? One answer might be that the amount of activity data a modern
    application produces exceeds the capacity of any one person's analytical abilities.
    We can't react to that much information usefully in real time. It is, therefore,
    necessary to store, or log, the mass of details and use smart tools to slice and
    sort that data into forms that we humans can comprehend. We can look for patterns
    in the logs and perhaps find bottlenecks or even bugs in our application, helping
    us improve the design of our system. We can garner business intelligence from
    logs, discovering usage patterns that help us understand customer preferences
    or ones that can help us design new features or enhance existing ones.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要记录数据？一个可能的答案是，现代应用程序产生的活动数据量超出了任何一个人的分析能力。我们无法实时有效地处理这么多信息。因此，有必要存储或记录大量细节，并使用智能工具将数据切割和排序成我们人类可以理解的形式。我们可以在日志中寻找模式，也许可以找到应用程序中的瓶颈或甚至错误，帮助我们改进系统的设计。我们可以从日志中获得商业智能，发现有助于我们理解客户偏好的使用模式，或者有助于我们设计新功能或增强现有功能的模式。
- en: In what follows, I'll take you through some of the information available to
    all Node processes, how those might be logged using **UDP**, and how to use Morgan
    for simple request logging.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我将向您介绍所有 Node 进程可用的信息，这些信息如何使用 **UDP** 进行记录，以及如何使用 Morgan 进行简单的请求记录。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A popular open source project from the Etsy team for logging and statistical
    reporting is **StatsD** ([https://github.com/etsy/statsd](https://github.com/etsy/statsd)),
    for which there is a good Node client at [https://github.com/sivy/node-statsd](https://github.com/sivy/node-statsd).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Etsy 团队的一个流行的开源日志和统计报告项目是 **StatsD** ([https://github.com/etsy/statsd](https://github.com/etsy/statsd))，它有一个很好的
    Node 客户端在 [https://github.com/sivy/node-statsd](https://github.com/sivy/node-statsd)。
- en: Let's create a logging module that uses UDP. Detailed information on how UDP
    works was provided in [Chapter 3](ch03.html "Chapter 3. Scaling Node"), *Scaling
    Node*—go ahead and refresh your memory if necessary. The important concept to
    remember is that UDP achieves extremely high performance by making no guarantee
    that messages will arrive. Note that in 99 percent of cases, very few messages
    will drop, making UDP an excellent balance of speed and accuracy for applications
    that do not need perfect fidelity, such as logging applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用 UDP 的日志模块。关于 UDP 如何工作的详细信息可以在第 3 章（[ch03.html "第 3 章. 扩展 Node"]*Scaling
    Node*）中找到，如果需要的话，请刷新您的记忆。需要记住的重要概念是，UDP 通过不保证消息到达来实现极高的性能。请注意，在 99% 的情况下，消息丢失的情况非常少，这使得
    UDP 对于不需要完美保真度的应用程序（如日志应用程序）来说是一个速度和准确性的优秀平衡。
- en: Logging with UDP
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 UDP 进行日志记录
- en: The goal of our UDP logging module is to have a straightforward interface for
    any Node program to do logging. Also, we'll want to allow many independent processes
    to write to the same log file. The full code for this module can be found in the
    `udp/logger` folder of your code bundle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 UDP 日志模块的目标是为任何 Node 程序提供一个简单的日志接口。此外，我们希望允许许多独立进程写入同一日志文件。此模块的完整代码可以在您的代码包的
    `udp/logger` 文件夹中找到。
- en: 'Starting from the end, let''s go over the client code first before diving into
    the logger itself. All clients will send (at least) a log file path, optional
    information about the port or host, a few handler functions if necessary, and
    the system will just work:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从结尾开始，我们先来看一下客户端代码，然后再深入到日志记录器本身。所有客户端都将发送（至少）一个日志文件路径，可选的端口或主机信息，如果需要的话，一些处理函数，系统将正常工作：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see that our module starts a server on the port provided and is configured
    to notify the client of any errors as well as its ready state. By fleshing out
    the remaining code for `onReady`, we can also see the ways that we expect clients
    to hit the UDP logger:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的模块在提供的端口上启动了一个服务器，并配置为通知客户端任何错误以及其就绪状态。通过完善 `onReady` 的剩余代码，我们还可以看到我们期望客户端如何使用
    UDP 日志记录器：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The client will be able to either call the module's `log` function or send a
    UDP message directly. Also, we expect that it is possible to receive many messages.
    Besides, we expect that any number of processes could be logging to *the same
    file*, so we must deal with managing a flood of messages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可以选择调用模块的 `log` 函数或直接发送 UDP 消息。此外，我们预计可能会接收到许多消息。此外，我们预计任何数量的进程都可能将日志记录到 *同一文件*
    中，因此我们必须处理管理消息洪流的问题。
- en: 'The logging module is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 日志模块如下：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is all the code necessary to manage the setting up of a UDP server and
    our client interface. Note how the `log` function will either be called directly
    by a client or will be called via the `on('message')` handler of our UDP binding.
    This allows clients the flexibility of calling our logging server from any environment—using
    this module, using another language, using another server, without using this
    module, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理设置 UDP 服务器和我们的客户端接口所需的所有代码。注意 `log` 函数要么直接由客户端调用，要么通过我们的 UDP 绑定的 `on('message')`
    处理器调用。这允许客户端从任何环境中调用我们的日志服务器——使用此模块、使用另一种语言、使用另一个服务器、不使用此模块等。
- en: The last important bit is the management of backpressure in `log`. Because many
    independent sources may be hitting our log file, the write stream managing that
    resource could be at its high watermark (*full*) when we try to use `write`. When
    that happens, a call to `stream.write` will return `false`, which the caller should
    take as a signal to *stop sending data*. When that happens, we bind to the `drain`
    event (only once—see [http://nodejs.org/api/events.html#events_emitter_once_event_listener](http://nodejs.org/api/events.html#events_emitter_once_event_listener)),
    which is fired when the consumer (the write manager for our log file) is ready
    to accept more data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的问题是 `log` 中的背压管理。因为许多独立来源可能会访问我们的日志文件，当我们尝试使用 `write` 时，管理该资源的写入流可能已经达到其高水位（*满*）。当这种情况发生时，对
    `stream.write` 的调用将返回 `false`，调用者应将其视为停止发送数据的信号。当这种情况发生时，我们绑定到 `drain` 事件（仅一次——见
    [http://nodejs.org/api/events.html#events_emitter_once_event_listener](http://nodejs.org/api/events.html#events_emitter_once_event_listener)），该事件在消费者（我们的日志文件的写入管理器）准备好接受更多数据时触发。
- en: Logging with Morgan
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Morgan 记录日志
- en: '**Morgan** ([https://github.com/expressjs/morgan](https://github.com/expressjs/morgan))
    is an HTTP logger for the **Express** framework. If logging HTTP connection data
    for a server is all you need, it serves very well and is easy to use. We''ll close
    out this section with a few short examples using Express.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Morgan** ([https://github.com/expressjs/morgan](https://github.com/expressjs/morgan))
    是一个用于 **Express** 框架的 HTTP 记录器。如果你只需要为服务器记录 HTTP 连接数据，它非常适用且易于使用。我们将通过几个简短的 Express
    示例来结束本节。'
- en: 'The following is the most basic usage of Morgan:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最基本的 Morgan 使用方法：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code will create a server listening on port `8080` and will dump a log
    entry in Apache **Combined Log Format** ([httpd.apache.org/docs/1.3/logs.html#combined](http://httpd.apache.org/docs/1.3/logs.html#combined))
    to `stdout`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将创建一个监听端口 `8080` 的服务器，并将日志条目以 Apache **Combined Log Format** ([httpd.apache.org/docs/1.3/logs.html#combined](http://httpd.apache.org/docs/1.3/logs.html#combined))
    格式输出到 `stdout`：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to the format parameter, Morgan also accepts various options. For
    example, to stream log data to a file, use the `stream` option. For this example,
    replace the `app.use` declaration with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了格式参数外，Morgan 还接受各种选项。例如，要将日志数据流式传输到文件，请使用 `stream` 选项。对于此示例，将 `app.use` 声明替换为以下内容：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Log entries will now be written to `out.log`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 日志条目现在将被写入到 `out.log`。
- en: 'The combined argument reflects one of the built-in Morgan log formatters. These
    formatters are composed of tokenized strings, with several tokens available by
    default. For example, the combined formatter interpolates the following string:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 合并参数反映了 Morgan 内置的日志格式化器之一。这些格式化器由标记化的字符串组成，默认情况下有多个标记可用。例如，合并格式化器插入了以下字符串：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It should be clear how the preceding fully qualified output is generated via
    the given formatter with tokens mapping to the standard properties of the `ClientRequest`
    and `ClientResponse` objects managed by Node's `http` module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，前面的完全限定输出是通过给定的格式化器生成的，该格式化器将令牌映射到 Node 的 `http` 模块管理的 `ClientRequest`
    和 `ClientResponse` 对象的标准属性。
- en: 'Morgan logs data reflecting the states of the `ClientRequest` and `ClientResponse`
    objects. The `skip` option allows you to filter logging based on the state of
    these objects. By default, Morgan logs every request. To only log errors, you
    would add the following to your middleware definition:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 记录反映 `ClientRequest` 和 `ClientResponse` 对象状态的日志数据。`skip` 选项允许你根据这些对象的状态过滤日志。默认情况下，Morgan
    记录每个请求。要仅记录错误，你需要在你的中间件定义中添加以下内容：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also add new tokens. Here, we create one named `''cache''`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加新令牌。在这里，我们创建了一个名为 `'cache'` 的令牌：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This new token (and/or existing tokens) can be used in custom formatters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新令牌（和/或现有令牌）可以用于自定义格式化器：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Morgan is now initialized with a custom formatter that will write something
    like `cache-control is max-age=0` to your log.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 现在已初始化了一个自定义格式化器，它将像 `cache-control is max-age=0` 这样的内容写入到你的日志中。
- en: For more information on additional built-in formatters and other advanced options,
    visit the project page. Given its flexibility, Morgan can be customized to satisfy
    many logging needs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于其他内置格式化程序和其他高级选项的信息，请访问项目页面。由于其灵活性，Morgan 可以定制以满足许多日志需求。
- en: 'Other popular options are available for consideration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的选项可供考虑：
- en: '**Bunyan** ([https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan)):
    Bunyan is a simple but sufficiently powerful logging tool for most needs.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bunyan** ([https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan))：Bunyan
    是一个简单但足够强大的日志工具，适用于大多数需求。'
- en: '**Winston** ([https://github.com/flatiron/winston](https://github.com/flatiron/winston)):
    The key selling point of Winston is the number of logging transport plugins it
    supports—you can configure it to log to Redis, a file, or a third-party service,
    such as [loggly.com](http://loggly.com).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Winston** ([https://github.com/flatiron/winston](https://github.com/flatiron/winston))：Winston
    的关键卖点是其支持的日志传输插件数量——你可以配置它将日志记录到 Redis、文件或第三方服务，例如 [loggly.com](http://loggly.com)。'
- en: Modifying behavior in changing environments
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不断变化的环境中修改行为
- en: Modifying application data in a running system has been compared to changing
    the engine of a jet while it is in flight. Luckily, we developers work in a virtual
    world where the *laws of physics* are more forgiving. In this section, we will
    learn how to create a *remote control* for your Node applications using examples
    demonstrating how to monitor processes remotely.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行中的系统中修改应用程序数据，这被比作在飞机飞行中更换引擎。幸运的是，我们开发者在一个虚拟世界中工作，这里的 *物理定律* 更为宽容。在本节中，我们将通过示例学习如何使用
    Node 应用程序的远程监控方法来创建一个 *遥控器*。
- en: Node REPL
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node REPL
- en: 'Node''s **Read-Eval-Print-Loop** (**REPL**) represents the Node shell. To enter
    the shell prompt, enter Node via your terminal without passing a filename:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 **Read-Eval-Print-Loop**（**REPL**）代表了 Node 壳。要进入壳提示符，请在终端中输入 Node，而不传递文件名：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You now have access to a running Node process and can pass JavaScript commands
    to this process. For example, after entering `2+2`, the shell would send `4` to
    `stdout`. Node's REPL is an excellent place to try out, debug, test, or otherwise
    play with JavaScript code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以访问一个正在运行的 Node 进程，并可以向该进程传递 JavaScript 命令。例如，在输入 `2+2` 之后，壳会向 `stdout`
    发送 `4`。Node 的 REPL 是尝试、调试、测试或以其他方式玩 JavaScript 代码的绝佳场所。
- en: 'Because REPL is a native object, programs can also use instances as a context
    in which to run JavaScript interactively. For example, here, we create our own
    custom function `sayHello`, add it to the context of an REPL instance, and start
    REPL, emulating a Node shell prompt:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 REPL 是一个原生对象，程序也可以使用实例作为运行 JavaScript 的上下文。例如，在这里，我们创建了自己的自定义函数 `sayHello`，将其添加到
    REPL 实例的上下文中，并启动 REPL，模拟 Node 壳提示符：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Entering `sayHello()` at the prompt will result in `Hello` being sent to `stdout`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符中输入 `sayHello()` 将导致 `Hello` 被发送到 `stdout`。
- en: What this also means is that your Node process can expose an REPL instance to
    the outside world that can access that process in some way, providing a *backdoor*
    through which you can connect to a process, modify its context, change its behavior,
    or even shut it down if it has gone bad in some way. Let's explore possible applications
    related to monitoring processes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你的 Node 进程可以对外界暴露一个 REPL 实例，该实例可以以某种方式访问该进程，提供一个 *后门*，通过它可以连接到进程，修改其上下文，改变其行为，或者如果它在某些方面出了问题，甚至可以将其关闭。让我们探讨与进程监控相关的可能应用。
- en: 'Create two files, `repl_client.js` and `repl_server.js`, using the following
    code, and run each in its own terminal window so that both terminal windows are
    visible to you:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建两个文件，`repl_client.js` 和 `repl_server.js`，并在各自的终端窗口中运行它们，以便你可以看到两个终端窗口：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `repl_client` file simply creates a new socket connection to port `8080`
    through `net.connect` and pipes any data coming from `stdin` (your terminal) through
    that socket. Similarly, any data arriving from the socket is piped to `stdout`
    (your terminal). It should be clear that we have created a way to take input and
    send it via a socket to port `8080`, listening for any data that the socket may
    send back to us. The following code shows this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`repl_client` 文件简单地通过 `net.connect` 创建一个新的套接字连接到端口 `8080`，并将来自 `stdin`（你的终端）的任何数据通过该套接字传输。同样，来自套接字的数据也会被传输到
    `stdout`（你的终端）。应该很清楚，我们已经创建了一种方法来接收输入并通过套接字将其发送到端口 `8080`，监听套接字可能发送回我们的任何数据。以下代码展示了这一点：'
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `repl_server` file closes the loop. We will first create a new **Transmission
    Control Protocol** (**TCP**) server with `net.createServer`, binding to port `8080`
    via `.listen`. The callback passed to `net.createServer` will receive a reference
    to the bound socket. Within the enclosure of that callback, we instantiate a new
    REPL instance, giving it a nice `prompt` (`'repl_server>'` in this case, but it
    could be any string), indicating that it should both listen for `input` from,
    and broadcast `output` to, the passed socket reference, indicating that the socket
    data should be treated as `terminal` data (which has special encoding).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`repl_server` 文件闭合了循环。我们将首先使用 `net.createServer` 创建一个新的 **传输控制协议**（**TCP**）服务器，通过
    `.listen` 绑定到端口 `8080`。传递给 `net.createServer` 的回调将接收一个指向已绑定套接字的引用。在这个回调的封装中，我们实例化一个新的
    REPL 实例，给它一个漂亮的 `prompt`（在这个例子中是 `''repl_server>''`，但它可以是任何字符串），表示它应该监听来自传递的套接字引用的
    `input`，并将 `output` 广播到该套接字引用，表示套接字数据应被视为 `terminal` 数据（它有特殊的编码）。'
- en: We can now type something, such as `console.log("hello")`, in the client terminal,
    and see `hello` displayed—the REPL server has executed the command we sent via
    our REPL client and sent back the evaluated response.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在客户端终端中输入一些内容，例如 `console.log("hello")`，然后看到 `hello` 被显示出来——REPL 服务器已经执行了我们通过
    REPL 客户端发送的命令，并发送回评估后的响应。
- en: To confirm that the execution of our JavaScript commands is occurring in the
    `repl_server` process, type `process.argv` in the client terminal, and the server
    will display an object containing the current process path, which will be `/.../repl_server.js`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的 JavaScript 命令的执行是在 `repl_server` 进程中进行的，请在客户端终端中输入 `process.argv`，服务器将显示一个包含当前进程路径的对象，该路径将是
    `/.../repl_server.js`。
- en: 'Additionally, we can add custom methods to the REPL `context` that are then
    accessible through clients. For example, add the following line to `repl_server.js`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以向 REPL 的 `context` 中添加自定义方法，然后通过客户端访问这些方法。例如，将以下行添加到 `repl_server.js`
    中：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Restart the server and the client, and enter `sayHello()` in the client terminal.
    You will see `Hello` displayed. It should be clear from this demonstration that
    we have created a way to remotely monitor Node processes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器和客户端，然后在客户端终端中输入 `sayHello()`。你会看到 `Hello` 被显示出来。从这个演示中应该很明显，我们已经创建了一种远程监控
    Node 进程的方法。
- en: 'Finally, REPL provides custom commands, in particular `.save` and `.load` (the
    dot (`.`) prefix is intentional). The .`save` command will save the current REPL
    session to a file—all the commands you have sent to REPL will be written to a
    specified file, meaning that they can be replayed. To see this in action, open
    an REPL session and run some commands, building up a session history. Then, enter
    the following two commands:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，REPL 提供了自定义命令，特别是 `.save` 和 `.load`（点 (`.`) 前缀是故意的）。`.save` 命令将保存当前的 REPL
    会话到一个文件中——你发送给 REPL 的所有命令都将写入到指定的文件中，这意味着它们可以被回放。要看到这个动作，打开一个 REPL 会话并运行一些命令，建立会话历史。然后，输入以下两个命令：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's create a demonstration module, which, when included in a process,
    opens it up to remote management via REPL.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个演示模块，当它包含在一个进程中的时候，它将通过 REPL 打开远程管理的通道。
- en: Remotely monitoring and managing Node processes
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程监控和管理 Node 进程
- en: In your code bundle, you will find the `repl-monitor` package. This module will
    expose a server on a given port, which will provide the current process memory
    usage, allowing a remote process to read this information and send instructions
    to the monitored process. For this example, we'll be able to tell the process
    to stop storing things in memory when the process heap exceeds a limit and to
    start storing things again when it is back below the given threshold.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码包中，你会找到 `repl-monitor` 包。这个模块将在指定的端口上暴露一个服务器，该服务器将提供当前进程的内存使用情况，允许远程进程读取这些信息并向被监控的进程发送指令。对于这个例子，我们将能够告诉进程在进程堆超过限制时停止在内存中存储东西，当它回到给定的阈值以下时再次开始存储东西。
- en: We'll also demonstrate the usefulness of `.load` to create highly dynamic monitoring
    solutions that can be adjusted without restarting targeted processes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将演示 `.load` 的有用性，以创建高度动态的监控解决方案，可以在不重新启动目标进程的情况下进行调整。
- en: Note that creating this sort of access point in the internals of your application
    should be done with caution. While these techniques are very useful, you must
    take care to secure access to the various ports, and so on, primarily by limiting
    access to those within a properly secured private network.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在应用程序的内部创建此类访问点应谨慎进行。虽然这些技术非常有用，但你必须小心保护对各种端口等的访问，主要通过限制对正确安全私有网络的访问来实现。
- en: 'The monitor code is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 监控代码如下：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This module creates REPL on a specified port and exposes two custom methods
    via the REPL context that clients can use. The `heapUsed` method returns a specific
    memory reading, and `send` is used by connecting clients to broadcast messages
    to monitored processes via the returned `EventEmitter` instance. It is important
    to note that the `output` pipe for this REPL is the connecting socket (identical
    to the `input` pipe). As we discussed earlier, this means that the calling process
    will receive the results of executing the JavaScript code it sends. We will provide
    more information on this later.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块在指定的端口上创建REPL，并通过REPL上下文公开两个自定义方法，客户端可以使用这些方法。`heapUsed`方法返回特定的内存读取值，而`send`方法则通过返回的`EventEmitter`实例将消息广播到被监控的进程。需要注意的是，此REPL的`output`管道是连接的套接字（与`input`管道相同）。正如我们之前讨论的，这意味着调用进程将接收到它发送的JavaScript代码的执行结果。我们将在稍后提供更多相关信息。
- en: 'Next, we will create a process to be monitored, which will require the monitoring
    module:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个要监控的进程，这需要监控模块：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have a process that keeps adding to an array. Via the monitor module,
    a client can connect to this process, check memory usage, and broadcast either
    a start or a stop message, which this process will listen for and act upon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个不断向数组中添加内容的进程。通过监控模块，客户端可以连接到这个进程，检查内存使用情况，并广播启动或停止消息，该进程将监听并据此行动。
- en: 'The last step is to create a client that does remote process management. The
    control client is straightforward. We connect to REPL via a TCP (net) connection
    and periodically poll the memory state of the targeted process:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个用于远程进程管理的客户端。控制客户端很简单。我们通过TCP（net）连接连接到REPL，并定期轮询目标进程的内存状态：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Recalling how we added the `heapUsed` method to the monitor''s REPL context,
    we should expect some value back when we write to the REPL `input` socket. This
    means that we must add a data listener to `sock`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们是如何将`heapUsed`方法添加到监控器的REPL上下文中的，当我们向REPL `input`套接字写入时，我们应该期望得到一些值。这意味着我们必须向`sock`添加一个数据监听器：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we receive a memory probe reading, it is converted to an integer and checked
    against the threshold value (based on whatever the first reading was). If the
    reading exceeds a predetermined limit, we tell the process to stop allocating
    memory; when the memory frees up, the process is told to resume.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到内存探测读取值时，它被转换为整数，并与阈值值（基于第一次读取的值）进行比较。如果读取值超过预定的限制，我们告诉进程停止分配内存；当内存释放时，进程被告知继续。
- en: 'Importantly, the particular opportunity afforded by REPL is the ability to
    *run a script* in the context of a remote process. Note the commands sent to `socket.write`,
    each of which loads an external file containing JavaScript:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，REPL提供的特定机会是能够在远程进程的上下文中*运行脚本*。注意发送到`socket.write`的命令，每个命令都加载包含JavaScript的外部文件：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While these *one-liners* simply exercise the messaging interface we discussed
    earlier, there is nothing that stops your implementation from using a much longer
    list of commands in the service of more realistic deployment needs. Crucially,
    this decoupling of process control facilitates dynamic process management as the
    script that you use `.load` on today can be changed in the future without requiring
    any alteration of the target process.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些*单行代码*只是简单地练习了我们之前讨论的消息接口，但你的实现并不妨碍使用更长的命令列表来满足更现实的部署需求。关键的是，这种进程控制解耦促进了动态进程管理，因为今天你使用的`.load`脚本可以在未来更改，而不需要修改目标进程。
- en: Now, let's take a look at more comprehensive techniques for deep analysis of
    application performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看更全面的用于深入分析应用程序性能的技术。
- en: Profiling processes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对进程进行性能分析
- en: When tracing memory leaks and other hard-to-find bugs, it is useful to have
    profiling tools at the ready. What we will look at in this section is how to take
    snapshots of running processes and how to draw useful information out of them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在追踪内存泄漏和其他难以发现的错误时，拥有分析工具是非常有用的。在本节中，我们将探讨如何对运行中的进程进行快照，以及如何从中提取有用的信息。
- en: 'Node already provides some process information natively. Basic tracking of
    how much memory your Node process is using is easy to fetch with `process.memoryUsage()`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Node 已经原生提供了一些进程信息。使用 `process.memoryUsage()` 可以轻松获取你的 Node 进程使用的内存量：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are also modules available to track a little more information on processes.
    For example, the `usage` module ([github.com/arunoda/node-usage](http://github.com/arunoda/node-usage))
    delivers straightforward memory and CPU usage information. To probe the current
    process, use the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些模块可以用来跟踪更多关于进程的信息。例如，`usage` 模块 ([github.com/arunoda/node-usage](http://github.com/arunoda/node-usage))
    提供了直接的内存和 CPU 使用信息。要探测当前进程，请使用以下代码：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This delivers the following result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we see the total process memory usage in bytes and the CPU usage percentage.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到进程的总内存使用量（以字节为单位）和 CPU 使用百分比。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A good resource to learn about JavaScript memory profiling can be found at [https://developer.chrome.com/devtools/docs/javascript-memory-profiling](https://developer.chrome.com/devtools/docs/javascript-memory-profiling).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 JavaScript 内存分析的好资源可以在 [https://developer.chrome.com/devtools/docs/javascript-memory-profiling](https://developer.chrome.com/devtools/docs/javascript-memory-profiling)
    找到。
- en: It is more interesting to be able to get a look into what V8 sees when it is
    running your process. Any node process can have `v8.log` generated simply by passing
    the `--prof` (for profile) flag. Let's create a log reader and check its performance
    using the `tick` module ([https://github.com/sidorares/node-tick](https://github.com/sidorares/node-tick)),
    which will read v8 logs and generate a breakdown of the execution profile.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 能够查看 V8 在运行你的进程时看到的内容更有趣。任何 Node 进程都可以通过传递 `--prof`（用于配置文件）标志来简单地生成 `v8.log`。让我们创建一个日志读取器，并使用
    `tick` 模块 ([https://github.com/sidorares/node-tick](https://github.com/sidorares/node-tick))
    来检查其性能，该模块将读取 V8 日志并生成执行配置文件的分解。
- en: 'To begin with, install the package globally:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，全局安装该包：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In your code bundle, under the `/profiling` directory for this chapter, there
    will be a file called `logreader.js`. This simply reads the `dummy.log` file (also
    in that folder) and dumps its contents to the console. It''s a good example of
    how to use a `Transform` stream to process log files:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码包中，在为本章创建的 `/profiling` 目录下，将有一个名为 `logreader.js` 的文件。这个文件简单地读取（也在该文件夹中）的
    `dummy.log` 文件，并将其内容输出到控制台。这是一个如何使用 `Transform` 流处理日志文件的优秀示例：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The important thing to note is that the main functions have been named and prefixed
    with `$`. This is good practice generally—you should always name your functions.
    The reason is specifically relevant to debugging. We want those names to show
    up in the reports we're about to generate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，主要函数已经被命名，并且以 `$` 为前缀。这通常是一个好的实践——你应该始终为你的函数命名。具体原因与调试相关。我们希望这些名称出现在我们即将生成的报告中。
- en: 'To generate a v8 log, run this script using the `–-prof` (profile) argument
    and `–-nologfile-per-isolate` to suppress default log file generation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 V8 日志，请使用 `–-prof`（配置文件）参数和 `–-nologfile-per-isolate` 参数运行此脚本以抑制默认日志文件的生成：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should now see a log file in the current working directory with the name
    `v8.log`. Go ahead and take a look at it—the log is somewhat intimidating. This
    is where the `tick` module comes into play:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能在当前工作目录中看到一个名为 `v8.log` 的日志文件。不妨查看一下——日志有些令人畏惧。这正是 `tick` 模块发挥作用的地方：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This command will generate a more readable profile and dump that to the `profile`
    file. Open that file and take a look. There is a lot of information and doing
    a deep dive into what it all means is well beyond the scope of this chapter. However,
    it is very clear how many ticks are being consumed by various functions in our
    script, such as `$transform`, and we can also see whether or not the functions
    are optimized. For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成一个更易读的配置文件并将其输出到 `profile` 文件。打开该文件并查看。这里有很多信息，深入探究其含义超出了本章的范围。然而，我们可以清楚地看到我们的脚本中各种函数（如
    `$transform`）消耗了多少个 tick，我们还可以看到函数是否已优化。例如：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we see that `$transform` occupied 16 ticks and was lazily compiled, and
    the tilde (`~`) indicates that the function is not optimized—if it was optimized,
    you would see an asterisk (`*`) prefix.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `$transform` 占用了 16 个 tick，并且是懒编译的，波浪号 (`~`) 表示该函数没有被优化——如果它被优化了，你会在前面看到一个星号
    (`*`) 前缀。
- en: 'As an experiment, create a script with the following code and run it with the
    `--prof` flag:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验，创建一个包含以下代码的脚本，并使用 `--prof` 标志运行它：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let this endless loop run for a while and then terminate the process by using
    *Ctrl* + *C*. Create a profile file, as we did previously, and view it. It should
    be clear how easy it would be to catch an expensive function using these profiling
    tools.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个无限循环运行一段时间，然后通过使用 *Ctrl* + *C* 终止进程。创建一个配置文件，就像我们之前做的那样，并查看它。应该很清楚，使用这些分析工具捕捉到昂贵的函数是多么容易。
- en: 'An extremely useful visualization tool available to those running the latest
    Node.js build (0.11.x or higher and io.js) is accessible simply by running the
    following in a version of the Chrome browser—`chrome://tracing/`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行最新 Node.js 构建版本（0.11.x 或更高版本和 io.js）的用户，有一个极其有用的可视化工具，只需在 Chrome 浏览器中运行以下命令即可访问——`chrome://tracing/`：
- en: '![Profiling processes](img/1403OS_05_05.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![分析进程](img/1403OS_05_05.jpg)'
- en: 'Once you have this ready in your browser, click on the **Load** button and
    upload your `v8.log` file. The execution timeline is laid out across the top,
    and, by clicking on the link (V8: V8 PC) on the left, you can access the starburst
    navigation tool. Starbursts radiate call stacks, nicely visualizing where the
    work in our application is being done. Note how our `$transform` function is listed
    to the right—name your functions!'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你在浏览器中准备好了，点击 **加载** 按钮，上传你的 `v8.log` 文件。执行时间线在顶部展开，通过点击左侧的链接（V8: V8 PC），你可以访问星爆导航工具。星爆辐射调用栈，很好地可视化我们的应用程序中的工作。注意我们的
    `$transform` 函数被列在右侧——给你的函数命名吧！'
- en: 'These are a few helpful links if you''d like to learn more about profiling
    v8:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于分析 v8 的信息，以下是一些有用的链接：
- en: '[https://developers.google.com/v8/profiler_example](https://developers.google.com/v8/profiler_example)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/v8/profiler_example](https://developers.google.com/v8/profiler_example)'
- en: '[https://groups.google.com/forum/#!msg/nodejs/oRbX5eZvOPg/jM6TINytVhoJ](https://groups.google.com/forum/#!msg/nodejs/oRbX5eZvOPg/jM6TINytVhoJ)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://groups.google.com/forum/#!msg/nodejs/oRbX5eZvOPg/jM6TINytVhoJ](https://groups.google.com/forum/#!msg/nodejs/oRbX5eZvOPg/jM6TINytVhoJ)'
- en: Using third-party monitoring tools
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方监控工具
- en: Node is a new technology for which there are few mature application monitoring
    tools. Some independent developers, along with established companies in the application
    monitoring space, have jumped in to fill this gap. In this section, we'll look
    at PM2 as a process manager and monitor and also have a look at Nodetime.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Node 是一种新技术，目前还没有成熟的应用程序监控工具。一些独立开发者和在应用程序监控领域的知名公司已经跳进来填补这一空白。在本节中，我们将探讨 PM2
    作为进程管理器和监控工具，并查看 Nodetime。
- en: PM2
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PM2
- en: PM2 is designed to be an enterprise-level process manager. As discussed elsewhere,
    Node runs within a Unix process, and its `child_process` and `cluster` modules
    are used to spawn further processes, typically when scaling an application across
    multiple cores. PM2 can be used to implement the deployment and monitoring of
    your Node processes both via the command line and programmatically. Here, I will
    focus on programmatically using PM2 for process management and show you how to
    use it to monitor and display process activity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 被设计成是一个企业级进程管理器。如前所述，Node 在 Unix 进程中运行，它的 `child_process` 和 `cluster` 模块用于生成更多进程，通常是在跨多个核心扩展应用程序时。PM2
    可以用于通过命令行和编程方式实现你的 Node 进程的部署和监控。在这里，我将专注于编程方式使用 PM2 进行进程管理，并展示如何使用它来监控和显示进程活动。
- en: 'Install PM2 globally:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装 PM2：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The most straightforward way to use PM2 is as a simple process runner. The
    following program will increment and log a value every second:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PM2 最直接的方式是作为一个简单的进程运行器。以下程序将每秒递增并记录一个值：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we use `fork` on a new process from `script.js`, running it in the background
    *forever*, until we stop it. This is a great way to run a daemonized process:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `fork` 在 `script.js` 的新进程中，将其在后台 *永远* 运行，直到我们停止它。这是一个运行守护进程的绝佳方式：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the script launches, you should see something like this in your terminal:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本启动，你应该在你的终端看到类似以下的内容：
- en: '![PM2](img/1403OS_05_02.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![PM2](img/1403OS_05_02.jpg)'
- en: The meaning of most of the values should be clear, such as the amount of memory
    your process is using, whether or not it is online, how long it has been up, and
    so on (the `mode` and `watching` fields will be explained shortly). The process
    will continue to run until it is stopped or deleted.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数值的含义应该是清晰的，例如你的进程使用的内存量，是否在线，运行了多长时间等等（`mode` 和 `watching` 字段将在稍后解释）。进程将继续运行，直到停止或删除。
- en: 'To set a custom name for your process when you start it, pass the `--name`
    argument to PM2 as follows: `pm2 start script.js --name ''myProcessName''`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动时为你的进程设置自定义名称，将 `--name` 参数传递给 PM2，如下所示：`pm2 start script.js --name 'myProcessName'`。
- en: 'This overview of all running PM2 processes can be brought up at any time via
    the `pm2 list` command. PM2 offers other straightforward commands:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有运行中的 PM2 进程的概述可以通过 `pm2 list` 命令随时调出。PM2 提供了其他简单的命令：
- en: '`pm2 stop <app_name | id | all>`: This is used to stop a process by name or
    ID or stop all processes. A stopped process remains in the process list and can
    be restarted later.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm2 stop <app_name | id | all>`：这是通过名称或 ID 停止进程或停止所有进程的方式。停止的进程将保留在进程列表中，以后可以重新启动。'
- en: '`pm2 restart <app_name | id | all>`: This is used to restart a process. The
    number of process restarts is displayed under `restarted` in all process lists.
    To automatically restart a process when it reaches a maximum memory limit (say,
    15 M), use the `pm2 start script.js --max-memory-restart 15M` command.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm2 restart <app_name | id | all>`：这是用于重新启动进程的方式。所有进程列表中的 `restarted` 下都会显示进程重启的次数。要自动在进程达到最大内存限制（例如，15
    M）时重新启动进程，请使用 `pm2 start script.js --max-memory-restart 15M` 命令。'
- en: '`pm2 delete <app_name | id | all>`: This deletes a process. This process cannot
    be restarted.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm2 delete <app_name | id | all>`：这用于删除一个进程。该进程不能被重新启动。'
- en: '`pm2 info <app_name | id >`: This provides detailed information on a process,
    as shown here:![PM2](img/1403OS_05_03.jpg)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm2 info <app_name | id>`：这提供了关于进程的详细信息，如下所示：![PM2](img/1403OS_05_03.jpg)'
- en: 'Note the paths given for error and other logs. Remember that our script increments
    an integer by one every second and logs that count. If you use `cat /path/to/script/
    out/log`, your terminal will show what has been written to the `out` log, which
    should be a list of incrementing numbers. Errors are similarly written to a log.
    Furthermore, you can stream the output logs in real time with `pm2 logs`. For
    example, our `script.js` process is still pumping out incremented values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意给出的错误和其他日志路径。记住，我们的脚本每秒递增一个整数并记录该计数。如果你使用 `cat /path/to/script/ out/log`，你的终端将显示写入到
    `out` 日志的内容，该日志应是一系列递增的数字。错误也会类似地写入到日志中。此外，你可以使用 `pm2 logs` 实时流式传输输出日志。例如，我们的
    `script.js` 进程仍在输出递增的值：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To clear all logs, use `pm2 flush`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除所有日志，使用 `pm2 flush`。
- en: 'You can also use PM2 programmatically. First, you will need to install PM2
    locally in your application''s `package.json` file with the standard `npm install
    pm2` command. To replicate the steps we took to run `scripts.js` with PM2, first
    create the `programmatic.js` script as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编程方式使用 PM2。首先，你需要在应用程序的 `package.json` 文件中本地安装 PM2，使用标准的 `npm install pm2`
    命令。要复制我们使用 PM2 运行 `scripts.js` 的步骤，首先创建以下 `programmatic.js` 脚本：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This script will use the `pm2` module to run `script.js` as a process. Go ahead
    and run it with `node programmatic.js`. Executing a PM2 list should show that
    `programmed script runner` is alive. To make sure this is so, try `pm2 logs`—you
    should see numbers being incremented, just as before.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将使用 `pm2` 模块以进程方式运行 `script.js`。请运行 `node programmatic.js`。执行 PM2 列表应显示 `programmed
    script runner` 正在运行。为了确保这一点，尝试 `pm2 logs`——你应该看到递增的数字，就像之前一样。
- en: Monitoring
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控
- en: 'PM2 makes process monitoring easy. To view real-time statistics on the CPU
    and memory usage for your processes, simply enter the command `pm2 monit`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 使进程监控变得简单。要查看进程的 CPU 和内存使用情况的实时统计信息，只需输入 `pm2 monit` 命令：
- en: '![Monitoring](img/1403OS_05_04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![监控](img/1403OS_05_04.jpg)'
- en: Here, we see a constantly updated graph of the CPU and memory usage for our
    process. What could be easier?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们进程的 CPU 和内存使用情况的持续更新的图表。还有什么比这更简单吗？
- en: 'PM2 also makes it easy to create web-based monitoring interfaces—it''s as simple
    as running `pm2 web`. This command will start a monitored process listening on
    port `9615`—running `pm2 list` will now list a process named `pm2-http-interface`.
    Run the web command and then navigate to `localhost:9615` in your browser. You
    will see a detailed snapshot of your processes, OS, and so on, as a JSON object:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 还使得创建基于 Web 的监控界面变得简单——只需运行 `pm2 web` 即可。这个命令将启动一个监听端口 `9615` 的监控进程——运行
    `pm2 list` 现在将列出名为 `pm2-http-interface` 的进程。运行 web 命令，然后在浏览器中导航到 `localhost:9615`。你将看到一个详细的进程、操作系统等的快照，作为一个
    JSON 对象：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Creating a web-based UI that polls your server every few seconds, fetches process
    information, and then graphs it is made much simpler due to this built-in feature
    of PM2.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PM2 的这个内置功能，创建一个每几秒轮询你的服务器、获取进程信息并将其图形化的基于 Web 的 UI 变得简单得多。
- en: 'PM2 also has an option to set a watcher on all managed scripts so that any
    changes to the watched script will cause an automatic process restart. This is
    very useful when developing. As a demonstration, let''s create a simple HTTP server
    and run it through PM2:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 还有一个选项可以在所有管理的脚本上设置监视器，以便任何对监视脚本的更改都会导致自动进程重启。这在开发时非常有用。作为演示，让我们创建一个简单的
    HTTP 服务器并通过 PM2 运行它：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This server will echo **"Hello World"** whenever `localhost:8080` is hit. Start
    it using `pm2 start server.js --watch --name 'watchedHTTPServer'`. Note that if
    you now list the running processes, our named process will show `enabled` in the
    `watching` column. Bring up this server in your browser. You should see **"Hello
    World"**. Now, navigate to the `server.js` script and change `"Hello World"` to
    `"Hello World, I've changed!"`. Reload your browser. Note the change. Run a process
    list, and you'll see that this server process indicates a restart. Do it a few
    more times. Live development of your server applications just got easier thanks
    to PM2.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `localhost:8080` 被访问时，这个服务器将回显 **"Hello World"**。使用 `pm2 start server.js --watch
    --name 'watchedHTTPServer'` 启动它。注意，如果你现在列出正在运行的过程，我们的命名进程将在 `watching` 列表中显示为
    `enabled`。在浏览器中打开这个服务器。你应该会看到 **"Hello World"**。现在，导航到 `server.js` 脚本，将 `"Hello
    World"` 改为 `"Hello World, I've changed!"`。重新加载浏览器。注意变化。运行进程列表，你会看到这个服务器进程指示重启。这样做几次。由于
    PM2，你的服务器应用程序的实时开发变得更容易了。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A process management tool with features similar to those of PM2 that is more
    focused on delivering a full-featured web UI out of the box is **Guvnor**: [https://github.com/tableflip/guvnor](https://github.com/tableflip/guvnor).
    Other popular process monitors can be found at [https://github.com/remy/nodemon](https://github.com/remy/nodemon)
    and [https://github.com/foreverjs/forever](https://github.com/foreverjs/forever).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有与 PM2 类似功能的过程管理工具，更专注于提供开箱即用的全功能 Web UI 是 **Guvnor**：[https://github.com/tableflip/guvnor](https://github.com/tableflip/guvnor)。其他流行的进程监控工具可以在
    [https://github.com/remy/nodemon](https://github.com/remy/nodemon) 和 [https://github.com/foreverjs/forever](https://github.com/foreverjs/forever)
    找到。
- en: We will talk about application deployment strategies using PM2 in [Chapter 7](ch07.html
    "Chapter 7. Deploying and Maintaining"), *Deploying and Maintaining*, including
    using PM2's `cluster` mode.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 7 章 [部署和维护](ch07.html "第 7 章。部署和维护") 中讨论使用 PM2 的应用程序部署策略，包括使用 PM2 的 `cluster`
    模式。
- en: Nodetime
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nodetime
- en: Nodetime is an easy-to-use Node-monitoring tool. Visit [www.nodetime.com](http://www.nodetime.com)
    and sign up. Once you do so, you will be presented with a page containing code
    to include in your application. Keep this page open as it will update when we
    start our application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Nodetime 是一个易于使用的 Node 监控工具。访问 [www.nodetime.com](http://www.nodetime.com) 并注册。一旦这样做，你将看到一个包含要包含在你的应用程序中的代码的页面。保持这个页面打开，因为它将在我们启动应用程序时更新。
- en: 'To begin with, we''ll create a simple HTTP server application that returns
    `"Hello World"` for every request:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的 HTTP 服务器应用程序，对于每个请求都返回 `"Hello World"`：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Save this as `server.js`. Execute it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为 `server.js`。执行它：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note how, on the Nodetime page in your browser, you will see **monitoring**
    show up under the **Applications** section. Click on that link—you will now see
    Nodetime''s monitoring interface:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在你的浏览器中的 Nodetime 页面上，你将在 **应用程序** 部分看到 **监控** 出现。点击该链接——你现在将看到 Nodetime
    的监控界面：
- en: '![Nodetime](img/1403OS_05_01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Nodetime](img/1403OS_05_01.jpg)'
- en: Go ahead and hit the server by visiting `localhost:8080` in your browser. After
    doing that a number of times, go back to your Nodetime interface and use the dropdown
    listing **OS / Load average**, selecting other useful metrics. Try `Process/V8
    heap total (MB)` to see how V8 is allocating memory. Other metrics allow you to
    check the profile of the machine executing this server process, and so on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中访问 `localhost:8080` 来击中服务器。这样做几次后，返回您的 Nodetime 界面，并使用下拉列表选择 **OS / 平均负载**，选择其他有用的指标。尝试
    `Process/V8 heap total (MB)` 来查看 V8 如何分配内存。其他指标允许您检查执行此服务器进程的机器的配置文件，等等。
- en: Using New Relic for monitoring
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 New Relic 进行监控
- en: New Relic is a well-known tool to monitor servers and applications that has
    been upgraded to support Node. It is intended to be used by those looking to monitor
    the memory and CPU usage as well as things such as network activity and the health
    of your Node processes. In this section, we'll look into how to install it on
    your server and provide examples of its use.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: New Relic 是一个广为人知的监控服务器和应用程序的工具，它已升级以支持 Node。它旨在供那些希望监控内存和 CPU 使用率以及网络活动、Node
    进程健康状况等的人使用。在本节中，我们将探讨如何在您的服务器上安装它，并提供其使用示例。
- en: Installation involves applying for a license key from the New Relic website
    at [newrelic.com](http://newrelic.com). Setting up your account is straightforward.
    After signing up, you'll be presented with a list of monitoring tools that New
    Relic provides—you'll want to select New Relic Servers. In the next steps, you'll
    select Node.js as your development environment and the OS you'll be working within.
    I'll use CentOS. After selecting your OS, you should see the installation instructions
    generated for you, with your license key included—just cut and paste.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程涉及从 New Relic 网站申请许可证密钥，网址为 [newrelic.com](http://newrelic.com)。设置您的账户非常简单。注册后，您将看到
    New Relic 提供的监控工具列表——您需要选择 New Relic Servers。在接下来的步骤中，您将选择 Node.js 作为您的开发环境以及您将在其中工作的操作系统。我将使用
    CentOS。在选择您的操作系统后，您应该会看到为您生成的安装说明，包括您的许可证密钥——只需剪切和粘贴即可。
- en: You are installing and starting a server that will probe system processes and
    report results to New Relic. This server must authenticate with New Relic by using
    your license key, and that means you must store that key in an accessible location.
    For this reason, a configuration file will be stored on your system. For most
    Unix installs, this file will be stored in `/etc/newrelic/nrsysmond.cfg`. Read
    through the configuration options described in that file, such as the location
    of log files.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在安装并启动一个服务器，该服务器将探测系统进程并向 New Relic 报告结果。此服务器必须使用您的许可证密钥与 New Relic 进行身份验证，这意味着您必须将此密钥存储在可访问的位置。因此，将在您的系统上存储一个配置文件。对于大多数
    Unix 安装，此文件将存储在 `/etc/newrelic/nrsysmond.cfg`。阅读该文件中描述的配置选项，例如日志文件的位置。
- en: Many third-party deployment environments/hosts often provide easy integration
    with New Relic, such as Heroku ([https://devcenter.heroku.com/articles/newrelic](https://devcenter.heroku.com/articles/newrelic)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 许多第三方部署环境/主机通常提供与 New Relic 的简单集成，例如 Heroku ([https://devcenter.heroku.com/articles/newrelic](https://devcenter.heroku.com/articles/newrelic))。
- en: 'Once New Relic is running, a log file will be created, and if all goes well,
    that file should contain a line similar to the following, indicating that New
    Relic is now tracking:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 New Relic 运行，将创建一个日志文件，如果一切顺利，该文件应包含类似以下内容的行，表明 New Relic 现在正在跟踪：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ll connect to this server via the `newrelic` package. Once that package
    is installed into your application directory, you will need to configure it. Somewhat
    awkwardly, this means copying the `newrelic.js` file from `node_modules/newrelic`
    into your application''s root folder, modifying its contents, and adding your
    license key and a name for your application. The log level field corresponds to
    the log levels used by Bunyan, so you may want to visit the project page for more
    information: [https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 `newrelic` 包连接到该服务器。一旦该包安装到您的应用程序目录中，您将需要对其进行配置。有些尴尬的是，这意味着将 `newrelic.js`
    文件从 `node_modules/newrelic` 复制到您的应用程序根目录，修改其内容，并添加您的许可证密钥以及您的应用程序名称。日志级别字段对应于
    Bunyan 使用的日志级别，因此您可能想访问项目页面以获取更多信息：[https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan)。
- en: You'll want to avoid storing your license key in the `newrelic.js` file when
    you go into production. You can pass configuration parameters to New Relic via
    environment variables rather than hardcoding them via environment variables. For
    example, you can pass your license key via the `NEW_RELIC_LICENSE_KEY` environment
    variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进入生产环境时，您会希望避免在`newrelic.js`文件中存储您的许可证密钥。您可以通过环境变量传递配置参数给New Relic，而不是通过硬编码。例如，您可以通过`NEW_RELIC_LICENSE_KEY`环境变量传递您的许可证密钥。
- en: The `newrelic` package repository can be found at [https://github.com/newrelic/node-newrelic](https://github.com/newrelic/node-newrelic).
    This project page contains extensive information on New Relic's usage and configuration,
    environment variables, and so on. Also, there are examples for setting up client-side
    monitoring.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`newrelic`包仓库可以在[https://github.com/newrelic/node-newrelic](https://github.com/newrelic/node-newrelic)找到。这个项目页面包含了关于New
    Relic的使用和配置、环境变量等方面的详细信息。此外，还有设置客户端监控的示例。'
- en: 'Let''s add New Relic monitoring to an example application. Create the following
    Express server:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个示例应用程序中添加New Relic监控。创建以下Express服务器：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can add additional routes or change the route names if you'd like. What
    we're going to do is run this server, hit it a few times, and then check with
    New Relic to see what it has picked up. Start the server and make some requests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想添加额外的路由或更改路由名称，可以这样做。我们将运行这个服务器，点击几次，然后使用New Relic检查它捕捉到了什么。启动服务器并发出一些请求。
- en: 'Once you''ve exercised the server a bit, head over to `newrelic.com` and log
    in. Across the top of the page, you will see a navigation menu, and you''ll be
    in the **APM** section. Here is where you can access various monitoring tools
    for you applications. You should see a list including the application name you
    set earlier. Click on that name, and you''ll be brought to a dashboard overview
    (there won''t be much information yet). You should, however, see some information
    about the server route activity:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对服务器进行了一些测试，请转到`newrelic.com`并登录。在页面顶部，您将看到一个导航菜单，您将处于**APM**部分。这里您可以访问您应用程序的各种监控工具。您应该会看到一个包括您之前设置的名称的应用程序列表。点击该名称，您将被带到仪表板概览（目前不会有太多信息）。但是，您应该会看到一些关于服务器路由活动的信息：
- en: '![Using New Relic for monitoring](img/1403OS_05_06.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![使用New Relic进行监控](img/1403OS_05_06.jpg)'
- en: Along the left-hand side, there will be a more detailed navigation pane. Go
    to **Reports** | **Web transactions**, and you'll see more detailed information
    on the routes you've set up. If you navigate to the **SERVERS** section, you'll
    see a dashboard for your host containing detailed system information.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，将会有一个更详细的导航面板。转到**报告** | **Web事务**，您将看到您设置的路径的更详细信息。如果您导航到**服务器**部分，您将看到包含详细系统信息的宿主仪表板。
- en: Now, let's create server load and see how New Relic does with monitoring. If
    you have a favorite load stress tool, go ahead and send some traffic to your application.
    If you'd like to learn a simple and common stress-testing tool, learn and use
    the Apache Bench tool ([http://httpd.apache.org/docs/2.2/programs/ab.html](http://httpd.apache.org/docs/2.2/programs/ab.html)).
    There are also free online stress-testing services, such as [http://loader.io](http://loader.io)
    and [https://loadimpact.com](https://loadimpact.com).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建服务器负载并看看New Relic在监控方面的表现。如果您有一个喜欢的负载压力工具，请继续向您的应用程序发送一些流量。如果您想学习一个简单且常见的压力测试工具，可以学习和使用Apache
    Bench工具([http://httpd.apache.org/docs/2.2/programs/ab.html](http://httpd.apache.org/docs/2.2/programs/ab.html))。还有免费的在线压力测试服务，例如[http://loader.io](http://loader.io)和[https://loadimpact.com](https://loadimpact.com)。
- en: Once you've started the stress test, return to the New Relic dashboard for your
    application and host server. You'll see regularly updated statistics as the New
    Relic monitor reports the effect of requests on the memory, CPU load, and other
    key metrics.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始压力测试，请返回您应用程序和宿主服务器的New Relic仪表板。您将看到New Relic监控报告请求对内存、CPU负载和其他关键指标的影响时定期更新的统计数据。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we engaged with one of the most important aspects of deployment—monitoring
    running processes. Starting at the most basic and necessary level—catching errors—you
    learned how to trap errors at the individual process level and across processes.
    After discussing techniques to log errors with both UDP and third-party tools,
    we looked at how to build remote process monitors using Node's REPL, leading to
    a deeper discussion on how to do extensive application profiling and memory analysis.
    Finally, we looked at how to deploy the PM2 process runner in an effort to manage
    processes and visualize their activity. We also looked at how to use the cloud-based
    Nodetime and New Relic services to monitor your applications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了部署最重要的方面之一——监控运行中的进程。从最基本和必要的水平开始——捕获错误——你学习了如何在单个进程级别和跨进程级别捕获错误。在讨论了使用UDP和第三方工具记录错误的技术之后，我们探讨了如何使用Node的REPL构建远程进程监控器，进而深入讨论了如何进行广泛的应用程序分析和内存分析。最后，我们探讨了如何部署PM2进程运行器以管理进程并可视化其活动。我们还探讨了如何使用基于云的Nodetime和New
    Relic服务来监控你的应用程序。
- en: Direct monitoring provides crucial real-time insights into any potential threats,
    but we must also try to limit the possibility of future errors by writing resilient
    code that we can be confident of. In the next chapter, we will look at how to
    build and test our applications such that they inspire confidence. Advice on how
    best to build and organize your applications so that their design is clear will
    be presented. This way, applying the remaining chapter content on testing strategies
    to your application can flow naturally with your ongoing development.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 直接监控提供了对任何潜在威胁的关键实时洞察，但我们也必须尝试通过编写我们能够自信的健壮代码来限制未来错误的可能性。在下一章中，我们将探讨如何构建和测试我们的应用程序，以便它们能够激发信心。将介绍如何最佳地构建和组织你的应用程序，以便其设计清晰。这样，将剩余章节内容关于测试策略应用到你的应用程序中可以与你的持续开发自然地流动。
