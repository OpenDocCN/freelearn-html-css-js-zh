<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Scaling Up"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Scaling Up</h1></div></div></div><p>So far we've really<a id="id992" class="indexterm"/> only covered how to create apps for smaller devices such as phones. But there are a lot of other mobile devices that aren't phone-shaped, namely tablets (and the so called phablets, which are often 7 inches instead of 10). Though there aren't as many users who have tablets as phones, it is still an incredibly important market.</p><p>Sometimes it is possible to simply display the same user interface on a larger device. This is often seen in games, where the graphics and control areas are often just scaled to the device's screen size. Other times it is possible to largely use the same user interface, but small tweaks are required in order to make it function well on an a larger screen. And there are other times when there is simply no choice; the user interface must be re-thought entirely for the larger screen.</p><div class="section" title="What do we build?"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec91"/>What do we build?</h1></div></div></div><p>In this project, we'll <a id="id993" class="indexterm"/>revisit an app that we created in <a class="link" href="ch03.html" title="Chapter 3. Being Productive">Project 3</a>, <span class="emphasis"><em>Being Productive</em></span>. The app isn't terribly complex, but it is flexible enough to support various ways of scaling up, which is what we'll do. We're going to create several different versions of Filer, each with different concepts of scaling to a tablet-sized screen.</p><div class="section" title="What does it do?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec208"/>What does it do?</h2></div></div></div><p>One of the main <a id="id994" class="indexterm"/>problems with developing for a larger screen when one has been solely developing for a small screen is "What to do with all that space?" When one is constrained to developing for a 320 x 80 or 600 x 800 dimension, it can be a sudden shock to realize that one has a lot more pixels to fill. Often, these larger displays are sized at 1024 x 768, 1280 x 768, 1280 x 800, or higher. In fact, the iPad 3 has a display that's technically 2048 x 1536, which when you think about it, is pretty astounding. Thankfully, the iPad 3 scales that back to 1024 x 768 for us.</p><p>What we'll do in this project is rethink the user interface for Filer to account for the larger real estate. We won't focus so much on the actual functionality—we've done that work in <a class="link" href="ch03.html" title="Chapter 3. Being Productive">Project 3</a>, <span class="emphasis"><em>Being Productive</em></span>, but we will deal with how to handle larger screens.</p><p>We'll focus on two typical scenarios: <a id="id995" class="indexterm"/>
<span class="strong"><strong>scale-it-up</strong></span>, where we simply scale the interface to fit the new screen size, and <span class="strong"><strong>split view</strong></span>
<a id="id996" class="indexterm"/> (otherwise referred to as <a id="id997" class="indexterm"/>
<span class="strong"><strong>master-detail</strong></span>), where we will add a sidebar to the <a id="id998" class="indexterm"/>interface (something you see quite often on the iPad, for example, the <span class="strong"><strong>Settings</strong></span> app).</p></div><div class="section" title="Why is it great?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec209"/>Why is it great?</h2></div></div></div><p>Sometimes an app just <a id="id999" class="indexterm"/>screams for more space—and note-taking apps aren't any exception. A bigger screen means that there is a larger on-screen keyboard, and a bigger screen means that there is more space for important content—such as text. At other times, we can transition an app to the larger screen by using split-view layouts that allow us to efficiently flatten the app's hierarchy. We'll explore all these options with our three versions of Filer.</p></div><div class="section" title="How are we going to do it?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec210"/>How are we going to do it?</h2></div></div></div><p>We'll approach the three<a id="id1000" class="indexterm"/> designs as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the scaled-up UI</li><li class="listitem" style="list-style-type: disc">Implementing the scaled-up UI</li><li class="listitem" style="list-style-type: disc">Designing the split-view UI</li><li class="listitem" style="list-style-type: disc">Implementing the split-view UI</li></ul></div></div><div class="section" title="What do I need to get started?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec211"/>What do I need to get started?</h2></div></div></div><p>For this particular task, <a id="id1001" class="indexterm"/>we'll be working with the files for this project, so if you want to follow along, go ahead and download them. There are two directories named <code class="literal">1</code> and <code class="literal">2</code>, which are versions of the app in this project. The first is what we'll focus on next, while the second is what we'll work on later.</p></div></div></div>
<div class="section" title="Designing the scaled-up UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Designing the scaled-up UI </h1></div></div></div><p>A lot of apps can <a id="id1002" class="indexterm"/>simply "scale up" to fit the larger screen, and our framework, thankfully, does a lot of the "scaling" part for us. While this works well for games, we do need to do a bit more work to make Filer fit the big screen well.</p><div class="section" title="Getting on with it"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec212"/>Getting on with it</h2></div></div></div><p>If you remember the Filer app from <a class="link" href="ch03.html" title="Chapter 3. Being Productive">Project 3</a>, <span class="emphasis"><em>Being Productive</em></span>, there were three views: a <a id="id1003" class="indexterm"/>
<span class="strong"><strong>start view</strong></span>, a <a id="id1004" class="indexterm"/>
<span class="strong"><strong>documents view</strong></span>, and the <a id="id1005" class="indexterm"/>
<span class="strong"><strong>document view</strong></span>. We'll be scrapping the first view—there'd be nothing to do with it to make it work on a larger screen anyway. Instead, we'll focus on the last two views—and, in all honesty, for this task, we're only really going to make a lot of the changes to the first of them.</p><p>Let's take a look at the screenshot from the documents view for the Filer app from <a class="link" href="ch03.html" title="Chapter 3. Being Productive">Project 3</a>, <span class="emphasis"><em>Being Productive</em></span>:</p><div class="mediaobject"><img src="graphics/9403_10_02.jpg" alt="Getting on with it"/></div><p>For our tablet-sized app, we'll display this list of documents horizontally and vertically, rather than just horizontally. On an iPad, this will show about three icons across when in portrait orientation and four icons across when in landscape. This means our mockup looks like this:</p><div class="mediaobject"><img src="graphics/9403_10_01.jpg" alt="Getting on with it"/></div><p>For the purposes of <a id="id1006" class="indexterm"/>this project, we'll keep the <span class="strong"><strong>Create</strong></span> button on the navigation bar, but there is a challenge at the end of the project to turn this into a larger feature within the document list. For example, some apps might have a blank document image with a "plus" icon in it to symbolize creating a new document. Others might use a dashed rectangle to indicate the same thing. For the larger display, something like this is definitely appropriate; while on a small screen, it'd be seen as a waste of space.</p><p>Beyond making this change to the document list, that's really all we're going to be doing to the app. The rest of it will work as is on the larger screen, thanks to the fact that our framework is designed to fill the screen.</p></div><div class="section" title="What did we do?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec213"/>What did we do?</h2></div></div></div><p>In this task we went over the app from <a class="link" href="ch03.html" title="Chapter 3. Being Productive">Project 3</a>, <span class="emphasis"><em>Being Productive</em></span>, and created a new mockup for the user interface for the larger screen.</p></div><div class="section" title="What else do I need to know?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec214"/>What else do I need to know?</h2></div></div></div><p>Scaling up an iPhone app is pretty easy <span class="emphasis"><em>if</em></span> you've already planned for the future of scaling it up. That is, if you've planned everything down to the pixel and built for a 320 x 480 screen, you're going to have to change all those pixels around on a larger screen. When dealing with simple productivity apps such as Filer, building a layout that can scale to a larger screen isn't terribly difficult, but get into more complex layouts and graphics, and it starts to become a challenge.</p><p>In some ways, highly graphical games have it both the hardest and the easiest. A game is probably going to keep the same user interface when scaling to a new screen—with perhaps a few minor tweaks to button placement or size. The graphics, however, are going to be the same, visually. Underneath the hood, though, those graphics may be rendered at vastly different resolutions. A certain graphic might work fine on a small screen, but get that up to a larger screen, and it will either seem too large or too small. To avoid forcing the browser to scale <span class="emphasis"><em>everything</em></span> (which always slows things down and results in some blurriness), it is better to re-render the graphics for the target screen, because you never know what kind of screens will be out in the future. It is, for this reason, always better to create your graphics in a vector format—this way you can always create a new rendition when a new size is needed.</p><p>One of the <a id="id1007" class="indexterm"/>hardest things to deal with properly are full-screen images. These might be in-game backgrounds, menu backgrounds, splashes, and so on, and you want them to look as nice as possible. In our sample game (<a class="link" href="ch08.html" title="Chapter 8. Playing Around">Project 8</a>, <span class="emphasis"><em>Playing Around</em></span>), we didn't focus on this a great deal, but if you had a device that had a substantially different aspect ratio than I had, you probably noticed some letter-boxing when the full-screen assets were shown. This is one way to approach it without having to do a lot of work—the other would be to scale and crop the image, potentially blurring it a bit, and losing portions of the image. The only other realistic option is to create an image specifically for each supported resolution.</p><p>For the best visual appearance, you should always render your images at the device's native resolution. For a Retina iPad, this would be 2048 x 1536 for a full-screen image. This, of course, is different for just about every Android device, and there's no terribly easy way to deal with it. You can replace the graphics via JavaScript based on the size of the screen, or you can use media queries to target specific graphic elements. You should note that though the framework we use does make a distinction between phone-sized devices and tablet-sized devices as well as non-retina and retina displays, it does nothing about all the different resolutions available on Android. Your best option would be to use CSS media queries (for more information, see <a class="ulink" href="https://developer.mozilla.org/en-US/docs/CSS/Media_queries">https://developer.mozilla.org/en-US/docs/CSS/Media_queries</a>).</p><p>In other ways, non-game apps can be terribly painful to scale up. You might be dealing with, for example, a lot of content that is formatted in a reasonably complex manner. It looks great given one screen size, but on another, things may break in odd places, especially when just scaling it. Sometimes the fact that we're working in HTML and CSS will save us—it's meant for dealing with complicated layout, but just as many times as not, it'll cause the look and feel to go awry in a way that you hadn't envisioned.</p><p>This is when creating code and layout <span class="emphasis"><em>specifically</em></span> for the tablet-size screen may be necessary. You can do things in your JavaScript, HTML, and CSS code to handle these sizes—you could put a <code class="literal">DIV</code> tag<a id="id1008" class="indexterm"/> classed with <code class="literal">tablet</code> in your HTML, and have a CSS rule that hides it on anything but a tablet. Likewise, you could hide the phone UI elements if you're trying to create a universal app that can run on both phone-sized screens and tablet-sized screens. Or, if <a id="id1009" class="indexterm"/>you're positioning certain things with JavaScript, you can always look at the type of device you're running on to get a good idea about what to do—and worst case, look at the width or height of the screen. Again, using media queries can often help when dealing with multiple resolutions.</p></div></div>
<div class="section" title="Implementing the scaled-up UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec93"/>Implementing the scaled-up UI</h1></div></div></div><p>Now that we've <a id="id1010" class="indexterm"/>designed the UI for Filer HD mark I, it's time to implement it. The number of changes that we've made to our code are astoundingly small, so get ready to keep your eyes open—blink, and you might miss it!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec215"/>Getting ready</h2></div></div></div><p>Although we're focusing primarily on the iOS platform for this app, the concepts apply equally to any platform-based tablet. With that said, to render an iOS app specific to the iPad, there are a couple of settings that need to be set in the project itself, outside of code:</p><p>In the project's settings in Xcode, change the <span class="strong"><strong>Devices</strong></span> setting to <span class="strong"><strong>iPad</strong></span> from <span class="strong"><strong>Universal</strong></span>.</p><p>You should see the project setting like so:</p><div class="mediaobject"><img src="graphics/9403_10_08.jpg" alt="Getting ready"/></div><p>Aside from this change (and setting our typical settings for the project in <code class="literal">Cordova.plist</code> for iOS), we'll copy the files from <a class="link" href="ch03.html" title="Chapter 3. Being Productive">Project 3</a>, <span class="emphasis"><em>Being Productive</em></span>. If you want to follow along, navigate to <code class="literal">/1/www</code> in the code files of this project.</p></div><div class="section" title="Getting on with it"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec216"/>Getting on with it</h2></div></div></div><p>There's really<a id="id1011" class="indexterm"/> surprisingly little that we have to do to make the app fit to the larger screen. As we've said before, our framework does do a good portion of the work—it always attempts to ensure that the content fills the screen, and our HTML in our views helps too—where possible, we want to use percentages not pixels. (This is not to say that using pixels is not good; for example, we use them liberally when dealing with button placement on the navigation bar.)</p><p>Just as a reminder, here's the documents view's HTML:</p><div class="informalexample"><pre class="programlisting">&lt;div class="viewBackground"&gt;
 &lt;div class="navigationBar"&gt;
  &lt;div id="documentsView_title"&gt;&lt;/div&gt;
  &lt;button class="barButton" id="documentsView_createButton" style="right:10px" &gt;&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="content avoidNavigationBar " style="padding:0; overflow: scroll;" id="documentsView_scroller"&gt;
   &lt;div id="documentsView_contentArea" style="padding: 0; height: auto; position: relative;"&gt;
   &lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;div id="documentsView_documentTemplate" class="hidden"&gt;
 &lt;div class="documentContainer"&gt;
  &lt;div class="documentImage"&gt;
   &lt;img src="./images/DocumentImage.png" border=0 onclick="documentsView.openDocument(%INDEX%)"/&gt;
  &lt;/div&gt;
  &lt;div class="documentTitle" onclick="documentsView.renameDocument(%INDEX%)"&gt;
   &lt;span &gt;%TITLE%&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="documentActions"&gt;
   &lt;img src="./images/Copy.png" width=28 height=28 border=0 onclick="documentsView.copyDocument(%INDEX%)" /&gt;
   &lt;img src="./images/Share.png" width=27 height=28  border=0 onclick="documentsView.shareDocument(%INDEX%)" /&gt;
   &lt;img src="./images/Trash.png" width=28 height=28  border=0 onclick="documentsView.deleteDocument(%INDEX%)" /&gt;
  &lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;</pre></div><p>Nothing here has to change, really. Next up, here's some of our styling:</p><div class="informalexample"><pre class="programlisting">.documentContainer
{
    width: 240px;
    height: auto;
    padding: 40px;
    padding-left: 20px;
    padding-right: 0px;
    display: inline-block;
    text-align: center;
}
.documentContainer .documentImage img
{
    width: 190px;
    height: 242px;
}

.landscape .documentContainer
{
    padding: 10px;
}

.landscape .documentContainer .documentImage img
{
    width: 125px;
    height: 160px;
}</pre></div><p>So far, no change <a id="id1012" class="indexterm"/>for the iPad devices. We did strip out the code that turned this into a list for Android devices, and so all tablet devices will get nice, big document icons.</p><p>The one place where we made some change was in the actual code, so let's take a look there:</p><div class="informalexample"><pre class="programlisting">  documentsView.documentIterator = function ( o )
    {
        var theHTML = "";
        var theNumberOfDocuments = 0;
        for (var i=0; i&lt;o.getDocumentCount(); i++)
        {
            var theDocumentEntry = o.getDocumentAtIndex ( i );
            
            theHTML += PKUTIL.instanceOfTemplate ( $ge("documentsView_documentTemplate"),
                                                   { "title": theDocumentEntry.name.substr(0, theDocumentEntry.name.length-4),
                                                     "index": i
                                                   }
                                                 );
            theNumberOfDocuments++;
        }
// code deleted
        $ge("documentsView_contentArea").innerHTML = theHTML;
    }</pre></div><p>See the comment about deleted code?</p><p>That's right—we <span class="emphasis"><em>deleted</em></span> something! If you remember, on the iPhone we wanted the document listing to scroll <span class="emphasis"><em>horizontally</em></span>, so there was some code that set the width of the document list's container to <span class="emphasis"><em>the number of items multiplied by the width</em></span>. This would make <code class="literal">DIV</code> larger, and it<a id="id1013" class="indexterm"/> therefore allowed the content to scroll horizontally. For this app, we want the width to be of one-screen width, and then we want the browser to <span class="emphasis"><em>wrap</em></span> our documents just like words on a page. So the next document to the right of the screen actually goes below the left-most document and starts a new row.</p><p>Guess what—that's <span class="emphasis"><em>it</em></span>. Our buttons didn't need to change position, and the text editor in our document view is already coded to fill the entire screen, so we didn't need to do anything there. The only thing we <span class="emphasis"><em>had</em></span> to take out was code that was written specifically for a phone-sized device.</p><div class="mediaobject"><img src="graphics/9403_10_03.jpg" alt="Getting on with it"/></div><p>So what does it look like now?</p><div class="mediaobject"><img src="graphics/9403_10_04.jpg" alt="Getting on with it"/></div></div><div class="section" title="What did we do?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec217"/>What did we do?</h2></div></div></div><p>In this task we converted what was a phone app into a tablet app.</p></div><div class="section" title="What else do I need to know?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec218"/>What else do I need to know?</h2></div></div></div><p>We<a id="id1014" class="indexterm"/> accomplished this by actually removing code that was constraining the app to that of a phone, but not all apps will be so simple to scale. Sometimes you may need to reposition buttons, content, and various elements in order to fit better on the larger screen. If you want the app to remain universal (that is, it will work on both a phone-sized device and a tablet-sized device), your work becomes harder, because you have to keep both layouts around. Thankfully, CSS, HTML, and JavaScript come to the rescue and help us out by letting us target certain classes and IDs or media queries with CSS and writing JavaScript code specific to a particular layout. In our case, we could have kept the phone-sized specific code by checking for the size of the device—the framework happily takes care of the rest of the sizing itself to the different sizes.</p><p>Sometimes you can get by with the way your framework handles the different viewport sizes, but there are often times when this falls flat—the UI is either too sparse on a large screen or too crammed on a small screen. If this occurs, it would be better to build your UI specifically for each device size rather than relying on the framework to get things right—because sometimes it doesn't.</p></div></div>
<div class="section" title="Designing the split-view UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec94"/>Designing the split-view UI</h1></div></div></div><p>The split-view layout is by <a id="id1015" class="indexterm"/>far one of the most popular methods for scaling your app to the tablet. It also has the side benefit of flattening the application's information hierarchy, which is just the technical way of saying that it takes less "taps" to get somewhere in the app.</p><p>Most tablet platforms implement this view in similar ways—in landscape mode it's always there on the left (but sometimes on the right), and in portrait mode it's usually hidden offscreen, ready and waiting for when the user taps a button to call it out. Other times the view is always visible in portrait mode, but this depends on the type of app and whether or not the loss of screen space is worth having the split view always visible.</p><div class="section" title="Getting on with it"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec219"/>Getting on with it</h2></div></div></div><p>The split view is really just two views put together. That's the easy way to think about it—one view is on the left in a smaller sidebar while the second view is on the right. The left view is technically called the <a id="id1016" class="indexterm"/>
<span class="strong"><strong>master view</strong></span>, while the right view is called the <a id="id1017" class="indexterm"/>
<span class="strong"><strong>detail view</strong></span>. Technically, this pattern is the <a id="id1018" class="indexterm"/>
<span class="strong"><strong>master-detail</strong></span> pattern, and it is most obvious when working with data records where the record selection occurs in the master view (on the left), and the detail of the record shows in the detail view (on the right).</p><p>In our app, we're going to make the documents list the master view so that the document itself can be the focus of the user. This means that a specific document will become the detail. In this arrangement, however, we need to switch from the pretty grid listing of documents in the previous version of the app and go back to a simple list.</p><p>Here's what our design looks like now:</p><div class="mediaobject"><img src="graphics/9403_10_05.jpg" alt="Getting on with it"/></div><p>The only thing not quite "true" in this sketch is the <span class="strong"><strong>Create</strong></span> button on the top. In reality there's going to be a title next to it as well, just that there wasn't enough space in the mockup to put it there. So it won't look as out-of-place as it does in the previous screenshot.</p><p>What isn't obvious is what happens when the device rotates to portrait orientation. The sidebar will actually disappear—leaving only the text document visible. We'll have a button on the left titled <span class="strong"><strong>Documents</strong></span> that will bring the sidebar back, and once the sidebar is displayed, a <span class="strong"><strong>Close</strong></span> button that will dismiss it. In a challenge at the end of this project, you'll be asked to implement gestures to open and close the sidebar.</p></div><div class="section" title="What did we do?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec220"/>What did we do?</h2></div></div></div><p>In this task, we<a id="id1019" class="indexterm"/> designed the user interface for a split-view layout.</p></div><div class="section" title="What else do I need to know?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec221"/>What else do I need to know?</h2></div></div></div><p>It really depends on your app if the master view needs to go away when oriented in portrait. Some apps can spare the loss of screen-width, other apps can't. When dealing with content (such as graphics, text, and so on.), it's probably a good idea to get rid of it when in portrait mode. If you're dealing with settings, properties, or the like, then you can keep it there with little impact on usability.</p></div></div>
<div class="section" title="Implementing the split-view UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Implementing the split-view UI</h1></div></div></div><p>Now it's time to<a id="id1020" class="indexterm"/> implement the changes necessary to make our app a split-view app. From this point forward, we'll be working in <code class="literal">/2/www</code> if you want to follow along. We started from the code in the last task and then modified it to suit the new user interface.</p><div class="section" title="Getting on with it"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec222"/>Getting on with it</h2></div></div></div><p>Unlike the last time, we're going to be making several modifications. Not a <span class="emphasis"><em>lot</em></span> of code, mind you, but we'll be touching several different files and making tweaks to support the change. The documents view gets only a few minor modifications, though we will change the display to a list instead of a grid, and the file view gets several modifications. For one, it has to handle what to do when there is no document loaded (which will happen at the beginning of the app). Second, it has to change the way it handles autosaving content (since there is no longer any dismissal of the view).</p><p>But first, we need to get the layout set up to show two views side-by-side. We'll start in <code class="literal">index.html</code>:</p><div class="informalexample"><pre class="programlisting">  &lt;body&gt;
    &lt;div class="container" id="rootContainer"&gt;
      &lt;div class="container leftSplit" id="leftSplitContainer"&gt;
      &lt;/div&gt;
      &lt;div class="container rightSplit" id="rightSplitContainer"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;</pre></div><p>Notice that we've added two elements to the<a id="id1021" class="indexterm"/> <code class="literal">rootContainer</code> element. The first is <code class="literal">leftSplitContainer</code> and the second is <code class="literal">rightSplitContainer</code>. The position of these elements should be apparent from the <code class="literal">ID</code> values.</p><p>This alone isn't going to get us there, though. We need to style these appropriately—and for this, we've made a change in the framework's base CSS. Look at <code class="literal">2/www/framework/base.css</code>:</p><div class="informalexample"><pre class="programlisting">.landscape .container.leftSplit {
  width:319px;
}

.landscape .container.rightSplit {
  left:320px;
}
.portrait .container.leftSplit
{
  display: none;
  width: 319px;
  z-index:2;
  box-shadow: rgb(0, 0, 0) 0px 0px 8px;
}

.portrait .container.rightSplit
{
  left:0;
}</pre></div><p>What we've done is indicated that while the device is in landscape orientation, the two splits should be side-by-side. The left-hand will be 319 pixels wide, and the right-hand view will start at pixel 320. Whatever's left on the screen will determine the width of the right-hand view. <span class="emphasis"><em>The size of this sidebar is not set in stone</em></span>—if your app needs a smaller sidebar, go ahead and aim lower—likewise, if it needs a larger one, set it larger. It is best, however, to not exceed half the width of the screen. If you feel the need, it is time to decide if you've got your views on the correct side.</p><p>In portrait mode, we <span class="emphasis"><em>hide</em></span> the sidebar. That said, this sidebar can appear again when the user wants, so we also make sure that it is indexed above all of the other content. We also give it a shadow so that there is a visual distinction for the user between the sidebar and the content underneath.</p><p>Changing the styles<a id="id1022" class="indexterm"/> alone, however, isn't enough. Let's take a look at what we've changed in <code class="literal">app.js</code>:</p><div class="informalexample"><pre class="programlisting"> // load our document view
  PKUTIL.loadHTML ( "./views/documentsView.html",
                    { id : "documentsView",
                      className: "container", 
<span class="strong"><strong>                      attachTo: $ge("leftSplitContainer"), </strong></span>
                      aSync: true
                    },
                    function (success)
                    {
                      if (success)
                      {
                        documentsView.initializeView();
<span class="strong"><strong>                        PKUI.CORE.showView ( documentsView );</strong></span>
                      }
                    });
  // load our fileView
  PKUTIL.loadHTML ( "./views/fileView.html",
                    { id : "fileView",
                      className: "container", 
                      attachTo: $ge("rightSplitContainer"), 
                      aSync: true
                    },
                    function (success)
                    {
                      if (success)
                      {
                        fileView.initializeView();
                        PKUI.CORE.showView ( fileView );
                      }
                    });

    window.addEventListener('orientationchange', APP.updateSidebar, false);
}</pre></div><p>First, our loading code has changed a little. Note that instead of attaching to <code class="literal">rootContainer</code>, we attach to <code class="literal">leftSplitContainer</code> and <code class="literal">rightSplitContainer</code>. This first step is critical to ensuring that each view's content ends up in the right place on the screen. Note also that we show <span class="emphasis"><em>each</em></span> view. This is new too—previously we would only have shown one view, <a id="id1023" class="indexterm"/>but since we are combining two views on the screen, we need them both to be visible.</p><p>There's one last new feature at the bottom of the previous code—a new event listener. We'll cover the following code, but essentially we ask the browser to notify us of any change in orientation. While the CSS and HTML go a long way to making sure our layout is correct when the orientation changes, they don't get us <span class="emphasis"><em>all</em></span> the way, and so we need some code to figure out the rest.</p><div class="informalexample"><pre class="programlisting">APP.toggleSidebar = function ()
{
  $ge("leftSplitContainer").style.display = 
   ( ($ge("leftSplitContainer").style.display == "block") ? "none" : "block" );
}</pre></div><p>This code is called by both the documents and file views, and its sole purpose is to toggle the appearance of the sidebar. If it is visible, this function will hide it, and vice versa.</p><div class="informalexample"><pre class="programlisting">APP.updateSidebar = function ()
{
  if (PKDEVICE.isPortrait())
  {
    $ge("leftSplitContainer").style.display = "none";
  }
  else
  {
    $ge("leftSplitContainer").style.display = "block";    
  }
}</pre></div><p>This code gets called at every change in orientation. If we change to portrait, we'll hide the sidebar, and if we change to landscape, we show it.</p><p>Next, we need to make some minor changes to the documents view:</p><div class="informalexample"><pre class="programlisting">&lt;div class="viewBackground"&gt;
 &lt;div class="navigationBar"&gt;
  &lt;div id="documentsView_title"&gt;&lt;/div&gt;
  &lt;button class="barButton" id="documentsView_closeButton" style="left:10px" &gt;&lt;/button&gt;
  &lt;button class="barButton" id="documentsView_createButton" style="right:10px" &gt;&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="content avoidNavigationBar " style="padding:0; overflow: scroll;" id="documentsView_scroller"&gt;
   &lt;div id="documentsView_contentArea" style="padding: 0; height: auto; position: relative;"&gt;
   &lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The main <a id="id1024" class="indexterm"/>difference is that we've added a <span class="strong"><strong>Close</strong></span> button to the view—this button will allow the user to dismiss the sidebar when they've previously elected to display it in portrait mode. We'll add some styles later on to prevent it from being visible while in landscape mode. We also changed the click handlers for certain areas, since this is now a list instead of a grid.</p><p>To support the new button, we have added some code to <code class="literal">documentsView.initializeView</code>:</p><div class="informalexample"><pre class="programlisting">documentsView.initializeView = function ()
  {
    PKUTIL.include ( ["./models/FilerDocuments.js", "./models/FilerDocument.js"], function ()
                     {
                        // display the list of available documents
                        documentsView.displayAvailableDocuments();
                     }
                   );

    documentsView.viewTitle = $ge("documentsView_title");
    documentsView.viewTitle.innerHTML = __T("APP_TITLE");

    documentsView.closeButton = $ge("documentsView_closeButton");
    documentsView.closeButton.innerHTML = __T("CLOSE");
    PKUI.CORE.addTouchListener(documentsView.closeButton, "touchend", function () { APP.toggleSidebar(); });


    documentsView.createButton = $ge("documentsView_createButton");
    documentsView.createButton.innerHTML = __T("CREATE");
    PKUI.CORE.addTouchListener(documentsView.createButton, "touchend", function () { documentsView.createNewDocument(); });</pre></div><p>All this does is call <code class="literal">APP.toggleSidebar</code> whenever the <span class="strong"><strong>Close</strong></span> button is tapped. Since the sidebar will be visible when we call this function, this means it will dismiss the sidebar by hiding it.</p><p>The only other <a id="id1025" class="indexterm"/>change? We removed calls to <code class="literal">PKUI.CORE.pushView</code>. These would normally have pushed the file view on the stack, but since it's already visible, we don't need to push anything. So we just remove those lines.</p><p>We did make changes to the styling, however (in <code class="literal">style.css</code>):</p><div class="informalexample"><pre class="programlisting">.documentContainer
{
  padding: 10px;
  background-color: #FFFFFF;
  width: 100%;
  height: 90px;
  color: #000;
  text-align: left;
  border-bottom: 1px solid #C0C2C4;
}
.documentContainer .documentImage img
{
    width: 60px;
    height: 70px;
}
.documentContainer .documentImage
{
  width: 70px;
  height: 80px;
  float: left;
}

.documentContainer .documentTitle
{
  height: 2em;
}</pre></div><p>The previous code will make each document item a nice little list item with the icon on the left, the title on the right, and the action icons below. You could take what you've learned from previous projects and add gesture support as well.</p><p>The file view itself gets quite a bit of change:</p><div class="informalexample"><pre class="programlisting">&lt;div class="viewBackground"&gt;
 &lt;div class="navigationBar"&gt;
  &lt;button class="barButton" id="fileView_documentsButton" style="left:10px" &gt;&lt;/button&gt;
  &lt;div id="fileView_title"&gt;&lt;/div&gt;
 &lt;/div&gt;
 &lt;div class="content avoidNavigationBar" style="padding:0; " id="fileView_scroller"&gt;
   &lt;div id="fileView_contentArea"&gt;
     &lt;textarea id="fileView_text"&gt;&lt;/textarea&gt;
   &lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The first thing different is that we've added a documents button on the navigation bar in place of the <span class="strong"><strong>Back</strong></span> button. This button will show the sidebar when in portrait mode. When in landscape, we'll have a special style that makes this button go away.</p><p>Next, let's look at the code:</p><div class="informalexample"><pre class="programlisting">  fileView.initializeView = function ()
  {
    fileView.viewTitle = $ge("fileView_title");
    fileView.viewTitle.innerHTML = __T("Select or Create a Document");
    PKUI.CORE.addTouchListener(fileView.viewTitle, "touchend", function () { fileView.entitleDocument(); } ); 
    fileView.documentsButton = $ge("fileView_documentsButton");
    fileView.documentsButton.innerHTML = __T("DOCUMENTS");
    PKUI.CORE.addTouchListener(fileView.documentsButton, "touchend", function () {APP.toggleSidebar(); } )
 
    $ge("fileView_text").style.display = "none"; 
  }</pre></div><p>This code is <a id="id1026" class="indexterm"/>pretty similar—instead of adding a listener to a <span class="strong"><strong>Back</strong></span> button, we add one to the <span class="strong"><strong>Documents</strong></span> button. The only other thing we do differently is hide the <code class="literal">TEXTAREA</code> control—if no document is loaded, there's no reason to show it.</p><div class="informalexample"><pre class="programlisting">  fileView.hasLoadedDocument = false;
  …
  fileView.setFileEntry = function ( theNewFileEntry )
  {
      if (fileView.hasLoadedDocument)
      {
        // we're potentially loading a NEW document -- save the old one.
        if (fileView.theSaveTimer!==-1)
        {
            // clear the interval so we don't save again.
            clearInterval (fileView.theSaveTimer);
            fileView.theSaveTimer = -1;
        }
        fileView.saveDocument();    // force the save so we have the up-to-date contents
        documentsView.reloadAvailableDocuments(); // reload our directory structure (just in case)
      }

      // now load the correct document
      fileView.theFileEntry = theNewFileEntry;
      fileView.theFilerDocument = {};
      fileView.hasLoadedDocument = true;
      fileView.loadDocument();
  }</pre></div><p>There's nothing new in this code—just a lot of movement of code. Some of this code used to live in <code class="literal">viewWillHide</code>—to handle saving just before the view disappeared. But this view will never disappear now, so how do we know we should save the document? Turns out that the only time we'll ever know is when a new document is selected. So before we <a id="id1027" class="indexterm"/>load <span class="emphasis"><em>that</em></span> document, we save the one we've currently got loaded. We can tell if we have one loaded by <code class="literal">fileView.hasLoadedDocument</code>—we'll set it to <code class="literal">true</code> once we get a document loaded.</p><p>At the end of the function, <code class="literal">fileView.loadDocument()</code> used to live in <code class="literal">viewWillAppear</code>. Since we may not have a document selected (especially at the beginning of the app), we aren't trying to load a nonexistent document there, and so we move it here.</p><p>Speaking of loading a document, consider the following code:</p><div class="informalexample"><pre class="programlisting"> fileView.loadDocument = function ()
  {
    // load our document.
    fileView.viewTitle = $ge("fileView_title");
    fileView.viewTitle.innerHTML = fileView.theFileEntry.name.substr(0,
                                          fileView.theFileEntry.name.length-4);
    fileView.theTextElement = $ge("fileView_text");
    fileView.theTextElement.value = "";
    $ge("fileView_text").style.display = "block";
   …
  }</pre></div><p>The highlighted code in <code class="literal">loadDocument</code> is what makes sure our <code class="literal">TEXTAREA</code> element to become visible so that the user can edit it. One thing our code doesn't do is hide it again if there's an error—you should definitely handle an error appropriately in your own code by hiding the <code class="literal">TEXTAREA</code> element and ensuring that you don't autosave, and so on.</p><p>The only other change necessary was the removal of any code handling a back-button event—this leaves <code class="literal">viewWillAppear</code> and <code class="literal">viewWillHide</code> completely empty! Note that for Android, we still need a<a id="id1028" class="indexterm"/> <code class="literal">backButtonPressed</code> function, but we don't do anything in it. (You could save the document and quit the app, though, if you wanted.)</p><p>We're <span class="emphasis"><em>almost</em></span> done—one last thing to do before we quit, and that's to make the styles hide our buttons appropriately. In <code class="literal">style.css</code>, we have:</p><div class="informalexample"><pre class="programlisting">.landscape #documentsView_closeButton,
.landscape #fileView_documentsButton
{
  display: none;
}

.portrait #documentsView_closeButton,
.portrait #fileView_documentsButton
{
  display: inline-block;
}</pre></div><p>And that's it! Here's<a id="id1029" class="indexterm"/> what things look like in landscape mode:</p><div class="mediaobject"><img src="graphics/9403_10_06.jpg" alt="Getting on with it"/></div><p>And in portrait mode (with the sidebar visible), it looks like this:</p><div class="mediaobject"><img src="graphics/9403_10_07.jpg" alt="Getting on with it"/></div><p>Notice in the image on the right that the sidebar is visible in the portrait orientation—this is because we clicked the <span class="strong"><strong>Documents</strong></span> button to bring it up. Now if we clicked <span class="strong"><strong>Close</strong></span>, the sidebar would disappear.</p></div><div class="section" title="What did we do?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec223"/>What did we do?</h2></div></div></div><p>We converted the <a id="id1030" class="indexterm"/>Filer app to a split-view application ready for the tablet-sized screen.</p></div><div class="section" title="What else do I need to know?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec224"/>What else do I need to know?</h2></div></div></div><p>If your app includes a couple of views (like this one), then conversion is going to be pretty simple. But if your app needs to have navigation occur in both views, then you're going to run into a hitch as our current framework <span class="emphasis"><em>doesn't</em></span> actually support it.</p><p>The view stack as implemented by our current framework assumes only one view on the screen at one time. But in a split-view app, you can have multiple views on the screen. Although the framework plans to support this in the near future, it's not currently available, and so you would need to handle navigation between views on your own. In short, don't try to use view pushing or popping—otherwise funny things will happen.</p><p>If you want to follow the framework's progress beyond this book, please visit the framework's <a id="id1031" class="indexterm"/>Github page: <a class="ulink" href="https://github.com/photokandyStudios/YASMF">https://github.com/photokandyStudios/YASMF</a>.</p></div></div>
<div class="section" title="Game Over..... Wrapping it up"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Game Over..... Wrapping it up</h1></div></div></div><p>Well, we did it. We've converted an app into two different forms ready for the tablet-sized screen. Although these are the most popular ways of doing it, that doesn't mean that another method might not work better for your app, or a combination of several. It all depends on your content and how the app itself works. You would do well to consult your platform's <span class="emphasis"><em>Human Interface Guidelines</em></span> (links in <a class="link" href="apa.html" title="Appendix A. Quick Design Pattern Reference">Appendix A</a>, <span class="emphasis"><em>Quick Design Pattern Reference</em></span>) too. Only after a thorough examination of your content, layout, graphics, and so on, can you determine what approach would be best—and even then, don't be afraid to experiment and try something else.</p></div>
<div class="section" title="Can you take the HEAT? The Hotshot Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec97"/>Can you take the HEAT? The Hotshot Challenge</h1></div></div></div><p>This project only covered two methods of scaling to a tablet interface. There are, of course, myriad ways of improving what we've shown here, or using other design patterns to scale to a tablet interface. Why don't you try a few?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The split-view pattern has the left split view (or master view) disappearing when in portrait mode. When the <span class="strong"><strong>Documents</strong></span> button is tapped, it appears immediately. Why don't you add some animation instead, to make this less jarring? (Don't forget to animate it when <span class="strong"><strong>Close</strong></span> is tapped too.)</li><li class="listitem" style="list-style-type: disc">Continuing the theme, dismiss the left split view automatically when you select (or create) a document when in portrait mode.</li><li class="listitem" style="list-style-type: disc">Most apps today will allow a gesture to open and close the sidebar (usually a horizontal swipe). Add this to the app.</li><li class="listitem" style="list-style-type: disc">Lastly, when the app opens in portrait mode, there's no real indication of what to do (short of tapping <span class="strong"><strong>Documents</strong></span>)—make the sidebar appear automatically.</li><li class="listitem" style="list-style-type: disc">Instead of using <span class="strong"><strong>Create</strong></span> buttons to create a document, use a "create" item in the document list instead. This can be similar in shape to the existing document items, or not—your call!</li><li class="listitem" style="list-style-type: disc">Take the split view a step further and add a twist! If you've seen the Facebook iOS app, you know that the sidebar actually lives below the main content. The main content can then be slid to the right, which exposes the sidebar underneath. Try and implement this style of app.</li><li class="listitem" style="list-style-type: disc">Try putting the sidebar of the split view in a different position. Putting it on the right is the easiest, but a harder challenge would be the top or the bottom of the screen.</li></ul></div></div></body></html>