<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Service Worker Life Cycle</h1>
                
            
            
                
<p class="calibre2">The service worker life cycle is one of the most important concepts you must master in order to create proper service workers. This part of the service worker discipline is often overlooked and leads to many questions and frustrations expressed on sites such as Stack Overflow. But mastering the service worker life cycle allows you to seamlessly register and update service workers.</p>
<p class="calibre2">I think developers overlook the life cycle because it is not obvious until they hit an obstacle due to not understanding the service worker lifespan. The issue that confuses most developers is when a service worker becomes active.</p>
<p class="calibre2">Service workers obey a known life cycle that allows a new service worker to get itself ready without disrupting the current one. The life cycle is designed for the best user experience.</p>
<p class="calibre2">When a service worker is registered, it does not immediately seize control of the client. There are rules designed to minimize errors due to differences in code versions.</p>
<p class="calibre2">If a new service worker just took control of a client's context, there could be issues if the client or page is expecting the previous version. Even though the service worker operates on a separate thread, the UI code could have dependencies on service worker logic or cached assets. If the new version breaks the frontend, your user experience could go sideways.</p>
<p class="calibre2">The life cycle is designed to ensure that an in-scope page or task is controlled by the same service worker (or no service worker) throughout its session:</p>
<div><img src="img/00063.jpeg" class="calibre77"/></div>
<p class="calibre2">The life cycle consists of the registration, installation, and activation steps. The installation and activation events can have handlers bound to them so that they perform specific tasks.</p>
<p class="calibre2">The life cycle also covers service worker updates, maybe the most important life cycle step, and unregistration. These last two tasks may not be used as often, but developers should still be familiar with how they work.</p>
<p class="calibre2">Each stage can be used for different process phases to manage the service worker, cached assets, and possibly state data. This chapter goes into details about the life cycle and how each phase can be used to make your application more performant and easier to manage.</p>
<p class="calibre2">The following topics will be covered in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Registering a service worker</li>
<li class="calibre11">Service worker clients</li>
<li class="calibre11">Updating a service worker</li>
<li class="calibre11">Service worker scope</li>
<li class="calibre11">Service worker updates</li>
<li class="calibre11">Service worker events</li>
</ul>
<p class="calibre2">When a service worker is registered, the script is downloaded and then installed. At this point, it does not take over any active clients, including the page that registers the service worker. This is by design, to ensure that the client experience is not at risk of breaking due to changes in service worker code.</p>
<p class="calibre2">When a service worker becomes active, it claims or controls any clients within the worker's scope. Since there could be a previous worker controlling the clients, a new version does not automatically take over. This could lead to all sorts of trouble if there are logical differences between the two versions.</p>
<p class="calibre2">To avoid potential error states, the service worker specification errs on the side of caution. You can call the <kbd class="calibre12">skipWaiting</kbd> function in the install event handler to cause the new version to become active. When calling <kbd class="calibre12">skipWaiting</kbd>, you may still need to claim active clients:</p>
<pre class="calibre17">self.addEventListener('install', event =&gt; {<br class="title-page-name"/>   self.skipWaiting();<br class="title-page-name"/>   event.waitUntil(<br class="title-page-name"/>     // caching etc<br class="title-page-name"/>   );<br class="title-page-name"/> }); </pre>
<p class="calibre2">If you use <kbd class="calibre12">skipWaiting</kbd>, it is best to call the method before you proceed to any pre-cache activities, because they may take a while. This is why the pre-cache logic is wrapped in a <kbd class="calibre12">waitUntil</kbd> method.</p>
<p class="calibre2">The <kbd class="calibre12">waitUntil</kbd> method holds the event handler open until the tasks have finished processing. Think about holding an elevator door open until everyone gets on or off the car. If you have extending processing, the service worker will not shut down.</p>
<p class="calibre2">If the service worker is idle for a long period of time, the active service worker is terminated to reduce CPU load and other resources it might otherwise consume. This is a good thing because continuous service workers would drain your devices battery if it ran continuously.</p>
<p class="calibre2">Beware, if you force a new service worker to become active, you need to make sure that it will not break your application. Users don't like it when the user experience breaks and error messages are displayed.</p>
<p class="calibre2">A best practice is to execute some sort of testing to verify the integrity of your application. You may also want to warn the user that the application has been updated, possibly encouraging a manual refresh.</p>
<p class="calibre2">Never automatically refresh the page without warning the visitor as this could be confusing. The messaging API can be used to communicate with the user to coordinate the update.</p>
<p class="calibre2">If there are any errors during the service worker installation, the registration will fail and its life cycle will end. After installation, the service worker can become active. Once active, it can respond to function events such as <kbd class="calibre12">fetch</kbd>.</p>
<p class="calibre2">A common error during the installation handler is the cache. The <kbd class="calibre12">addAll</kbd> method may receive a 404 Not Found response. When this happens, the <kbd class="calibre12">addAll</kbd> method throws an exception. Since the install event cannot determine the error severity or context, it rolls back. The service worker never installs. This is represented by the red error block in the following flow chart.</p>
<p class="calibre2">You can catch exceptions and handle them gracefully. You can still make individual requests and cache those results. This requires a little more code, but gives you some insulation against a single request, causing the service worker install to fail. You can also make sure that good responses are cached, even when one fails.</p>
<p class="calibre2">The following flow chart demonstrates the core life cycle, but does not visualize how a service worker becomes active:</p>
<div><img src="img/00064.jpeg" class="calibre78"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Registering a service worker</h1>
                
            
            
                
<p class="calibre2">Service workers must be registered from a web page. This is done in a normal UI script. Before you call the <kbd class="calibre12">register</kbd> method, you should feature detect service worker support. If supported, the <kbd class="calibre12">navigator</kbd> object has a <kbd class="calibre12">serviceWorker</kbd> property:</p>
<pre class="calibre17">if ('serviceWorker' in navigator) {<br class="title-page-name"/> } </pre>
<p class="calibre2">If the browser supports service workers, you can then safely register your service worker. The <kbd class="calibre12">serviceWorker</kbd> object has a <kbd class="calibre12">register</kbd> method, so you need to supply a URL reference to the service worker script:</p>
<pre class="calibre17">if ('serviceWorker' in navigator) {<br class="title-page-name"/> navigator.serviceWorker.register('/sw.js')<br class="title-page-name"/> .then(function(registration) {<br class="title-page-name"/> // Registration was successful<br class="title-page-name"/> });<br class="title-page-name"/> }</pre>
<p class="calibre2">The <kbd class="calibre12">serviceWorker.register("sw path"[, options])</kbd> function accepts two parameters. The first is the path to the service worker. This path is relative to the site origin or root folder.</p>
<p class="calibre2">The second parameter is optional, and is an object containing registration options. For now, the only option available is <kbd class="calibre12">scope</kbd>. An object was used to afford future modifications to the <kbd class="calibre12">register</kbd> function.</p>
<p class="calibre2">The <kbd class="calibre12">scope</kbd> option is a string reference to the path that is relative to the site's root the service worker is allowed to control. In the following example, a service worker is being registered for the human resources department. The same code would be used from the site's root domain or the <kbd class="calibre12">hr</kbd> subfolder because all paths are relative to the site's root:</p>
<pre class="calibre17">navigator.serviceWorker.register('/hr/sw.js', {scope: '/hr/'})<br class="title-page-name"/> .then(function (registration) {<br class="title-page-name"/> // Registration was successful<br class="title-page-name"/> console.log('ServiceWorker registration successful with scope: ', registration.scope);<br class="title-page-name"/> });</pre>
<p class="calibre2">You could register a service worker for any path within the site from anywhere. The scope is still limited to where the service worker physically resides. This means you could also register the marketing and finance service workers from the HR application. However, HR would not have the ability to manipulate anything in those applications and vice versa.</p>
<p class="calibre2">A script can be stored at any level at or above its designated scope. For example, if all of your application's service workers were located in the site's root folder, they would each need a different <kbd class="calibre12">scope</kbd> value:</p>
<pre class="calibre17">navigator.serviceWorker.register('/sw-hr.js', {scope: '/hr/'})<br class="title-page-name"/> .then(function (registration) {<br class="title-page-name"/> // Registration was successful<br class="title-page-name"/> console.log('ServiceWorker registration successful with scope: ', registration.scope);<br class="title-page-name"/> });</pre>
<p class="calibre2">The preceding example demonstrates how the HR department's service worker is stored in the domain's root folder. Setting the scope to <kbd class="calibre12">/hr/</kbd> limits its scope to the <kbd class="calibre12">hr</kbd> folder and below.</p>
<p class="calibre2">Misunderstanding scope is one of the most common mistakes new service worker developers make. The first step is to accept that service workers are different from the client-side JavaScript we have been authoring for the past two decades.</p>
<p class="calibre2">You should make an effort to separate your service worker scripts from your traditional client script files. Place the service worker file of your register in your application's root folder. You can still import scripts from other folders, giving you the freedom to reuse code across application scopes.</p>
<p class="calibre2"><strong class="calibre4">Scope</strong> is a valuable feature that guards against bad things happening due to external service providers or sites your customer may visit. You can think about it as a way to silo your logical business units. It is also a way to protect your applications from potential security threats if one application on your domain becomes compromised.</p>
<p class="calibre2">By default, a service worker is scoped to the folder the script resides in. The service worker is not allowed to control pages hosted at a higher folder level or in a sibling folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service worker clients</h1>
                
            
            
                
<p class="calibre2">I have mentioned the service worker clients several times in this chapter. The obvious definition is a browser tab with a site's page open. While this will be the case in most situations, it is not the only client type.</p>
<p class="calibre2">Because service workers execute in a separate context from a browser tab's UI thread, they can service multiple clients. This includes multiple tabs, push notifications, and background sync events. The latter two are clients without a traditional user interface.</p>
<p class="calibre2">The service worker specification says (<a href="https://w3c.github.io/ServiceWorker/#service-worker-client-concept" class="calibre9">https://w3c.github.io/ServiceWorker/#service-worker-client-concept</a>):</p>
<p>"A service worker client is an environment."</p>
<p class="calibre2">It goes on to define a series of potential client types. The concept of a service worker client is designed not to account for the obvious browser tab, but any process that might trigger a service worker event. For now, this includes push notifications and background sync events. The future is open as more features are being standardized to use the service worker infrastructure</p>
<p class="calibre2">The following screenshot shows the Chrome developer tools listing three different tabs that are open from the same site:</p>
<div><img src="img/00065.jpeg" class="calibre79"/></div>
<p class="calibre2">Each tab is a unique client. You can click the focus link to the right of any of the clients to immediately display the corresponding browser tab.</p>
<p class="calibre2">The following code allows you to check all of the service worker registrations for the current scope:</p>
<pre class="calibre17">navigator.serviceWorker.getRegistrations()<br class="title-page-name"/> .then(function(registrations){<br class="title-page-name"/>    registrations.forEach(function(registration) {<br class="title-page-name"/>             console.log("registration: ", registration.scope);<br class="title-page-name"/>          }, this);<br class="title-page-name"/> }); </pre>
<p class="calibre2">You may be asking, why is there a <kbd class="calibre12">getRegistrations</kbd> method when you can only have a single service worker registered for a scope? The <kbd class="calibre12">getRegistrations</kbd> function returns a list of all registered service workers within the domain.</p>
<p class="calibre2">The <kbd class="calibre12">getRegistration</kbd> method works in a similar fashion but only returns the registered service worker for the current scope:</p>
<pre class="calibre17">navigator.serviceWorker.getRegistration().then(function (registration) {<br class="title-page-name"/>     if (registration) {<br class="title-page-name"/>         console.log("registration: ", registration.scope);<br class="title-page-name"/>     }<br class="title-page-name"/> }); </pre>
<p class="calibre2">The <kbd class="calibre12">getRegistration</kbd> method has an optional parameter where you can specify a URL and it returns the service worker registration for the worker that controls the URL's scope. For example, if you supplied <kbd class="calibre12">/marketing/</kbd>, the <kbd class="calibre12">registration.scope</kbd> would return <kbd class="calibre12">{domain}/marketing/</kbd>, assuming that you have a service worker registered for that scope.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The service worker registration object</h1>
                
            
            
                
<p class="calibre2">Registering a service worker creates an entry in a service worker registry that's maintained by the user agent. When you register or call the <kbd class="calibre12">getRegistration</kbd> or <kbd class="calibre12">getRegistrations</kbd> methods, they return a reference to the matching registration object(s).</p>
<p class="calibre2">The registration object contains the following members:</p>
<p class="calibre2"><strong class="calibre4">Properties</strong></p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">scope</kbd>: The service worker's scope</li>
<li class="calibre11"><kbd class="calibre12">installing</kbd>: If the service worker is installing, it returns a <kbd class="calibre12">ServiceWorker</kbd> object, otherwise it returns undefined</li>
<li class="calibre11"><kbd class="calibre12">waiting</kbd>: If the service worker is waiting, it returns a <kbd class="calibre12">ServiceWorker</kbd> object, otherwise it returns undefined</li>
<li class="calibre11"><kbd class="calibre12">active</kbd>: If the service worker is active or activating, it returns a <kbd class="calibre12">ServiceWorker</kbd> object, otherwise it returns undefined</li>
<li class="calibre11"><kbd class="calibre12">navigationPreLoad</kbd>: Returns a reference to the service worker's <kbd class="calibre12">preLoadManager</kbd></li>
<li class="calibre11"><kbd class="calibre12">periodicSync</kbd>: Returns a reference to the service worker's <kbd class="calibre12">PeriodicSyncManager</kbd> for background synchronization</li>
<li class="calibre11"><kbd class="calibre12">pushManager</kbd>: Returns a reference to the service worker's <kbd class="calibre12">pushManager</kbd></li>
<li class="calibre11"><kbd class="calibre12">sync</kbd>: Returns a reference to the service worker's <kbd class="calibre12">syncManager</kbd></li>
</ul>
<p class="calibre2"><strong class="calibre4">Methods</strong></p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">update</kbd>: Programmatically checks for a service worker update, bypassing caches</li>
<li class="calibre11"><kbd class="calibre12">unregister</kbd>: Programmatically removes the service worker</li>
<li class="calibre11"><kbd class="calibre12">getNotifications</kbd>: Returns a promise that resolves an array of notifications for the service worker</li>
<li class="calibre11"><kbd class="calibre12">showNotifications</kbd>: Displays a notification identified by the title</li>
</ul>
<p class="calibre2"><strong class="calibre4">Event</strong></p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">onupdatefound</kbd>: Triggered any time there is a new service worker</li>
</ul>
<p class="calibre2">The following is an example of how the <kbd class="calibre12">updatefound</kbd> event might be handled. When it triggers, there should be a <kbd class="calibre12">serviceworker</kbd> object present in the registration's installing property. Here, the <kbd class="calibre12">serviceworker</kbd> object (<kbd class="calibre12">newWorker</kbd>) has had its state property interrogated:</p>
<pre class="calibre17">reg.addEventListener('updatefound', () =&gt; {   // A wild service worker <br class="title-page-name"/>//   has appeared in reg.installing!<br class="title-page-name"/>const newWorker = reg.installing;<br class="title-page-name"/>console.log("newWorker.state: ", newWorker.state);<br class="title-page-name"/>// "installing" - the install event has fired, but not yet complete<br class="title-page-name"/>// "installed"  - install complete<br class="title-page-name"/>// "activating" - the activate event has fired, but not yet complete<br class="title-page-name"/>// "activated"  - fully active<br class="title-page-name"/>// "redundant"  - discarded. Either failed install, or it's been<br class="title-page-name"/>//   replaced by a newer version<br class="title-page-name"/><br class="title-page-name"/>newWorker.addEventListener('statechange', () =&gt; {<br class="title-page-name"/>// newWorker.state has changed<br class="title-page-name"/>console.log("service worker state change");<br class="title-page-name"/>});<br class="title-page-name"/><br class="title-page-name"/>}); </pre>
<p class="calibre2">This event could be used to perform a series of logic to prepare the client for updating, including notifying the user to reload the browser to take advantage of the newer version.</p>
<p class="calibre2">The <kbd class="calibre12">update</kbd> and <kbd class="calibre12">unregister</kbd> methods will be covered in <a target="_blank" href="part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 6</a>, <em class="calibre13">Mastering the Cache API – Managing Web Assets in a Podcast Application</em>. Let's take a moment to see how push notifications work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Updating a service worker</h1>
                
            
            
                
<p class="calibre2">The following diagrams show the sequence a service worker goes through during a replacement cycle. The first diagram shows how a new service worker is registered and lives <em class="calibre13">next to</em> an existing service worker. The new service worker is not active, but hangs around, waiting for all active clients to close:</p>
<div><img src="img/00066.jpeg" class="calibre80"/></div>
<p class="calibre2">Once the clients are closed, the initial service worker dies and the new service worker begins its new active role:</p>
<div><img src="img/00067.jpeg" class="calibre81"/></div>
<p class="calibre2">After the new service worker becomes active, it is the only service worker that's alive:</p>
<div><img src="img/00068.jpeg" class="calibre82"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service worker scope</h1>
                
            
            
                
<p class="calibre2">As mentioned earlier, service workers are limited to a single domain. The domain is your site's address, such as <a href="https://podcast.love2dev.com/" target="_blank" class="calibre9">https://podcast.love2dev.com/</a>. This is a security feature. Limiting a service worker is known as the <strong class="calibre4">service worker's scope</strong>. This prevents external scripts from doing bad things to your site.</p>
<p class="calibre2">Imagine if your customer also visits your competition's web site, which installs a service worker. Without limits on service worker scope, they could conceivably manipulate your content or spy on you and your customer's private data.</p>
<p class="calibre2">In fact, a third-party script cannot register a service worker from a page on your site. This should keep external scripts and service providers from using service workers in conjunction with your domain.</p>
<p class="calibre2">A service worker is limited to the origin domain, and it is also limited to the folder in which it is physically located. This means you can register a service worker in any subfolder within the site's domain. The child script would control any request originating from its folder and below.</p>
<p class="calibre2">If another service worker were to register at a lower folder, then it would take control from that folder down and so on. Another way to think about a service worker's scope of control is downward, but not upward. A script residing in a subfolder does not execute in response to events triggered at the site's root.</p>
<p class="calibre2">Be careful about where your service worker file is located. The common practice is to store JavaScript files under a <kbd class="calibre12">/js</kbd> folder. This is fine for traditional UI JavaScript, but often leads to confusion when the service worker file is stored under the <kbd class="calibre12">js</kbd> folder. The best practice is to locate the service worker in your site's root folder or root folder of the scope it controls.</p>
<p class="calibre2">The scope determines which pages are controlled by the service worker. Once a page is controlled by a service worker, all HTTP requests originating from the page, regardless of the request URL, will trigger the service worker's fetch event.</p>
<p class="calibre2">Most of the time, this means that your service worker is located in the top folder of your domain's website. But there are many scenarios where this would not be the case. Large sites and corporate intranet sites are often collections of different, isolated applications.</p>
<p class="calibre2">In architectures where there are different application islands, each application can have its own service worker. For example, an enterprise might have sibling sites for HR, finance, and marketing. Each one can have a separate service worker. The different service workers are isolated from each other and cannot access the other applications' scope.</p>
<p class="calibre2">Each of these service workers could be registered anywhere within the site's root domain. This means you can register a child application's service worker from another scope. Each service worker is still limited in scope to the folder in which it resides and below.</p>
<p class="calibre2">The following screenshot shows that four service workers can be registered for a single site, each controlling their own scope:</p>
<div><img src="img/00069.jpeg" class="calibre83"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service worker updates</h1>
                
            
            
                
<p class="calibre2">Updating the service worker file can be a tricky concept as well. There are several factors that determine when your service worker is updated. The update cycle does not start until the browser determines that there is a new service worker file available.</p>
<p class="calibre2">Once a service worker is registered, the browser treats the file like any other file when determining if there is a new version available. It makes a request to the server, which triggers a well-known cycle.</p>
<p class="calibre2">First, there is the local browser cache (not the service worker cache) for the file. If there is a local version available that has not become stale, it is retrieved. Next, the request is sent across the network to the server. If the server responds with a 304, it means that the browser has the most current version. If the file has not changed, then the service worker update cycle does not start. If there is a newer version, the service worker is updated.</p>
<p class="calibre2">The one exception to the basic update flow is a built-in guard against large Cache-Control header values. The browser will always retrieve the service worker from the server if it has not been updated within the past 24 hours.</p>
<p class="calibre2">Cache-Control headers tell the browser how long to persist a copy of a file in browser storage. For most assets, you want a long time to cache, for example, a year, because they don't change often. This could lead to a bad situation where your application is not updated.</p>
<p class="calibre2">For static assets such as style sheets and images, a common practice is to name them using a file hash generated value and assign a very long lifetime to them. This means any updates use a new file name and trigger a new request. You can certainly employ this strategy with service workers.</p>
<p class="calibre2">If you use the same service worker file name, then you should set a short lifetime. This can vary from a few minutes to a few hours. Anything over 24 hours will be ignored by the browser.</p>
<p class="calibre2">If the browser has not checked for a new service worker version within the past 24 hours, it will force a server-side check. This was added to the spec as a safety precaution just in case you deploy a service worker that causes major problems and you cannot force an update programmatically.</p>
<p class="calibre2">This scenario could play out if you have a long cache time specified for the pages in your site that register the service worker and have done the same for the service worker script. This means that the worst-case scenario you would experience would a full day from the time the bad service worker was installed.</p>
<p class="calibre2">Not the best solution to a bad problem, but at least there is an ultimate fail-safe to bail you out. If you find yourself in this situation, you can still deploy the update immediately and users that have not installed the buggy version will be spared.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service worker events</h1>
                
            
            
                
<p class="calibre2">There are two types of service worker events: core and functional. Core messages are fundamental to what makes a service worker a service worker. Functional events can be thought of as extensions to the central service worker backbone:</p>
<p class="calibre2"><strong class="calibre4">Core Events</strong>:</p>
<ul class="calibre10">
<li class="calibre11">Install</li>
<li class="calibre11">Activate</li>
<li class="calibre11">Message</li>
</ul>
<p class="calibre2"><strong class="calibre4">Functional Events</strong>:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">fetch</kbd></li>
<li class="calibre11"><kbd class="calibre12">sync</kbd></li>
<li class="calibre11"><kbd class="calibre12">push</kbd></li>
</ul>
<p class="calibre2">Each of these events can be used to trigger processing. The install and activate events are part of the life cycle. In <a target="_blank" href="part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 7</a>, <em class="calibre13">Service Worker Caching Patterns</em>, we will dive into different caching patterns. The install and activate events are very useful to manage pre-caching assets and cleaning up your cache model.</p>
<p class="calibre2">When a new service worker is registered, the install event immediately triggers. The activate event triggers when the service worker becomes active. This means that any existing service worker is replaced with the new service worker.</p>
<p class="calibre2">The message event triggers when a message is sent from the client using the <kbd class="calibre12">postMessage</kbd> method.</p>
<p class="calibre2">Functional events are triggered in response to external actions. We have already looked at push and background sync. In <a href="" target="_blank" class="calibre9">Chapter 6</a>, <em class="calibre13">Mastering the Cache API – Managing Web Assets in a Podcast Application</em>, we will review how the Fetch API works and start down the path of caching strategies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">The service worker life cycle looks simple until you start working with service workers. Understanding how the life cycle executes is helpful so that you can understand what the state of your service worker is.</p>
<p class="calibre2">The service worker life cycle is designed to help us avoid situations where you upgrade and could potentially break the application. A new service worker can be registered, but wait for any existing clients to close. When safe, you could use the <kbd class="calibre12">skipWaiting</kbd> method to allow a new service worker to immediately take control.</p>
<p class="calibre2">More complex applications may also have multiple service workers with different scopes. This allows larger applications to silo control across the different sub applications.</p>
<p class="calibre2">Now that you have a foundation in how to use the service worker and the service worker life cycle, in the next chapter, you will see how to use the Fetch and Cache APIs to make the Podstr app work offline and save episodes to listen to anywhere, anytime.</p>


            

            
        
    </body></html>