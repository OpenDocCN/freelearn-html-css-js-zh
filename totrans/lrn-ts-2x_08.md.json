["```js\n\"experimentalDecorators\": true, \n\"emitDecoratorMetadata\": true \n```", "```js\nnpm install reflect-metadata\n```", "```js\n class Person {\n\n    public name: string; \n    public surname: string; \n\n    public constructor(name: string, surname: string) { \n        this.name = name; \n        this.surname = surname; \n    } \n\n    public saySomething(something: string): string { \n        return `${this.name} ${this.surname} says: ${something}`; \n    } \n\n} \n```", "```js\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void; \n```", "```js\nfunction logClass(target: any) { \n  // ... \n} \n```", "```js\n@logClass \nclass Person { \n  public name: string; \n  public surname: string; \n  //... \n```", "```js\nvar Person = /** @class */ (function () { \n    function Person(name, surname) { \n        this.name = name; \n        this.surname = surname; \n    } \n    Person.prototype.saySomething = function (something) { \n        return this.name + \" \" + this.surname + \" says: \" + something; \n    }; \n    Person = __decorate([ \n        logClass \n    ], Person); \n    return Person; \n}()); \n```", "```js\nfunction logClass<TFunction extends Function>(target: TFunction) { \n\n    // save a reference to the original constructor \n    const originalConstructor = target; \n\n    function logClassName(func: TFunction) { \n        console.log(\"New: \" + func.name); \n    } \n\n    // a utility function to generate instances of a class \n    function instanciate(constructor: any, ...args: any[]) { \n        return new constructor(...args); \n    } \n\n    // the new constructor behaviour \n    const newConstructor = function(...args: any[]) { \n        logClassName(originalConstructor); \n        return instanciate(originalConstructor, ...args); \n    }; \n\n    // copy prototype so instanceof operator still works \n    newConstructor.prototype = originalConstructor.prototype; \n\n    // return new constructor (will override original) \n    return newConstructor as any; \n} \n```", "```js\nconst me = new Person(\"Remo\", \"Jansen\"); \n```", "```js\n\"New: Person\"  \n```", "```js\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void; \n```", "```js\ninterface TypedPropertyDescriptor<T> { \n    enumerable?: boolean; \n    configurable?: boolean; \n    writable?: boolean; \n    value?: T; \n    get?: () => T; \n    set?: (value: T) => void; \n} \n```", "```js\nfunction logMethod(target: any, key: string, descriptor: any) { \n  // ... \n} \n```", "```js\nclass Person { \n\n    public name: string; \n    public surname: string; \n\n    public constructor(name: string, surname: string) { \n        this.name = name; \n        this.surname = surname; \n    } \n\n    @logMethod \n    public saySomething(something: string): string { \n        return `${this.name} ${this.surname} says: ${something}`; \n    } \n\n} \n```", "```js\nfunction logMethod(\n    target: any, \n    key: string, \n    descriptor: TypedPropertyDescriptor<any> \n) { \n\n    // save a reference to the original method \n    const originalMethod = descriptor.value; \n\n    function logFunctionCall(method: string, args: string, result: string) { \n        console.log(`Call: ${method}(${args}) => ${result}`); \n    } \n\n    // editing the descriptor/value parameter \n    descriptor.value = function(this: any, ...args: any[]) { \n\n        // convert method arguments to string \n        const argsStr = args.map((a: any) => { \n            return JSON.stringify(a); \n        }).join(); \n\n        // invoke method and get its return value \n        const result = originalMethod.apply(this, args); \n\n        // convert result to string \n        const resultStr = JSON.stringify(result); \n\n        // display in console the function call details \n        console.log(); \n        console.log(`Call: ${key}(${argsStr}) => ${resultStr}`); \n\n        // return the result of invoking the method \n        return result; \n    }; \n\n    // return edited descriptor \n    return descriptor; \n}\n```", "```js\nconst person = new Person(\"Michael\", \"Jackson\"); \nperson.saySomething(\"Annie, are you ok?\"); \n```", "```js\nCall: saySomething(\"Annie, are you ok?\") => \"Michael Jackson says: Annie, are you ok?\"\n```", "```js\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void; \n```", "```js\nfunction logProperty(target: any, key: string) {\n  // ... \n} \n```", "```js\nclass Person { \n\n    @logProperty \n    public name: string; \n\n    @logProperty \n    public surname: string; \n\n    public constructor(name: string, surname: string) { \n        this.name = name; \n        this.surname = surname; \n    } \n\n    public saySomething(something: string): string { \n        return `${this.name} ${this.surname} says: ${something}`; \n    } \n\n} \n```", "```js\nfunction logProperty(target: any, key: string) { \n\n    // property value \n    let _val = target[key]; \n\n    function logPropertyAccess(acces: \"Set\" | \"Get\", k: string, v: any) { \n        console.log(`${acces}: ${k} => ${v}`); \n    } \n\n    // property getter \n    const getter = function() { \n        logPropertyAccess(\"Get\", key, _val); \n        return _val; \n    }; \n\n    // property setter \n    const setter = function(newVal: any) { \n        logPropertyAccess(\"Set\", key, newVal); \n        _val = newVal; \n    }; \n\n    // Delete property. The delete operator throws \n    // in strict mode if the property is an own \n    // non-configurable property and returns \n    // false in non-strict mode. \n    if (delete target[key]) { \n        Object.defineProperty(target, key, { \n            get: getter, \n            set: setter, \n            enumerable: true, \n            configurable: true \n        }); \n}\n}\n```", "```js\nconst person = new Person(\"Michael\", \"Jackson\"); \n// Set: name => Michael \n// Set: surname => Jackson \n\nperson.saySomething(\"Annie, are you ok?\"); \n// Get: name => Michael \n// Get: surname => Jackson \n```", "```js\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void; \n```", "```js\nfunction addMetadata(target: any, key: string, index: number) {\n  // ... \n} \n```", "```js\n@logMethod \npublic saySomething(@addMetadata something: string): string { \n    return `${this.name} ${this.surname} says: ${something}`; \n} \n```", "```js\nfunction addMetadata(target: any, key: string, index: number) {\n    const metadataKey = `_log_${key}_parameters`; \n    if (Array.isArray(target[metadataKey])) { \n        target[metadataKey].push(index); \n    } else { \n        target[metadataKey] = [index]; \n    } \n} \n```", "```js\n@readMetadata \npublic saySomething(@addMetadata something: string): string { \n    return `${this.name} ${this.surname} says: ${something}`; \n} \n```", "```js\nfunction readMetadata(target: any, key: string, descriptor: any) {\n\n    const originalMethod = descriptor.value; \n\n    descriptor.value = function(...args: any[]) { \n\n        const metadataKey = `_log_${key}_parameters`; \n        const indices = target[metadataKey]; \n\n        if (Array.isArray(indices)) { \n\n            for (let i = 0; i < args.length; i++) { \n\n                if (indices.indexOf(i) !== -1) { \n                    const arg = args[i]; \n                    const argStr = JSON.stringify(arg); \n                    console.log(`${key} arg[${i}]: ${argStr}`); \n                } \n            } \n\n            return originalMethod.apply(this, args); \n\n        } \n\n    }; \n\n    return descriptor; \n}\n```", "```js\nconst person = new Person(\"Remo\", \"Jansen\"); \nperson.saySomething(\"hello!\"); \n```", "```js\nsaySomething arg[0]: \"hello!\" \n```", "```js\n@logClass(\"option\") \nclass Person { \n// ... \n```", "```js\nfunction logClass(option: string) { \n    return function(target: any) { \n        // class decorator logic goes here \n        // we have access to the decorator parameters \n        console.log(target, option); \n    }; \n} \n```", "```js\nnpm install reflect-metadata \n```", "```js\nimport \"reflect-metadata\"; \n```", "```js\n\"types\": [ \n  \"reflect-metadata\" \n] \n```", "```js\nclass Demo1 { \n    @logType \n    public attr1: string; \n    public constructor(attr1: string) { \n        this.attr1 = attr1; \n    } \n} \n```", "```js\nfunction logType(target: any, key: string) { \n    const type = Reflect.getMetadata(\"design:type\", target, key); \n    console.log(`${key} type: ${type.name}`); \n} \n```", "```js\n    'attr1 type: String'  \n```", "```js\nclass Foo {} \ninterface FooInterface {} \n\nclass Demo2 { \n    @logParamTypes \n    public doSomething( \n        param1: string, \n        param2: number, \n        param3: Foo, \n        param4: { test: string }, \n        param5: FooInterface, \n        param6: Function, \n        param7: (a: number) => void \n    ): number { \n        return 1; \n    } \n}\n```", "```js\nfunction logParamTypes(target: any, key: string) {\n    const types = Reflect.getMetadata( \n        \"design:paramtypes\", \n        target, \n        key \n    ); \n    const s = types.map((a: any) => a.name).join(); \n    console.log(`${key} param types: ${s}`); \n} \n```", "```js\n    'doSomething param types: String, Number, Foo, Object, Object, \n Function, Function'\n\n```", "```js\nclass Demo3 { \n    @logReturntype \n    public doSomething2(): string { \n        return \"test\"; \n    } \n} \n```", "```js\nfunction logReturntype(target: any, key: string) { \n    const returnType = Reflect.getMetadata( \n        \"design:returntype\", \n        target, \n        key \n    ); \n    console.log(`${key} return type: ${returnType.name}`); \n} \n```", "```js\n    'doSomething2 return type: String'\n\n```", "```js\n@logClass \nclass Person { \n\n    @logProperty \n    public name: string; \n\n    @logProperty \n    public surname: string; \n\n    public constructor(name: string, surname: string) { \n        this.name = name; \n        this.surname = surname; \n    } \n\n    @readMetadata \n    public saySomething(@addMetadata something: string): string { \n        return `${this.name} ${this.surname} says: ${something}`; \n    } \n} \n```", "```js\n@log \nclass Person { \n\n    @log \n    public name: string; \n\n    @log \n    public surname: string; \n\n    public constructor(name: string, surname: string) { \n        this.name = name; \n        this.surname = surname; \n    } \n\n    @log \n    public saySomething(@log something: string): string { \n        return `${this.name} ${this.surname} says: ${something}`; \n    } \n} \n```", "```js\nfunction decoratorFactory( \n    classDecorator: Function, \n    propertyDecorator: Function, \n    methodDecorator: Function, \n    parameterDecorator: Function \n) { \n    return function (this: any, ...args: any[]) { \n        const nonNullableArgs = args.filter(a => a !== undefined); \n        switch (nonNullableArgs.length) { \n            case 1: \n                return classDecorator.apply(this, args); \n            case 2: \n                // break instead of return as property \n                // decorators don't have a return \n                propertyDecorator.apply(this, args); \n                break; \n            case 3: \n                if (typeof args[2] === \"number\") { \n                    parameterDecorator.apply(this, args); \n                } else { \n                    return methodDecorator.apply(this, args); \n                } \n                break; \n            default: \n                throw new Error(\"Decorators are not valid here!\"); \n        } \n    }; \n} \n```", "```js\nconst log = decoratorFactory( \n    logClass, \n    logProperty, \n    readMetadata, \n    addMetadata \n); \n```"]