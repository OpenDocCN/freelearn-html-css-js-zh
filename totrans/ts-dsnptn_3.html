<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Behavioral Design Patterns</h1></div></div></div><p>As the name suggests, behavioral design patterns are patterns about how objects or classes interact with each other. The implementation of behavioral design patterns usually requires certain data structures to support the interaction in a system. However, behavioral patterns and structural patterns focus on different aspects when applied. As a result, you might find patterns in the category of behavioral design patterns usually have simpler or more straightforward structures compared to structural design patterns.</p><p>In this chapter, we are going to talk about some of the following common behavioral patterns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Chain of Responsibility</strong>: Organizes behaviors with different scopes</li><li class="listitem" style="list-style-type: disc"><strong>Command</strong>: Exposes commands from the internal with encapsulated context</li><li class="listitem" style="list-style-type: disc"><strong>Memento</strong>: Provides an approach for managing states outside of their owners without exposing detailed implementations</li><li class="listitem" style="list-style-type: disc"><strong>Iterator</strong>: Provides a universal interface for traversing</li><li class="listitem" style="list-style-type: disc"><strong>Mediator</strong>: It groups coupling and logically related objects and makes interconnections cleaner in a system that manages many objects</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Chain of Responsibility Pattern</h1></div></div></div><p>There are many scenarios under which we might want to apply certain actions that can fall back from a detailed scope to a more general one.</p><p>A nice example would be the help information of a GUI application: when a user requests help information for a certain part of the user interface, it is expected to show information as specific as possible. This can be done with different implementations, and the most intuitive one for a web developer could be events bubbling.</p><p>Consider a DOM structure like this:</p><pre class="programlisting">&lt;div class="outer"&gt; &#13;
  &lt;div class="inner"&gt; &#13;
    &lt;span class="origin"&gt;&lt;/span&gt; &#13;
  &lt;/div&gt; &#13;
&lt;/div&gt; &#13;
</pre><p>If a user clicks on the <code class="literal">span.origin</code> element, a <code class="literal">click</code> event would start bubbling from the <code class="literal">span</code> element to the document root (if <code class="literal">useCapture</code> is <code class="literal">false</code>):</p><pre class="programlisting">$('.origin').click(event =&gt; { &#13;
  console.log('Click on `span.origin`.'); &#13;
}); &#13;
 &#13;
$('.outer').click(event =&gt; { &#13;
  console.log('Click on `div.outer`.'); &#13;
}); &#13;
</pre><p>By default, it will trigger both event listeners added in the preceding code. To stop the propagation as soon as an event gets handled, we can call its <code class="literal">stopPropagation</code> method:</p><pre class="programlisting">$('.origin').click(event =&gt; { &#13;
  console.log('Click on `span.origin`.'); &#13;
<strong>  event.stopPropagation();</strong> &#13;
}); &#13;
 &#13;
$('.outer').click(event =&gt; { &#13;
  Console.log('Click on `div.outer`.'); &#13;
}); &#13;
</pre><p>Though a <code class="literal">click</code> event is not exactly the same as the help information request, with the support of custom events, it's quite easy to handle help information with necessary detailed or general information in the same chain.</p><p>Another important implementation of the Chain of Responsibility Pattern is related to error handling. A primitive example for this could be using <code class="literal">try...catch</code>. Consider code like this: we have three functions: <code class="literal">foo</code>, <code class="literal">bar</code>, and <code class="literal">biu</code>, <code class="literal">foo</code> is called by <code class="literal">bar</code> while <code class="literal">bar</code> is called by <code class="literal">biu</code>:</p><pre class="programlisting">function foo() { &#13;
  // throw some errors. &#13;
} &#13;
 &#13;
function bar() { &#13;
  foo(); &#13;
} &#13;
 &#13;
function biu() { &#13;
  bar(); &#13;
} &#13;
 &#13;
biu(); &#13;
</pre><p>Inside both functions <code class="literal">bar</code> and <code class="literal">biu</code>, we can do some error catching. Assuming function <code class="literal">foo</code> throws two kinds of errors:</p><pre class="programlisting">function foo() { &#13;
  let value = Math.random(); &#13;
 &#13;
  if (value &lt; 0.5) { &#13;
    throw new Error('Awesome error'); &#13;
  } else if (value &lt; 0.8) { &#13;
    throw new TypeError('Awesome type error'); &#13;
  } &#13;
} &#13;
</pre><p>In function <code class="literal">bar</code> we would like to handle the <code class="literal">TypeError</code> and leave other errors throwing on:</p><pre class="programlisting">function bar() { &#13;
  try { &#13;
    foo(); &#13;
  } catch (error) { &#13;
    if (error instanceof TypeError) { &#13;
      console.log('Some type error occurs', error); &#13;
    } else { &#13;
      throw error; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>And in function <code class="literal">biu</code>, we would like to add more general handling that catches all the errors so that the program will not crash:</p><pre class="programlisting">function biu() { &#13;
  try { &#13;
    bar(); &#13;
  } catch (error) { &#13;
    console.log('Some error occurs', error); &#13;
  } &#13;
} &#13;
</pre><p>So by using <code class="literal">try...catch</code> statements, you may have been using the Chain of Responsibility Pattern constantly without paying any attention to it. Just like you may have been using other well-known design patterns all the time.</p><p>If we abstract the structure of Chain of Responsibility Pattern into objects, we could have something as illustrated in the figure:</p><p>
</p><div><img src="img/image_05_001.jpg" alt="Chain of Responsibility Pattern"/></div><p>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Participants</h2></div></div></div><p>The participants of the Chain of Responsibility Pattern include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Handler</strong>: Defines the interface of the handler with successor and method to handle requests. This is done implicitly with classes like <code class="literal">EventEmitter</code> and <code class="literal">try...catch</code> syntax.</li><li class="listitem" style="list-style-type: disc"><strong>Concrete handler</strong>: <code class="literal">EventListener</code>, <code class="literal">catch</code> block and <code class="literal">HandlerA</code>/<code class="literal">HandlerB</code> in the class version. Defines handlers in the form of callbacks, code blocks and classes that handle requests.</li><li class="listitem" style="list-style-type: disc"><strong>Client</strong>: Initiates the requests that go through the chain.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Pattern scope</h2></div></div></div><p>The Chain of Responsibility Pattern itself could be applied to many different scopes in a program. It requires a multi-level chain to work, but this chain could be in different forms. We've been playing with events as well as <code class="literal">try...catch</code> statements that have structural levels, this pattern could also be applied to scenarios that have logical levels.</p><p>Consider objects marked with different scopes using string:</p><pre class="programlisting">let objectA = { &#13;
  scope: 'user.installation.package' &#13;
}; &#13;
 &#13;
let objectB = { &#13;
  scope: 'user.installation' &#13;
}; &#13;
</pre><p>Now we have two objects with related scopes specified by string, and by adding filters to these scope strings, we can apply operations from specific ones to general ones.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Implementation</h2></div></div></div><p>In this part, we are going to implement the class version we've mentioned at the end of the introduction to the Chain of Responsibility Pattern. Consider requests that could either ask for help information or feedback prompts:</p><pre class="programlisting">type RequestType = 'help' | 'feedback'; &#13;
 &#13;
interface Request { &#13;
  type: RequestType; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note38"/>Note</h3><p>We are using string literal type here with union type. It is a pretty useful feature provided in TypeScript that plays well with existing JavaScript coding styles.
See the following link for more information: <a class="ulink" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html">http://www.typescriptlang.org/docs/handbook/advanced-types.html</a>.</p></div></div><p>One of the key processes for this pattern is going through the handlers' chain and finding out the most specific handler that's available for the request. There are several ways to achieve this: by recursively invoking the <code class="literal">handle</code> method of a successor, or having a separate logic walking through the handler successor chain until the request is confirmed as handled.</p><p>The logic walking through the chain in the second way requires the acknowledgment of whether a request has been properly handled. This can be done either by a state indicator on the request object or by the return value of the <code class="literal">handle</code> method.</p><p>We'll go with the recursive implementation in this part. Firstly, we want the default handling behavior of a handler to be forwarding requests to its successor if any:</p><pre class="programlisting">class Handler { &#13;
  private successor: Handler; &#13;
 &#13;
  handle(request: Request): void { &#13;
    if (this.successor) { &#13;
      this.successor.handle(request); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>And now for <code class="literal">HelpHandler</code>, it handles help requests but forwards others:</p><pre class="programlisting">class HelpHandler extends Handler { &#13;
  handle(request: Request): void { &#13;
    if (request.type === 'help') { &#13;
      // Show help information. &#13;
    } else { &#13;
      super.handle(request); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The code for <code class="literal">FeedbackHandler</code> is similar:</p><pre class="programlisting">class FeedbackHandler extends Handler { &#13;
  handle(request: Request): void { &#13;
    if (request.type === 'feedback') { &#13;
      // Prompt for feedback. &#13;
    } else { &#13;
      super.handle(request); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>Thus, a chain of handlers could be made up in some way. And if a request got in this chain, it would be passed on until a handler recognizes and handles it. However, it is not necessary to have all requests <em>handled</em> after processing them. The handlers can always pass a request on whether this request gets processed by this handler or not.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Consequences</h2></div></div></div><p>The Chain of Responsibility Pattern decouples the connection between objects that issue the requests and logic that handles those requests. The sender assumes that its requests could, but not necessarily, be properly handled without knowing the details. For some implementations, it is also very easy to add new responsibilities to a specific handler on the chain. This provides notable flexibility for handling requests.</p><p>Besides the examples we've been talking about, there is another important mutation of <code class="literal">try...catch</code> that can be treated in the Chain of Responsibility Pattern - Promise. Within a smaller scope, the chain could be represented as:</p><pre class="programlisting">promise &#13;
  .catch(TypeError, reason =&gt; { &#13;
    // handles TypeError. &#13;
  }) &#13;
  .catch(ReferenceError, reason =&gt; { &#13;
    // handles ReferenceError. &#13;
  }) &#13;
  .catch(reason =&gt; { &#13;
    // handles other errors. &#13;
  }); &#13;
</pre><div><div><h3 class="title"><a id="note39"/>Note</h3><p>The standard <code class="literal">catch</code> method on an ES Promise object does not provide the overload that accepts an error type as a parameter, but many implementations do.</p></div></div><p>In a larger scope, this chain would usually appear when the code is playing with third-party libraries. A common usage would be converting errors produced by other libraries to errors known to the current project. We'll talk more about error handling of asynchronous code later in this book.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Command Pattern</h1></div></div></div><p>Command Pattern involves encapsulating operations as executable commands and could either be in the form of objects or functions in JavaScript. It is common that we may want to make operations rely on certain context and states that are not accessible for the invokers. By storing those pieces of information with a command and passing it out, this situation could be properly handled.</p><p>Consider an extremely simple example: we want to provide a function called <code class="literal">wait</code>, which returns a <code class="literal">cancel</code> handler:</p><pre class="programlisting">function wait() { &#13;
  let $layer = $('.wait-layer'); &#13;
   &#13;
  $layer.show(); &#13;
   &#13;
  return () =&gt; { &#13;
    $layer.hide(); &#13;
  }; &#13;
} &#13;
 &#13;
let cancel = wait(); &#13;
 &#13;
setTimeout(() =&gt; cancel(), 1000); &#13;
</pre><p>The <code class="literal">cancel</code> handler in the preceding code is just a command we were talking about. It stores the context (<code class="literal">$layer</code>) using closure and is passed out as the return value of function <code class="literal">wait</code>.</p><p>Closure in JavaScript provides a really simple way to store command context and states, however, the direct disadvantage would be compromised flexibility between context/states and command functions because closure is lexically determined and cannot be changed at runtime. This would be okay if the command is only expected to be invoked with fixed context and states, but for more complex situations, we might need to construct them as objects with a proper data structure.</p><p>The following diagram shows the overall relations between participants of Command Pattern:</p><p>
</p><div><img src="img/image_05_002.jpg" alt="Command Pattern"/></div><p>
</p><p>By properly splitting apart context and states with the command object, Command Pattern could also play well with Flyweight Pattern if you wanted to reuse command objects multiple times.</p><p>Other common extensions based on Command Pattern include undo support and macros with multiple commands. We are going to play with those later in the implementation part.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Participants</h2></div></div></div><p>The participants of Command Pattern include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Command</strong>: Defines the general interface of commands passing around, it could be a function signature if the commands are in the form of functions.</li><li class="listitem" style="list-style-type: disc"><strong>Concrete command</strong>: Defines the specific behaviors and related data structure. It could also be a function that matches the signature declared as <code class="literal">Command</code>. The <code class="literal">cancel</code> handler in the very first example is a concrete command.</li><li class="listitem" style="list-style-type: disc"><strong>Context</strong>: The context or receiver that the command is associated with. In the first example, it is the <code class="literal">$layer</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Client</strong>: Creates concrete commands and their contexts.</li><li class="listitem" style="list-style-type: disc"><strong>Invoker</strong>: Executes concrete commands.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Pattern scope</h2></div></div></div><p>Command Pattern suggests two separate parts in a single application or a larger system: <em>client</em> and <em>invoker</em>. In the simplified example <code class="literal">wait</code> and <code class="literal">cancel</code>, it could be hard to distinguish the difference between those parts. But the line is clear: <em>client</em> knows or controls the context of commands to be executed with, while <em>invoker</em> does not have access or does not need to care about that information.</p><p>The key to the Command Pattern is the separation and bridging between those two parts through commands that store context and states.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Implementation</h2></div></div></div><p>It's common for an editor to expose commands for third-party extensions to modify the text content. Consider a <code class="literal">TextContext</code> that contains information about the text file being edited and an abstract <code class="literal">TextCommand</code> class associated with that context:</p><pre class="programlisting">class TextContext { &#13;
  content = 'text content'; &#13;
} &#13;
 &#13;
abstract class TextCommand { &#13;
  constructor( &#13;
    public context: TextContext &#13;
  ) { } &#13;
 &#13;
  abstract execute(...args: any[]): void; &#13;
} &#13;
</pre><p>Certainly, <code class="literal">TextContext</code> could contain much more information like language, encoding, and so on. You can add them in your own implementation for more functionality. Now we are going to create two commands: <code class="literal">ReplaceCommand</code> and <code class="literal">InsertCommand</code>.</p><pre class="programlisting">class ReplaceCommand extends TextCommand { &#13;
  execute(index: number, length: number, text: string): void { &#13;
    let content = this.context.content; &#13;
 &#13;
    this.context.content = &#13;
      content.substr(0, index) + &#13;
      text + &#13;
      content.substr(index + length); &#13;
  } &#13;
} &#13;
 &#13;
class InsertCommand extends TextCommand { &#13;
  execute(index: number, text: string): void { &#13;
    let content = this.context.content; &#13;
 &#13;
    this.context.content = &#13;
      content.substr(0, index) + &#13;
      text + &#13;
      content.substr(index); &#13;
  } &#13;
} &#13;
</pre><p>Those two commands share similar logic and actually <code class="literal">InsertCommand</code> can be treated as a subset of <code class="literal">ReplaceCommand</code>. Or if we have a new delete command, then replace command can be treated as the combination of delete and insert commands.</p><p>Now let's assemble those commands with the client and invoker:</p><pre class="programlisting">class Client { &#13;
  private context = new TextContext(); &#13;
 &#13;
  replaceCommand = new ReplaceCommand(this.context); &#13;
  insertCommand = new InsertCommand(this.context); &#13;
} &#13;
 &#13;
let client = new Client(); &#13;
 &#13;
$('.replace-button').click(() =&gt; { &#13;
  client.replaceCommand.execute(0, 4, 'the'); &#13;
}); &#13;
 &#13;
$('.insert-button').click(() =&gt; { &#13;
  client.insertCommand.execute(0, 'awesome '); &#13;
}); &#13;
</pre><p>If we go further, we can actually have a command that executes other commands. Namely, we can have macro commands. Though the preceding example alone does not make it necessary to create a macro command, there would be scenarios where macro commands help. As those commands are already associated with their contexts, a macro command usually does not need to have an explicit context:</p><pre class="programlisting">interface TextCommandInfo { &#13;
  command: TextCommand, &#13;
  args: any[]; &#13;
} &#13;
 &#13;
class MacroTextCommand { &#13;
  constructor( &#13;
    public infos: TextCommandInfo[] &#13;
  ) { } &#13;
 &#13;
  execute(): void { &#13;
    for (let info of this.infos) { &#13;
      info.command.execute(...info.args); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Consequences</h2></div></div></div><p>Command Pattern decouples the client (who knows or controls context) and the invoker (who has no access to or does not care about detailed context).</p><p>It plays well with Composite Pattern. Consider the example of macro commands we mentioned above: a macro command can have other macro commands as its components, thus we make it a composite command.</p><p>Another important case of Command Pattern is adding support for undo operations. A direct approach is to add the <code class="literal">undo</code> method to every command. When an undo operation is requested, invoke the <code class="literal">undo</code> method of commands in reverse order, and we can pray that every command would be undone correctly. However, this approach relies heavily on a flawless implementation of the <code class="literal">undo</code> method as every mistake will accumulate. To implement more stable undo support, redundant information or snapshots could be stored.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Memento Pattern</h1></div></div></div><p>We've talked about an undo support implementation in the previous section on the Command Pattern, and found it was not easy to implement the mechanism purely based on reversing all the operations. However, if we take snapshots of objects as their history, we may manage to avoid accumulating mistakes and make the system more stable. But then we have a problem: we need to store the states of objects while the states are encapsulated with objects themselves.</p><p>Memento Pattern helps in this situation. While a memento carries the state of an object at a certain time point, it also controls the process of setting the state back to an object. This makes the internal state implementation hidden from the undo mechanism in the following example:</p><p>
</p><div><img src="img/image_05_003.jpg" alt="Memento Pattern"/></div><p>
</p><p>We have the instances of the memento controlling the state restoration in the preceding structure. It can also be controlled by the caretaker, namely the undo mechanism, for simple state restoring cases.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Participants</h2></div></div></div><p>The participants of Memento Pattern include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Memento</strong>: Stores the state of an object and defines method <code class="literal">restore</code> or other APIs for restoring the states to specific objects</li><li class="listitem" style="list-style-type: disc"><strong>Originator</strong>: Deals with objects that need to have their internal states stored</li><li class="listitem" style="list-style-type: disc"><strong>Caretaker</strong>: Manages mementos without intervening with what's inside</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Pattern scope</h2></div></div></div><p>Memento Pattern mainly does two things: it prevents the caretaker from knowing the internal state implementation and decouples the state retrieving and restoring process from states managed by the <code class="literal">Caretaker</code> or <code class="literal">Originator.</code>
</p><p>When the state retrieving and restoring processes are simple, having separated mementos does not help much if you are already keeping the decoupling idea in mind.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec82"/>Implementation</h2></div></div></div><p>Start with an empty <code class="literal">State</code> interface and <code class="literal">Memento</code> class. As we do not want <code class="literal">Caretaker</code> to know the details about state inside an <code class="literal">Originator</code> or <code class="literal">Memento</code>, we would like to make <code class="literal">state</code> property of <code class="literal">Memento</code> private. Having restoration logic inside <code class="literal">Memento</code> does also help with this, and thus we need method <code class="literal">restore</code>. So that we don't need to expose a public interface for reading state inside a memento.</p><p>And as an object assignment in JavaScript assigns only its reference, we would like to do a quick copy for the states (assuming state objects are single-level):</p><pre class="programlisting">interface State { } &#13;
 &#13;
class Memento { &#13;
  private state: State; &#13;
 &#13;
  constructor(state: State) { &#13;
    this.state = Object.assign({} as State, state); &#13;
  } &#13;
 &#13;
  restore(state: State): void { &#13;
    Object.assign(state, this.state); &#13;
  } &#13;
} &#13;
</pre><p>For <code class="literal">Originator</code> we use a getter and a setter for creating and restoring specific mementos:</p><pre class="programlisting">class Originator { &#13;
  state: State; &#13;
 &#13;
  get memento(): Memento { &#13;
    return new Memento(this.state); &#13;
  } &#13;
 &#13;
  set memento(memento: Memento) { &#13;
    memento.restore(this.state); &#13;
  } &#13;
} &#13;
</pre><p>Now the <code class="literal">Caretaker</code> would manage the history accumulated with mementos:</p><pre class="programlisting">class Caretaker { &#13;
  originator: Originator; &#13;
  history: Memento[] = []; &#13;
 &#13;
  save(): void { &#13;
    this.history.push(this.originator.memento); &#13;
  } &#13;
 &#13;
  restore(): void { &#13;
    this.originator.memento = this.history.shift(); &#13;
  } &#13;
} &#13;
</pre><p>In some implementations of Memento Pattern, a <code class="literal">getState</code> method is provided for instances of <code class="literal">Originator</code> to read state from a memento. But to prevent classes other than <code class="literal">Originator</code> from accessing the <code class="literal">state</code> property, it may rely on language features like a <em>friend modifier</em> to restrict the access (which is not yet available in TypeScript).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Consequences</h2></div></div></div><p>Memento Pattern makes it easier for a caretaker to manage the states of originators and it becomes possible to extend state retrieving and restoring. However, a perfect implementation that seals everything might rely on language features as we've mentioned before. Using mementos could also bring a performance cost as they usually contain redundant information in trade of stability.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Iterator Pattern</h1></div></div></div><p>Iterator Pattern provides a universal interface for accessing internal elements of an aggregate without exposing the underlying data structure. A typical iterator contains the following methods or getters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">first()</code>: moves the cursor to the <em>first</em> element in the aggregates</li><li class="listitem" style="list-style-type: disc"><code class="literal">next()</code>: moves the cursor to the <em>next</em> element</li><li class="listitem" style="list-style-type: disc"><code class="literal">end</code>: a getter that returns a Boolean indicates whether the cursor is at the end</li><li class="listitem" style="list-style-type: disc"><code class="literal">item</code>: a getter that returns the element at the position of the current cursor</li><li class="listitem" style="list-style-type: disc"><code class="literal">index</code>: a getter that returns the index of the element at the current cursor</li></ul></div><p>Iterators for aggregates with different interfaces or underlying structures usually end with different implementations as shown in the following figure:</p><p>
</p><div><img src="img/image_05_004.jpg" alt="Iterator Pattern"/></div><p>
</p><p>Though the client does not have to worry about the structure of an aggregate, an iterator would certainly need to. Assuming we have everything we need to build an iterator, there could be a variety of ways for creating one. The factory method is widely used when creating iterators, or a <em>factory getter</em> if no parameter is required.</p><p>Starting with ES6, syntax sugar <code class="literal">for...of</code> is added and works for all objects with property <code class="literal">Symbol.iterator</code>. This makes it even easier and more comfortable for developers to work with customized lists and other classes that can be iterated.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec84"/>Participants</h2></div></div></div><p>The participants of Iterator Pattern include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Iterator</strong>: <code class="literal">AbstractListIterator</code><p>Defines the universal iterator interface that is going to transverse different aggregates.</p></li><li class="listitem" style="list-style-type: disc"><strong>Concrete iterator</strong>: <code class="literal">ListIterator</code>, <code class="literal">SkipListIterator</code> and <code class="literal">ReversedListIterator</code><p>Implements specific iterator that transverses and keeps track of a specific aggregate.</p></li><li class="listitem" style="list-style-type: disc"><strong>Aggregate</strong>: <code class="literal">AbstractList</code><p>Defines a basic interface of aggregates that iterators are going to work with.</p></li><li class="listitem" style="list-style-type: disc"><strong>Concreate aggregate</strong>: <code class="literal">List</code> and <code class="literal">SkipList</code><p>Defines the data structure and factory method/getter for creating associated iterators.</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec85"/>Pattern scope</h2></div></div></div><p>Iterator Pattern provides a unified interface for traversing aggregates. In a system that doesn't rely on iterators, the main functionality provided by iterators could be easily taken over by simple helpers. However, the reusability of those helpers could be reduced as the system grows.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec86"/>Implementation</h2></div></div></div><p>In this part, we are going to implement a straightforward array iterator, as well as an ES6 iterator.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec32"/>Simple array iterator</h3></div></div></div><p>Let's start by creating an iterator for a JavaScript array, which should be extremely easy. Firstly, the universal interface:</p><pre class="programlisting">interface Iterator&lt;T&gt; { &#13;
  first(): void; &#13;
  next(): void; &#13;
  end: boolean; &#13;
  item: T; &#13;
  index: number; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note40"/>Note</h3><p>Please notice that the TypeScript declaration for ES6 has already declared an interface called <code class="literal">Iterator</code>. Consider putting the code in this part into a namespace or module to avoid conflicts.</p></div></div><p>And the implementation of a simple array iterator could be:</p><pre class="programlisting">class ArrayIterator&lt;T&gt; implements Iterator&lt;T&gt; { &#13;
  index = 0; &#13;
 &#13;
  constructor( &#13;
    public array: T[] &#13;
  ) { } &#13;
 &#13;
  first(): void { &#13;
    this.index = 0; &#13;
  } &#13;
 &#13;
  next(): void { &#13;
    this.index++; &#13;
  } &#13;
 &#13;
  get end(): boolean { &#13;
    return this.index &gt;= this.array.length; &#13;
  } &#13;
 &#13;
  get item(): T { &#13;
    return this.array[this.index]; &#13;
  } &#13;
} &#13;
</pre><p>Now we need to extend the prototype of native <code class="literal">Array</code> to add an <code class="literal">iterator</code> getter:</p><pre class="programlisting">Object.defineProperty(Array.prototype, 'iterator', { &#13;
  get() { &#13;
    return new ArrayIterator(this); &#13;
  } &#13;
}); &#13;
</pre><p>To make <code class="literal">iterator</code> a valid property of the  <code class="literal">Array</code> instance, we also need to extend the interface of <code class="literal">Array</code>:</p><pre class="programlisting">interface Array&lt;T&gt; { &#13;
  iterator: IteratorPattern.Iterator&lt;T&gt;; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note41"/>Note</h3><p>This should be written outside the namespace under the global scope. Or if you are in a module or ambient module, you might want to try <code class="literal">declare global { ... }</code> for adding new properties to existing global interfaces.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec33"/>ES6 iterator</h3></div></div></div><p>ES6 provides syntax sugar <code class="literal">for...of</code> and other helpers for <em>iterable</em> objects, namely the objects that have implemented the <code class="literal">Iterable</code> interface of the following:</p><pre class="programlisting">interface IteratorResult&lt;T&gt; { &#13;
  done: boolean; &#13;
  value: T; &#13;
} &#13;
 &#13;
interface Iterator&lt;T&gt; { &#13;
  next(value?: any): IteratorResult&lt;T&gt;; &#13;
  return?(value?: any): IteratorResult&lt;T&gt;; &#13;
  throw?(e?: any): IteratorResult&lt;T&gt;; &#13;
} &#13;
 &#13;
interface Iterable&lt;T&gt; { &#13;
  [Symbol.iterator](): Iterator&lt;T&gt;; &#13;
} &#13;
</pre><p>Assume we have a class with the following structure:</p><pre class="programlisting">class SomeData&lt;T&gt; { &#13;
  array: T[]; &#13;
} &#13;
</pre><p>And we would like to make it iterable. More specifically, we would like to make it iterates reversely. As the <code class="literal">Iterable</code> interface suggests, we just need to add a method with a special name <code class="literal">Symbol.iterator</code> for creating an <code class="literal">Iterator</code>. Let's call the iterator <code class="literal">SomeIterator</code>:</p><pre class="programlisting">class SomeIterator&lt;T&gt; implements Iterator&lt;T&gt; { &#13;
  index: number; &#13;
 &#13;
  constructor( &#13;
    public array: T[] &#13;
  ) { &#13;
    this.index = array.length - 1; &#13;
  } &#13;
 &#13;
  next(): IteratorResult&lt;T&gt; { &#13;
    if (this.index &lt;= this.array.length) { &#13;
      return { &#13;
        value: undefined, &#13;
        done: true &#13;
      }; &#13;
    } else { &#13;
      return { &#13;
        value: this.array[this.index--], &#13;
        done: false &#13;
      } &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>And then define the <code class="literal">iterator</code> method:</p><pre class="programlisting">class SomeData&lt;T&gt; { &#13;
  array: T[]; &#13;
 &#13;
<strong>  [Symbol.iterator]() {</strong>
<strong>    &#13;
    return new SomeIterator&lt;T&gt;(this.array);&#13;
</strong>
<strong>  }</strong> &#13;
} &#13;
</pre><p>Now we would have <code class="literal">SomeData</code> that works with <code class="literal">for...of</code>.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Iterators also play well with generators; see the following link for more examples: <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols</a>.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec87"/>Consequences</h2></div></div></div><p>Iterator Pattern decouples iteration usage from the data structure that is being iterated. The direct benefit of this is enabling an interchangeable data class that may have completely different internal structures, like an array and binary tree. Also, one data structure can be iterated via different iterators with different traversal mechanisms and results in different orders and efficiencies.</p><p>A unified iterator interface in one system could also help the developer from being confused when facing different aggregates. As we mentioned previously, some language like your beloved JavaScript provides a language level abstraction for iterators and makes life even easier.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Mediator Pattern</h1></div></div></div><p>The connections between UI components and related objects could be extremely complex. Object-oriented programming distributes functionalities among objects. This makes coding easier with cleaner and more intuitive logic; however, it does not ensure the reusability and sometimes makes it difficult to understand if you look at the code again after some days (you may still understand every single operation but would be confused about the interconnections if the network becomes really intricate).</p><p>Consider a page for editing user profile. There are standalone inputs like nickname and tagline, as well as inputs that are related to each other. Taking location selection for example, there could easily be a tree-level location and the options available in lower levels are determined by the selection of higher levels. However, if those objects are managed directly by a single huge controller, it will result in a page that has limited reusability. The code formed under this situation would also tend to have a hierarchy that's less clean for people to understand.</p><p>Mediator Pattern tries to solve this problem by separating coupling elements and objects as groups, and adding a <em>director</em> between a group of elements and other objects as shown in the following figure:</p><p>
</p><div><img src="img/image_05_005.jpg" alt="Mediator Pattern"/></div><p>
</p><p>Those objects form a mediator with their colleagues that can interact with other objects as a single object. With proper encapsulation, the mediator will have better reusability as it has just the right size and properly divided functionality. In the world of web front end development, there are concepts or implementations that fit Mediator Pattern well, like <em>Web Component</em> and <em>React</em>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec88"/>Participants</h2></div></div></div><p>The participants of Mediator Pattern include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mediator</strong>:<p>Usually, the abstraction or skeleton predefined by a framework. Defines the interface that colleagues in a mediator communicate through.</p></li><li class="listitem" style="list-style-type: disc"><strong>Concrete mediator</strong>: <code class="literal">LocationPicker</code><p>Manages the colleagues and makes them cooperate, providing a higher level interface for objects outside.</p></li><li class="listitem" style="list-style-type: disc"><strong>Colleague classes</strong>: <code class="literal">CountryInput</code>, <code class="literal">ProvinceInput</code>, <code class="literal">CityInput</code><p>Defines references to their mediator and notifies its changes to the mediator and accepts modifications issued by the mediator.</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec89"/>Pattern scope</h2></div></div></div><p>Mediator Pattern could connect many parts of a project, but does not have direct or enormous impact on the outline. Most of the credit is given because of increased usability and cleaner interconnections introduced by mediators. However, along with a nice overall architecture, Mediator Pattern can help a lot with refined code quality, and make the project easier to maintain.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>Implementation</h2></div></div></div><p>Using libraries like React would make it very easy to implement Mediator Pattern, but for now, we are going with a relatively primitive way and handle changes by hand. Let's think about the result we want for a <code class="literal">LocationPicker</code> we've discussed, and hopefully, it includes <code class="literal">country</code>, <code class="literal">province</code> and <code class="literal">city</code> fields:</p><pre class="programlisting">interface LocationResult { &#13;
  country: string; &#13;
  province: string; &#13;
  city: string; &#13;
} &#13;
</pre><p>And now we can sketch the overall structure of class <code class="literal">LocationPicker</code>:</p><pre class="programlisting">class LocationPicker { &#13;
  $country = $(document.createElement('select')); &#13;
  $province = $(document.createElement('select')); &#13;
  $city = $(document.createElement('select')); &#13;
 &#13;
  $element = $(document.createElement('div')) &#13;
    .append(this.$country) &#13;
    .append(this.$province) &#13;
    .append(this.$city); &#13;
 &#13;
  get value(): LocationResult { &#13;
    return { &#13;
      country: this.$country.val(), &#13;
      province: this.$province.val(), &#13;
      city: this.$city.val() &#13;
    }; &#13;
  } &#13;
} &#13;
</pre><p>Before we can tell how the colleagues are going to cooperate, we would like to add a helper method <code class="literal">setOptions</code> for updating options in a <code class="literal">select</code> element:</p><pre class="programlisting">private static setOptions( &#13;
  $select: JQuery, &#13;
  values: string[] &#13;
): void { &#13;
  $select.empty(); &#13;
 &#13;
  let $options = values.map(value =&gt; { &#13;
    return $(document.createElement('option')) &#13;
      .text(value) &#13;
      .val(value); &#13;
  }); &#13;
 &#13;
  $select.append($options); &#13;
} &#13;
</pre><p>I personally tend to have methods that do not depend on a specific instance static methods and this applies to methods <code class="literal">getCountries</code>, <code class="literal">getProvincesByCountry</code>, and <code class="literal">getCitiesByCountryAndProvince</code> that simply return a list by the information given as function arguments (though we are not going to actually implement that part):</p><pre class="programlisting">private static getCountries(): string[] { &#13;
  return ['-'].concat([/* countries */]); &#13;
} &#13;
 &#13;
private static getProvincesByCountry(country: string): string[] { &#13;
  return ['-'].concat([/* provinces */]); &#13;
} &#13;
 &#13;
private static getCitiesByCountryAndProvince( &#13;
  country: string, &#13;
  province: string &#13;
): string[] { &#13;
  return ['-'].concat([/* cities */]); &#13;
} &#13;
</pre><p>Now we may add methods for updating options in the <code class="literal">select</code> elements:</p><pre class="programlisting">updateProvinceOptions(): void { &#13;
  let country: string = this.$country.val(); &#13;
 &#13;
  let provinces = LocationPicker.getProvincesByCountry(country); &#13;
  LocationPicker.setOptions(this.$province, provinces); &#13;
 &#13;
  this.$city.val('-'); &#13;
} &#13;
 &#13;
updateCityOptions(): void { &#13;
  let country: string = this.$country.val(); &#13;
  let province: string = this.$province.val(); &#13;
 &#13;
  let cities = LocationPicker &#13;
    .getCitiesByCountryAndProvince(country, province); &#13;
  LocationPicker.setOptions(this.$city, cities); &#13;
} &#13;
</pre><p>Finally, weave those colleagues together and add listeners to the <code class="literal">change</code> events:</p><pre class="programlisting">constructor() { &#13;
  LocationPicker &#13;
    .setOptions(this.$country, LocationPicker.getCountries()); &#13;
  LocationPicker.setOptions(this.$province, ['-']); &#13;
  LocationPicker.setOptions(this.$city, ['-']); &#13;
 &#13;
  this.$country.change(() =&gt; { &#13;
    this.updateProvinceOptions(); &#13;
  }); &#13;
 &#13;
  this.$province.change(() =&gt; { &#13;
    this.updateCityOptions(); &#13;
  }); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>Consequences</h2></div></div></div><p>Mediator Pattern, like many other design patterns, downgrades a level-100 problem into two level-10 problems and solves them separately. A well-designed mediator usually has a proper size and usually tends to be reused in the future. For example, we might not want to put nickname input together with the country, province, and city inputs as this combination doesn't tend to occur in other situations (which means they are not strongly related).</p><p>As the project evolves, a mediator may grow to a size that's not efficient anymore. So a properly designed mediator should also take the dimension of time into consideration.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we talked about some common behavioral patterns for different scopes and different scenarios. Chain of Responsibility Pattern and Command Pattern can apply to a relatively wide range of scopes, while other patterns mentioned in this chapter usually care more about the scope with objects and classes directly related.</p><p>Behavioral patterns we've talked about in this chapter are less like each other compared to creational patterns and structural patterns we previously walked through. Some of the behavioral patterns could compete with others, but many of them could cooperate. For example, we talked about Command Pattern with Memento Pattern to implement undo support. Many others may cooperate in parallel and do their own part.</p><p>In the next chapter, we'll continue talking about other behavioral design patterns that are useful and widely used.</p></div></body></html>