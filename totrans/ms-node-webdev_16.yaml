- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authenticating and Authorizing Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most projects need to restrict access to features; otherwise, anyone who knows
    an application’s URL can execute any operation. This is currently how the example
    application is set up: anyone who can request `http://localhost:5000` will be
    able to store and delete data, regardless of who they are.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Authorization*, often referred to as *AuthZ*, is the process of restricting
    access so that operations can only be performed by some users – known, naturally
    enough, as *authorized users*. *Authentication*, often referred to as *AuthN*,
    is the process of a user identifying themselves so that the application can determine
    whether the user is authorized for the operations they request. This chapter explains
    how Node.js applications can apply authentication and authorization, building
    on the features described in earlier chapters. *Table 15.1* puts this chapter
    in context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15.1: Putting authorization and authentication in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | Authentication is the process of identifying a user. Authorization
    is the process of restricting access to application features to a subset of users.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Identifying users allows an application to alter its
    behavior by using data or preferences that are specific to one account. Restricting
    access to features means that applications can support operations that would otherwise
    be dangerous or prejudicial to effective service provision. |'
  prefs: []
  type: TYPE_TB
- en: '| How is it used? | Users identify themselves by presenting credentials to
    the application, which produces a temporary token that is included in subsequent
    requests. The token is used to associate an identity with each request, which
    can be inspected to authorize access to restricted features. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | Thorough testing is required to
    ensure that authentication and authorization work as expected. Many applications
    will require additional work to support user enrolment and account maintenance.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Not all applications require authentication
    and authorization, but most do. Some of the surrounding features can be delegated
    to third-party authentication providers, but integration is still required. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 15.2* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Authenticate users | Provide a mechanism that allows the user to provide
    credentials, which can be validated against stored data. | *4-9, 26-28* |'
  prefs: []
  type: TYPE_TB
- en: '| Create an authentication token for HTML clients | Include the user’s identity
    in the session so that the session cookie becomes the authentication token. |
    *10-12* |'
  prefs: []
  type: TYPE_TB
- en: '| Create an authentication token for API clients | Create a bearer token. |
    *13-16* |'
  prefs: []
  type: TYPE_TB
- en: '| Authorize requests | Use the identity associated with a request to determine
    if the user is entitled to perform the target operation. | *17-25, 29* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter uses the `part2app` project from *Chapter 14*. The first set of
    examples in this chapter is for a round-trip application. To prepare, add a file
    named `data.handlebars` to the `templates/server` folder with the content shown
    in *Listing 15.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.1: The contents of the data.handlebars file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This template contains a table that displays data, with a form that sends HTTP
    requests to the server. To handle the HTTP requests, replace the contents of the
    `forms.ts` file in the `src/server` folder with the code shown in *Listing 15.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.2: The contents of the forms.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The routes defined in *Listing 15.2* render the data template, delete an item
    from the database, and store an item. After data is stored or deleted, the browser
    is sent a redirection to the `/form` URL that will show the user the results of
    their actions. Run the command shown in *Listing 15.3* in the `part2app` folder
    to start the development tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.3: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000/form`, and you will see the
    content generated by the new template, as shown in *Figure 15.1*. Clicking one
    of the **Delete** buttons will remove an item from the database, and clicking
    the **Add** button will store a new item using fixed data values.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Running the example application'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the end-to-end process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are part of a larger process through which
    a user gains access to the features provided by an application. The process is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enrolment. The enrolment process creates an account for the user, who is given
    credentials to identify themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User Authentication. The user presents their credentials when they want to use
    the application. The authentication process, often called signing in, produces
    a token that temporarily identifies the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request Authentication. When making HTTP requests, the client includes the temporary
    token to identify the user without needing to provide the credentials again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorization. The token included in the request is used to determine whether
    the user can access the feature specified by the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter covers the authentication and authorization parts of the process.
    The details of the enrolment process are not described because they depend on
    the type of application. For corporate applications, enrolment will usually happen
    when a new employee joins the company and, for larger companies, will be done
    by the HR department through a central employee directory. For consumer-facing
    applications, enrolment is often linked to payment and is done before the user
    receives access to the application (for services, such as Spotify) or after they
    have made a product selection (for goods, such as Amazon). In both cases, the
    user enrolls themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that require users to enroll themselves usually provide account
    maintenance tools, which allow users to change their credentials, update personal
    information, and close their accounts. In some parts of the world, users are legally
    entitled to receive a copy of all of the data held about them, and this is often
    part of the account management process.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authentication process requires the user to present their credentials to
    identify themselves to the application. The standard credentials are a username
    and password. The password is known only to the user, which means they can prove
    they are the user who owns the account by submitting the correct password.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, passwords can be stolen or shared, and so a common approach is to
    require additional proof of identity. The conventional approach is to combine
    a password with a physical token, which can be a dedicated hardware device or
    an authenticator app running on a phone. The device provides a time-limited code
    that proves the user has the device.
  prefs: []
  type: TYPE_NORMAL
- en: To work through the details of how users are authenticated, I am going to add
    support for usernames and passwords to the example application. Later in the chapter,
    I’ll introduce an open-source package that supports a wider range of credentials,
    but simple passwords are enough to explain how the overall authentication and
    authorization processes work. *Part 3* of this book demonstrates the use of a
    third-party authentication service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a credential store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To authenticate users, an application needs to have a store of credentials
    against which requests can be validated. Create the `src/server/auth` folder and
    add to it a file named `auth_types.ts`, with the content shown in *Listing 15.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.4: The contents of the auth_types.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Credentials` interface describes a user’s credentials as they are stored
    for validation. It is poor practice to store passwords in plain text, and the
    conventional approach is to create a one-way hash code and store that instead.
    To validate credentials, the password provided by the user is put through the
    same hashing algorithm and compared with the stored value. Hash algorithms always
    produce the same result, which means the credential store will contain the same
    hash code for all users who pick the same password. If the password for one of
    those accounts is obtained, then anyone who can see the credential store will
    be able to figure out which other accounts can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, a random *salt* value is added to the password so that
    users can have the same password without causing duplicate hash codes in the credential
    store. The salt value must be stored alongside the password so that credentials
    can be validated. The hash code and the salt are `Buffer` values, which is the
    type that Node.js uses to represent byte arrays. The `AuthStore` interface defines
    the methods that will be used to retrieve and store credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file named `orm_auth_models.ts` to the `src/server/auth` folder with
    the contents shown in *Listing 15.5*, which defines the data model for credentials
    using the *Sequelize ORM package* introduced in *Chapter 12*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.5: The contents of the orm_auth_models.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `CredentialsModel` class extends the Sequelize `Model` class and implements
    the `Credentials` interface, which allows `CredentialsModel` objects to be stored
    in the database and used as a method result with the `AuthStore` interface. The
    `initializeAuthModels` function receives a `Sequelize` object and initializes
    the `CredentialsModel` for database storage, identifying the `username` property
    as the primary key and telling `Sequelize` to represent values, using the SQL
    `STRING` data type for the username property and the `BLOB` type for the hash
    code and salt values (the `BLOB` type allows data to be stored as strings or buffers).
  prefs: []
  type: TYPE_NORMAL
- en: To create a Sequelize implementation of the `AuthStore` interface, add a file
    named `orm_authstore.ts` to the `src/server/auth` folder with the contents shown
    in *Listing 15.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.6: The contents of the orm_authstore.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `OrmAuthStore` class implements the `AuthStore` interface using the Sequelize
    features presented by the `CredentialsModel` class. The `getUser` method is implemented
    using the `findByPk` method, which queries the database using a primary key value.
    The `storeOrUpdateUser` method is implemented using the `upsert` method, which
    updates an existing value if there is one and otherwise creates a new value. The
    data will be stored in an SQLite database file named `orm_auth.db`.
  prefs: []
  type: TYPE_NORMAL
- en: The `createHashCode` method accepts a password and a salt value and creates
    a new hash code, using the `pbkdf2` function from the Node.js `crypto` module.
    This function is an implementation of a **Password-Based Key Derivation Function**
    (**PBKDF**), which is a function that is well-suited to create hash codes from
    passwords (see [https://en.wikipedia.org/wiki/PBKDF2](https://en.wikipedia.org/wiki/PBKDF2)
    for details). The arguments to the `pbkdf2` function are the password to be hashed,
    the salt value, the number of iterations used to generate the hash code, the length
    of the hash code, and the algorithm that will be used to generate the hash code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15.6* uses the values described in the Node.js API ([https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback](https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback)).
    The `pbkdf2` function uses a callback, which is wrapped in a Promise to make it
    easier to work with the `Sequelize` API.'
  prefs: []
  type: TYPE_NORMAL
- en: The `validateCredentials` method uses the `getUser` method to retrieve the stored
    credentials and uses the stored salt value to compute a new hash code with the
    candidate password, which is then compared to the stored hash code, using the
    `timingSafeEqual` function in the Node.js `crypto` module. This function is used
    to compare hash codes securely, as described in the API documentation `(`[https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b](https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b)).
  prefs: []
  type: TYPE_NORMAL
- en: The database is seeded with two sets of credentials, matching those described
    in *Table 15.3*. Credentials are usually created as part of an enrolment process,
    as described earlier in the chapter, but test credentials are enough for this
    chapter. See *Part 3* for an example of an enrolment process typical of an online
    store. As with examples in earlier chapters, the database is reset each time the
    application is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15.3: The test credentials added to the database'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Password |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to create a workflow that allows a user to sign in and out
    of the application. Add a file named `signin.handlebars` to the `templates/server`
    folder with the content shown in *Listing 15.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.7: The contents of the signin.handlebars file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The template contains a form to send a username and password to the application,
    along with an error message that is hidden by default but which will be displayed
    if the user provides invalid credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the Express routes that will present the user with
    the contents of the `signin` template and validate credentials when they are submitted.
    Add a file named `index.ts` to the `src/server/auth` folder with the content shown
    in *Listing 15.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.8: The contents of the index.ts file in the src/server/auth folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This file exports a function named `createAuth`, which sets up authentication
    for the application. The contents of the `signin` template are rendered when a
    GET request is sent to `/signin`. When a POST request is sent to `/signin`, the
    credentials it contains are validated. A redirection is used to send the user
    back to the application if the credentials are valid.
  prefs: []
  type: TYPE_NORMAL
- en: A redirection is also sent when credentials fail validation but, this time,
    to the same URL. This is a pattern known as `Post/Redirect/Get`, and it ensures
    that the user can reload the browser without triggering another sign-in attempt.
    This pattern can be used in any form, but it is particularly useful for authentication,
    where repeated failed attempts are often counted and can lead to an account being
    logged out. The URL query string is used to include the credentials provided by
    the user so they will be displayed by the result of the GET request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication should always be performed over an encrypted HTTP connection;
    otherwise, the credentials provided by the user can be exposed to network sniffing.
    See *Chapter 5* for details of setting up HTTPS for a stand-alone Node.js server
    and see *Part 3* for an example that demonstrates how HTTPS is typically set up
    for more complex Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15.9* calls the `createAuth` function as part of the server startup
    so that the authentication features are part of the request-handling process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.9: Enabling authentication in the server.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `createAuth` method is called after the middleware components required by
    forms are set up, but before the rest of the application. This allows the authentication
    request handlers to rely on the features previously described for forms, such
    as decoding form data and using sessions.
  prefs: []
  type: TYPE_NORMAL
- en: To test the authentication workflow, use a web browser to request `http://localhost:5000/signin`,
    enter `alice` and `badpass` into the form, and click the **Sign In** button. Validation
    will fail because the wrong password has been provided. Change the password to
    `mysecret` and click the button again. This time, the credentials are validated,
    and the browser is redirected to the root URL. This sequence is shown in *Figure
    15.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: The signing-in workflow'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application can validate credentials, but that isn’t much use because there
    is currently no association between credentials sent to the `/signin` URL and
    any subsequent HTTP requests made by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the purpose of the temporary token that can be presented to the application
    to prove that the user has been through the credential validation process. Cookies
    are the most common way to solve this problem, either by creating a separate cookie
    or by associating authentication data with an existing session cookie, which is
    the approach I am going to take in this chapter because it is the simplest approach
    and takes advantage of session features, such as automatic inactivity expiration.
    *Listing 15.10* uses a session to record successful authentication, and it defines
    middleware that detects the new session data and adds a `user` property to the
    request object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.10: Completing authentication in the index.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first `declare` statement extends the `SessionData` interface to define
    a `username` property so that a user’s identity can be associated with a session.
    It can be tempting to put more complex data in the session, but the purpose of
    this new property is just to identify the user, which can be done by just adding
    one `string` property to the `SessionData` interface. The second `declare` statement
    adds `user` and `authenticated` properties to the Express `Request` interface,
    which will allow more complex user data to be provided to the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user’s credentials are validated, the `username` property added to
    the `SessionData` interface is used to store the username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The new middleware component inspects the session data for requests to check
    to see if this property has been set. If it has, then the `username` and `authenticated`
    properties of the `Request` object are set, which is how the rest of the application
    will be able to identify the authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: The final addition is a new route for the `/signout` URL, which lets a user
    sign out of the application by destroying the session, by calling the `destroy`
    method, which is a feature provided by the `express-session` package added to
    the project in *Chapter 13*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the session cookie has been transformed into the temporary token
    that authenticates the user’s requests. When the browser includes the session
    cookie in a request, the application knows that the request has been sent on behalf
    of the user because the session cookie represents the successful validation of
    the user’s credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Using the authentication data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete the authentication feature, the user has to be able to see that
    they have successfully signed in and allowed to sign out again. Express has a
    useful feature for working with templates, called *local data* or *locals*, that
    allows data to be provided to a template outside of the call to the render method.
    Local data is specific to a single request/response pair, and any value that is
    assigned to the `Response.locals` property is available for use within any template.
    This is perfect for providing authentication information to templates, which would
    otherwise have to be added to the context data for every call to the `render`
    method. *Listing 15.11* uses this feature to provide templates with authentication
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.11: Providing authentication details in the index.ts file in the
    src/server/auth folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The new statements added to the middleware component create local data values
    named `user` and `authenticated`, which means that this information will be available
    to any template that is executed by a request/response that has been processed
    by this middleware. There is also a regular context data property named `signinpage`,
    which is passed to the `render` method when the sign-in form is presented to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15.12* updates the layout that is used with all templates, which allows
    the authentication information to be displayed throughout the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.12: Using authentication data in the main.handlebars file in the
    templates/server/layouts folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Local data values are used in the same way as regular template context data,
    and the additions to the template display the user’s name and a sign-out button
    if the request has been authenticated. If the request isn’t authenticated, then
    the template displays a sign-in button, unless the `signinpage` property is set,
    in which case no new content is shown.
  prefs: []
  type: TYPE_NORMAL
- en: To see the effect of the changes, use a browser to navigate to `http://localhost:5000/signin`,
    enter `alice` and `mysecret` into the `Name` and `Password` fields, respectively,
    and click the **Sign In** button. The credentials will be validated, and the browser
    will display the username and a **Sign Out** button. Click the **Sign Out** button,
    and a **Sign In** button will be displayed. This sequence is shown in *Figure
    15.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Using authentication data'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating web service requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications can’t rely on forms to authenticate web services because clients
    may not be browsers and cannot be relied on to render HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Web service clients can use cookies – because they are a standard part of HTTP
    – but session cookies can often cause problems because the session expiry is often
    set to suit round-trip clients, where every user interaction refreshes the cookie.
    Web service clients only send requests when they need data, and the frequency
    of requests can be so low that sessions expire too quickly to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Applications can address the lack of HTML support by providing an API to present
    credentials as JSON data. Instead of a cookie, the authentication API produces
    a *bearer token*, which is a string that can be included in requests, much like
    a cookie, but with its own lifecycle and without the dependency on sessions.
  prefs: []
  type: TYPE_NORMAL
- en: The most common form of bearer token is the **JSON Web Token** (**JWT**) standard,
    which is a self-contained authentication token that doesn’t depend on server-side
    data. (There is a good overview of JWT at [https://jwt.io](https://jwt.io), along
    with tools to validate tokens, which can be useful during development).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with just about every aspect of web services, there are no hard-and-fast
    standards for how a client performs authentication, but I am going to follow widely
    used conventions. To sign in, the client will send an `HTTP POST` request to the
    `/api/signin` URL, with a JSON payload that includes the user’s credentials, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will contain a JSON object that contains a success property that
    indicates whether the credentials were accepted and, if they were, a `token` property
    that contains the bearer token, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Real JWT tokens are longer sequences of characters, but I have shorted this
    one for brevity. The client doesn’t have to parse or process the token in any
    way, and they just have to include the token in HTTP requests using the `Authorization`
    header, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `Authorization` header is a scheme, which is `Bearer`, followed
    by the token generated during authentication. The server decodes the token and
    uses it to determine the identity of the authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding API keys**'
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter focus on user authentication. Web services can
    also use API keys, which identify the client making the request on behalf of the
    user, which can be useful when a third-party creates clients that consume your
    project’s APIs. API keys usually have a long life and are used to control access
    to API features, track request volumes, and so on. I don’t describe API keys in
    this book, but there is a good overview available at [https://cloud.google.com/endpoints/docs/openapi/when-why-api-key](https://cloud.google.com/endpoints/docs/openapi/when-why-api-key).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the command shown in *Listing 15.13* in the `part2app` folder to add a
    JWT package and its type descriptions to the example project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.13: Installing a package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to generate and validate JWT values using custom code, but it
    is simpler and easier to use a good package. *Listing 15.14* adds support to sign
    in API clients:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.14: Signing in API clients in the index.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/api/signin` route relies on the Express JSON middleware to parse the
    data sent by the client and validates the user’s credentials. If the credentials
    are valid, then a token is created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `sign` function creates a token, which is signed to prevent tampering. The
    arguments are the data to use as the token payload, a secret used to sign the
    token (which must be used again during validation), and a configuration object
    that is used to specify the token expiry.
  prefs: []
  type: TYPE_NORMAL
- en: The `jsonwebtoken` package supports setting expiry times using the syntax defined
    by the `ms` package ([https://github.com/vercel/ms](https://github.com/vercel/ms)).
    This allows the `expiresIn` property to be set to `1h`, which creates a token
    that’svalid for 60 mins.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can put any data in a token that is consumed by the same application that
    generates it. If you are generating tokens that will be validated by third parties,
    then there are well-defined payload properties that are used to describe authentication
    and authorization data, which can be found at [https://jwt.io/introduction](https://jwt.io/introduction).
    Tokens are signed but not encrypted, which means that sensitive data should not
    be included in a token.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication middleware checks to see if the request includes the `Authorization`
    header and, if it does, verifies its value as a token. The verification checks
    the signature to ensure that the payload hasn’t been altered and ensures the token
    has not expired. The username is read from the token’s payload and used to authenticate
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the web service client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete the authentication implementation, *Listing 15.15* updates the
    command-line client to add operations to sign in and out of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.15: Adding authentication in the operations.mjs file in the src/cmdline
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The token received from successfully signing in is assigned to the variable
    named `bearer_token`, which is included in subsequent requests using the `Authorization`
    header. Note that the client doesn’t explicitly sign out of the application but
    simply discards the token. That’s because the server doesn’t keep track of the
    tokens it has issued, and there is no way to invalidate them. Once a token has
    been issued, it is valid until it has expired, and so web service clients simply
    stop using the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a second command prompt, and run the command shown in *Listing 15.16*
    in the `part2app` folder to start the command-line client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.16: Starting the client'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the **Sign In** option, and enter `alice` as the username and `mysecret`
    as the password. The response from the server shows the outcome of the authentication
    and the token, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will see a different token value, but the structure of the data will be
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the user can authenticate themselves, the next step is to restrict
    access to operations based on the user’s identity so that actions can only be
    performed by authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: The foundation for authorization is the *authorization policy*, which is a mapping
    between the operations the application provides and the users that are allowed
    to perform them. At its simplest, the mapping can be expressed as a simple list,
    as shown in *Table 15.4* for the example application, which provides `Add` and
    `Delete` operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15.4: A simple authorization policy'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Authorized Users |'
  prefs: []
  type: TYPE_TB
- en: '| `Add` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Delete` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that the authorization policy is an integral
    part of the application, which means that adding a new user or changing the operations
    that a user can perform requires a code change and a new release to be tested
    and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, most applications introduce *roles* and rely on *role* *assignment*
    to authorize requests. Rather than checking to see if the user is on the list,
    the application checks to see if the user has been assigned to one of the roles
    that are authorized to perform an operation. The details of which users are assigned
    to each role can be stored in a database so that changes can be made without altering
    the application’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Applications are free to assign users to roles in whatever way makes the most
    sense, but a common approach is to focus on the different ways in which they engage
    with an application. For this chapter, I am going to create two roles, as described
    in *Table 15.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15.5: The example application roles'
  prefs: []
  type: TYPE_NORMAL
- en: '| Roles | Members |'
  prefs: []
  type: TYPE_TB
- en: '| `Users` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Admins` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The authorization policy can now be expressed in terms of authorized roles,
    rather than individual users, as described in *Table 15.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15.6: A role-based authorization policy'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Authorized Roles |'
  prefs: []
  type: TYPE_TB
- en: '| `Add` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Delete` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The user `alice` has been assigned to both roles and will be able to perform
    the `Add` and `Delete` operations. The user `bob` has been assigned to the `Users`
    role and will be able to perform the `Add` operation, but not the `Delete` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to expand the database to add support for describing roles,
    as shown in *Listing 15.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.17: Adding types in the auth_types.ts in the src/server/auth folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15.18* defines the model class that Sequelize will use to represent
    roles in the database and modifies the existing model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For consistency, it is easier to store credentials and role assignments in the
    same database so that the primary key for a user account can be used as a foreign
    key for role membership. You can use separate databases, if you prefer, just as
    long as you ensure that changes are applied consistently, such as updating role
    memberships when a user account is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.18: Adding a model in the orm_auth_models.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Storing role memberships requires a *many-to-many relationship*, where each
    role can be associated with many user credentials, and each user credential can
    be associated with many roles. The `RoleModel` class represents a role, with properties
    that provide the role name and an array of `CredentialsModels` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many-to-many relationships are represented in SQL using a junction table, where
    each row represents the relationship between one user and one role. Many-to-many
    relationships are always awkwardly represented by ORM packages, and some trial
    and error is usually required to get the objects created by the ORM to match up
    to the SQL tables that are created. Sequelize has a better-than-average approach,
    and the relationship between the model classes is created using the `belongsToMany`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments define the many-to-many relationship using a table named after
    the `RoleMembershipJunction` class to create the junction. Sequelize will create
    the table and figure out the column data types automatically and will include
    associated data in results when the `include` query configuration setting is used,
    as you will see in *Listing 15.18*. The associated data can be read using properties
    that are added to the model class, which are described to TypeScript like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties are optional, as denoted by the `?` character, because they
    will only be populated when the query includes related data. Sequelize adds methods
    to model objects to allow their relationships to other models to be used for more
    than reading data. For the benefit of TypeScript, the `declare` keyword has to
    be used to describe the properties, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The names given to the methods combine the operation and the model class, such
    that `setCredentialsModels` is a method that allows the `CredentialModels` objects
    associated with a `RoleModel` to be set in a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these methods, Sequelize provides types that can be used with the
    `declare` statement. In the case of the set operation, the type is named `HasManySetAssociationsMixin`,
    and the generic type parameters are used to specify the associated model class
    as the type of the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the only method I need for this example because roles are updated by
    replacing all of the members, but Sequelize adds methods to read, add, and remove
    associated data, along with type descriptions for each of them, as described at
    [https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances](https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to extend the store to add support to query, store, and check
    roles, as shown in *Listing 15.19*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.19: Supporting roles in the orm_authstore.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The new statements in the constructor initialize the database models and add
    the `Admins` and `Users` roles, which will be used to demonstrate the authorization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getRole` method queries the database for `RoleModel` objects and uses
    the `include` option to include the associated `CredentialsModel` objects in the
    results, which is transformed into the `Role` result required by the `RoleStore`
    interface. I only need the `username` value to create a role, and I have specified
    the column I want `Sequelize` to include in the query using the `attributes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `include` property is configured with an object whose `model` property specifies
    the associated data and `attributes` property specifies the model properties to
    populate in the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar technique is used to implement the `getRolesForUser` method. The
    `findAll` method is used to query for all `RoleModel` objects, but the `where`
    clause is used to make a selection based on the associated data so that only `RoleModel`
    objects that have associations with `CredentialsModel` objects whose `username`
    property matches a given value. An empty `attributes` array is used to exclude
    all of the `CredentialModel` data from the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There can be several different ways to approach queries when there are relationships
    between models, and the same data can be obtained by starting with the `CredentialModel`
    class and including the `RoleModel` class. My advice is to pick whichever approach
    feels the most natural to you, which will be a matter of personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: The `storeOrUpdateRole` method accepts a `Role` object and queries the database
    for all of the matching `CredentialsModel` objects, which ensures that any name
    for which there are no user credentials is ignored. The `findOrCreate` method
    ensures that a `RoleModel` object exists in the database, and the `setCredentialsModels`
    method is used to set the role membership. A transaction is used to ensure that
    the update is performed atomically.
  prefs: []
  type: TYPE_NORMAL
- en: The `validateMembership` method gets the roles to which a user has been assigned
    and checks that one of them matches the required role.
  prefs: []
  type: TYPE_NORMAL
- en: Checking authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to guard routes so that only users who are assigned to authorized
    roles can perform operations. There are lots of ways to implement authorization,
    but one of the simplest is to use the Express feature that allows middleware components
    to be added to individual routes, which means that requests can be inspected and
    rejected before they are passed to the route’s request handler. *Listing 15.20*
    adds a function that creates a middleware component that restricts access to one
    or more roles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.20: Defining a guard handler in the index.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `roleGuard` function accepts a role and returns a middleware component that
    will only pass on the request to the handler if the user has been assigned to
    that role, which is checked using the `validateMembership` method provided by
    the store.
  prefs: []
  type: TYPE_NORMAL
- en: There are two outcomes for unauthorized requests. If the user has not been authenticated,
    then the user is redirected to the `/signin` URL, so they can authenticate themselves
    and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'For authenticated requests, the user is redirected to the `/unauthorized` URL.
    *Listing 15.20* adds a route for `/unauthorized` that renders a template. To create
    the template, add a file named `unauthorized.handlebars` to the `templates/server`
    folder with the content shown in *Listing 15.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.21: The contents of the unauthorized.handlebars file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to apply the guard to restrict access to operations, as shown
    in *Listing 15.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.22: Authorizing requests in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `/form/add` route is restricted to the `Users` role, and the `/form/delete/:id`
    route is restricted to the `Admins` role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the role guard reveals an inconsistency in the type descriptions for
    the Express API, which causes the TypeScript compiler to complain about statements
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The type that the compiler uses for the `Request.params` property has changed,
    and the compiler will complain about the `id` property. It is possible to correct
    this by adding a type annotation to the request handler, but a quick fix is to
    access the property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000`, and make sure that no user
    is signed in. Click the **Add** button. The browser will send a request to the
    `/form/add` route, but since the request is unauthenticated, the browser will
    be redirected to the `/signin` page. Sign in with the username `bob` and the password
    `mysecret`, and click the **Add** button again. This time, the request is authenticated,
    and the user has been assigned to the `Users` role, so the request is authorized
    and passed onto the request handler, which adds a new value to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Delete** button, and the browser will send a request to the `/form/delete/:id`
    route. The request is authenticated but the user has not been assigned to the
    `Admins` role, so the browser is redirected to the `/unauthorized` URL. The complete
    sequence is shown in *Figure 15.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Testing authorization'
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing API requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Feathers` package that I introduced in *Chapter 14* provides support for
    hooks, which allow requests to be intercepted, and which I used to alter the status
    code when a specific error was thrown. In this chapter, I am going to use the
    same feature to manage authorization. The first step is to create a function that
    will create a hook that checks the user’s membership of a role, as shown in *Listing
    15.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.23: Adding a hook function in the index.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `roleHook` function creates a hook that will authorize access if a user
    has been assigned to a specified role. The user’s identity is accessed through
    the `HookContext` parameter, which Feathers provides when a hook is invoked. The
    key difference from the route guard used for non-API requests is that the responses
    are HTTP status codes and not HTML documents. The `401` status code indicates
    a request that does not include authentication data, and a `403` status code is
    sent when the user is authenticated but not authorized. The status code is set
    using the `HookContext.http` property, and setting the `result` property has the
    effect of terminating request handling.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15.24* applies the hook and configures Feathers so that the hook receives
    the request’s authentication data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.24: Applying authorization in the index.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to get the authentication data from the request and add it
    to the `feathers` property, which is added to requests when Feathers is used and
    presented through the `HookContext` object provided to hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to create hooks to protect the web service. The `before`
    property is used to register hooks that are invoked before a web service method
    is invoked, and the `create`, `remove`, `update`, and `patch` methods are protected
    by hooks that require either the `Users` or `Admins` role.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you closed the command-line client from earlier in the chapter, then open
    a new command prompt, navigate to the `part2app` folder, and run the command shown
    in *Listing 15.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.25: Starting the command-line client'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the **Store** option, enter the data values, and when the request is
    sent, the server will response with a `401` status code, which indicates that
    an operation requires authorization but the request contained no authentication
    data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Sign in as `bob` with the password `mysecret` and repeat the process. This
    time, the request will contain the bearer token, and the user `bob` has been assigned
    to the `Users` role, so the operation will be authorized, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Select **Delete** and enter an `ID`. The request will contain a token, but
    `bob` hasn’t been assigned to the `Admins` role, so the server will respond with
    a `403` status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Sign in as `alice` and repeat the `Delete` request, which will succeed because
    `alice` has been assigned to the `Admins` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The authorization process for the web service is based on the same user data
    as for HTML clients, but returning a status code gives API clients a response
    that can be handled programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Using packages for authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how authentication and authorization work together in
    a web application, it is time to replace some of the custom code with open-source
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: There are two good reasons to use open-source packages for authentication in
    particular. The first reason is that it is easy to make a mistake when writing
    custom code that creates a security vulnerability. The second reason is that a
    good authentication package will support a range of different authentication strategies,
    including authentication with third-party services, such as Google and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 3* of this book, I demonstrate a different authentication strategy,
    but for this chapter, I am going to use open-source packages but still use usernames
    and passwords for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Not all features can be replaced with custom code. The focus tends to be on
    authentication, while authorization is left to individual applications to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating HTML clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I am going to use the Passport package ([https://www.passportjs.org](https://www.passportjs.org))
    to provide authentication. Passport supports a wide range of authentication strategies,
    including support for using third-party authentication services, and provides
    an API to implement custom strategies. In this chapter, I use the `Local` strategy,
    which provides support to authenticate users with locally stored username and
    password data and uses sessions to authenticate subsequent requests. I also use
    the **JWT** strategy, which uses bearer tokens to authenticate requests. Run the
    commands shown in *Listing 15.26* in the `part2app` folder to install the main
    passport package, the packages that contain the strategies, and type descriptions
    for all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.26: Installing packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Passport requires configuration so that it can be integrated into the application.
    Add a file named `passport_config.ts` to the `src/server/auth` folder, with the
    content shown in *Listing 15.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.27: The contents of the passport_config.ts file in the src/server/auth
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `passport.use` function is used to set up strategies, and in *Listing 15.27*,
    the local and JWT strategies are applied. These strategies require a verification
    function, which receives the request data and returns an object representing the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verification function for the local strategy receives the username and
    password sent by the user, which is validated using the stored credentials. The
    outcome is provided to Passport with a callback, which either provides an object
    that represents the user or `false` if verification fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The verification function will only be called when the user signs in, after
    which Passport uses a temporary token to authenticate subsequent requests. One
    option is to use session cookies to store the user data, which is the same approach
    used by the custom code.
  prefs: []
  type: TYPE_NORMAL
- en: The verification for the JWT strategy is different. Passport doesn’t generate
    JWT tokens, and the verification function is called when a bearer token is received.
    The strategy is configured with an object that tells Passport how to locate the
    bearer token in the request and provides the key to check the token signature.
    The verification function receives the payload from the token and is responsible
    for providing an object that represents the authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `serializeUser` and `deserializeUser` functions are used by Passport to
    include user information in the session. These functions must be defined even
    when, as in this case, user data is just an object containing a username. *Listing
    15.28* uses Passport to authenticate requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.28: Using Passport in the index.ts File in the src/server/auth Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Passport provides its own additions to the `Express` `Request` object, so adjustments
    are required to prevent conflicts. The `Passport` `authenticate` function is used
    twice. When used with a route, the `authenticate` method is used to create a request
    handler that will validate credentials using the local strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The configuration options tell Passport where to redirect the browser for successful
    and failed sign-in attempts. Passport doesn’t include the username and password
    in redirections for failed sign-in attempts, which is why the values are no longer
    included when the sign-in template is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other use of the `authenticate` function is to authenticate requests, and
    the argument specifies that the session is the source of authentication data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Passport doesn’t have an `authenticate` property, but a follow-on handler function
    allows the property to be set, along with the local data required for templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, Passport doesn’t create JWT tokens, so the code that authenticates
    API clients remains unchanged. Passport does *validate* JWT tokens, however, which
    is why the code that read and validated the bearer token was removed in *Listing
    15.28*. *Listing 15.29* uses Passport to authenticate bearer tokens for web service
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 15.29: Using Passport in the index.ts file in the src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `authenticate` function is used to create a request handler that will validate
    tokens, using the JWT strategy. A follow-on function is used to set the values
    used by the Feathers hook so that authorization checks can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Feathers has its own authentication and authorization features, which are useful
    if you are creating a stand-alone API project, and they are described at [https://feathersjs.com/api/authentication](https://feathersjs.com/api/authentication).
    Mixing authentication features from multiple packages can be difficult, which
    is why I have used Passport for all authentication in the examples, even though
    some features, like JWT creation, are not available.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the Passport package doesn’t alter the way authentication works,
    and users sign into the application in the same way. The difference is the reduction
    in custom code and support for a wider range of authentication strategies, which
    can make it easier to integrate an application into an existing environment or
    to use third-party authentication services.
  prefs: []
  type: TYPE_NORMAL
- en: Custom code is still required to perform role-based authorization, which is
    why it is important to understand how users and requests are authenticated, and
    how the results can be used to restrict access to application features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I demonstrated how users and requests can be authenticated,
    and how authentication data can be used to authorize access to application features:'
  prefs: []
  type: TYPE_NORMAL
- en: Users present their credentials, whether using an HTML form or a JSON payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When credentials are validated, the client is sent a temporary token that can
    be used to authenticate subsequent requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The temporary authentication token can be a cookie (and a session cookie is
    often used) or a bearer token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization is usually performed through roles, which prevents you having
    to hardcode user permissions into the application. The relationship between users
    and roles is stored in a database, so it can be altered without releasing a new
    version of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are good open-source packages available for user and request authentication,
    but authorization is typically done using custom code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Part 3*, I use the features described in *Parts 1* and *2* of this book
    to create an online store that shows how the different parts of an application
    work together.
  prefs: []
  type: TYPE_NORMAL
