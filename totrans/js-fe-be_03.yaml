- en: '*Chapter 2*: Exploring the Advanced Concepts of JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the advanced features of JavaScript, such
    as object-oriented programming. We will also study two types of objects that are
    widely used in JavaScript: arrays and strings. Finally, we will see how JavaScript
    allows you to trigger deferred processing, using so-called callback functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multitasking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these topics are fundamental to building JavaScript applications. Let’s
    start now!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter on GitHub at: [https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%202.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%202.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notion of classes and objects is fundamental to programming languages. JavaScript
    allows them to be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: A class is used to represent any type of data. For example, people, customers,
    cars, and so on. We can define a class to represent each of these types of elements,
    for example, a `Person` class to represent people, a `Client` class to represent
    customers, and a `Car` class to represent cars.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the class name traditionally begins with an uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: An object, on the other hand, will be a particular element of a class (this
    element will be also called an instance). For example, among all the people of
    the class `Person`, the person identified by his name “Clinton” and his first
    name “Bill” represents a particular object of the class `Person`. This object
    can be associated, for example, with the variable `p` in the program. We can thus
    create variables to identify each object associated with the class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question to ask yourself when creating a class is what actions you want
    to perform on the type of data it represents.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we create the `Person` class, we should ask what characterizes
    a person and what action can we perform on this class. We could, for example,
    say that the `Person` class is characterized by the last name, first name, and
    age of the person. You can also add an address, phone number, email, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As for the possible actions on people, we can imagine, for example, the action
    of getting married to another person, the action of moving to another city, the
    action of changing employers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics such as last name, first name, age, and so on are called properties
    of the class, while actions such as getting married, moving, and so on are called
    methods of the class. A class will therefore group together a set of properties
    and a set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JavaScript class is created using the keyword `class` followed by the name
    of the class, followed by braces describing the content. For example, the `Person`
    class will be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Person class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This definition of the `Person` class will not be very useful for now, because
    no properties or methods are defined inside it. We will see later how to improve
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object by using a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the class is defined, we can create objects associated with this class.
    For this, we use the keyword `new` followed by the name of the class. This creates
    a variable that represents an object of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object p of class Person
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Creating a Person class object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Creating a Person class object
  prefs: []
  type: TYPE_NORMAL
- en: The `p` object is displayed in the console. We are told that it is a `Person`
    class object and that it is empty `{}`. The representation of an object in the
    form of braces is traditional in JavaScript, as we saw in the *Type of variables
    used in JavaScript* section of the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that it also works on the client side, in a browser. The HTML
    file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.2 – Creating an object in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Creating an object in the browser
  prefs: []
  type: TYPE_NORMAL
- en: We find the display of braces, which symbolizes the display of a JavaScript
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object without using a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to create an object without having created a class first. All
    you have to do is use the notation with the braces { and }.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object using the braces notation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the object `p` with the `lastname` and `firstname` properties.
    Note that you can indicate the names of the properties by enclosing them in quotation
    marks, or not. So `{ lastname: "Clinton" }` can also be written `{ "lastname":
    "Clinton" }` by surrounding the `lastname` property with single or double quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to improve the `Person` class previously created by adding
    properties and methods to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding properties to a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A person has, in our example, a last name, a first name, and an age. We will
    create these three properties for people of the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do is indicate each of these properties, by name, in the body
    of the `Person` class. Above all, do not use the `var` or `let` keywords to define
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding firstname, lastname, and age properties in Person class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.3 – Creation of lastname, firstname, and age properties in the Person
    class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Creation of lastname, firstname, and age properties in the Person
    class
  prefs: []
  type: TYPE_NORMAL
- en: The `Person` class object `p` now has the properties added in the class. Any
    other object of this class will also have them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the values of the added properties are `undefined`. This is normal
    because no values have been specified for these properties in the `p` object or
    the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `Person` class so that the properties have default values,
    rather than `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties with default values
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each property is initialized with its default value. The `lastname` and `firstname`
    properties are initialized with an empty string `""`, while `age` is initialized
    by default to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Properties with default values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Properties with default values
  prefs: []
  type: TYPE_NORMAL
- en: A class has properties, but also methods. Now let’s see how to add methods to
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can add methods to a class. Objects created from the class (with `new`)
    will be able to use these methods directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s create the `display()` method, which displays a line of
    text containing the person’s first and last name. The instruction `p.display()`
    (assuming that `p` is a `Person` class object) is used to display the last name
    and first name of the person related to the object `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the display() method in the Person class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The properties of the class are accessible in the methods of the class by prefixing
    them with the keyword `this`. For example, `this.lastname` provides access to
    the `lastname` property of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` keyword refers to the object itself that uses the `display()` method,
    so here, the `p` object.
  prefs: []
  type: TYPE_NORMAL
- en: If you omit the `this` keyword and use the `lastname` property directly, you
    will get a syntax error because the property is only accessible with the `this`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code snippet is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Using the display() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Using the display() method
  prefs: []
  type: TYPE_NORMAL
- en: The `display()` method displays `firstname` and `lastname` of the person associated
    with the variable `p`, but since `lastname` and `firstname` have been initialized
    to an empty string, no last name or first name is displayed. Let’s look at how
    to modify the value of a property.
  prefs: []
  type: TYPE_NORMAL
- en: Changing an object’s property values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can modify the value of the properties of an object by using these properties
    directly, for example, `p.lastname` allows you to read or modify the value of
    the `lastname` property for the object `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization of the lastname and firstname of the person
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The lastname and firstname properties are initialized'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – The lastname and firstname properties are initialized
  prefs: []
  type: TYPE_NORMAL
- en: Once the object `p` has been created by the `new` operator, we initialize its
    `lastname` and `firstname` properties to the values indicated. The `age` property
    is not modified here, and will therefore remain equal to the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: We modified the value of the `lastname` and `firstname` properties of the object
    `p` created using `p.lastname` and `p.firstname`.
  prefs: []
  type: TYPE_NORMAL
- en: This modification of property values is done after the object `p` is created.
    It is possible to do this modification during the very creation of the object,
    in the `new` instruction. This requires defining a method called `constructor()`,
    which allows this initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Using the class constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `constructor()` method is called the constructor of the class. It is automatically
    called during each `new` statement if the `constructor()` method exists in the
    class. We define it in a class if we want to perform a specific process each time
    an object is created in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `constructor()` method can have any number of parameters or none at all.
    The parameters indicated here will be used to initialize the `lastname` and `firstname`
    properties of the person:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a constructor for the Person class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `constructor()` method is defined by giving it the three parameters `lastname`,
    `firstname`, and `age`. They are transferred into the properties of the object
    by means of `this.lastname`, `this.firstname`, and `this.age`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the object `p` is now created by passing as parameters the values of
    `lastname`, `firstname`, and `age` of the person created with `new`. Here, `age`
    is not specified in parameters in the `new` instruction; it will therefore be
    an `undefined` value that will be transmitted to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Using a constructor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Using a constructor
  prefs: []
  type: TYPE_NORMAL
- en: 'We find the `lastname` and `firstname` properties initialized, but the `age`
    property is now initialized to the value `undefined` instead of `0`. To assign
    it another value, simply pass an additional value when creating the object with
    `new`. This additional value will represent the person’s age, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Using age when creating Person class object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.8 – The person''s age is now transmitted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – The person’s age is now transmitted
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create an object, by directly defining its properties and
    methods using a class. However, we can also create an object from another object.
    Let’s see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Merging one object with another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be cases when you want to create a new object from an old object.
    Let’s see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: If the object `p` contains a value, the statement `var p2 = p` does not create
    a new object `p2` distinct from the object `p`, but only a reference `p2` that
    points to the same value as the reference `p`. So any modification of the properties
    of the object `p` will also be visible in the object `p2` because both point to
    the same memory location.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be verified using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an object in memory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Even if only the `p2` object is modified, the `p` object is also modified because
    they are memory references that point to the same location. If the contents of
    the memory location are changed, both references see the same change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this situation, it would not be necessary to write `p2 = p`, but rather
    to copy the properties of the object `p` into those of the object `p2`, thus creating
    a new memory location. For this, JavaScript offers the spread operator, used in
    the form `…`, which allows it:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the spread operator ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The spread operator is used by surrounding the original object with braces `{
    and }`, and preceding the object with the spread operator (for example, `{...p}`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Using the spread operator...'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Using the spread operator...
  prefs: []
  type: TYPE_NORMAL
- en: Object `p` is no longer modified when object `p2` is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to write it in shortened form:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating object p2 from object p, adding the city
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have looked at classes and objects and how to work with them, let’s
    take a look at an important class object: the `Array` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays store a collection of data, ordered according to their index. The index
    is also called the index of the array. It starts at 0 and scales up to the total
    number of elements in the array, minus 1 (0 to n-1).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to create an array first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array corresponds in JavaScript to an `Array` class object. We therefore
    create an array using the `new Array` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: However, since arrays are widely used in JavaScript programs, it is also possible
    to create them using a bracket notation `[ and ]`. This is an easier way to use
    them without going through the `Array` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a detailed look at these two ways to create an array (with brackets
    and with the `Array` class).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array using square brackets [ and ]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest and fastest way to create an array is to use the bracket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array using square brackets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The array begins with an opening square bracket `[` and ends with a closing
    square bracket `]`. The elements of the array are separated by a comma. We have
    inserted elements here as strings, but in fact, any type of element can be inserted
    into an array.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Elements inserted into an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Elements inserted into an array
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is possible to create an empty array (without any elements). We
    write this as `[]`, without indicating any element inside the square brackets.
    It will then be possible to add elements to this array.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array using the Array class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `Array` class to create an array. The `Array` class includes
    a constructor in which we indicate the list of array elements, each separated
    from the next by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same array as before can be created by the `new Array` statement by writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array using new Array
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.11 – Creation of the array using new Array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Creation of the array using new Array
  prefs: []
  type: TYPE_NORMAL
- en: The array created is the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty array, simply pass no parameters to the constructor by writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty array using new Array()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.12 – Creating an empty array [ ]'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Creating an empty array [ ]
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to create an array, let’s see how to access each of
    its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing array elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous programs, we displayed the entire array, using the `console.log(tab)`
    statement. It is possible to access each element of the array separately. Each
    element can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: By its index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a `for()` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `forEach()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at each of these three ways.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an element by index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take the previous array of five elements, that is, `tab = ["Element 1",
    "Element 2", "Element 3", "Element 4", "Element 5"]`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first element can be accessed by its index 0, that is, `tab[0]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next one, with index 1, will be accessed by `tab[1]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last one, with index 4, will be accessed by `tab[4]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how you will display each element:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying each element of the array by its index
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is displayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Displaying each element by its index'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – Displaying each element by its index
  prefs: []
  type: TYPE_NORMAL
- en: The array contains five elements, which means the indices go from 0 to 4\. However,
    to do a test, we also access the element with index 5\. It is possible to access
    an index of an element that does not exist in the array. The result in this case
    is the JavaScript value `undefined`, which means that the value of this element
    has not yet been assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is possible with this access method to modify the value of an
    array element – just give it a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the value of the elements in indexes 2 and 3 of the array
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Modifying array elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Modifying array elements
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at accessing an element with a `for()` or `while()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an element with a for() or while() loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `for()` and `while()` loops already studied in the previous chapter allow
    you to browse all the elements of an array. The index of the loop starts at 0
    (to access the first element of the array, the one with index 0) and ends at the
    last index of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know this last index, JavaScript provides the `length` property in the `Array`
    class, which allows us to know the total number of elements of an array. The last
    index will be the one with the value `length – 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing array elements with a for() loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Note that the end of the loop is written by testing the value `i < tab.length`.
    This is equivalent to writing `i <= tab.length – 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Accessing array elements with a for() loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Accessing array elements with a for() loop
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at accessing an element with the `forEach(callback)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an element with the forEach(callback) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `forEach(callback)` method is a method defined by JavaScript on the `Array`
    class. It is used to browse the elements of an array by transmitting each of the
    elements of the array to a function passed as a parameter. The function indicated
    as a parameter therefore has access to each element of the array (and to its index
    if necessary).
  prefs: []
  type: TYPE_NORMAL
- en: Callback Function
  prefs: []
  type: TYPE_NORMAL
- en: The principle of indicating a function in the parameters of a method is very
    common in JavaScript. The function in the parameters is known as a callback function,
    which means that the actual processing to be executed is that indicated in the
    callback function.
  prefs: []
  type: TYPE_NORMAL
- en: We show here how to use a callback function indicated in parameters of the `forEach(callback)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `tab` array of five elements seen previously, to which we apply
    the `forEach()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing array elements using the forEach() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: We indicate a function as a parameter of the `forEach()` method. This so-called
    callback function will be called automatically by JavaScript for each element
    of the `tab` array (which uses the `forEach()` method).
  prefs: []
  type: TYPE_NORMAL
- en: The callback function takes as its first parameter the element of the array
    for which the function is called (parameter `elem`), and its index (parameter
    `i`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Accessing array elements using the forEach() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Accessing array elements using the forEach() method
  prefs: []
  type: TYPE_NORMAL
- en: The result is the same as that obtained by the `for()` loop. However, there
    is a (small) difference that we discover right away.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the for() loop and the forEach() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous program did not show any difference between the `for()` loop and
    `forEach()` method results to access array elements.
  prefs: []
  type: TYPE_NORMAL
- en: To show the difference between these two approaches, let’s introduce a new element
    in the array, at index 10, knowing that the last index used during the creation
    of the array was 4\. We thus create a new element that is much further away than
    the current last element of the array. How will the array react to this enlargement?
  prefs: []
  type: TYPE_NORMAL
- en: Addition of an element at index 10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: We add an element to the array using `tab[10] = "Element 9"`, then display the
    contents of the array using the `for()` loop and then the `forEach()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is displayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Adding an element at index 10 of the array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Adding an element at index 10 of the array
  prefs: []
  type: TYPE_NORMAL
- en: The display of the `for()` loop shows that the elements with indices 5 to 9
    exist but are of value `undefined`, because effectively, no values have been inserted
    for these indices of the array. However, the indices 5 to 9 with their `undefined`
    values are displayed by the `for()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the `forEach()` method provides the callback function indicated
    in parameters with only the array elements that have actually been affected in
    the array. This therefore avoids the elements at indices 5 to 9, which have not
    been assigned in the program.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create an array, then how to access each of its elements.
    Let’s look at how to add new elements to the array.
  prefs: []
  type: TYPE_NORMAL
- en: Adding items to the array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the array has been created (empty or not), it is possible to add elements
    to it. We will mainly use one of the two following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an element by its index in the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an item using the `push()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s take a look at these two techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an element by index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This corresponds to the assignment `tab[i] = value`. We used it in the previous
    section by writing `tab[10] = "Element 9"`.
  prefs: []
  type: TYPE_NORMAL
- en: Note simply that if the index used is greater than the current number of elements
    in the array, this enlarges the array by creating elements initialized to the
    value `undefined`. And if the index used is less than the number of elements in
    the array, it modifies the current value of the targeted element.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an element using the push() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `push()` method is defined in the `Array` class. It allows you to add a
    new element to an array without worrying about the insertion index because it
    automatically inserts the element at the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an element using the push() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The instruction `tab.push("Element 6")` inserts this element at the end of the
    array. The array is then displayed using the various methods seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Adding an element using the push() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Adding an element using the push() method
  prefs: []
  type: TYPE_NORMAL
- en: We know how to add and modify elements in an array. All that remains is to know
    how to delete elements from an array.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting array elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript allows us to delete array elements in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the value of the element in the array, while retaining the element
    in the array with an `undefined` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the element itself from the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine these two possibilities now.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element value (without deleting the element from the array)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the `delete` keyword to delete the value of an element in an array.
    For example, `delete tab[0]` deletes the value of the element with index 0 in
    the array `tab`, by assigning it the value `undefined`. The element is not removed
    from the array, which still has the same number of elements as before:'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the value of the element with index 0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.19 – Deleting the value of the element with index 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Deleting the value of the element with index 0
  prefs: []
  type: TYPE_NORMAL
- en: We see that the `for()` loop displays the `undefined` value of the element,
    while the `forEach()` method no longer displays the element because its value
    has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that if instead of using `delete tab[0]`, we use `tab[0] = undefined`,
    the `forEach()` method displays the element at index 0 as the first element of
    the array, because the value of the element has not actually been deleted but
    rather assigned to a new value, which here is `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the second method for removing the element from the array.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element from an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `delete` keyword does not delete the element from the array, which
    retains the same number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `splice(begin, count)` method defined in the `Array` class allows you to
    physically remove the element from the array, which will therefore have at least
    one element less after its use.
  prefs: []
  type: TYPE_NORMAL
- en: The `splice(begin, count)` method includes the `begin` and `count` parameters,
    which allow you to indicate from which index you want to delete (`begin` parameter)
    the elements and the number of consecutive elements you want to delete (`count`
    parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to remove the element with index 0 from the array `tab`, just write `tab.splice
    (0, 1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing element with index 0 in array with splice() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Deletion of element with index 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.20_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – Deletion of element with index 0
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to add and delete elements in an array. Now let’s see how to
    extract a new array from the elements present in the current array.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to filter the elements of an array, for example, to keep only certain
    elements or to return new ones. The `Array` class has two methods—`filter(callback)`
    and `map(callback)`—that allow us to return a new array according to our conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the filter(callback) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tab.filter(callback)` method returns a new array while keeping only the
    desired elements of the `tab` array.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function of the form `callback(element, index)` is called for each
    of the elements of the array `tab`. It must return `true` if we decide to keep
    the element; otherwise, the element is excluded. A new array is returned as a
    result by the `tab.filter()` method, but the original `tab` array is not modified
    (unless it is assigned in return from the method, as in the following example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `filter()` method to keep only the elements of the array whose
    index is greater than or equal to 2:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the filter() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'If the callback function returns `true`, the element is kept; otherwise, it
    is excluded. The callback function can also return `false`, or even return nothing,
    like here, and in this case, the element is excluded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Using the filter() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.21_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – Using the filter() method
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the filter() method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the map(callback) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tab.map(callback)` method is used to return a new array from the elements
    of the initial `tab` array. Each element of the initial array is passed to the
    callback function of the form `callback(element, index)`, which must return for
    each element a new element that will replace the original element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `map(callback)` method to return a new array in which all elements
    have been capitalized:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the map() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The `toUpperCase()` method is a method defined on the `String` class (following
    screenshot), allowing you to capitalize the character string that uses the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is displayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Using the map() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.22_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Using the map() method
  prefs: []
  type: TYPE_NORMAL
- en: 'We have studied in this section the use of objects of the `Array` class. Another
    class of objects is also widely used with JavaScript: character strings, which
    are represented by the `String` class. Now let’s see how to use objects of the
    `String` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Character strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are widely used in programming languages. They are used to represent
    text entered by a user or text that will be displayed to a user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a character string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A character string is represented by an object of class `String`. But since
    character strings are widely used in JavaScript, the language allows them to be
    used by surrounding them with double quotes `" and "` or single quotes `' and
    '`. It is also possible, for certain uses, to use backticks (reverse quotation
    marks `' and ')`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The string literal must in this case begin and end with the same type of quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to create a string using these various methods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a string literal using double or single quotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to create a string literal is to use the single or double quote
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a string literal with double quotes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, with single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a string literal with single quotes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the character string displayed is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Creating a character string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.23_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23 – Creating a character string
  prefs: []
  type: TYPE_NORMAL
- en: Advantage of Having the Option to Use Single/Double Quotation Marks
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of having the possibility of using single or double quotes is
    visible if the string itself contains quotes. For example, if the string is `"I'll
    love JavaScript"`, using single quotes to create the string will produce an error
    because the string will be assumed to end with the apostrophe in the word `I'll`.
    In this case, you must use double quotes to avoid the error.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a string literal using backticks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use backticks. This is useful in special cases where you want to
    use the value of variables in character strings in a simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to display a string that uses a person’s first
    and last name. The last name and first name are in variables named `lastname`
    and `firstname`:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating strings and variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: When using reverse quotes, the `+` symbol is no longer used to concatenate strings
    and variables. Everything is written in a single string, and the variables are
    identified by the “symbols” `${variable}`.
  prefs: []
  type: TYPE_NORMAL
- en: What is written between the braces `{ and }` can be a simple variable (like
    here), but also a more complex JavaScript expression that can be calculated (for
    example, `{a+b}`).
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the two result strings are identical.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Sequence of character strings and variables creating a string
    using the String class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.24_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – Sequence of character strings and variables creating a string
    using the String class
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is possible to use the `String` class to create the character string.
    The `String` class has a constructor in which the string to be constructed is
    indicated as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the String class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure displays the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Using the String class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.25_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.25 – Using the String class
  prefs: []
  type: TYPE_NORMAL
- en: The `String` class has properties and methods. For example, the `length` property
    lets you know the number of characters in the string, and thus lets you compare,
    for example, the length of two character strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `length` property to display the length of the two strings created
    using quotes and the `String` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the length property of the String class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Using the length property of the String class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.26_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.26 – Using the length property of the String class
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how the string is created, its length is the same (here, 20 characters).
    We have seen how to create a character string, now let’s see how to access the
    characters that compose it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing characters in a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class defines methods for accessing characters in the string. These
    are, in particular, the `charAt(index)` and `slice(start, end)` methods. `charAt(index)`
    is used to retrieve the character located at the index indicated in the string,
    starting from index 0\. The maximum index is that associated with the value of
    the `length` property, reduced by 1\. `slice(start, end)` breaks the string into
    a substring, by extracting the characters that go from the `start` index (included)
    to the `end` index (excluded).
  prefs: []
  type: TYPE_NORMAL
- en: Using the charAt(index) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use the `charAt(index)` method to display the characters of a string,
    one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying characters from a string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of reverse quotes to display the result string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is displayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – Using the charAt() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.27_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.27 – Using the charAt() method
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the `slice(start, end)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the slice(start, end) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding `charAt(index)` method retrieves a single character from the
    string, while the `slice(start, end)` method can retrieve several consecutive
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `slice(start, end)` method does not modify the string on which
    the method applies, but rather returns a new string. The original string is not
    modified, allowing it to remain intact.
  prefs: []
  type: TYPE_NORMAL
- en: Using slice() on the “Hello” string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: If the `end` index (second parameter) of the `slice(start, end)` method is negative,
    it means counting starts from the end of the string (instead of the beginning
    if it is positive).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Using the slice() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.28_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.28 – Using the slice() method
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to get the characters that make up the string, let’s
    look at how to modify the string.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a character string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To modify a string, there is only one possibility: you have to construct a
    new one from it. The original string cannot be changed directly.'
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will use the previous `slice()` and `charAt()` methods, which will
    make it possible to extract parts of the original string, in order to build the
    resulting string.
  prefs: []
  type: TYPE_NORMAL
- en: But to search or modify parts of character strings, it is better to use regular
    expressions. We study them below.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions are related to strings. They are used to check whether a
    string has a certain format (for example, the format of an email, of a telephone
    number, and so on), or to replace the characters that are in this format with
    others.
  prefs: []
  type: TYPE_NORMAL
- en: For this, the `String` class has the `match(regexp)` method to check whether
    a character string has a given format and the `replace(regexp, str)` method to
    replace the part of the string in this format with the new string `str`.
  prefs: []
  type: TYPE_NORMAL
- en: In both methods, the `regexp` parameter corresponds to a regular expression,
    the meaning of which we will study next.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a string has a given format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `match(regexp)` method is used to check whether the character string on
    which the method is used is in the format indicated in `regexp`. The `regexp`
    parameter is called a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is a sequence of characters surrounded by `/` and `/`,
    for example, `/abc/`. The regular expression `/abc/` means that we are looking
    for the sequence of characters `abc` in the character string. If the string contains
    the sequence `abc`, the `match(/abc/)` method returns this sequence of characters
    as a result, otherwise it returns the value `null`.
  prefs: []
  type: TYPE_NORMAL
- en: A full description of regular expressions can be found at [https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/RegExp](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/RegExp).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of regular expressions with the values returned when
    using the `match()` method on the string `"Hello"`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using match(regexp)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: When the regular expression is found in the `"Hello"` string, the part of the
    string found is returned by the `match()` method, otherwise it returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The `i` sign at the end of the regular expression indicates that uppercase or
    lowercase letters must be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The square brackets `[` and `]` around a series of letters mean that only one
    of these letters is required.
  prefs: []
  type: TYPE_NORMAL
- en: The question mark `?` means that the preceding character is optional (it can
    be present or not).
  prefs: []
  type: TYPE_NORMAL
- en: The braces `{min,max}` mean that the preceding character must be present at
    least `min` times and at most `max` times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the previous program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Using regular expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.29_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.29 – Using regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Writing a regular expression can sometimes be complex to formulate. The site
    [https://regex101.com/](https://regex101.com/) allows you to test the regular
    expressions you want.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression can also modify parts of character strings, using the `replace()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a part of a string with a given format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `replace(regexp, str)` method is used to replace the part of the string
    having the format of the regular expression `regexp` with the string `str`. It
    returns a new string, and the original one is not modified. If the format indicated
    by the regular expression is not found, the original string is returned with no
    modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the regular expressions from the previous example and replace the
    string found with the string “abc”, thanks to the regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the replace() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – Using the replace() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.30_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.30 – Using the replace() method
  prefs: []
  type: TYPE_NORMAL
- en: All executions of previous programs were executed immediately. We are now going
    to study how to perform deferred processing over time.
  prefs: []
  type: TYPE_NORMAL
- en: Multitasking in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you start coding in JavaScript, a question often comes up: is it possible
    to perform several processes simultaneously (what is called multitasking in computing)?
    This would be useful if a process to be executed will take a long time, so as
    not to block other equally urgent processes.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript does not allow several processing operations to be carried out simultaneously.
    On the other hand, it is possible not to block the program (both on the client
    side in the browser, and on the server side with Node.js) by using the callback
    function (which we have already talked about when studying the `forEach()`method
    in the *Accessing an element with the forEach(callback) method* section).
  prefs: []
  type: TYPE_NORMAL
- en: Callback Function
  prefs: []
  type: TYPE_NORMAL
- en: A callback function corresponds to a processing function used as parameters
    of a JavaScript method or function. The callback function will be executed at
    the desired time by the method or function that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js makes extensive use of this feature. For example, when reading a file,
    the `readFile(callback)` method calls the callback function as a parameter when
    the file has been read, which allows the program not to block the pending processing
    of the file to be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript defines as standard two main functions that use this callback function
    concept: the `setTimeout()` and `setInterval()` functions. Both these use a callback
    function as a parameter. We’ll describe these two functions next.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the setTimeout() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setTimeout(callback, timeout)` function is used to position a processing
    function (the `callback` function) that will be executed when the time period
    expressed by `timeout` (in milliseconds) has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you, for example, to perform processing after 5 seconds (that is,
    5,000 milliseconds). You can execute other instructions while waiting for this
    delay, so the program is not blocked during this time:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing instructions after a delay of 5 seconds
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: We display a message (`"Before setTimeout()"`) in the console at the start of
    the program. We program a delay of 5 seconds, after which a callback function
    is triggered, which displays another message in the console (`"In the callback
    function"`). Finally, we end the program by displaying a new message (`"After
    setTimeout()"`).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run this program with the `node testnode.js` command, for example. To
    test this program in a browser, simply place the preceding JavaScript code between
    the `<script>` and `</script>` tags of the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the display after 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – Using setTimeout()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.31_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.31 – Using setTimeout()
  prefs: []
  type: TYPE_NORMAL
- en: Note that the display message of the start and that of the end follow each other,
    even though the 5-second time limit has not elapsed. This shows that the program
    is not blocked, waiting for the timeout to expire.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the display after at least 5 seconds (when the
    delay used in the `setTimeout()` method has elapsed).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – Display when the 5-second delay has elapsed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.32_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.32 – Display when the 5-second delay has elapsed
  prefs: []
  type: TYPE_NORMAL
- en: We see that when the 5-second delay has elapsed, the callback function registered
    in the `setTimeout()` function is called automatically by the `setTimeout()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s improve the program by displaying the time when the messages are displayed.
    This makes it possible to verify that the 5-second time limit is respected:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the time when messages are posted
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: The `time()` function is used to generate a character string that contains the
    time in the form HH:MM:SS. This time is displayed at the beginning of each message
    displayed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: The `Date` class used here is a JavaScript class that allows you to manage dates
    and to extract hours, minutes, and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33 – Displaying the time when messages are displayed in the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.33_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.33 – Displaying the time when messages are displayed in the console
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the callback function is executed at the end of the
    5-second period indicated in the parameter of the `setTimeout()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the setInterval() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setInterval(callback, timeout)` function is similar to the `setTimeout()`
    function seen previously. But instead of executing the callback function only
    once at the end of the delay (as the `setTimeout()` function does), the `setInterval()`
    function executes the callback function repeatedly by setting a new delay at the
    end of it. The callback function is therefore executed at regular intervals. The
    only way to stop this cycle is to use the `clearInterval()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `setInterval()` function is very useful for running processes at regular
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `setInterval()` function to display, every second, the value
    of a counter initialized to `1`. The counter is incremented every second:'
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing a counter every second
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.34 – Incrementing a counter every second'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.34_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.34 – Incrementing a counter every second
  prefs: []
  type: TYPE_NORMAL
- en: The counter increments every second, indefinitely. To stop this endless cycle,
    you have to use a new JavaScript function, which is `clearInterval()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the clearInterval() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `clearInterval(timer)` function is used to stop the cycle started during
    the `setInterval()` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that multiple timers can be started by multiple calls to the `setInterval()`
    function. So the `clearInterval(timer)` function must specify which timer it wants
    to stop: the `timer` parameter is used to tell it.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, the `setInterval()` function returns the `timer` parameter that
    will be used when calling the `clearInterval(timer)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `clearInterval()` function to stop the timer when the `count`
    counter has reached the value `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the clearInterval() function to stop the timer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'The program of the callback function is modified: as soon as the counter reaches
    `5`, the timer is stopped. Otherwise, the counter is incremented by 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that the count stops after 5 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.35 – Timer stops after 5 counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.35_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.35 – Timer stops after 5 counts
  prefs: []
  type: TYPE_NORMAL
- en: The callback function that is used in the `setTimeout()` or `setInterval()`
    functions is included directly in the parameters of each function. JavaScript
    makes it easier to write callback functions by using a new type of object called
    a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Using promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises are another way to use callback functions. Rather than integrating
    the callback function into the method call (as a parameter), we use it as a parameter
    of the new `then(callback)` method. This simplifies the reading of JavaScript
    code in case it uses callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: For an object to use the `then(callback)` method, it must be a `Promise` class
    object. The `Promise` class is a class defined in JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise Class
  prefs: []
  type: TYPE_NORMAL
- en: A `Promise` class object uses a callback function of the form `callback(resolve,
    reject)` as a parameter of its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `resolve` and `reject` parameters are functions, which will be called from
    the promise’s callback:'
  prefs: []
  type: TYPE_NORMAL
- en: When the `resolve()` function is called, it triggers the `then(callback)` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `reject()` function is called, it triggers the `catch(callback)` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `resolve()` function must be called, otherwise the `then(callback)` method
    cannot be executed. On the other hand, calling the `reject()` function is optional,
    and if it is not used, the `catch(callback)` method will not be called (and therefore
    does not have to be present in the program).
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `resolve` and `reject` parameters, we therefore have the possibility
    of executing the cases of success (with the `then(callback)` method) and the cases
    of failure (with the `catch(callback)` method). This way of writing ensures more
    readability of the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let’s take the example of the `setTimeout(callback, timeout)`
    function seen previously. The callback function is included in the method call
    here, which we want to avoid with promises. Let’s write the new `wait(timeout)`
    method that can be used in the form `wait(timeout).then(callback)`. The callback
    function is now externalized from the `wait()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function registered in the `then(callback)` method will be called
    when the timeout expires.
  prefs: []
  type: TYPE_NORMAL
- en: This form of writing is more readable than the previous one with `setTimeout()`,
    because it thus shows the delay before a process is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, the `wait(timeout)` method must return a `Promise` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Promise object, then using the then() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: The `wait()` method returns a `Promise` object thanks to the `return new Promise()`
    statement. In the `callback(resolve, reject)` function, we call the `resolve()`
    function when we consider that the `then()` method can execute, here at the end
    of the timeout.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to specify arguments for the `resolve()` and `reject()` methods.
    These arguments will be used in the callback functions used in the `then(callback)`
    or `catch(callback)` methods. For example, here, we call the `resolve(sec)` method,
    which allows us to use the `sec` parameter in the callback function of the `then()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `reject()` function is not used in our example because no error
    cases can occur here. The `resolve()` function must, however, be called; otherwise,
    the `then()` method will never be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `time()` function is used to display the times of each process to check
    that the execution is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.36 – Using the then() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.36_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.36 – Using the then() method
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we went through advanced concepts related to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use classes and objects, particularly the `Array` and `String`
    classes. We also saw how to delay the execution of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, we will discover the use of the Vue.js JavaScript library
    associated with the client side of application development.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how the knowledge obtained here will allow us to use this language
    in aspects of client-side and then server-side programming.
  prefs: []
  type: TYPE_NORMAL
