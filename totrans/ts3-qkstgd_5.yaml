- en: Scoping Variables with Different Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we see the most basic concept that is a variable. Knowing what
    is the exact type, from a primitive to an object, is essential for accessing specific
    members. Scoping down the exact type at runtime and design time is crucial, to
    have consistency between the two environments and to have feedback about what
    is possible and what is not. The variety of configurations among the different
    types of variable requires many different patterns that are covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to compare at runtime and design time with `typeof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to check with a guarantee for `undefined` and `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need to check every possibility of a union to have the right type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the limitation of `instanceof`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why a discriminator is essential for type identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why using `user` defined `guard`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and why to cast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a type assertion?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compare classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to narrow type for function with a union in signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing at runtime and design time with typeof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript brings type in JavaScript, but this is mostly true at design type.
    TypeScript during compilation removes all the type. This is the reason that the
    code produced is purely JavaScript and does not contain any trace of interfaces
    or types. The purity of respect for JavaScript makes type comparison harder because
    it cannot rely on the name of the type to perform a type check. However, we can
    use all JavaScript's tricks to know whether a value is from a different type.
    The first feature answers the main question of this section about how to compare
    runtime and design type. The use of the JavaScript `typeof` operator that is present
    in JavaScript is also working the same way in TypeScript. The `typeof` operator returns
    the type of a primitive, or it returns `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is simple: call `typeof` followed by the variable that you want to
    compare it with. Most of the time, you will compare it to the name of the type
    that requires being written in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` operator is especially used when having a union type where an
    object can be from many primitives. In fact, it can be used even with a union
    that has a complex object (interface or type) because `typeof` returns `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To know which type of object the object is will require the use of other mechanisms
    that we will cover in this chapter. Before moving on, even if `typeOf` is comparable
    to a string, the result of the operation can be set a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `typeOf` works on primitive types but behaves strangely with `undefined`
    or `null`. However, `undefined` will return `undefined` and null will return `object`.
    The best approach to check for `undefined` or `null` is to not use `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Differentiating undefined from null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While  `typeof` returns the `undefined` string when performing against an undefined
    type, it returns `object` against `null`. This inconsistency becomes an issue
    when you forget which case can use `typeof` by performing the wrong operation
    for the wrong `no type` type. However, `undefined` and `null` do not require the
    use of `typeof` to do a type check. It is possible to compare directly the variable
    against `undefined` or  `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In a situation where a variable can be undefined or null or any other primitive,
    the best way is to check for the nullability of the type and carry on with further
    type comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the type of element in a union
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript inference system gets better with every version. In the most
    recent version, TypeScript uses a control flow to find out in a smart way the
    type depending on how the code is written. If a check is performed in one code
    path, TypeScript knows that for the closure of the type validation that the type
    is as checked. If an *else* code path exists to a type check, it knows that it
    is the reverse of the type comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows that depending on the position of the execution
    the type changes. It starts as a number or undefined. The value check against
    `undefined` makes the value narrow down to an undefined value for the scope of
    the `if`. The `else` can only be everything else than undefined in the union.
    In that particular case, it can only be a number. After `if` and `else`, TypeScript
    cannot know what the type is; thus, the value is back to both potential types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript understands the code flow. It is smart to freeze the type from a
    particular type check. In the following code example, a value equals to undefined
    force the function to return. It means that passing that point, there is no way
    to have an undefined value. The subtraction of `undefined` in the set of potential
    values diminishes the possibility to only a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript narrows down the union from your conditional check for more than
    a primitive. You can also use this behavior with a discriminator and a user-defined
    type guard, which are two patterns that we will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations of instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `typeof`, there is in JavaScript the `instanceof` operator. The
    limitation of `instanceof` is that it can be only used on a type with a prototype
    chain: a class. Like `typeof`, `instanceof` works at design and runtime and is
    native to JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to `typeof`, the result of `instanceof` is not a string and cannot
    be used in the `console.log` function; it is possible to set the value in a type
    or in a variable. It can only be used for comparison purposes. The next example
    does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instanceOf` limitations are beyond just being focused on class. The `instanceOf` operator
    also does not distinguish which class is exactly used in the situation of inheritance.
    In the next code example, the variable ` c` is of type `MyClass3`, which inherits
    `MyClass2`.  `InstanceOf` identifies the variable to be of both types. In the
    following code, both `if` are entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using of a discriminator for type identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript is a structural language, which means that it does not rely on the
    name of the type like a nominal language. JavaScript doesn''t have a type; hence,
    it is a structural language. C# or Java are both nominal languages. The difference
    is important because it means that TypeScript doesn''t check for the name of the
    interface or type to take any decision. This makes sense when we think about how
    TypeScript compiles the code. During compilation, all types are stripped out of
    the code to produce a clean JavaScript. This symbiosis is in respect to JavaScript;
    thus, giving TypeScript the honor of being a superset of JavaScript. However,
    at runtime for TypeScript and design time for JavaScript, we need to know which
    type we are manipulating. In structural code, the approach is to analyze, compare,
    and infer type by looking at the structure. If specific members exist, it gives
    a hint of what we are working on. The following code example shows two identical
    interfaces with the same body, a type with the same structure as well, and the
    first variable with an anonymous type. The object can be of each type because
    it respects the contract of each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the way to make every type different is with the concept
    of a discriminator. A **discriminator** is a member with a shared name between
    a group of a common type that needs to be distinguished. This group is often a
    union. The idea is to have a unique `string literal` per type with the same name.
    Having `string literal` as a type member requires the implementation to implement
    the same `string`. It means that each instance of a specific type will have the
    same `string`. TypeScript can then infer the type by looking at `string literal`.
    The following code example applies this principle. The common member is named
    `kind`*,* and each interface and type has a unique one. The anonymous type tries
    to impersonate `Type1` but fails because the type inferred is a `string` and not
    a `string literal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The discriminator proves to be useful not only for avoid cross type but also
    for narrowing down a type. In a union of many types, when comparing against the
    discriminator, TypeScript will know exactly the type and hence the scope of the
    comparison. The following code allows reducing to the exact type. In that particular
    case, the m1 member is a member that is in all three types and thus does not require
    to be narrowed down to a single type to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an interface with completely different members, the distinction
    is primordial to have access to a member that is unique to one interface or another.
    The following code narrows down the interface, allowing it to use a member from
    the proper type, depending on the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The usage of a string literal as a discriminator is often named the **literal
    type guard** or the **tagged** **union**. It is powerful for functional programming
    and provides a quick way to identify a type without having to develop specific
    conditions as needed in other techniques such as a user-defined guard.
  prefs: []
  type: TYPE_NORMAL
- en: The user-defined guard pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knowing the type of an interface or type can be challenging. We saw in this
    chapter the use of a discriminator. However, there is a drawback with the commonly
    named `string literal` approach, which is with inheritance and intersection. The
    following code does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true with an intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last code example creates for the member kind a type that requires to be
    both `strings literal` at the same time make it impossible to fulfill and not
    practical. With that information to hand, we can see that the discriminator pattern
    works well when inheritance is avoided as well as intersecting. The idea is to
    use a custom user-defined guard per type. This can be cumbersome to create but
    will ensure you the type at design and runtime. The idea is to check for fields
    and see whether they are defined. This technique works well for a type with no
    optional field, since you need to check whether fields exist. As the author of
    the function and the type, you do not need to check every field. You should know
    which field is enough to identify the type. In the following code, both types
    exist, and one type extends the other. Two type user-defined guards are created—one
    for each interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The function must know which of the two types are passed, and it checks by using
    the user-defined guard. The return type of the defined guard is unique. It uses
    the name of the parameter followed by *is* and the type we are expecting if the
    value is `true`. It allows to automatically narrow down to the expected type by
    comparing the structure. If everything is present and defined, it returns `true`,
    but the function will not return an actual `boolean` value. It returns the object
    cast to the type.
  prefs: []
  type: TYPE_NORMAL
- en: The reason to cast a type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Casting** is the act of taking one type and transposing it onto something
    else. It is dangerous and should be used seldomly. The reason casting can have
    side effects is that you are taking manual control of coercing a variable into
    another type. The type may be creating an incompatible and unexpected result.
    A cast is possible for any kind of variable, from a primitive to a more-complex
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic cast scenario is getting a value that is from `any` and to type
    it. The following code shows a number that is set in `any` and then cast to a
    variable of type number. You can notice two different ways to cast. One with the
    smaller and bigger symbol `<>` and one with `as`. The latter is the recommended
    way because it does not confuse code using TSX syntax, which uses the symbols
    for a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code works because the cast went from `any` to `number`. Casting
    a number to a string does not work. The reason is that cast only works if you
    are working with a subtype. Furthermore, `any` is a subtype of everything, which
    allows casting to every type. However, the following code does not compile because
    `variable1` is a number that is cast to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript is also present to avoid casting between objects that miss fields.
    In the following code, both types cannot be cast to each other. TypeScript cannot
    find `m2` in `Type1`, and the second cast cannot find `m1` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, adding `m1` to `Type2` changes the whole situation and allows casting
    in both sides without any compilation errors. The reason is that `Type1` is a
    subtype of `Type2` by its structure, which is what matters in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What is interesting about the last code is that the last cast is useless. The
    reason is that Type2 has all the structure of `Type1`, and `Type1` is a subtype
    of `Type2`. It means that they are structurally equivalent at a minimum point
    in their structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The casting is required for `t1` to `Type2` because `t1` doesn't fulfil the
    contract (it misses `m2` and `m3`). The cast produces a `false` `Type2` because
    `m2` and `m3` are not there, which means they are undefined. `Type2` does not
    have any undefined type for these members, which makes it problematic for future
    usage, since TypeScript will allow `m2` to use any string's function while this
    one is undefined. The casting comes with great responsibilities, and the tampering
    type will make TypeScript unable to perform safe validation.
  prefs: []
  type: TYPE_NORMAL
- en: The slippery slope is steeper when a cast is affecting an object that is `any`.
    It's hard to avoid all  `any`. For example, when data is crossing between systems.
    An Ajax request returns a JSON object, which is an inevitability, as `any`. The
    response is not typed, and to introduce the value into TypeScript, a crucial cast
    is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bad pattern is to cast to `any` and then to the desired type. This is a way
    to short-circuit TypeScript, finding that the cast is not a valid one. Everything
    can be cast to `any` and from any cast to everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What is a type assertion?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are scenarios where you know that a type is not undefined or null but
    that TypeScript will hint that it might be. When this happens, you can perform
    a check against `undefined` or `null` and within the closure of the condition
    will be a guarantee that the type is not nullable. However, three scenarios can
    benefit from having a shorter syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first scenario is with a deep-nesting object. In that case, you may have
    several levels of nullable fields and if you are sure that they are not undefined
    or null, this will be great to avoid having a nested `if` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The conditional check is the safest way to ensure that nothing is undefined.
    However, in some cases, the check may have been made prior to accessing the data,
    but an access to the value is needed outside the scope of the check, which makes
    TypeScript nervous about `if` meanwhile, the state has changed. That would be
    the case if we tried to access `myNumber` right after the previous code. This
    is where `assertion` type comes into play. A `assertion` type is the bang operator,
    or exclamation point, after a member that specifies that the member is not null
    or undefined. You are asserting that this is the case and take the responsibility
    to *un-undefined* or to *un-nullable* to field.
  prefs: []
  type: TYPE_NORMAL
- en: 'It means that you can access the member by using a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is crucial to understand that this can lead to a potential runtime error
    if used at the wrong time. For some reason, any nullable field can become nullable
    if applied at the wrong time or place. There is no guarantee that the execution
    will succeed but will soothe TypeScript error saying that you are accessing a
    nullable field without narrowing it down to the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case of using type `assertion` is when you are defining a field
    in a class. If TypeScript is set to have the compilation strictness to avoid an
    uninitialized field, then you will have an error when defining a field and not
    specifying a value at the declaration or in the constructor. This is a great validation,
    but, in some rare cases, the value may come later in an `initialize` function.
    In that case, you can assert the class''s field to say that you are taking care
    of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, this should be used with parsimony, because it can bring some issues.
    For example, you can now access the member and use it without TypeScript validating
    that the value was assigned before accessing the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This might seem like a trifle, since you know that you will not do such a thing.
    But it can be less obvious. A case of error is that you are accessing the member
    from another public function that might be called before the `init` function causing
    any usage of the variable to be undefined. Type asserting forces TypeScript to
    close its eyes about uninitialized value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last scenario is also dangerous to use and should be coded only with a
    lot of care. You can at any time use the exclamation point to erase the nullability.
    It means that it works with a simple variable as well. The following code declares
    a variable of type string or undefined. It sets its value using a function that
    is immediately invoked. The function has a return type of also `string | undefined`.
    TypeScript concludes that this function may return one or both types, and hence
    could legally return something undefined. However, we know that it is not the
    case, and hence can use the exclamation point to remove the undefined possibility
    and use the string''s functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is dangerous and a better way around it could be employed. The first
    thing is to avoid having a union with `undefined` or `null`. If this is out of
    your control, avoiding functions such as one of the last code examples that aslo
    return undefined. The same code with the return type of string would have solved
    the problem gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes are different than interfaces, types, or primitives. They have a prototype
    chain and obey different rules. For example, two different classes can be interchangeable
    if they have the same structure. The following classes, `C1` and `C2`, are identical
    in terms of structure and can be swapped in the function that requires `C1`. You
    can even instantiate `C2` in a `C1` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add in the `private` field in `C1` or `C2`, then it won''t be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `private` and `protected` fields make each class unique. TypeScript continues
    to compare the structure but does make an exception with regard to these two visibility
    modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is when using inheritance and assigning a child class to a base
    type it must be from the same hierarchy and not something with a similar shape
    that is not from the same hierarchy. The following code shows how without a `private`
    or a `protected` field the base class can be substituted by a single class that
    has the structure of the child and the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, adding a `private` field at the base class `B1` and the same in `C2`
    makes them different, which stops `C2` being addressable to the variable `C2`
    of type `B1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Narrowing type for function with a union in signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Complex functions can be hard to work with. This is often the case with a function
    with one or many parameters of different types, which can also return one or several
    types. TypeScript allows stitching any type together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the code is not compiling. The reason is because the
    function returns a union that must narrow down. However, if we add the overloads
    above the function, we can match the union to one particular set of parameters
    to a single return type. The previous code was not compiling because it was returning
    a union into a single type variable. With a change specifying that when a parameter
    is a number, then the function returns `boolean`, and when it is a string it returns
    a date, no casting or anything is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is beyond just associating a single parameter to a return type. For example,
    in the following code, we make sure we can only send all number parameters together
    or all strings together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to have a better sense of the type of a variable.
    Not only does it help to take decisions, but it narrows down to a single type,
    giving the possibility to access specific members that are specific to a particular
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to generalize a type by using a generic
    variable. Generic variables increase the reusability of objects and variables
    in your code, which reduces the necessity of creating trivial types.
  prefs: []
  type: TYPE_NORMAL
