- en: Chapter 9. What Was I Thinking? Documenting Backbone Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will consider various options for documenting your Backbone
    code, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Non-documentation" approach to documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to explicitly document your code without a formal structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to explicitly document your code using a formal structure such as JSDoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Docco, an alternate documentation tool from the creator of Backbone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backbone and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation is important in any software project, but Backbone projects have
    some unique considerations when it comes to documentation. However, before we
    delve into these considerations, it's important to identify why you are documenting
    your code in the first place, and what strategy you plan to use to document it.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers have the false impression that documentation is for other developers,
    when in fact, nothing could be further from the truth. Most software isn't written
    just once but is instead iterated on over time. Each new revision can occur days,
    months, or even years after the previous one, and when you go back to modify code
    you wrote months/years ago, the code can almost look as if it was written by another
    person.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, even if you are the only developer on your team, and even if
    you know exactly how every last line in your code base works at the moment, it
    is important to document your code, if only for the benefit of your future self.
    Further, if you aren't the only developer on your team, documentation becomes
    all the more important, as it can also serve as a bridge between you and your
    coworkers.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three main approaches to documenting JavaScript code, none of which
    are a one-size-fits-all solution. You will need to determine which approach makes
    the most sense for you and your team on the basis of your team size and the ambitions
    of your project.
  prefs: []
  type: TYPE_NORMAL
- en: The three main approaches can be referred to as the non-documentation, simple
    documentation, and robust documentation approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the larger your team is, and the larger the organization to which
    this team belongs is, the more likely are you to want robust documentation, although
    size isn't the only factor to consider here. Other factors include your team members'
    desire for external documentation and whether or not any of your code is customer-facing
    (for instance, if you offer a public API for your customers to extend your application).
  prefs: []
  type: TYPE_NORMAL
- en: The non-documentation approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let me clarify that the non-documentation approach doesn't mean avoiding
    documentation entirely. Rather, it relies on using forms of documentation other
    than explicit code comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we had wanted to, we could have written a comment describing this line
    of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, adding such a comment doesn't really tell us anything we don't already
    know, because our choice of variable name (`Book`) already tells us what the class
    is. Simply by choosing a descriptive variable name for our class, we have documented
    what it does, without the need of supplemental documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the names of class variables aren''t the only important names. Function
    names, and particularly, method names, can also be very helpful in explaining
    what the function/method does. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just by typing a few extra characters we've eliminated the need to read the
    method's definition in order to understand it. Further, while reading, the definition
    might not seem so hard in this particular example; however, if the function were
    longer or more complex, it might not be so easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other way that functions can be used to convey documentation is by breaking
    them up into separate functions. For instance, let''s say we had a `View` method
    that incremented a counter, saved a `Model`, updated and then rendered another
    `View` method, and finally changed the URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Naming such a method would be difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"incrementCounterAndSaveModelAndUpdateAndRenderSiblingViewAndRefreshURL`"
    doesn''t roll off the tongue very well. You could simplify it to `updateCounterAndRefresh`,
    but then you''d lose some of the non-documentation that the more verbose name
    would provide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to use the simpler name but separate the parts of the
    method into their own methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the contents of our `updateCounterAndRefresh` method now read
    almost like an English documentation string, effectively documenting what's going
    on without any actual documentation. Furthermore, if we wanted to unit test this
    code (which we'll discuss in the following chapter), it will be far easier to
    do so with these separate methods than it would have been originally.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the preceding code is a relatively simple example, while your actual
    methods may in fact be much longer than six lines. In real-world projects, it
    is even more important to utilize this technique of using many (well-named) methods
    rather than long monolithic methods, as it will greatly improve both the code's
    readability and ease of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Class, function, and other variable names are not the only forms of non-documentation.
    File names and folder structure can also provide a great deal of information if
    used correctly. Consider a file named `Book.js`. On its own, we have no way of
    knowing whether this file contains a book `Model`, a book `View`, both, or something
    else entirely. However, if this file were renamed "`BookView.js`", it would be
    obvious. Similarly, if the file retained the name "`Book.js`" but was stored inside
    a "`views`" folder, the contents would again be apparent, without the requirement
    of any additional documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of non-documentation for other approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to the other two documentation approaches, it is worth noting
    that the strategies we just described aren't only useful if you choose the non-documentation
    approach. In fact, they are great advice for all programmers. No matter what documentation
    you generate to supplement your code, at the end of the day, you and your fellow
    developers are going to have to work with the code itself, not the documentation.
    By working to keep that code as readable and instructive as possible, you provide
    benefits that while not the same as those offered by explicit documentation, are
    none the less very valuable, particularly in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: The simple documentation approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Non-documentation is incredibly important to writing maintainable code, but
    it does have its limits. For instance, while you can use expressive variable names
    to describe many variables, you can''t use them to describe parts of Backbone
    itself. For example, when a `View` takes a `model` option, the only way to rename
    it more expressively would be to create an entirely new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is nothing wrong with the above code, but in some sense, it crosses
    the line between *code as documentation* and *replacing documentation with code*.
    In cases like these, a more natural solution may instead be to simply use a comment,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, many programmers find that it''s easy to miss such single-line comments,
    and therefore, they save them only for documenting specific lines of code. For
    class or method documentation, these developers rely on a specialized form of
    the multiline comment, which is marked with an extra leading asterisk and (optional)
    leading asterisks on each subsequent line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most modern code editors will color such documentation differently from the
    rest of the code as well, making it even easier to skim through.
  prefs: []
  type: TYPE_NORMAL
- en: By using a combination of these multiline comments for your classes and methods,
    and using single-line comments to explain the tricky code inside of functions,
    you can very effectively document what class of `Model` a `View` has or which
    routes use a particular `View`. Further, while writing such comments does take
    more time than relying on non-documentation, the few extra seconds that they take
    you to write could save you hours or even days of work later on.
  prefs: []
  type: TYPE_NORMAL
- en: The robust documentation approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Either of the two preceding approaches are enough for most programmers to reap
    the benefits of documentation without having to spend too much time writing it.
    However, if you are looking for a more universal structure to your documentation,
    or if you and your team are not the documentation's only audience, then it might
    be beneficial to use an external tool such as JSDoc or Docco.
  prefs: []
  type: TYPE_NORMAL
- en: In larger organizations, it's not uncommon to have different teams working on
    different parts of the code. When one team needs to use a component or library
    that another team manages, the first team may not want to read the second team's
    code, or for that matter, they might not even have access to it themselves. Robust
    documentation can be useful in these cases by providing a way for teams to understand
    each other's code without having to read it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Another important scenario is user customization. With the robust and powerful
    applications that Backbone enables, it often is only a matter of time before a
    customer requests a way to customize something or, if they can't write JavaScript
    themselves, have a consultant customize it for them. In these cases, the best
    solution is often to expose a subset of the code for the customer to work with,
    and this public customization API will require documentation so that the customer
    (or their contractor) can learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In either of these cases, a tool such as JSDoc or Docco can be used to generate
    separate documentation files that can be shared without sharing the code itself.
    However, at the same time, developers can still write their documentation along
    with their code; there's no need for them to maintain (for instance) a separate
    MS Word document.
  prefs: []
  type: TYPE_NORMAL
- en: Many teams also use the structure of JSDoc within their documentation, without
    ever actually using this tool to generate externally facing documentation. For
    these teams, the main benefit of JSDoc lies in its annotations, which let the
    teams write documentation in a similar manner and in a way that future team members
    are more likely to understand.
  prefs: []
  type: TYPE_NORMAL
- en: JSDoc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSDoc ([http://www.usejsdoc.org](http://www.usejsdoc.org)) is the oldest and
    most popular JavaScript documentation tool available. As far back as 1999, before
    the JSDoc tool even existed, developers used its syntax (borrowed from JavaDoc)
    to document the very early JavaScript code. The JSDoc tool itself, now in its
    third edition, is incorporated into several different other tools (including Google's
    Closure compiler), and support for its syntax can be found in almost every major
    code editor from Sublime to Eclipse to Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using JSDoc, a developer can easily convert his inline documentation into external
    HTML files, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSDoc](img/image00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'JSDoc works by relying on annotations included in documentation strings. For
    instance, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the above code, a developer using JSDoc would use an `@param`
    annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `"@param` annotation tells JSDoc that the method takes a *baz* argument
    and that it should be an instance of the "`Baz`" class. The full list of annotations
    can be found on the JSDoc website, and they are fairly straightforward, so we
    won't discuss all of them here. However, two of them (`@property` and `@param`)
    can be slightly problematic when used with the Backbone code, so let's examine
    how to use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we want to document a Backbone `Model`. For doing so, we
    might write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s assume that our `Book Model` can have three different attributes:
    title, description, and page length. Now, the problem is how do we document them?
    There is no `@attribute` annotation in JSDoc since *attributes* are Backbone-specific
    and the `@param` annotation can seemingly only specify the argument of a single
    attribute; it can''t (for example) tell us that two of the attributes should be
    strings and the others should be integers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, one can use multiple `@param` or `@property` annotations to solve
    this problem (which one you use is up to you; because Backbone creates properties
    for both attributes and options, both are in fact parameters and properties).
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you are using JSDoc informally (that is, you don't plan to generate external
    documentation), you can even simplify the above slightly by leaving out the initial
    `@param {object}` attribute annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Docco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docco([http://jashkenas.github.io/docco/](http://jashkenas.github.io/docco/))
    is notable both because it takes a very different approach from JSDoc and because
    it was written by the creator of Backbone itself (Jeremy Ashkenas). Unlike JSDoc,
    which focuses on creating API documentation, Docco focuses on generating tutorials
    and/or explanations of how a given block of code works. Docco also differs from
    JSDoc in that it uses single-line comments, rather than multiline ones, to generate
    its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of documentation generated using Docco; in fact, it was
    generated using Backbone''s own source code (you can find the original version
    on the Backbone website):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docco](img/image00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding example, Docco generates documentation with
    two columns. On the right is the original source code being documented, minus
    any comments, and on the left are the comments that correspond to this source
    code. For example, here are the original lines from Backbone that were used to
    generate the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A key part of Docco''s appeal is just how simple it is: There are no annotations
    or even multiline comments, just plain old `//` single-line comments. Docco is
    also valuable because of the type of documentation it generates: If you want to
    create a tutorial or walk through of your code Docco is a much better choice than
    JSDoc.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately which documentation system or systems you use will depend on your
    needs and future expectations. Even if you opt for simple documentation, it is
    important that you not underestimate the need to properly document your code.
    If you do, your future self (and possibly your coworkers) will regret it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as with most things in programming, it is also possible to have too
    much documentation. When adding documentation, you should always remember that
    as you refactor and update your code, any documentation written for that code
    must similarly be updated. This certainly shouldn't stop you from adding documentation,
    given its many benefits, but before we move on to testing (which shares the same
    downside), we'd be remiss not to mention this ongoing maintenance cost.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to document Backbone JavaScript code and what
    specific areas to focus on when doing so. We explored three different documentation
    options—non-documentation, simple documentation, and robust documentation—and
    considered two popular tools for generating robust documentation: JSDoc, and Docco.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to test your Backbone code. In particular,
    we'll explore the popular test running frameworks QUnit and Mocha, as well as
    the Sinon library for creating spies, stubs, and mocks.
  prefs: []
  type: TYPE_NORMAL
