- en: Chapter 9. What Was I Thinking? Documenting Backbone Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。我在想什么？记录Backbone代码
- en: 'In this chapter, we will consider various options for documenting your Backbone
    code, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑各种用于记录你的Backbone代码的选项，包括以下内容：
- en: '"Non-documentation" approach to documentation'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “非文档”的文档方法
- en: How to explicitly document your code without a formal structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在没有正式结构的情况下明确地记录你的代码
- en: How to explicitly document your code using a formal structure such as JSDoc
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用形式化的结构，如JSDoc，明确地记录你的代码
- en: How to use Docco, an alternate documentation tool from the creator of Backbone'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Docco，Backbone创建者的一个替代文档工具'
- en: Backbone and documentation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone和文档
- en: Documentation is important in any software project, but Backbone projects have
    some unique considerations when it comes to documentation. However, before we
    delve into these considerations, it's important to identify why you are documenting
    your code in the first place, and what strategy you plan to use to document it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文档在任何软件项目中都很重要，但在文档方面，Backbone项目有一些独特的考虑因素。然而，在我们深入探讨这些考虑因素之前，重要的是要确定你为什么要记录你的代码，以及你打算使用什么策略来记录它。
- en: Many developers have the false impression that documentation is for other developers,
    when in fact, nothing could be further from the truth. Most software isn't written
    just once but is instead iterated on over time. Each new revision can occur days,
    months, or even years after the previous one, and when you go back to modify code
    you wrote months/years ago, the code can almost look as if it was written by another
    person.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者有一种错误的印象，认为文档是给其他开发者看的，但实际上，没有比这更远离真相的了。大多数软件不是一次性写成的，而是在一段时间内不断迭代。每个新版本都可能在前一个版本之后几天、几个月甚至几年后发生，当你回到几个月/几年前写的代码时，代码几乎看起来像是另一个人的作品。
- en: Because of this, even if you are the only developer on your team, and even if
    you know exactly how every last line in your code base works at the moment, it
    is important to document your code, if only for the benefit of your future self.
    Further, if you aren't the only developer on your team, documentation becomes
    all the more important, as it can also serve as a bridge between you and your
    coworkers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，即使你是你团队中唯一的开发者，即使你确切地知道你代码库中每一行的当前工作方式，记录你的代码也很重要，至少是为了你未来的利益。进一步来说，如果你不是你团队中唯一的开发者，文档就变得更加重要，因为它也可以作为你和你同事之间的桥梁。
- en: Documentation approaches
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档方法
- en: There are three main approaches to documenting JavaScript code, none of which
    are a one-size-fits-all solution. You will need to determine which approach makes
    the most sense for you and your team on the basis of your team size and the ambitions
    of your project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记录JavaScript代码有三种主要方法，它们都不是万能的解决方案。你需要根据你团队的大小和项目的雄心来确定哪种方法对你和你的团队来说最有意义。
- en: The three main approaches can be referred to as the non-documentation, simple
    documentation, and robust documentation approaches.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 三种主要方法可以被称为非文档、简单文档和强大文档方法。
- en: In general, the larger your team is, and the larger the organization to which
    this team belongs is, the more likely are you to want robust documentation, although
    size isn't the only factor to consider here. Other factors include your team members'
    desire for external documentation and whether or not any of your code is customer-facing
    (for instance, if you offer a public API for your customers to extend your application).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你的团队越大，这个团队所属的组织也越大，你就越有可能想要强大的文档，尽管大小并不是这里唯一需要考虑的因素。其他因素包括你的团队成员对外部文档的需求，以及是否有任何代码是面向客户的（例如，如果你为你的客户提供了一个公开的API来扩展你的应用程序）。
- en: The non-documentation approach
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非文档方法
- en: First, let me clarify that the non-documentation approach doesn't mean avoiding
    documentation entirely. Rather, it relies on using forms of documentation other
    than explicit code comments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我澄清一下，非文档方法并不意味着完全避免文档。相反，它依赖于使用除明确代码注释之外的其他形式的文档。
- en: 'For instance, consider the following line of code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码行：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we had wanted to, we could have written a comment describing this line
    of code, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们愿意，我们可以写一个注释来描述这一行代码，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, adding such a comment doesn't really tell us anything we don't already
    know, because our choice of variable name (`Book`) already tells us what the class
    is. Simply by choosing a descriptive variable name for our class, we have documented
    what it does, without the need of supplemental documentation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，添加这样的注释并没有真正告诉我们什么我们不知道的事情，因为我们的变量名选择（`Book`）已经告诉我们这个类是什么。仅仅通过为我们的类选择一个描述性的变量名，我们就已经记录了它所做的事情，而不需要额外的文档。
- en: 'However, the names of class variables aren''t the only important names. Function
    names, and particularly, method names, can also be very helpful in explaining
    what the function/method does. Consider the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类变量的名称并不是唯一重要的名称。函数名，尤其是方法名，也可以在解释函数/方法做什么时非常有帮助。考虑以下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just by typing a few extra characters we've eliminated the need to read the
    method's definition in order to understand it. Further, while reading, the definition
    might not seem so hard in this particular example; however, if the function were
    longer or more complex, it might not be so easy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入几个额外的字符，我们就消除了阅读方法定义以理解它的需要。进一步来说，在阅读时，这个特定的例子中的定义可能并不那么困难；然而，如果函数更长或更复杂，可能就不那么容易了。
- en: 'One other way that functions can be used to convey documentation is by breaking
    them up into separate functions. For instance, let''s say we had a `View` method
    that incremented a counter, saved a `Model`, updated and then rendered another
    `View` method, and finally changed the URL, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以用来传达文档的另一种方式是将它们分解成单独的函数。例如，假设我们有一个`View`方法，它增加了一个计数器，保存了一个`Model`，更新并渲染了另一个`View`方法，最后改变了URL，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Naming such a method would be difficult:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 命名这样的方法会有困难：
- en: '`"incrementCounterAndSaveModelAndUpdateAndRenderSiblingViewAndRefreshURL`"
    doesn''t roll off the tongue very well. You could simplify it to `updateCounterAndRefresh`,
    but then you''d lose some of the non-documentation that the more verbose name
    would provide.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`"incrementCounterAndSaveModelAndUpdateAndRenderSiblingViewAndRefreshURL"`听起来并不顺口。你可以简化为`updateCounterAndRefresh`，但这样就会失去一些更冗长的名称提供的非文档化信息。'
- en: 'A better approach is to use the simpler name but separate the parts of the
    method into their own methods, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是使用更简单的名称，但将方法的不同部分分离成它们自己的方法，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see the contents of our `updateCounterAndRefresh` method now read
    almost like an English documentation string, effectively documenting what's going
    on without any actual documentation. Furthermore, if we wanted to unit test this
    code (which we'll discuss in the following chapter), it will be far easier to
    do so with these separate methods than it would have been originally.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们的`updateCounterAndRefresh`方法的内容现在几乎就像一个英语文档字符串，有效地记录了正在发生的事情，而不需要任何实际的文档。此外，如果我们想对这个代码进行单元测试（我们将在下一章讨论），使用这些单独的方法会比最初更容易。
- en: Moreover, the preceding code is a relatively simple example, while your actual
    methods may in fact be much longer than six lines. In real-world projects, it
    is even more important to utilize this technique of using many (well-named) methods
    rather than long monolithic methods, as it will greatly improve both the code's
    readability and ease of testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前面的代码只是一个相对简单的例子，而你的实际方法可能实际上比六行要长得多。在现实世界的项目中，利用使用许多（命名良好的）方法而不是长而单一的代码方法的技术尤为重要，因为这将大大提高代码的可读性和测试的便捷性。
- en: Class, function, and other variable names are not the only forms of non-documentation.
    File names and folder structure can also provide a great deal of information if
    used correctly. Consider a file named `Book.js`. On its own, we have no way of
    knowing whether this file contains a book `Model`, a book `View`, both, or something
    else entirely. However, if this file were renamed "`BookView.js`", it would be
    obvious. Similarly, if the file retained the name "`Book.js`" but was stored inside
    a "`views`" folder, the contents would again be apparent, without the requirement
    of any additional documentation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类、函数和其他变量名不是非文档化的唯一形式。如果正确使用，文件名和文件夹结构也可以提供大量信息。考虑一个名为`Book.js`的文件。单独来看，我们无法知道这个文件是否包含一个`Book`模型、一个`Book`视图、两者都有，或者完全是其他东西。然而，如果这个文件被重命名为"`BookView.js`"，那就很明显了。同样，如果文件保留了名为"`Book.js`"的名字，但存储在名为"`views`"的文件夹中，内容也会很明显，而不需要任何额外的文档。
- en: Benefits of non-documentation for other approaches
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非文档化对其他方法的好处
- en: Before we move on to the other two documentation approaches, it is worth noting
    that the strategies we just described aren't only useful if you choose the non-documentation
    approach. In fact, they are great advice for all programmers. No matter what documentation
    you generate to supplement your code, at the end of the day, you and your fellow
    developers are going to have to work with the code itself, not the documentation.
    By working to keep that code as readable and instructive as possible, you provide
    benefits that while not the same as those offered by explicit documentation, are
    none the less very valuable, particularly in the long run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续介绍其他两种文档方法之前，值得注意的是，我们刚才描述的策略并不仅在你选择非文档方法时有用。实际上，这对所有程序员都是极好的建议。无论你生成什么文档来补充你的代码，最终你和你同行开发者都将不得不与代码本身而不是文档一起工作。通过努力使代码尽可能易于阅读和指导，你提供了虽然与显式文档提供的不同，但同样非常有价值的益处，尤其是在长期来看。
- en: The simple documentation approach
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的文档方法
- en: 'Non-documentation is incredibly important to writing maintainable code, but
    it does have its limits. For instance, while you can use expressive variable names
    to describe many variables, you can''t use them to describe parts of Backbone
    itself. For example, when a `View` takes a `model` option, the only way to rename
    it more expressively would be to create an entirely new property:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 非文档对于编写可维护的代码至关重要，但它确实有其局限性。例如，虽然你可以使用表达性的变量名来描述许多变量，但你不能使用它们来描述 Backbone 本身的部分。例如，当一个
    `View` 接收一个 `model` 选项时，唯一更具有表达性地重命名它的方法就是创建一个全新的属性：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, there is nothing wrong with the above code, but in some sense, it crosses
    the line between *code as documentation* and *replacing documentation with code*.
    In cases like these, a more natural solution may instead be to simply use a comment,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上述代码并没有什么问题，但从某种意义上说，它跨越了 *代码作为文档* 和 *用代码替换文档* 之间的界限。在这些情况下，一个更自然的解决方案可能是简单地使用注释，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, many programmers find that it''s easy to miss such single-line comments,
    and therefore, they save them only for documenting specific lines of code. For
    class or method documentation, these developers rely on a specialized form of
    the multiline comment, which is marked with an extra leading asterisk and (optional)
    leading asterisks on each subsequent line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多程序员发现很容易错过这样的单行注释，因此他们只将它们保存下来以记录特定的代码行。对于类或方法文档，这些开发者依赖于一种特殊的多行注释形式，它以一个额外的前置星号以及（可选的）后续每行的前置星号标记：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most modern code editors will color such documentation differently from the
    rest of the code as well, making it even easier to skim through.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代代码编辑器也会将此类文档与代码的其他部分区分开来，使其更容易浏览。
- en: By using a combination of these multiline comments for your classes and methods,
    and using single-line comments to explain the tricky code inside of functions,
    you can very effectively document what class of `Model` a `View` has or which
    routes use a particular `View`. Further, while writing such comments does take
    more time than relying on non-documentation, the few extra seconds that they take
    you to write could save you hours or even days of work later on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些多行注释来描述你的类和方法，以及使用单行注释来解释函数内部的复杂代码，你可以非常有效地记录 `View` 拥有的 `Model` 类别或哪些路由使用特定的
    `View`。此外，虽然编写这样的注释确实比依赖非文档花费更多时间，但它们所花费的额外几秒钟可能会为你节省数小时甚至数天的工作时间。
- en: The robust documentation approach
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强健的文档方法
- en: Either of the two preceding approaches are enough for most programmers to reap
    the benefits of documentation without having to spend too much time writing it.
    However, if you are looking for a more universal structure to your documentation,
    or if you and your team are not the documentation's only audience, then it might
    be beneficial to use an external tool such as JSDoc or Docco.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两种方法中的任何一种都足以让大多数程序员在不花费太多时间编写文档的情况下获得文档的好处。然而，如果你正在寻找一个更通用的文档结构，或者如果你和你的团队不是文档的唯一受众，那么使用外部工具如
    JSDoc 或 Docco 可能会更有益。
- en: In larger organizations, it's not uncommon to have different teams working on
    different parts of the code. When one team needs to use a component or library
    that another team manages, the first team may not want to read the second team's
    code, or for that matter, they might not even have access to it themselves. Robust
    documentation can be useful in these cases by providing a way for teams to understand
    each other's code without having to read it directly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型组织中，不同团队负责代码的不同部分的情况并不少见。当一个团队需要使用另一个团队管理的组件或库时，第一个团队可能不想阅读第二个团队的代码，或者更确切地说，他们可能甚至没有访问权限。在这些情况下，稳健的文档可以通过提供一种方式，让团队在不直接阅读代码的情况下理解彼此的代码，从而非常有用。
- en: Another important scenario is user customization. With the robust and powerful
    applications that Backbone enables, it often is only a matter of time before a
    customer requests a way to customize something or, if they can't write JavaScript
    themselves, have a consultant customize it for them. In these cases, the best
    solution is often to expose a subset of the code for the customer to work with,
    and this public customization API will require documentation so that the customer
    (or their contractor) can learn how to use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的场景是用户定制。随着 Backbone 所提供的强大和稳健的应用程序，通常只需一段时间，客户就会要求定制某些功能，或者如果他们自己不能编写
    JavaScript，就会要求顾问为他们定制。在这些情况下，最佳解决方案通常是向客户公开代码的一部分以便他们操作，而这个公共定制 API 将需要文档，以便客户（或他们的承包商）可以学习如何使用它。
- en: In either of these cases, a tool such as JSDoc or Docco can be used to generate
    separate documentation files that can be shared without sharing the code itself.
    However, at the same time, developers can still write their documentation along
    with their code; there's no need for them to maintain (for instance) a separate
    MS Word document.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，可以使用 JSDoc 或 Docco 这样的工具来生成单独的文档文件，这些文件可以在不共享代码本身的情况下共享。然而，与此同时，开发者仍然可以边编写代码边编写文档；他们不需要维护（例如）一个单独的
    MS Word 文档。
- en: Many teams also use the structure of JSDoc within their documentation, without
    ever actually using this tool to generate externally facing documentation. For
    these teams, the main benefit of JSDoc lies in its annotations, which let the
    teams write documentation in a similar manner and in a way that future team members
    are more likely to understand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多团队也在他们的文档中使用 JSDoc 的结构，而实际上从未真正使用这个工具来生成面向外部的文档。对于这些团队，JSDoc 的主要好处在于其注解，这使得团队可以以类似的方式编写文档，并且以未来团队成员更可能理解的方式。
- en: JSDoc
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSDoc
- en: JSDoc ([http://www.usejsdoc.org](http://www.usejsdoc.org)) is the oldest and
    most popular JavaScript documentation tool available. As far back as 1999, before
    the JSDoc tool even existed, developers used its syntax (borrowed from JavaDoc)
    to document the very early JavaScript code. The JSDoc tool itself, now in its
    third edition, is incorporated into several different other tools (including Google's
    Closure compiler), and support for its syntax can be found in almost every major
    code editor from Sublime to Eclipse to Visual Studio.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc ([http://www.usejsdoc.org](http://www.usejsdoc.org)) 是最古老且最受欢迎的 JavaScript
    文档工具。早在 1999 年，在 JSDoc 工具甚至存在之前，开发者就使用其语法（从 JavaDoc 借用）来记录非常早期的 JavaScript 代码。JSDoc
    工具本身，现在已进入第三版，被整合到几个不同的其他工具中（包括 Google 的 Closure 编译器），并且几乎在所有主要的代码编辑器中都可以找到对其语法的支持。
- en: 'Using JSDoc, a developer can easily convert his inline documentation into external
    HTML files, as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSDoc，开发者可以轻松地将他的内联文档转换为外部 HTML 文件，如下面的截图所示：
- en: '![JSDoc](img/image00167.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![JSDoc](img/image00167.jpeg)'
- en: 'JSDoc works by relying on annotations included in documentation strings. For
    instance, consider the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc 通过依赖于文档字符串中包含的注解来工作。例如，考虑以下代码：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of using the above code, a developer using JSDoc would use an `@param`
    annotation, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用上述代码不同，使用 JSDoc 的开发者会使用 `@param` 注解，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `"@param` annotation tells JSDoc that the method takes a *baz* argument
    and that it should be an instance of the "`Baz`" class. The full list of annotations
    can be found on the JSDoc website, and they are fairly straightforward, so we
    won't discuss all of them here. However, two of them (`@property` and `@param`)
    can be slightly problematic when used with the Backbone code, so let's examine
    how to use them properly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`"@param` 注释告诉 JSDoc 该方法接受一个 *baz* 参数，并且它应该是一个 "`Baz`" 类的实例。完整的注释列表可以在 JSDoc
    网站上找到，它们相当直接，所以我们在这里不会讨论所有内容。然而，其中两个（`@property` 和 `@param`）在与 Backbone 代码一起使用时可能会有些问题，所以让我们来看看如何正确使用它们。'
- en: 'Let''s imagine that we want to document a Backbone `Model`. For doing so, we
    might write the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要记录一个 Backbone `Model`。为了做到这一点，我们可能会编写以下代码：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s assume that our `Book Model` can have three different attributes:
    title, description, and page length. Now, the problem is how do we document them?
    There is no `@attribute` annotation in JSDoc since *attributes* are Backbone-specific
    and the `@param` annotation can seemingly only specify the argument of a single
    attribute; it can''t (for example) tell us that two of the attributes should be
    strings and the others should be integers.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们的 `Book Model` 可以有三个不同的属性：标题、描述和页数。现在的问题是，我们如何记录它们？JSDoc 中没有 `@attribute`
    注释，因为 *属性* 是 Backbone 特有的，而 `@param` 注释似乎只能指定单个属性的参数；它不能（例如）告诉我们两个属性应该是字符串，而其他属性应该是整数。
- en: 'Luckily, one can use multiple `@param` or `@property` annotations to solve
    this problem (which one you use is up to you; because Backbone creates properties
    for both attributes and options, both are in fact parameters and properties).
    Consider the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以通过使用多个 `@param` 或 `@property` 注释来解决这个问题（使用哪一个取决于你；因为 Backbone 为属性和选项都创建了属性，所以两者实际上都是参数和属性）。考虑以下内容：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you are using JSDoc informally (that is, you don't plan to generate external
    documentation), you can even simplify the above slightly by leaving out the initial
    `@param {object}` attribute annotation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是非正式地使用 JSDoc（也就是说，你并不打算生成外部文档），你甚至可以通过省略初始的 `@param {object}` 属性注释来稍微简化上述内容。
- en: Docco
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docco
- en: Docco([http://jashkenas.github.io/docco/](http://jashkenas.github.io/docco/))
    is notable both because it takes a very different approach from JSDoc and because
    it was written by the creator of Backbone itself (Jeremy Ashkenas). Unlike JSDoc,
    which focuses on creating API documentation, Docco focuses on generating tutorials
    and/or explanations of how a given block of code works. Docco also differs from
    JSDoc in that it uses single-line comments, rather than multiline ones, to generate
    its documentation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docco([http://jashkenas.github.io/docco/](http://jashkenas.github.io/docco/))
    因其采取了与 JSDoc 完全不同的方法，并且是由 Backbone 本身的创造者（Jeremy Ashkenas）编写的而引人注目。与专注于创建 API
    文档的 JSDoc 不同，Docco 专注于生成教程和/或解释给定代码块的工作原理。Docco 与 JSDoc 的不同之处还在于它使用单行注释，而不是多行注释来生成文档。
- en: 'Here''s an example of documentation generated using Docco; in fact, it was
    generated using Backbone''s own source code (you can find the original version
    on the Backbone website):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Docco 生成的文档示例；实际上，它是使用 Backbone 的源代码生成的（你可以在 Backbone 网站上找到原始版本）：
- en: '![Docco](img/image00168.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Docco](img/image00168.jpeg)'
- en: 'As you can see from the preceding example, Docco generates documentation with
    two columns. On the right is the original source code being documented, minus
    any comments, and on the left are the comments that correspond to this source
    code. For example, here are the original lines from Backbone that were used to
    generate the preceding example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，Docco 生成的文档有两列。在右边是正在记录的原始源代码，不包括任何注释，而在左边是与该源代码对应的注释。例如，以下是用于生成前例的 Backbone
    的原始行：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A key part of Docco''s appeal is just how simple it is: There are no annotations
    or even multiline comments, just plain old `//` single-line comments. Docco is
    also valuable because of the type of documentation it generates: If you want to
    create a tutorial or walk through of your code Docco is a much better choice than
    JSDoc.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docco 吸引人的一个关键部分就是它的简单性：没有注释，甚至没有多行注释，只有普通的 `//` 单行注释。Docco 还很有价值，因为它生成的文档类型：如果你想创建教程或代码的遍历，Docco
    比起 JSDoc 是一个更好的选择。
- en: Ultimately which documentation system or systems you use will depend on your
    needs and future expectations. Even if you opt for simple documentation, it is
    important that you not underestimate the need to properly document your code.
    If you do, your future self (and possibly your coworkers) will regret it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将使用哪种文档系统或系统将取决于你的需求和未来的期望。即使你选择了简单的文档，你也绝不能低估正确记录你的代码的需求。如果你这样做，未来的你（以及可能的其他同事）将会后悔。
- en: Of course, as with most things in programming, it is also possible to have too
    much documentation. When adding documentation, you should always remember that
    as you refactor and update your code, any documentation written for that code
    must similarly be updated. This certainly shouldn't stop you from adding documentation,
    given its many benefits, but before we move on to testing (which shares the same
    downside), we'd be remiss not to mention this ongoing maintenance cost.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像编程中的大多数事情一样，也可能有太多的文档。在添加文档时，你应该始终记住，随着你重构和更新代码，为该代码编写的任何文档都必须相应地进行更新。这当然不应该阻止你添加文档，考虑到它的许多好处，但在我们继续进行测试（它也有同样的缺点）之前，我们不应该不提及其持续维护的成本。
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned how to document Backbone JavaScript code and what
    specific areas to focus on when doing so. We explored three different documentation
    options—non-documentation, simple documentation, and robust documentation—and
    considered two popular tools for generating robust documentation: JSDoc, and Docco.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何记录 Backbone JavaScript 代码，以及在进行文档记录时应关注的具体领域。我们探讨了三种不同的文档选项——非文档、简单文档和强大文档——并考虑了两种用于生成强大文档的流行工具：JSDoc
    和 Docco。
- en: In the next chapter, we'll look at how to test your Backbone code. In particular,
    we'll explore the popular test running frameworks QUnit and Mocha, as well as
    the Sinon library for creating spies, stubs, and mocks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何测试你的 Backbone 代码。特别是，我们将探讨流行的测试运行框架 QUnit 和 Mocha，以及用于创建间谍、存根和模拟的
    Sinon 库。
