- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the User Experience, Deployment Options, and DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to discuss a few other “random” topics, but that
    randomness really falls into two categories: the look, feel, and function of your
    site, and some options for deploying it to run for real. Admittedly, they are
    two different gears, but they mesh together in that you want any website you build
    to look good and work well, but obviously, that won’t be the case if you can’t
    build and eventually deploy it somewhere that others can access.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’ll learn about ways to make your website attractive while ensuring
    it is functional for as wide an audience as possible. These are important considerations
    because users are attracted to websites that look good. But, then again, looking
    good doesn’t much matter if the website can’t really be used by them effectively,
    so both are key considerations.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll then learn about **virtual machines** (**VMs**), containers, and the
    cloud, all of which play into the notion of where and how to run your website
    because it has to run somewhere for people to access it! These options provide
    the flexibility and stability you need when putting a website online for all the
    world to see.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll learn a bit about DevOps, which is the modern approach to managing
    those deployments, as well as how you build your website from source code to final
    form. This is important because as a website gets more complex, so does the difficulty
    involved in keeping everything straight and ensuring you deliver high-quality
    results for your clients, and DevOps can help with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter, therefore, will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what makes a website look pretty – graphic design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring it doesn’t just look good but also works well for everyone – **user**
    **experience** (**UX**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtualizing the world – VMs and containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping your head in the clouds – cloud providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking back control – DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Later in this chapter, we’re going to be talking about something called VMs
    and something called containers. As part of that discussion, I’m going to show
    you some basic container functionality. To follow along, you’ll need to do two
    things.
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://www.virtualbox.org](https://www.virtualbox.org) and download
    and install Oracle VirtualBox. This is a program that lets you run VMs (whatever
    those are!).
  prefs: []
  type: TYPE_NORMAL
- en: Once that’s installed, head over to [https://www.osboxes.org/ubuntu](https://www.osboxes.org/ubuntu)
    and download the 23.10 Ubuntu Linux VirtualBox image. Just keep those at the ready
    for later!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’re going to lightly touch on Python, another programming language
    that developers often use. For that, you’ll need to install it on your system
    so that you can play with the sample code. To do so, head over to [https://www.python.org](https://www.python.org)
    and download and install the version appropriate for your system.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also want to make sure you have the source code bundle for this book
    downloaded (as explained in [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082)) and
    the `ch05/1-python` directory at the ready.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what makes a website look pretty – graphic design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so you’ve built a website that works. That’s a fine accomplishment to
    be sure, but what does it *look* like? Is it attractive? Is it pleasing to the
    eye? Is it a work of art? Answering those questions requires delving into the
    realm of graphic design. But, contrary to what you might think from my using the
    word “art” there, it’s surprisingly scientific!
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphic design**, in simplest terms, is the application of certain techniques
    and knowledge about human psychology and even physiology to create visual content
    that communicates messages and does so in a way that is considered visually pleasing
    to many people. It blends creativity and technology to convey ideas through various
    visual means and plays a crucial role in branding, marketing, and media production.'
  prefs: []
  type: TYPE_NORMAL
- en: Graphic designers – as well as web developers who very often find themselves
    playing the role – use various tools and software to create visual compositions
    (in our case, web development tools), which certainly include HTML, CSS, and even
    **JavaScript** (**JS**). While graphic design *is* rooted in art, a good design
    often considers principles such as balance, contrast, and hierarchy to ensure
    effective communication. This is the “science” part I mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: While graphic design, by and large, is about visual appeal – essentially, whether
    what’s on the screen looks pleasing – there’s also an element of usability to
    it. **Usability** refers to the ability of users to get work done efficiently
    with a given human-tool interface, where “tool” here can mean a website. That
    idea gets into something called **UX** – this is a topic that will be coming in
    the next section, but it revolves around things such as whether the user can navigate
    a website efficiently, whether the website meets their expectations in terms of
    functionality, and a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of usability, if you have light-green text on a light-yellow background,
    that will likely be hard for a user to read, making the website less usable. Another
    example is animated backgrounds, which are all the rage on the web these days.
    They look great, but if you don’t properly consider the content that you’re putting
    on top of them, then you may make consuming that content much more difficult for
    users. You might disorient some users, even potentially making them feel sick.
    Applying graphic design principles in such scenarios can help you make the design
    look good while also maintaining solid usability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the key areas that make up graphic design now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding key graphic design areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graphic design touches on several areas, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Typography**: This includes things such as effective font choices, line lengths,
    and spacing, with the goal of making content readable and visually appealing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout and print design**: This is all about arranging visual elements in
    space effectively, ensuring that there is a pleasing use of negative space (empty
    areas) to highlight content better, and effective alignment of elements to make
    scanning content easier on the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branding and logo design**: Proper branding and logo design create a visual
    identity for companies or products. This also includes color palette choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motion graphics**: Not all graphics are static, especially nowadays on the
    web. Adding elements of animation can elevate a design greatly, but there is a
    fine line between elevation and distraction, and that balance must be maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While graphic design techniques and tools evolve constantly, along with the
    technology used to implement designs, the core of graphic design always remains
    true: the visual communication of a message or ideas, effectively and aesthetically,
    and for the web, it also plays a big role in making a website more usable for
    users, meaning less frustrating and distracting from their goals.'
  prefs: []
  type: TYPE_NORMAL
- en: There exists a set of principles that can guide you in your graphic design duties
    called the Gestalt Principles, which we’ll look at now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Gestalt Principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Gestalt Principles** are a set of psychological theories about how humans
    perceive visual elements. They explain why certain elements are perceived as part
    of a group or related in some way. These principles are often applied in graphic
    design to enhance understanding and organization. The principles are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proximity**: Elements that are close to each other are often perceived as
    related or grouped together. In graphic design for the web, related buttons or
    menu items are often placed close to one another to visually communicate that
    they are related functionally. In *Figure 5**.1*, notice how your mind groups
    the twelve squares on the left, the three squares in the upper right, and the
    three screens in the center:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.1: The Gestalt Proximity principle](img/B18315_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The Gestalt Proximity principle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Similarity**: Just as with proximity, when objects look alike, we group them
    together in our minds. This could be in terms of shape, size, or color. In *Figure
    5**.2*, your mind tends to group the dark squares together even when they aren’t
    immediately near each other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.2: The Gestalt Similarity principle](img/B18315_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The Gestalt Similarity principle'
  prefs: []
  type: TYPE_NORMAL
- en: As another example, sizing icons or buttons on a website gives a sense of related
    functionality and allows the user to build a mental model that says, “Things that
    look like this are buttons, and I can click them,” which helps make the website
    more usable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A **mental model** is a common term that refers to the understanding a user
    creates – right or wrong – in their minds about what they’re looking at and what
    they’re doing as they proceed. Users build up mental models as they use an app
    or a website about what it’s doing, how it’s doing it, why, and what the results
    of actions are expected to be. It’s our job to ensure that the mental models users
    build match up with reality through graphic design principles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closure**: Our minds tend to fill in missing information to create a whole
    image. This comes into play when we look at complex arrangements of visual elements.
    Our minds tend to perceive a single, recognizable pattern from them. In the example
    in *Figure 5**.3*, your mind perceives a pentagon even though the line is broken:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.3: The Gestalt Closure principle](img/B18315_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The Gestalt Closure principle'
  prefs: []
  type: TYPE_NORMAL
- en: This may be perfectly fine and even desired, but it can sometimes lead to confusion,
    so you have to take care in your design to avoid this where you can unless it’s
    what you’re going for.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enclosure**: The Enclosure principle describes the tendency of human visual
    perception to group elements together to form a whole, most especially when they
    are enclosed within a boundary of some sort, even if they are otherwise disconnected.
    When we see a set of elements enclosed by a solid border or even just an outline,
    we perceive them as a single, cohesive group, almost as a discrete shape regardless
    of their physical positioning. The example in *Figure 5**.4* causes your brain
    to subconsciously group the three squares inside the large square together even
    though they aren’t near each other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.4: The Gestalt Enclosure principle](img/B18315_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The Gestalt Enclosure principle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuity**: Our eyes follow paths, lines, or curves, often preferring to
    see them as continuing along an established direction rather than making abrupt
    changes. This principle is useful in guiding a user’s attention in a specific
    direction! In *Figure 5**.5*, your mind is in a sense comforted by the subconscious
    expectation that the boxes will get larger as you go down, as they do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.5: The Gestalt Continuity principle](img/B18315_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The Gestalt Continuity principle'
  prefs: []
  type: TYPE_NORMAL
- en: For example, taking the registration page we’ve previously worked on, all the
    entry fields go vertically down the page, in a single line. A user’s eye can follow
    this easily. If one of the fields suddenly aligned to the right side of the page,
    that would be disruptive for users, plus it probably wouldn’t look very good visually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure and Ground**: We instinctively perceive objects as either being in
    the foreground (figure) or the background (ground). This helps designers emphasize
    certain elements, but you must ensure you’re emphasizing the *right* elements
    at the *right* time, or you can confuse users. *Figure 5**.6* shows an example
    of how your mind tends to view the boxes inside the large rectangle as being more
    “up front” than those outside, even if you don’t realize it consciously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.6: The Gestalt Figure and Ground principle](img/B18315_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The Gestalt Figure and Ground principle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connectedness**: Elements that are connected by uniform visual properties,
    such as a line or color, are perceived as being more related than elements that
    aren’t connected. This is often implemented on the web as group boxes – those
    boxes around elements that often have a small title on them. In *Figure 5**.7*,
    the fact that the shapes in each of the two connected groups aren’t the same doesn’t
    stop your brain from thinking of them as connected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.7: The Gestalt Connectedness principle](img/B18315_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: The Gestalt Connectedness principle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Fate**: Elements moving in the same direction are perceived as related
    or grouped. For instance, animations that move cohesively can show they’re part
    of the same action or concept, or even elements that move or are aligned in a
    haphazard way still appear to be grouped to us. *Figure 5**.8* demonstrates how
    your mind will see the boxes on the top being part of a continuous line and the
    boxes on the bottom as part of another continuous line, even though they are not
    spaced or aligned consistently, but because they appear to move in a consistent
    direction or toward a common fate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.8: The Gestalt Common Fate principle](img/B18315_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: The Gestalt Common Fate principle'
  prefs: []
  type: TYPE_NORMAL
- en: These principles help designers – and us web developers – create visual designs
    that are easily understood and processed by our users. By understanding how humans
    naturally group and separate visual information, we can create more effective,
    intuitive, and harmonious graphic design layouts, which for us means websites.
  prefs: []
  type: TYPE_NORMAL
- en: Having elements on the screen that look good and are well organized according
    to graphic design principles are factors in how well a user can actually use your
    site, but there’s more to it than that. Let’s now enter the domain of UX!
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring it doesn’t just look good but also works well for everyone – UX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we briefly discussed graphic design, and I mentioned
    that graphic design has a role to play in something called UX. Let’s dive into
    that topic in more detail now.
  prefs: []
  type: TYPE_NORMAL
- en: UX refers to a person’s overall experience when interacting with a product,
    system, or service, especially in terms of how easy or pleasing it is to use.
    It’s concerned with their perception of a product, with the ultimate goal being
    to make them happy using the thing you produce both before, during, and after
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: UX is an iterative process where you research, plan, test, and then refine the
    various touch points a person has with a product, trying to move closer to those
    goals with each iteration. It’s not about guesswork; it tends to be very scientific.
    You can guess which features of a product will make users happy, but those guesses
    – which should be based on research – are just a starting point. You then need
    to put the product in front of people, see how they interact with it, get their
    feedback, and then tweak the product based on that feedback.
  prefs: []
  type: TYPE_NORMAL
- en: UX isn’t a web development or even a computer thing. In fact, one of the most
    famous books on UX ever, *The Design of Everyday Things* by Don Norman, barely
    even talks about computers, let alone websites – it spends more time talking about
    teapots and turn signals in your car! That’s because UX applies to how humans
    interact with any piece of technology, or really any object more generally. But,
    specifically within the context of digital design, UX focuses on the user’s journey
    through a website or application. So, let’s take a closer look at the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts of UX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the key concepts that comprise UX:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Usability**: This is about how user-friendly and intuitive the interface
    is. It includes ideas such as ease of learning (are users able to discover, without
    reading documentation, how your app works?), efficiency of use (can users get
    work done with a minimum of steps?), memorability, error frequency, severity and
    how easily they can recover from errors, and overall user satisfaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction design**: This involves designing interactive digital products,
    environments, systems, and services. It’s about creating interfaces with well-thought-out
    behaviors. One thing you never want to do with any software product is to surprise
    users. It should be obvious what a button will do if they click it; they shouldn’t
    have to guess. Interaction design largely defines this idea.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User research**: Understanding the users’ needs, motivations, and behaviors
    through methods such as surveys, interviews, and usability testing (oftentimes,
    you’ll literally watch users interact with your website to look for things such
    as if they get frustrated trying to navigate it). This research informs design
    decisions, especially as you iterate the design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information architecture (IA)**: This is about structuring, organizing, and
    labeling content effectively and sustainably. Good IA helps users find information
    and complete tasks. One common tool for IA is a **card-sorting** exercise. Let’s
    say you have several topics to be covered on a website, and some of them are sub-topics
    of others. To organize this, you might write every topic on a literal note card,
    then arrange the top-level topics in a line, and then put the sub-topics beneath
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content strategy**: This involves planning, creating, delivering, and managing
    content. Content should be relevant and useful to users, and you should look to
    minimize extraneous content that might just confuse them or get in the way. In
    graphic design, the idea of negative space is important, which is knowing when
    *not* to put something on the screen. There is value in empty space sometimes,
    but by the same token, there can be value in *not* providing information when
    it won’t help a user achieve their primary goal. The company Apple is a great
    example of this: it tends to minimize options available to users. This can be
    frustrating for some more advanced users, but for typical users, it actually aids
    them because the phenomenon of **analysis paralysis** is avoided by not overloading
    them with options. This applies not only to options but to information as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User feedback**: Continuous collection of user feedback is crucial for iterative
    improvement of the UX. Of course, when initially designing and building a website,
    it’s helpful to get that feedback so that you can make changes as you go. However,
    seeking user feedback shouldn’t stop after the site is live. There’s always room
    for improvement, but you shouldn’t go about this blindly. Hearing from your users
    is a good way to get the information you need to make improvements based on data.
    User feedback can be direct – things such as surveys users can fill out – or indirect
    – perhaps by looking at metrics about things such as how often users click a help
    link, for example. If you find that every user that visits your site looks for
    help or, worse, abandons the site before doing something meaningful, that’s a
    form of feedback that is probably telling you your site isn’t as easy to use as
    you might have thought. Analytics and performance data are, therefore, an aspect
    of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototyping and wireframing**: These are essential tools in UX design. Prototyping
    is about creating a preliminary model of a product, which can be a low-fidelity
    sketch or a high-fidelity interactive model. Wireframes are basic layouts that
    outline sizes and placement of page elements, features, and navigation for your
    website or app. We talked about this in the first chapter, but it’s worth mentioning
    it here to understand how it relates to UX. These are your early “guesses” about
    the overall design that you’ll want to present to users as early as possible so
    that you can begin iterating as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User personas**: These are fictional characters created to represent the
    different user types that might use a service, product, site, or brand. Personas
    help designers and developers understand their users’ needs, experiences, behaviors,
    and goals. What does a persona look like? Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With a persona such as this, design decisions can be made that will address
    the challenges of the client. For example, based on Mike’s challenges, we may
    want to create a design that presents as little information as possible at any
    given time to keep Mike from getting overwhelmed. Also, given his needs, we begin
    to have an understanding of what the interface will look like; in this case, we’ll
    most likely need some visual metaphor that presents categories of information,
    perhaps a tab for each, or maybe sections that can be expanded and collapsed for
    each.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Journey mapping**: This involves creating a visual representation of the
    user’s interaction with a product. It helps in understanding and addressing user
    needs and pain points throughout their journey. As with card sorting, this will
    often take the form of pieces of paper on a large pegboard with string and thumbtacks.
    The pieces of paper may have hand-drawn sketches of various screens, and then
    the string shows how the user will move from one screen or function to the next.
    It certainly doesn’t have to take this form – some people prefer to work in a
    graphics or flowcharting program and do it all digitally – but the low-fidelity
    approach is often employed for both speed and for ensuring you aren’t focusing
    on anything technological. The concerns here shouldn’t take technology into account,
    at least no more than is absolutely necessary. You’re focusing on logic flow and
    nothing more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform consistency**: Ensuring a consistent experience across various
    platforms and devices, which includes maintaining functionality and design uniformity.
    In other words, you usually want a website to look the same on a Windows machine
    as on a Mac machine, and you usually don’t want there to be functionality available
    on a desktop machine that isn’t also available on a cell phone (though the form
    of that function could be different, of course). There are sometimes exceptions
    to this idea, of course – times when it makes sense for things to look different
    or function differently on one platform versus another – but they tend to be just
    that: exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contextual design**: This is about designing based on the understanding of
    how users interact with the product in their actual environment. This often involves
    watching users use your product as they really do, not in a lab setting, because
    sometimes there are considerations you wouldn’t otherwise be aware of. To give
    one example, you could find that users of your factory control system have to
    use your system wearing bulky gloves. This may affect your design by requiring
    that buttons on the screen be much larger than usual so that they are easier to
    tap. You wouldn’t have known this without observing them in their natural environment
    (which means it’s helpful to do this as research *before* you get into designing
    anything too).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability testing**: Regular testing with real users to get feedback on designs
    and functionality, which is crucial for iterative design processes. You never
    want to assume that your designs are ideal; you want to test those assumptions
    as often as you can and make changes based on what you discover. There are many
    forms of usability testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having webcams pointed at users as they test your design.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a usability lab set up where things such as eye tracking (to see what
    a user is actually looking at and fixating on can be determined) and otherwise
    observing them in action come into play.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Having user interviews, where you simply sit with a user and ask them questions
    about their experience (sometimes done as they’re playing with your website; sometimes,
    afterward). Surveys and focus groups can also be considered here too.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other forms, each with a different goal and focus, but all
    with the one common goal of validating your design decisions against real UX.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Design thinking**: A problem-solving approach that involves empathizing with
    users, defining problems, ideating solutions, prototyping, and testing. As designers,
    it’s very easy to make decisions based on what you like and think is optimal,
    but that isn’t always what’s best for users. Research and testing play a big role
    in this, but there’s a larger mindset involved. You have to fight the urge to
    make assumptions and to make decisions based on your own thinking. It’s all about
    the user at the end of the day, which is where the term *user-centric design*
    comes in. The user is the focus; they are the center, and everything you do should
    be based on them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ethics and privacy**: Considering ethical implications and privacy concerns
    in design, especially when dealing with user data. This can come in many forms,
    but one example is simply masking passwords. You’ve certainly seen websites where
    when you type your password, only asterisks appear. This is done so that someone
    can’t stand over your shoulder and see your password. It’s a small, simple example,
    but it shows that design plays a role in privacy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction animation**: Subtle animations can improve the UX by providing
    feedback, demonstrating cause and effect, and adding a layer of polish and professionalism
    to the interaction. We talked about this in the graphic design section, but it’s
    worth calling out as it relates to usability because animation can be a divisive
    topic. Too much animation will actually annoy and frustrate users and maybe even
    make them sick, but too little will often yield a design that isn’t as pleasing
    to use as one with just the right amount used. Given all of this, that’s why the
    use of animation to reflect interactions is important enough to be its own key
    topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual design**: Although distinct from UX, visual design (how things look)
    impacts UX. It includes typography, color schemes, and layout. Effectively, this
    means the same as graphic design, then, but it’s worth being aware of the term
    since you may hear both at various times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating these aspects of UX into your work can greatly enhance the quality
    and user satisfaction of the software products you develop or architect. In your
    role as a web developer, integrating UX principles into your development process
    can significantly enhance the end product’s effectiveness, efficiency, and user
    satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: While in some organizations, there will be an entirely separate group responsible
    for UX, that won’t always be the case, and even when it is, it makes a lot of
    sense for you as a developer to have some grasp of these concepts, if for no other
    reason than to be better able to interface with such separate groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember only one thing from all of this, let it be this: users are
    what it’s all about! You have to base your design decisions on what they need,
    what they want, and what makes them happy. And you need to make those decisions
    based on good research and testing, not assumptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Another topic that has a role to play in UX is accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Considering accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessibility is, in a sense, another aspect of UX, but it’s a large enough
    concern to be its own topic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessibility**, in the context of digital design, refers to the practice
    of making your websites and applications usable by as many people as possible,
    including those with disabilities. This encompasses a wide range of conditions,
    including visual, auditory, physical, speech, cognitive, language, learning, and
    neurological disabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Content Accessibility Guidelines (WCAG)**: These are part of a series
    of web accessibility guidelines published by the **World Wide Web Consortium**
    (**W3C**) ([https://www.w3.org/WAI/standards-guidelines/wcag](https://www.w3.org/WAI/standards-guidelines/wcag)),
    consisting of a set of recommendations for making web content more accessible.
    They encompass many points that you can follow to help make your sites accessible
    to various user groups with different needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<img src="img/companyLogo.png" alt="This is a company logo showing an eagle
    with a fish in its beak">`. Someone who is blind and is using a screen reader
    will have the alt text read out to them, providing a description of the logo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyboard navigation**: Ensure that all interactive elements on a website
    can be accessed and used through keyboard controls, which is crucial for users
    who cannot use a mouse. This is generally easy to achieve and to a large extent
    happens automatically thanks to web browsers. The one thing you need to keep in
    mind, though, is relatively simple things such as the order of elements on a form.
    An HTML form – unless you do something wrong – should be keyboard-navigable by
    default. But if you don’t put the elements of the form in a logical order, what
    can happen is you can make elements that most users need to access more difficult
    to get to via the keyboard. For example, on a user registration form that needs
    a person’s first and last name, you probably don’t want to put the last name at
    the end of the form with 10 other fields between it and the first name field at
    the top.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual design**: This includes considerations for color contrast to aid users
    with color blindness or visual impairments, as well as ensuring text size and
    spacing are adjustable. Some of this again comes for free with web browsers, unless
    you write bad code that gets in the way. But some elements of design come into
    play too – things such as using colors for text that work well against background
    colors, as a simple example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Captioning and transcripts**: Supply captions for video content and transcripts
    for audio content is essential for users who are deaf or hard of hearing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent navigation**: Keep navigation consistent throughout the site helps
    users with cognitive disabilities to better understand and interact with the content.
    This is, of course, good for users who aren’t disabled too, though the difference
    is that someone with disabilities may be unable to use your site while someone
    without disabilities may simply not like using your site. The former is worse,
    but the latter isn’t much better!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error identification and instructions**: Make sure that errors are clearly
    identified and instructions are provided to help users understand how to complete
    tasks, such as filling out forms. You never want to insult your users first of
    all, so simple things such as the wording of error messages are a factor. For
    example, writing “A first name is required” is probably better than “You didn’t
    enter a first name.” But more than that, you want to ensure that your error messages
    and instructions clearly describe what needs to be done as succinctly as possible.
    This is harder than it sounds and is a place where good user research is very
    helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legal compliance**: In many regions, there are legal requirements for digital
    accessibility, such as the **Americans with Disabilities Act** (**ADA**) in the
    US. That means that what we’re talking about here isn’t just good; it’s legally
    *necessary* in many cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating accessibility into your software development and design processes
    not only expands your user base but also reflects a commitment to inclusivity
    and legal compliance. As a software developer/architect, considering accessibility
    from the outset of a project can significantly enhance the usability and reach
    of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: One final topic I want to discuss within the context of UX is something that
    very often plays into designing for mobile devices (though not exclusively), and
    that’s responsive design.
  prefs: []
  type: TYPE_NORMAL
- en: Flexing with responsive design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more topic that plays into UX, but which is often considered its own, separate
    concept, is responsive design. Today, across the world, it’s often said that more
    people are accessing websites from mobile devices such as cell phones than desktop
    computers with large monitors sitting on their desks. Therefore, it’s often a
    good idea to take a mobile-first design strategy – that is, design your website
    to look and work well on small form factor devices such as cell phones, and *then*
    enhance it to work better on larger screens. This is where responsive design comes
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive design** is an approach to website design that has the goal of
    creating sites that provide an optimal viewing experience, meaning it is easy
    to read and navigate with a minimum of resizing, panning, and scrolling, across
    a wide range of devices, from large desktop computer monitors to smaller mobile
    phones. While there are some specific technological components, it’s largely more
    about a basic approach, a mindset even. It’s based on the knowledge that a large
    percentage of the world’s population uses smaller mobile devices to access the
    internet these days rather than desktop computers with, typically, large monitors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key aspects of responsive design include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fluid grids**: The layout of a website can use a CSS construct called flexible
    grids. They adapt to the viewer’s screen size automatically, reflowing content
    or even rearranging it as needed. This also means that instead of designing fixed-width
    layouts, elements on the page are sized in relative units such as percentages,
    rather than absolute units such as pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible images**: Images in responsive design are also fluid. They are sized
    in relative units to prevent them from displaying outside their containing element.
    This ensures that images don’t suddenly take up a large chunk of the screen real
    estate, pushing more important content out of the way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Media queries**: CSS media queries allow the page to use different CSS style
    rules based on the characteristics of the device, most commonly the width of the
    browser. I’ll give an example of this shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile first**: The concept here is that you should design for small screens
    first and then add more features and content for larger screens as necessary.
    It ensures accessibility for mobile users from the start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breakpoints**: In responsive design, breakpoints are used to define where
    the website’s layout should change to accommodate different screen sizes. Common
    breakpoints are set for mobile, tablet, and desktop widths. Breakpoints and media
    queries typically work together in that breakpoints typically are implemented,
    in part, using media queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`em` or `rem` for text sizing, which are alternate units available in CSS (as
    opposed to `px` and `pt`, for example – there are *a lot* of units available in
    CSS for more advanced use cases).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Touch versus mouse**: Developers should be aware that some users will be
    using devices where touch is the primary method of interaction – a smartphone,
    for example – versus desktops that are more often used with mice. Touch interactions
    have different needs than those with a mouse. As one common example, buttons tend
    to need to be larger for touch interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance optimization**: Responsive sites often need to load on various
    devices with different capabilities and connection speeds. While many users will
    have modern, high-powered smartphones, that isn’t always the case. Some may have
    underpowered devices that are simply slower. Therefore, optimizing images, minifying
    CSS and JS (reducing their size through various tools), and leveraging techniques
    such as lazy loading, where images and other content aren’t even loaded until
    the user scrolls far enough down the page for them to be visible, can help improve
    performance for all users, but especially those using weaker devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Responsive designs must be tested on multiple devices and browsers
    to ensure compatibility and usability. This can involve physical device testing,
    emulators, and online sites that can simulate a website across many different
    devices and configurations at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive design is essential in a web environment where users expect a seamless
    experience whether they’re on a phone, tablet, laptop, or desktop. For a web developer,
    understanding the principles of responsive design is crucial for creating web
    applications that are accessible and user-friendly across all devices.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating responsive design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate responsive design at a very simple level, take a look at this
    HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To break it down, let’s look at the `<body>` content first. As you can see,
    it’s three `<div>` elements inside a single `<div>` element. The outer `<div>`
    element is assigned the `container` style class, while all three of the inner
    `<div>` elements have an inline style to give them a gray background color.
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing here is building a page that has three boxes of content. Maybe
    the first is a navigation menu, the second is the main content, and the third
    is probably for some ads (because it seems that every website in the world has
    to have ads today, unfortunately!). This is a pretty typical layout for a website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on a large screen, we want to show this content in three columns, as shown
    in *Figure 5**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Our web page in three columns](img/B18315_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Our web page in three columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, on a smaller device (specifically on a screen less than 600 pixels
    in width), we want this content to wrap so that all three boxes “stack” on top
    of one another, as you see in *Figure 5**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Our web page, now “stacked” so that the boxes are effectively
    rows now](img/B18315_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Our web page, now “stacked” so that the boxes are effectively
    rows now'
  prefs: []
  type: TYPE_NORMAL
- en: This will also happen as you resize the browser window on a large screen. As
    you make the window smaller, the content should automatically reflow as described
    and shown in *Figure 5**.10*, and I encourage you to actually do that now to see
    what happens.
  prefs: []
  type: TYPE_NORMAL
- en: It’s the CSS that is responsible for this rearranging of the content, so let’s
    check that out now.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the `container` class definition, which is applied to our `<div>`
    element. This uses a CSS feature called `display` to `grid` tells the browser
    that the contents inside this `<div>` element should be laid out in a grid, meaning
    we’ll have some number of rows and columns inside it. Setting `grid-template-columns`
    specifies that we want columns, and the `repeat(3, 1fr)` value specifies that
    we want three columns of equal size. The `repeat()` statement allows us to specify
    styles across multiple elements, and the `fr` unit is a flexible unit that allows
    us to define what fraction of the total available space each column gets. So,
    `1fr` means each column, of which there will be three, should get one equal fraction
    of the total, so the browser will distribute the space evenly between them. Finally,
    the `gap` property simply tells the browser how much space, if any, to put between
    the columns. Altogether, this defines the grid layout we want our three boxes
    to use by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the first part of the responsive equation. The second part is the `@media`
    statement, which is a `max-width` part. So, in other words, the style inside this
    media query will only be applied when the width of the browser window is less
    than `600` pixels. This means we’re defining a `600` pixels: we want the layout
    of the page – the `<div>` container, more specifically – to change when we hit
    `600` pixels wide.'
  prefs: []
  type: TYPE_NORMAL
- en: Below 600 pixels, the style applied to the `<div>` container overrides the `grid-template-columns`
    value defined in the `container` class itself, setting it to `1fr`. Since `repeat()`
    is not used this time, we’ll wind up with just a single column, and `1fr` now
    means one fraction of the total space should be allotted to it, but since there’s
    just one column, all the space is used up by it, which causes the boxes inside
    to wrap underneath each other.
  prefs: []
  type: TYPE_NORMAL
- en: You can define as many breakpoints as you like, and you can use media queries
    to apply styles based on other conditions, but when it comes to responsive design,
    it’s nearly always going to be widths such as this.
  prefs: []
  type: TYPE_NORMAL
- en: Progressing with progressive enhancement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another factor that plays into whether a website is accessible or not can depend
    on things beyond your control, such as the capabilities of the browser and even
    a user’s connectivity. We’ve discussed that many users use smaller devices such
    as phones to access sites these days, which will sometimes mean less powerful
    browsers. And even when the browsers are full-featured, imagine the scenario where
    a user is trying to access a site while riding on a train. In such a case, their
    connection speed may be considerably slower than at home and may not be stable
    either.
  prefs: []
  type: TYPE_NORMAL
- en: These sorts of concerns are where an approach to web development called **progressive
    enhancement** comes into play. This is the theory that you should start from a
    bare-bones design and then enhance it when accessed based on factors such as connection
    speed and browser capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example might begin with this simple markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a complete, functional – albeit extremely simple – website, perhaps
    to allow a user to subscribe to your newsletter. It will work fine in virtually
    any browser on any device. However, what if we want to ensure the email address
    is in a valid form? That’s easy to do with JS, but what if the browser doesn’t
    support JS at all or the user disables it? What we need is a way to ensure that
    the page will work even without JS but will work *better* when JS *is* available.
    This is where progressive enhancement comes into play (this is the `progressive.html`
    file in the `ch-5` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, what happens is that when the page fully loads, the `<script>` block executes.
    In it, we get a reference to the form using `document.getElementById()`, and then
    call `addEventListener()` on the DOM node returned. This adds an event listener
    function for the form’s `submit` event, which fires when the user clicks the `email`
    field. It then checks to see if it includes an `@` sign. While this is definitely
    not a complete test of email address validity, it’s good enough for this simple
    example. If no `@` sign is present, then an error message is shown in the `myDiv`
    `<div>` element. Finally, the call to `event.preventDefault()` stops the form
    submission from occurring (the `event` object passed into the function contains
    all information about the event the function is called in response to – the form
    submission, in this case – and provides some functions to work with it, including
    the `preventDefault()` function to terminate whatever the default action would
    be, which in this case is sending the form to the server).
  prefs: []
  type: TYPE_NORMAL
- en: This is a good thing to do because when you can catch simple errors such as
    this in the browser without having to involve the server, that’s a more efficient
    approach. But, since browsers will ignore what they don’t understand, which would
    include the `<script>` block if JS isn’t available, there’s no harm in it being
    present. If JS isn’t available, then you still have a functional form (and one
    presumes the email address will be checked for validity on the server). But when
    JS *is* available, the page is enhanced to do the email address validation in
    the browser. That’s the basic idea of progressive enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design is effectively a form of progressive enhancement in that the
    display can change based on the size of the screen, providing functionality for
    all users. Both responsive design and progressive enhancement play into accessibility
    because the very idea of accessibility is to make a site accessible. If the form
    submission *depended* on the JS working, then the page would be broken when JS
    isn’t available, and hence it wouldn’t be accessible to those users. By progressively
    enhancing, we ensure everything works in roughly the same way regardless.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of progressive enhancement also starts down the path to something else
    called **Progressive Web Apps** (**PWAs**), which is what we’ll talk about now.
  prefs: []
  type: TYPE_NORMAL
- en: PWAs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the ideas discussed so far lead to one final frontend topic: **PWAs**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PWAs are a way to write more advanced websites – web applications, really –
    by using common web technologies such as HTML, CSS, and JS (which may or may not
    use various libraries, which you’ll explore in the next chapter). They are intended
    to work on any platform that uses a standards-compliant web browser. PWAs have
    several defining features and benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: PWAs should fit any form factor, be it desktop, mobile, tablet,
    or device that hasn’t even been developed yet or is in the early days (virtual
    reality, anyone?)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Progressive enhancement**: The core functionality of the app should work
    for every user no matter what their browser and OS capabilities are, but then
    progressive enhancement is used to provide a better experience for users with
    more capable platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connectivity independent**: Using a special bit of JS code called a **service
    worker**, PWAs can work even when the user is offline. This is accomplished by
    storing resources (HTML, CSS, JS, images, and more) on the client and using those
    stored – known as **cached** – versions when the user can’t connect to the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An app-like feel**: PWAs often feel more like desktop apps (native apps,
    we call them) rather than websites. This comes about due to things such as alerts
    appearing like others generated by the OS, the ability to use hardware devices
    that generally aren’t usable on a website, and more complex interactions (multiple
    windows, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fresh**: While service workers allow for offline access, they also provide
    a mechanism by which to update those cached resources when online. This ensures
    the PWA has the latest code and therefore appears *fresh* to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe**: PWAs can only be served via HTTPS connections. This prevents snooping
    and ensures content hasn’t been tampered with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discoverable**: Thanks to some special configuration files you must provide
    when building a PWA, they are identified as an application, not merely a website,
    to the browser and the OS. This is what allows them to be installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installable**: Users can add apps to their home screen on their phone, or
    their desktop/start menu on a PC or Mac, without the hassle of going through an
    app store. Simply going to a URL like any other website, as long as the website
    provides a few necessary pieces (service worker and a configuration file called
    a manifest file, mainly), is enough for the browser and OS to treat it as an installable
    app, much like any other app you might install.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linkable**: Since a PWA is fundamentally still a website – just one with
    more capabilities – it means it is easily shared via a URL and does not require
    complex installation. Typically, visiting a website that is set up to be a PWA
    will trigger a request asking if you want to install it. After that, it appears
    like any other installed app on your phone or computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a software developer, building a PWA involves creating a responsive web
    application that includes a manifest file and a service worker – the manifest
    file provides information about the application (such as name, author, icon, and
    description) to the browser, and the service worker enables features such as push
    notifications, background data sync, and offline functionality via caching and
    updating of resources. PWAs bridge the gap between web applications and native
    applications, offering the UX and capabilities of native apps with the reach and
    accessibility of the web.
  prefs: []
  type: TYPE_NORMAL
- en: Building a PWA isn’t fundamentally complex, but it does involve a few steps
    that can be tricky, especially when dealing with the need to work over HTTPS only.
    Because of this, I’m not going to demonstrate building one here as it’s definitely
    a more advanced topic. While PWAs are fairly popular these days, they aren’t universally
    supported, nor are they something you definitely need to know. In fact, you may
    never need to build one at all. If you do, though, this section should have laid
    the groundwork for understanding the basics, and you can explore it at a later
    time, when and if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: So, yes – ensuring your website looks good and follows good UX practices so
    that it is functional for your users is very important. Implementing responsive
    design is often a part of that, and using progressive concepts can also result
    in a more efficient experience for your users. PWAs are another potential level
    after that.
  prefs: []
  type: TYPE_NORMAL
- en: But none of that would much matter if you don’t put your website somewhere that
    can be accessed by those users. While that can be as easy as dropping your code
    onto a physical server, in this day and age, that’s not necessarily the best answer.
    Plus, best or not, it’s for sure not the *only* answer. Along these lines, another
    concept that plays into deploying a website is virtualization, by way of VMs and
    containers, and that’s the next topic up for discussion!
  prefs: []
  type: TYPE_NORMAL
- en: Virtualizing the world – VMs and containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you played around with Linux a bit via some online Linux
    playgrounds (you *did* do that, right?). Did you stop for a second and wonder
    how those sites pulled that off? You were essentially logging in to a machine
    running Linux, but surely there couldn’t be a physical server for every user who
    might be doing the same thing at the same time, could there? In all likelihood,
    the answer is no. Instead, they most probably used either a VM or a container
    to pull off that magic.
  prefs: []
  type: TYPE_NORMAL
- en: '**VMs and containers** are two different but related technologies used to create
    efficient, isolated environments for running applications. They both have the
    same basic goal, which is to virtualize an environment.'
  prefs: []
  type: TYPE_NORMAL
- en: But what does *virtualize* mean? To explain that, you have to think about how
    a computer normally works.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you have some hardware – obviously, things such as motherboards, CPUs,
    memory, various buses for components to communicate over, and so on. This is all
    physical stuff – electronics and all that.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on top of the hardware, you have an operating system or OS. It might be
    Windows, or maybe Linux, or perhaps macOS, and so on. Sharp-eyed readers may realize
    there is also something called *firmware*, which is software that is permanently
    embedded in the hardware. You can kind of think of that as part of the hardware,
    though, since that’s where it lives. For the most part, it’s the hardware plus
    the software in the form of an OS, and of course, then all the applications that
    run on top of that, which is more software.
  prefs: []
  type: TYPE_NORMAL
- en: So now, **virtualizing** in essence means to take all of that – the hardware,
    software/firmware, all of it – and simulate it in a computer. Through some very
    clever coding, it is possible to simulate a computer, all the way down to the
    hardware, in software. How that works is *way* beyond the scope of this book,
    but fortunately, it doesn’t really matter either! We can simply be happy that
    such magic exists.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit to this, probably the biggest one anyway, is this virtualized computer
    – which is completely separate from the computer it’s running on (typically called
    the *host*). If you create a file on the host, usually, it won’t be accessible
    from a virtualized computer running on it and vice versa. If you install some
    piece of software on a virtualized computer, it has no impact on the host. It’s
    literally as if you have two different computers; they are isolated from one another.
  prefs: []
  type: TYPE_NORMAL
- en: There is more than one way to virtualize a computer such as this, and two of
    the most common are VMs and containers. These strive to achieve the same basic
    goal – simulating a computer inside of another – but they differ significantly
    in their approach and architecture. Let’s talk about both now, see how they compare
    and how they differ, and why we might choose one over another.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding VMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A VM is really what I was just describing. Architecturally, a VM includes not
    only the application and necessary binaries and libraries to supply the functionality
    a user might want but also an entire OS, which we typically call the *guest*.
  prefs: []
  type: TYPE_NORMAL
- en: A VM runs on a physical server and is managed by a **hypervisor**, such as VMware’s
    ESXi, Microsoft’s Hyper-V, or Oracle’s VirtualBox. The hypervisor is simply a
    program that manages VMs, managing things such as their access to the underlying
    physical hardware. Since it’s possible to run multiple VMs on one physical machine,
    and since those machines will at some level need to use and share the real physical
    hardware, the hypervisor manages that sharing and ensures there are no conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'VMs are ideal for running applications that require a full OS, for ensuring
    complete isolation, or when running applications on different OS types. For example,
    if you usually use a Windows machine but want to play with Linux, you can create
    a VM using your favorite version of Linux, which will then appear as a separate
    window, as you can see in *Figure 5**.11*. You can then install software in Linux,
    completely separate from your Windows host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Ubuntu Linux running in a VirtualBox VM on top of Windows 11](img/B18315_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Ubuntu Linux running in a VirtualBox VM on top of Windows 11'
  prefs: []
  type: TYPE_NORMAL
- en: VMs are very compatible and as such can run almost any OS you like. In fact,
    you can even run older OSs that wouldn’t work on your physical machine anymore,
    which provides a solution for running legacy applications, or applications requiring
    specific OS environments that you wouldn’t normally want to run on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Each VM has its own set of virtual hardware (CPUs, memory, disks, and so on),
    including storage devices, which are in effect carved out from your physical storage.
    This leads to potentially higher storage requirements on your host. For example,
    if you have a 500 GB hard drive in your computer and you want to create a Linux
    VM with a 100 GB hard drive, this means you lose 100 GB of your physical hard
    drive to the VM.
  prefs: []
  type: TYPE_NORMAL
- en: VMs require more management overhead due to the need to support separate OSs
    and virtual hardware configurations. Remember – you in effect have more than one
    computer to deal with now! When you first create a VM, it is “naked,” meaning
    that it’s just like having a physical computer with nothing on it yet. You will
    then have to install the OS yourself (which means you’ll need a proper license
    for it). Later, when updates need to be done, you’ll need to do that yourself,
    on top of any you might have to do on your host machine. It’s just more management
    you need to do, just like having two physical machines.
  prefs: []
  type: TYPE_NORMAL
- en: VMs nowadays provide excellent performance, which is a bit surprising given
    they are simulating a full computer, often down to the hardware level. There are
    a lot of tricks played to make this happen, things such as effective sharing of
    the physical hardware. But however it’s done, on a sufficiently powerful host
    machine, you should notice only small performance differences in the guest. In
    fact, if you maximize the window a VM is running in, you should find that it’s
    fairly tough to tell it isn’t the physical machine at that point.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now set up a Ubuntu Linux VM inside VirtualBox to play around with.
  prefs: []
  type: TYPE_NORMAL
- en: Using VMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the *Technical requirements* section of the chapter, you should already
    have VirtualBox installed, and you should have downloaded a copy of Ubuntu Linux.
    Now, to set up a VM in VirtualBox, click the **Machine** menu, then the **New**
    button. You should get a dialog like what is shown in *Figure 5**.12*, where you
    can enter a name, select a folder to store all the VM files in, and select the
    right type and version (**Linux** and **Ubuntu** respectively, most likely the
    64-bit version of Ubuntu specifically):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Setting up Ubuntu in VirtualBox](img/B18315_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Setting up Ubuntu in VirtualBox'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll then need to tell VirtualBox to use the VDI file you downloaded. **VDI**
    stands for **Virtual Disk Image**, and it is a file that stores the contents of
    a storage device, like a hard drive, right down to the byte level, so it’s an
    exact byte-for-byte copy of that device. To do that, click on the **Hard Disk**
    section at the bottom, select **Use an Existing Virtual Hard Disk File**, then
    click the icon next to the dropdown that says **Empty** in it. You’ll then see
    the dialog shown in *Figure 5**.13*. Click **Add** and add the VDI file you downloaded
    earlier. Make sure it’s highlighted, then click **Choose**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Adding the VDI to VirtualBox](img/B18315_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Adding the VDI to VirtualBox'
  prefs: []
  type: TYPE_NORMAL
- en: That dialog will close, and you’ll be back on the one from *Figure 5**.12*.
    All the default values there should be fine, so you can simply click **Finish**.
    You now have a Ubuntu VM!
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do now is click the `osboxes.org`). As you play around, realize
    that it’s just like you’re connected to a different computer in that window, which
    of course is the whole point of a VM. You can run various applications and install
    new ones – anything you can do on a real computer can be done in this VM.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, though, VMs are just one way to skin the virtualization
    cat. Another extremely popular way is containers, so let’s look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers differ from VMs in that they are not simulations of whole computers,
    though you can be fooled into thinking they are. In many cases, you can log in
    to a container and do everything inside of it that you could in a VM or a physical
    machine. They pull this off by isolating what’s inside the container and what’s
    outside on the host at a low level in the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers** are primarily a Linux facility as they depend on certain low-level
    capabilities in the Linux kernel (the core code that the entire Linux OS is built
    on top of). You can run containers on Windows too, but the way it’s done there
    is actually by using a Linux VM in a way transparent to you!'
  prefs: []
  type: TYPE_NORMAL
- en: But, regardless, the basic architecture of a container is that containers package
    together an application and its dependencies (things such as libraries, binaries,
    and so on) but share the OS kernel of the host system. Whereas the kernel is simulated
    inside a VM, a container uses the actual kernel that the host OS is in.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with VMs, containers are isolated from the host OS, despite the fact
    that they share the kernel and other system resources. The OS itself takes care
    of that isolation automatically, so from our user perspective, it looks like a
    VM, which of course looks like a physical machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers have a couple of benefits over VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: First, because they aren’t simulating a full machine, they are noticeably faster.
    This is especially apparent during startup. Whereas a VM has to go through a full
    OS boot cycle just like a real computer, a container does not, and so they tend
    to start pretty much instantly. They also use considerably fewer host resources
    since, again, they aren’t simulating a whole computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, containers provide a more consistent environment. Think about earlier
    chapters where we talked about being able to give a developer a `package.json`
    file, which they can then run `npm install` with and get all the dependencies
    your application needs. That is indeed handy, but what happens if they have a
    different version of Node installed than you do? And what if that version happens
    to have a bug that yours doesn’t? That developer may find that your project doesn’t
    work on their machine but does on yours. Containers solve this by bundling up
    not only your code and its dependencies but even things such as Node. If you give
    that developer a container instead, you can ensure their environment matches yours,
    so you know your code will work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are a general term for what is a function of the operating system.
    But you won’t usually be interacting with this function directly because it is,
    to put it mildly, not a pleasant experience. Instead, you’ll almost certainly
    use some sort of software that is a wrapper around that function. The most popular
    such wrapper today by far is called Docker. In fact, it’s so popular that people
    will usually call them *Docker containers* rather than just containers. Let’s
    talk about containers under Docker a bit now and see them in action!
  prefs: []
  type: TYPE_NORMAL
- en: Using containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To play with containers, we’re actually going to use your brand-new Ubuntu VM!
    You see, since containers require Linux, and since I don’t know what OS you’re
    using normally, I can at least be sure you have Ubuntu running in VirtualBox at
    this point, so I know you have a Linux machine available, albeit a virtual one!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you’ll need to do, inside your VM, is launch the Terminal application.
    This gets you to a command prompt. Next, you’ll need to install Docker with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the installation when prompted, and then give it a minute or two, depending
    on your internet connection speed. Once it’s done, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should be prompted with the help documentation. Now, you are ready to start
    a container!
  prefs: []
  type: TYPE_NORMAL
- en: 'As is customary when talking about seemingly anything in programming, we’ll
    start by spinning up a “Hello, World!” container. As luck would have it, Docker
    Hub, which is a website that is a public image repository run by the company behind
    Docker, has just such an image available! We can pull the image down to our local
    machine and use it to create a container, all with one simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and execute that, and after a couple of seconds, you should see something
    like *Figure 5**.14* greet you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Your very first Docker container!](img/B18315_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Your very first Docker container!'
  prefs: []
  type: TYPE_NORMAL
- en: What actually happens is that, first, Docker will look for an image named `hello-world`
    on your system. When you create a container, you always start from a blueprint
    known as an image. The image almost always begins with an operating system and
    then has stuff added on top of it, building up to the final image. You can think
    of an image as a snapshot of an OS filesystem at a given point in time, but it’s
    not a snapshot of your host OS; it’s a snapshot of the result of a series of steps
    used to build up the image layer by layer as if you were executing the commands
    yourself. Docker then takes that image and creates a container from it. You can
    have multiple containers running based on a single image if you wish, just like
    you can have multiple houses built from the same blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: If the specified image isn’t present on your system yet, Docker will call out
    to Docker Hub and look for an image with the name you requested and download it
    if found (or give you an error if it’s not). From that point on, new containers
    can be spawned from that image without requesting anything from Docker Hub again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve created your first container, let’s take a very brief look at
    some of the most common commands you might need to work with containers.
  prefs: []
  type: TYPE_NORMAL
- en: Learning basic Docker commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker` program is your interface into Docker itself, and it provides many
    different commands to control Docker. Let’s take a look at some.
  prefs: []
  type: TYPE_NORMAL
- en: Listing images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How can you tell what images and containers there are available on your system?
    Well, that’s easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That will list all the images previously downloaded onto your system from which
    you can create containers.
  prefs: []
  type: TYPE_NORMAL
- en: Listing containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For listing containers, it’s just as easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Modeled on the Linux `ps` command, this command shows your containers, but it
    only shows you running containers. After the `hello-world` container finishes
    its work, it shuts down immediately. Therefore, you won’t see it running with
    this command. Other containers will continue running and so will show up with
    this command; it all depends on what the container is meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the container still exists in a sense, and you can see it by adding
    an option to the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Starting (and stopping) containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You could start a container again if you want by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For this `hello-world` container, however, nothing will happen when you do this,
    and the container will exit at once. It only seems to show that helpful information
    when initially run.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also stop a running container with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a quick aside, at this point, you may realize that entering the container
    IDs that Docker generates can get annoying in a hurry (and, plus, you’ve seen
    me write `<container_id_or_name>`, implying you can do something other than using
    the default ID). Fortunately, Docker also generates a name for each container,
    as you can see in the `ps` output (and it can often be quite entertaining to see
    what it spits out!). However, it’s more user-friendly to give it a name yourself,
    which you can do with the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should see a container with the specified name, which you can then
    use to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be aware that when using the ID, you can enter a partial ID,
    starting from the beginning and entering enough to be unique. The first few characters
    are usually sufficient. In my opinion, though, providing a name is the overall
    better and easier approach as you have less chance of accidentally doing something
    to the wrong container (in theory, at least!).
  prefs: []
  type: TYPE_NORMAL
- en: Removing containers and images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll probably want to clean up those containers at some point, and there’s
    a command for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the container is running, Docker won’t let you remove it until you stop
    it. Likewise, you can remove images like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As with containers, Docker won’t allow you to remove an image that’s used by
    a container, regardless of whether it’s running or not, so you’ll need to clean
    up the containers first.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While I think it’s much easier to go to Docker Hub through the web to look
    for images, which you can do at [https://hub.docker.com](https://hub.docker.com),
    you also can search for an image directly from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This returns a list of many images that include the `hello-world` string in
    their name.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you’ll want to treat containers like VMs and log in to them, assuming
    it’s one that keeps running. To show that, we’ll need a container that will continue
    running, so let’s use `nginx` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `-d` option “detaches” the terminal session from the container, which causes
    it to run in the background (assuming whatever is inside the container doesn’t
    exit immediately). You’ll be returned to your command prompt, but the container
    will continue to run. The `-p` option is for exposing network ports. Here, we’re
    saying that port `8080` inside the container should be exposed as port `80` on
    the host machine’s network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Once you execute this command, do `sudo docker ps`, and you should see a running
    container for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with a container running, we can go ahead and attach to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see a few things. First, the `-i` option keeps the system’s `STDIN`
    input stream open so that it can be interacted with. The `-t` option allocates
    a new pseudo-tty terminal session (for all intents and purposes, this means a
    Linux command prompt). `/bin/bash` at the end is a command that is executed after
    the container is started, in this case specifying a Linux `bash` command prompt.
    All three combined result in you being “inside” the container.
  prefs: []
  type: TYPE_NORMAL
- en: The command prompt you see at that point is the command prompt inside the container
    itself. Go ahead and do some `bash`-y stuff (for example, `ls`), and you should
    notice that what you see differs from your host operating system (though if you’re
    using Ubuntu, then it’s going to look very similar anyway). Execute the `exit`
    command, and you’ll be dropped back to your actual host VM’s command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing container logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, without attaching to a container, you can view the logs produced inside
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, “logs” include anything routed to standard out, barring any specific configuration
    done inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some idea what VMs and containers are all about, let’s look
    at the key differences between them and the questions to ask yourself when deciding
    which is appropriate to use.
  prefs: []
  type: TYPE_NORMAL
- en: Key differences between VMs and containers and choosing between them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several differences between VMs and containers that will often factor
    into deciding which to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Containers are generally faster and more resource-efficient
    than VMs. This is definitely true when thinking about how fast they start up,
    but it’s also true when they are running. Remember – a VM is simulating an entire
    computer while containers aren’t, and that simulation costs processor time and
    memory utilization on the host machine, all of which can impact the performance
    of the VM *and* the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overhead**: In a sense, this is another aspect of performance, but it’s different
    enough to call out. VMs have more overhead in terms of CPU, memory, storage, and
    other system resources, due to the need for a full OS in each instance. Containers
    are sharing the resources of the host more directly, so while they certainly do
    have some degree of overhead, it tends to be a lot lower than VMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Containers are highly portable across different machines,
    as long as they run the same OS kernel. In other words, the files inside a container
    have to work with the kernel in the host machine, and as long as they do, then
    a container can run on any machine. With a VM, this isn’t the case, which means
    they are even *more* portable than containers since you can run a Windows VM on
    a Linux host, a macOS VM on a Windows host, or any other combination you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: VMs offer more isolation, which can be beneficial for security,
    while containers offer enough isolation for most purposes but require careful
    management to ensure security. The complete isolation of VMs can provide a more
    secure environment, as one VM’s compromise doesn’t directly threaten others. Given
    that containers share the host OS’s kernel, it should be obvious that there is
    at least some possibility of security issues, and vulnerabilities in the kernel
    itself can potentially affect all containers. However, in practice, as long as
    you have an up-to-date host machine, and as long as your containers are configured
    properly, they are quite safe from a security standpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management and orchestration**: VMs are often managed with pretty advanced
    management tools such as VMware vCenter or Microsoft System Center, which provide
    for centralized management of many VMs. Containers tend to be managed more often
    from a command prompt, though there definitely are graphical management tools
    as well. VM management tools allow for easy deployment, control, and scaling of
    VMs. Scaling means that if a VM needs more resources, it can be expanded, often
    on the fly. With containers, the answer more often than not is simply to create
    more instances of a given container and balance work between them. This is called
    orchestration, and it’s where more advanced things such as Kubernetes come into
    play. This is a Google product that allows for more flexible control of containers
    – things such as grouping them more efficiently to handle load. It’s a very powerful
    tool, but it’s also quite a bit more complex than the containers themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rapid deployment and scaling**: I mentioned this in the previous bullet,
    but it’s an important point: because containers tend to start very fast and are
    more lightweight, containers can be started, stopped, and replicated quickly and
    easily, making them ideal for dynamic, scalable environments. VMs, by contrast,
    take longer to start and use more host resources. That means that for a given
    server, you can almost certainly run more containers than you can VMs, so if you
    start getting a lot of new users on your shiny new website, you can create more
    containers to handle traffic faster and easier and with fewer host requirements
    than with VMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, while there is certainly an overlap between VMs and containers,
    each has its unique strengths and weaknesses. VMs provide complete isolation with
    a full OS environment, making them suitable for applications that need a full
    OS or different OS types. But that makes them more heavyweight in terms of resource
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Containers, being lighter and more efficient since they are not a complete running
    OS, are ideal for applications where portability and quick scaling are important.
    I would go so far as to say that today, it’s usually safer to start from the assumption
    that you’ll use containers more often than a VM for deploying an app or website
    (if you’re not going to simply run your code on a server, that is, which we tend
    to call *bare metal*). Especially in cases where you expect that your load requirements
    (how many users are using your website) might increase rapidly, containers are
    usually the better option (VMs can scale as well, but it’s a less efficient process).
    On the other hand, if absolute security is your main concern, and/or complete
    isolation from anything else that might be running on the same physical machine,
    then a VM is a very good option.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know a bit about containers and VMs, let’s talk about a place you
    may wind up running them (or just your “naked” application without VMs or containers
    at all), that being the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your head in the clouds – cloud providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some people like to be trite and say that the cloud just means running your
    code on someone else’s computer. And, I mean, it’s not *untrue*! But there’s much
    more to it than that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **cloud** refers to cloud computing, which is the delivery of various services
    over the internet, including data storage, servers, databases, networking, and
    software (read: your websites and applications). Cloud computing allows for flexible
    resources (meaning you can get just what you need when you need it), faster innovation
    (since you don’t need to build and configure servers and services yourself), and
    economies of scale (since the costs of building the infrastructure behind the
    cloud are amortized across all the people using it). You typically pay only for
    the cloud services you use, helping lower operating costs, run infrastructure
    more efficiently, and scale as your business needs change.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you *don’t* want to use the cloud. What that may mean is that you
    have to buy your own hardware, set it up, and configure the operating system and
    all the services on top of it (databases, mail services, user authentication services,
    web servers, and so on). Then, you have to put your code on it and run it, ensuring
    that the whole thing is secure. Then, if your website becomes super-popular and
    you start getting more traffic, you may then have to add hardware to expand the
    capacity or reconfigure the services to handle the added load. Eventually, you
    may have to add whole servers and configure networking in such a way that the
    load is balanced across them.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the cloud, these sorts of concerns are automatic, or at least can be changed
    just by updating some settings on a control panel website offered by the cloud
    provider. You change some settings, click a button, and suddenly you have more
    memory, more bandwidth, and more CPU available to handle the expanded load. It’s
    a much easier thing to do. And the cost savings are significant: when you build
    your own server, you have to guess at the load, and it’s usually smart to over-purchase.
    If you think a server with a single 3 GHz CPU will be enough, you may want to
    buy a dual-processor machine up-front to have some headroom to grow. But, if you
    don’t grow, now you’ve effectively wasted money. With the cloud, you can add that
    second CPU when you see that you need it, so you’re not paying for one you don’t
    need or may not need for a while.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing cloud providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many different cloud providers these days, but the biggest are **Amazon
    Web Services** (**AWS**), **Microsoft Azure**, and **Google Cloud Platform** (**GCP**).
    Oracle also has a fairly popular cloud offering, as does IBM and some other smaller
    players, but Amazon, Microsoft, and Google are definitely the big boys. Ultimately,
    though, they all have the same basic proposition: run your code on their infrastructure,
    using only what you need.'
  prefs: []
  type: TYPE_NORMAL
- en: It may be surprising to hear that the company that most people associate with
    the internet – Google – has a cloud offering that, it’s fair to say, isn’t quite
    as popular as AWS and Azure, which are the two most popular cloud providers as
    of this writing, almost without question. In fact, when someone talks about “the
    cloud” these days, they almost certainly mean one of those two providers. That’s
    how much larger they are than the rest in terms of usage and mindshare.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, though, all cloud providers offer a ton of different services,
    with a high degree of stability. Of course, that doesn’t come for free: using
    a public cloud can get rather expensive if you aren’t careful. It’s not at all
    difficult to find horror stories online of people waking up to huge AWS bills
    because their website got super-popular overnight. You definitely need to exercise
    caution when using them. Fortunately, all good cloud providers offer ways to control
    your spending. With AWS, for example, you can configure spending limits on your
    account so that you don’t get hit with a life-altering bill out of the blue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s more than that, though: you have to think about whether the cloud is the
    right answer for a given use case at all. Sometimes, it more clearly is: when
    you know your load requirements will be highly variable, for example. Being able
    to use just the capacity you need is very appealing in such cases. Obviously,
    the complexity of setting up the various services cloud providers offer yourself
    can be overwhelming and very expensive in such cases.'
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes, having your own hardware is cheaper and simpler too, especially
    if you have a good idea of what your load will be over time. And if what you’re
    building doesn’t require most of what the cloud provides, then it might make more
    sense to do it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not simple calculus and many, many factors go into such a decision, many
    of which are very project-dependent. I’m not trying to supply a checklist to use
    for such a decision here because that would be a nigh-impossible task. Instead,
    I’m just trying to make the point that the decision to go to the cloud or not
    is one you’ll need to make with every project based on its unique requirements.
    There are certainly benefits to the cloud, but there are negatives too.
  prefs: []
  type: TYPE_NORMAL
- en: Complicating matters more is that the cloud isn’t a single thing, regardless
    of whose cloud it is. There are effectively three types of clouds to be familiar
    with. Let’s talk about them now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cloud types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cloud can be public, private, or hybrid:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public cloud**: These are cloud services offered over the public internet,
    available to anyone willing to pay. The public cloud is generally services such
    as AWS, Azure, and GCP. They run in data centers provided by, maintained by, and
    completely controlled by the providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private cloud**: This is server infrastructure used exclusively by a single
    business or organization, making it available only to their internal development
    teams. This is typically done by larger companies who want or need a higher level
    of control over how things are done, especially in areas such as banking where
    regulations dictate a tighter level of control over sensitive data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid cloud**: Combines public and private clouds, bound together by technology
    allowing data and applications to be shared. Imagine running your website on your
    private cloud, but then having it connect to a database service in a public cloud
    in order to save some money (database software tends to be quite expensive at
    larger scales).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And besides those three types, cloud services can break down into several key
    services too. Let’s look at just some of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing key services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud offerings come in many flavors, but they tend to come with names that
    end in “**aaS**,” which is short for “**as a Service**.” When you build a server
    yourself, and you need a database to run on it, you will need to install the database
    software and configure it. By contrast, **DataBase as a Service**, or **DBaaS**,
    is when a cloud provider offers preconfigured database services to you. You’ll
    still need to do some degree of configuration, of course, for your needs, but
    the basic database software is something you won’t have to worry about. From your
    perspective, it’s just a service you use, just like cable TV (uhh, does anyone
    actually still have cable TV?!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other “aaS” offerings you may meet – but definitely not all of
    them since there seems to be a new one every week – include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as a Service (IaaS)**: This is an offering of fundamental
    computing resources such as VMs, networking, and storage. An example of this is
    AWS **Elastic Compute Cloud** (**EC2**). This can largely be thought of as someone
    setting up a server for you, which you can then do what you want with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform as a Service (PaaS)**: This provides hardware and software tools
    over the internet. It is conceptually a level above IaaS in that it normally will
    include things such as an operating system and software installed on top of that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software as a Service (SaaS)**: This service delivers software applications
    over the internet, on a subscription basis. One example is Microsoft Office 365,
    where you can use all of Microsoft’s Office applications over the internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers as a Service (CaaS)**: This provides a runtime environment for
    containers of any type you wish to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disaster Recovery as a Service (DRaaS)**: This is a service that you can
    use to back up your important data and restore it as necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I said, there are a myriad of other “aaS” offerings, and each cloud provider
    will have different options available. To complicate matters, the various providers
    won’t even always agree on the terminology! For example, *CaaS* may not mean *Container
    as a Service* in one cloud provider versus another. That said, the ones in this
    list tend to be fairly consistent and are probably the ones you’ll see most often.
  prefs: []
  type: TYPE_NORMAL
- en: 'Names aside, when you use the cloud, you may use just one service, or you may
    use many. AWS, for example, has upward of 200 services available as of this writing.
    But that’s another advantage of the cloud: you can mix and match services however
    you need, adding and subtracting as you go. It’s the Burger King model: have it
    your way!'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing’s flexibility, combined with its capacity for innovation, makes
    it a cornerstone of modern IT infrastructure, essential for businesses to remain
    competitive and agile in a rapidly evolving digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: But you may not need the cloud at all. Well, sort of. Let’s talk about something
    called serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Who even needs the cloud or even servers? – Serverless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fairly recent development in software development is something called **serverless**.
    This is still really a cloud offering, but it’s a fair bit different than the
    usual cloud. Generally speaking, with any cloud offering, you have some software
    running all the time. If no one uses it, it’s still running, albeit at a very
    low level because clouds can scale operations down at such times to save resources
    and ultimately save you money.
  prefs: []
  type: TYPE_NORMAL
- en: But, for some applications, you don’t even need that!
  prefs: []
  type: TYPE_NORMAL
- en: Imagine for a second that you want to write an application that can solve mathematical
    equations. Based on what you’ve learned so far, you can imagine creating a web
    page where you can enter a math equation and submit it to some server-side code
    to solve the equation and return the result. You can further imagine writing some
    Node code to do that work. And given what you’ve learned so far, you even have
    some idea what that might look like in terms of code, at least at a high level.
    Ultimately, you’re going to have a JS function that your Node server calls to
    solve the equation.
  prefs: []
  type: TYPE_NORMAL
- en: But what if I told you that there was a way to have just that function in the
    cloud and make it callable as if it were a server? Well, that’s exactly what serverless
    is!
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, you can think of serverless as a way to start that Node server
    only when a request comes in, let it call that function, return a result, and
    then immediately shut down. But that all happens so fast that you can’t even tell
    – it looks to you like the server is always running.
  prefs: []
  type: TYPE_NORMAL
- en: But, better still, while the code isn’t very complex, as you’ve seen, wouldn’t
    it be better if you didn’t even have to write the server code? Wouldn’t it be
    better if you only had to write the function that solves the equations?
  prefs: []
  type: TYPE_NORMAL
- en: That’s serverless in a nutshell!
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda is one such serverless service. With it, you can write functions,
    not just in JS but in a whole host of languages. These functions are then callable
    as if they were running on a server. Lambda takes care of all the plumbing, so
    to speak – all the code you would need to write yourself to make a server. You
    just focus on the logic needed and let Lambda take care of the rest. And, best
    of all, since there isn’t code running all the time awaiting requests, you aren’t
    paying anything if your functions aren’t being called. You’ll just pay when they’re
    called, based on how many resources they use. So, if you write fast, efficient
    code, it’ll cost you less to run them serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, serverless isn’t a suitable model for all applications. But, for
    the ones where it makes sense, it can make *a lot* of sense.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud is an expansive topic and one you may or may not wind up needing to
    get deeper into, depending on your needs. But the last topic I want to touch on
    plays into almost everything we’ve discussed so far because whether you build
    your own server or use a cloud provider, you’re obviously going to need to do
    things such as build your code into a runnable form and deploy it, and all of
    that, and more, is the domain of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Taking back control – DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of **Information Technology** (**IT**), of which web development is
    one part, is an interesting field in that technologies and approaches come and
    go all the time. What also tends to happen is we repeat ourselves! Someone has
    a good idea; it becomes popular but eventually is supplanted by something else.
    Then, somewhere down the road, someone has another good idea that becomes popular,
    but anyone who was around for the last good idea often realizes the new good idea
    is actually just the old good idea slightly updated and wrapped in new clothes!
  prefs: []
  type: TYPE_NORMAL
- en: In the early days, developers did it all. We wrote the code, and then we were
    the ones who deployed it, meaning installed it onto the server it ran on (whether
    they were servers we built, servers provided by outside vendors, or the cloud).
    This was just part of the development process. We then worried about things such
    as monitoring a website for issues and dealing with those issues.
  prefs: []
  type: TYPE_NORMAL
- en: After a while, though, a lot of organizations started taking a different approach
    by separating out some of those duties and assigning them to groups other than
    developers, typically called the operations team. At that point, developers still
    wrote the code, but when it came time to deploy it, another group would do that.
    Things such as monitoring might be handled by an entirely different group, and
    dealing with issues that came up at least started with a specific support group
    (though developers still frequently had to get involved ultimately).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the pendulum is starting to swing the other way again in that developers
    commonly have a hand in deployments and support and all the other concerns that
    go into running a live website, so we’re repeating ourselves again, though with
    a few differences. The “new clothes” this time around is something called DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: '**DevOps** is a set of practices that combines **software development** (**Dev**)
    and **IT operations** (**Ops**), aiming to shorten the development life cycle
    and provide continuous delivery of software of websites while still delivering
    high-quality output (generally meaning fewer bugs or other issues relative to
    the speed at which updates are delivered). DevOps is notable for its emphasis
    on collaboration, automation, and integration between software developers and
    IT professionals. It often involves tools for automating and streamlining the
    integration and deployment processes, aiming to improve and speed up delivery.
    This approach is particularly relevant in the context of agile software development,
    an approach where you build software in many phases that each deliver a part of
    the expected whole while allowing for changes as development progresses. It can
    significantly enhance the efficiency and quality of software production and maintenance
    as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the key aspects of DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several key points to DevOps at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Culture shift**: DevOps emphasizes a shift in mindset, encouraging collaboration
    between development and operations teams. This breaks down silos and fosters a
    culture where building, testing, and releasing software happens rapidly, frequently,
    and more reliably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: DevOps relies heavily on automation to speed up software development
    and deployment processes. This includes code deployments, testing, infrastructure
    provisioning, monitoring, and more. Anything that can be automated and run with
    little or no human intervention is something DevOps will typically seek to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration and Continuous Delivery (CI/CD)**: These are core
    practices in DevOps. **CI** refers to the process of automatically integrating
    code changes from multiple contributors into a single software project. **CD**
    is an extension of this, where the software can be released to production at any
    time. The basic idea is that as developers push code to Git, automation will see
    that new code and will build the software or website and deploy it to a test environment.
    Frequently, automated tests are run at that point, and developers are alerted
    to failures so that they can correct issues. If no issues are found, and if everything
    is configured for it, the new code can be deployed immediately to a production
    environment for end users to start using immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and feedback**: Continuous monitoring of the application and its
    performance is crucial, especially with so much being automated and more rapid
    deployments being done. It helps in identifying issues early and helps improve
    the product in real time based on user feedback and system-level tests. For example,
    if new code is deployed and you have monitoring in place that alerts you to errors
    that begin happening, you can take action possibly even before users become aware
    that there is an issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tools and technologies**: DevOps in general, and CI/CD in particular, come
    with a host of new tools to make it all happen. Names such as Jenkins and GitLab
    come up, which are platforms for running what are called **pipelines**. A pipeline
    is really just a fancy way of saying some scripts that know how to build, test,
    and deploy your code automatically. Of course, containers play a large role in
    all of this. For example, a CI/CD pipeline to build and deploy your code may involve
    the pipeline automatically creating a container temporarily to do the build-in.
    Other products such as Ansible or Puppet are also often used. These are tools
    for managing the configuration of environments, often servers. For example, the
    CI/CD pipeline might execute an Ansible job, which handles ensuring the configuration
    of your production server meets the needs of your application. Getting into DevOps
    involves learning about many new tools and technologies beyond those needed to
    design websites and write code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices architecture**: One way that many DevOps teams follow to make
    dealing with the code they manage easier is to adopt a microservices architecture.
    This is a way of building applications and websites that breaks them down into
    many smaller pieces, each providing a needed service to the larger application.
    For example, you may create a microservice that validates users during login.
    You may create another that handles registering new users. Rather than rolling
    both these services up as part of your website, you instead can deploy them as
    separate applications that the website then makes use of. This allows you to upgrade
    the registration service without touching the login validation service. This architecture
    is a natural fit for the DevOps approach because automating these smaller pieces
    tends to be easier. The trade-off is that making all the pieces work together
    can sometimes be challenging, and it does tend to make tracking down problems
    a bit more difficult. But, the benefits oftentimes outweigh any negatives, including
    the fact that you can scale up services individually to handle greater needs as
    they develop easier than trying to scale up a single large – **monolithic**, as
    they’re known – application. It can also help teams get features out faster since
    there is less risk in adding a new service or updating a single service without
    touching the code of another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the benefits of DevOps (and some negatives)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several benefits to DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: One is the ability to increase deployment frequency (since it’s all automated
    and in most cases will simply run faster than a human doing it). Teams that implement
    CI/CD pipelines will often release changes in days or weeks, while teams that
    don’t use a DevOps mindset may take weeks or months between releases. There are
    even some companies that deploy code daily, and that would be nearly impossible
    to do – assuming they want a stable product – without DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Faster **time to market** (**TTM**) is another key benefit. With everything
    automated, teams can focus more on writing code than worrying about how it will
    ultimately get deployed and run.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps also usually allows for a lower failure rate of new releases, at least
    when done properly. This is primarily because testing is usually built into CI/CD
    pipelines, and assuming the tests are robust enough, you can be fairly well assured
    that new code doesn’t break anything, and you can therefore have confidence releasing
    it faster.
  prefs: []
  type: TYPE_NORMAL
- en: In general, in your role as a web developer, you will likely find that DevOps
    practices not only streamline the development process but also enhance the overall
    quality and responsiveness of software maintenance and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, few things in life are all unicorns and rainbows! Even the best of
    ideas tend to have some downside, and DevOps is no different.
  prefs: []
  type: TYPE_NORMAL
- en: It can become incredibly frustrating when your carefully developed automation
    suddenly fails. Maybe it relies on a service to compile code, for example, and
    maybe that service is down for some reason. All of a sudden, your pipelines fail,
    and maybe they don’t provide detailed enough error information to immediately
    see what the problem is. Perhaps the admins upgraded Jenkins, and the new version
    has a bug that breaks your pipeline in some very difficult-to-troubleshoot way.
    Or, maybe there are a lot of teams running pipelines at once, and all of a sudden,
    your pipeline takes 2 hours instead of 5 minutes. Maybe it’s simply difficult
    to write the pipeline script to work exactly the way you need because it has some
    limitations you discovered the hard way.
  prefs: []
  type: TYPE_NORMAL
- en: All of these are things I’ve run into in my work, and that’s just the tip of
    the iceberg.
  prefs: []
  type: TYPE_NORMAL
- en: As I alluded to earlier, the microservices architecture has many benefits, but
    troubleshooting them when something goes wrong is definitely not one of them.
    And matters get much worse when you have services maintained by several different
    teams. Now, not only do you have the difficulty of figuring out which service
    is at fault, but now you have to interface with that team and get them to correct
    the issue, and that isn’t always as smooth a situation as you might hope.
  prefs: []
  type: TYPE_NORMAL
- en: But, at the end of the day, most developers tend to agree that the benefits
    of DevOps far outweigh any negatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have some insight into DevOps, let’s talk about a technology that
    is often used in the context of DevOps: Python.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not all about HTML, CSS, and JS – Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Python** is a high-level, interpreted programming language known for its
    readability and simplicity. Developed by Guido van Rossum and first released in
    1991, Python has become one of the most popular programming languages in the world.
    Its key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to learn**: Python has a straightforward syntax that is similar to the
    English language, which makes it easy for most people to pick up quickly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic typing**: Variables can change their type based on the value assigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management**: Automatic memory management and garbage collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensive standard library**: A large standard library with modules for various
    tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: Runs on multiple OSs such as Windows, macOS, and Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpreted**: Code is executed line by line, which makes debugging easier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiparadigm**: Supports object-oriented, imperative, and functional programming
    styles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: Can be extended with C/C++ for performance-critical tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embeddable**: Can be embedded within C/C++ programs to give scripting capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community**: A large and active community supporting development and offering
    numerous modules and libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is used in various domains such as web development, data science, **artificial
    intelligence** (**AI**), **machine learning** (**ML**), networking, and more.
    Its frameworks such as Django and Flask are popular for web development, while
    libraries such as NumPy, Pandas, and TensorFlow are extensively used in scientific
    computing and AI.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a popular language in the realm of DevOps. You’ll often find various
    scripts written in Python that are then executed from CI/CD pipelines or other
    automation tooling. It’s definitely not required for DevOps, and sometimes other
    languages and facilities are used in favor of it, but for sure it’s a popular
    option in DevOps circles.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some basic Python example code, just to give you some idea of
    what it’s like.
  prefs: []
  type: TYPE_NORMAL
- en: Examining some simple Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is an expansive language, at least as complex as JS, and probably more
    so, honestly. Entire books have been written about Python, so there’s no way I
    could possibly teach you everything about Python in one chapter. But I want to
    give you at least a taste of what it looks like and what it can do. To do this,
    I’m going to show you an admittedly contrived example of something you might write
    as part of a CI/CD pipeline for a website. I think, given your exposure to JS
    thus far, that you’ll find Python pretty understandable even without delving into
    the details of it, which is one of the reasons it’s become so popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, take a look at the contents of the `build_and_deploy.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, a couple of libraries are imported for our Python script to use: the
    `os` and `shutil` libraries for working with the operating system and filesystem,
    and `datetime` so that we can get the current date and time.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, two functions named `make_index()` and `deploy()` are defined (that’s
    what the `def` keyword means in Python). The `make_index()` function writes a
    file named `index.html` into the `src` directory (the directory to write to is
    passed in as `source_path`), and `deploy()` is responsible for creating our final
    deployment directory (which, in this contrived example, we presume a web server
    uses to serve content).
  prefs: []
  type: TYPE_NORMAL
- en: Inside `make_index()`, a variable named `current_time` is defined with a value
    returned to us by a call to the `datetime.datetime.now()` function, which is made
    available to us from the imported `datetime` library. The `strftime()` function
    allows us to specify the format of the date and time we want – in this case, a
    string in the form `YYYY-MM-FF HH:MM:SS` (so, for example, `2023-12-10 18:10:53`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, another variable named `head` is defined that contains the HTML for the
    `<head>` section of our HTML document. In it, the `styles.css` file is imported,
    which you’ll find already exists in the `src` directory. The style configuration
    in it is simply `body { color : #ff0000; }` to make all the text in the `<body>`
    section red.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, the `index.html` file is written, and the value of `head` is inserted
    into it, giving us a proper `<head>` section in our HTML document. Because the
    string passed to the `file.write()` function that writes to the file is defined
    starting with `f"`, we can use replacement tokens inside, as with `{head}`. Python
    will insert the value of the `head` variable there for us. Another replacement
    token, `{current_time}`, does the same, so we’ll see the current date and time
    when the page is loaded (well, current as of when we built the site, that is).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `print()` statement echoes a status message to the console when
    we run the script.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `deploy()` function, it first checks to see if the site is already
    deployed by checking for the `live` directory, as specified in the `deploy_path`
    argument. If it does, then the `shutil.rmtree()` function is used to delete the
    directory, and a status message reflecting that is displayed via `print()`. Then,
    whether the directory was deleted or not, `shutil.copytree()` is used to create
    the deployment directory. More specifically, it copies the contents of the `src`
    directory – specified by the `source_path` argument – into the deployment directory.
    Finally, a status message is shown with `print()` again.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this script, the execution actually begins down at the bottom where
    you see the comment, which is denoted by the line beginning with a hash symbol.
    First, the source and deployment directories are defined as the `source_path`
    and `deploy_path` variables. Then, `make_index()` is called, which results in
    the `index.html` file being written into the `src` directory. Finally, `deploy()`
    is called, which will ensure we have a brand new deployment directory named `live`,
    and in it will be the `index.html` and `styles.css` files. We now effectively
    have a full –albeit very simple – website in the `live` directory, and if a web
    server is pointed at that directory, the website will be available for visitors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to run the script, assuming you have Python installed, you simply
    execute this command at a command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `py` command should have been made available as a result of installing Python.
    Give it a shot!
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, there is a lot more to Python than this simple example
    shows. However, it demonstrates many of the key concepts, including variables,
    functions, libraries, comments, conditionals, and the basic structure of a Python
    script. And this example shows something that you might conceivably want to execute
    in a CI/CD pipeline. Imagine if this script is automatically executed every time
    you push new code to Git, which is something typically done with CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you could have your new code deployed to a live web server for all
    the world to see, all automatically. That’s the power of DevOps and Python together!
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ah, we’re moving right along, revealing squares like mad! Here’s the updated
    web developer roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: The roadmap with a few more boxes filled in](img/B18315_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: The roadmap with a few more boxes filled in'
  prefs: []
  type: TYPE_NORMAL
- en: This time, you uncovered the **Graphic Design**, **DevOps**, **UX**, **Python**,
    **VMs and Containers**, and **Cloud Infrastructure** boxes. That was a big one!
    Let’s keep going, and before long, we’ll have them all revealed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered several unique areas. First, you looked at some
    frontend concerns, including graphic design, usability, and responsive design,
    to get a feel for why they’re important and how they benefit you in your web development
    journey. We then moved to the server side and talked about VMs and containers
    a bit to see how they are used to run your code. You then got a look at the cloud
    and learned what that’s about. Finally, we talked about DevOps a bit to understand
    how this popular approach to development enhances our ability to deliver quality
    code. As part of that discussion, you got a look at Python and played with it
    a little bit to see what it offers, especially as related to DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll jump back onto the frontend and focus on some of
    the biggest frameworks in use today, seeing how they provide you with a head start
    in your development and allow you to deliver more robust websites while reducing
    the effort to do so.
  prefs: []
  type: TYPE_NORMAL
