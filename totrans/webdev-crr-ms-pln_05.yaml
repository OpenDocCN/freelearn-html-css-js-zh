- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Understanding the User Experience, Deployment Options, and DevOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解用户体验、部署选项和DevOps
- en: 'In this chapter, we’re going to discuss a few other “random” topics, but that
    randomness really falls into two categories: the look, feel, and function of your
    site, and some options for deploying it to run for real. Admittedly, they are
    two different gears, but they mesh together in that you want any website you build
    to look good and work well, but obviously, that won’t be the case if you can’t
    build and eventually deploy it somewhere that others can access.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些其他的“随机”主题，但这些随机性实际上分为两类：你网站的外观、感觉和功能，以及一些部署它以实际运行的选择。诚然，它们是两个不同的齿轮，但它们结合在一起，因为你希望你构建的任何网站看起来都很好，工作得也很好，但显然，如果你不能构建并最终部署到其他人可以访问的地方，那就不会是这样的情况。
- en: Here, you’ll learn about ways to make your website attractive while ensuring
    it is functional for as wide an audience as possible. These are important considerations
    because users are attracted to websites that look good. But, then again, looking
    good doesn’t much matter if the website can’t really be used by them effectively,
    so both are key considerations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将了解如何使你的网站对尽可能广泛的受众既吸引人又实用。这些是重要的考虑因素，因为用户会被看起来好的网站所吸引。然而，如果网站不能被他们有效使用，那么外观好看也就不那么重要了，所以两者都是关键考虑因素。
- en: You’ll then learn about **virtual machines** (**VMs**), containers, and the
    cloud, all of which play into the notion of where and how to run your website
    because it has to run somewhere for people to access it! These options provide
    the flexibility and stability you need when putting a website online for all the
    world to see.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将了解**虚拟机**（**VMs**）、容器和云，这些都涉及到你的网站在哪里以及如何运行的问题，因为人们必须能够访问它！这些选项提供了你将网站上线供全世界看到时所需的灵活性和稳定性。
- en: Finally, you’ll learn a bit about DevOps, which is the modern approach to managing
    those deployments, as well as how you build your website from source code to final
    form. This is important because as a website gets more complex, so does the difficulty
    involved in keeping everything straight and ensuring you deliver high-quality
    results for your clients, and DevOps can help with that.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将了解一些关于DevOps的知识，这是管理这些部署的现代方法，以及如何从源代码构建你的网站到最终形式。这很重要，因为随着网站变得更加复杂，保持一切井然有序并确保你为客户提供高质量结果的难度也在增加，而DevOps可以帮助你做到这一点。
- en: 'This chapter, therefore, will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将涵盖以下主题：
- en: Understanding what makes a website look pretty – graphic design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使网站看起来漂亮的原因 – 图形设计
- en: Ensuring it doesn’t just look good but also works well for everyone – **user**
    **experience** (**UX**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它不仅看起来好，而且对每个人来说都工作得很好 – **用户体验**（**UX**）
- en: Virtualizing the world – VMs and containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化世界 – 虚拟机和容器
- en: Keeping your head in the clouds – cloud providers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持你的思维在云端 – 云服务提供商
- en: Taking back control – DevOps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复控制权 – DevOps
- en: Reviewing the roadmap
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查路线图
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Later in this chapter, we’re going to be talking about something called VMs
    and something called containers. As part of that discussion, I’m going to show
    you some basic container functionality. To follow along, you’ll need to do two
    things.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论一些被称为虚拟机（VMs）和容器的东西。作为这部分讨论的一部分，我将向你展示一些基本的容器功能。为了跟上，你需要做两件事。
- en: First, go to [https://www.virtualbox.org](https://www.virtualbox.org) and download
    and install Oracle VirtualBox. This is a program that lets you run VMs (whatever
    those are!).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往[https://www.virtualbox.org](https://www.virtualbox.org)下载并安装Oracle VirtualBox。这是一个允许你运行虚拟机（无论它们是什么！）的程序。
- en: Once that’s installed, head over to [https://www.osboxes.org/ubuntu](https://www.osboxes.org/ubuntu)
    and download the 23.10 Ubuntu Linux VirtualBox image. Just keep those at the ready
    for later!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，请前往[https://www.osboxes.org/ubuntu](https://www.osboxes.org/ubuntu)下载23.10
    Ubuntu Linux VirtualBox镜像。只需准备好这些，稍后使用即可！
- en: Finally, we’re going to lightly touch on Python, another programming language
    that developers often use. For that, you’ll need to install it on your system
    so that you can play with the sample code. To do so, head over to [https://www.python.org](https://www.python.org)
    and download and install the version appropriate for your system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要介绍Python，这是开发者经常使用的另一种编程语言。为此，你需要在你的系统上安装它，以便可以玩转示例代码。要做到这一点，请前往[https://www.python.org](https://www.python.org)下载并安装适合你系统的版本。
- en: You’ll also want to make sure you have the source code bundle for this book
    downloaded (as explained in [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082)) and
    the `ch05/1-python` directory at the ready.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what makes a website look pretty – graphic design
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so you’ve built a website that works. That’s a fine accomplishment to
    be sure, but what does it *look* like? Is it attractive? Is it pleasing to the
    eye? Is it a work of art? Answering those questions requires delving into the
    realm of graphic design. But, contrary to what you might think from my using the
    word “art” there, it’s surprisingly scientific!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphic design**, in simplest terms, is the application of certain techniques
    and knowledge about human psychology and even physiology to create visual content
    that communicates messages and does so in a way that is considered visually pleasing
    to many people. It blends creativity and technology to convey ideas through various
    visual means and plays a crucial role in branding, marketing, and media production.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Graphic designers – as well as web developers who very often find themselves
    playing the role – use various tools and software to create visual compositions
    (in our case, web development tools), which certainly include HTML, CSS, and even
    **JavaScript** (**JS**). While graphic design *is* rooted in art, a good design
    often considers principles such as balance, contrast, and hierarchy to ensure
    effective communication. This is the “science” part I mentioned.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: While graphic design, by and large, is about visual appeal – essentially, whether
    what’s on the screen looks pleasing – there’s also an element of usability to
    it. **Usability** refers to the ability of users to get work done efficiently
    with a given human-tool interface, where “tool” here can mean a website. That
    idea gets into something called **UX** – this is a topic that will be coming in
    the next section, but it revolves around things such as whether the user can navigate
    a website efficiently, whether the website meets their expectations in terms of
    functionality, and a lot more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: As an example of usability, if you have light-green text on a light-yellow background,
    that will likely be hard for a user to read, making the website less usable. Another
    example is animated backgrounds, which are all the rage on the web these days.
    They look great, but if you don’t properly consider the content that you’re putting
    on top of them, then you may make consuming that content much more difficult for
    users. You might disorient some users, even potentially making them feel sick.
    Applying graphic design principles in such scenarios can help you make the design
    look good while also maintaining solid usability.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the key areas that make up graphic design now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Understanding key graphic design areas
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graphic design touches on several areas, including the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Typography**: This includes things such as effective font choices, line lengths,
    and spacing, with the goal of making content readable and visually appealing.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排版设计**：这包括有效字体选择、行宽和间距等因素，目的是使内容易于阅读和视觉上吸引人。'
- en: '**Layout and print design**: This is all about arranging visual elements in
    space effectively, ensuring that there is a pleasing use of negative space (empty
    areas) to highlight content better, and effective alignment of elements to make
    scanning content easier on the user.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局和印刷设计**：这全部关于在空间中有效地安排视觉元素，确保负空间（空白区域）的使用令人愉悦，以更好地突出内容，以及元素的有效对齐，使用户扫描内容更容易。'
- en: '**Branding and logo design**: Proper branding and logo design create a visual
    identity for companies or products. This also includes color palette choice.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**品牌和标志设计**：适当的品牌和标志设计为公司或产品创造了一个视觉身份。这也包括色彩选择。'
- en: '**Motion graphics**: Not all graphics are static, especially nowadays on the
    web. Adding elements of animation can elevate a design greatly, but there is a
    fine line between elevation and distraction, and that balance must be maintained.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态图形**：并非所有图形都是静态的，尤其是在当今的互联网上。添加动画元素可以极大地提升设计，但提升和分散注意力之间的界限很微妙，这种平衡必须保持。'
- en: 'While graphic design techniques and tools evolve constantly, along with the
    technology used to implement designs, the core of graphic design always remains
    true: the visual communication of a message or ideas, effectively and aesthetically,
    and for the web, it also plays a big role in making a website more usable for
    users, meaning less frustrating and distracting from their goals.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图形设计技术和工具不断演变，以及用于实现设计的技术的演变，但图形设计的核心始终如一：信息的视觉传达，有效且美观，对于网络来说，它还在很大程度上决定了网站对用户的易用性，意味着减少用户在实现目标时的挫败感和分心。
- en: There exists a set of principles that can guide you in your graphic design duties
    called the Gestalt Principles, which we’ll look at now.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一系列称为格式塔原理的原则，可以指导你在图形设计工作中的职责，我们现在将探讨这些原则。
- en: Understanding the Gestalt Principles
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解格式塔原理
- en: 'The **Gestalt Principles** are a set of psychological theories about how humans
    perceive visual elements. They explain why certain elements are perceived as part
    of a group or related in some way. These principles are often applied in graphic
    design to enhance understanding and organization. The principles are listed next:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式塔原理**是一套关于人类如何感知视觉元素的心理理论。它们解释了为什么某些元素会被感知为属于一个群体或以某种方式相关联。这些原则通常应用于图形设计，以增强理解和组织。以下列出这些原则：'
- en: '**Proximity**: Elements that are close to each other are often perceived as
    related or grouped together. In graphic design for the web, related buttons or
    menu items are often placed close to one another to visually communicate that
    they are related functionally. In *Figure 5**.1*, notice how your mind groups
    the twelve squares on the left, the three squares in the upper right, and the
    three screens in the center:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻近性**：彼此靠近的元素通常被认为是有关系的或被分组在一起。在网页图形设计中，相关的按钮或菜单项通常放置在一起，以视觉上传达它们在功能上的相关性。在*图5.1*中，注意你的大脑如何将左边的十二个方块、右上角的三个方块和中间的三个屏幕分组在一起：'
- en: '![Figure 5.1: The Gestalt Proximity principle](img/B18315_05_1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：格式塔邻近性原理](img/B18315_05_1.jpg)'
- en: 'Figure 5.1: The Gestalt Proximity principle'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：格式塔邻近性原理
- en: '**Similarity**: Just as with proximity, when objects look alike, we group them
    together in our minds. This could be in terms of shape, size, or color. In *Figure
    5**.2*, your mind tends to group the dark squares together even when they aren’t
    immediately near each other:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相似性**：与邻近性一样，当物体看起来相似时，我们在心里将它们分组。这可能是形状、大小或颜色的相似。在*图5.2*中，你的大脑倾向于将深色方块分组在一起，即使它们并不立即相邻：'
- en: '![Figure 5.2: The Gestalt Similarity principle](img/B18315_05_2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：格式塔相似性原理](img/B18315_05_2.jpg)'
- en: 'Figure 5.2: The Gestalt Similarity principle'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：格式塔相似性原理
- en: As another example, sizing icons or buttons on a website gives a sense of related
    functionality and allows the user to build a mental model that says, “Things that
    look like this are buttons, and I can click them,” which helps make the website
    more usable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以另一个例子来说，在网站上调整图标或按钮的大小，可以给人一种相关功能的感觉，并允许用户构建一个心理模型，即“看起来像这样的东西是按钮，我可以点击它们”，这有助于使网站更易用。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A **mental model** is a common term that refers to the understanding a user
    creates – right or wrong – in their minds about what they’re looking at and what
    they’re doing as they proceed. Users build up mental models as they use an app
    or a website about what it’s doing, how it’s doing it, why, and what the results
    of actions are expected to be. It’s our job to ensure that the mental models users
    build match up with reality through graphic design principles.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**心智模型**是一个常用术语，指的是用户在他们心中形成的理解——无论是对是错——关于他们正在看什么以及他们正在做什么。用户在使用应用程序或网站时，会建立起关于它做什么、如何做、为什么以及预期行动结果的心智模型。我们的任务是确保用户建立的心智模型通过图形设计原则与现实相符。'
- en: '**Closure**: Our minds tend to fill in missing information to create a whole
    image. This comes into play when we look at complex arrangements of visual elements.
    Our minds tend to perceive a single, recognizable pattern from them. In the example
    in *Figure 5**.3*, your mind perceives a pentagon even though the line is broken:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封闭性**: 我们的大脑倾向于填补缺失的信息以形成一个完整的图像。当我们观察视觉元素的复杂排列时，这一点就会发挥作用。我们的思维倾向于从它们中感知到一个单一、可识别的图案。在*图5.3*中的例子中，尽管线条断裂，你的思维仍然感知到一个五边形：'
- en: '![Figure 5.3: The Gestalt Closure principle](img/B18315_05_3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3: 格式塔封闭性原则](img/B18315_05_3.jpg)'
- en: 'Figure 5.3: The Gestalt Closure principle'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '图5.3: 格式塔封闭性原则'
- en: This may be perfectly fine and even desired, but it can sometimes lead to confusion,
    so you have to take care in your design to avoid this where you can unless it’s
    what you’re going for.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能完全正常，甚至可能是所希望的，但它有时会导致混淆，因此你必须在设计中小心避免这种情况，除非这正是你想要的。
- en: '**Enclosure**: The Enclosure principle describes the tendency of human visual
    perception to group elements together to form a whole, most especially when they
    are enclosed within a boundary of some sort, even if they are otherwise disconnected.
    When we see a set of elements enclosed by a solid border or even just an outline,
    we perceive them as a single, cohesive group, almost as a discrete shape regardless
    of their physical positioning. The example in *Figure 5**.4* causes your brain
    to subconsciously group the three squares inside the large square together even
    though they aren’t near each other:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**: 封装原则描述了人类视觉感知将元素组合在一起形成整体的倾向，尤其是在它们被某种类型的边界包围时，即使它们在其他方面是分离的。当我们看到一组由实线边界或甚至只是轮廓包围的元素时，我们会将它们视为一个单一的、统一的群体，几乎就像一个离散的形状，而不管它们的物理位置如何。*图5.4*中的例子会让你的大脑潜意识地将大正方形内的三个小正方形组合在一起，尽管它们并不相邻：'
- en: '![Figure 5.4: The Gestalt Enclosure principle](img/B18315_05_4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4: 格式塔封装性原则](img/B18315_05_4.jpg)'
- en: 'Figure 5.4: The Gestalt Enclosure principle'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '图5.4: 格式塔封装性原则'
- en: '**Continuity**: Our eyes follow paths, lines, or curves, often preferring to
    see them as continuing along an established direction rather than making abrupt
    changes. This principle is useful in guiding a user’s attention in a specific
    direction! In *Figure 5**.5*, your mind is in a sense comforted by the subconscious
    expectation that the boxes will get larger as you go down, as they do:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续性**: 我们的眼睛会跟随路径、线条或曲线，通常更喜欢看到它们沿着既定的方向继续，而不是突然改变。这个原则在引导用户注意力的特定方向上非常有用！在*图5.5*中，你的思维在某种程度上得到了安慰，因为你潜意识地期望随着你向下移动，盒子会变大，正如它们所做的那样：'
- en: '![Figure 5.5: The Gestalt Continuity principle](img/B18315_05_5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5: 格式塔连续性原则](img/B18315_05_5.jpg)'
- en: 'Figure 5.5: The Gestalt Continuity principle'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '图5.5: 格式塔连续性原则'
- en: For example, taking the registration page we’ve previously worked on, all the
    entry fields go vertically down the page, in a single line. A user’s eye can follow
    this easily. If one of the fields suddenly aligned to the right side of the page,
    that would be disruptive for users, plus it probably wouldn’t look very good visually.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以我们之前工作过的注册页面为例，所有输入字段都垂直排列在页面下方，形成一条单线。用户的眼睛可以轻松地跟随这条线。如果其中一个字段突然对齐到页面的右侧，这可能会对用户造成干扰，而且从视觉上看可能也不会很好。
- en: '**Figure and Ground**: We instinctively perceive objects as either being in
    the foreground (figure) or the background (ground). This helps designers emphasize
    certain elements, but you must ensure you’re emphasizing the *right* elements
    at the *right* time, or you can confuse users. *Figure 5**.6* shows an example
    of how your mind tends to view the boxes inside the large rectangle as being more
    “up front” than those outside, even if you don’t realize it consciously:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图与底**：我们本能地将物体感知为前景（图）或背景（底）。这有助于设计师强调某些元素，但你必须确保你在正确的时间强调正确的元素，否则可能会让用户感到困惑。*图
    5.6* 展示了一个例子，说明你的大脑倾向于将大矩形内部的盒子视为比外部的盒子更“突出”，即使你并没有有意识地意识到这一点：'
- en: '![Figure 5.6: The Gestalt Figure and Ground principle](img/B18315_05_6.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：格式塔图与底原则](img/B18315_05_6.jpg)'
- en: 'Figure 5.6: The Gestalt Figure and Ground principle'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：格式塔图与底原则
- en: '**Connectedness**: Elements that are connected by uniform visual properties,
    such as a line or color, are perceived as being more related than elements that
    aren’t connected. This is often implemented on the web as group boxes – those
    boxes around elements that often have a small title on them. In *Figure 5**.7*,
    the fact that the shapes in each of the two connected groups aren’t the same doesn’t
    stop your brain from thinking of them as connected:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接性**：通过统一视觉属性（如线条或颜色）连接的元素被视为比未连接的元素更相关。这在网络上通常作为分组框实现——围绕元素的小标题周围的框。在 *图
    5.7* 中，两个连接组中形状的不同并不阻止你的大脑认为它们是连接的：'
- en: '![Figure 5.7: The Gestalt Connectedness principle](img/B18315_05_7.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：格式塔连接性原则](img/B18315_05_7.jpg)'
- en: 'Figure 5.7: The Gestalt Connectedness principle'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：格式塔连接性原则
- en: '**Common Fate**: Elements moving in the same direction are perceived as related
    or grouped. For instance, animations that move cohesively can show they’re part
    of the same action or concept, or even elements that move or are aligned in a
    haphazard way still appear to be grouped to us. *Figure 5**.8* demonstrates how
    your mind will see the boxes on the top being part of a continuous line and the
    boxes on the bottom as part of another continuous line, even though they are not
    spaced or aligned consistently, but because they appear to move in a consistent
    direction or toward a common fate:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共同命运**：朝同一方向移动的元素被视为相关或分组。例如，协同移动的动画可以表明它们是同一动作或概念的组成部分，或者即使元素以杂乱无章的方式移动或对齐，它们在我们看来仍然似乎被分组。*图
    5.8* 展示了你的大脑将顶部的盒子视为连续线的一部分，而底部的盒子作为另一条连续线的一部分，尽管它们在空间或对齐上并不一致，但这是因为它们似乎以一致的方向或向共同命运移动：'
- en: '![Figure 5.8: The Gestalt Common Fate principle](img/B18315_05_8.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：格式塔共同命运原则](img/B18315_05_8.jpg)'
- en: 'Figure 5.8: The Gestalt Common Fate principle'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：格式塔共同命运原则
- en: These principles help designers – and us web developers – create visual designs
    that are easily understood and processed by our users. By understanding how humans
    naturally group and separate visual information, we can create more effective,
    intuitive, and harmonious graphic design layouts, which for us means websites.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则帮助设计师——以及我们这些网页开发者——创建易于用户理解和处理的视觉设计。通过了解人类如何自然地分组和分离视觉信息，我们可以创建更有效、直观和和谐的图形设计布局，对我们来说这意味着网站。
- en: Having elements on the screen that look good and are well organized according
    to graphic design principles are factors in how well a user can actually use your
    site, but there’s more to it than that. Let’s now enter the domain of UX!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的元素看起来很好，并且根据图形设计原则组织得很好，这些都是用户能够有效使用你的网站的因素，但还有更多。现在让我们进入用户体验（UX）的领域！
- en: Ensuring it doesn’t just look good but also works well for everyone – UX
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保它不仅看起来很好，而且对每个人来说都工作得很好——用户体验（UX）
- en: In the previous section, we briefly discussed graphic design, and I mentioned
    that graphic design has a role to play in something called UX. Let’s dive into
    that topic in more detail now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们简要讨论了图形设计，并提到图形设计在所谓的用户体验（UX）中扮演着一定的角色。现在让我们更详细地探讨这个话题。
- en: UX refers to a person’s overall experience when interacting with a product,
    system, or service, especially in terms of how easy or pleasing it is to use.
    It’s concerned with their perception of a product, with the ultimate goal being
    to make them happy using the thing you produce both before, during, and after
    using it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: UX指的是人与产品、系统或服务互动的整体体验，特别是在使用过程中的易用性和愉悦性。它关注他们对产品的感知，最终目标是让他们在使用你生产的产品之前、使用过程中以及使用之后都感到满意。
- en: UX is an iterative process where you research, plan, test, and then refine the
    various touch points a person has with a product, trying to move closer to those
    goals with each iteration. It’s not about guesswork; it tends to be very scientific.
    You can guess which features of a product will make users happy, but those guesses
    – which should be based on research – are just a starting point. You then need
    to put the product in front of people, see how they interact with it, get their
    feedback, and then tweak the product based on that feedback.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: UX是一个迭代的过程，在这个过程中，你研究、规划、测试，然后根据每次迭代的结果，改进人们与产品互动的各种接触点，试图逐步接近那些目标。这并非关于猜测；它往往非常科学。你可以猜测哪些产品特性会让用户感到高兴，但这些猜测——应该基于研究——只是起点。然后你需要将产品展示给人们，观察他们如何与之互动，获取他们的反馈，然后根据这些反馈调整产品。
- en: UX isn’t a web development or even a computer thing. In fact, one of the most
    famous books on UX ever, *The Design of Everyday Things* by Don Norman, barely
    even talks about computers, let alone websites – it spends more time talking about
    teapots and turn signals in your car! That’s because UX applies to how humans
    interact with any piece of technology, or really any object more generally. But,
    specifically within the context of digital design, UX focuses on the user’s journey
    through a website or application. So, let’s take a closer look at the topic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: UX并非仅仅是网页开发或计算机相关的事物。实际上，关于UX最著名的书籍之一，唐·诺曼的《日常事物的设计》，几乎完全没有提到计算机，更不用说网站了——它更多地讨论了茶壶和汽车上的转向信号！这是因为UX适用于人类与任何技术或更广泛地说，任何物体互动的方式。但是，在数字设计的具体背景下，UX专注于用户在网站或应用程序中的旅程。因此，让我们更深入地探讨这个话题。
- en: Key concepts of UX
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UX的关键概念
- en: 'Here are some of the key concepts that comprise UX:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些构成UX的关键概念：
- en: '**Usability**: This is about how user-friendly and intuitive the interface
    is. It includes ideas such as ease of learning (are users able to discover, without
    reading documentation, how your app works?), efficiency of use (can users get
    work done with a minimum of steps?), memorability, error frequency, severity and
    how easily they can recover from errors, and overall user satisfaction.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这关乎界面的用户友好性和直观性。它包括诸如学习容易程度（用户是否能够在不阅读文档的情况下发现应用程序的工作方式？）、使用效率（用户能否以最少的步骤完成任务？）、记忆度、错误频率、严重程度以及他们从错误中恢复的容易程度，以及整体用户满意度。'
- en: '**Interaction design**: This involves designing interactive digital products,
    environments, systems, and services. It’s about creating interfaces with well-thought-out
    behaviors. One thing you never want to do with any software product is to surprise
    users. It should be obvious what a button will do if they click it; they shouldn’t
    have to guess. Interaction design largely defines this idea.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互设计**：这涉及到设计交互式数字产品、环境、系统和服务。它关乎创建具有深思熟虑行为的界面。你绝对不希望在任何软件产品中让用户感到惊讶。如果他们点击按钮，按钮会做什么应该是显而易见的；他们不应该需要猜测。交互设计在很大程度上定义了这一概念。'
- en: '**User research**: Understanding the users’ needs, motivations, and behaviors
    through methods such as surveys, interviews, and usability testing (oftentimes,
    you’ll literally watch users interact with your website to look for things such
    as if they get frustrated trying to navigate it). This research informs design
    decisions, especially as you iterate the design.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户研究**：通过调查、访谈和可用性测试（通常，你会实际观察用户如何与你的网站互动，寻找他们是否在导航时感到沮丧等问题）等方法了解用户的需求、动机和行为。这项研究为设计决策提供信息，尤其是在你迭代设计时。'
- en: '**Information architecture (IA)**: This is about structuring, organizing, and
    labeling content effectively and sustainably. Good IA helps users find information
    and complete tasks. One common tool for IA is a **card-sorting** exercise. Let’s
    say you have several topics to be covered on a website, and some of them are sub-topics
    of others. To organize this, you might write every topic on a literal note card,
    then arrange the top-level topics in a line, and then put the sub-topics beneath
    them.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息架构（IA）**：这是关于有效且可持续地构建、组织和标记内容。良好的信息架构有助于用户找到信息并完成任务。信息架构的一个常见工具是**卡片分类**练习。假设您有一个网站需要涵盖的几个主题，其中一些是其他主题的子主题。为了组织这些，您可能会在每个主题上写一个实际的卡片，然后将顶级主题排成一行，然后将子主题放在它们下面。'
- en: '**Content strategy**: This involves planning, creating, delivering, and managing
    content. Content should be relevant and useful to users, and you should look to
    minimize extraneous content that might just confuse them or get in the way. In
    graphic design, the idea of negative space is important, which is knowing when
    *not* to put something on the screen. There is value in empty space sometimes,
    but by the same token, there can be value in *not* providing information when
    it won’t help a user achieve their primary goal. The company Apple is a great
    example of this: it tends to minimize options available to users. This can be
    frustrating for some more advanced users, but for typical users, it actually aids
    them because the phenomenon of **analysis paralysis** is avoided by not overloading
    them with options. This applies not only to options but to information as well.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容策略**：这涉及到规划、创建、交付和管理内容。内容应该对用户相关且有用，您应该尽量减少可能只是混淆他们或阻碍他们的无关内容。在图形设计中，负空间的概念很重要，即知道何时不在屏幕上放置某些内容。有时空白空间是有价值的，但同样，当信息不会帮助用户实现主要目标时，不提供信息也可能有价值。苹果公司是这方面的绝佳例子：它倾向于最小化用户可用的选项。这可能会让一些高级用户感到沮丧，但对于典型用户来说，这实际上有助于他们，因为通过不过度加载选项来避免**分析瘫痪**的现象。这不仅适用于选项，也适用于信息。'
- en: '**User feedback**: Continuous collection of user feedback is crucial for iterative
    improvement of the UX. Of course, when initially designing and building a website,
    it’s helpful to get that feedback so that you can make changes as you go. However,
    seeking user feedback shouldn’t stop after the site is live. There’s always room
    for improvement, but you shouldn’t go about this blindly. Hearing from your users
    is a good way to get the information you need to make improvements based on data.
    User feedback can be direct – things such as surveys users can fill out – or indirect
    – perhaps by looking at metrics about things such as how often users click a help
    link, for example. If you find that every user that visits your site looks for
    help or, worse, abandons the site before doing something meaningful, that’s a
    form of feedback that is probably telling you your site isn’t as easy to use as
    you might have thought. Analytics and performance data are, therefore, an aspect
    of this.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户反馈**：持续收集用户反馈对于用户体验的迭代改进至关重要。当然，在最初设计和构建网站时，获取反馈以便在过程中进行更改是有帮助的。然而，在网站上线后，寻求用户反馈不应停止。总有改进的空间，但您不应盲目行事。听取用户的意见是获取您需要的信息以基于数据进行改进的好方法。用户反馈可以是直接的——例如用户可以填写的调查——或者间接的——例如通过查看有关用户点击帮助链接频率等指标的度量。如果您发现每个访问您网站的用户都在寻找帮助，或者更糟糕的是，在做一些有意义的事情之前就放弃了网站，那么这种反馈可能是在告诉您，您的网站可能不像您想象的那么易于使用。因此，分析和性能数据是这一方面的一个方面。'
- en: '**Prototyping and wireframing**: These are essential tools in UX design. Prototyping
    is about creating a preliminary model of a product, which can be a low-fidelity
    sketch or a high-fidelity interactive model. Wireframes are basic layouts that
    outline sizes and placement of page elements, features, and navigation for your
    website or app. We talked about this in the first chapter, but it’s worth mentioning
    it here to understand how it relates to UX. These are your early “guesses” about
    the overall design that you’ll want to present to users as early as possible so
    that you can begin iterating as needed.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型设计和线框图**：这些是用户体验设计中的基本工具。原型设计是指创建产品的初步模型，这可能是一个低保真草图或一个高保真交互模型。线框图是基本的布局，概述了网页或应用中页面元素、功能和导航的大小和位置。我们在第一章中讨论了这一点，但在这里再次提及是为了理解它与用户体验的关系。这些是您对整体设计的早期“猜测”，您希望尽可能早地向用户展示，以便开始必要的迭代。'
- en: '**User personas**: These are fictional characters created to represent the
    different user types that might use a service, product, site, or brand. Personas
    help designers and developers understand their users’ needs, experiences, behaviors,
    and goals. What does a persona look like? Here’s an example:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户画像**：这些是为了代表可能使用服务、产品、网站或品牌的不同用户类型而创建的虚构人物。用户画像帮助设计师和开发者了解用户的需求、体验、行为和目标。用户画像是什么样的？以下是一个例子：'
- en: '[PRE0]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With a persona such as this, design decisions can be made that will address
    the challenges of the client. For example, based on Mike’s challenges, we may
    want to create a design that presents as little information as possible at any
    given time to keep Mike from getting overwhelmed. Also, given his needs, we begin
    to have an understanding of what the interface will look like; in this case, we’ll
    most likely need some visual metaphor that presents categories of information,
    perhaps a tab for each, or maybe sections that can be expanded and collapsed for
    each.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这样的用户画像，可以做出设计决策来解决客户面临的挑战。例如，基于迈克的挑战，我们可能希望创建尽可能少地展示信息的设计，以防止迈克感到不知所措。此外，考虑到他的需求，我们开始了解界面将是什么样子；在这种情况下，我们很可能需要一些视觉隐喻来展示信息类别，可能每个类别都有一个标签，或者可能是可以展开和折叠的各个部分。
- en: '**Journey mapping**: This involves creating a visual representation of the
    user’s interaction with a product. It helps in understanding and addressing user
    needs and pain points throughout their journey. As with card sorting, this will
    often take the form of pieces of paper on a large pegboard with string and thumbtacks.
    The pieces of paper may have hand-drawn sketches of various screens, and then
    the string shows how the user will move from one screen or function to the next.
    It certainly doesn’t have to take this form – some people prefer to work in a
    graphics or flowcharting program and do it all digitally – but the low-fidelity
    approach is often employed for both speed and for ensuring you aren’t focusing
    on anything technological. The concerns here shouldn’t take technology into account,
    at least no more than is absolutely necessary. You’re focusing on logic flow and
    nothing more.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旅程映射**：这涉及到创建用户与产品交互的视觉表示。它有助于理解和解决用户在整个旅程中的需求和痛点。与卡片分类一样，这通常以大版图上的纸张形式出现，使用绳子和图钉。这些纸张上可能有手绘的各种屏幕草图，然后绳子显示用户如何从一个屏幕或功能移动到下一个。当然，这不必采取这种形式——有些人更喜欢在图形或流程图程序中工作，并全部数字化处理——但低保真方法通常用于速度和确保你不会专注于任何技术方面。这里的关注点不应考虑技术，至少不应超过绝对必要的程度。你专注于逻辑流程，不再关注其他。'
- en: '**Cross-platform consistency**: Ensuring a consistent experience across various
    platforms and devices, which includes maintaining functionality and design uniformity.
    In other words, you usually want a website to look the same on a Windows machine
    as on a Mac machine, and you usually don’t want there to be functionality available
    on a desktop machine that isn’t also available on a cell phone (though the form
    of that function could be different, of course). There are sometimes exceptions
    to this idea, of course – times when it makes sense for things to look different
    or function differently on one platform versus another – but they tend to be just
    that: exceptions.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台一致性**：确保在各种平台和设备上提供一致的用户体验，这包括保持功能和设计的统一性。换句话说，你通常希望网站在Windows机器上和在Mac机器上看起来一样，而且通常不希望桌面机器上有的功能在手机上没有（当然，该功能的形态可能会有所不同）。当然，有时会有例外——有些时候，让事物在一个平台上看起来或功能上与另一个平台不同是有意义的——但它们往往只是例外。'
- en: '**Contextual design**: This is about designing based on the understanding of
    how users interact with the product in their actual environment. This often involves
    watching users use your product as they really do, not in a lab setting, because
    sometimes there are considerations you wouldn’t otherwise be aware of. To give
    one example, you could find that users of your factory control system have to
    use your system wearing bulky gloves. This may affect your design by requiring
    that buttons on the screen be much larger than usual so that they are easier to
    tap. You wouldn’t have known this without observing them in their natural environment
    (which means it’s helpful to do this as research *before* you get into designing
    anything too).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情境设计**：这是基于对用户在实际环境中如何与产品互动的理解来进行设计。这通常涉及观察用户如何真正使用你的产品，而不是在实验室环境中，因为有时会有你之前没有意识到的考虑因素。举一个例子，你可能会发现你的工厂控制系统用户必须戴着笨重的手套使用你的系统。这可能会影响你的设计，需要屏幕上的按钮比通常要大得多，以便更容易点击。如果没有在他们的自然环境中观察他们，你就不会知道这一点（这意味着在开始设计任何东西之前进行这项研究是有帮助的）。'
- en: '**Usability testing**: Regular testing with real users to get feedback on designs
    and functionality, which is crucial for iterative design processes. You never
    want to assume that your designs are ideal; you want to test those assumptions
    as often as you can and make changes based on what you discover. There are many
    forms of usability testing:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**：定期与真实用户进行测试，以获取对设计和功能性的反馈，这对于迭代设计过程至关重要。你永远不希望假设你的设计是完美的；你希望尽可能多地测试这些假设，并根据你发现的内容进行修改。有许多形式的可用性测试：'
- en: Having webcams pointed at users as they test your design.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试你的设计时，将摄像头对准用户。
- en: Having a usability lab set up where things such as eye tracking (to see what
    a user is actually looking at and fixating on can be determined) and otherwise
    observing them in action come into play.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个可用性实验室中设置，可以观察用户的行为，例如通过眼动追踪（以确定用户实际看什么以及他们注视什么）以及其他观察他们在行动中的表现。
- en: Having user interviews, where you simply sit with a user and ask them questions
    about their experience (sometimes done as they’re playing with your website; sometimes,
    afterward). Surveys and focus groups can also be considered here too.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行用户访谈，你只需与用户坐在一起，询问他们关于其体验的问题（有时在他们玩你的网站时进行；有时在之后进行）。调查和焦点小组也可以考虑在这里。
- en: There are several other forms, each with a different goal and focus, but all
    with the one common goal of validating your design decisions against real UX.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有其他几种形式，每种都有不同的目标和重点，但所有这些都有一个共同的目标，即验证你的设计决策是否符合真实的用户体验。
- en: '**Design thinking**: A problem-solving approach that involves empathizing with
    users, defining problems, ideating solutions, prototyping, and testing. As designers,
    it’s very easy to make decisions based on what you like and think is optimal,
    but that isn’t always what’s best for users. Research and testing play a big role
    in this, but there’s a larger mindset involved. You have to fight the urge to
    make assumptions and to make decisions based on your own thinking. It’s all about
    the user at the end of the day, which is where the term *user-centric design*
    comes in. The user is the focus; they are the center, and everything you do should
    be based on them.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计思维**：一种涉及与用户共情、定义问题、构思解决方案、原型设计和测试的问题解决方法。作为设计师，很容易基于你喜欢的和认为最优的东西做出决定，但这并不总是对用户最好的。研究和测试在这个过程中扮演着重要角色，但还涉及到更大的思维模式。你必须克服做出假设和基于自己思考做出决定的冲动。最终，一切都是为了用户，这就是“以用户为中心的设计”这个术语的由来。用户是重点；他们是中心，你所做的一切都应该基于他们。'
- en: '**Ethics and privacy**: Considering ethical implications and privacy concerns
    in design, especially when dealing with user data. This can come in many forms,
    but one example is simply masking passwords. You’ve certainly seen websites where
    when you type your password, only asterisks appear. This is done so that someone
    can’t stand over your shoulder and see your password. It’s a small, simple example,
    but it shows that design plays a role in privacy.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伦理和隐私**：在设计时考虑伦理影响和隐私问题，尤其是在处理用户数据时。这可以有多种形式，但一个例子是简单地隐藏密码。你肯定见过当你在输入密码时，只有星号出现。这样做是为了防止有人站在你身后看到你的密码。这是一个简单的小例子，但它表明设计在隐私方面发挥着作用。'
- en: '**Interaction animation**: Subtle animations can improve the UX by providing
    feedback, demonstrating cause and effect, and adding a layer of polish and professionalism
    to the interaction. We talked about this in the graphic design section, but it’s
    worth calling out as it relates to usability because animation can be a divisive
    topic. Too much animation will actually annoy and frustrate users and maybe even
    make them sick, but too little will often yield a design that isn’t as pleasing
    to use as one with just the right amount used. Given all of this, that’s why the
    use of animation to reflect interactions is important enough to be its own key
    topic.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互动画**：微妙的动画可以通过提供反馈、展示因果关系，并为交互添加一层光泽和专业性来改善用户体验。我们在图形设计部分讨论了这一点，但鉴于它与可用性的关系，值得单独指出，因为动画可能是一个有争议的话题。过多的动画实际上会令用户烦恼和沮丧，甚至可能让他们感到恶心，而太少的动画则往往会导致设计不如使用恰到好处的动画那样令人愉悦。考虑到所有这些，这就是为什么使用动画来反映交互如此重要，以至于它成为一个关键主题。'
- en: '**Visual design**: Although distinct from UX, visual design (how things look)
    impacts UX. It includes typography, color schemes, and layout. Effectively, this
    means the same as graphic design, then, but it’s worth being aware of the term
    since you may hear both at various times.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉设计**：尽管与UX不同，视觉设计（事物看起来如何）会影响UX。它包括字体、配色方案和布局。实际上，这意味着与图形设计相同，但值得注意这个术语，因为你可能会在各个时候听到它。'
- en: Incorporating these aspects of UX into your work can greatly enhance the quality
    and user satisfaction of the software products you develop or architect. In your
    role as a web developer, integrating UX principles into your development process
    can significantly enhance the end product’s effectiveness, efficiency, and user
    satisfaction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些UX方面融入你的工作中可以极大地提高你开发或设计的软件产品的质量和用户满意度。在你作为网络开发者的角色中，将UX原则融入你的开发流程可以显著提高最终产品的有效性、效率和用户满意度。
- en: While in some organizations, there will be an entirely separate group responsible
    for UX, that won’t always be the case, and even when it is, it makes a lot of
    sense for you as a developer to have some grasp of these concepts, if for no other
    reason than to be better able to interface with such separate groups.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些组织中，可能会有一个完全独立的团队负责用户体验（UX），但这并不总是如此，即使如此，作为一个开发者，你对这些概念有所了解也是非常合理的，至少可以更好地与这样的独立团队进行接口。
- en: 'If you remember only one thing from all of this, let it be this: users are
    what it’s all about! You have to base your design decisions on what they need,
    what they want, and what makes them happy. And you need to make those decisions
    based on good research and testing, not assumptions.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只从所有这些中记住一件事，那就让它成为：用户是这一切的核心！你必须基于他们的需求、他们的愿望以及让他们快乐的因素来做出设计决策。而且你需要基于良好的研究和测试来做出这些决策，而不是基于假设。
- en: Another topic that has a role to play in UX is accessibility.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在UX中扮演角色的主题是可访问性。
- en: Considering accessibility
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑可访问性
- en: Accessibility is, in a sense, another aspect of UX, but it’s a large enough
    concern to be its own topic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，可访问性是UX的另一个方面，但它是一个足够大的问题，可以成为一个单独的主题。
- en: '**Accessibility**, in the context of digital design, refers to the practice
    of making your websites and applications usable by as many people as possible,
    including those with disabilities. This encompasses a wide range of conditions,
    including visual, auditory, physical, speech, cognitive, language, learning, and
    neurological disabilities.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字设计的背景下，**可访问性**指的是使你的网站和应用尽可能由尽可能多的人使用，包括那些有残疾的人的做法。这包括广泛的情况，包括视觉、听觉、身体、言语、认知、语言、学习和神经系统的残疾。
- en: 'Here are some key points to consider:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的关键点：
- en: '**Web Content Accessibility Guidelines (WCAG)**: These are part of a series
    of web accessibility guidelines published by the **World Wide Web Consortium**
    (**W3C**) ([https://www.w3.org/WAI/standards-guidelines/wcag](https://www.w3.org/WAI/standards-guidelines/wcag)),
    consisting of a set of recommendations for making web content more accessible.
    They encompass many points that you can follow to help make your sites accessible
    to various user groups with different needs.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络内容可访问性指南（WCAG）**：这是由**万维网联盟（W3C）**（[https://www.w3.org/WAI/standards-guidelines/wcag](https://www.w3.org/WAI/standards-guidelines/wcag)）发布的一系列网络可访问性指南的一部分，包括一系列使网络内容更具可访问性的建议。它们包括许多你可以遵循的点，以帮助使你的网站对具有不同需求的各个用户群体更加可访问。'
- en: '`<img src="img/companyLogo.png" alt="This is a company logo showing an eagle
    with a fish in its beak">`. Someone who is blind and is using a screen reader
    will have the alt text read out to them, providing a description of the logo.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<img src="img/companyLogo.png" alt="This is a company logo showing an eagle
    with a fish in its beak">`. Someone who is blind and is using a screen reader
    will have the alt text read out to them, providing a description of the logo.'
- en: '**Keyboard navigation**: Ensure that all interactive elements on a website
    can be accessed and used through keyboard controls, which is crucial for users
    who cannot use a mouse. This is generally easy to achieve and to a large extent
    happens automatically thanks to web browsers. The one thing you need to keep in
    mind, though, is relatively simple things such as the order of elements on a form.
    An HTML form – unless you do something wrong – should be keyboard-navigable by
    default. But if you don’t put the elements of the form in a logical order, what
    can happen is you can make elements that most users need to access more difficult
    to get to via the keyboard. For example, on a user registration form that needs
    a person’s first and last name, you probably don’t want to put the last name at
    the end of the form with 10 other fields between it and the first name field at
    the top.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键盘导航**：确保网站上的所有交互元素都可以通过键盘控制来访问和使用，这对于无法使用鼠标的用户至关重要。这通常很容易实现，在很大程度上是自动完成的，多亏了网络浏览器。然而，你需要记住的是相对简单的事情，比如表单中元素的顺序。除非你做错了什么，否则HTML表单应该默认可以通过键盘导航。但如果你没有将表单的元素按照逻辑顺序排列，可能会使得大多数用户需要通过键盘访问的元素变得更加困难。例如，在一个需要输入个人姓名的注册表单中，你很可能不希望将姓氏放在表单的末尾，中间有10个其他字段，而姓氏字段在顶部。'
- en: '**Visual design**: This includes considerations for color contrast to aid users
    with color blindness or visual impairments, as well as ensuring text size and
    spacing are adjustable. Some of this again comes for free with web browsers, unless
    you write bad code that gets in the way. But some elements of design come into
    play too – things such as using colors for text that work well against background
    colors, as a simple example.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉设计**：这包括考虑颜色对比以帮助色盲或视觉障碍用户，以及确保文本大小和间距可调整。其中一些又因为网络浏览器而免费提供，除非你编写了阻碍的糟糕代码。但也有一些设计元素发挥作用——比如使用与背景颜色搭配良好的颜色来显示文本，仅举一个简单的例子。'
- en: '**Captioning and transcripts**: Supply captions for video content and transcripts
    for audio content is essential for users who are deaf or hard of hearing.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字幕和文本脚本**：为视频内容提供字幕，为音频内容提供文本脚本，对于听力受损或听力障碍的用户至关重要。'
- en: '**Consistent navigation**: Keep navigation consistent throughout the site helps
    users with cognitive disabilities to better understand and interact with the content.
    This is, of course, good for users who aren’t disabled too, though the difference
    is that someone with disabilities may be unable to use your site while someone
    without disabilities may simply not like using your site. The former is worse,
    but the latter isn’t much better!'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的导航**：在整个网站上保持导航的一致性，有助于认知障碍用户更好地理解和交互内容。当然，这对没有残疾的用户也是有益的，尽管区别在于，有残疾的人可能无法使用你的网站，而没有残疾的人可能只是不喜欢使用你的网站。前者更糟糕，但后者也不见得更好！'
- en: '**Error identification and instructions**: Make sure that errors are clearly
    identified and instructions are provided to help users understand how to complete
    tasks, such as filling out forms. You never want to insult your users first of
    all, so simple things such as the wording of error messages are a factor. For
    example, writing “A first name is required” is probably better than “You didn’t
    enter a first name.” But more than that, you want to ensure that your error messages
    and instructions clearly describe what needs to be done as succinctly as possible.
    This is harder than it sounds and is a place where good user research is very
    helpful.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误识别和说明**：确保错误被清楚地识别，并提供说明以帮助用户理解如何完成任务，例如填写表格。首先，你绝对不希望冒犯你的用户，所以像错误消息的措辞这样的简单事情是一个因素。例如，写“需要输入名字”可能比“你没有输入名字”更好。但不仅如此，你还想确保你的错误消息和说明尽可能简洁地清楚地描述需要做什么。这比听起来要难，而且良好的用户研究在这里非常有帮助。'
- en: '**Legal compliance**: In many regions, there are legal requirements for digital
    accessibility, such as the **Americans with Disabilities Act** (**ADA**) in the
    US. That means that what we’re talking about here isn’t just good; it’s legally
    *necessary* in many cases.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法律合规性**：在许多地区，存在关于数字可访问性的法律要求，例如美国的**美国残疾人法案**（ADA）。这意味着我们在这里讨论的不仅仅是好的；在许多情况下，它是法律上**必要**的。'
- en: Incorporating accessibility into your software development and design processes
    not only expands your user base but also reflects a commitment to inclusivity
    and legal compliance. As a software developer/architect, considering accessibility
    from the outset of a project can significantly enhance the usability and reach
    of your applications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将可访问性融入你的软件开发和设计流程不仅扩大了你的用户群，而且反映了你对包容性和法律合规性的承诺。作为一名软件开发者/架构师，从项目一开始就考虑可访问性可以显著提高你应用程序的可用性和覆盖范围。
- en: One final topic I want to discuss within the context of UX is something that
    very often plays into designing for mobile devices (though not exclusively), and
    that’s responsive design.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户体验的背景下，我想讨论的最后一个话题是，它经常与为移动设备设计（尽管不是唯一）相关，那就是响应式设计。
- en: Flexing with responsive design
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与响应式设计一起弯曲
- en: One more topic that plays into UX, but which is often considered its own, separate
    concept, is responsive design. Today, across the world, it’s often said that more
    people are accessing websites from mobile devices such as cell phones than desktop
    computers with large monitors sitting on their desks. Therefore, it’s often a
    good idea to take a mobile-first design strategy – that is, design your website
    to look and work well on small form factor devices such as cell phones, and *then*
    enhance it to work better on larger screens. This is where responsive design comes
    into play.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与用户体验相关但通常被视为一个独立概念的话题是响应式设计。今天，在全球范围内，人们通过手机等移动设备访问网站的人数往往比坐在办公桌前的大型显示器上的台式电脑要多。因此，采取以移动设备为先的设计策略通常是一个好主意——也就是说，设计你的网站使其在小尺寸设备上看起来和工作得很好，然后**再**增强其在更大屏幕上的表现。这就是响应式设计发挥作用的地方。
- en: '**Responsive design** is an approach to website design that has the goal of
    creating sites that provide an optimal viewing experience, meaning it is easy
    to read and navigate with a minimum of resizing, panning, and scrolling, across
    a wide range of devices, from large desktop computer monitors to smaller mobile
    phones. While there are some specific technological components, it’s largely more
    about a basic approach, a mindset even. It’s based on the knowledge that a large
    percentage of the world’s population uses smaller mobile devices to access the
    internet these days rather than desktop computers with, typically, large monitors.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式设计**是一种网站设计方法，其目标是创建提供最佳观看体验的网站，这意味着它易于阅读和导航，最小化调整大小、平移和滚动，适用于从大型台式电脑显示器到小型手机的广泛设备。虽然有一些特定的技术组件，但它更多地关乎基本方法，甚至是一种心态。它基于这样一个事实：如今，世界上很大一部分人口使用的是较小的移动设备来访问互联网，而不是通常配备大屏幕的台式电脑。'
- en: 'Key aspects of responsive design include the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式设计的关键方面包括以下内容：
- en: '**Fluid grids**: The layout of a website can use a CSS construct called flexible
    grids. They adapt to the viewer’s screen size automatically, reflowing content
    or even rearranging it as needed. This also means that instead of designing fixed-width
    layouts, elements on the page are sized in relative units such as percentages,
    rather than absolute units such as pixels.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流动网格**：网站的布局可以使用称为灵活网格的CSS结构。它们会自动适应观看者的屏幕大小，根据需要重新排列内容或重新排列。这也意味着，而不是设计固定宽度的布局，页面上的元素尺寸使用相对单位，如百分比，而不是绝对单位，如像素。'
- en: '**Flexible images**: Images in responsive design are also fluid. They are sized
    in relative units to prevent them from displaying outside their containing element.
    This ensures that images don’t suddenly take up a large chunk of the screen real
    estate, pushing more important content out of the way.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的图片**：响应式设计中的图片也是流动的。它们的尺寸使用相对单位来防止它们超出其包含元素显示。这确保了图片不会突然占据屏幕的大量空间，从而将更重要的内容推离原位。'
- en: '**Media queries**: CSS media queries allow the page to use different CSS style
    rules based on the characteristics of the device, most commonly the width of the
    browser. I’ll give an example of this shortly.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体查询**：CSS媒体查询允许页面根据设备的特征使用不同的CSS样式规则，最常见的是浏览器的宽度。我很快会给出一个例子。'
- en: '**Mobile first**: The concept here is that you should design for small screens
    first and then add more features and content for larger screens as necessary.
    It ensures accessibility for mobile users from the start.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从移动端开始设计**：这里的理念是您应该首先为小屏幕设计，然后根据需要添加更多功能和内容以适应大屏幕。这确保了从开始就为移动用户提供可访问性。'
- en: '**Breakpoints**: In responsive design, breakpoints are used to define where
    the website’s layout should change to accommodate different screen sizes. Common
    breakpoints are set for mobile, tablet, and desktop widths. Breakpoints and media
    queries typically work together in that breakpoints typically are implemented,
    in part, using media queries.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**：在响应式设计中，断点用于定义网站布局应如何改变以适应不同的屏幕尺寸。常见的断点设置为适用于移动设备、平板电脑和桌面宽度。断点和媒体查询通常一起工作，断点通常部分通过媒体查询实现。'
- en: '`em` or `rem` for text sizing, which are alternate units available in CSS (as
    opposed to `px` and `pt`, for example – there are *a lot* of units available in
    CSS for more advanced use cases).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文本大小，使用`em`或`rem`，这些是CSS中可用的替代单位（例如，与`px`和`pt`相比——CSS中有许多单位可用于更高级的使用场景）。
- en: '**Touch versus mouse**: Developers should be aware that some users will be
    using devices where touch is the primary method of interaction – a smartphone,
    for example – versus desktops that are more often used with mice. Touch interactions
    have different needs than those with a mouse. As one common example, buttons tend
    to need to be larger for touch interactions.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触摸与鼠标**：开发者应该意识到，一些用户将使用以触摸为主要交互方式的设备——例如智能手机——而桌面电脑更常使用鼠标。触摸交互有不同的需求，与鼠标交互不同。一个常见的例子是，按钮通常需要更大，以便于触摸交互。'
- en: '**Performance optimization**: Responsive sites often need to load on various
    devices with different capabilities and connection speeds. While many users will
    have modern, high-powered smartphones, that isn’t always the case. Some may have
    underpowered devices that are simply slower. Therefore, optimizing images, minifying
    CSS and JS (reducing their size through various tools), and leveraging techniques
    such as lazy loading, where images and other content aren’t even loaded until
    the user scrolls far enough down the page for them to be visible, can help improve
    performance for all users, but especially those using weaker devices.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：响应式网站需要在具有不同能力和连接速度的各种设备上加载。虽然许多用户将拥有现代、高性能的智能手机，但这并不总是如此。有些人可能拥有性能不足的设备，运行速度较慢。因此，优化图像、最小化CSS和JS（通过各种工具减小其大小）以及利用如懒加载等技术（即图像和其他内容只有在用户滚动到足够远的位置以便它们可见时才加载），可以帮助提高所有用户的性能，尤其是那些使用较弱设备的用户。'
- en: '**Testing**: Responsive designs must be tested on multiple devices and browsers
    to ensure compatibility and usability. This can involve physical device testing,
    emulators, and online sites that can simulate a website across many different
    devices and configurations at once.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：响应式设计必须在多个设备和浏览器上测试，以确保兼容性和可用性。这可能包括物理设备测试、模拟器和可以同时模拟许多不同设备和配置的在线网站。'
- en: Responsive design is essential in a web environment where users expect a seamless
    experience whether they’re on a phone, tablet, laptop, or desktop. For a web developer,
    understanding the principles of responsive design is crucial for creating web
    applications that are accessible and user-friendly across all devices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户期望无论在手机、平板电脑、笔记本电脑还是桌面上都能获得无缝体验的网页环境中，响应式设计至关重要。对于网页开发者来说，理解响应式设计的原则对于创建在所有设备上都易于访问和用户友好的网络应用程序至关重要。
- en: Demonstrating responsive design
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示响应式设计
- en: 'To demonstrate responsive design at a very simple level, take a look at this
    HTML page:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在非常简单的层面上展示响应式设计，请看这个HTML页面：
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To break it down, let’s look at the `<body>` content first. As you can see,
    it’s three `<div>` elements inside a single `<div>` element. The outer `<div>`
    element is assigned the `container` style class, while all three of the inner
    `<div>` elements have an inline style to give them a gray background color.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分解这个过程，让我们首先看看`<body>`内容。正如您所看到的，它是一个包含在单个`<div>`元素内的三个`<div>`元素。外部的`<div>`元素被分配了`container`样式类，而所有三个内部的`<div>`元素都有一个内联样式，以赋予它们灰色背景颜色。
- en: What we’re doing here is building a page that has three boxes of content. Maybe
    the first is a navigation menu, the second is the main content, and the third
    is probably for some ads (because it seems that every website in the world has
    to have ads today, unfortunately!). This is a pretty typical layout for a website.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是构建一个包含三个内容框的页面。也许第一个是导航菜单，第二个是主要内容，第三个可能是用于一些广告（因为似乎世界上每个网站今天都必须有广告，不幸的是！）这是一个相当典型的网站布局。
- en: 'Now, on a large screen, we want to show this content in three columns, as shown
    in *Figure 5**.9*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在大型屏幕上，我们希望将此内容以三列的形式显示，如图*图5.9*所示：
- en: '![Figure 5.9: Our web page in three columns](img/B18315_05_9.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9：我们的网页以三列布局](img/B18315_05_9.jpg)'
- en: 'Figure 5.9: Our web page in three columns'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：我们的网页以三列布局
- en: 'However, on a smaller device (specifically on a screen less than 600 pixels
    in width), we want this content to wrap so that all three boxes “stack” on top
    of one another, as you see in *Figure 5**.10*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在较小的设备上（特别是宽度小于600像素的屏幕上），我们希望此内容可以包裹，使得所有三个框“堆叠”在一起，如图*图5.10*所示：
- en: '![Figure 5.10: Our web page, now “stacked” so that the boxes are effectively
    rows now](img/B18315_05_10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10：我们的网页，现在“堆叠”使得框实际上变成了行](img/B18315_05_10.jpg)'
- en: 'Figure 5.10: Our web page, now “stacked” so that the boxes are effectively
    rows now'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：我们的网页，现在“堆叠”使得框实际上变成了行
- en: This will also happen as you resize the browser window on a large screen. As
    you make the window smaller, the content should automatically reflow as described
    and shown in *Figure 5**.10*, and I encourage you to actually do that now to see
    what happens.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在大型屏幕上调整浏览器窗口大小时，这也会发生。当你使窗口变小时，内容应自动重新布局，如图*图5.10*所示，我鼓励你现在实际操作一下，看看会发生什么。
- en: It’s the CSS that is responsible for this rearranging of the content, so let’s
    check that out now.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 是CSS负责这种内容的重新排列，所以现在让我们来看看。
- en: First, we have the `container` class definition, which is applied to our `<div>`
    element. This uses a CSS feature called `display` to `grid` tells the browser
    that the contents inside this `<div>` element should be laid out in a grid, meaning
    we’ll have some number of rows and columns inside it. Setting `grid-template-columns`
    specifies that we want columns, and the `repeat(3, 1fr)` value specifies that
    we want three columns of equal size. The `repeat()` statement allows us to specify
    styles across multiple elements, and the `fr` unit is a flexible unit that allows
    us to define what fraction of the total available space each column gets. So,
    `1fr` means each column, of which there will be three, should get one equal fraction
    of the total, so the browser will distribute the space evenly between them. Finally,
    the `gap` property simply tells the browser how much space, if any, to put between
    the columns. Altogether, this defines the grid layout we want our three boxes
    to use by default.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`container`类定义，它应用于我们的`<div>`元素。这使用了一个名为`display`的CSS特性来`grid`，告诉浏览器这个`<div>`元素内的内容应该以网格形式布局，这意味着我们将在其中有一些行和列。设置`grid-template-columns`指定我们想要列，而`repeat(3,
    1fr)`值指定我们想要三个大小相等的列。`repeat()`语句允许我们指定多个元素的风格，而`fr`单位是一个灵活的单位，允许我们定义每个列占总可用空间的多少。所以`1fr`意味着将有三个列，每个列应该获得总空间的一个相等部分，因此浏览器将在它们之间平均分配空间。最后，`gap`属性简单地告诉浏览器在列之间放置多少空间，如果有。总的来说，这定义了我们想要我们的三个框默认使用的网格布局。
- en: 'That’s the first part of the responsive equation. The second part is the `@media`
    statement, which is a `max-width` part. So, in other words, the style inside this
    media query will only be applied when the width of the browser window is less
    than `600` pixels. This means we’re defining a `600` pixels: we want the layout
    of the page – the `<div>` container, more specifically – to change when we hit
    `600` pixels wide.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是响应式方程的第一部分。第二部分是`@media`语句，它是一个`max-width`部分。换句话说，这个媒体查询内的样式只会在浏览器窗口宽度小于`600`像素时应用。这意味着我们定义了一个`600`像素的宽度：我们希望页面的布局——更具体地说——`<div>`容器——在我们达到`600`像素宽时改变。
- en: Below 600 pixels, the style applied to the `<div>` container overrides the `grid-template-columns`
    value defined in the `container` class itself, setting it to `1fr`. Since `repeat()`
    is not used this time, we’ll wind up with just a single column, and `1fr` now
    means one fraction of the total space should be allotted to it, but since there’s
    just one column, all the space is used up by it, which causes the boxes inside
    to wrap underneath each other.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在600像素以下，应用于`<div>`容器的样式会覆盖`container`类本身定义的`grid-template-columns`值，将其设置为`1fr`。由于这次没有使用`repeat()`，我们将只得到一个列，而`1fr`现在意味着总空间中的一份应该分配给它，但由于只有一个列，所有空间都被它占用，这导致盒子内部相互包裹。
- en: You can define as many breakpoints as you like, and you can use media queries
    to apply styles based on other conditions, but when it comes to responsive design,
    it’s nearly always going to be widths such as this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义尽可能多的断点，并且你可以使用媒体查询根据其他条件应用样式，但谈到响应式设计，几乎总是要使用这样的宽度。
- en: Progressing with progressive enhancement
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐进增强的进展
- en: Another factor that plays into whether a website is accessible or not can depend
    on things beyond your control, such as the capabilities of the browser and even
    a user’s connectivity. We’ve discussed that many users use smaller devices such
    as phones to access sites these days, which will sometimes mean less powerful
    browsers. And even when the browsers are full-featured, imagine the scenario where
    a user is trying to access a site while riding on a train. In such a case, their
    connection speed may be considerably slower than at home and may not be stable
    either.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 网站是否可访问还可能受到超出你控制范围的因素影响，例如浏览器的功能甚至用户的连接性。我们讨论过，如今许多用户使用手机等小型设备来访问网站，这有时意味着浏览器功能较弱。即使浏览器功能齐全，想象一下用户在乘坐火车时尝试访问网站的场景。在这种情况下，他们的连接速度可能比在家时慢得多，而且可能也不稳定。
- en: These sorts of concerns are where an approach to web development called **progressive
    enhancement** comes into play. This is the theory that you should start from a
    bare-bones design and then enhance it when accessed based on factors such as connection
    speed and browser capabilities.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的担忧正是被称为**渐进增强**的网页开发方法发挥作用的地方。这是这样一个理论：你应该从一个骨架设计开始，然后在根据连接速度和浏览器功能等因素访问时对其进行增强。
- en: 'A simple example might begin with this simple markup:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子可能从以下简单的标记开始：
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That’s a complete, functional – albeit extremely simple – website, perhaps
    to allow a user to subscribe to your newsletter. It will work fine in virtually
    any browser on any device. However, what if we want to ensure the email address
    is in a valid form? That’s easy to do with JS, but what if the browser doesn’t
    support JS at all or the user disables it? What we need is a way to ensure that
    the page will work even without JS but will work *better* when JS *is* available.
    This is where progressive enhancement comes into play (this is the `progressive.html`
    file in the `ch-5` directory):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整、功能性的——尽管非常简单——网站，可能允许用户订阅你的通讯。它几乎在任何设备上的任何浏览器上都能正常工作。然而，如果我们想确保电子邮件地址是有效的形式呢？这用JS很容易做到，但如果浏览器根本不支持JS或者用户禁用了它怎么办？我们需要确保页面即使在没有JS的情况下也能工作，但在JS可用时工作得更好。这正是渐进增强发挥作用的地方（这是`ch-5`目录中的`progressive.html`文件）：
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, what happens is that when the page fully loads, the `<script>` block executes.
    In it, we get a reference to the form using `document.getElementById()`, and then
    call `addEventListener()` on the DOM node returned. This adds an event listener
    function for the form’s `submit` event, which fires when the user clicks the `email`
    field. It then checks to see if it includes an `@` sign. While this is definitely
    not a complete test of email address validity, it’s good enough for this simple
    example. If no `@` sign is present, then an error message is shown in the `myDiv`
    `<div>` element. Finally, the call to `event.preventDefault()` stops the form
    submission from occurring (the `event` object passed into the function contains
    all information about the event the function is called in response to – the form
    submission, in this case – and provides some functions to work with it, including
    the `preventDefault()` function to terminate whatever the default action would
    be, which in this case is sending the form to the server).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当页面完全加载时，`<script>`块会执行。在其中，我们通过`document.getElementById()`获取表单的引用，然后对返回的DOM节点调用`addEventListener()`。这为表单的`submit`事件添加了一个事件监听函数，当用户点击`email`字段时触发。然后它会检查是否包含`@`符号。虽然这绝对不是对电子邮件地址有效性的完整测试，但对于这个简单的例子来说已经足够好了。如果没有`@`符号，那么在`myDiv`
    `<div>`元素中会显示错误消息。最后，调用`event.preventDefault()`阻止表单提交（传递给函数的`event`对象包含函数被调用的所有事件信息——在这个例子中是表单提交，并提供了一些与之交互的函数，包括`preventDefault()`函数来终止默认操作，在这个例子中就是将表单发送到服务器）。
- en: This is a good thing to do because when you can catch simple errors such as
    this in the browser without having to involve the server, that’s a more efficient
    approach. But, since browsers will ignore what they don’t understand, which would
    include the `<script>` block if JS isn’t available, there’s no harm in it being
    present. If JS isn’t available, then you still have a functional form (and one
    presumes the email address will be checked for validity on the server). But when
    JS *is* available, the page is enhanced to do the email address validation in
    the browser. That’s the basic idea of progressive enhancement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事，因为当你可以在不涉及服务器的情况下在浏览器中捕获像这样的简单错误时，这是一种更有效的方法。但是，由于浏览器会忽略它们不理解的内容，包括如果JS不可用时的`<script>`块，所以它存在是没有害处的。如果JS不可用，那么你仍然有一个功能性的表单（并且假设电子邮件地址将在服务器上进行有效性检查）。但是当JS可用时，页面会增强以在浏览器中进行电子邮件地址验证。这就是渐进增强的基本理念。
- en: Responsive design is effectively a form of progressive enhancement in that the
    display can change based on the size of the screen, providing functionality for
    all users. Both responsive design and progressive enhancement play into accessibility
    because the very idea of accessibility is to make a site accessible. If the form
    submission *depended* on the JS working, then the page would be broken when JS
    isn’t available, and hence it wouldn’t be accessible to those users. By progressively
    enhancing, we ensure everything works in roughly the same way regardless.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式设计实际上是一种渐进增强的形式，因为显示可以根据屏幕大小进行变化，为所有用户提供功能。响应式设计和渐进增强都涉及到可访问性，因为可访问性的基本理念就是使网站可访问。如果表单提交*依赖于*JS的运行，那么当JS不可用时，页面就会损坏，因此这些用户无法访问。通过渐进增强，我们确保一切大致以相同的方式工作。
- en: The idea of progressive enhancement also starts down the path to something else
    called **Progressive Web Apps** (**PWAs**), which is what we’ll talk about now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强的理念也引出了另一个被称为**渐进式Web应用**（**PWAs**）的概念，这正是我们现在要讨论的内容。
- en: PWAs
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PWAs
- en: 'All the ideas discussed so far lead to one final frontend topic: **PWAs**.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的所有想法都引出了一个最终的前端主题：**PWAs**。
- en: 'PWAs are a way to write more advanced websites – web applications, really –
    by using common web technologies such as HTML, CSS, and JS (which may or may not
    use various libraries, which you’ll explore in the next chapter). They are intended
    to work on any platform that uses a standards-compliant web browser. PWAs have
    several defining features and benefits:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: PWAs是一种通过使用常见的Web技术（如HTML、CSS和JS，这些技术可能或可能不使用各种库，你将在下一章中探索它们）来编写更高级的网站——实际上是Web应用的方式。它们旨在在任何使用标准兼容Web浏览器的平台上运行。PWAs具有几个定义性的特性和优势：
- en: '**Responsive**: PWAs should fit any form factor, be it desktop, mobile, tablet,
    or device that hasn’t even been developed yet or is in the early days (virtual
    reality, anyone?)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：PWAs应适应任何形态，无论是桌面、移动、平板，还是尚未开发或处于早期阶段的设备（比如虚拟现实设备？）'
- en: '**Progressive enhancement**: The core functionality of the app should work
    for every user no matter what their browser and OS capabilities are, but then
    progressive enhancement is used to provide a better experience for users with
    more capable platforms.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进式增强**：应用程序的核心功能应该适用于所有用户，无论他们的浏览器和操作系统功能如何，但随后使用渐进式增强为功能更强大的平台上的用户提供更好的体验。'
- en: '**Connectivity independent**: Using a special bit of JS code called a **service
    worker**, PWAs can work even when the user is offline. This is accomplished by
    storing resources (HTML, CSS, JS, images, and more) on the client and using those
    stored – known as **cached** – versions when the user can’t connect to the network.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接独立性**：使用一个名为**服务工作者**的特殊JS代码片段，PWA即使在用户离线时也能工作。这是通过在客户端存储资源（HTML、CSS、JS、图片等）并在用户无法连接到网络时使用这些存储的版本（称为**缓存**）来实现的。'
- en: '**An app-like feel**: PWAs often feel more like desktop apps (native apps,
    we call them) rather than websites. This comes about due to things such as alerts
    appearing like others generated by the OS, the ability to use hardware devices
    that generally aren’t usable on a website, and more complex interactions (multiple
    windows, for example).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类似应用的体验**：PWA（渐进式Web应用）常常给人一种更像桌面应用（我们称之为原生应用）而不是网站的感觉。这主要是因为像操作系统生成的其他警报一样出现的警报、能够使用通常在网站上无法使用的硬件设备，以及更复杂的交互（例如多窗口）等因素。'
- en: '**Fresh**: While service workers allow for offline access, they also provide
    a mechanism by which to update those cached resources when online. This ensures
    the PWA has the latest code and therefore appears *fresh* to the user.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新鲜感**：虽然服务工作者允许离线访问，但它们还提供了一种机制，在在线时更新那些缓存的资源。这确保了PWA拥有最新的代码，因此对用户来说看起来是*新鲜的*。'
- en: '**Safe**: PWAs can only be served via HTTPS connections. This prevents snooping
    and ensures content hasn’t been tampered with.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：PWA只能通过HTTPS连接提供服务。这防止了窃听并确保内容未被篡改。'
- en: '**Discoverable**: Thanks to some special configuration files you must provide
    when building a PWA, they are identified as an application, not merely a website,
    to the browser and the OS. This is what allows them to be installed.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可发现性**：由于在构建PWA时必须提供一些特殊的配置文件，因此浏览器和操作系统将它们识别为应用程序，而不仅仅是网站。这正是它们能够被安装的原因。'
- en: '**Installable**: Users can add apps to their home screen on their phone, or
    their desktop/start menu on a PC or Mac, without the hassle of going through an
    app store. Simply going to a URL like any other website, as long as the website
    provides a few necessary pieces (service worker and a configuration file called
    a manifest file, mainly), is enough for the browser and OS to treat it as an installable
    app, much like any other app you might install.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可安装性**：用户可以在他们的手机主屏幕上添加应用程序，或者在PC或Mac的桌面/开始菜单上添加，而无需通过应用商店。只需像访问任何其他网站一样访问一个URL，只要网站提供一些必要的组件（服务工作者和一个名为清单文件的配置文件，主要是），浏览器和操作系统就会将其视为可安装的应用程序，就像你可能安装的任何其他应用程序一样。'
- en: '**Linkable**: Since a PWA is fundamentally still a website – just one with
    more capabilities – it means it is easily shared via a URL and does not require
    complex installation. Typically, visiting a website that is set up to be a PWA
    will trigger a request asking if you want to install it. After that, it appears
    like any other installed app on your phone or computer.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可链接性**：由于PWA本质上仍然是一个网站——只是功能更强大——这意味着它可以通过URL轻松共享，无需复杂的安装。通常，访问设置为PWA的网站将触发一个请求，询问你是否想要安装它。之后，它看起来就像你手机或电脑上安装的任何其他应用程序一样。'
- en: For a software developer, building a PWA involves creating a responsive web
    application that includes a manifest file and a service worker – the manifest
    file provides information about the application (such as name, author, icon, and
    description) to the browser, and the service worker enables features such as push
    notifications, background data sync, and offline functionality via caching and
    updating of resources. PWAs bridge the gap between web applications and native
    applications, offering the UX and capabilities of native apps with the reach and
    accessibility of the web.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于软件开发者来说，构建PWA涉及创建一个响应式Web应用程序，该应用程序包括一个清单文件和一个服务工作者——清单文件向浏览器提供有关应用程序的信息（例如名称、作者、图标和描述），而服务工作者通过缓存和更新资源来启用推送通知、后台数据同步和离线功能等特性。PWA弥合了Web应用和原生应用之间的差距，提供了原生应用的UX和功能，以及Web的覆盖范围和可访问性。
- en: Building a PWA isn’t fundamentally complex, but it does involve a few steps
    that can be tricky, especially when dealing with the need to work over HTTPS only.
    Because of this, I’m not going to demonstrate building one here as it’s definitely
    a more advanced topic. While PWAs are fairly popular these days, they aren’t universally
    supported, nor are they something you definitely need to know. In fact, you may
    never need to build one at all. If you do, though, this section should have laid
    the groundwork for understanding the basics, and you can explore it at a later
    time, when and if you need to.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个PWA（渐进式Web应用）并不复杂，但它确实涉及一些可能很棘手的步骤，尤其是在处理仅需要通过HTTPS工作的需求时。正因为如此，我这里不会演示如何构建一个，因为这绝对是一个更高级的话题。虽然PWA在当今相当流行，但它们并不被普遍支持，也不是你绝对需要知道的东西。实际上，你可能根本不需要构建一个。如果你需要，那么本节应该已经为你理解基础知识奠定了基础，你可以在需要的时候再进行探索。
- en: So, yes – ensuring your website looks good and follows good UX practices so
    that it is functional for your users is very important. Implementing responsive
    design is often a part of that, and using progressive concepts can also result
    in a more efficient experience for your users. PWAs are another potential level
    after that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的——确保你的网站看起来不错，遵循良好的用户体验（UX）实践，以便对用户来说功能齐全，这一点非常重要。实现响应式设计通常是其中的一部分，使用渐进式概念也可以为用户提供更高效的使用体验。PWA（渐进式Web应用）是之后的另一个潜在层次。
- en: But none of that would much matter if you don’t put your website somewhere that
    can be accessed by those users. While that can be as easy as dropping your code
    onto a physical server, in this day and age, that’s not necessarily the best answer.
    Plus, best or not, it’s for sure not the *only* answer. Along these lines, another
    concept that plays into deploying a website is virtualization, by way of VMs and
    containers, and that’s the next topic up for discussion!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你没有将你的网站放在那些用户可以访问的地方，那么这一切都不会很重要。虽然这可以简单到将你的代码放在一个物理服务器上，但在当今这个时代，这并不一定是最好的答案。而且，不管怎样，这绝对不是*唯一*的答案。沿着这个思路，另一个在部署网站时起到作用的观念是虚拟化，通过虚拟机（VMs）和容器来实现，这正是接下来要讨论的主题！
- en: Virtualizing the world – VMs and containers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化世界——虚拟机和容器
- en: In the last chapter, you played around with Linux a bit via some online Linux
    playgrounds (you *did* do that, right?). Did you stop for a second and wonder
    how those sites pulled that off? You were essentially logging in to a machine
    running Linux, but surely there couldn’t be a physical server for every user who
    might be doing the same thing at the same time, could there? In all likelihood,
    the answer is no. Instead, they most probably used either a VM or a container
    to pull off that magic.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你通过一些在线Linux沙盒（你*确实*做了那件事，对吧？）对Linux进行了一些操作。你是否停下来想过这些网站是如何做到这一点的？你实际上是在登录一个运行Linux的机器，但肯定不可能为每个可能同时进行相同操作的用户都有一个物理服务器，对吧？很可能答案是否定的。相反，他们最可能使用虚拟机或容器来实现这一神奇的功能。
- en: '**VMs and containers** are two different but related technologies used to create
    efficient, isolated environments for running applications. They both have the
    same basic goal, which is to virtualize an environment.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机（VMs）和容器**是两种不同但相关的技术，用于创建高效、隔离的应用程序运行环境。它们都有相同的基本目标，即虚拟化一个环境。'
- en: But what does *virtualize* mean? To explain that, you have to think about how
    a computer normally works.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但“虚拟化”是什么意思？为了解释这一点，你必须考虑计算机通常是如何工作的。
- en: Normally, you have some hardware – obviously, things such as motherboards, CPUs,
    memory, various buses for components to communicate over, and so on. This is all
    physical stuff – electronics and all that.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你有一些硬件——显然，像主板、CPU、内存、各种用于组件之间通信的总线等。这些都是物理的东西——电子和所有这些。
- en: Then, on top of the hardware, you have an operating system or OS. It might be
    Windows, or maybe Linux, or perhaps macOS, and so on. Sharp-eyed readers may realize
    there is also something called *firmware*, which is software that is permanently
    embedded in the hardware. You can kind of think of that as part of the hardware,
    though, since that’s where it lives. For the most part, it’s the hardware plus
    the software in the form of an OS, and of course, then all the applications that
    run on top of that, which is more software.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在硬件之上，你有一个操作系统或OS。它可能是Windows，也可能是Linux，或者可能是macOS等等。敏锐的读者可能会意识到还有一个叫做*固件*的东西，这是一种永久嵌入在硬件中的软件。你可以把它看作是硬件的一部分，因为这就是它所在的地方。大部分情况下，它是硬件加上以操作系统形式存在的软件，当然，然后是所有在之上运行的应用程序，这又是更多的软件。
- en: So now, **virtualizing** in essence means to take all of that – the hardware,
    software/firmware, all of it – and simulate it in a computer. Through some very
    clever coding, it is possible to simulate a computer, all the way down to the
    hardware, in software. How that works is *way* beyond the scope of this book,
    but fortunately, it doesn’t really matter either! We can simply be happy that
    such magic exists.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**虚拟化**本质上意味着将所有这些——硬件、软件/固件，所有的一切——都在计算机中模拟出来。通过一些非常巧妙的编码，我们可以在软件中模拟出一个计算机，甚至可以模拟到硬件层面。这种工作原理远远超出了本书的范围，但幸运的是，这实际上并不重要！我们只需简单地为此魔法存在而感到高兴。
- en: The benefit to this, probably the biggest one anyway, is this virtualized computer
    – which is completely separate from the computer it’s running on (typically called
    the *host*). If you create a file on the host, usually, it won’t be accessible
    from a virtualized computer running on it and vice versa. If you install some
    piece of software on a virtualized computer, it has no impact on the host. It’s
    literally as if you have two different computers; they are isolated from one another.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的好处，可能也是最大的好处，就是这种虚拟化计算机——它与运行它的计算机（通常称为*宿主*）完全分离。如果你在宿主机上创建一个文件，通常情况下，它无法从运行在虚拟机上的计算机中访问，反之亦然。如果你在虚拟机上安装了一些软件，它对宿主机没有任何影响。这实际上就像你有两台不同的计算机；它们彼此隔离。
- en: There is more than one way to virtualize a computer such as this, and two of
    the most common are VMs and containers. These strive to achieve the same basic
    goal – simulating a computer inside of another – but they differ significantly
    in their approach and architecture. Let’s talk about both now, see how they compare
    and how they differ, and why we might choose one over another.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化这种计算机的方式不止一种，其中两种最常见的是虚拟机和容器。它们都力求实现相同的基本目标——在另一个计算机内部模拟计算机——但它们在方法和架构上存在显著差异。现在让我们来谈谈这两种，看看它们如何比较和不同，以及为什么我们可能选择其中一种而不是另一种。
- en: Understanding VMs
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解虚拟机（VMs）
- en: A VM is really what I was just describing. Architecturally, a VM includes not
    only the application and necessary binaries and libraries to supply the functionality
    a user might want but also an entire OS, which we typically call the *guest*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机正是我刚才描述的。从架构上看，虚拟机不仅包括应用程序和提供用户可能需要的功能的必要二进制文件和库，还包括一个完整的操作系统，我们通常称之为*客户机*。
- en: A VM runs on a physical server and is managed by a **hypervisor**, such as VMware’s
    ESXi, Microsoft’s Hyper-V, or Oracle’s VirtualBox. The hypervisor is simply a
    program that manages VMs, managing things such as their access to the underlying
    physical hardware. Since it’s possible to run multiple VMs on one physical machine,
    and since those machines will at some level need to use and share the real physical
    hardware, the hypervisor manages that sharing and ensures there are no conflicts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机运行在物理服务器上，并由**虚拟化程序**（如VMware的ESXi、Microsoft的Hyper-V或Oracle的VirtualBox）管理。虚拟化程序实际上是一个管理虚拟机的程序，管理诸如它们对底层物理硬件的访问等问题。由于一个物理机上可以运行多个虚拟机，并且这些机器在某种程度上需要使用和共享真实的物理硬件，因此虚拟化程序管理这种共享并确保没有冲突。
- en: 'VMs are ideal for running applications that require a full OS, for ensuring
    complete isolation, or when running applications on different OS types. For example,
    if you usually use a Windows machine but want to play with Linux, you can create
    a VM using your favorite version of Linux, which will then appear as a separate
    window, as you can see in *Figure 5**.11*. You can then install software in Linux,
    completely separate from your Windows host:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机非常适合运行需要完整操作系统（OS）的应用程序，确保完全隔离，或者在不同类型的操作系统上运行应用程序。例如，如果你通常使用Windows机器，但想尝试Linux，你可以使用你喜欢的Linux版本创建一个虚拟机，它将作为一个独立的窗口出现，正如你可以在*图5.11*中看到的那样。然后你可以在Linux中安装软件，完全独立于你的Windows宿主机：
- en: '![Figure 5.11: Ubuntu Linux running in a VirtualBox VM on top of Windows 11](img/B18315_05_11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11：在Windows 11上运行在VirtualBox虚拟机中的Ubuntu Linux](img/B18315_05_11.jpg)'
- en: 'Figure 5.11: Ubuntu Linux running in a VirtualBox VM on top of Windows 11'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：在Windows 11上运行在VirtualBox虚拟机中的Ubuntu Linux
- en: VMs are very compatible and as such can run almost any OS you like. In fact,
    you can even run older OSs that wouldn’t work on your physical machine anymore,
    which provides a solution for running legacy applications, or applications requiring
    specific OS environments that you wouldn’t normally want to run on your computer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机非常兼容，因此可以运行你喜欢的几乎所有操作系统。实际上，你甚至可以运行那些在你的物理机上不再工作的旧操作系统，这为运行遗留应用程序或需要特定操作系统环境的应用程序提供了解决方案，而你通常不希望将这些应用程序运行在你的计算机上。
- en: Each VM has its own set of virtual hardware (CPUs, memory, disks, and so on),
    including storage devices, which are in effect carved out from your physical storage.
    This leads to potentially higher storage requirements on your host. For example,
    if you have a 500 GB hard drive in your computer and you want to create a Linux
    VM with a 100 GB hard drive, this means you lose 100 GB of your physical hard
    drive to the VM.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟机都有自己的虚拟硬件集合（CPU、内存、硬盘等），包括存储设备，实际上是从你的物理存储中划分出来的。这可能导致宿主机上更高的存储需求。例如，如果你的计算机中有一个500GB的硬盘，你想要创建一个具有100GB硬盘的Linux虚拟机，这意味着你将失去100GB的物理硬盘空间给虚拟机。
- en: VMs require more management overhead due to the need to support separate OSs
    and virtual hardware configurations. Remember – you in effect have more than one
    computer to deal with now! When you first create a VM, it is “naked,” meaning
    that it’s just like having a physical computer with nothing on it yet. You will
    then have to install the OS yourself (which means you’ll need a proper license
    for it). Later, when updates need to be done, you’ll need to do that yourself,
    on top of any you might have to do on your host machine. It’s just more management
    you need to do, just like having two physical machines.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机由于需要支持独立的操作系统和虚拟硬件配置，因此需要更多的管理开销。记住——你现在实际上要处理不止一台计算机了！当你第一次创建虚拟机时，它是“裸机”的，这意味着它就像一台没有任何东西的物理计算机。然后你必须自己安装操作系统（这意味着你需要为其获取适当的许可证）。稍后，当需要更新时，你需要在你的宿主机上执行这些操作，这还包括你可能需要执行的任何其他操作。这仅仅是需要你进行更多的管理，就像拥有两台物理机器一样。
- en: VMs nowadays provide excellent performance, which is a bit surprising given
    they are simulating a full computer, often down to the hardware level. There are
    a lot of tricks played to make this happen, things such as effective sharing of
    the physical hardware. But however it’s done, on a sufficiently powerful host
    machine, you should notice only small performance differences in the guest. In
    fact, if you maximize the window a VM is running in, you should find that it’s
    fairly tough to tell it isn’t the physical machine at that point.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的虚拟机提供了出色的性能，考虑到它们正在模拟一个完整的计算机，甚至到硬件级别，这有点令人惊讶。为了实现这一点，有很多技巧被使用，比如有效共享物理硬件。但不管怎样，在足够强大的宿主机上，你应该只会注意到在客户机上的微小性能差异。事实上，如果你最大化一个虚拟机运行的窗口，你应该会发现很难判断它此时不是物理机器。
- en: Let’s now set up a Ubuntu Linux VM inside VirtualBox to play around with.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在VirtualBox中设置一个Ubuntu Linux虚拟机，以便进行实验。
- en: Using VMs
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟机
- en: 'As per the *Technical requirements* section of the chapter, you should already
    have VirtualBox installed, and you should have downloaded a copy of Ubuntu Linux.
    Now, to set up a VM in VirtualBox, click the **Machine** menu, then the **New**
    button. You should get a dialog like what is shown in *Figure 5**.12*, where you
    can enter a name, select a folder to store all the VM files in, and select the
    right type and version (**Linux** and **Ubuntu** respectively, most likely the
    64-bit version of Ubuntu specifically):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章的*技术要求*部分，你应该已经安装了VirtualBox，并且应该已经下载了Ubuntu Linux的副本。现在，要在VirtualBox中设置虚拟机，点击**机器**菜单，然后点击**新建**按钮。你应该会看到一个类似于*图5.12*所示的对话框，在那里你可以输入一个名称，选择一个文件夹来存储所有虚拟机文件，并选择正确的类型和版本（**Linux**和**Ubuntu**，很可能是Ubuntu的64位版本）：
- en: '![Figure 5.12: Setting up Ubuntu in VirtualBox](img/B18315_05_12.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12：在VirtualBox中设置Ubuntu](img/B18315_05_12.jpg)'
- en: 'Figure 5.12: Setting up Ubuntu in VirtualBox'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：在VirtualBox中设置Ubuntu
- en: 'You’ll then need to tell VirtualBox to use the VDI file you downloaded. **VDI**
    stands for **Virtual Disk Image**, and it is a file that stores the contents of
    a storage device, like a hard drive, right down to the byte level, so it’s an
    exact byte-for-byte copy of that device. To do that, click on the **Hard Disk**
    section at the bottom, select **Use an Existing Virtual Hard Disk File**, then
    click the icon next to the dropdown that says **Empty** in it. You’ll then see
    the dialog shown in *Figure 5**.13*. Click **Add** and add the VDI file you downloaded
    earlier. Make sure it’s highlighted, then click **Choose**:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要告诉VirtualBox使用你下载的VDI文件。**VDI**代表**虚拟磁盘镜像**，它是一个存储存储设备内容的文件，如硬盘，直到字节级别，因此它是该设备的精确字节复制。为此，点击底部的**硬盘**部分，选择**使用现有的虚拟硬盘文件**，然后点击下拉菜单旁边的图标，该菜单中显示为**空**。然后你会看到*图5.13*所示的对话框。点击**添加**并添加你之前下载的VDI文件。确保它被高亮显示，然后点击**选择**：
- en: '![Figure 5.13: Adding the VDI to VirtualBox](img/B18315_05_13.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13：将VDI添加到VirtualBox](img/B18315_05_13.jpg)'
- en: 'Figure 5.13: Adding the VDI to VirtualBox'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：将VDI添加到VirtualBox
- en: That dialog will close, and you’ll be back on the one from *Figure 5**.12*.
    All the default values there should be fine, so you can simply click **Finish**.
    You now have a Ubuntu VM!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那个对话框将会关闭，你将回到*图5.12*的对话框。那里的所有默认值都应该没问题，所以你可以直接点击**完成**。你现在有一个Ubuntu虚拟机了！
- en: All you need to do now is click the `osboxes.org`). As you play around, realize
    that it’s just like you’re connected to a different computer in that window, which
    of course is the whole point of a VM. You can run various applications and install
    new ones – anything you can do on a real computer can be done in this VM.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要点击`osboxes.org`)。当你尝试时，你会意识到，这就像你在那个窗口中连接到了另一台不同的计算机一样，这当然是虚拟机的全部意义。你可以运行各种应用程序并安装新的应用程序——你可以在真实计算机上做的任何事情都可以在这个虚拟机中完成。
- en: As I mentioned earlier, though, VMs are just one way to skin the virtualization
    cat. Another extremely popular way is containers, so let’s look at them now.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，虚拟机只是虚拟化猫皮的一种方式。另一种极其流行的方式是容器，所以现在让我们来看看它们。
- en: Understanding containers
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解容器
- en: Containers differ from VMs in that they are not simulations of whole computers,
    though you can be fooled into thinking they are. In many cases, you can log in
    to a container and do everything inside of it that you could in a VM or a physical
    machine. They pull this off by isolating what’s inside the container and what’s
    outside on the host at a low level in the host OS.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 容器与虚拟机不同，因为它们不是整个计算机的模拟，尽管你可能会被误导以为它们是。在许多情况下，你可以登录到容器中，并在其中做所有在虚拟机或物理机器上能做的事情。它们通过在宿主操作系统的底层隔离容器内部和宿主外部的内容来实现这一点。
- en: '**Containers** are primarily a Linux facility as they depend on certain low-level
    capabilities in the Linux kernel (the core code that the entire Linux OS is built
    on top of). You can run containers on Windows too, but the way it’s done there
    is actually by using a Linux VM in a way transparent to you!'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**主要是一个Linux设施，因为它们依赖于Linux内核中某些底层功能（整个Linux操作系统构建在其之上的核心代码）。你也可以在Windows上运行容器，但那里实际上是通过使用一个对你来说透明的Linux虚拟机来实现的！'
- en: But, regardless, the basic architecture of a container is that containers package
    together an application and its dependencies (things such as libraries, binaries,
    and so on) but share the OS kernel of the host system. Whereas the kernel is simulated
    inside a VM, a container uses the actual kernel that the host OS is in.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论如何，容器的基本架构是这样的：容器将应用程序及其依赖项（如库、二进制文件等）打包在一起，但共享宿主系统的操作系统内核。而内核在虚拟机内部是模拟的，而容器使用的是宿主操作系统实际运行的内核。
- en: Just as with VMs, containers are isolated from the host OS, despite the fact
    that they share the kernel and other system resources. The OS itself takes care
    of that isolation automatically, so from our user perspective, it looks like a
    VM, which of course looks like a physical machine.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像虚拟机一样，容器虽然共享内核和其他系统资源，但它们与宿主操作系统是隔离的。操作系统本身会自动处理这种隔离，所以从我们的用户角度来看，它看起来像是一个虚拟机，而虚拟机当然看起来像一台物理机器。
- en: 'Containers have a couple of benefits over VMs:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容器相对于虚拟机有几个优点：
- en: First, because they aren’t simulating a full machine, they are noticeably faster.
    This is especially apparent during startup. Whereas a VM has to go through a full
    OS boot cycle just like a real computer, a container does not, and so they tend
    to start pretty much instantly. They also use considerably fewer host resources
    since, again, they aren’t simulating a whole computer.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，因为它们没有模拟整个机器，所以它们明显更快。这在启动时尤为明显。虚拟机必须像真实计算机一样经历完整的操作系统启动周期，而容器则不需要，因此它们几乎可以立即启动。它们还使用较少的宿主资源，因为，再次强调，它们没有模拟整个计算机。
- en: Second, containers provide a more consistent environment. Think about earlier
    chapters where we talked about being able to give a developer a `package.json`
    file, which they can then run `npm install` with and get all the dependencies
    your application needs. That is indeed handy, but what happens if they have a
    different version of Node installed than you do? And what if that version happens
    to have a bug that yours doesn’t? That developer may find that your project doesn’t
    work on their machine but does on yours. Containers solve this by bundling up
    not only your code and its dependencies but even things such as Node. If you give
    that developer a container instead, you can ensure their environment matches yours,
    so you know your code will work.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，容器提供了一个更一致的环境。想想我们之前章节中提到的，能够给开发者一个`package.json`文件，他们可以使用它运行`npm install`来获取应用程序需要的所有依赖项。这确实很方便，但如果他们安装的Node版本与您不同怎么办？而且如果那个版本恰好有一个您没有的bug怎么办？那个开发者可能会发现，您的项目在他的机器上无法工作，但在您的机器上可以工作。容器通过捆绑您的代码及其依赖项，甚至包括Node这样的东西来解决这个问题。如果您给那个开发者一个容器，您就可以确保他们的环境与您的环境匹配，这样您就可以知道您的代码将能够工作。
- en: Containers are a general term for what is a function of the operating system.
    But you won’t usually be interacting with this function directly because it is,
    to put it mildly, not a pleasant experience. Instead, you’ll almost certainly
    use some sort of software that is a wrapper around that function. The most popular
    such wrapper today by far is called Docker. In fact, it’s so popular that people
    will usually call them *Docker containers* rather than just containers. Let’s
    talk about containers under Docker a bit now and see them in action!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个通用的术语，指的是操作系统的功能。但您通常不会直接与这个功能交互，因为它，用温和的话说，不是一个愉快的体验。相反，您几乎肯定会使用某种软件，这种软件是围绕该功能的包装。目前最受欢迎的这种包装软件是Docker。事实上，它如此受欢迎，以至于人们通常称之为*Docker容器*而不是仅仅容器。现在让我们就Docker下的容器进行一些讨论，并看看它们在实际中的应用！
- en: Using containers
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器
- en: To play with containers, we’re actually going to use your brand-new Ubuntu VM!
    You see, since containers require Linux, and since I don’t know what OS you’re
    using normally, I can at least be sure you have Ubuntu running in VirtualBox at
    this point, so I know you have a Linux machine available, albeit a virtual one!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了玩转容器，我们实际上将使用您全新的Ubuntu虚拟机（VM）！您看，由于容器需要Linux，而且我不知道您通常使用什么操作系统，我至少可以确信您在这个时候在VirtualBox中运行了Ubuntu，这样我知道您有一个可用的Linux机器，尽管是虚拟的！
- en: 'The first thing you’ll need to do, inside your VM, is launch the Terminal application.
    This gets you to a command prompt. Next, you’ll need to install Docker with this
    command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟机（VM）内部，您首先需要启动终端应用程序。这将带您进入命令提示符。接下来，您需要使用以下命令安装Docker：
- en: '[PRE4]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Confirm the installation when prompted, and then give it a minute or two, depending
    on your internet connection speed. Once it’s done, execute this command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示确认安装时，请确认，然后根据您的网络连接速度，等待一分钟左右。一旦安装完成，执行以下命令：
- en: '[PRE5]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should be prompted with the help documentation. Now, you are ready to start
    a container!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到帮助文档的提示。现在，您已经准备好启动容器了！
- en: 'As is customary when talking about seemingly anything in programming, we’ll
    start by spinning up a “Hello, World!” container. As luck would have it, Docker
    Hub, which is a website that is a public image repository run by the company behind
    Docker, has just such an image available! We can pull the image down to our local
    machine and use it to create a container, all with one simple command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论编程中的任何看似相关内容时的惯例，我们将从启动一个“Hello, World!”容器开始。幸运的是，Docker Hub，这是一个由Docker背后的公司运营的公共镜像仓库网站，恰好有这样一个镜像可供使用！我们可以将镜像拉取到本地机器上，并使用它来创建一个容器，这一切都只需要一个简单的命令：
- en: '[PRE6]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Go ahead and execute that, and after a couple of seconds, you should see something
    like *Figure 5**.14* greet you:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行该命令，几秒钟后，您应该会看到类似*图5.14*的界面欢迎您：
- en: '![Figure 5.14: Your very first Docker container!](img/B18315_05_14.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14：您的第一个Docker容器！](img/B18315_05_14.jpg)'
- en: 'Figure 5.14: Your very first Docker container!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：您的第一个Docker容器！
- en: What actually happens is that, first, Docker will look for an image named `hello-world`
    on your system. When you create a container, you always start from a blueprint
    known as an image. The image almost always begins with an operating system and
    then has stuff added on top of it, building up to the final image. You can think
    of an image as a snapshot of an OS filesystem at a given point in time, but it’s
    not a snapshot of your host OS; it’s a snapshot of the result of a series of steps
    used to build up the image layer by layer as if you were executing the commands
    yourself. Docker then takes that image and creates a container from it. You can
    have multiple containers running based on a single image if you wish, just like
    you can have multiple houses built from the same blueprint.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是，首先，Docker 将在您的系统上寻找名为 `hello-world` 的镜像。当您创建一个容器时，您始终从一个称为镜像的蓝图开始。镜像几乎总是从一个操作系统开始，然后在其上添加一些内容，最终形成最终的镜像。您可以将镜像视为在特定时间点的操作系统文件系统的快照，但它不是您宿主操作系统的快照；它是构建镜像层层的步骤结果的快照，就像您亲自执行这些命令一样。然后
    Docker 从该镜像创建一个容器。如果您愿意，可以基于单个镜像运行多个容器，就像您可以从相同的蓝图建造多座房屋一样。
- en: If the specified image isn’t present on your system yet, Docker will call out
    to Docker Hub and look for an image with the name you requested and download it
    if found (or give you an error if it’s not). From that point on, new containers
    can be spawned from that image without requesting anything from Docker Hub again.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的镜像尚未存在于您的系统上，Docker 将调用 Docker Hub 并寻找您请求的名称的镜像，如果找到（或者如果您没有找到，则给出错误）。从那时起，新的容器可以基于该镜像创建，而无需再次从
    Docker Hub 请求。
- en: Now that you’ve created your first container, let’s take a very brief look at
    some of the most common commands you might need to work with containers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了第一个容器，让我们简要地看看一些您可能需要与容器一起使用的最常见命令。
- en: Learning basic Docker commands
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习基本的 Docker 命令
- en: The `docker` program is your interface into Docker itself, and it provides many
    different commands to control Docker. Let’s take a look at some.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` 程序是您进入 Docker 本身的接口，它提供了许多不同的命令来控制 Docker。让我们看看一些例子。'
- en: Listing images
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出镜像
- en: 'How can you tell what images and containers there are available on your system?
    Well, that’s easy:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何知道系统上有哪些可用的镜像和容器？嗯，这很简单：
- en: '[PRE7]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That will list all the images previously downloaded onto your system from which
    you can create containers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出之前下载到您系统上的所有镜像，您可以从这些镜像创建容器。
- en: Listing containers
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出容器
- en: 'For listing containers, it’s just as easy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列出容器，同样简单：
- en: '[PRE8]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modeled on the Linux `ps` command, this command shows your containers, but it
    only shows you running containers. After the `hello-world` container finishes
    its work, it shuts down immediately. Therefore, you won’t see it running with
    this command. Other containers will continue running and so will show up with
    this command; it all depends on what the container is meant to do.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Linux 的 `ps` 命令建模，此命令显示您的容器，但它只显示正在运行的容器。`hello-world` 容器完成工作后，会立即关闭。因此，您不会看到它通过此命令运行。其他容器将继续运行，并且会通过此命令显示；这完全取决于容器打算做什么。
- en: 'However, the container still exists in a sense, and you can see it by adding
    an option to the previous command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，容器在某种意义上仍然存在，您可以通过在之前的命令中添加一个选项来查看它：
- en: '[PRE9]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Starting (and stopping) containers
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动（和停止）容器
- en: 'You could start a container again if you want by running the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想再次启动容器，可以运行以下命令：
- en: '[PRE10]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this `hello-world` container, however, nothing will happen when you do this,
    and the container will exit at once. It only seems to show that helpful information
    when initially run.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这个 `hello-world` 容器，当您这样做时，将不会发生任何事，容器会立即退出。它似乎只在初次运行时显示有用的信息。
- en: 'You can also stop a running container with this command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用此命令停止正在运行的容器：
- en: '[PRE11]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a quick aside, at this point, you may realize that entering the container
    IDs that Docker generates can get annoying in a hurry (and, plus, you’ve seen
    me write `<container_id_or_name>`, implying you can do something other than using
    the default ID). Fortunately, Docker also generates a name for each container,
    as you can see in the `ps` output (and it can often be quite entertaining to see
    what it spits out!). However, it’s more user-friendly to give it a name yourself,
    which you can do with the following option:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小插曲，此时你可能意识到，快速输入Docker生成的容器ID可能会变得很烦人（而且，此外，你也看到我写过`<container_id_or_name>`，这意味着你可以做些除了使用默认ID之外的事情）。幸运的是，Docker还为每个容器生成一个名称，正如你在`ps`输出中看到的那样（而且看到它吐出什么内容通常很有趣！）。然而，自己给它起个名字会更友好，你可以使用以下选项：
- en: '[PRE12]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, you should see a container with the specified name, which you can then
    use to interact with it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到一个指定名称的容器，然后你可以用它来与之交互。
- en: You should also be aware that when using the ID, you can enter a partial ID,
    starting from the beginning and entering enough to be unique. The first few characters
    are usually sufficient. In my opinion, though, providing a name is the overall
    better and easier approach as you have less chance of accidentally doing something
    to the wrong container (in theory, at least!).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该意识到，当使用ID时，你可以输入部分ID，从开头开始输入足够多的字符以使其唯一。前几个字符通常就足够了。然而，在我看来，提供名称是更好的、更简单的方法，因为你不太可能不小心对错误的容器做了什么（至少在理论上是这样！）。
- en: Removing containers and images
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除容器和镜像
- en: 'You’ll probably want to clean up those containers at some point, and there’s
    a command for that:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在某个时候清理这些容器，为此有一个命令：
- en: '[PRE13]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the container is running, Docker won’t let you remove it until you stop
    it. Likewise, you can remove images like so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器正在运行，Docker不会让你删除它，直到你停止它。同样，你可以这样删除镜像：
- en: '[PRE14]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with containers, Docker won’t allow you to remove an image that’s used by
    a container, regardless of whether it’s running or not, so you’ll need to clean
    up the containers first.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就像容器一样，Docker不会允许你删除被容器使用的镜像，无论它是否正在运行，所以你需要先清理容器。
- en: Searching for images
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索镜像
- en: 'While I think it’s much easier to go to Docker Hub through the web to look
    for images, which you can do at [https://hub.docker.com](https://hub.docker.com),
    you also can search for an image directly from the command line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我认为通过网页访问Docker Hub查找镜像要容易得多，你可以在[https://hub.docker.com](https://hub.docker.com)做到这一点，但你也可以直接从命令行搜索镜像：
- en: '[PRE15]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This returns a list of many images that include the `hello-world` string in
    their name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回一个包含`hello-world`字符串的许多镜像的列表。
- en: Attaching to a container
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到容器
- en: 'Sometimes, you’ll want to treat containers like VMs and log in to them, assuming
    it’s one that keeps running. To show that, we’ll need a container that will continue
    running, so let’s use `nginx` for that:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想将容器当作虚拟机来对待，并登录到它们，假设它是一个持续运行的容器。为了展示这一点，我们需要一个会持续运行的容器，所以让我们使用`nginx`：
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-d` option “detaches” the terminal session from the container, which causes
    it to run in the background (assuming whatever is inside the container doesn’t
    exit immediately). You’ll be returned to your command prompt, but the container
    will continue to run. The `-p` option is for exposing network ports. Here, we’re
    saying that port `8080` inside the container should be exposed as port `80` on
    the host machine’s network interface.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`选项“断开”了终端会话与容器的连接，这导致它在后台运行（假设容器内部的内容不会立即退出）。你将返回到命令提示符，但容器将继续运行。`-p`选项用于暴露网络端口。在这里，我们说的是容器内部的`8080`端口应该暴露为主机网络接口上的`80`端口。'
- en: Once you execute this command, do `sudo docker ps`, and you should see a running
    container for the first time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行此命令，执行`sudo docker ps`，你应该会看到第一次运行的容器。
- en: 'Now, with a container running, we can go ahead and attach to it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个容器正在运行，我们可以继续连接到它：
- en: '[PRE17]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you can see a few things. First, the `-i` option keeps the system’s `STDIN`
    input stream open so that it can be interacted with. The `-t` option allocates
    a new pseudo-tty terminal session (for all intents and purposes, this means a
    Linux command prompt). `/bin/bash` at the end is a command that is executed after
    the container is started, in this case specifying a Linux `bash` command prompt.
    All three combined result in you being “inside” the container.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一些东西。首先，`-i`选项保持系统的`STDIN`输入流打开，以便与之交互。`-t`选项分配一个新的伪终端会话（从本质上讲，这意味着一个Linux命令提示符）。最后的`/bin/bash`是一个在容器启动后执行的命令，在这种情况下指定了一个Linux
    `bash`命令提示符。这三个选项的组合意味着你“进入”了容器。
- en: The command prompt you see at that point is the command prompt inside the container
    itself. Go ahead and do some `bash`-y stuff (for example, `ls`), and you should
    notice that what you see differs from your host operating system (though if you’re
    using Ubuntu, then it’s going to look very similar anyway). Execute the `exit`
    command, and you’ll be dropped back to your actual host VM’s command prompt.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的命令提示符是容器内部的命令提示符。你可以执行一些`bash`命令（例如，`ls`），你应该会注意到你所看到的内容与你的宿主操作系统不同（尽管如果你使用的是Ubuntu，那么看起来可能非常相似）。执行`exit`命令，你将返回到实际的宿主虚拟机的命令提示符。
- en: Viewing container logs
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看容器日志
- en: 'Finally, without attaching to a container, you can view the logs produced inside
    of it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使没有连接到容器，你也可以查看容器内部产生的日志：
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, “logs” include anything routed to standard out, barring any specific configuration
    done inside the container.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“日志”包括任何被路由到标准输出的内容，除非容器内部进行了特定的配置。
- en: Now that you have some idea what VMs and containers are all about, let’s look
    at the key differences between them and the questions to ask yourself when deciding
    which is appropriate to use.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对虚拟机（VMs）和容器（containers）有了大概的了解，让我们来看看它们之间的关键区别，以及在你决定使用哪一种时需要问自己的问题。
- en: Key differences between VMs and containers and choosing between them
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟机和容器之间的关键区别以及如何选择
- en: 'There are several differences between VMs and containers that will often factor
    into deciding which to use:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机和容器之间有几个区别，这些区别通常会影响决定使用哪一种：
- en: '**Performance**: Containers are generally faster and more resource-efficient
    than VMs. This is definitely true when thinking about how fast they start up,
    but it’s also true when they are running. Remember – a VM is simulating an entire
    computer while containers aren’t, and that simulation costs processor time and
    memory utilization on the host machine, all of which can impact the performance
    of the VM *and* the host.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：容器通常比虚拟机更快、更高效。在考虑它们启动速度时这一点无疑是正确的，但它们运行时也是如此。记住——虚拟机是在模拟整个计算机，而容器不是，这种模拟会消耗宿主机的处理器时间和内存利用率，所有这些都会影响虚拟机和宿主机的性能。'
- en: '**Overhead**: In a sense, this is another aspect of performance, but it’s different
    enough to call out. VMs have more overhead in terms of CPU, memory, storage, and
    other system resources, due to the need for a full OS in each instance. Containers
    are sharing the resources of the host more directly, so while they certainly do
    have some degree of overhead, it tends to be a lot lower than VMs.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开销**：在某种程度上，这是性能的另一个方面，但它足够不同，值得单独指出。由于每个实例都需要完整的操作系统，虚拟机在CPU、内存、存储和其他系统资源方面有更多的开销。容器更直接地共享宿主机的资源，因此虽然它们确实有一定的开销，但通常比虚拟机低得多。'
- en: '**Portability**: Containers are highly portable across different machines,
    as long as they run the same OS kernel. In other words, the files inside a container
    have to work with the kernel in the host machine, and as long as they do, then
    a container can run on any machine. With a VM, this isn’t the case, which means
    they are even *more* portable than containers since you can run a Windows VM on
    a Linux host, a macOS VM on a Windows host, or any other combination you want.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**：容器在不同机器之间具有高度的便携性，只要它们运行相同的操作系统内核。换句话说，容器内的文件必须与宿主机的内核兼容，只要它们兼容，容器就可以在任何机器上运行。对于虚拟机来说，情况并非如此，这意味着它们比容器更具便携性，因为你可以在一个Linux宿主机上运行Windows虚拟机，在一个Windows宿主机上运行macOS虚拟机，或者任何你想要的组合。'
- en: '**Security**: VMs offer more isolation, which can be beneficial for security,
    while containers offer enough isolation for most purposes but require careful
    management to ensure security. The complete isolation of VMs can provide a more
    secure environment, as one VM’s compromise doesn’t directly threaten others. Given
    that containers share the host OS’s kernel, it should be obvious that there is
    at least some possibility of security issues, and vulnerabilities in the kernel
    itself can potentially affect all containers. However, in practice, as long as
    you have an up-to-date host machine, and as long as your containers are configured
    properly, they are quite safe from a security standpoint.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：虚拟机提供了更多的隔离，这可以有益于安全性，而容器在大多数情况下提供了足够的隔离，但需要谨慎管理以确保安全性。虚拟机的完全隔离可以提供一个更安全的环境，因为一个虚拟机的妥协不会直接威胁到其他虚拟机。鉴于容器共享主机操作系统的内核，应该很明显，至少存在一些安全问题的可能性，内核本身的漏洞可能会影响所有容器。然而，在实践中，只要你的主机机器是最新的，并且你的容器配置得当，它们在安全方面相当安全。'
- en: '**Management and orchestration**: VMs are often managed with pretty advanced
    management tools such as VMware vCenter or Microsoft System Center, which provide
    for centralized management of many VMs. Containers tend to be managed more often
    from a command prompt, though there definitely are graphical management tools
    as well. VM management tools allow for easy deployment, control, and scaling of
    VMs. Scaling means that if a VM needs more resources, it can be expanded, often
    on the fly. With containers, the answer more often than not is simply to create
    more instances of a given container and balance work between them. This is called
    orchestration, and it’s where more advanced things such as Kubernetes come into
    play. This is a Google product that allows for more flexible control of containers
    – things such as grouping them more efficiently to handle load. It’s a very powerful
    tool, but it’s also quite a bit more complex than the containers themselves.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理和编排**：虚拟机通常使用相当高级的管理工具进行管理，例如VMware vCenter或Microsoft System Center，这些工具提供了对多个虚拟机的集中管理。容器通常更多地从命令提示符进行管理，尽管当然也有图形管理工具。虚拟机管理工具允许轻松部署、控制和扩展虚拟机。扩展意味着如果虚拟机需要更多资源，它可以在运行时进行扩展。对于容器，答案通常是简单地创建更多实例的特定容器，并在它们之间平衡工作。这被称为编排，这也是更高级的工具如Kubernetes发挥作用的地方。这是一个Google产品，它允许对容器进行更灵活的控制——例如更有效地分组以处理负载。这是一个非常强大的工具，但它也比容器本身复杂得多。'
- en: '**Rapid deployment and scaling**: I mentioned this in the previous bullet,
    but it’s an important point: because containers tend to start very fast and are
    more lightweight, containers can be started, stopped, and replicated quickly and
    easily, making them ideal for dynamic, scalable environments. VMs, by contrast,
    take longer to start and use more host resources. That means that for a given
    server, you can almost certainly run more containers than you can VMs, so if you
    start getting a lot of new users on your shiny new website, you can create more
    containers to handle traffic faster and easier and with fewer host requirements
    than with VMs.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速部署和扩展**：我在上一个要点中提到了这一点，但这是一个重要的观点：因为容器启动非常快且更轻量级，所以容器可以快速、轻松地启动、停止和复制，这使得它们非常适合动态、可扩展的环境。相比之下，虚拟机启动需要更长的时间，并且使用更多的主机资源。这意味着对于一台特定的服务器，你几乎肯定可以运行比虚拟机更多的容器，所以如果你在你的新网站上开始获得大量新用户，你可以创建更多的容器来更快、更轻松地处理流量，并且比使用虚拟机有更少的资源需求。'
- en: In summary, while there is certainly an overlap between VMs and containers,
    each has its unique strengths and weaknesses. VMs provide complete isolation with
    a full OS environment, making them suitable for applications that need a full
    OS or different OS types. But that makes them more heavyweight in terms of resource
    requirements.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，虽然虚拟机和容器之间确实存在重叠，但每个都有其独特的优势和劣势。虚拟机提供了完整的隔离和完整的操作系统环境，这使得它们适合需要完整操作系统或不同操作系统类型的应用程序。但这使得它们在资源需求方面更重。
- en: Containers, being lighter and more efficient since they are not a complete running
    OS, are ideal for applications where portability and quick scaling are important.
    I would go so far as to say that today, it’s usually safer to start from the assumption
    that you’ll use containers more often than a VM for deploying an app or website
    (if you’re not going to simply run your code on a server, that is, which we tend
    to call *bare metal*). Especially in cases where you expect that your load requirements
    (how many users are using your website) might increase rapidly, containers are
    usually the better option (VMs can scale as well, but it’s a less efficient process).
    On the other hand, if absolute security is your main concern, and/or complete
    isolation from anything else that might be running on the same physical machine,
    then a VM is a very good option.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 容器由于不是完整的运行操作系统，因此更轻便、更高效，对于需要便携性和快速扩展的应用程序来说非常理想。我甚至可以说，今天，通常更安全地假设你将比虚拟机更频繁地使用容器来部署应用程序或网站（如果你不是要在服务器上简单地运行代码，我们通常称之为*裸机*）。特别是在你预计你的负载需求（使用你网站的用户的数量）可能会迅速增加的情况下，容器通常是更好的选择（虚拟机也可以扩展，但过程效率较低）。另一方面，如果你主要关心绝对的安全性，并且/或者需要与同一物理机上可能运行的任何其他东西完全隔离，那么虚拟机是一个非常不错的选择。
- en: Now that you know a bit about containers and VMs, let’s talk about a place you
    may wind up running them (or just your “naked” application without VMs or containers
    at all), that being the cloud.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对容器和虚拟机有了一些了解，让我们谈谈你可能最终会运行它们的地方（或者只是运行“裸露”的应用程序，根本不使用虚拟机或容器），那就是云。
- en: Keeping your head in the clouds – cloud providers
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持头脑清醒——云服务提供商
- en: Some people like to be trite and say that the cloud just means running your
    code on someone else’s computer. And, I mean, it’s not *untrue*! But there’s much
    more to it than that.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人喜欢陈词滥调地说，云只是意味着在别人的电脑上运行你的代码。我的意思是，这并不*完全错误*！但其中还有更多。
- en: 'The **cloud** refers to cloud computing, which is the delivery of various services
    over the internet, including data storage, servers, databases, networking, and
    software (read: your websites and applications). Cloud computing allows for flexible
    resources (meaning you can get just what you need when you need it), faster innovation
    (since you don’t need to build and configure servers and services yourself), and
    economies of scale (since the costs of building the infrastructure behind the
    cloud are amortized across all the people using it). You typically pay only for
    the cloud services you use, helping lower operating costs, run infrastructure
    more efficiently, and scale as your business needs change.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**云**指的是云计算，它是指通过互联网提供各种服务，包括数据存储、服务器、数据库、网络和软件（即：你的网站和应用程序）。云计算允许灵活的资源（这意味着你可以在需要时获得所需的一切），更快的创新（因为你不需要自己构建和配置服务器和服务），以及规模经济（因为云背后的基础设施成本被分摊到所有使用它的人身上）。你通常只为使用的云服务付费，这有助于降低运营成本，更有效地运行基础设施，并根据业务需求的变化进行扩展。'
- en: Let’s say you *don’t* want to use the cloud. What that may mean is that you
    have to buy your own hardware, set it up, and configure the operating system and
    all the services on top of it (databases, mail services, user authentication services,
    web servers, and so on). Then, you have to put your code on it and run it, ensuring
    that the whole thing is secure. Then, if your website becomes super-popular and
    you start getting more traffic, you may then have to add hardware to expand the
    capacity or reconfigure the services to handle the added load. Eventually, you
    may have to add whole servers and configure networking in such a way that the
    load is balanced across them.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你*不想*使用云。这可能意味着你必须购买自己的硬件，设置它，并配置操作系统及其上的所有服务（数据库、邮件服务、用户身份验证服务、Web服务器等等）。然后，你必须将代码放在上面并运行它，确保整个系统是安全的。然后，如果你的网站变得非常受欢迎，开始获得更多流量，你可能需要添加硬件来扩展容量或重新配置服务以处理额外的负载。最终，你可能需要添加整个服务器，并配置网络以实现负载均衡。
- en: 'With the cloud, these sorts of concerns are automatic, or at least can be changed
    just by updating some settings on a control panel website offered by the cloud
    provider. You change some settings, click a button, and suddenly you have more
    memory, more bandwidth, and more CPU available to handle the expanded load. It’s
    a much easier thing to do. And the cost savings are significant: when you build
    your own server, you have to guess at the load, and it’s usually smart to over-purchase.
    If you think a server with a single 3 GHz CPU will be enough, you may want to
    buy a dual-processor machine up-front to have some headroom to grow. But, if you
    don’t grow, now you’ve effectively wasted money. With the cloud, you can add that
    second CPU when you see that you need it, so you’re not paying for one you don’t
    need or may not need for a while.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Introducing cloud providers
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many different cloud providers these days, but the biggest are **Amazon
    Web Services** (**AWS**), **Microsoft Azure**, and **Google Cloud Platform** (**GCP**).
    Oracle also has a fairly popular cloud offering, as does IBM and some other smaller
    players, but Amazon, Microsoft, and Google are definitely the big boys. Ultimately,
    though, they all have the same basic proposition: run your code on their infrastructure,
    using only what you need.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: It may be surprising to hear that the company that most people associate with
    the internet – Google – has a cloud offering that, it’s fair to say, isn’t quite
    as popular as AWS and Azure, which are the two most popular cloud providers as
    of this writing, almost without question. In fact, when someone talks about “the
    cloud” these days, they almost certainly mean one of those two providers. That’s
    how much larger they are than the rest in terms of usage and mindshare.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, though, all cloud providers offer a ton of different services,
    with a high degree of stability. Of course, that doesn’t come for free: using
    a public cloud can get rather expensive if you aren’t careful. It’s not at all
    difficult to find horror stories online of people waking up to huge AWS bills
    because their website got super-popular overnight. You definitely need to exercise
    caution when using them. Fortunately, all good cloud providers offer ways to control
    your spending. With AWS, for example, you can configure spending limits on your
    account so that you don’t get hit with a life-altering bill out of the blue.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s more than that, though: you have to think about whether the cloud is the
    right answer for a given use case at all. Sometimes, it more clearly is: when
    you know your load requirements will be highly variable, for example. Being able
    to use just the capacity you need is very appealing in such cases. Obviously,
    the complexity of setting up the various services cloud providers offer yourself
    can be overwhelming and very expensive in such cases.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes, having your own hardware is cheaper and simpler too, especially
    if you have a good idea of what your load will be over time. And if what you’re
    building doesn’t require most of what the cloud provides, then it might make more
    sense to do it yourself.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，拥有自己的硬件既便宜又简单，特别是如果你对未来的负载有很好的了解。而且如果你正在构建的东西不需要云提供的大部分功能，那么自己动手可能更有意义。
- en: It’s not simple calculus and many, many factors go into such a decision, many
    of which are very project-dependent. I’m not trying to supply a checklist to use
    for such a decision here because that would be a nigh-impossible task. Instead,
    I’m just trying to make the point that the decision to go to the cloud or not
    is one you’ll need to make with every project based on its unique requirements.
    There are certainly benefits to the cloud, but there are negatives too.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是简单的微积分，许多许多因素都会影响到这样的决策，其中许多因素与项目本身密切相关。我并不是试图提供一个用于此类决策的清单，因为这几乎是一项不可能完成的任务。相反，我只是想指出，是否选择云服务是一个你需要根据每个项目的独特需求来做出的决策。云服务当然有好处，但也有不利之处。
- en: Complicating matters more is that the cloud isn’t a single thing, regardless
    of whose cloud it is. There are effectively three types of clouds to be familiar
    with. Let’s talk about them now.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的是，云服务并不是单一的东西，无论它是谁的云。实际上，你需要熟悉三种类型的云。现在让我们来谈谈它们。
- en: Understanding cloud types
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解云类型
- en: 'The cloud can be public, private, or hybrid:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 云可以是公有、私有或混合：
- en: '**Public cloud**: These are cloud services offered over the public internet,
    available to anyone willing to pay. The public cloud is generally services such
    as AWS, Azure, and GCP. They run in data centers provided by, maintained by, and
    completely controlled by the providers.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公有云**：这些是通过公共互联网提供的云服务，对任何愿意付费的人开放。公有云通常包括AWS、Azure和GCP等服务。它们在由提供商提供、维护和完全控制的数据中心中运行。'
- en: '**Private cloud**: This is server infrastructure used exclusively by a single
    business or organization, making it available only to their internal development
    teams. This is typically done by larger companies who want or need a higher level
    of control over how things are done, especially in areas such as banking where
    regulations dictate a tighter level of control over sensitive data.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有云**：这是仅由单个企业或组织使用的服务器基础设施，使其仅对内部开发团队可用。这通常由那些希望或需要更高控制水平的大型公司完成，特别是在像银行这样的领域，监管机构规定了更严格的敏感数据控制水平。'
- en: '**Hybrid cloud**: Combines public and private clouds, bound together by technology
    allowing data and applications to be shared. Imagine running your website on your
    private cloud, but then having it connect to a database service in a public cloud
    in order to save some money (database software tends to be quite expensive at
    larger scales).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合云**：结合了公有云和私有云，通过技术手段实现数据和应用程序的共享。想象一下，在你的私有云上运行你的网站，然后通过连接到公有云中的数据库服务来节省一些费用（数据库软件在大规模上往往相当昂贵）。'
- en: And besides those three types, cloud services can break down into several key
    services too. Let’s look at just some of them now.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三种类型之外，云服务还可以细分为几个关键服务。现在让我们看看其中的一些。
- en: Recognizing key services
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别关键服务
- en: Cloud offerings come in many flavors, but they tend to come with names that
    end in “**aaS**,” which is short for “**as a Service**.” When you build a server
    yourself, and you need a database to run on it, you will need to install the database
    software and configure it. By contrast, **DataBase as a Service**, or **DBaaS**,
    is when a cloud provider offers preconfigured database services to you. You’ll
    still need to do some degree of configuration, of course, for your needs, but
    the basic database software is something you won’t have to worry about. From your
    perspective, it’s just a service you use, just like cable TV (uhh, does anyone
    actually still have cable TV?!)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务有多种类型，但它们往往以“**aaS**”结尾，这是“**as a Service**”的缩写。当你自己搭建服务器，并且需要在其上运行数据库时，你需要安装数据库软件并对其进行配置。相比之下，**数据库即服务**（**DBaaS**），是指云服务提供商为你提供预配置的数据库服务。当然，为了满足你的需求，你仍需要进行一定程度的配置，但基本的数据库软件是你不必担心的。从你的角度来看，它只是你使用的一项服务，就像有线电视（嗯，还有人在用有线电视吗？！）
- en: 'Some of the other “aaS” offerings you may meet – but definitely not all of
    them since there seems to be a new one every week – include the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的一些其他“aaS”服务——但肯定不是全部，因为似乎每周都会出现一个新的——包括以下内容：
- en: '**Infrastructure as a Service (IaaS)**: This is an offering of fundamental
    computing resources such as VMs, networking, and storage. An example of this is
    AWS **Elastic Compute Cloud** (**EC2**). This can largely be thought of as someone
    setting up a server for you, which you can then do what you want with.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即服务（IaaS）**：这是一种提供基本计算资源的服务，例如虚拟机（VM）、网络和存储。一个例子是AWS的**弹性计算云（EC2**）。这可以大致理解为有人为您设置服务器，然后您可以随心所欲地使用它。'
- en: '**Platform as a Service (PaaS)**: This provides hardware and software tools
    over the internet. It is conceptually a level above IaaS in that it normally will
    include things such as an operating system and software installed on top of that.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台即服务（PaaS）**：这项服务通过互联网提供硬件和软件工具。从概念上讲，它在IaaS之上，因为它通常包括操作系统以及安装在其上的软件。'
- en: '**Software as a Service (SaaS)**: This service delivers software applications
    over the internet, on a subscription basis. One example is Microsoft Office 365,
    where you can use all of Microsoft’s Office applications over the internet.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件即服务（SaaS）**：这项服务通过互联网以订阅方式提供软件应用程序。一个例子是微软的Office 365，您可以通过互联网使用微软的所有Office应用程序。'
- en: '**Containers as a Service (CaaS)**: This provides a runtime environment for
    containers of any type you wish to run.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器即服务（CaaS）**：这为运行任何类型容器的运行环境提供支持。'
- en: '**Disaster Recovery as a Service (DRaaS)**: This is a service that you can
    use to back up your important data and restore it as necessary.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灾难恢复即服务（DRaaS）**：这是一种可以用来备份您的重要数据并在必要时恢复它的服务。'
- en: As I said, there are a myriad of other “aaS” offerings, and each cloud provider
    will have different options available. To complicate matters, the various providers
    won’t even always agree on the terminology! For example, *CaaS* may not mean *Container
    as a Service* in one cloud provider versus another. That said, the ones in this
    list tend to be fairly consistent and are probably the ones you’ll see most often.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，还有许多其他的“aaS”服务，每个云服务提供商都将提供不同的选项。为了使问题复杂化，不同的提供商甚至不会总是对术语达成一致！例如，*CaaS*在不同的云服务提供商中可能并不总是指*容器即服务*。但话虽如此，这个列表中的服务通常相当一致，并且可能是您最常看到的服务。
- en: 'Names aside, when you use the cloud, you may use just one service, or you may
    use many. AWS, for example, has upward of 200 services available as of this writing.
    But that’s another advantage of the cloud: you can mix and match services however
    you need, adding and subtracting as you go. It’s the Burger King model: have it
    your way!'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不论名称如何，当您使用云服务时，您可能只使用一项服务，或者使用多项服务。例如，AWS在撰写本文时，有200多项服务可供使用。但这也是云服务的另一个优势：您可以按需混合匹配服务，在过程中添加和删除。这就是汉堡王模式：您想怎么来就怎么来！
- en: Cloud computing’s flexibility, combined with its capacity for innovation, makes
    it a cornerstone of modern IT infrastructure, essential for businesses to remain
    competitive and agile in a rapidly evolving digital landscape.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算的灵活性与其创新能力相结合，使其成为现代IT基础设施的基石，对于企业保持竞争力和敏捷性在快速发展的数字领域中至关重要。
- en: But you may not need the cloud at all. Well, sort of. Let’s talk about something
    called serverless.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能根本不需要云服务。好吧，差不多吧。让我们来谈谈所谓的无服务器技术。
- en: Who even needs the cloud or even servers? – Serverless
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁需要云服务甚至服务器？——无服务器
- en: A fairly recent development in software development is something called **serverless**.
    This is still really a cloud offering, but it’s a fair bit different than the
    usual cloud. Generally speaking, with any cloud offering, you have some software
    running all the time. If no one uses it, it’s still running, albeit at a very
    low level because clouds can scale operations down at such times to save resources
    and ultimately save you money.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发领域最近的一个发展是所谓的**无服务器**技术。这实际上仍然是一种云服务，但它与传统的云服务有很大的不同。一般来说，任何云服务都意味着有一些软件一直在运行。即使没有人使用它，它仍然在运行，尽管在非常低的水平上，因为云可以在这种情况下缩小操作规模以节省资源，并最终为您节省金钱。
- en: But, for some applications, you don’t even need that!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于某些应用程序来说，您甚至不需要这些服务！
- en: Imagine for a second that you want to write an application that can solve mathematical
    equations. Based on what you’ve learned so far, you can imagine creating a web
    page where you can enter a math equation and submit it to some server-side code
    to solve the equation and return the result. You can further imagine writing some
    Node code to do that work. And given what you’ve learned so far, you even have
    some idea what that might look like in terms of code, at least at a high level.
    Ultimately, you’re going to have a JS function that your Node server calls to
    solve the equation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你想编写一个可以解决数学方程式的应用程序。根据你到目前为止所学的内容，你可以想象创建一个网页，你可以输入一个数学方程式并将其提交给服务器端代码来解决方程式并返回结果。你可以进一步想象编写一些Node代码来完成这项工作。而且根据你到目前为止所学的内容，你甚至对代码的大致样子有一些了解，至少在高级层面上。最终，你将有一个JS函数，你的Node服务器会调用它来解决方程式。
- en: But what if I told you that there was a way to have just that function in the
    cloud and make it callable as if it were a server? Well, that’s exactly what serverless
    is!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我说有一种方法可以在云中实现这个功能，并且像服务器一样调用它，你会怎么想？嗯，这正是无服务器架构的精髓！
- en: Conceptually, you can think of serverless as a way to start that Node server
    only when a request comes in, let it call that function, return a result, and
    then immediately shut down. But that all happens so fast that you can’t even tell
    – it looks to you like the server is always running.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，你可以将无服务器架构视为仅在请求到来时启动Node服务器，让它调用该函数，返回结果，然后立即关闭。但这一切发生得如此之快，以至于你甚至感觉不到——对你来说，服务器似乎一直在运行。
- en: But, better still, while the code isn’t very complex, as you’ve seen, wouldn’t
    it be better if you didn’t even have to write the server code? Wouldn’t it be
    better if you only had to write the function that solves the equations?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，更好的是，虽然代码并不复杂，正如你所看到的，如果你甚至不需要编写服务器代码，那不是更好吗？如果你只需要编写解决方程式的函数，那不是更好吗？
- en: That’s serverless in a nutshell!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是无服务器架构的精髓！
- en: AWS Lambda is one such serverless service. With it, you can write functions,
    not just in JS but in a whole host of languages. These functions are then callable
    as if they were running on a server. Lambda takes care of all the plumbing, so
    to speak – all the code you would need to write yourself to make a server. You
    just focus on the logic needed and let Lambda take care of the rest. And, best
    of all, since there isn’t code running all the time awaiting requests, you aren’t
    paying anything if your functions aren’t being called. You’ll just pay when they’re
    called, based on how many resources they use. So, if you write fast, efficient
    code, it’ll cost you less to run them serverless.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda就是这样一种无服务器服务。使用它，你可以编写函数，不仅限于JS，还可以使用一系列其他语言。这些函数可以像在服务器上运行一样被调用。Lambda负责所有的基础设施，换句话说，就是所有你需要自己编写的服务器代码。你只需专注于所需的逻辑，让Lambda处理其余部分。而且，最好的是，由于没有代码一直在运行等待请求，如果你的函数没有被调用，你就不需要支付任何费用。只有在它们被调用时，你才会根据它们使用的资源数量支付费用。所以，如果你编写的是快速、高效的代码，那么运行无服务器架构的成本会更低。
- en: Of course, serverless isn’t a suitable model for all applications. But, for
    the ones where it makes sense, it can make *a lot* of sense.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，无服务器架构并不是所有应用程序都适用的模型。但是，对于那些适用的情况，它可以非常有意义。
- en: The cloud is an expansive topic and one you may or may not wind up needing to
    get deeper into, depending on your needs. But the last topic I want to touch on
    plays into almost everything we’ve discussed so far because whether you build
    your own server or use a cloud provider, you’re obviously going to need to do
    things such as build your code into a runnable form and deploy it, and all of
    that, and more, is the domain of DevOps.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 云是一个广泛的话题，你可能需要也可能不需要深入研究，这取决于你的需求。但我想讨论的最后一个话题几乎涵盖了我们之前讨论的所有内容，因为无论你是自己搭建服务器还是使用云服务提供商，你显然都需要做一些事情，比如将代码构建成可执行的形式并部署它，所有这些以及更多，都属于DevOps的范畴。
- en: Taking back control – DevOps
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复控制权 - DevOps
- en: The world of **Information Technology** (**IT**), of which web development is
    one part, is an interesting field in that technologies and approaches come and
    go all the time. What also tends to happen is we repeat ourselves! Someone has
    a good idea; it becomes popular but eventually is supplanted by something else.
    Then, somewhere down the road, someone has another good idea that becomes popular,
    but anyone who was around for the last good idea often realizes the new good idea
    is actually just the old good idea slightly updated and wrapped in new clothes!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 信息技术（IT）的世界，其中网络开发只是其中一部分，是一个有趣的领域，因为技术和方法总是来来去去。还经常发生的事情是我们重复自己！有人有一个好主意；它变得流行，但最终被其他东西取代。然后，在某个时候，有人又有了一个好主意变得流行，但那些经历过上一个好主意的人通常意识到新的好主意实际上只是旧的好主意略作更新并穿上新衣服！
- en: In the early days, developers did it all. We wrote the code, and then we were
    the ones who deployed it, meaning installed it onto the server it ran on (whether
    they were servers we built, servers provided by outside vendors, or the cloud).
    This was just part of the development process. We then worried about things such
    as monitoring a website for issues and dealing with those issues.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，开发者做所有的事情。我们编写代码，然后我们就是那些将其部署到服务器上的人，这意味着将其安装到运行它的服务器上（无论是我们自己建造的服务器，还是由外部供应商提供的服务器，或者是云服务器）。这只是开发过程的一部分。然后我们担心诸如监控网站问题并处理这些问题之类的事情。
- en: After a while, though, a lot of organizations started taking a different approach
    by separating out some of those duties and assigning them to groups other than
    developers, typically called the operations team. At that point, developers still
    wrote the code, but when it came time to deploy it, another group would do that.
    Things such as monitoring might be handled by an entirely different group, and
    dealing with issues that came up at least started with a specific support group
    (though developers still frequently had to get involved ultimately).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过了一段时间，许多组织开始采取不同的方法，通过将一些职责分离出来并分配给除了开发者之外的其他团队，通常称为运维团队。在那个阶段，开发者仍然编写代码，但在部署的时候，另一个团队会负责。像监控这样的任务可能由一个完全不同的团队处理，并且处理出现的问题至少从特定的支持团队开始（尽管开发者最终仍然经常需要介入）。
- en: Now, the pendulum is starting to swing the other way again in that developers
    commonly have a hand in deployments and support and all the other concerns that
    go into running a live website, so we’re repeating ourselves again, though with
    a few differences. The “new clothes” this time around is something called DevOps.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，摆锤又开始向另一边摆动了，因为开发者通常在部署和支持以及运行一个实时网站的所有其他关注点中都有所参与，所以我们又重复了自己，尽管有一些不同。这次“新衣服”是指一种叫做DevOps的东西。
- en: '**DevOps** is a set of practices that combines **software development** (**Dev**)
    and **IT operations** (**Ops**), aiming to shorten the development life cycle
    and provide continuous delivery of software of websites while still delivering
    high-quality output (generally meaning fewer bugs or other issues relative to
    the speed at which updates are delivered). DevOps is notable for its emphasis
    on collaboration, automation, and integration between software developers and
    IT professionals. It often involves tools for automating and streamlining the
    integration and deployment processes, aiming to improve and speed up delivery.
    This approach is particularly relevant in the context of agile software development,
    an approach where you build software in many phases that each deliver a part of
    the expected whole while allowing for changes as development progresses. It can
    significantly enhance the efficiency and quality of software production and maintenance
    as a result.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps** 是一套将软件开发（**Dev**）和IT运维（**Ops**）相结合的实践，旨在缩短开发周期并提供软件或网站的持续交付，同时仍然提供高质量的输出（通常意味着相对于更新速度，更少的错误或其他问题）。DevOps因其强调软件开发人员和IT专业人员之间的协作、自动化和集成而著称。它通常涉及自动化和简化集成和部署流程的工具，旨在提高和加快交付。这种方法在敏捷软件开发背景下尤其相关，这是一种在许多阶段构建软件的方法，每个阶段都交付预期整体的一部分，同时允许在开发过程中进行更改。它可以显著提高软件生产和维护的效率和品质。'
- en: Understanding the key aspects of DevOps
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解DevOps的关键方面
- en: 'There are several key points to DevOps at a high level:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，有几个关于DevOps的关键点：
- en: '**Culture shift**: DevOps emphasizes a shift in mindset, encouraging collaboration
    between development and operations teams. This breaks down silos and fosters a
    culture where building, testing, and releasing software happens rapidly, frequently,
    and more reliably.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文化转变**：DevOps 强调心态的转变，鼓励开发和运维团队之间的协作。这打破了隔阂，营造了一种快速、频繁且更可靠地构建、测试和发布软件的文化。'
- en: '**Automation**: DevOps relies heavily on automation to speed up software development
    and deployment processes. This includes code deployments, testing, infrastructure
    provisioning, monitoring, and more. Anything that can be automated and run with
    little or no human intervention is something DevOps will typically seek to do.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：DevOps 严重依赖自动化来加速软件开发和部署流程。这包括代码部署、测试、基础设施配置、监控等。任何可以自动化运行且几乎不需要人工干预的事情，DevOps
    通常都会寻求去实现。'
- en: '**Continuous Integration and Continuous Delivery (CI/CD)**: These are core
    practices in DevOps. **CI** refers to the process of automatically integrating
    code changes from multiple contributors into a single software project. **CD**
    is an extension of this, where the software can be released to production at any
    time. The basic idea is that as developers push code to Git, automation will see
    that new code and will build the software or website and deploy it to a test environment.
    Frequently, automated tests are run at that point, and developers are alerted
    to failures so that they can correct issues. If no issues are found, and if everything
    is configured for it, the new code can be deployed immediately to a production
    environment for end users to start using immediately.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成和持续交付 (CI/CD)**：这些是 DevOps 的核心实践。**CI** 指的是将来自多个贡献者的代码更改自动集成到单个软件项目中的过程。**CD**
    是这一过程的扩展，其中软件可以随时发布到生产环境。基本思想是，当开发者将代码推送到 Git 时，自动化会看到新的代码，并构建软件或网站，将其部署到测试环境。通常，此时会运行自动测试，开发者会收到失败的警报，以便他们可以纠正问题。如果没有发现任何问题，并且如果一切配置得当，新的代码可以立即部署到生产环境，供最终用户立即使用。'
- en: '**Monitoring and feedback**: Continuous monitoring of the application and its
    performance is crucial, especially with so much being automated and more rapid
    deployments being done. It helps in identifying issues early and helps improve
    the product in real time based on user feedback and system-level tests. For example,
    if new code is deployed and you have monitoring in place that alerts you to errors
    that begin happening, you can take action possibly even before users become aware
    that there is an issue.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和反馈**：对应用程序及其性能的持续监控至关重要，尤其是在大量自动化和快速部署的情况下。它有助于早期发现问题，并根据用户反馈和系统级测试实时改进产品。例如，如果部署了新的代码，并且你设置了监控来提醒你错误开始发生，你可以在用户意识到问题之前采取行动。'
- en: '**Tools and technologies**: DevOps in general, and CI/CD in particular, come
    with a host of new tools to make it all happen. Names such as Jenkins and GitLab
    come up, which are platforms for running what are called **pipelines**. A pipeline
    is really just a fancy way of saying some scripts that know how to build, test,
    and deploy your code automatically. Of course, containers play a large role in
    all of this. For example, a CI/CD pipeline to build and deploy your code may involve
    the pipeline automatically creating a container temporarily to do the build-in.
    Other products such as Ansible or Puppet are also often used. These are tools
    for managing the configuration of environments, often servers. For example, the
    CI/CD pipeline might execute an Ansible job, which handles ensuring the configuration
    of your production server meets the needs of your application. Getting into DevOps
    involves learning about many new tools and technologies beyond those needed to
    design websites and write code.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和技术**：一般来说，DevOps 以及特别是 CI/CD，都带来了一系列新的工具来使这一切成为可能。例如 Jenkins 和 GitLab
    这样的名字出现，它们是运行所谓的 **流水线** 的平台。流水线实际上只是指一些知道如何自动构建、测试和部署代码的脚本。当然，容器在所有这些过程中都扮演着重要角色。例如，构建和部署代码的
    CI/CD 流水线可能涉及流水线自动创建一个临时容器来进行构建。其他产品，如 Ansible 或 Puppet，也经常被使用。这些是用于管理环境配置的工具，通常是服务器。例如，CI/CD
    流水线可能会执行一个 Ansible 任务，该任务负责确保生产服务器的配置满足应用程序的需求。进入 DevOps 需要学习许多新的工具和技术，而不仅仅是设计网站和编写代码所需的那些。'
- en: '**Microservices architecture**: One way that many DevOps teams follow to make
    dealing with the code they manage easier is to adopt a microservices architecture.
    This is a way of building applications and websites that breaks them down into
    many smaller pieces, each providing a needed service to the larger application.
    For example, you may create a microservice that validates users during login.
    You may create another that handles registering new users. Rather than rolling
    both these services up as part of your website, you instead can deploy them as
    separate applications that the website then makes use of. This allows you to upgrade
    the registration service without touching the login validation service. This architecture
    is a natural fit for the DevOps approach because automating these smaller pieces
    tends to be easier. The trade-off is that making all the pieces work together
    can sometimes be challenging, and it does tend to make tracking down problems
    a bit more difficult. But, the benefits oftentimes outweigh any negatives, including
    the fact that you can scale up services individually to handle greater needs as
    they develop easier than trying to scale up a single large – **monolithic**, as
    they’re known – application. It can also help teams get features out faster since
    there is less risk in adding a new service or updating a single service without
    touching the code of another.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：许多DevOps团队为了使管理代码更容易，会采用微服务架构。这是一种构建应用程序和网站的方式，将它们分解成许多更小的部分，每个部分都为更大的应用程序提供所需的服务。例如，你可能会创建一个在登录时验证用户的微服务。你也可能创建另一个处理注册新用户的微服务。而不是将这两个服务作为网站的一部分进行打包，你相反可以部署它们作为独立的程序，然后网站再使用这些程序。这允许你在不触及登录验证服务的情况下升级注册服务。这种架构非常适合DevOps方法，因为自动化这些较小的部分通常更容易。权衡的是，让所有这些部分协同工作有时可能具有挑战性，并且确实会使追踪问题变得更加困难。但是，好处往往超过了任何负面影响，包括你可以更容易地扩展服务以应对不断增长的需求，而不是尝试扩展一个单一的大型——**单体**，正如它们所知——应用程序。它还可以帮助团队更快地推出功能，因为添加新服务或更新单个服务而不触及其他代码的风险更小。'
- en: Determining the benefits of DevOps (and some negatives)
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定DevOps的好处（以及一些负面影响）
- en: There are several benefits to DevOps.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps有几个好处。
- en: One is the ability to increase deployment frequency (since it’s all automated
    and in most cases will simply run faster than a human doing it). Teams that implement
    CI/CD pipelines will often release changes in days or weeks, while teams that
    don’t use a DevOps mindset may take weeks or months between releases. There are
    even some companies that deploy code daily, and that would be nearly impossible
    to do – assuming they want a stable product – without DevOps.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是增加部署频率的能力（因为一切都是自动化的，在大多数情况下会简单地比人工快得多）。实施CI/CD管道的团队通常会几天或几周内发布更改，而没有使用DevOps思维的团队可能需要几周或几个月才能发布。甚至有些公司每天部署代码，如果没有DevOps，这几乎是不可能的——假设他们想要一个稳定的产品。
- en: Faster **time to market** (**TTM**) is another key benefit. With everything
    automated, teams can focus more on writing code than worrying about how it will
    ultimately get deployed and run.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的**上市时间**（**TTM**）是另一个关键好处。由于一切自动化，团队可以更多地专注于编写代码，而不是担心代码最终如何部署和运行。
- en: DevOps also usually allows for a lower failure rate of new releases, at least
    when done properly. This is primarily because testing is usually built into CI/CD
    pipelines, and assuming the tests are robust enough, you can be fairly well assured
    that new code doesn’t break anything, and you can therefore have confidence releasing
    it faster.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps通常也能降低新版本发布的失败率，至少在正确实施的情况下是这样的。这主要是因为测试通常被集成到CI/CD管道中，并且假设测试足够稳健，你可以相当有信心地保证新代码不会破坏任何东西，因此你可以有信心更快地发布。
- en: In general, in your role as a web developer, you will likely find that DevOps
    practices not only streamline the development process but also enhance the overall
    quality and responsiveness of software maintenance and deployment.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，作为网络开发者的你可能会发现，DevOps实践不仅使开发过程更加流畅，而且还能提高软件维护和部署的整体质量和响应速度。
- en: Of course, few things in life are all unicorns and rainbows! Even the best of
    ideas tend to have some downside, and DevOps is no different.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，生活中很少有事情都是完美的！即使是最好的想法也往往有一些缺点，DevOps也不例外。
- en: It can become incredibly frustrating when your carefully developed automation
    suddenly fails. Maybe it relies on a service to compile code, for example, and
    maybe that service is down for some reason. All of a sudden, your pipelines fail,
    and maybe they don’t provide detailed enough error information to immediately
    see what the problem is. Perhaps the admins upgraded Jenkins, and the new version
    has a bug that breaks your pipeline in some very difficult-to-troubleshoot way.
    Or, maybe there are a lot of teams running pipelines at once, and all of a sudden,
    your pipeline takes 2 hours instead of 5 minutes. Maybe it’s simply difficult
    to write the pipeline script to work exactly the way you need because it has some
    limitations you discovered the hard way.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当你精心开发的自动化突然失败时，可能会非常令人沮丧。也许它依赖于一个编译代码的服务，而这个服务可能因为某些原因而宕机。突然之间，你的管道失败，也许它们没有提供足够详细的错误信息，以至于无法立即看到问题所在。也许管理员升级了Jenkins，新版本有一个导致你的管道在某些非常难以调试的方式中中断的bug。或者，也许有很多团队同时运行管道，突然之间，你的管道需要2小时而不是5分钟。也许仅仅是因为难以编写管道脚本以完全满足你的需求，因为它有一些你在艰难中发现限制。
- en: All of these are things I’ve run into in my work, and that’s just the tip of
    the iceberg.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在我的工作中遇到的事情，这只是冰山一角。
- en: As I alluded to earlier, the microservices architecture has many benefits, but
    troubleshooting them when something goes wrong is definitely not one of them.
    And matters get much worse when you have services maintained by several different
    teams. Now, not only do you have the difficulty of figuring out which service
    is at fault, but now you have to interface with that team and get them to correct
    the issue, and that isn’t always as smooth a situation as you might hope.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，微服务架构有很多好处，但出问题时进行故障排除绝对不是其中之一。当你有由几个不同团队维护的服务时，情况会变得更糟。现在，你不仅要弄清楚哪个服务出了问题，而且还要与那个团队接口，让他们纠正问题，而这并不总是像你希望的那样顺利。
- en: But, at the end of the day, most developers tend to agree that the benefits
    of DevOps far outweigh any negatives.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，最终，大多数开发者倾向于认为DevOps的好处远远超过了任何负面影响。
- en: 'Now that you have some insight into DevOps, let’s talk about a technology that
    is often used in the context of DevOps: Python.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对DevOps已经有了一些了解，让我们来谈谈在DevOps环境中经常使用的一种技术：Python。
- en: It’s not all about HTML, CSS, and JS – Python
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不仅仅是HTML、CSS和JS——Python
- en: '**Python** is a high-level, interpreted programming language known for its
    readability and simplicity. Developed by Guido van Rossum and first released in
    1991, Python has become one of the most popular programming languages in the world.
    Its key features include the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**是一种高级、解释型编程语言，以其可读性和简单性而闻名。由Guido van Rossum开发并于1991年首次发布，Python已成为世界上最受欢迎的编程语言之一。其关键特性包括以下内容：'
- en: '**Easy to learn**: Python has a straightforward syntax that is similar to the
    English language, which makes it easy for most people to pick up quickly'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于学习**：Python具有简单明了的语法，类似于英语语言，这使得大多数人可以快速掌握'
- en: '**Dynamic typing**: Variables can change their type based on the value assigned'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态类型**：变量可以根据分配的值改变其类型'
- en: '**Memory management**: Automatic memory management and garbage collection'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：自动内存管理和垃圾回收'
- en: '**Extensive standard library**: A large standard library with modules for various
    tasks'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广泛的标准库**：包含用于各种任务的模块的大标准库'
- en: '**Cross-platform**: Runs on multiple OSs such as Windows, macOS, and Linux'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：在多个操作系统上运行，如Windows、macOS和Linux'
- en: '**Interpreted**: Code is executed line by line, which makes debugging easier'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释型**：代码逐行执行，这使得调试更容易'
- en: '**Multiparadigm**: Supports object-oriented, imperative, and functional programming
    styles'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多范式**：支持面向对象、命令式和函数式编程风格'
- en: '**Extensibility**: Can be extended with C/C++ for performance-critical tasks'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：可以通过C/C++扩展以用于性能关键任务'
- en: '**Embeddable**: Can be embedded within C/C++ programs to give scripting capabilities'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可嵌入性**：可以嵌入到C/C++程序中以提供脚本功能'
- en: '**Community**: A large and active community supporting development and offering
    numerous modules and libraries'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区**：一个庞大且活跃的社区支持开发并提供众多模块和库'
- en: Python is used in various domains such as web development, data science, **artificial
    intelligence** (**AI**), **machine learning** (**ML**), networking, and more.
    Its frameworks such as Django and Flask are popular for web development, while
    libraries such as NumPy, Pandas, and TensorFlow are extensively used in scientific
    computing and AI.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Python 被用于各种领域，如网站开发、数据科学、**人工智能**（**AI**）、**机器学习**（**ML**）、网络等。其框架如 Django
    和 Flask 在网站开发中很受欢迎，而库如 NumPy、Pandas 和 TensorFlow 在科学计算和 AI 中被广泛使用。
- en: It’s also a popular language in the realm of DevOps. You’ll often find various
    scripts written in Python that are then executed from CI/CD pipelines or other
    automation tooling. It’s definitely not required for DevOps, and sometimes other
    languages and facilities are used in favor of it, but for sure it’s a popular
    option in DevOps circles.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 它也是 DevOps 领域中的一种流行语言。你经常会发现用 Python 编写的各种脚本，然后从 CI/CD 管道或其他自动化工具中执行。它绝对不是 DevOps
    的必需品，有时会使用其他语言和设施来代替它，但肯定在 DevOps 圈中是一个流行的选择。
- en: Let’s look at some basic Python example code, just to give you some idea of
    what it’s like.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些基本的 Python 示例代码，以便给你一些关于它是什么样的概念。
- en: Examining some simple Python
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查一些简单的 Python
- en: Python is an expansive language, at least as complex as JS, and probably more
    so, honestly. Entire books have been written about Python, so there’s no way I
    could possibly teach you everything about Python in one chapter. But I want to
    give you at least a taste of what it looks like and what it can do. To do this,
    I’m going to show you an admittedly contrived example of something you might write
    as part of a CI/CD pipeline for a website. I think, given your exposure to JS
    thus far, that you’ll find Python pretty understandable even without delving into
    the details of it, which is one of the reasons it’s become so popular.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种广泛的语言，至少和 JS 一样复杂，而且可能更复杂，说实话。关于 Python 已经有整本书的论述，所以不可能在一章中教你关于 Python
    的所有内容。但我至少想给你一些关于它的外观和功能的尝鲜。为此，我将向你展示一个承认是人为编造的例子，你可能会将其作为网站 CI/CD 管道的一部分来编写。我认为，鉴于你迄今为止对
    JS 的了解，即使不深入研究其细节，你也会觉得 Python 很容易理解，这也是它变得如此受欢迎的原因之一。
- en: 'So, take a look at the contents of the `build_and_deploy.py` file:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请查看 `build_and_deploy.py` 文件的内容：
- en: '[PRE19]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, a couple of libraries are imported for our Python script to use: the
    `os` and `shutil` libraries for working with the operating system and filesystem,
    and `datetime` so that we can get the current date and time.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入了一些库供我们的 Python 脚本使用：用于操作操作系统和文件系统的 `os` 和 `shutil` 库，以及 `datetime` 以便我们可以获取当前的日期和时间。
- en: Next, two functions named `make_index()` and `deploy()` are defined (that’s
    what the `def` keyword means in Python). The `make_index()` function writes a
    file named `index.html` into the `src` directory (the directory to write to is
    passed in as `source_path`), and `deploy()` is responsible for creating our final
    deployment directory (which, in this contrived example, we presume a web server
    uses to serve content).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义了两个名为 `make_index()` 和 `deploy()` 的函数（这就是 Python 中 `def` 关键字的意思）。`make_index()`
    函数将一个名为 `index.html` 的文件写入 `src` 目录（写入的目录作为 `source_path` 传入），而 `deploy()` 负责创建我们的最终部署目录（在这个人为编造的例子中，我们假设它是一个网络服务器用来提供内容的地方）。
- en: Inside `make_index()`, a variable named `current_time` is defined with a value
    returned to us by a call to the `datetime.datetime.now()` function, which is made
    available to us from the imported `datetime` library. The `strftime()` function
    allows us to specify the format of the date and time we want – in this case, a
    string in the form `YYYY-MM-FF HH:MM:SS` (so, for example, `2023-12-10 18:10:53`).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `make_index()` 函数内部，定义了一个名为 `current_time` 的变量，其值由 `datetime.datetime.now()`
    函数返回，该函数由导入的 `datetime` 库提供。`strftime()` 函数允许我们指定我们想要的日期和时间的格式——在这种情况下，是一个形式为
    `YYYY-MM-DD HH:MM:SS` 的字符串（例如，`2023-12-10 18:10:53`）。
- en: 'Next, another variable named `head` is defined that contains the HTML for the
    `<head>` section of our HTML document. In it, the `styles.css` file is imported,
    which you’ll find already exists in the `src` directory. The style configuration
    in it is simply `body { color : #ff0000; }` to make all the text in the `<body>`
    section red.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，定义了一个名为 `head` 的变量，它包含我们 HTML 文档 `<head>` 部分的 HTML。在其中，导入了 `styles.css`
    文件，你会在 `src` 目录中找到它。其中的样式配置很简单：`body { color : #ff0000; }`，使 `<body>` 部分中的所有文本都变为红色。'
- en: After that, the `index.html` file is written, and the value of `head` is inserted
    into it, giving us a proper `<head>` section in our HTML document. Because the
    string passed to the `file.write()` function that writes to the file is defined
    starting with `f"`, we can use replacement tokens inside, as with `{head}`. Python
    will insert the value of the `head` variable there for us. Another replacement
    token, `{current_time}`, does the same, so we’ll see the current date and time
    when the page is loaded (well, current as of when we built the site, that is).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将`index.html`文件写入，并将`head`的值插入其中，从而在我们的HTML文档中创建一个适当的`<head>`部分。因为写入文件的`file.write()`函数中传递的字符串是以`f"`开头的，所以我们可以在其中使用替换令牌，就像`{head}`一样。Python会自动将`head`变量的值插入其中。另一个替换令牌`{current_time}`也做同样的事情，因此当页面加载时（好吧，当我们构建网站时的当前时间），我们会看到当前的日期和时间。
- en: Finally, the `print()` statement echoes a status message to the console when
    we run the script.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们运行脚本时，`print()`语句会在控制台回显一个状态信息。
- en: Inside the `deploy()` function, it first checks to see if the site is already
    deployed by checking for the `live` directory, as specified in the `deploy_path`
    argument. If it does, then the `shutil.rmtree()` function is used to delete the
    directory, and a status message reflecting that is displayed via `print()`. Then,
    whether the directory was deleted or not, `shutil.copytree()` is used to create
    the deployment directory. More specifically, it copies the contents of the `src`
    directory – specified by the `source_path` argument – into the deployment directory.
    Finally, a status message is shown with `print()` again.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在`deploy()`函数内部，它首先检查网站是否已经通过检查`deploy_path`参数指定的`live`目录来确认是否已部署。如果是，则使用`shutil.rmtree()`函数来删除该目录，并通过`print()`函数显示相应的状态信息。然后，无论目录是否被删除，都会使用`shutil.copytree()`函数来创建部署目录。更具体地说，它会将`src`目录（由`source_path`参数指定）的内容复制到部署目录中。最后，再次使用`print()`函数显示状态信息。
- en: When you run this script, the execution actually begins down at the bottom where
    you see the comment, which is denoted by the line beginning with a hash symbol.
    First, the source and deployment directories are defined as the `source_path`
    and `deploy_path` variables. Then, `make_index()` is called, which results in
    the `index.html` file being written into the `src` directory. Finally, `deploy()`
    is called, which will ensure we have a brand new deployment directory named `live`,
    and in it will be the `index.html` and `styles.css` files. We now effectively
    have a full –albeit very simple – website in the `live` directory, and if a web
    server is pointed at that directory, the website will be available for visitors.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此脚本时，执行实际上是从你看到的注释下面的部分开始的，该注释以井号符号开始。首先，定义源目录和部署目录为`source_path`和`deploy_path`变量。然后调用`make_index()`，这将导致`index.html`文件被写入到`src`目录中。最后，调用`deploy()`，这将确保我们有一个全新的名为`live`的部署目录，其中包含`index.html`和`styles.css`文件。现在我们实际上在`live`目录中拥有一个完整的网站——尽管非常简单——如果Web服务器指向该目录，网站将对访客可用。
- en: 'Finally, to run the script, assuming you have Python installed, you simply
    execute this command at a command prompt:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了运行脚本，假设你已经安装了Python，你只需在命令提示符下执行此命令：
- en: '[PRE20]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `py` command should have been made available as a result of installing Python.
    Give it a shot!
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`py`命令应该在安装Python后可用。试一试！'
- en: As I mentioned earlier, there is a lot more to Python than this simple example
    shows. However, it demonstrates many of the key concepts, including variables,
    functions, libraries, comments, conditionals, and the basic structure of a Python
    script. And this example shows something that you might conceivably want to execute
    in a CI/CD pipeline. Imagine if this script is automatically executed every time
    you push new code to Git, which is something typically done with CI/CD pipelines.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，Python远不止这个简单示例所展示的。然而，它演示了许多关键概念，包括变量、函数、库、注释、条件和Python脚本的基本结构。而且这个示例展示了你可能在CI/CD管道中执行的内容。想象一下，如果每次你向Git推送新代码时，这个脚本都会自动执行，这是CI/CD管道通常执行的操作。
- en: With that, you could have your new code deployed to a live web server for all
    the world to see, all automatically. That’s the power of DevOps and Python together!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就可以将新代码自动部署到实时Web服务器上，供全世界的人查看。这就是DevOps和Python结合的力量！
- en: Reviewing the roadmap
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查路线图
- en: 'Ah, we’re moving right along, revealing squares like mad! Here’s the updated
    web developer roadmap:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，我们正迅速前进，揭示出无数的方块！这是更新的Web开发者路线图：
- en: '![Figure 5.15: The roadmap with a few more boxes filled in](img/B18315_05_15.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15：填入更多框的路线图](img/B18315_05_15.jpg)'
- en: 'Figure 5.15: The roadmap with a few more boxes filled in'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：填入更多框的路线图
- en: This time, you uncovered the **Graphic Design**, **DevOps**, **UX**, **Python**,
    **VMs and Containers**, and **Cloud Infrastructure** boxes. That was a big one!
    Let’s keep going, and before long, we’ll have them all revealed.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你揭开了**图形设计**、**DevOps**、**UX**、**Python**、**虚拟机和容器**以及**云基础设施**这些框。这是一个很大的进展！让我们继续前进，不久我们就会全部揭示它们。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered several unique areas. First, you looked at some
    frontend concerns, including graphic design, usability, and responsive design,
    to get a feel for why they’re important and how they benefit you in your web development
    journey. We then moved to the server side and talked about VMs and containers
    a bit to see how they are used to run your code. You then got a look at the cloud
    and learned what that’s about. Finally, we talked about DevOps a bit to understand
    how this popular approach to development enhances our ability to deliver quality
    code. As part of that discussion, you got a look at Python and played with it
    a little bit to see what it offers, especially as related to DevOps.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了几个独特的领域。首先，你查看了一些前端关注点，包括图形设计、可用性和响应式设计，以了解为什么它们很重要以及它们如何在你进行网页开发的过程中为你带来好处。然后，我们转向服务器端，简要讨论了虚拟机和容器，以了解它们是如何用来运行你的代码的。接着，你对云进行了了解，并学习了它是什么。最后，我们简要讨论了DevOps，以了解这种流行的开发方法如何增强我们交付高质量代码的能力。作为那次讨论的一部分，你了解了Python，并对其进行了小小的尝试，以了解它提供了什么，特别是与DevOps相关的内容。
- en: In the next chapter, we’ll jump back onto the frontend and focus on some of
    the biggest frameworks in use today, seeing how they provide you with a head start
    in your development and allow you to deliver more robust websites while reducing
    the effort to do so.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到前端，关注一些今天使用的一些最大的框架，看看它们如何为你提供开发上的优势，并允许你在减少努力的同时交付更健壮的网站。
