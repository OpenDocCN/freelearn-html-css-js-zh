<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Data Persistence through REST"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Data Persistence through REST</h1></div></div></div><p class="calibre7">Up to this point, we've been dealing with frontend aspects of Ember.js-powered applications. Your typical application will, however, need to connect to backend services such as databases. Ember.js makes this simple by integrating solutions for such needs. This chapter assumes no knowledge of server-side technologies, but it will attempt to explain any samples that contain server-side code as clearly as possible. Ensure that you also attempt the given exercises in order to understand the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Making Ajax requests</li><li class="listitem">Understanding Ember-data</li><li class="listitem">Creating data stores</li><li class="listitem">Defining models</li><li class="listitem">Declaring model relations</li><li class="listitem">Creating records</li><li class="listitem">Updating records</li><li class="listitem">Deleting records</li><li class="listitem">Persisting data</li><li class="listitem">Finding records</li><li class="listitem">Defining a store's adapter</li><li class="listitem">Creating REST APIs</li><li class="listitem">Customizing a store's serializer</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Data Persistence through REST">
<div class="book" title="Making Ajax requests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec88" class="calibre1"/>Making Ajax requests</h1></div></div></div><p class="calibre7">Most web <a id="id383" class="calibre1"/>applications communicate with backend services through either of the following technologies:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Web sockets</li><li class="listitem">Ajax</li></ul></div><p class="calibre7">This chapter will mainly deal with Ajax, which enables client applications to send asynchronous <a id="id384" class="calibre1"/>requests to remote services through the use of <code class="email">XMLHttpRequests</code>. Web sockets will be handled in a later chapter, but we'll find that many concepts used will be related. Here's an example of a <code class="email">POST</code> request to a music catalog endpoint:</p><div class="informalexample"><pre class="programlisting">  var data = JSON.stringify({
    album: 'Folie A Deux',
    artiste: 'Fall Out Boy'
  });

  function onreadystatechange(event){
    if (event.target.readyState != 4) return;
    console.log('POST /albums %s', event.target.status);
  }

  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = onreadystatechange;
  xhr.open('POST', '/albums');
  xhr.setRequestHeader('Content-type', 'application/json');
  xhr.send(data);</pre></div><p class="calibre7">This is obviously boilerplate code, and jQuery makes this as simple as:</p><div class="informalexample"><pre class="programlisting">$
  .post('/albums', data)
  .then(function(albut){
    console.log('POST /albums 200');
  });</pre></div><p class="calibre7">There are numerous ways we could integrate this into an Ember.js application. For example, if this was to be initiated after a form submission, we could implement it in a <code class="email">save</code> action, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/x-handlebars'&gt;{{outlet}}&lt;/script&gt;
&lt;script type='text/x-handlebars' id='index'&gt;

  {{#with model}}
  &lt;form {{action 'saveAlbum' this on='submit'}}&gt;
      {{input value=artiste}}
      {{input value=album}}
      {{input value='save' type='submit'}}
  &lt;/form&gt;
  {{/with}}

&lt;/script&gt;

&lt;script&gt;

  App = Ember.Application.create();

  App.Router.map(function(){});

  App.IndexRoute = Ember.Route.extend({
    model: function(){
      return {};
    },
    actions: {
      saveAlbum: function(album){
        var data =  {
          album: album.album,
          artiste: album.artiste
        };
      $
        .post('/albums', data)
        .then(function(album){
           console.log('POST /albums 200');
         }, function(response){
           alert('failed!');
         });
      }
    }
  });
&lt;/script&gt;</pre></div><p class="calibre7">When a user <a id="id385" class="calibre1"/>submits the provided form, the index controller's <code class="email">saveAlbum</code> action would be called to post the album to the server using jQuery. Ideally, we could create an <code class="email">album</code> class to separate concerns, as follows:</p><div class="informalexample"><pre class="programlisting">App.Album = Ember.Object.extend({
  toJSON: function(){
    return {
      album: this.get('album'),
      artiste: this.get('artiste')
    };
  },
  save: function(){ // function to persist album to the server
    $
      .post('/albums', this.toJSON())
      .then(function(event){
        console.log('POST /albums 200');
      }, function(event){
        alert('failed!');
      });
  }
});</pre></div><p class="calibre7">With this<a id="id386" class="calibre1"/> class, we could then do a final refactor, as follows:</p><div class="informalexample"><pre class="programlisting">App.IndexRoute = Ember.Route.extend({
  model: function(){
    return App.Album.create();
  },
  actions: {
    saveAlbum: function(album){
      album.save();
    }
  }
});</pre></div><p class="calibre7">In addition, we may wish to load the saved albums from the server to present to the user. A simple way would be to implement a <code class="email">find</code> class method to load these albums, as follows:</p><div class="informalexample"><pre class="programlisting">Album.reopenClass({
  find: function(){
    return $.getJSON('/albums');
  }
});</pre></div><p class="calibre7">This example adds a static class method to the <code class="email">Album</code> class, which would then be used to query the backend for albums, as follows:</p><div class="informalexample"><pre class="programlisting">App.AlbumsRoute = Ember.Route.extend({
  model: function(){
    return App.Album.find();
  }
});</pre></div><p class="calibre7">As this is a common practice, the Ember.js community also maintains another project called<a id="id387" class="calibre1"/> <span class="strong"><strong class="calibre8">Ember-data</strong></span> (<a class="calibre1" href="http://github.com/emberjs/data">http://github.com/emberjs/data</a>) and that aims to abstract such needs. This chapter is, therefore, going to walk us through using Ember-data in RESTful applications. These <a id="id388" class="calibre1"/>applications use <span class="strong"><strong class="calibre8">REST</strong></span> (<span class="strong"><strong class="calibre8">Representational State Transfer</strong></span>), which, as we know, lets us consume APIs that use some of the following <a id="id389" class="calibre1"/>HTTP verbs:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">GET</code></li><li class="listitem"><code class="email">POST</code></li><li class="listitem"><code class="email">PUT</code></li><li class="listitem"><code class="email">DELETE</code></li></ul></div></div></div>
<div class="book" title="Understanding Ember-data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec89" class="calibre1"/>Understanding Ember-data</h1></div></div></div><p class="calibre7">Ember-data<a id="id390" class="calibre1"/> is another ambitious, opinionated, open source project used to develop applications that need to communicate with backend database services. A suitable <a id="id391" class="calibre1"/>version can be downloaded from <a class="calibre1" href="http://builds.emberjs.com/">http://builds.emberjs.com/</a>. In our case, we will be using Version 1.0.0-beta.9 build that is already included in the chapter samples. These samples define a simple <span class="strong"><strong class="calibre8">Todos</strong></span> application implementation of <a class="calibre1" href="http://github.com/component/todo">http://github.com/component/todo</a>:</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Understanding Ember-data" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We will be using the <code class="email">fixtures-adapter</code> sample first, which you can load via the <code class="email">index.html</code> file. This<a id="id392" class="calibre1"/> application enables users to do the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Load saved todos</li><li class="listitem">Create and save new todos</li><li class="listitem">Filter loaded todos by state (complete versus incomplete todos)</li></ul></div></div>
<div class="book" title="Ember-data namespace"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec90" class="calibre1"/>Ember-data namespace</h1></div></div></div><p class="calibre7">The Ember-data library <a id="id393" class="calibre1"/>utilizes its own global namespace named <code class="email">DS</code>, from which we will be referencing commonly-used classes such as <code class="email">DS.Store</code> and <code class="email">DS.Model</code>.</p></div>
<div class="book" title="Creating a data store"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec91" class="calibre1"/>Creating a data store</h1></div></div></div><p class="calibre7">Applications <a id="id394" class="calibre1"/>that use Ember-data usually use a single storage repository that <a id="id395" class="calibre1"/>stores all records that are available to the application. This store is defined from the <code class="email">DS.Store</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">App.ApplicationStore = DS.Store.extend({
});</pre></div><p class="calibre7">The preceding code is automatically executed by Ember.js, and so we do not need to do anything. Just like the router, this class is usually autoinstantiated and made accessible to all routes and controllers as a <code class="email">store</code> property. Here's an example that demonstrates a route that accesses the application's store:</p><div class="informalexample"><pre class="programlisting">App.BooksRoute = Ember.Route.extend({
  model: function(){
    return this.store.find('book');
  }
   });</pre></div><p class="calibre7">Do not worry about what this does. The important thing to learn from the preceding snippet is how the store instance is accessed.</p></div>
<div class="book" title="Defining models"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec92" class="calibre1"/>Defining models</h1></div></div></div><p class="calibre7">In the <a id="id396" class="calibre1"/>introductory chapters, we learned how to organize application objects<a id="id397" class="calibre1"/> into reusable classes called <code class="email">models</code>. Ember-data provides support for defining such models that extend <code class="email">DS.Model</code>, and from which records can then be created. For example, let's review the <code class="email">Todo</code> model that was defined in the samples:</p><div class="informalexample"><pre class="programlisting">App.Todo = DS.Model.extend({
  title: DS.attr('string'),
  complete: DS.attr('boolean', {
    defaultValue: false
  })
});</pre></div><p class="calibre7">As illustrated, the<a id="id398" class="calibre1"/> model was defined by extending the <code class="email">DS.Model</code> class. We<a id="id399" class="calibre1"/> then defined two attributes using the <code class="email">DS.attr</code> class methods that take two arguments:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The name of the attribute</li><li class="listitem">An optional options object</li></ul></div><p class="calibre7">The attribute's type is usually one of the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">String</li><li class="listitem">Number</li><li class="listitem">Date</li><li class="listitem">Boolean</li></ul></div><p class="calibre7">However, we learn later that it's possible to define other custom types. The options object commonly contains a <code class="email">defaultValue</code> property, which could be a value or a function that evaluates to the value to be used as the default.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Declaring relations"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec93" class="calibre1"/>Declaring relations</h1></div></div></div><p class="calibre7">Records in <a id="id400" class="calibre1"/>our <a id="id401" class="calibre1"/>application may be related; thus, Ember-data supports defining some of the following common relations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">One-one</li><li class="listitem">One-many</li><li class="listitem">Many-many</li></ul></div></div>

<div class="book" title="Declaring relations">
<div class="book" title="One to one"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec39" class="calibre1"/>One to one</h2></div></div></div><p class="calibre7">In this<a id="id402" class="calibre1"/> type<a id="id403" class="calibre1"/> of relation, only one model can belong to the other. For example, we can define two objects, a person and a passport, where the person only owns one passport:</p><div class="informalexample"><pre class="programlisting">App.Person = DS.Model.extend({</pre></div></div></div>
<div class="book" title="Finding records"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec94" class="calibre1"/>Finding records</h1></div></div></div><p class="calibre7">Ember-data<a id="id404" class="calibre1"/> provides<a id="id405" class="calibre1"/> various ways to query loaded records as well to pull new ones from backend services. To find all records of a particular model, we can simply utilize the store's <code class="email">find</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">// GET /todos

store.find('todo');</pre></div><p class="calibre7">This method loads all todos from the server via a promise that we then consume, shown as follows:</p><div class="informalexample"><pre class="programlisting">store
  .find('todo')
  .then(function(todos){
    todos.map(function(todo){
      todo.set('complete', false);
      return todo;
    });
  });</pre></div><p class="calibre7">If we, however, want to only query loaded records, we can use the store's <code class="email">all</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">store.all('todo');</pre></div><p class="calibre7">Similarly, we may want to query a record by a given <code class="email">id</code>, as follows:</p><div class="informalexample"><pre class="programlisting">// GET /todos/1

store.find('todo', id);</pre></div><p class="calibre7">Querying records by search terms is also as easy as:</p><div class="informalexample"><pre class="programlisting">// GET /todos?complete=true

store.find('todo', {
  complete: true
});</pre></div></div>
<div class="book" title="Defining a store's adapter"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec95" class="calibre1"/>Defining a store's adapter</h1></div></div></div><p class="calibre7">Every store needs<a id="id406" class="calibre1"/> an adapter that sits at the network layer, where it makes<a id="id407" class="calibre1"/> the actual API request calls. This is what differentiates the two variants of our Todos application, where each of its stores defines an adapter that communicates with different remote data stores. For example, the first sample defines its adapter as follows:</p><div class="informalexample"><pre class="programlisting">App.ApplicationAdapter = DS.FixtureAdapter;</pre></div><p class="calibre7">All adapters <a id="id408" class="calibre1"/>need to implement the following methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">find</code></li><li class="listitem"><code class="email">findAll</code></li><li class="listitem"><code class="email">findQuery</code></li><li class="listitem"><code class="email">createRecord</code></li><li class="listitem"><code class="email">updateRecord</code></li><li class="listitem"><code class="email">deleteRecord</code></li></ul></div><p class="calibre7">These adapters <a id="id409" class="calibre1"/>enable applications to stay in sync with various data stores such as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Local caches</li><li class="listitem">A browser's local storage or indexdb</li><li class="listitem">Remote databases through REST</li><li class="listitem">Remote databases through RPC</li><li class="listitem">Remote databases through WebSockets</li></ul></div><p class="calibre7">These adapters are, therefore, swappable in case applications need to use different data providers. Ember-data comes with two built-in adapters: the <code class="email">fixtures-adapter</code> and the <code class="email">rest-adapter</code>.</p><p class="calibre7">The fixtures adapter uses an in-browser cache to store the application's records. This adapter is especially useful when the backend service of the project is either inaccessible for testing or is still being developed. When using this adapter, it may be necessary to add initial data called fixtures to mock out the existing records. These records can be loaded into the application's store by adding them in the <code class="email">FIXTURES</code> property of the affected model, shown as follows:</p><div class="informalexample"><pre class="programlisting">App.Todo.FIXTURES = [
  { id: 1, title: 'Bake cake', complete: true },
];</pre></div></div>
<div class="book" title="Creating REST APIs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec96" class="calibre1"/>Creating REST APIs</h1></div></div></div><p class="calibre7">Once satisfied<a id="id410" class="calibre1"/> with the workings of the models, we may then swap out the fixtures adapter with the <code class="email">rest-adapter</code>, that as you guessed, communicates with remote data stores through REST. The second sample includes a simple Node.js server (Server.js) that uses<a id="id411" class="calibre1"/> Express.js (<a class="calibre1" href="http://expressjs.com">http://expressjs.com</a>) to demonstrate the use of this adapter. To test the application, you will need to install Node.js by following these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Download <a id="id412" class="calibre1"/>your platform's Node.js binary at <a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>.</li><li class="listitem" value="2">Un-archive the downloaded package.</li><li class="listitem" value="3">Add the location of the <code class="email">bin</code> directory inside the un-archived directory into your environment <code class="email">PATH</code> setting.</li><li class="listitem" value="4">Test out the installation by running <code class="email">node</code> in a terminal.</li></ol><div class="calibre22"/></div><p class="calibre7">To start the <a id="id413" class="calibre1"/>application, navigate to the <code class="email">rest-adapter</code> sample directory and then simply run the following two commands in your shell emulator:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install</strong></span>
<span class="strong"><strong class="calibre8">node server</strong></span>
</pre></div><p class="calibre7">Then, visit <code class="email">http://localhost:5000</code> in your browser. We notice that the two applications are different in that the latter persists data to the running backend. If we add new todos and visit a new tab, we will realize that the new changes are reflected. The application, however, does not persist the changes in a real database as this is out of the scope of this book. Therefore, as an exercise, try and reimplement this sample in your favorite server-side stack.</p><p class="calibre7">The rest-adapter makes a few assumptions that our todos server API must adhere to, shown in the following table:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Action</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Request HTTP verb</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Request URL</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Request</p>
<p class="calibre19">JSON payload</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Response JSON data</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">Create</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">POST</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/todos</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data}</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data} or id</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">Find all</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">GET</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/todos</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">None</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data}</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">Find query</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">GET</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/todos?complete=true</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">None</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data}</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">Find one</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">GET</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/todos/1</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">None</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data}</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">Update</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">UPDATE</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/todos/1</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data}</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">{todo: data} or None</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">Delete</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">DELETE</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/todos/1</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">None</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">None</code>
</p>
</td></tr></tbody></table></div><p class="calibre7">This implementation can be found in the <code class="email">api.js</code> module. Therefore, it is wise to use such a format when creating new APIs that are primarily consumed by Ember-data applications. This convention is also documented at <a class="calibre1" href="http://jsonapi.org/">http://jsonapi.org/</a>, which may be a great resource for you.</p><p class="calibre7">Related objects can also be loaded in a similar way. For example, in our <span class="strong"><em class="calibre9">tweet-retweet</em></span> case, we could load retweets of a particular tweet, as follows:</p><div class="informalexample"><pre class="programlisting">{ tweet: {
  id: 1,
  title: 'New book out',
  retweets: [{
    id: 1,
    title: 'RT New book out',
    user: 'Jon',
  }, {
    id: 2,
    title: 'RT  New book out',
    user: 'Doe'
  }]
}}</pre></div><p class="calibre7">Notice that <a id="id414" class="calibre1"/>Ember-data expects that the property in the response data that contains the related objects should be named as the pluralized form of the related model:</p><div class="informalexample"><pre class="programlisting">retweets: DS.hasMany('retweet')

retweet =&gt; retweets
person =&gt; people</pre></div><p class="calibre7">Alternatively, the API can only send the IDs of the related objects, as follows:</p><div class="informalexample"><pre class="programlisting">{ tweet: {
  id: 1,
  title: 'New book out',
  retweets: [1, 2, 3]
}}</pre></div><p class="calibre7">Ember-data will then <span class="strong"><em class="calibre9">side-load</em></span> the corresponding objects into the data store.</p><p class="calibre7">Sometimes, a model may have more than one relation of the same model. For example, a typical Facebook user has followers and followings, whose model can then be defined as follows:</p><div class="informalexample"><pre class="programlisting">App.User = DS.Model.extend({
  followers: DS.hasMany('user'),
  followings: DS.hasMany('user')
});</pre></div><p class="calibre7">Ember-data will then expect the response data to contain a list of related objects named <code class="email">users</code>. However, since there is more than one attribute that depends on the user model, we can easily resolve this by using the <code class="email">inverse</code> option, as follows:</p><div class="informalexample"><pre class="programlisting">App.User = DS.Model.extend({
  followers: DS.hasMany('user', { inverse: 'followers'} ),
  followings: DS.hasMany('user', { inverse: 'followings'} )
});</pre></div><p class="calibre7">With this, we can then return a response as follows:</p><div class="informalexample"><pre class="programlisting">{ user: {
  id: 1,
  followers: [],
  following: []
}}</pre></div><p class="calibre7">If the<a id="id415" class="calibre1"/> application consumes APIs from different endpoints, we will need to define different adapters for each of the models, as follows:</p><div class="informalexample"><pre class="programlisting">App.BookAdapter = DS.RESTAdapter.extend({
  namespace: 'v3/',
  host: 'http://books.example.com'
});

App.PenAdapter = DS.RESTAdapter.extend({
  namespace: 'v3/',
  host: 'http://pens.example.com'
});</pre></div><p class="calibre7">As shown in the preceding code, adapters can be customized in many different ways in order to meet the needs of your APIs and domain logic. This ensures that the existing APIs can still be consumed easily rather than having to build separate API endpoints reserved for Ember-data applications.</p></div>
<div class="book" title="Customizing a store's serializer"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec97" class="calibre1"/>Customizing a store's serializer</h1></div></div></div><p class="calibre7">In addition to <a id="id416" class="calibre1"/>a store's adapter, all stores have a serializer<a id="id417" class="calibre1"/> that serializes and deserializes data that comes in and out of the application. For example, if the data models in our backend use primary keys other than <code class="email">id</code>, we can easily do this:</p><div class="informalexample"><pre class="programlisting">DS.RESTSerializer.reopen({
  primaryKey: 'key'
});</pre></div><p class="calibre7">Note that this could also be specified per model, as follows:</p><div class="informalexample"><pre class="programlisting">App.PhoneSerializer = DS.RESTSerializer.extend({
  primaryKey: 'phone_id'
});</pre></div></div>
<div class="book" title="Creating custom transformations"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec98" class="calibre1"/>Creating custom transformations</h1></div></div></div><p class="calibre7">Transformations <a id="id418" class="calibre1"/>are the different types of model <a id="id419" class="calibre1"/>attributes. Application authors are not limited to the built-in ones, so they may define their own transformations easily. For example, one of our backend services may represent Booleans as zeros and ones:</p><div class="informalexample"><pre class="programlisting">1 – true
0 – false</pre></div><p class="calibre7">We could create a transformation that resolves these values where necessary:</p><div class="informalexample"><pre class="programlisting">App.BinaryBoolean = DS.Transform.extend({
  serialize: function(boolean){
    return (!boolean)
     ? 0
     : 1;
  },
  deserialize: function(binary){
    return (!!!binary)
     ? false
     : true;
  }
});</pre></div><p class="calibre7">We just created a new transformation by extending <code class="email">DS.Transform</code> and then defining the following two methods that act on the attribute's value:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">serialize</code>: This converts the attribute value to a form acceptable by the server</li><li class="listitem"><code class="email">deserialize</code>: This converts the value loaded from the server into what the application will use</li></ul></div><p class="calibre7">We can then easily use this new type as follows:</p><div class="informalexample"><pre class="programlisting">App.Todo = DS.Todo.extend({
  complete: DS.attr('binaryBoolean')
});
var todo = store.createRecord('todo', {
  complete: true
});
todo.save(); // POST /todos {'todo': {complete: 1}}</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec99" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we've discussed how to use Ember-data to create applications that need to communicate with backend storage services through REST. We have learned how to create records from defined models as well as updating and deleting them. We have also learned the different customizations we would need to make in order to consume existing APIs as much as possible. We should, therefore, be comfortable enough to start writing any client-side applications backed by REST APIs. As we proceed to the other exciting chapters, we should start thinking of how web sockets, JSONP, and RPC can be integrated with Ember-data seamlessly.</p></div></body></html>