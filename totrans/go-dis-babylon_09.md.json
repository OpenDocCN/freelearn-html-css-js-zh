["```js\n\nconst CONTROL_NAMES = Object.freeze({\n    cancel: 'userCancel',\n    accept: 'userAccept',\n    titleText: 'titleText',\n    bodyText: 'dialogText',\n    acceptText: 'userAcceptText',\n    cancelText: 'userCancelText',\n    dialog: 'dialogBorder',\n    bodyScrollViewer: 'bodyContainer',\n    bodyStackPanel: 'bodyStackPanel',\n});\n```", "```js\n\nthis.advancedTexture = AdvancedDynamicTexture\n     .CreateFullscreenUI(\"dialog\", false, scene,\n          Texture.NEAREST_NEAREST, true);\n```", "```js\n\nthis.scene.executeWhenReady(async () => {\n     await this.advancedTexture\n           .parseFromSnippetAsync(DIALOG_GUI_SNIPPET,\n             false);\n     this.dialogContainer.isVisible = false;\n```", "```js\n\nget dialogContainer() {\n    return this.advancedTexture\n           .getControlByName(CONTROL_NAMES.dialog);\n}\nget titleText() {\n    let ctrl = this.advancedTexture\n            .getControlByName(CONTROL_NAMES.titleText);\n    return ctrl.text;\n}\nset titleText(value) {\n    let ctrl = this.advancedTexture\n            .getControlByName(CONTROL_NAMES.titleText);\n    ctrl.text = value;\n}\n```", "```js\n\nconst {\n  bodyText, titleText,\n  displayOnLoad, acceptText,\n  cancelText\n} = options; //...later...\nif (bodyText) { this.bodyText = bodyText; }\nthis.titleText = titleText ?? \"Space-Truckers: The Dialog\n  Box\";\nthis.acceptText = acceptText ?? \"OK\";\nthis.cancelText = cancelText ?? \"Cancel\";\n```", "```js\n\nthis.#acceptPointerObserver =\n  this.acceptButton.onPointerClickObservable\n    .add(async (evt) => {\n        await this.onAccepted();\n        this.onAcceptedObservable.notifyObservers();\n    });\nthis.#cancelPointerObserver =\n  this.cancelButton.onPointerClickObservable\n    .add((evt) => {\n        await this.onCancelled();\n        this.onCancelledObservable.notifyObservers();\n    });\nthis.scene.onDisposeObservable.add(() => {\n    this.dispose();\n});\n```", "```js\n\ndispose() {\n    if (this.#showTimer) {\n        this.#showTimer = null;\n    }\n    this.onAcceptedObservable?.clear();\n    this.onAcceptedObservable?.cancelAllCoroutines();\n    this.onCancelledObservable?.clear();\n    this.onCancelledObservable?.cancelAllCoroutines();\n    this.advancedTexture?.clear();\n} \n```", "```js\n\n    onAccepted() {\n        return this.hide();\n    }\n    onCancelled() {\n        return this.hide();\n    }\n```", "```js\n\nreturn new Promise((resolve, reject) => {\n   this.dialogContainer.alpha = 1;\n   this.#showTimer = setAndStartTimer(\n   {\n       timeout: this.#fadeInTransitionDurationMs,\n       onTick: (d) => this.dialogContainer.alpha = Scalar\n                      .SmoothStep(0.998, 0, d.completeRate),\n       onEnded: () => {\n           this.advancedTexture.isForeground = false;\n           this.dialogContainer.isVisible = false;  \n           resolve();\n        },\n        breakCondition: this.dialogContainer == null\n     });\n   }\n});\n```", "```js\n    let opts = {\n        bodyText: \"Your flight plan appears to be viable!\"\n            + '\\n'\n            + \"Would you like to file it with Space-\n              Truckers Traffic Control (STC)?\",\n        titleText: 'Route Planning Success',\n        displayOnLoad: false,\n        acceptText: 'Launch!',\n        cancelText: 'Retry',\n        guiData: DIALOG_GUI_SNIPPET // e.g., \"923BBT#32\"\n    };\n    ```", "```js\n    let dialog = new DialogBox(opts, scene);\n    ```", "```js\n    dialog.onAcceptedObservable.add(async () => {\n            dialog.dispose();\n            dialog = createScoringDialog(null, scene);\n    });\n    dialog.onCancelledObservable.add(()=>console.log\n      ('cancelled'))\n    ```", "```js\n    dialog.show();\n    ```", "```js\n    await dialog.hide();\n    ```", "```js\n\n\"source\":\"/assets/menuBackground.png\"\n```", "```js\n\nimport stackedDialog from \"./gui-dialog-buttons-\n  scroll.json\";\n// later…\nthis.advancedTexture.parseContent(stackedDialog, false);\n```", "```js\n\nimport DialogBox from \"../guis/guiDialog\";\n```", "```js\n\nthis.routeConfirmationDialog = new DialogBox({\n    bodyText: 'Successful route planning! Use route and\n      launch?',\n    titleText: 'Confirm Flight Plan',\n    acceptText: 'Launch!',\n    cancelText: 'Reset',\n    displayOnLoad: false\n}, this.scene);\nthis.routeConfirmationDialog.onAcceptedObservable.add(() =>\n  {\n    this.routeAcceptedObservable.notifyObservers();\n    this.gameState = PLANNING_STATE.RouteAccepted;\n    this.routeConfirmationDialog.hide();\n});\nthis.routeConfirmationDialog.onCancelledObservable.add(()\n  => {\n    this.routeConfirmationDialog.hide();\n    this.setReadyToLaunchState();\n});\n```", "```js\n\nscoreFactors: {\n    routeLength: 12450.25,\n    cargoCondition: 0.768,\n    encounters: 125,\n    launch: 100.00\n},\nmultipliers: {\n    transitTime: { expected: 180, actual: 150, factor: 1.2  },\n    delivery: 1.0,\n    condition: 0.768,\n    encounterTypes: 1.05\n},\nfinalScores: {\n    'Base Delivery': 1000,\n    'Route Score': 14940,\n    'Cargo Score': 11474,\n    'Delivery Bonus': 10000,\n    'Encounters': 1312,\n    'Final Total': 38726\n}\n```", "```js\n\nlet computeScores = function (route) {\n    let score = createDefaultScoring();\n    calculateEncounterScoreToRef(route, score);\n    calculateRouteScoreToRef(route, score);\n    calculateCargoScoreToRef(route, score);\n    calculateBonusScoreToRef(route, score);\n    calculateFinalScoreToRef(score);\n    console.log(score);\n    return score;\n}\n```", "```js\n\nconst { pathPoints } = route;\nconst encounters = pathPoints\n    .map(p => p.encounter)\n    .filter(e => e);\nscoreFactors.encounters = encounters.length;\nlet encounterModifier = \n    1 + encounters.map(e => e.scoreModifier)\n        .reduce((prev, curr, cidx, arr) => {\n            return prev + curr;\n        });\nmultipliers.encounterTypes = encounterModifier;\nlet encounterScore = 100 * encounters.length * \n  multipliers.encounterTypes;\nfinalScores['Encounters'] = encounterScore;\n```", "```js\n\ntransit.factor = 0.5 + route.transitTime /\n  route.actualTransitTime;\nfinalScores['Route Score'] = \n(route.distanceTraveled * transit.factor) – \n(route.launchForce * transit.factor);\n```", "```js\n\nconst { cargoCondition } = route;\nscoreFactors.cargoCondition = cargoCondition;\nlet cargoScore = 10 * cargoCondition *\n  multipliers.condition;\nfinalScores['Cargo Score'] = cargoScore;\n```", "```js\n\nif (route.cargoCondition >= 100) {\n   s.finalScores['Delivery Bonus'] = DELIVERY_BONUS;\n} else { s.finalScores['Delivery Bonus'] = 0;}\n```", "```js\n\nlet { finalScores } = score;\nfinalScores['Base Delivery'] = BASE_DELIVERY_SCORE;\nlet finalScore = Object.values(finalScores)\n  .reduce((prev, curr) => prev + Number(curr));\nscore.finalScores['Final Total'] = finalScore;\n```", "```js\n\n    get routeData() {\n        return {\n            route: this.cargo.routePath,\n            launchForce: this.launchForce,\n            transitTime: this.cargo.timeInTransit,\n            distanceTraveled: this.cargo.distanceTraveled\n        }\n    }\n```", "```js\n\n{\n   name: 'Rock Hazard',\n   id: 'rock_hazard',\n   image: hazard_icon,\n   probability: 0.89,\n   scoreModifier: 0.019\n}\n```", "```js\n\nlet closestPathPosition =\n  path3d.getClosestPositionTo(mesh.absolutePosition);\n// not close enough!\nif (closestPathPosition < 0.976) {\n    this.reset();\n    return;\n}\nthis.completeRound();\n```", "```js\n\ncompleteRound() {\n    this.gui.guiCamera.layerMask = 0x0;\n    this.currentState = DRIVING_STATE.RouteComplete;\n    this.route.actualTransitTime = this.currentTransitTime;\n    // gather data for score computation\n    let scoring = computeScores(this.route);\n    let scoreDialog = createScoringDialog(scoring, this);\n    scoreDialog.onAcceptedObservable\n     .addOnce(() =>\n       this.onExitObservable.notifyObservers());\n    scoreDialog.onCancelledObservable\n     .addOnce(() => this.reset());\n    this.scoreDialog = scoreDialog;\n}\n```", "```js\n\n    let opts = {\n        bodyText: 'Time to earn payday!',\n        titleText: 'The Drayage Report',\n        displayOnLoad: true,\n        acceptText: 'Main Menu',\n        cancelText: 'Retry'\n    };\n    const { scene, soundManager } = drivingScreen;\n    const sound = soundManager.sound('scoring');\n\n    let scoreDialog = new DialogBox(opts, scene);\n    let dialog = { scoreDialog };\n    dialog.height = \"98%\";\n    let scoringCo = scoringAnimationCo();\n```", "```js\n\nfunction* nextColor() {\n    while (true) {\n        yield \"#0d5088\";\n        yield \"#94342c\";\n        yield \"#e2ba77\";\n        yield \"#787b6d\";\n    }\n}\nlet colorPicker = nextColor();\n```", "```js\n\n// ...inside the createScoringDialog function scope\n// ...inside the function* scoringAnimationCo scope\nfunction createScoringBlock(label) {\n    let scoreBlock = new TextBlock(\"scoreLine\",\n      `${label}`);\n    scoreBlock.width = \"100%\";\n    scoreBlock.color = colorPicker.next().value;\n    scoreBlock.textHorizontalAlignment =\n      Control.HORIZONTAL_ALIGNMENT_LEFT;\n    // …snip…\n    return scoreBlock;\n}\n```", "```js\n\nfor (let i in finalScores) {\n    yield Tools.DelayAsync(500);\n    // ...snip... compute and adjust height    \n    yield Tools.DelayAsync(1800);\n    if (skipCountUp) {\n        // display score right away\n    }\n    else {\n        const MAX_COUNT = 50;\n        while (frameCounter <= MAX_COUNT) {\n            let currProgress = frameCounter / MAX_COUNT;\n            sound.play();\n            let speed = Scalar\n                    .SmoothStep(0, score, currProgress);\n            scoreBlock.text =\n                     `${label}.........${speed.toFixed()\n                      .toLocaleString()}`;\n            frameCounter++;\n            yield Tools.DelayAsync(50);\n          }\n        }\n        yield;\n      }\n      return;\n```", "```js\n\nlet scoringCo = scoringAnimationCo();    \nscene.onBeforeRenderObservable.runCoroutineAsync(scoringCo);\n```", "```js\n\nfunction* think() {\n    while (true) {\n        yield Tools.DelayAsync(1500);\n        yield* moveToTarget(new Vector3(PERIMETER / 2, 1,\n          0));\n        yield Tools.DelayAsync(1500);\n        yield* patrolCo();\n        yield* moveToTarget(new Vector3(0, 1, 0));\n    }\n}\n```", "```js\n\nfunction* patrolCo() {\n    let targetVector = new BABYLON.Vector3(0, 1, 0)\n    yield;\n    sphereMat.diffuseColor = BABYLON.Color3.Random();\n    targetVector.set(PERIMETER / 2, 1, 0);\n    yield* moveToTarget(targetVector);\n    sphereMat.diffuseColor = BABYLON.Color3.Random();\n    targetVector.addInPlaceFromFloats(0, 0, PERIMETER / 2);\n    // ...snip... \n    yield* moveToTarget(targetVector);\n    return;\n}\n```", "```js\n\nconst maxDelta = 0.0075;\nfunction* moveToTarget(targetPosition) {\n    let hasArrived = false;\n    while (!hasArrived) {\n        let dir = targetPosition.subtract(sphere.position);\n        if (dir.length() <= 0.75) {\n            hasArrived = true;\n        }\n        dir.scaleInPlace(maxDelta);\n        sphere.position.addInPlace(dir);\n        yield;\n    }\n    return;\n}\n```"]