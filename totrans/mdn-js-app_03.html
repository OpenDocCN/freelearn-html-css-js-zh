<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Communication between Browsers in Real Time"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Communication between Browsers in Real Time</h1></div></div></div><p>To implement features such as audio/video chat or some other features in websites that require real-time peer-to-peer (browser-to-browser) data transfer, or need to retrieve audio/video stream from a microphone, webcam, or any other device, we had to use browser plugins such as Java and Flash. There are various issues with making websites depend on browser plugins, such as mobile browsers not supporting plugins and plugins requiring to be kept up to date. Therefore, WebRTC was introduced to solve these problems, that is, browsers that support WebRTC provide APIs to exchange data in real time directly between browsers and also retrieve stream from physical media sources without the use of plugins. In this chapter, we will discuss WebRTC and also the PeerJS library that wraps the WebRTC APIs to provide an easy to use API to work with WebRTC.</p><p>In this chapter, we'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discussing various APIs provided by WebRTC</li><li class="listitem" style="list-style-type: disc">Retrieving stream from physical media input devices</li><li class="listitem" style="list-style-type: disc">Displaying a media stream</li><li class="listitem" style="list-style-type: disc">Discussing protocols used by WebRTC</li><li class="listitem" style="list-style-type: disc">Exchanging media stream and arbitrary data between peers using PeerJS</li><li class="listitem" style="list-style-type: disc">Discussing topics related to the fundamentals of WebRTC and PeerJS</li></ul></div><div class="section" title="Terminologies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Terminologies</h1></div></div></div><p>Before we <a id="id81" class="indexterm"/>get into WebRTC and PeerJS, you <a id="id82" class="indexterm"/>need to know the meaning of some terms that we are going to use. These terms are discussed in the following sections.</p><div class="section" title="Stream"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Stream</h2></div></div></div><p>A <span class="strong"><strong>stream</strong></span> is <a id="id83" class="indexterm"/>a sequence of any kind of data that is made available over time. A stream object represents a stream. Usually, an event handler or callback is attached to the stream object, which is invoked whenever new data is available.</p><p>A <span class="strong"><strong>media stream</strong></span> is <a id="id84" class="indexterm"/>a stream whose data is either audio or video. Similarly, a <span class="strong"><strong>media source</strong></span> <a id="id85" class="indexterm"/>is a physical device, file, or something that provides data that is audio or video. A <span class="strong"><strong>media consumer</strong></span> <a id="id86" class="indexterm"/>is also a physical device, API, or something that uses media stream.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>WebRTC allows us to retrieve a media stream of physical media sources, such as microphones, webcams, screens, and so on. We will discuss more about it later in this chapter.</p></div></div></div><div class="section" title="Peer-to-peer network model"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Peer-to-peer network model</h2></div></div></div><p>Peer-to-peer model <a id="id87" class="indexterm"/>is the opposite of the client-server model. In the client-server model, the server provides resources to the clients, whereas in peer-to-peer model, every node in the network acts as a server and client, that is, every node provides and consumes resources. Peers in the peer-to-peer model communicate with each other directly.</p><p>To establish a peer-to-peer connection, we need a signaling server, which is used for signaling. <span class="strong"><strong>Signaling</strong></span> refers <a id="id88" class="indexterm"/>to the exchange of data by peers that is required to establish a peer-to-peer connection. Data such as session control messages, network configuration, and so on is required to establish a peer-to-peer connection. A signaling server implements a signaling protocol such as SIP, Jingle, or some other protocol.</p><p>A model is selected depending on the requirements and resource availability for the application. Let's consider some examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To build a video chat app, we should use the peer-to-peer model instead of the client-server model. As each node, in this case, is going to produce a lot data (or frames), and send the data to other node in real time, the server requires a lot of networks and other resources, increasing the server running cost. So, the peer-to-peer model is the best option for a video chat app. For example, Skype video chat is based on the peer-to-peer model.</li><li class="listitem" style="list-style-type: disc">To build a text chat app that stores messages in a centralized database, we should use the client-server model as the amount of data that a client produces is not very high and you would also want to store the messages in a centralized database. For example, the Facebook messenger is based on the client-server model.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>To establish a peer-to-peer connection using WebRTC, you will need a signaling server, STUN server, and optional TURN server. We will discuss more about it later in this chapter.</p></div></div></div><div class="section" title="Real-time data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Real-time data</h2></div></div></div><p>
<span class="strong"><strong>Real-time data</strong></span> is <a id="id89" class="indexterm"/>the data that needs to be processed and transferred without much delay. For example, video chatting, live analytics, live stock price, live streaming, text chat, live score, online multiplayer game data, and so on are all real-time data.</p><p>Real-time data transfer is a difficult task to achieve. The techniques and technologies used for real-time data transfer depend on the amount of data and whether the loss of data during data transfer is tolerable or not. If the real-time data is large, and the loss of data is intolerable, then it requires a lot of resources to achieve real-time data transfer, making it practically impossible to achieve real-time data transfer. For example, while video chatting, every user generates a lot of frames. If some frames are lost, then it is tolerable, therefore in this case, we can use the UDP protocol as a transport layer protocol that is unreliable and also has less overhead than TCP, making UDP very suitable for video chat application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>WebRTC allows us to transfer real-time media stream produced by it using the SRTP protocol. To transfer arbitrary data, it uses the SCTP protocol. We will discuss more about what these protocols are later in this chapter.</p></div></div></div></div></div>
<div class="section" title="Introduction to WebRTC"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Introduction to WebRTC</h1></div></div></div><p>
<span class="strong"><strong>Web Real-Time Communications (WebRTC)</strong></span> is <a id="id90" class="indexterm"/>a browser technology that enables retrieval of media stream of physical media sources and exchange media stream or any other data in real time. It comprises of three APIs: the <code class="literal">MediaStream</code> constructor, <code class="literal">RTCPeerConnection</code> constructor, and <code class="literal">RTCDataChannel</code> interface.</p><p>In short, <code class="literal">MediaStream</code> is used to retrieve the stream of physical media source, <code class="literal">RTCPeerConnection</code> is used to exchange <code class="literal">MediaStream</code> among peers in real time, and finally, <code class="literal">RTCDataChannel</code> is used to exchange arbitrary data among peers.</p><p>Let's see how these APIs work.</p><div class="section" title="MediaStream API"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>MediaStream API</h2></div></div></div><p>Two <a id="id91" class="indexterm"/>main components of MediaStream API are the <code class="literal">MediaStream</code> constructor and <code class="literal">MediaStreamTrack</code> interface.</p><p>A track <a id="id92" class="indexterm"/>represents the stream of a media source. A track implements the <code class="literal">MediaStreamTrack</code> interface. A track can either be an audio track or be a video track. That is, a track attached to an audio source is an audio track, and a track attached to a video source is a video track. There can be multiple tracks attached to a particular media source. We can also attach constraints to a track. For example, a track attached to a webcam can have constraints such as the minimum video resolution and FPS. Each track has its own constraints.</p><p>You can change the constraints of a track after it's created using the <code class="literal">applyConstraints()</code> method of the <code class="literal">MediaStreamTrack</code> interface. You can retrieve the constraints applied to a track anytime using the <code class="literal">getSettings()</code> method of the <code class="literal">MediaStreamTrack</code> interface. To detach a track from a media source, that is, to stop the track permanently, we can use the <code class="literal">stop()</code> method of the <code class="literal">MediaStreamTrack</code> interface. To pause a track, that is, to stop the track temporarily, we can assign <code class="literal">false</code> to the <code class="literal">enabled</code> property of the <code class="literal">MediaStreamTrack</code> interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Find <a id="id93" class="indexterm"/>out more about the <code class="literal">MediaStreamTrack</code> interface at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack">https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack</a>.</p></div></div><p>A track can either be a local or remote track. A local track represents the stream of a local media source; whereas, a remote track represents the stream of a remote media source. You cannot apply constraints to the remote track. To find whether a track is local or remote, we can use the <code class="literal">remote</code> property of the <code class="literal">MediaStreamTrack</code> interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>We will come across the remote track while exchanging tracks between peers. When we send a local track to a peer, the other peer receives the remote version of the track.</p></div></div><p>A <code class="literal">MediaStream</code> holds multiple tracks together. Technically, it doesn't do anything. It just represents a <a id="id94" class="indexterm"/>group of tracks that should be played, stored, or transferred together in a synchronized manner.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Find out more about the <code class="literal">MediaStream</code> constructor at <a class="ulink" href="https://developer.mozilla.org/en/docs/Web/API/MediaStream">https://developer.mozilla.org/en/docs/Web/API/MediaStream</a>.</p></div></div><p>The<code class="literal"> getSources()</code> method of the <code class="literal">MediaStreamTrack</code> object allows us to retrieve the ID of <a id="id95" class="indexterm"/>all the media devices, such as speakers, microphones, webcams, and so on. We can use the ID to create a track if the ID represents a media input device. The following is an example that demonstrates this:</p><div class="informalexample"><pre class="programlisting">MediaStreamTrack.getSources(function(sources){
  for(var count = 0; count &lt; sources.length; count++)
  {
    console.log("Source " + (count + 1) + " info:");
    console.log("ID is: " + sources[count].id);

    if(sources[count].label == "")
    {
      console.log("Name of the source is: unknown");
    }
    else
    {
      console.log("Name of the source is: " + sources[count].label);
    }
    
    console.log("Kind of source: " + sources[count].kind);

    if(sources[count].facing == "")
    {
      console.log("Source facing: unknown");
    }
    else
    {
      console.log("Source facing: " + sources[count].facing);
    }
  }
})</pre></div><p>The output will vary for everyone. Here is the output I got:</p><div class="informalexample"><pre class="programlisting">Source 1 info:
ID is: 0c1cb4e9e97088d405bd65ea5a44a20dab2e9da0d298438f82bab57ff9787675
Name of the source is: unknown
Kind of source: audio
Source facing: unknown
Source 2 info:
ID is: 68fb69033c86a4baa4a03f60cac9ad1c29a70f208e392d3d445f3c2d6731f478
Name of the source is: unknown
Kind of source: audio
Source facing: unknown
Source 3 info:
ID is: c83fc025afe6c7841a1cbe9526a6a4cb61cdc7d211dd4c3f10405857af0776c5
Name of the source is: unknown
Kind of source: video
Source facing: unknown</pre></div></div><div class="section" title="navigator.getUserMedia"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>navigator.getUserMedia</h2></div></div></div><p>There are <a id="id96" class="indexterm"/>various APIs that return <code class="literal">MediaStream</code> with <a id="id97" class="indexterm"/>tracks in it. One such method is <code class="literal">navigator.getUserMedia()</code>. Using <code class="literal">navigator.getUserMedia()</code>, we can retrieve a stream from media input sources, such as microphones, webcams, and so on. The following is an example to demonstrate:</p><div class="informalexample"><pre class="programlisting">navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

var constraints = {
  audio: true, 
  video: {
    mandatory: {
      minWidth: 640,
      minHeight: 360
    },
    optional: [{
      minWidth: 1280
    }, {
      minHeight: 720
    }]
  }
}

var av_stream = null;

navigator.getUserMedia(constraints, function(mediastream){
  av_stream = mediastream; //this is the MediaStream
}, function(err){
  console.log("Failed to get MediaStream", err);
});</pre></div><p>When you run the preceding code, the browser will display a popup seeking permission from the user. The user has to give the permission to the code to access the media input devices.</p><p>By default, the media input devices to which the tracks are attached while using <code class="literal">getUserMedia()</code> depends on the browser. Some browsers let the user choose the audio and <a id="id98" class="indexterm"/>video device that they want to use, while other browsers use the default audio and video devices listed in the operating system configuration.</p><p>We can also provide the <code class="literal">sourceId</code> property assigned to the ID of the media input device in the constraint object's <code class="literal">audio</code> or <code class="literal">video</code> property's <code class="literal">mandatory</code> property to make <code class="literal">getUserMedia()</code> attach tracks to these devices. So, if there are multiple webcams and microphones, then you can use <code class="literal">MediaStreamTrack.getSources()</code> to let the user choose a media input device and provide this media input device ID to <code class="literal">getUserMedia()</code> instead of relying on <a id="id99" class="indexterm"/>the browser, which doesn't guarantee whether it will let the user choose a media input device.</p><p>The first parameter that it takes is a constraint object with audio and video track constraints. Mandatory constraints are those constraints that must be applied. Optional indicates that they are not very important, so they can be omitted if it's not possible to apply them.</p><p>Some important constraints of an audio track are <code class="literal">volume</code>, <code class="literal">sampleRate</code>, <code class="literal">sampleSize</code>, and <code class="literal">echoCancellation</code>. Some important constraints of a video track are <code class="literal">aspectRatio</code>, <code class="literal">facingMode</code>, <code class="literal">frameRate</code>, <code class="literal">height</code>, and <code class="literal">width</code>. If a constraint is not provided, then its default value is used.</p><p>You can simply set the <code class="literal">audio</code> or <code class="literal">video</code> property to <code class="literal">false</code> if you don't want to create the audio or video tracks respectively.</p><p>We can retrieve the tracks of <code class="literal">MediaStream</code> using the <code class="literal">getTracks()</code> method of <code class="literal">MediaStream</code>. Similarly, we can add or remove a track using the <code class="literal">addTrack()</code> and <code class="literal">removeTrack()</code> methods, respectively. Whenever a track is added, the <code class="literal">onaddtrack</code> event is triggered. Similarly, whenever a track is removed, the <code class="literal">onendtrack</code> is triggered.</p><p>If we already have some tracks, then we can directly use the <code class="literal">MediaStream</code> constructor to create <code class="literal">MediaStream</code> with the tracks. The <code class="literal">MediaStream</code> constructor takes an array of tracks and returns <code class="literal">MediaStream</code> with the reference of the tracks added to it.</p><p>An API that reads data from tracks of <code class="literal">MediaStream</code> is called a <code class="literal">MediaStream</code> consumer. Some of the <code class="literal">MediaStream</code> consumers are the <code class="literal">&lt;audio&gt;</code> tag, <code class="literal">&lt;video&gt;</code> tag, <code class="literal">RTCPeerConnection</code>, <code class="literal">Media Recorder</code> API, <code class="literal">Image Capture</code> API, <code class="literal">Web Audio</code> API, and so on.</p><p>Here is an example that demonstrates how to display data of tracks of <code class="literal">MediaStream</code> in the video tag:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;body&gt;

    &lt;video id="myVideo"&gt;&lt;/video&gt;
    &lt;br&gt;
    &lt;input value="Pause" onclick="pause()" type="button" /&gt;

    &lt;script type="text/javascript"&gt;

      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

      var constraints = {
        audio: true, 
        video: true
      }

      var av_stream = null;

      navigator.getUserMedia(constraints, function(mediastream){

        av_stream = mediastream;

        document.getElementById("myVideo").setAttribute("src", URL.createObjectURL(mediastream));
        document.getElementById("myVideo").play();
      }, function(err){
        console.log("Failed to get MediaStream", err);
      });

      function pause()
      {
        av_stream.getTracks()[0].enabled = !av_stream.getTracks()[0].enabled;
        av_stream.getTracks()[1].enabled = !av_stream.getTracks()[1].enabled;
      }

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Here <a id="id100" class="indexterm"/>we have a <code class="literal">&lt;video&gt;</code> tag and a button to pause it. A video tag takes a URL <a id="id101" class="indexterm"/>and displays the resource.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Before HTML5, HTML tags and CSS attributes could only read data from <code class="literal">http://</code> and <code class="literal">file://</code> URLs. However, in HTML5, they can read <code class="literal">blob://</code>, <code class="literal">data://</code>, <code class="literal">mediastream://</code>, and other such URLs.</p></div></div><p>To display the <a id="id102" class="indexterm"/>output of <code class="literal">MediaStream</code> in the <code class="literal">&lt;video&gt;</code> tag, we need to use the <code class="literal">URL.createObjectURL()</code> method, which takes a blob, file object, or <code class="literal">MediaStream</code> and provides <a id="id103" class="indexterm"/>a URL to read its data. <code class="literal">URL.createObjectURL()</code> takes extra memory and CPU time to provide access to the value passed on to it via a URL, therefore, it is wise to release the URL using <code class="literal">URL.revokeObjectURL()</code> when we don't need the URL anymore.</p><p>If there are multiple audio and video tracks in <code class="literal">MediaStream</code>, then <code class="literal">&lt;video&gt;</code> reads the first audio and video tracks.</p></div><div class="section" title="RTCPeerConnection API"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>RTCPeerConnection API</h2></div></div></div><p>
<code class="literal">RTCPeerConnection</code> allows <a id="id104" class="indexterm"/>two browsers to exchange <a id="id105" class="indexterm"/>
<code class="literal">MediaStream</code> in real time. <code class="literal">RTCPeerConnection</code> is an instance of the <code class="literal">RTCPeerConnection</code> constructor.</p><div class="section" title="Establishing peer-to-peer connection"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Establishing peer-to-peer connection</h3></div></div></div><p>For a <a id="id106" class="indexterm"/>peer-to-peer connection to be established, a signaling <a id="id107" class="indexterm"/>server is needed. Through the signaling server, the peers exchange data required to establish a peer-to-peer connection. Actual data transfer takes place directly between peer-to-peer. The signaling server is just used to exchange pre-requirements to establish a peer-to-peer connection. Both the peers can disconnect from the signaling server once the peer-to-peer connection has been established. The signaling server doesn't need to be a highly configured server as the actual data is not transferred through it. Data transfer for a single peer-to-peer connection will be in some KB, so a decent server can be used for signaling.</p><p>A signaling server usually uses a signaling protocol, but it is also okay if it's an HTTP server as long as it can pass messages between two peers. WebRTC doesn't force us to use any particular signaling protocol.</p><p>For example, say that there are two users, Alice and Bob, on two different browsers. If Alice wants to establish a peer-to-peer connection with Bob for chatting, then this is how a peer-to-peer connection would be established between them:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">They both will connect to a signaling server.</li><li class="listitem">Alice will then send a request to Bob via the signaling server, requesting to chat.</li><li class="listitem">The signaling server can optionally check whether Alice is allowed to chat with Bob, and also if Alice and Bob are logged in. If yes, then the signaling server passes the message to Bob.</li><li class="listitem">Bob receives the request and sends a message to Alice via the signaling server, confirming to establish a peer-to-peer connection.</li><li class="listitem">Now both of them need to exchange messages related to session control, network configuration, and media capabilities. All these messages are exchanged between them by the <code class="literal">RTCPeerConnection</code>. So, they both need to create an <code class="literal">RTCPeerConnection</code>, initiate it, and attach an event handler to <code class="literal">RTCPeerConnection</code> that will be triggered by <code class="literal">RTCPeerConnection</code> when it wants to send a message via the signaling server. <code class="literal">RTCPeerConnection</code> passes <a id="id108" class="indexterm"/>the message to the event handler in the <span class="strong"><strong>Session Description Protocol</strong></span> (<span class="strong"><strong>SDP</strong></span>) format, and the messages for the <code class="literal">RTCPeerConnection</code> received from the signaling server must be fed to <code class="literal">RTCPeerConnection</code> in the SDP format, that is, <code class="literal">RTCPeerConnection</code> only understands the SDP format. You need to use your own programming logic to split custom messages and messages for <code class="literal">RTCPeerConnection</code>.</li></ol></div><p>The <a id="id109" class="indexterm"/>preceding steps seem to <a id="id110" class="indexterm"/>have no problem; however, there are some major problems. The peers may be behind a NAT device or firewall, so finding their public IP address is a challenging task, sometimes it is practically impossible to find their IP address. So, how does <code class="literal">RTCPeerConnection</code> find an IP address of the peers when they may be behind a NAT device or firewall?</p><p>
<code class="literal">RTCPeerConnection</code> uses <a id="id111" class="indexterm"/>a technique called <span class="strong"><strong>Interactive Connectivity Establishment </strong></span>(<span class="strong"><strong>ICE</strong></span>) to resolve all these issues.</p><p>ICE <a id="id112" class="indexterm"/>involves <span class="strong"><strong>Session Traversal Utilities for NAT</strong></span> (<span class="strong"><strong>STUN</strong></span>) and <span class="strong"><strong>Traversal Using Relays around NAT</strong></span> (<span class="strong"><strong>TURN</strong></span>) server <a id="id113" class="indexterm"/>to solve the problems. A STUN server is used to find the public IP address of a peer. In case the IP address of a peer cannot be found, or due to some other reason a peer-to-peer cannot be established, then a TURN server is used to redirect the traffic, that is, both the peers communicate via the TURN server.</p><p>We just need to provide the addresses of the STUN and TURN servers and <code class="literal">RTCPeerConnection</code> handles the rest. Google provides a public STUN server, which is used by everyone. Building a TURN server requires a lot of resources as the actual data flows throw it. Therefore, WebRTC makes it optional to use a TURN server. If <code class="literal">RTCPeerConnection</code> fails to establish a direct communication between two peers and a TURN server is not provided, there is no other way for the peers to communicate and a peer-to-peer connection establishment fails.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>WebRTC doesn't provide any way to make signaling secure. It's your job to make the signaling secure.</p></div></div></div><div class="section" title="Transferring MediaStream"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Transferring MediaStream</h3></div></div></div><p>We saw <a id="id114" class="indexterm"/>how <code class="literal">RTCPeerConnection</code> establishes a peer-to-peer <a id="id115" class="indexterm"/>connection. Now, to transfer <code class="literal">MediaStream</code>, we just need to pass the reference of <code class="literal">MediaStream</code> to <code class="literal">RTCPeerConnection</code> and it will transfer <code class="literal">MediaStream</code> to the connected peer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>When we say that <code class="literal">MediaStream</code> is transferred, we mean the stream of individual tracks is transferred.</p></div></div><p>The following are some of the things you need to know regarding the transfer of <code class="literal">MediaStream</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RTCPeerConnection</code> uses SRTP as an application layer protocol and UDP as a transport layer protocol to transfer <code class="literal">MediaStream</code>. SRTP is designed for media stream transfer in real time.</li><li class="listitem" style="list-style-type: disc">UDP doesn't guarantee the order of packets, but SRTP takes care of the order of the frames.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Datagram Transport Layer Security</strong></span> (<span class="strong"><strong>DTLS</strong></span>) protocol is used to secure <a id="id116" class="indexterm"/>the <code class="literal">MediaStream</code> transfer. So, you don't have to worry about the security while transferring <code class="literal">MediaStream</code>.</li><li class="listitem" style="list-style-type: disc">Constraints of the tracks that the remote peer receives may be different from the constraints of the local tracks, as <code class="literal">RTCPeerConnection</code> modifies the stream automatically, depending on the bandwidth and other network factors to speed up the transfer, achieving real-time data transfer. For example, <code class="literal">RTCPeerConnection</code> may decrease the resolution and frame rate of video stream while transferring.</li><li class="listitem" style="list-style-type: disc">If you add or remove a track from <code class="literal">MediaStream</code> that is already being sent, then <code class="literal">RTCPeerConnection</code> updates <code class="literal">MediaStream</code> of the other peer by communicating to the other peer via the signaling server.</li><li class="listitem" style="list-style-type: disc">If you pause a track that is being sent, then <code class="literal">RTCPeerConnection</code> pauses transfer of the track.</li><li class="listitem" style="list-style-type: disc">If you stop a track that is being sent, <code class="literal">RTCPeerConnection</code> stops the transfer of the track.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>You can send and receive multiple <code class="literal">MediaStream</code> instances via single <code class="literal">RTCPeerConnection</code>, that is, you <a id="id117" class="indexterm"/>don't have <a id="id118" class="indexterm"/>to create multiple <code class="literal">RTCPeerConnection</code> instances to send and receive multiple <code class="literal">MediaStream</code> instances to and from a peer. Whenever you add or remove a new <code class="literal">MediaStream</code> to or from <code class="literal">RTCPeerConnection</code>, the peers exchange information related to this via the signaling server.</p></div></div></div></div><div class="section" title="RTCDataChannel API"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>RTCDataChannel API</h2></div></div></div><p>
<code class="literal">RTCDataChannel</code> is <a id="id119" class="indexterm"/>used to transfer data other than <code class="literal">MediaStream</code> between <a id="id120" class="indexterm"/>peers to transfer arbitrary data. The mechanism to establish a peer–to-peer connection to transfer arbitrary data is similar to the mechanism explained in the earlier section.</p><p>
<code class="literal">RTCDataChannel</code> is an object that implements the <code class="literal">RTCDataChannel</code> interface.</p><p>The following are some of the things you need to know regarding <code class="literal">RTCDataChannel</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RTCDataChannel</code> uses SCTP over UDP as a transport layer protocol to transfer data. It doesn't use unlayered SCTP protocol as the SCPT protocol is not supported by many operating systems.</li><li class="listitem" style="list-style-type: disc">SCTP can be configured for reliability and delivery order, unlike UDP, which is unreliable and unordered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">RTCDataChannel</code> also uses DTLS to secure data transfer. So, you don't have to worry about the security at all while transferring data via <code class="literal">RTCDataChannel</code>.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>We can have multiple peer-to-peer connections open between browsers. For example, we can have three peer-to-peer connections, that is, first one for webcam stream transfer, second one for text message transfer, and third one for file transfer.</p></div></div></div></div>
<div class="section" title="WebRTC applications using PeerJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>WebRTC applications using PeerJS</h1></div></div></div><p>
<span class="strong"><strong>PeerJS</strong></span> is a <a id="id121" class="indexterm"/>client-side JavaScript library <a id="id122" class="indexterm"/>that provides <a id="id123" class="indexterm"/>an easy-to-use API to work with WebRTC. It only provides an API to exchange <code class="literal">MediaStream</code> and arbitrary data between peers. It doesn't provide an API to work with <code class="literal">MediaStream</code>.</p><div class="section" title="PeerServer"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>PeerServer</h2></div></div></div><p>
<span class="strong"><strong>PeerServer</strong></span> is <a id="id124" class="indexterm"/>an open source signaling server used by PeerJS to establish a peer-to-peer connection. PeerServer is written in Node.js. If you don't want to run your own PeerServer instance, then you can use PeerServer cloud, which hosts PeerServer for public use. PeerServer cloud allows you to establish a maximum of 50 concurrent connections for free.</p><p>A unique ID identifies every peer connected to PeerServer. PeerServer itself can generate the ID, or else the peers can provide their own ID. For a peer to establish a peer-to-peer connection with another peer, it just needs to know the other peer's ID.</p><p>You might want to run your own PeerServer instance when you want to add more functionality to PeerServer or you want to support more than 50 concurrent connections. For example, if you want to check whether the user is logged in to PeerServer, then you need to add this feature and host your own customized PeerServer.</p><p>In this chapter, we will use PeerServer cloud, but in the next chapter, we will create our own instance of PeerServer. Therefore, to continue further with this chapter, create an account on the PeerServer cloud and retrieve the API key. Every application gets an API key to access the PeerServer cloud. If you are hosting your own PeerServer, then you won't need an API key. The API key is used by PeerServer cloud to track the total connections <a id="id125" class="indexterm"/>established by an application. To create an account and retrieve an API key, visit <a class="ulink" href="http://peerjs.com/peerserver">http://peerjs.com/peerserver</a>.</p></div><div class="section" title="PeerJS API"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>PeerJS API</h2></div></div></div><p>Let's discuss <a id="id126" class="indexterm"/>the PeerJS API by creating a simple app that allows the users to exchange video and text messages with any user whose ID they have.</p><p>Create a <code class="literal">peerjs-demo</code> directory in your web server and place a file named <code class="literal">index.html</code> in it.</p><p>In the <code class="literal">index.html</code> file, we <a id="id127" class="indexterm"/>need to first enqueue the <code class="literal">PeerJS</code> library. Download <code class="literal">PeerJS</code> from <a class="ulink" href="http://peerjs.com/">http://peerjs.com/</a>. At the time of writing, the latest version of PeerJS was 0.3.14. I would recommend that you stick to this version for the following examples. Place this starting code in the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;PeerJS Demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;!-- Place HTML code here --&gt;

    &lt;script src="peer.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      //place JavaScript code here
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Here, I enqueued the minified version of PeerJS.</p><p>PeerJS API <a id="id128" class="indexterm"/>comprises of three main constructors, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Peer</code>: An instance <a id="id129" class="indexterm"/>of <code class="literal">Peer</code> represents a peer in the network. A peer is connected to the signaling server and STUN, and optionally, to a TURN.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DataConnection</code>: DataConnection (that is, the instance of <code class="literal">DataConnection</code>) represents <a id="id130" class="indexterm"/>a peer-to-peer connection, which is used to exchange the arbitrary data. Technically, it wraps <code class="literal">RTCDataChannel</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MediaConnection</code>: MediaConnection (that is, the instance of <code class="literal">MediaConnection</code>) represents <a id="id131" class="indexterm"/>a peer-to-peer connection that is used to exchange <code class="literal">MediaStream</code>. Technically, it wraps <code class="literal">RTCPeerConnection</code>.</li></ul></div><p>If a peer wants to establish <code class="literal">DataConnection</code> or <code class="literal">MediaConnection</code> with another peer, then it simply needs to know the other peer's ID. PeerJS doesn't give the other peer an option to accept or reject <code class="literal">DataConnection</code>. Also, in the case of <code class="literal">MediaConnection</code>, PeerJS doesn't give the other peer an option to accept or reject <code class="literal">MediaConnection</code>, but <code class="literal">MediaConnection</code> will be inactive until it is activated programmatically by the other peer so that <code class="literal">MediaStream</code> can be transferred, otherwise <code class="literal">MediaStream</code> will not be transferred. So, we can write our own logic to let the other user accept or reject <code class="literal">DataConnection</code> or <code class="literal">MediaConnecton</code>, that is, as soon as <code class="literal">DataConnection</code> or <code class="literal">MediaConnection</code> is established, we can cancel it by asking the user for their opinion.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>At present, one <code class="literal">MediaConnection</code> can transfer only one <code class="literal">MediaStream</code>. In future releases of PeerJS, a single <code class="literal">MediaConnection</code> will support the transfer of multiple MediaStreams.</p></div></div><p>Now, we need to create a <code class="literal">&lt;video&gt;</code> tag where the video will be displayed, a button to connect to a peer, and also a text box to send message. Here is the HTML code to display all these:</p><div class="informalexample"><pre class="programlisting">&lt;video id="remoteVideo"&gt;&lt;/video&gt;
&lt;br&gt;
&lt;button onclick="connect()"&gt;Connect&lt;/button&gt;
&lt;br&gt;
&lt;input type="text" id="message"&gt;
&lt;button onclick="send_message()"&gt;Send Message&lt;/button&gt;</pre></div><p>Now as <a id="id132" class="indexterm"/>soon as the page loads, we need to connect to <code class="literal">PeerServer</code> and ICE servers so that other peers can talk to us, and also when a user clicks on the connect button, we can establish <code class="literal">DataConnection</code> and <code class="literal">MediaConnection</code>. The following is the code for this:</p><div class="informalexample"><pre class="programlisting">var peer = null;

window.addEventListener("load", function(){
  var id = prompt("Please enter an unique name");
  
  peer = new Peer(id, {key: "io3esxy6y43zyqfr"}); 

  peer.on("open", function(id){
    alert("Connected to PeerServer successfully with ID: " + id);
  });

  peer.on("error", function(err){
    alert("An error occured. Error type: " + err.type);
  })

  peer.on("disconnected", function(){
    alert("Disconnected from signaling server. You ID is taken away. Peer-to-peer connections is still intact");
  })

  peer.on("close", function(){
    alert("Connection to signaling server and peer-to-peer connections have been killed. You ID is taken away. You have been destroyed");
  })

  peer.on("connection", function(dataConnection){
    setTimeout(function(){
      if(confirm(dataConnection.peer + " wants to send data to you. Do you want to accept?"))
      {
        acceptDataConnection(dataConnection);
      }
      else
      {
        dataConnection.close();
      }
    }, 100)
  })

  peer.on("call", function(mediaConnection){
    setTimeout(function(){
      if(confirm("Got a call from " + mediaConnection.peer + ". Do you want to pick the call?"))
      {
        acceptMediaConnection(mediaConnection);
      }
      else
      {
        mediaConnection.close();
      }
    }, 100);
  })
});</pre></div><p>Here is <a id="id133" class="indexterm"/>how the code works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First we displayed a prompt box to take the ID as an input so that every peer can decide their own ID.</li><li class="listitem" style="list-style-type: disc">Then we created an instance of <code class="literal">Peer</code> with ID and PeerServer cloud key. Here we didn't provide signaling and ICE server's URLs, therefore, PeerJS will use PeerServer cloud as the signaling server and Google's public STUN server. It will not use any TURN server. As soon as a <code class="literal">Peer</code> instance is created, the instance connects to the signaling server and registers the given ID.</li><li class="listitem" style="list-style-type: disc">Then we attached five event handlers to the <code class="literal">peer</code> object.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> open</code> event is triggered when the connection to <code class="literal">PeerServer</code> was successful.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> error</code> event is triggered for errors on the <code class="literal">peer</code> object.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> disconnected</code> event is triggered when the connection with the signaling server is disconnected. The connection with the signaling server may get disconnected due to network problem or if you manually call the <code class="literal">peer.disconnect()</code> method. Once you are disconnected, your ID can be taken by someone else. You can try to reconnect with the same ID using the <code class="literal">peer.reconnect()</code> method. You can check whether <code class="literal">peer</code> is connected to the signaling server using the <code class="literal">peer.disconnect</code> Boolean property.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> close</code> event is triggered when <code class="literal">peer</code> is destroyed, that is, it cannot be used anymore, all <code class="literal">MediaConnections</code> and <code class="literal">DataConnections</code> are killed, connection with the signaling server is killed, the ID is taken away, and so on. You may want to manually destroy <code class="literal">peer</code> when you don't need it anymore. You can <a id="id134" class="indexterm"/>destroy a peer using the <code class="literal">peer.destroy()</code> method.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> connection</code> event is triggered when some other peer establishes <code class="literal">DataConnection</code> with you. As I said earlier, <code class="literal">DataConnection</code> is established without further permission, but you can close it as soon as it's established if you want. Here we let the user decide if they want to continue or close <code class="literal">DataConnection</code> established by another peer. The event handler attached to the event receives an instance of <code class="literal">DataConnection</code> via the parameter that represents the currently established <code class="literal">DataConnection</code>.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> call</code> event is triggered when some other peer establishes <code class="literal">MediaConnection</code> with you. Here, we also let the user decide if they want to continue or close <code class="literal">MediaConnection</code> established by another peer. The event handler attached to the event receives an instance of <code class="literal">MediaConnection</code> via the parameter that represents the currently established <code class="literal">MediaConnection</code>.</li><li class="listitem" style="list-style-type: disc">Here, in the <code class="literal">call</code> and <code class="literal">connection</code> event handlers, we asynchronously displayed the confirm popup boxes to prevent blocking the execution of the event handler that causes issues in some browsers, that is, blocking it fails to establish <code class="literal">DataConnection</code> and <code class="literal">MediaConnection</code>.</li></ul></div><p>Now, let's implement the <code class="literal">acceptDataConnection()</code> and <code class="literal">acceptMediaConnection()</code> functions so that we can display the text messages and remote <code class="literal">MediaStream</code> when other peer establishes <code class="literal">DataConnection</code> or <code class="literal">MediaConnection</code> with us. Here's the code:</p><div class="informalexample"><pre class="programlisting">navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

var myDataConnection = null;
var myMediaConnection = null;

function acceptDataConnection(dataConnection)
{
  myDataConnection = dataConnection;

  dataConnection.on("data", function(data){
    alert("Message from " + dataConnection.peer + ".\n" + data)
  })

  dataConnection.on("close", function(data){
    alert("DataConnecion closed");
  })

  dataConnection.on("error", function(err){
    alert("Error occured on DataConnection. Error: " + err);
  })
}

function acceptMediaConnection(mediaConnection)
{
  myMediaConnection = mediaConnection;

  mediaConnection.on("stream", function(remoteStream){

    document.getElementById("remoteVideo").setAttribute("src", URL.createObjectURL(remoteStream));
    document.getElementById("remoteVideo").play();
  })

  mediaConnection.on("close", function(data){
    alert("MediaConnecion closed");
  })

  mediaConnection.on("error", function(err){
    alert("Error occured on MediaConnection. Error: " + err);
  })

  navigator.getUserMedia({video: true, audio: true}, function(mediaStream) {
    mediaConnection.answer(mediaStream);
  }, function(e){ alert("Error with MediaStream: " + e); });
}</pre></div><p>This is <a id="id135" class="indexterm"/>how the preceding code works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">acceptDataConnection()</code> function, we attached three event handlers to <code class="literal">DataConnection</code>. The <code class="literal">data</code> event is triggered when the other peer sends us data. The <code class="literal">close</code> event is triggered when <code class="literal">DataConnection</code> is closed. Finally, the <code class="literal">error</code> event is triggered when an error occurs on <code class="literal">DataConnection</code>. We can manually close <code class="literal">DataConnection</code> using the <code class="literal">dataConnection.close()</code> method.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">acceptMediaConnection()</code> function, we attached three event handlers and transferred our <code class="literal">MediaStream</code> to the other peer. The <code class="literal">stream</code> event is triggered when other peer sends us <code class="literal">MediaStream</code>. The <code class="literal">close</code> event is triggered when <code class="literal">MediaConnection</code> is closed. Finally, we activated <code class="literal">MediaConnection</code> using the <code class="literal">mediaConnection.answer()</code> method by passing our <code class="literal">MediaStream</code>. After <code class="literal">MediaConnection</code> is activated, the <code class="literal">stream</code> event will be triggered.</li></ul></div><p>We finished writing the code to handle <code class="literal">MediaConnection</code> or <code class="literal">DataConnection</code> established <a id="id136" class="indexterm"/>by another peer with us. Now we need to write a code to create <code class="literal">MediaConnection</code> and <code class="literal">DataConnection</code> that a user clicks on the <span class="strong"><strong>connect</strong></span> button. Here is the code:</p><div class="informalexample"><pre class="programlisting">function connect()
{
  var id = prompt("Please enter other peer ID");
  establishDataConnection(id);
  establishMediaConnection(id);
}

function establishDataConnection(id)

{
  var dataConnection = peer.connect(id, {reliable: true, ordered: true});

  myDataConnection = dataConnection;

  dataConnection.on("open", function(){
    alert("DataConnecion Established");
  });

  dataConnection.on("data", function(data){
    alert("Message from " + dataConnection.peer + ".\n" + data)
  })

  dataConnection.on("close", function(data){
    alert("DataConnecion closed");
  })

  dataConnection.on("error", function(err){
    alert("Error occured on DataConnection. Error: " + err);
  })
}

function establishMediaConnection(id)
{
  var mediaConnection = null;

  navigator.getUserMedia({video: true, audio: true}, function(mediaStream) {
    mediaConnection = peer.call(id, mediaStream);

    myMediaConnection = mediaConnection;

    mediaConnection.on("stream", function(remoteStream){
      document.getElementById("remoteVideo").setAttribute("src", URL.createObjectURL(remoteStream));
      document.getElementById("remoteVideo").play();
    })

    mediaConnection.on("error", function(err){
      alert("Error occured on MediaConnection. Error: " + err);
    })

    mediaConnection.on("close", function(data){
      alert("MediaConnecion closed");
    })
  }, function(e){ alert("Error with MediaStream: " + e); });
}</pre></div><p>Here is <a id="id137" class="indexterm"/>how the code works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First we asked the user to input another user's ID.</li><li class="listitem" style="list-style-type: disc">Then we established <code class="literal">DataConnection</code>. To establish a <code class="literal">DataConnection</code> with another user, we need to invoke the <code class="literal">connect()</code> method of the <code class="literal">Peer</code> instance with other peer's ID. We also made <code class="literal">DataConnection</code> reliable and ordered. Then, we attached the event handlers. We also saw how <code class="literal">data</code>, <code class="literal">close</code>, and <code class="literal">error</code> events work. The <code class="literal">open</code> event is triggered when <code class="literal">DataConnection</code> is established.</li><li class="listitem" style="list-style-type: disc">After establishing the <code class="literal">DataConnection</code>, we established <code class="literal">MediaConnection</code>. To establish <code class="literal">MediaConnection</code>, we need to call the <code class="literal">call()</code> method of the <code class="literal">Peer</code> instance. We need to pass <code class="literal">MediaStream</code> to the <code class="literal">call()</code> method. Finally, we attached the event handlers. The <code class="literal">stream</code> event will be triggered when the other user calls the <code class="literal">answer()</code> method of the <code class="literal">MediaConnection</code> instance, that is, when the MediaConnection is activated.</li></ul></div><p>Now the last thing we need to do is write the code to send the message when a user clicks on the send message button. Here is the code for this:</p><div class="informalexample"><pre class="programlisting">function send_message()
{
  var text = document.getElementById("message").value;

  myDataConnection.send(text);
}</pre></div><p>To send data via <code class="literal">MediaConnection</code>, we need to call the <code class="literal">send()</code> method of the <code class="literal">MediaConnection</code> instance. Here, we are sending a string, but you can pass any type of data including blobs and objects.</p><p>Now, to test the application, open the <code class="literal">index.html</code> page URL in two different browsers, devices, or tabs. I am assuming that you have opened the URL in two different devices. In each device, provide a different ID to identify the user. Then click on the connect button in any one device and enter the other peer's ID. Now accept the request on the other device. Once this is done, both the devices will be able to display each other's webcam video and microphone audio. You can also send messages between them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>You <a id="id138" class="indexterm"/>can find the official documentation of PeerJS API at <a class="ulink" href="http://peerjs.com/docs/#api">http://peerjs.com/docs/#api</a>.</p></div></div></div></div>
<div class="section" title="Miscellaneous"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Miscellaneous</h1></div></div></div><p>At the time of writing this book, the WebRTC specifications were still not finalized. The overall idea of what WebRTC does and how WebRTC works has been finalized. It's just that the APIs are still under development.</p><p>For example, WebRTC has introduced an alternative to the <code class="literal">navigator.getUserMedia()</code> method, that is, the <code class="literal">navigator.mediaDevices.getUserMedia()</code> method. At the time of writing this book, <code class="literal">navigator.mediaDevices.getUserMedia()</code> is not supported in any browsers. The difference between them is that the <code class="literal">navigator.mediaDevices.getUserMedia()</code> method is based on the promise pattern, whereas <code class="literal">navigator.getUserMedia()</code> is based on the callback pattern. At present, there is no plan to get rid of <code class="literal">navigator.getUserMedia()</code> due to the backward compatibility reason, but in future, <code class="literal">navigator.getUserMedia()</code> may be removed as WebRTC wants to implement all APIs using the promise pattern, therefore, it's difficult to maintain multiple APIs that do the same thing. Similarly, <code class="literal">navigator.mediaDevices.enumerateDevice()</code> is an alternative to <code class="literal">MediaStreamTrack.getSources()</code>, that is, <code class="literal">navigator.mediaDevices.enumerateDevice()</code> is based on the promise pattern.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>You <a id="id139" class="indexterm"/>can find the official specification of WebRTC at <a class="ulink" href="http://www.w3.org/TR/#tr_Web_Real_Time_Communication">http://www.w3.org/TR/#tr_Web_Real_Time_Communication</a>.</p></div></div><p>Due to the fact that there are multiple APIs for the same feature, each with a different browser support, WebRTC provides a script called <code class="literal">adapter.js</code>, which is a shim to insulate websites <a id="id140" class="indexterm"/>from specification changes and prefix differences. You can find the shim at <a class="ulink" href="https://github.com/webrtc/adapter">https://github.com/webrtc/adapter</a>.</p><p>WebRTC has a GitHub repository <a id="id141" class="indexterm"/>where it puts a lot of example projects showing some of the things that can be built using WebRTC. You can find the repository at <a class="ulink" href="https://github.com/webrtc/samples">https://github.com/webrtc/samples</a>. Just by looking at the examples and their source code, you can learn a lot more about WebRTC.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we discussed the fundamentals of WebRTC and PeerJS by creating a simple app. We discussed the various protocols, techniques, and other technologies that WebRTC uses to enable real-time peer-to-peer communication and read streams of physical media sources. We also saw an overview of PeerServer. Now you must be comfortable with building any type of WebRTC app using PeerServer cloud.</p><p>In the next chapter, we will build an advanced WebRTC app using a custom PeerServer. </p></div></body></html>