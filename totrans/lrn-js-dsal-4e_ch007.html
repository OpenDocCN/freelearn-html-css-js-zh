<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>
<link rel="stylesheet" type="text/css" href="../override_v1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/><link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section id="linked-lists" class="level1 pkt" data-number="7">
<h1 data-number="7">6 Linked Lists</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="../media/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p>In previous chapters, we explored data structures stored sequentially in memory. Now, we turn our attention to linked lists, a dynamic and linear data structure with a non-sequential memory arrangement. This chapter delves into the inner workings of linked lists, covering:</p>
<ul>
<li>The linked list data structure</li>
<li>Techniques for adding and removing elements from linked lists</li>
<li>Variations of linked lists: doubly linked lists, circular linked lists and sorted linked lists</li>
<li>How linked lists can be used to implement other data structures</li>
<li>Implementing other data structures with linked lists</li>
<li>Exercises using linked lists</li>
</ul>
<section id="the-linked-list-data-structure" class="level2" data-number="7.1">
<h2 data-number="7.1">The linked list data structure</h2>
<p>Arrays, a ubiquitous data structure found in nearly every programming language, offer a convenient way to store collections of elements. Their familiar bracket notation (<code>[]</code>) provides direct access to individual items. However, arrays come with a key limitation: their fixed size in most languages. This constraint makes inserting or removing elements from the beginning or middle a costly operation due to the need to shift remaining elements. While JavaScript provides methods to handle this, the underlying process still involves these shifts, impacting performance.</p>
<p>Linked lists, like arrays, maintain a sequential collection of elements. However, unlike arrays where elements occupy contiguous memory locations, linked lists store elements as nodes scattered throughout memory. Each node encapsulates the element's data (the information or value we want to store) along with a reference (also called a pointer or link) that directs you to the next node in the sequence. The following diagram illustrates this linked list structure:</p>
<figure>
<img src="../media/file28.png" alt="The structure of a linked list data structure with nodes, data and pointers" width="1212" height="259"/><figcaption aria-hidden="true">The structure of a linked list data structure with nodes, data and pointers</figcaption>
</figure>
<p>The first node is called the <em>head</em>, and the last node usually points to <code>null</code> (or <code>undefined</code>) to indicate the end of the list.</p>
<p>A key advantage of linked lists over conventional arrays is the ability to insert or remove elements without the costly overhead of shifting other items. However, this flexibility comes with the tradeoff of using pointers, requiring greater care during implementation. While arrays allow direct access to elements at any position, linked lists necessitate traversal from the head to reach elements in the middle, potentially impacting access time.</p>
<p>However, linked lists are not the best data structure if you need to access elements by their index (like we do with arrays). This is because we need to traverse the list from the beginning, which can be slower. Linked lists also require additional memory for storage, as each node requires extra memory to store the pointer(s), which can be overhead for simple data.</p>
<p>Linked lists have numerous real-world applications due to their flexibility and efficiency in handling dynamic data. One of the popular examples are media players. Media players use linked lists to organize and manage playlists. Adding, removing, and rearranging songs or videos are straightforward operations on a linked list as represented as follows:</p>
<figure>
<img src="../media/file29.png" alt="A media player representation using linked list as data structure" width="585" height="543"/><figcaption aria-hidden="true">A media player representation using linked list as data structure</figcaption>
</figure>
<p>There are different types of linked lists:</p>
<ul>
<li><strong>Singly Linked List</strong> (or simply Linked List): each node has a pointer to the next node.</li>
<li><strong>Doubly Linked List</strong>: Each node has pointers to both the next and previous nodes.</li>
<li><strong>Circular Linked List</strong>: The last node points back to the head, forming a loop.</li>
</ul>
<p>In this chapter, we will cover the linked list as well as these variations, but let's start with the easiest data structure first.</p>
</section>
<section id="creating-the-linkedlist-class" class="level2" data-number="7.2">
<h2 data-number="7.2">Creating the LinkedList class</h2>
<p>Now that you understand what a linked list is, let's start implementing our data structure. We are going to create our own class to represent a linked list. The source code for this chapter is available inside the <code>src/06-linked-list</code> folder. We will start by creating the <code>linked-list.js</code> file which will contain our class that represents our data structure as well the node needed to store the data and the pointer.</p>
<p>To start, we define a <code>LinkedListNode</code> class, which represents each element (or node) within our linked list. Each node holds the <code>data</code> we want to store, along with a reference (<code>next</code>) pointing to the subsequent node:</p>
<div class="C0-SHCodePACKT">
<pre><code>class LinkedListNode {
  constructor(data, next = null) {
    this.data = data;
    this.next = next;
  }
}</code></pre>
</div>
<p>By default, a newly created node's <code>next</code> pointer is initialized to <code>null</code>. However, the constructor also allows you to specify the next node if it is known beforehand, proving beneficial in certain scenarios.</p>
<p>Next, we declare the <code>LinkedList</code> class which represents our linked list data structure:</p>
<div class="C0-SHCodePACKT">
<pre><code>class LinkedList {
  #head;
  #size = 0;
  // other methods
} </code></pre>
</div>
<p>This class begins by declaring a private <code>#head</code> reference, pointing to the first node (element) in the list. To avoid traversing the entire list whenever we need the element count, we also maintain a private <code>#size</code> variable. Both properties are kept private using the <code>#</code> prefix to ensure encapsulation.</p>
<p>The <code>LinkedList</code> class will provide the following methods:</p>
<ul>
<li><code>append(data)</code>: adds a new node containing the <code>data</code> at the end of the list.</li>
<li><code>prepend(data)</code>: adds a new node containing the <code>data</code> at the beginning (head) of the list.</li>
<li><code>insert(data, position)</code>: inserts a new node containing the <code>data</code> at the specified <code>position</code> in the list.</li>
<li><code>removeAt(position)</code>: removes the node at the specific <code>position</code> in the list.</li>
<li><code>remove(data)</code>: removes the first node containing the specified <code>data</code> from the list.</li>
<li><code>indexOf(data)</code>: returns the index of the first node containing the specified <code>data</code>. If the <code>data</code> is not found, returns <code>-1</code>.</li>
<li><code>isEmpty()</code>: returns <code>true</code> if the list does not contain any elements, and <code>false</code> otherwise.</li>
<li><code>clear()</code>:removes all the elements from the list.</li>
<li><code>size()</code>:returns the number of elements currently in the list.</li>
<li><code>toString()</code>:returns a string representation of the linked list, showing the elements in order.</li>
</ul>
<p>We will implement each of these methods in detail in the following sections.</p>
<section id="appending-elements-to-the-end-of-the-linked-list" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1">Appending elements to the end of the linked list</h3>
<p>When appending an element at the end of a LinkedList, we encounter two scenarios:</p>
<ul>
<li>Empty list: the list has no existing elements, and we are adding the first one.</li>
<li>Non-empty list: the list already contains elements, and we are adding a new one to the end of the list.</li>
</ul>
<p>The following is the implementation of the <code>append</code> method:</p>
<div class="C0-SHCodePACKT">
<pre><code>append(data) {
  const newNode = new LinkedListNode(data);
  if (!this.#head) {
    this.#head = newNode;
  } else {
    let current = this.#head;
    while (current.next !== null) {
      current = current.next;
    }
    current.next = newNode;
  }
  this.#size++;
}</code></pre>
</div>
<p>Regardless of the list's state, the first step is to create a new node to hold the data.</p>
<p>For the first scenario, we check if the list is empty. The condition <code>!this.#head</code> evaluates to <code>true</code> if the <code>#head</code> pointer is currently <code>null</code> (or <code>undefined</code>), indicating an empty list.</p>
<p>if the list is empty, the newly created node (<code>newNode</code>) becomes the head of the list. Its next pointer will automatically be <code>null</code> since it is the only node in the list.</p>
<p>Let's see a visual representation of these steps:</p>
<figure>
<img src="../media/file30.png" alt="Adding a new element to an empty linked list" width="859" height="217"/><figcaption aria-hidden="true">Adding a new element to an empty linked list</figcaption>
</figure>
<p>In the scenario where our linked list is not empty, we have a reference only to the <code>head</code> (the first node). To append a new element to the end, we need to traverse the list:</p>
<ul>
<li>We start by assigning a temporary variable, often called current, to the <code>head</code> of the list. This variable will act as our pointer as we move through the list.</li>
<li>Using a while loop, we continuously move current to the next node (<code>current.next</code>) as long as <code>current.next</code> is not <code>null</code>. This means we keep moving until we reach the last node, whose next pointer will be <code>null</code>.</li>
<li>Once the loop terminates, <code>current</code> will be referencing the last node. We simply set <code>current.next</code> to our new node, effectively adding it to the end of the list.</li>
</ul>
<p>Finally, we increment the <code>size</code> to reflect the addition of the new node.</p>
<p>The following diagram exemplifies appending an element to the end of a linked list when it is not empty:</p>
<figure>
<img src="../media/file31.png" alt="Adding a new element to the end of a linked list" width="547" height="383"/><figcaption aria-hidden="true">Adding a new element to the end of a linked list</figcaption>
</figure>
</section>
<section id="prepending-a-new-element-to-the-linked-list" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2">Prepending a new element to the linked list</h3>
<p>Adding a new element as the head (beginning) of the linked list is a simple operation:</p>
<div class="C0-SHCodePACKT">
<pre><code>prepend(data) {
  const newNode = new LinkedListNode(data, this.#head);
  this.#head = newNode;
  this.#size++;
}</code></pre>
</div>
<p>The first step is to create a new node to hold the <code>data</code>. Importantly, we pass the current <code>head</code> of the list as the second argument to the constructor. This sets the <code>next</code> pointer of the new node to the current <code>head</code>, establishing the link. If the list is empty, the current head is <code>null</code>, so the new node's <code>next</code> reference will also be <code>null</code>.</p>
<p>Next, we update the <code>head</code> of the list to point to the newly created node (<code>newNode</code>). Since the new node is already linked to the previous head, the entire list is seamlessly adjusted. And finally, we increase the <code>size</code> of the list to reflect the addition of the new node. The following diagram exemplifies this scenario:</p>
<figure>
<img src="../media/file32.png" alt="Prepending a new element to the linked list" width="911" height="299"/><figcaption aria-hidden="true">Prepending a new element to the linked list</figcaption>
</figure>
</section>
<section id="inserting-a-new-element-at-a-specific-position" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3">Inserting a new element at a specific position</h3>
<p>Now, let's explore how to insert an element at any position within the linked list. For this, we will create an <code>insert</code> method, taking both the <code>data</code> and the desired <code>position</code> as parameters:</p>
<div class="C0-SHCodePACKT">
<pre><code>insert(data, position) {
  if (this.#isInvalidPosition(position)) {
    return false;
  }
  const newNode = new LinkedListNode(data);
  if (position === 0) {
    this.prepend(data);
    return true;
  }
  let current = this.#head;
  let previous = null;
  let index = 0;
 
  while (index++ &lt; position) {
    previous = current;
    current = current.next;
  }
 
  newNode.next = current;
  previous.next = newNode;
  this.#size++;
  return true;
}</code></pre>
</div>
<p>We first verify if the provided <code>position</code> is valid using a helper private method, <code>#isInvalidPosition</code>. A valid position is one that falls within the bounds of the list (0 to size-1). If the position is invalid, the method returns <code>false</code> to indicate the failure to insert. The helper method is declared as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>#isInvalidPosition(position) {
  return position &lt; 0 || position &gt;= this.size;
}</code></pre>
</div>
<p>Next, we create the new node that will hold the data we are inserting.</p>
<p>The first scenario is handling the insertion at the head of the list. if the <code>position</code> is 0, it means we're inserting at the beginning of the list. In this case, we can simply call the prepend method we defined earlier and return <code>true</code> for success.</p>
<p>If not inserting at the head, it means we will need to traverse the list. To do so, we will need a helper variable we will name current and set it to the first node (<code>head</code>). We also need a second helper variable to assist with the linkage of the new node we will name <code>previous</code>. And we also initialize an index variable to keep track of our position as we traverse.</p>
<p>Then, we will traverse the list until we reach the desired position. To do so, the <code>while</code> loop iterates until the index matches the <code>position</code>. In each iteration, we move <code>previous</code> to the <code>current</code> node and the <code>current</code> to the <code>next</code> node.</p>
<p>After the loop, <code>previous</code> points to the node before the insertion point, and <code>current</code> points to the node at the insertion point. We adjust the next pointers: <code>newNode.next</code> is set to current (the node that was originally at the insertion point), and <code>previous.next</code> is set to <code>newNode</code>, effectively inserting the new node into the list.</p>
<p>Let's see this scenario in action in the following diagram:</p>
<figure>
<img src="../media/file33.png" alt="Inserting an element in the middle of a linked list" width="1209" height="379"/><figcaption aria-hidden="true">Inserting an element in the middle of a linked list</figcaption>
</figure>
<blockquote>
<p>It is very important to have variables referencing the nodes we need to control so that we do not lose the link between the nodes. We could work with only one variable (<code>previous</code>), but it would be harder to control the links between the nodes. For this reason, it is better to declare an extra variable to help us with these references.</p>
</blockquote>
</section>
<section id="returning-the-position-of-an-element" class="level3" data-number="7.2.4">
<h3 data-number="7.2.4">Returning the position of an element</h3>
<p>Now that we know how to traverse the list until a desired position, it makes easier to traverse the list searching for a particular element and returning its index.</p>
<p>Let's review the <code>indexOf</code> method implementation:</p>
<div class="C0-SHCodePACKT">
<pre><code>indexOf(data, compareFunction = (a, b) =&gt; a === b) {
  let current = this.#head;
  let index = 0;
  while (current) {
    if (compareFunction(current.data, data)) {
      return index;
    }
    index++;
    current = current.next;
  }
  return -1;
}</code></pre>
</div>
<p>We start by creating a variable <code>current</code> to track the node in the list and it is initially set to the head of the list. We also initialize an index variable to 0, representing the current position in the list.</p>
<p>The <code>while</code> loop continues if current is not <code>null</code> (we have not reached the end of the list). In each iteration, we check if the data property of the current node matches the element we are searching for, and if so, it returns the index of the element's position.</p>
<p>We can pass a custom comparison function to the <code>indexOf</code> method. This function should take two arguments (two different objects) and return <code>true</code> if the two objects match according to the desired criteria, or <code>false</code> otherwise. With this function, we gain flexibility and the ability to define exactly how elements are compared, accommodating complex data structures and different matching criteria. By default, we simply compare the references of the objects in case no comparison function is informed.</p>
<blockquote>
<p>Using a comparison function is also a standard practice in other programming languages. If you prefer, instead of passing the function to the method directly, we can have the function in the constructor of the <code>LinkedList</code> class so it can be used whenever needed.</p>
</blockquote>
<p>If the element is not found in the current node, it increments the <code>index</code> and moves to the next node.</p>
<p>If the loop completes without finding the element, it means the element is not present in the list. In this case, the method returns <code>-1</code> (which is an industry convention).</p>
<p>It is useful to have an <code>indexOf</code> method as we can use this method to search for elements, and we will also reuse it to remove elements from the list.</p>
</section>
<section id="removing-an-element-from-a-specific-position" class="level3" data-number="7.2.5">
<h3 data-number="7.2.5">Removing an element from a specific position</h3>
<p>Let's explore how we can remove elements from our linked list. Similar to appending, there are two scenarios to consider: removing the first element (the head) and removing any other element.</p>
<p>The <code>removeAt</code> code is presented as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>  removeAt(position) {
    if (this.#size === 0) {
      throw new RangeError('Cannot remove from an empty list.');
    }
    if (this.#isInvalidPosition(position)) {
      throw new RangeError('Invalid position');
    }
    if (position === 0) {
      return this.#removeFromHead();
    }
    return this.#removeFromMiddleOrEnd(position);
  }</code></pre>
</div>
<p>We will delve into this code step by step:</p>
<ol>
<li>First, we check if the list is not empty, if it is empty, we return an error.</li>
<li>Next, we check if the given position is valid using the <code>#isInvalidPosition</code> helper method.</li>
<li>Then we check for the first scenario: removing the first element of the list, and if so, we will segregate the logic into a separate private method for better organization and understanding.</li>
<li>Finally, if we are not removing the first element, it means we are removing the last element or from the middle of the list. For the singly linked list, both scenarios are similar, so we will handle them in a separate private method.</li>
</ol>
<p>While removing a node from a linked list might seem intricate, breaking down the problem into smaller, more manageable steps can simplify the process. This approach is a valuable technique not only for linked list operations but also for tackling complex tasks in various real-world scenarios.</p>
<p>Let's dive into the <code>#removeFromHead</code> method, which is our first scenario to remove the first element from the linked list:</p>
<div class="C0-SHCodePACKT">
<pre><code>#removeFromHead() {
  const nodeToRemove = this.#head;
  this.#head = this.#head.next;
  this.#size--;
  return nodeToRemove.data;
}</code></pre>
</div>
<p>If the <code>position</code> is 0 (indicating the head), we first store a reference to the head node in <code>nodeToRemove</code>. Then, we simply shift the <code>head</code> pointer to its <code>next</code> node, effectively disconnecting the original <code>head</code>. Finally, we decrease the list size and return the data of the removed node.</p>
<p>The following diagram exemplifies this action:</p>
<figure>
<img src="../media/file34.png" alt="Removing the element at the head of the linked list" width="1212" height="238"/><figcaption aria-hidden="true">Removing the element at the head of the linked list</figcaption>
</figure>
<p>Next, let's check the code to remove a node from the middle or from the end of a linked list:</p>
<div class="C0-SHCodePACKT">
<pre><code>#removeFromMiddleOrEnd(position) {
  let nodeToRemove = this.#head;
  let previous;
  for (let index = 0; index &lt; position; index++) {
    previous = nodeToRemove;
    nodeToRemove = nodeToRemove.next;
  }
  // unlink the node to be removed
  previous.next = nodeToRemove.next;
  this.#size--;
  return nodeToRemove.data;
}</code></pre>
</div>
<p>For any position other than 0, we need to traverse the list to find the node to remove. In previous sections, we used the <code>while</code> loop, and we will use the <code>for</code> loop now to demonstrate there are different ways of achieving the same result.</p>
<p>We keep two variables, <code>nodeToRemove</code> (starting at the first element) and <code>previous</code> to navigate through the list. At each iteration, we shift <code>previous</code> to the current node (<code>nodeToRemove</code>) and move <code>nodeToRemove</code> to the next node.</p>
<p>Once we reach the target position, <code>previous</code> points to the node before the one we want to remove, and <code>nodeToRemove</code> points to the node itself. We adjust the <code>previous</code> node's <code>next</code> pointer to skip over the <code>nodeToRemove</code> node, linking it directly to the node after <code>nodeToRemove</code>. This effectively removes the <code>nodeToRemove</code> node. Then we can decrement the size of the list and return the removed data.</p>
<p>The following diagram exemplifies removing an element from the middle of the list:</p>
<figure>
<img src="../media/file35.png" alt="Removing the element from the middle of the linked list" width="1211" height="258"/><figcaption aria-hidden="true">Removing the element from the middle of the linked list</figcaption>
</figure>
<p>The logic also works for the last element of the list, as the <code>nodeToRemove</code>'s next value will be <code>null</code> and when <code>previous.next</code> receives <code>null</code>, it automatically unlinks the last element. The following diagram exemplifies this action:</p>
<figure>
<img src="../media/file36.png" alt="Removing the last element of the linked list" width="1209" height="257"/><figcaption aria-hidden="true">Removing the last element of the linked list</figcaption>
</figure>
<p>Now that we know how to remove any element from the list, let's learn how to search for a specific element and then remove it.</p>
</section>
<section id="searching-and-removing-an-element-from-the-linked-list" class="level3" data-number="7.2.6">
<h3 data-number="7.2.6">Searching and removing an element from the linked list</h3>
<p>Sometimes, we need to remove an element from a linked list without knowing its exact position. In this scenario, we require a method that searches for the element based on its data and then removes it. We'll create a <code>remove</code> method that accepts the target data and an optional <code>compareFunction</code> for custom comparison logic:</p>
<div class="C0-SHCodePACKT">
<pre><code>remove(data, compareFunction = (a, b) =&gt; a === b) {
  const index = this.indexOf(data, compareFunction);
  if (index === -1) {
    return null;
  }
  return this.removeAt(index);
}</code></pre>
</div>
<p>The method first utilizes the <code>indexOf</code> method we created earlier to determine the position (<code>index</code>) of the first node whose data matches the provided <code>data</code> using the optional <code>compareFunction</code>.</p>
<p>If <code>indexOf</code> returns -1, it means the element is not found in the list. In this case, we return <code>null</code>. If the element is found, the method calls <code>removeAt(index)</code> to remove the node at that position. The <code>removeAt</code> method returns the removed data, which is then returned by the <code>remove</code> method as well.</p>
</section>
<section id="checking-if-it-is-empty-clearing-and-getting-the-current-size" class="level3" data-number="7.2.7">
<h3 data-number="7.2.7">Checking if it is empty, clearing and getting the current size</h3>
<p>The <code>isEmpty</code>, get <code>size</code> and <code>clear</code> methods are very similar to the ones we created in previous chapter and provide fundamental operations for managing our linked list. Let's look at them anyways:</p>
<div class="C0-SHCodePACKT">
<pre><code>isEmpty() {
  return this.#size === 0;
}
get size() {
  return this.#size;
}
clear() {
  this.#head = null;
  this.#size = 0;
}</code></pre>
</div>
<p>Here is an explanation:</p>
<ul>
<li><code>isEmpty</code>: this method checks if the linked list is empty. It does so by simply comparing the private <code>#size</code> property to zero. If #size is 0, it means the list has no elements and returns <code>true</code>; otherwise, it returns <code>false</code>.</li>
<li><code>size</code>: this method directly returns the value of the private <code>#size</code> property, providing the current number of elements in the linked list.</li>
<li><code>clear</code>: this method is used to completely empty the linked list. It does this by setting the <code>#head</code> pointer to <code>null</code>, effectively disconnecting all nodes. The <code>#size</code> property is also reset to 0.</li>
</ul>
</section>
<section id="transforming-the-linked-list-into-a-string" class="level3" data-number="7.2.8">
<h3 data-number="7.2.8">Transforming the linked list into a string</h3>
<p>The last method is the <code>toString</code> method, which its primary goal is to provide a string representation of the linked list. This is incredibly useful for debugging, logging, or simply displaying the contents of the list to users:</p>
<div class="C0-SHCodePACKT">
<pre><code>toString() {
  let current = this.#head;
  let objString = '';
  while (current) {
    objString += this.#elementToString(current.data);
    current = current.next;
    if (current) {
      objString += ', ';
    }
  }
  return objString;
}</code></pre>
</div>
<p>A temporary variable <code>current</code> is initialized to point to the <code>head</code> of the linked list. This will be our cursor as we traverse the list. An empty string <code>objString</code> is created to accumulate the string representation of the list.</p>
<p>The <code>while</code> loop continues as long as <code>current</code> is not <code>null</code>. This means we will iterate over each node in the list until we reach the end (where the last node's next property is <code>null</code>).</p>
<p>The <code>#elementToString</code> private method (which we have coded in previous chapters) is called to convert the data stored in the <code>current</code> node (<code>current.data</code>) into a string representation. This string is then appended (added) to the <code>objString</code>. We advance the <code>current</code> cursor to the <code>next</code> node of the list, and if there is a next node (we have not reached the end yet), a comma and a space are appended to the <code>objString</code> to separate the elements in the final string representation.</p>
</section>
</section>
<section id="doubly-linked-lists" class="level2" data-number="7.3">
<h2 data-number="7.3">Doubly linked lists</h2>
<p>The difference between a doubly linked list and a normal or singly linked list is that in a linked list we make the link from one node to the next one only, while in a doubly linked list, we have a double link: one for the next element and one for the previous element, as shown in the following diagram:</p>
<figure>
<img src="../media/file37.png" alt="Doubly linked list with previous and next nodes" width="1210" height="219"/><figcaption aria-hidden="true">Doubly linked list with previous and next nodes</figcaption>
</figure>
<p>Let's get started with the changes that are needed to implement the <code>DoublyLinkedList</code> class. We will start by declaring the node of our doubly linked list:</p>
<div class="C0-SHCodePACKT">
<pre><code>class DoublyLinkedListNode {
  constructor(data, next = null, previous = null) {
    this.data = data;
    this.next = next;
    this.previous = previous; // new
  } 
}</code></pre>
</div>
<p>In a doubly linked list, each node maintains two references:</p>
<ol>
<li><code>next</code>: a pointer to the next node in the list.</li>
<li><code>previous</code>: a pointer to the previous node in the list.</li>
</ol>
<p>This dual linking enables efficient traversal in both directions. To accommodate this structure, we add the <code>previous</code> pointer to our <code>DoublyLinkedListNode</code> class. The constructor is designed to be flexible. By default, both the <code>next</code> and <code>previous</code> pointers are initialized to <code>null</code>. This allows us to create new nodes that are not yet connected to other nodes in the list. When inserting a node into the list, we explicitly update these pointers to establish the correct links within the list.</p>
<p>Next, we will declare our <code>DoublyLinkedList</code> class:</p>
<div class="C0-SHCodePACKT">
<pre><code>class DoublyLinkedList {
  #head;
  #tail; // new
  #size = 0;
  // other methods
} </code></pre>
</div>
<p>A key distinction of a doubly linked list is that it tracks both the <code>head</code> (the first node) and the <code>tail</code> (the last node). This bidirectional linking enables us to traverse the list efficiently in either direction, offering greater flexibility compared to a singly linked list.</p>
<p>While the core functionality of a doubly linked list remains similar to a singly linked list, the implementation differs. In a doubly linked list, we must manage two references for each node: <code>next</code> (pointing to the following node) and <code>previous</code> (pointing to the preceding node). Therefore, when inserting or removing nodes, we need to carefully update not only the next pointers (as in a singly linked list) but also the previous pointers to maintain the correct links throughout the list. This means that methods like <code>append</code>, <code>prepend</code>, <code>insert</code>, and <code>removeAt</code> will require modifications to accommodate this dual linking.</p>
<p>Let's dive into each of the modifications needed.</p>
<section id="appending-a-new-element" class="level3" data-number="7.3.1">
<h3 data-number="7.3.1">Appending a new element</h3>
<p>Inserting a new element in a doubly linked list is very similar to a linked list. The difference is that in the linked list, we only control one pointer (<code>next</code>), and in the doubly linked list we need control both the <code>next</code> and <code>previous</code> references.</p>
<p>Let's see how the append method behaves in the doubly linked list:</p>
<div class="C0-SHCodePACKT">
<pre><code>append(data) {
  const newNode = new DoublyLinkedListNode(data);
  if (!this.#head) { // empty list
    this.#head = newNode;
    this.#tail = newNode;
  } else { // non-empty list
    newNode.previous = this.tail;
    this.#tail.next = newNode;
    this.#tail = newNode;
  }
  this.#size++;
}</code></pre>
</div>
<p>When we are trying to add a new element to the end of the list, we run into two different scenarios: if the list is empty or not empty. If the list is empty (<code>head</code> is <code>null</code>), we create a new node (<code>newNode</code>) and set both the <code>head</code> and <code>tail</code> to this new node. Since it is the only node, it becomes both the start and end.</p>
<p>If the list is not empty, the beauty of the doubly linked list is we do not have to traverse the entire list to get to its end. As we have the <code>tail</code> reference, we can simply link the new node's <code>previous</code> pointer to the tail, then we will link the tail's next pointer to the new node, and finally, we update the <code>tail</code> reference to the new node. The order of this operations is crucial, as if we update the <code>tail</code> prematurely, we will lose the reference to the original last node, making it impossible to correctly link the new node to the end of the list. The following diagram demonstrates the process of adding a new node to the end of the list:</p>
<figure>
<img src="../media/file38.png" alt="Appending a new node to the doubly linked list" width="1209" height="320"/><figcaption aria-hidden="true">Appending a new node to the doubly linked list</figcaption>
</figure>
<p>Next, let's review and changes needed to prepend an element to a doubly linked list.</p>
</section>
<section id="prepending-a-new-element-to-the-doubly-linked-list" class="level3" data-number="7.3.2">
<h3 data-number="7.3.2">Prepending a new element to the doubly linked list</h3>
<p>Prepending a new element to the doubly linked list is not much different then prepending a new element to a singly linked list:</p>
<div class="C0-SHCodePACKT">
<pre><code>prepend(data) {
  const newNode = new DoublyLinkedListNode(data);
  if (!this.#head) {  // empty list
    this.#head = newNode;
    this.#tail = newNode;
  } else { // non-empty list
    newNode.next = this.#head;
    this.#head.previous = newNode;
    this.#head = newNode;
  }
  this.#size++;
}</code></pre>
</div>
<p>Again, we have two scenarios. In case the list is empty, the behavior is identical to the <code>append</code> method, the new node becomes both the <code>head</code> and <code>tail</code>.</p>
<p>If the list is not empty, we set the <code>next</code> pointer of the new node (<code>newNode</code>) to the current <code>head</code>. We then update the <code>previous</code> pointer of the current head to reference the <code>newNode</code>. Finally, we update the <code>head</code> to be the <code>newNode</code>, as it is now the first node in the list.</p>
<p>In a singly linked list, the prepend operation only requires updating the <code>next</code> pointer of the new node and the <code>head</code> of the list. However, in a doubly linked list, we must also update the <code>previous</code> pointer of the original head node to ensure the bidirectional links are maintained.</p>
<p>Now that we are able to add elements at the head and at the tail of the list, let's checkout how to insert at any position.</p>
</section>
<section id="inserting-a-new-element-at-any-position" class="level3" data-number="7.3.3">
<h3 data-number="7.3.3">Inserting a new element at any position</h3>
<p>Inserting an element at an arbitrary position within a doubly linked list requires some additional considerations compared to simply appending or prepending. Let's see how to insert at any position:</p>
<div class="C0-SHCodePACKT">
<pre><code>insert(data, position) {
  if (this.isInvalidPosition(position)) {
    return false;
  }
  if (position === 0) { // first position
    this.prepend(data);
    return true;
  }
  if (position === this.#size) { // last position
    this.append(data);
    return true;
  }
  // middle position
  return this.#insertInTheMiddle(data, position);
}</code></pre>
</div>
<p>Let's review case by case:</p>
<ol>
<li>First, we start by checking if the position if valid, and if not, we return <code>false</code> to indicate the insertion was not successful.</li>
<li>Next, we will check if the insertion is at the <code>head</code>, and if so, we can reuse the <code>prepend</code> method, and return <code>true</code> to indicate the insertion was a success.</li>
<li>The next scenario is in case the insertion is at the end of the list, and if so, we can reuse the <code>append</code> method and return <code>true</code>. Checking for this case will avoid traversing the list to get to its end.</li>
<li>If not prepending and not appending, it means the position is in the middle of the list, and for this case, we will create a private method that will hold the logic.</li>
</ol>
<p>In case the position is in the middle, we will use the <code>#insertInTheMiddle</code> to help us organize the steps better as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>#insertInTheMiddle(data, position) {
  const newNode = new DoublyLinkedListNode(data);
  let currentNode = this.#head;
  let previousNode;
  for (let index = 0; index &lt; position; index++) {
    previousNode = currentNode;
    currentNode = currentNode.next;
  }
  newNode.next = currentNode;
  newNode.previous = previousNode;
  currentNode.previous = newNode;
  previousNode.next = newNode;
  this.#size++;
  return true;
}</code></pre>
</div>
<p>So, we will create a new node and we will traverse the list to the desired position. After the <code>for</code> loop, we will insert the new node between the previous and current references with the following steps:</p>
<ol>
<li>The <code>newNode</code>'s <code>next</code> pointer is set to the <code>currentNode</code>.</li>
<li>The <code>newNode</code>'s <code>previous</code> pointer is set to the <code>previousNode</code>. With these two steps, we have the new node partially inserted to the list. What we need to do now is updating the references of the existing nodes in the list to the new node.</li>
<li>The <code>currentNode</code>'s <code>previous</code> pointer is updated to point to the <code>newNode</code>.</li>
<li>The <code>previousNode</code>'s <code>next</code> pointer is updated to point to the <code>newNode</code>.</li>
</ol>
<p>The following diagram exemplifies this scenario:</p>
<figure>
<img src="../media/file39.png" alt="Inserting a new node in the middle of the doubly linked list" width="1212" height="443"/><figcaption aria-hidden="true">Inserting a new node in the middle of the doubly linked list</figcaption>
</figure>
<blockquote>
<p>Given we have a refence to both the <code>head</code> and the <code>tail</code> of the list, an improvement we could make to this method is checking if position is greater than size/2, then it would be best to iterate from the end than start from the beginning (by doing so, we will have to iterate through fewer elements from the list).</p>
</blockquote>
<p>Now that we have learned the details of how to handle two pointers for inserting nodes in the list, let's see how to remove an element from any position.</p>
</section>
<section id="removing-an-element-from-a-specific-position-1" class="level3" data-number="7.3.4">
<h3 data-number="7.3.4">Removing an element from a specific position</h3>
<p>Let's delve into the details and differences of removing an element from any position of the list:</p>
<div class="C0-SHCodePACKT">
<pre><code>removeAt(position) {
  if (this.#size === 0) {
    throw new RangeError('Cannot remove from an empty list.');
  }
  if (this.#isInvalidPosition(position)) {
    throw new RangeError('Invalid position.');
  }
  if (position === 0) {
    return this.#removeFromHead();
  }
  if (position === this.#size - 1) {
    return this.#removeFromTail();
  }
  return this.#removeFromMiddle(position);
}</code></pre>
</div>
<p>We will start by checking if the list is empty and for an invalid position. If the list is empty or if the given position is outside the valid range of the list (0 to size-1), we throw a <code>RangeError</code>.</p>
<p>Next, we will check for the three possible scenarios:</p>
<ol>
<li>If the removal is from the head (first position of the list)</li>
<li>If the removal is from the tail (last position of the list)</li>
<li>or from the middle of the list.</li>
</ol>
<p>Let's dive into each scenario.</p>
<p>The first scenario is if are removing the first element. Following is the code for the <code>#removeFromHead</code> private method:</p>
<div class="C0-SHCodePACKT">
<pre><code>#removeFromHead() {
  const nodeToRemove = this.#head;
  this.#head = nodeToRemove.next;
  if (this.#head) {
    this.#head.previous = null;
  } else {
    this.#tail = null; // List becomes empty
  }
  this.#size--;
  nodeToRemove.next = null;
  return nodeToRemove.data;
}</code></pre>
</div>
<p>We start by creating a reference (<code>nodeToRemove</code>) to the current head node. This is important because we will need to return its data later. Next, the <code>head</code> reference is now moved to the <code>next</code> node in the list.</p>
<p>If there was only one node, <code>nodeToRemove.next</code> will be <code>null</code>, and the <code>head</code> will become <code>null</code>, indicating an empty list.</p>
<p>If the list is not empty after the removal, the <code>previous</code> reference of the new <code>head</code> node (which was previously the second node) is set to <code>null</code>, since it is now the first node and has no predecessor.</p>
<p>If the list is empty, both <code>head</code> and <code>tail</code> need to be set to <code>null</code>. As we have already set the <code>head</code> to <code>null</code> in the second line of the method, we only need to set the <code>tail</code> to <code>null</code>.</p>
<p>Finally, we remove the <code>nodeToRemove</code> next reference in case there is any. The following diagram demonstrates this scenario:</p>
<figure>
<img src="../media/file40.png" alt="Removing the node at the head of a doubly linked list" width="1211" height="257"/><figcaption aria-hidden="true">Removing the node at the head of a doubly linked list</figcaption>
</figure>
<p>The next scenario is checking if we are removing the tail (the last element). Following is the code for the <code>#</code> <code>removeFromTail</code> private method:</p>
<div class="C0-SHCodePACKT">
<pre><code>#removeFromTail() {
  const nodeToRemove = this.#tail;
  this.#tail = nodeToRemove.previous;
  if (this.#tail) {
    this.#tail.next = null;
  } else {
    this.#head = null; // List becomes empty
  }
  this.#size--;
  nodeToRemove.previous = null;
  return nodeToRemove.data;
}</code></pre>
</div>
<p>After creating the reference to the current <code>tail</code> node, the <code>tail</code> reference is moved to the <code>previous</code> node. We need to check if the list if empty after the removal – this is similar to the <code>removeFromHead</code> method behavior. If the list is not empty, we set the new tail's <code>next</code> pointer is set to <code>null</code>. If the list is empty, we also update the <code>head</code> to <code>null</code>. The following diagram demonstrates this scenario:</p>
<figure>
<img src="../media/file41.png" alt="Removing the node at the tail of a doubly linked list" width="1211" height="236"/><figcaption aria-hidden="true">Removing the node at the tail of a doubly linked list</figcaption>
</figure>
<p>The last scenario is removing the element from the middle of the list. The method <code>#removeFromMiddle</code> is listed as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>  #removeFromMiddle(position) {
    let nodeToRemove = this.#head;
    let previousNode;
    for (let index = 0; index &lt; position; index++) {
      previousNode = nodeToRemove;
      nodeToRemove = nodeToRemove.next;
    }
 
    previousNode.next = nodeToRemove.next;
    nodeToRemove.next.previous = previousNode;
    nodeToRemove.next = null;
    nodeToRemove.previous = null;
    this.#size--;
    return nodeToRemove.data;
  }</code></pre>
</div>
<p>Since the position is not the <code>head</code> or <code>tail</code>, we need to traverse the list to find the node and correctly adjust the surrounding nodes' references. We start by declaring a <code>nodeToRemove</code>, referencing it to the <code>head</code> as the starting point and we will move this node through the list as we iterate. The <code>previousNode</code> keeps track of the node just before the <code>nodeToRemove</code> and it starts with <code>null</code> since the head has no previous node.</p>
<p>The <code>for</code> loop continues until <code>index</code> matches the <code>position</code> we want to remove from. Inside the loop, we update <code>previousNode</code> to be the current node (before we move it) and we mode <code>nodeToRemove</code> to the next node.</p>
<p>When the loop stops, <code>nodeToRemove</code> will reference the node we want to remove. So, we skip the reference to the <code>nodeToRemove</code> by making the <code>previousNode</code>'s <code>next</code> pointer point to the node after <code>nodeToRemove</code>.</p>
<p>Then, <code>nodeToRemove.next.previous = previousNode</code> updates the <code>previous</code> pointer of the node after <code>nodeToRemove</code> to point back to <code>previousNode</code>. This step is essential to maintain the doubly linked list's structure.</p>
<p>At last, we remove the <code>nodeToRemove</code> next and previous references, we decrease the size of the list and return the removed data.</p>
<p>The following diagram demonstrates this scenario:</p>
<figure>
<img src="../media/file42.png" alt="Removing the node from the middle of a doubly linked list" width="1211" height="219"/><figcaption aria-hidden="true">Removing the node from the middle of a doubly linked list</figcaption>
</figure>
<blockquote>
<p>To check the implementation of other methods of the doubly linked list (as they are the same as the linked list), refer to the source code of the book. The download link of the source code is mentioned in the Preface of the book, and it can also be accessed at: <a href="http://github.com/loiane/javascript-datastructures-algorithms">http://github.com/loiane/javascript-datastructures-algorithms</a>.</p>
</blockquote>
</section>
</section>
<section id="circular-linked-lists" class="level2" data-number="7.4">
<h2 data-number="7.4">Circular linked lists</h2>
<p>A circular linked list is a variation of a linked list where the last node's next pointer (or <code>tail.next</code>) references the first node (<code>head</code>) instead of being <code>null</code> or <code>undefined</code>. This creates a closed loop structure., as we can see in the following diagram:</p>
<figure>
<img src="../media/file43.png" alt="The structure of a circular linked list" width="1047" height="282"/><figcaption aria-hidden="true">The structure of a circular linked list</figcaption>
</figure>
<p>A doubly circular linked list has <code>tail.next</code> pointing to the head element, and <code>head.previous</code> pointing to the <code>tail</code> element as showed as follows:</p>
<figure>
<img src="../media/file44.png" alt="The structure of a doubly circular linked list" width="1208" height="271"/><figcaption aria-hidden="true">The structure of a doubly circular linked list</figcaption>
</figure>
<p>The key difference between circular and regular (linear) linked lists is that there is no explicit <em>end</em> to a circular linked list. You can continuously traverse the list starting from any node and eventually return to the starting point.</p>
<blockquote>
<p>We will implement a singly circular linked list, and you can find the bonus source code for a doubly circular linked list in the source code from this book.</p>
</blockquote>
<p>Let's check the code to create the <code>CircularLinkedList</code> class:</p>
<div class="C0-SHCodePACKT">
<pre><code>class CircularLinkedList {
  #head;
  #size = 0;
  // other methods
}</code></pre>
</div>
<p>We will utilize the same <code>LinkedListNode</code> structure for our <code>CircularLinkedList</code> class, as the fundamental node structure remains the same. However, the circular nature of the list introduces some key differences in how we implement operations like <code>append</code>, <code>prepend</code>, and <code>removeAt</code>. Let's explore these modifications in detail.</p>
<section id="appending-a-new-element-1" class="level3" data-number="7.4.1">
<h3 data-number="7.4.1">Appending a new element</h3>
<p>Appending a new element to a circular linked list shares similarities with appending to a standard linked list, but with a few key distinctions due to the circular structure. Let's see the code for the <code>append</code> method:</p>
<div class="C0-SHCodePACKT">
<pre><code>  append(data) {
    const newNode = new LinkedListNode(data);
    if (!this.#head) { // empty list                             
      this.#head = newNode;
      newNode.next = this.#head; // points to itself
    } else { // non-empty list
      let current = this.#head;
      while (current.next !== this.#head) {
        current = current.next;
      }
      current.next = newNode;
      newNode.next = this.#head; // circular reference
    }
    this.#size++;
  }</code></pre>
</div>
<p>We start by creating the new node to hold that data. Then checks if the list is empty. If so, the new node becomes the <code>head</code>, and its next pointer is set to point back to itself, completing the circle. The following diagram exemplifies the first scenario:</p>
<figure>
<img src="../media/file45.png" alt="Appending an element as the only node in a circular linked list" width="451" height="253"/><figcaption aria-hidden="true">Appending an element as the only node in a circular linked list</figcaption>
</figure>
<p>If the list is not empty, we need to find the last node. This is done by traversing the list starting from the <code>head</code> until we find a node whose next pointer points back to the <code>head</code>.</p>
<p>Once the last node (<code>current</code>) is found, its next pointer is updated to reference the <code>newNode</code>. The <code>newNode</code>'s next pointer is then set to the <code>head</code>, re-establishing the circular link. The following diagram exemplifies the second scenario:</p>
<figure>
<img src="../media/file46.png" alt="Appending an element in a non-empty circular linked list" width="558" height="269"/><figcaption aria-hidden="true">Appending an element in a non-empty circular linked list</figcaption>
</figure>
<p>Next, let's see how to insert a new node in the beginning of a circular linked list.</p>
</section>
<section id="prepending-a-new-element" class="level3" data-number="7.4.2">
<h3 data-number="7.4.2">Prepending a new element</h3>
<p>Prepending a new element in a circular linked list involves a few key steps due to the circular nature of the structure. Let's check out the code first:</p>
<div class="C0-SHCodePACKT">
<pre><code>prepend(data) {
  const newNode = new LinkedListNode(data, this.#head);
  if (!this.head) {
    this.head = newNode;
    newNode.next = this.head; // make it circular
  } else {
    // Find the last node
    let current = this.head;
    while (current.next !== this.head) {
      current = current.next;
    }
    current.next = newNode;
    this.head = newNode;
  }
  this.#size++;
}</code></pre>
</div>
<p>We start by creating a new node to hold the data. The <code>next</code> pointer of the new node is immediately set to the current <code>head</code> of this list, to maintain the circular nature of the list after the insertion.</p>
<p>If the list is empty, the new node becomes the <code>head</code> and we add a self-reference as the next pointer.</p>
<p>In case the list is not empty, we find the last element, so we can update its <code>next</code> pointer to the new node, which will become the new <code>head</code>. The diagram below exemplifies this action:</p>
<figure>
<img src="../media/file47.png" alt="Prepending an element in a non-empty circular linked list" width="736" height="346"/><figcaption aria-hidden="true">Prepending an element in a non-empty circular linked list</figcaption>
</figure>
<p>If we want to insert a new element in the middle of the list, the code is the same as the <code>LinkedList</code> class since no changes will be applied to the last or first nodes of the list.</p>
</section>
<section id="removing-an-element-from-a-specific-position-2" class="level3" data-number="7.4.3">
<h3 data-number="7.4.3">Removing an element from a specific position</h3>
<p>For the removal of an element of a circular linked list, we will cover removing the first and the last elements, since removing an element from the middle is the same behavior as the singly linked list.</p>
<p>First, let's cover removing from the head, with the code as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>  #removeFromHead() {
    const nodeToRemove = this.#head;
    let lastNode = this.#head;
    while (lastNode.next !== this.#head) { // Find the last node
      lastNode = lastNode.next;
    }
    this.#head = nodeToRemove.next; // skip the head
    lastNode.next = this.#head;  // make it circular
 
    if (this.#size === 1) {  // only one node
      this.#head = null;
    }
    this.#size--;               
    return nodeToRemove.data;
  }</code></pre>
</div>
<p>Following is the explanation:</p>
<ol>
<li>First, we traverse the list to find the last node.</li>
<li>Next, we set the head to the next node to remove the first element.</li>
<li>Then we make the last node point to the new <code>head</code>, closing the circle.</li>
<li>Finally, if the removed node was the only one in the list, set the <code>head</code> to <code>null</code> to reset it.</li>
</ol>
<p>The diagram below exemplifies this action:</p>
<figure>
<img src="../media/file48.png" alt="Removing the head from a circular linked list" width="1212" height="350"/><figcaption aria-hidden="true">Removing the head from a circular linked list</figcaption>
</figure>
<p>Now, let's check out how to remove from the end of the list:</p>
<div class="C0-SHCodePACKT">
<pre><code>#removeFromTail() {
  if (this.#head.next === this.#head) { // single node case
    const nodeToRemove = this.#head;
    this.#head = null;
    this.#size--;
    return nodeToRemove.data;
  } else {
    let lastNode = this.#head;
    let previousNode = null;
    while (lastNode.next !== this.#head) { // Find the last node
      previousNode = lastNode;
      lastNode = lastNode.next;
    }
    previousNode.next = this.#head; // skip the last node to remove it
    this.#size--;                 
    return lastNode.data;         
  }
}</code></pre>
</div>
<p>And following is the explanation:</p>
<ol>
<li>If there is only one node (<code>head</code> points to itself), removing it makes the list empty. We update <code>head</code> to <code>null</code> and return the removed data.</li>
<li>If the list is not empty, we need to find the last node and the second last node (<code>previousNode</code>). So we traverse the list until we reach its end, updating the <code>previous</code> and the <code>last</code> node references.</li>
<li>When the <code>while</code> loop is finished, the <code>lastNode</code> is the one we want to remove. So we set <code>previousNode.next = this.#head</code> to make the second last node point to the head, skipping the last node, which is now removed.</li>
<li>We decrement the list size and return the removed <code>data</code>.</li>
</ol>
<p>The diagram below exemplifies this action:</p>
<figure>
<img src="../media/file49.png" alt="Removing the tail from a circular linked list" width="1211" height="317"/><figcaption aria-hidden="true">Removing the tail from a circular linked list</figcaption>
</figure>
<p>Now that we know how to add and remove elements from three different types of linked lists, let's put all these concepts learned by creating a fun project!</p>
</section>
</section>
<section id="creating-a-media-player-using-a-linked-list" class="level2" data-number="7.5">
<h2 data-number="7.5">Creating a media player using a linked list</h2>
<p>To solidify our understanding of linked lists and explore new concepts, let's build a real-world application: a media player! This project will leverage the linked list structure and introduce us to additional techniques like working with doubly circular linked lists and ordered insertion.</p>
<p>Before we dive in, let's outline the core features of our media player:</p>
<ul>
<li>Ordered song insertion: add songs to the playlist based on song title.</li>
<li>Sequential playback: simulate playing songs one after the other in the playlist's order.</li>
<li>Navigation: easily jump to the previous or next song.</li>
<li>Continuous repeat: automatically loop the playlist, playing songs repeatedly.</li>
</ul>
<p>The following image represents the media player we will develop using linked lists:</p>
<figure>
<img src="../media/file50.png" alt="A media player using doubly circular linked list" width="1211" height="356"/><figcaption aria-hidden="true">A media player using doubly circular linked list</figcaption>
</figure>
<p>To model our media player's playlist, we will use a custom node structure to represent each song. Following is the <code>MediaPlayerSong</code> class:</p>
<div class="C0-SHCodePACKT">
<pre><code>class MediaPlayerSong {
  constructor(songTitle) {
    this.songTitle = songTitle;
    this.previous = null;
    this.next = null;
  }
}</code></pre>
</div>
<p>Each <code>MediaPlayerSong</code> node stores:</p>
<ul>
<li><code>songTitle</code>: the title of the song.</li>
<li><code>previous</code>: a reference to the previous song node in the playlist (or a reference to the last song, if it is the first song).</li>
<li><code>next</code>: a reference to the next song node in the playlist (or a reference to the first song if it is the last song).</li>
</ul>
<p>This will allow us to implement the continuous repeat feature of our media player.</p>
<p>Next, let's define the structure of our <code>MediaPlayer</code> class:</p>
<div class="C0-SHCodePACKT">
<pre><code>class MediaPlayer {
  #firstSong;
  #lastSong;
  #size = 0;
  #playingSong;
  // other methods
} </code></pre>
</div>
<p>The <code>MediaPlayer</code> class maintains:</p>
<ul>
<li><code>#firstSong</code>: a reference to the first <code>MediaPlayerSong</code> in the playlist.</li>
<li><code>#lastSong</code>: a reference to the last <code>MediaPlayerSong</code> in the playlist.</li>
<li><code>#size</code>: the count of songs currently in the playlist.</li>
<li><code>#playingSong</code>: a reference to the <code>MediaPlayerSong</code> that is currently being played.</li>
</ul>
<p>Before we can start playing songs, we need to be able to add songs to our playlist. Let's see how to do it in the next section.</p>
<section id="adding-new-songs-by-title-order-sorted-insertion" class="level3" data-number="7.5.1">
<h3 data-number="7.5.1">Adding new songs by title order (sorted insertion)</h3>
<p>To maintain an alphabetically ordered playlist, we will implement a method called <code>addSongByTitle</code>. This method will insert a new song into the correct position based on its title, ensuring the playlist remains sorted.</p>
<blockquote>
<p>Behind the scenes, we are doing a sorted insertion in a doubly circular linked list!</p>
</blockquote>
<p>We will start by declaring the method to insert a new song:</p>
<div class="C0-SHCodePACKT">
<pre><code>addSongByTitle(newSongTitle) {
  const newSong = new MediaPlayerSong(newSongTitle);
  if (this.#size === 0) { // empty list
    this.#insertEmptyPlayList(newSong);
  } else {
    const position = this.#findIndexOfSortedSong(newSongTitle);
    if (position === 0) { // insert at the beginning
      this.#insertAtBeginning(newSong);
    } else if (position === this.#size) { // insert at the end
      this.#insertAtEnd(newSong);
    } else { // insert in the middle
      this.#insertInMiddle(newSong, position);
    }
  }
  this.#size++;
}</code></pre>
</div>
<p>Here is a brief explanation before we start diving into the details:</p>
<ol>
<li>We start by creating a new <code>MediaPlayerSong</code> node with the given <code>newSongTitle</code>.</li>
<li>If the playlist is empty, we call a private method <code>#insertEmptyPlayList</code> to handle the insertion of the first song.</li>
<li>For non-empty playlists, we callsa private method <code>#findIndexOfSortedSong</code> to determine the correct <code>position</code> where the new song should be inserted to maintain alphabetical order.</li>
<li>Based on the returned <code>position</code>, the method dispatches the insertion to one of three private methods:
<ol type="A">
<li><code>#insertAtBeginning</code>: inserts the new song at the start of the list.</li>
<li><code>#insertAtEnd</code>: inserts the new song at the end of the list.</li>
<li><code>#insertInMiddle</code>: inserts the new song in the middle of the list at the specified position.</li>
</ol></li>
<li>Finally, the <code>#size</code> of the playlist is incremented to reflect the addition of the new song.</li>
</ol>
<p>Let's review each of the steps with more details.</p>
<section id="inserting-into-an-empty-playlist" class="level4" data-number="7.5.1.1">
<h4 data-number="7.5.1.1">Inserting into an empty playlist</h4>
<p>In this scenario, we are handling an insertion into a doubly circular linked list. Let's dive into the <code>#insertEmptyPlayList</code> method:</p>
<div class="C0-SHCodePACKT">
<pre><code>#insertEmptyPlayList(newSong) {
  this.#firstSong = newSong;
  this.#lastSong = newSong;
  newSong.next = newSong; // points to itself
  newSong.previous = newSong; // points to itself
}</code></pre>
</div>
<p>We are assigning the new song to the <code>firstSong</code> (head) and the <code>lastSong</code> (tail). And to keep the circular references, we set the new song's <code>next</code> and <code>previous</code> references to itself.</p>
<p>The next step in the logic is to find the position we need to insert the song in case the playlist is not empty.</p>
</section>
<section id="finding-the-alphabetically-sorted-insertion-position" class="level4" data-number="7.5.1.2">
<h4 data-number="7.5.1.2">Finding the alphabetically sorted insertion position</h4>
<p>We are dealing with a complex scenario: sorted insertion into a doubly circular linked list. To simplify this, we will tackle it in two phases, the first one determining the correct position (index) where the new song should be inserted to maintain alphabetical order and the second one being the insertion itself. So, for now, let's focus on finding the correct insertion index:</p>
<div class="C0-SHCodePACKT">
<pre><code>#findIndexOfSortedSong(newSongTitle) {
  let currentSong = this.#firstSong;
  let i = 0;
  for (; i &lt; this.#size &amp;&amp; currentSong; i++) {
    const currentSongTitle = currentSong.songTitle;
    if (this.#compareSongs(currentSongTitle, newSongTitle) &gt;= 0) {
      return i;
    }
    currentSong = currentSong.next;
  }
  return 0;
}</code></pre>
</div>
<p>We will traverse the list to find the position of the insertion. To do so, we will use a cursor called <code>currentSong</code>. We also need an index counter <code>i</code>.</p>
<p>We will loop from the first song up until the last song of the playlist. Inside the loop, we will call a helper method that contains the logic to compare the songs. If the result of the helper method is 0 (duplicate song) or a positive number, it means we found the position.</p>
<p>If the new song does not belong at the current position, we move to the next song in the list. If the loop completes without returning, it means the new song should be inserted at the beginning (index 0).</p>
<p>Next let's check the code for the <code>#compareSongs</code> method:</p>
<div class="C0-SHCodePACKT">
<pre><code>#compareSongs(songTitle1, songTitle2) {
  return songTitle1.localeCompare(songTitle2);
}</code></pre>
</div>
<p>This method is a helper function used to compare two song titles alphabetically, considering locale-specific sorting rules. The localeCompare method returns a number that indicates the sorting relationship between the two strings:</p>
<ul>
<li>Negative number: <code>songTitle1</code> comes before <code>songTitle2</code> in alphabetical order.</li>
<li>0 (zero): <code>songTitle1</code> and <code>songTitle2</code> are considered equal in the current locale.</li>
<li>Positive number: <code>songTitle1</code> comes after <code>songTitle2</code> in alphabetical order.</li>
</ul>
<p>You can modify this method as needed to customize how you would like to compare song titles.</p>
<p>Now that we know the position we need to insert, let's review each of the methods.</p>
</section>
<section id="inserting-at-the-beginning-of-the-playlist" class="level4" data-number="7.5.1.3">
<h4 data-number="7.5.1.3">Inserting at the beginning of the playlist</h4>
<p>Let's check how to prepend a new song in a playlist that is not empty:</p>
<div class="C0-SHCodePACKT">
<pre><code>#insertAtBeginning(newSong) {
  newSong.next = this.#firstSong;
  newSong.previous = this.#lastSong;
  this.#firstSong.previous = newSong;
  this.#lastSong.next = newSong;
  this.#firstSong = newSong;
}</code></pre>
</div>
<p>Given our next song, we will point its next reference to the first song (head) and its last reference to the last song (tail). Then, we update the existing first song's previous reference to the new song, and the last song's next reference also to the new song. Finally, we update the first song reference to the new song.</p>
<p>Next, let's see how to append a new song.</p>
</section>
<section id="inserting-at-the-end-of-the-playlist" class="level4" data-number="7.5.1.4">
<h4 data-number="7.5.1.4">Inserting at the end of the playlist</h4>
<p>Let's review how we can add new songs at the end of the playlist with the following method:</p>
<div class="C0-SHCodePACKT">
<pre><code>#insertAtEnd(newSong) {
  newSong.next = this.#firstSong;
  newSong.previous = this.#lastSong;
  this.#lastSong.next = newSong;
  this.#firstSong.previous = newSong;
  this.#lastSong = newSong;
}</code></pre>
</div>
<p>Given the new song, when inserting at the end, we need to link its next reference to the first song and its previous reference to the last song so we can keep the doubly circular references. Then, we need to update the last song's next reference to the new song, the first song's previous reference also to the new song to also keep the circular reference, and finally, update the reference of the last song to the new song.</p>
<p>Now, the last step is to insert a song in the middle of the playlist.</p>
</section>
<section id="inserting-in-the-middle-of-the-playlist" class="level4" data-number="7.5.1.5">
<h4 data-number="7.5.1.5">Inserting in the middle of the playlist</h4>
<p>Now that we have covered the insertion at the head and at the tail of the doubly circular linked list, let's dive into the details to insert a new element in the middle of the list as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>#insertInMiddle(newSong, position) {
  let currentSong = this.#firstSong;
  for (let i = 0; i &lt; position - 1; i++) {
    currentSong = currentSong.next;
  }
  newSong.next = currentSong.next;
  newSong.previous = currentSong;
  currentSong.next.previous = newSong;
  currentSong.next = newSong;
}</code></pre>
</div>
<p>Inserting in the middle is the same as inserting in a doubly linked list. As we have both the previous and next references, we do not need two references. So first, we find the position we are looking for, and we stop at one position before the one we want. Then, we link the new song's next reference to the current's next reference, and the new song's previous reference to the current song. With this step, we have inserted the new song in the list, and now we need to fix the remaining links. So, we fix the current songs' next node's previous reference to the new song, and the current song's next reference to the new song.</p>
<p>With the songs added to the playlist, we can start playing them!</p>
</section>
</section>
<section id="playing-a-song" class="level3" data-number="7.5.2">
<h3 data-number="7.5.2">Playing a song</h3>
<p>When we select the play song feature of our media player, the goal is to start playing the song. For our simulation, it means assigning the first song to the playing song reference, as described as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>play() {
  if (this.#size === 0) {
    return null;
  }
  this.#playingSong = this.#firstSong;
  return this.#playingSong.songTitle;
}</code></pre>
</div>
<p>If there are no songs in the playlist, we can return null, or if you prefer, you can throw an error as well. Then, we assign the reference of the playing song to the first song, and we return the title we are playing.</p>
</section>
<section id="playing-the-next-or-previous-song" class="level3" data-number="7.5.3">
<h3 data-number="7.5.3">Playing the next or previous song</h3>
<p>The behavior to play the next or previous song are very similar. The difference is on the reference we are updating: <code>previous</code> or <code>next</code>. Let's review the behavior for playing the next song first:</p>
<div class="C0-SHCodePACKT">
<pre><code>next() {
  if (this.#size === 0) {
    return null;
  }
  if (!this.#playingSong) {
    return this.play();
  }
  this.#playingSong = this.#playingSong.next;
  return this.#playingSong.songTitle;
}</code></pre>
</div>
<p>If there are no songs in the playlist, we return <code>null</code>. Also, if there is not any song playing at the moment, we play the first song. However, if there are songs playing and we decide we want to play the next song, we simply update the playing song with its next reference and we return the song title.</p>
<p>The code of the previous method is also very similar:</p>
<div class="C0-SHCodePACKT">
<pre><code>previous() {
  if (this.#size === 0) {
    return null;
  }
  if (!this.#playingSong) {
    return this.play();
  }
  this.#playingSong = this.#playingSong.previous;
  return this.#playingSong.songTitle;
}</code></pre>
</div>
<p>The difference is if there are songs playing, and we want to play the previous song, we update the current song with its previous reference.</p>
<p>In both cases, when we reach the end of the playlist, or the first song of the playlist, we can keep playing, because of the circular doubly references.</p>
</section>
<section id="using-our-media-player" class="level3" data-number="7.5.4">
<h3 data-number="7.5.4">Using our media player</h3>
<p>Now that we have built our media player, let's put it to the test. We will start by creating an instance and adding our favorite songs:</p>
<div class="C0-SHCodePACKT">
<pre><code>const mediaPlayer = new MediaPlayer();
mediaPlayer.addSongByTitle('The Bard\'s Song');
mediaPlayer.addSongByTitle('Florida!!!');
mediaPlayer.addSongByTitle('Run to the Hills');
mediaPlayer.addSongByTitle('Nothing Else Matters');</code></pre>
</div>
<p>After our playlist is created, we can start playing songs and seeing the output:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('Playing:', mediaPlayer.play()); // Florida!!!</code></pre>
</div>
<p>We can select the next song multiple times and check that the continuous playback works as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('Next:', mediaPlayer.next()); // Nothing Else Matters
console.log('Next:', mediaPlayer.next()); // Run to the Hills
console.log('Next:', mediaPlayer.next()); // The Bard's Song
console.log('Next:', mediaPlayer.next()); // Florida!!!</code></pre>
</div>
<p>And if we go the other way around it, selecting the previous button:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('Previous:', mediaPlayer.previous()); // The Bard's Song
console.log('Previous:', mediaPlayer.previous()); // Run to the Hills
console.log('Previous:', mediaPlayer.previous()); // Nothing Else Matters
console.log('Previous:', mediaPlayer.previous()); // Florida!!!</code></pre>
</div>
<blockquote>
<p>If we review the output, we can confirm the songs were inserted in an alphabetical order.</p>
</blockquote>
<p>Have fun playing with our media player!</p>
</section>
</section>
<section id="reviewing-the-efficiency-of-the-linked-lists" class="level2" data-number="7.6">
<h2 data-number="7.6">Reviewing the efficiency of the linked lists</h2>
<p>Let's review the efficiency of each method by review the Big O notation in terms of time of execution:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Singly</strong></td>
<td><strong>Doubly</strong></td>
<td><strong>Circular</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr class="even">
<td><code>append</code></td>
<td><em>O(n)</em></td>
<td><em>O(1)</em></td>
<td><em>O(n)</em></td>
<td>In singly and circular lists, we must traverse to the end to append. Doubly lists have a tail reference for constant time append.</td>
</tr>
<tr class="odd">
<td><code>prepend</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(n)</em></td>
<td>All lists can add a new node as the head directly. However, in circular lists, we must update the last node's next pointer to the new head.</td>
</tr>
<tr class="even">
<td><code>insert</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>For all types, we need to traverse to the position to insert.</td>
</tr>
<tr class="odd">
<td><code>removeAt</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>Similar to insertion, traversal to the position is required. Doubly lists have an optimization when removing the tail ( <em>O(1)</em> ), but this is less common than removing from an arbitrary position.</td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>Searching for the data takes <em>O(n)</em> in all cases, then removal itself is either <em>O(1)</em> (if the node is found at the head) or <em>O(n)</em> (traversing to the node).</td>
</tr>
<tr class="odd">
<td><code>indexOf</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>In the worst case, we might need to traverse the entire list to find the data or determine it's not present.</td>
</tr>
<tr class="even">
<td><code>isEmpty</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Checking if the list is empty is a simple size reference check.</td>
</tr>
<tr class="odd">
<td><code>size</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>The size is tracked as a property and directly accessible.</td>
</tr>
<tr class="even">
<td><code>clear</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Clearing a list simply involves resetting the head pointer (and tail in doubly linked lists), which is a constant-time operation.</td>
</tr>
<tr class="odd">
<td><code>toString</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>Building a string representation requires visiting each node.</td>
</tr>
</tbody>
</table>
<p>Doubly linked lists often have a performance advantage in append due to the tail pointer. Otherwise, all three list types have similar time complexities for most operations, as they all involve some degree of traversal.</p>
<p>Space complexity is <em>O(n)</em> for all three types, as the space used is proportional to the number of elements stored.</p>
<p>If we had to compare liked lists to arrays, there are pros and cons to each data structure. Let's review a few key points:</p>
<ul>
<li><em>Linked Lists</em>: prefer linked lists when:
<ul>
<li>You need a dynamic collection where the number of elements changes frequently.</li>
<li>You perform frequent insertions and deletions, especially at the beginning or middle of the list.</li>
<li>You do not require random access to elements.</li>
</ul></li>
<li><em>Arrays</em>: prefer arrays when:
<ul>
<li>You know the maximum size of the collection beforehand.</li>
<li>You need fast random access to elements by index.</li>
<li>You primarily need to iterate through the elements sequentially.</li>
</ul></li>
</ul>
<p>We have also learned about stacks, queues and deques earlier in this book and we have used arrays internally. These data structures can also be implemented using linked lists. So, what is the best implementation for each? We need to consider these factors when deciding:</p>
<ul>
<li>Frequency of operations: if you frequently need to access elements by index (random access), arrays might be a better choice. If insertions and deletions at the beginning or middle are common, linked lists could be more suitable.</li>
<li>Memory constraints: if memory is a significant concern and you know the maximum size of your data structure beforehand, arrays might be more memory efficient. However, if the size is highly variable, linked lists can save space by not reserving unused memory.</li>
<li>Simplicity versus flexibility: array implementations are often simpler to code. Linked lists offer more flexibility for dynamic resizing and efficient modifications.</li>
</ul>
<p>When it comes to answer, it all depends on what operations we will perform the most (and where) and the space we need to store our data.</p>
<p>For stacks and queues, array implementations are often the default choice due to their simplicity. However, if you need to implement a queue with very frequent operations such as push/pop and queue/dequeue, a doubly linked list where we have the head and tail references might be more efficient. For deques, doubly linked lists are a natural fit, as they allow efficient insertion and removal at both ends at constant time.</p>
<blockquote>
<p>Since we've covered linked lists, a versatile dynamic data structure, put your knowledge to the test! Try re-implementing classic data structures like stacks, deques, and queues using linked lists instead of arrays. This hands-on exercise will deepen your understanding of both linked lists and these abstract data types. Plus, you can compare the performance and characteristics of your linked list-based versions with their array-based counterparts. For reference, you'll find these linked list implementations within the source code accompanying this book.</p>
</blockquote>
<p>Let's put our knowledge into practice with some exercises.</p>
</section>
<section id="exercises-4" class="level2" data-number="7.7">
<h2 data-number="7.7">Exercises</h2>
<p>We will resolve one exercise from <strong>LeetCode</strong> so we can learn another concept we have not covered in this chapter so far.</p>
<p>However, there are many fun linked list exercises available in LeetCode that we should be able to resolve with the concepts we learned in this chapter. Below are some additional suggestions you can try to resolve, and you can also find the solution along with the explanation within the source code from this book:</p>
<ul>
<li>2. Add Two Numbers: traverse two linked list and sum each number.</li>
<li>62. Rotate List: remove nodes from the tail and prepend them in the list.</li>
<li>203. Remove Linked List Elements: traverse the list and check for the value that needs to be removed. Tip: keep a previous reference to make the removal easier.</li>
<li>234. Palindrome Linked List: check if the elements of the list are a palindrome.</li>
<li>642. Design Circular Deque: implement the deque data structure.</li>
<li>622. Design Circular Queue implement the queue data structure.</li>
</ul>
<section id="reverse-linked-list" class="level3" data-number="7.7.1">
<h3 data-number="7.7.1">Reverse Linked List</h3>
<p>The exercise we will resolve the is the <em>206. Reverse Linked List</em> problem available at <a href="https://leetcode.com/problems/reverse-linked-list/description/">https://leetcode.com/problems/reverse-linked-list/description/</a>.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function <code>function reverseList(head: ListNode | null): ListNode | null</code>, which receives the head of a linked list and is expecting a node that represents the head of the reverse list. The <code>ListNode</code> class consists of a <code>val</code> (number), and the <code>next</code> pointer.</p>
<p>Let's write the <code>reverseList</code> function:</p>
<div class="C0-SHCodePACKT">
<pre><code>function reverseList(head: ListNode | null): ListNode | null {
  let current = head;
  let newHead = null;
  let nextNode = null;
  while (current) {
    nextNode = current.next;
    current.next = newHead;
    newHead = current;
    current = nextNode;
  }
  return newHead;
}</code></pre>
</div>
<p>To better understand what is happening in the code, let's use some diagrams. We will use the example provided by the exercise, which is a linked list with the following values: [1, 2, 3, 4, 5], and is expecting the following result: [5, 4, 3, 2, 1].</p>
<p>For this exercise, we will use three variables:</p>
<ol>
<li><code>current</code> points to the head of the list.</li>
<li><code>newHead</code> starts as <code>null</code>, representing the new head of the reversed list. It is also the variable we will return as a result of the function.</li>
<li><code>nextNode</code> is a temporary cursor for the next node in the original list.</li>
</ol>
<p>The logic consists only of a loop, which will traverse the entire list. Inside the loop we have four important operations:</p>
<ol>
<li><code>nextNode = current.next</code>: saves the next node before we modify the current node's links.</li>
<li><code>current.next = newHead</code>: reverses the current node's link to point to the previous node (which is now <code>newHead</code>).</li>
<li><code>newHead = current</code>: moves the <code>newHead</code> one step forward, making the <code>current</code> node the new head.</li>
<li><code>current = nextNode</code>: moves current to the next node (which was previously stored in <code>nextNode</code>).</li>
</ol>
<p>After the first pass inside the loop, this is how the list will look like:</p>
<figure>
<img src="../media/file51.png" alt="The reverse linked list after the first pass inside the while loop" width="1210" height="668"/><figcaption aria-hidden="true">The reverse linked list after the first pass inside the while loop</figcaption>
</figure>
<p>After the second pass on the loop, this is how the list will look like:</p>
<figure>
<img src="../media/file52.png" alt="The reverse linked list after the second pass inside the while loop" width="1211" height="682"/><figcaption aria-hidden="true">The reverse linked list after the second pass inside the while loop</figcaption>
</figure>
<p>And the process continues until <code>current</code> is <code>null</code> and the list is reversed. This solution passes all the tests and resolves the problem.</p>
<p>The time complexity of this function is <em>O(n)</em>, where <em>n</em> is the number of nodes we have in the list. The space complexity is <em>O(1)</em>, because we only used the additional variables to track the nodes and we are not using any additional space, as our solution reverses the linked list in place.</p>
<blockquote>
<p>Go back to the <code>LinkedList</code>, <code>DoublyLinkedList</code> and <code>CircularLinkedList</code> classes and create a method to reverse each list in place, following a similar logic we used to resolve this exercise. You will also find this method in the source of this book.</p>
</blockquote>
</section>
</section>
<section id="summary-5" class="level2" data-number="7.8">
<h2 data-number="7.8">Summary</h2>
<p>This chapter explored linked lists and their variations: singly, doubly, and circular. We covered insertion, removal, and traversal techniques, highlighting the advantage of linked lists over arrays for frequent element additions and removals due to their dynamic nature.</p>
<p>To solidify our knowledge, we built a media player, applying concepts like doubly circular and sorted linked lists. We also solved a LeetCode challenge, reversing linked lists in place for an added twist.</p>
<p>Get ready! Next up, we dive into sets, a unique data structure for storing distinct elements.</p>
</section>
</section>
</div>
</div>
</body>
</html>