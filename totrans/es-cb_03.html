<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Promises</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating and waiting for Promises</li>
<li>Resolving Promise results</li>
<li>Rejecting Promise errors</li>
<li>Chaining Promises</li>
<li>Starting a Promise chain with Promise.resolve</li>
<li>Using Promise.all to resolve multiple Promises</li>
<li>Handling errors with Promise.catch</li>
<li>Simulating finally with the Promise API</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In earlier versions of JavaScript, the callback pattern was the most common way to organize asynchronous code. It got the job done, but it didn't scale well. With callbacks, as more asynchronous functions are added, the code becomes more deeply nested, and it becomes more difficult to add to, refactor, and understand the code. This situation is commonly known as <strong>callback hell</strong>.</p>
<p>Promises were introduced to improve on this situation. Promises allow the relationships of asynchronous operations to be rearranged and organized with more freedom and flexibility.</p>
<p>The recipes in this chapter demonstrate how to use promises to create and organize asynchronous functions, as well as how to handle error conditions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and waiting for Promises</h1>
                </header>
            
            <article>
                
<p>Promises provide a way to compose and combine asynchronous functions in an organized and easier to read way. This recipe demonstrates a very basic usage of promises.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>03-01-creating-and-waiting-for-promises</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that creates a promise and logs messages before and after the promise is created, as well as while the promise is executing and after it has been resolved:</li>
</ol>
<pre style="padding-left: 60px">// main.js 
export function main () { 
 
  console.log('Before promise created'); 
 
  new Promise(function (resolve) { 
    console.log('Executing promise'); 
    resolve(); 
  }).then(function () { 
    console.log('Finished promise'); 
  }); 
 
  console.log('After promise created'); 
} </pre>
<ol start="5">
<li>Start your Python web server and open the following link in your browser:<br/>
<span class="URLPACKT"><kbd>http://localhost:8000/</kbd>.</span></li>
</ol>
<ol start="6">
<li>You will see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7bdb1f62-5603-4bd8-a3dd-15c0de1a0388.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By looking at the order of the log messages, you can clearly see the order of operations. First, the initial log is executed. Next, the promise is created with an executor method. The executor method takes <kbd>resolve</kbd> as an argument. The <kbd>resolve</kbd> function fulfills the promise.</p>
<p>Promises adhere to an interface named <strong>thenable</strong>. This means that we can chain <kbd>then</kbd> callbacks. The callback we attached with this method is executed after the <kbd>resolve</kbd> function is called. This function executes asynchronously (not immediately after the Promise has been resolved).</p>
<p>Finally, there is a log after the promise has been created.</p>
<p>The order the logs messages appear reveals the asynchronous nature of the code. All of the logs are seen in the order they appear in the code, except the <kbd>Finished promise</kbd> message. That function is executed asynchronously after the <kbd>main</kbd> function has exited!</p>
<p>We'll be looking more at <kbd>resolve</kbd>, <kbd>then</kbd>, and other parts of the promise API in later recipes in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving Promise results</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we saw how to use promises to execute asynchronous code. However, this code is pretty basic. It just logs a message and then calls <kbd>resolve</kbd>. Often, we want to use asynchronous code to perform some long-running operation, then return that value.</p>
<p>This recipe demonstrates how to use <kbd>resolve</kbd> in order to return the result of a long-running operation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li> Create a new folder named <kbd>3-02-resolving-promise-results.</kbd></li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that creates a promise and logs messages before and after the promise is created:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main () { 
 
  console.log('Before promise created'); 
 
  new Promise(function (resolve) { 
  }); 
 
  console.log('After promise created'); 
} </pre>
<ol start="5">
<li>Within the promise, resolve a random number after a 5-second timeout:</li>
</ol>
<pre style="padding-left: 60px">    new Promise(function (resolve) { 
<strong>      </strong><strong>setTimeout(function () {<br/></strong><strong>        resolve(Math.random());</strong><strong><br/>      }, 5000);</strong> 
    }) </pre>
<ol start="6">
<li>Chain a <kbd>then</kbd> call off the promise. Pass a function that logs out the value of its only argument:</li>
</ol>
<pre style="padding-left: 60px">   new Promise(function (resolve) { 
      setTimeout(function () { 
        resolve(Math.random()); 
      }, 5000); 
<strong>    }).then(function (result) {<br/></strong><strong>      console.log('Long running job returned: %s', result);<br/></strong><strong>    });</strong></pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd><span class="URLPACKT">http://localhost:8000/</span></kbd>.</li>
</ol>
<ol start="8">
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/ef489ed3-ef1d-4033-818f-ac8ae272c79a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Just as in the previous recipe, the promise was not fulfilled until <kbd>resolve</kbd> was executed (this time after 5 seconds). This time however, we passed the called  <kbd>resolve</kbd> immediately with a random number for an argument. When this happens, the argument is provided to the callback for the subsequent <kbd>then</kbd> function. We'll see in future recipes how this can be continued to create <em>promise chains</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rejecting Promise errors</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we saw how to use <kbd>resolve</kbd> to provide a result from a successfully fulfilled promise. Unfortunately, the code doesn't always run as expected. Network connections can be down, data can be corrupted, and uncountable other errors can occur. We need to be able to handle those situations as well.</p>
<p>This recipe demonstrates how to use <kbd>reject</kbd> when errors arise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>3-03-rejecting-promise-errors</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that creates a promise, and logs messages before and after the promise is created and when the promise is fulfilled:</li>
</ol>
<pre style="padding-left: 60px">   new Promise(function (resolve) { 
     resolve(); 
      }).then(function (result) { 
     console.log('Promise Completed'); 
   }); </pre>
<ol start="5">
<li>Add a second argument to the promise callback named <kbd>reject</kbd>, and call <kbd>reject</kbd> with a new error:</li>
</ol>
<pre style="padding-left: 60px">    new Promise(function (resolve, reject) { 
<strong>      reject(new Error('Something went wrong');</strong> 
    }).then(function (result) { 
    console.log('Promise Completed'); 
   }); </pre>
<ol start="6">
<li>Chain a <kbd>catch</kbd> call off the promise. Pass a function that logs out its only argument:</li>
</ol>
<pre style="padding-left: 60px">    new Promise(function (resolve, reject) { 
<strong>      reject(new Error('Something went wrong');</strong> 
     }).then(function (result) { 
     console.log('Promise Completed'); 
<strong>    }).catch(function (error) {</strong><strong>      console.error(error);</strong><strong>    });</strong></pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/71d45fae-07fe-42ff-ae36-1c9e231e02c4.png" style="width:46.42em;height:29.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Previously we saw how to use <kbd>resolve</kbd> to return a value in the case of a successful fulfillment of a promise. In this case we called <kbd>reject</kbd> before <kbd>resolve</kbd>. This means that the Promise finished with an error before it could <kbd>resolve</kbd>.</p>
<p>When the Promise completes in an error state, the <kbd>then</kbd> callbacks are not executed. Instead we have to use <kbd>catch</kbd> in order to receive the error that the Promise rejects. You'll also notice that the <kbd>catch</kbd> callback is only executed after the <kbd>main</kbd> function has returned. Like successful fulfillment, listeners to unsuccessful ones execute asynchronously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Handle errors with <kbd>Promise.catch</kbd></li>
<li>Simulating <kbd>finally</kbd> with <kbd>Promise.then</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chaining Promises</h1>
                </header>
            
            <article>
                
<p>So far in this chapter, we've seen how to use promises to run single asynchronous tasks. This is helpful but doesn't provide a significant improvement over the callback pattern. The real advantage that promises offer comes when they are composed.</p>
<p>In this recipe, we'll use promises to combine asynchronous functions in series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that  you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>3-04-chaining-promises.</kbd></li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that creates a promise. Resolve a random number from the promise:</li>
</ol>
<pre style="padding-left: 60px">   new Promise(function (resolve) { 
     resolve(Math.random()); 
   }); 
);  </pre>
<ol start="5">
<li>Chain a <kbd>then</kbd> call off of the promise. Return <kbd>true</kbd> from the callback if the random value is greater than or equal to <kbd>0.5</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    new Promise(function (resolve, reject) { 
         resolve(Math.random()); 
<strong>   })</strong><strong>.then(function(value) {<br/></strong><strong>     return value &gt;= 0.5;<br/>   </strong><strong>});</strong></pre>
<ol start="6">
<li>Chain a final <kbd>then</kbd> call after the previous one. Log out a different message if the argument is <kbd>true</kbd> or <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 60px">  new Promise(function (resolve, reject) { 
    resolve(Math.random()); 
  }).then(function (value) { 
    return value &gt;= 0.5; 
<strong>  }).then(function (isReadyForLaunch) {<br/>    </strong><strong>if (isReadyForLaunch) {<br/>      </strong><strong>console.log('Start the countdown! <img src="assets/f7032fb1-8d2d-4e6e-a0ab-03ac5a186a06.png" style="width:1.08em;height:1.08em;"/>');<br/>    </strong><strong>} else {<br/>      </strong><strong>console.log('Abort the mission. <img src="assets/4fac89e8-1ce7-4abd-936a-8346d71ba864.png" style="width:1.00em;height:1.00em;"/>');<br/>    </strong><strong>}<br/></strong><strong>});</strong></pre>
<ol start="7">
<li>
<p>Start your Python web server and open the following link in your browser: <br/>
<span><kbd>http://localhost:8000/</kbd>.</span></p>
</li>
<li>
<p>If you are lucky, you'll see the following output:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa6229fe-69df-45ab-8719-cbe79bcfc45a.png" style="width:40.50em;height:25.42em;"/></p>
<ol start="9">
<li><span>If you are unlucky, we'll see the following output:</span></li>
</ol>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/4cc84fb5-4ee0-4b96-ab5e-7c04286e2736.png" style="width:40.58em;height:25.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We've already seen how to use <kbd>then</kbd> to wait for the result of a promise. Here, we are doing the same thing multiple times in a row. This is called a promise chain. After the promise chain is started with the new promise, all of the subsequent links in the promise chain return promises as well. That is, the callback of each <kbd>then</kbd> function is <kbd>resolve</kbd> like another promise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Using <kbd>Promise.all</kbd> to resolve multiple Promises</li>
<li>Handle errors with <kbd>Promise.catch</kbd></li>
<li>Simulating <kbd>finally</kbd> with a final <kbd>Promise.then</kbd> call</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting a Promise chain with Promise.resolve</h1>
                </header>
            
            <article>
                
<p>In this chapter's preceding recipes, we've been creating new <kbd>promise</kbd> objects with the constructor. This gets the jobs done, but it creates a problem. The first callback in the promise chain has a different shape than the subsequent callbacks.</p>
<p>In the first callback, the arguments are the <kbd>resolve</kbd> and <kbd>reject</kbd> functions that trigger the subsequent <kbd>then</kbd> or <kbd>catch</kbd> callbacks. In subsequent callbacks, the returned value is propagated down the chain, and thrown errors are captured by <kbd>catch</kbd> callbacks. This difference adds mental overhead. It would be nice to have all of the functions in the chain behave in the same way.</p>
<p>In this recipe, we'll see how to use <kbd>Promise.resolve</kbd> to start a promise chain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li> Create a new folder named <kbd>3-05-starting-with-resolve</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that calls <kbd>Promise.resolve</kbd> with an empty object as the first argument:</li>
</ol>
<pre style="padding-left: 60px">export function main () { 
<strong>  Promise.resolve({})</strong> 
} </pre>
<ol start="5">
<li>Chain a <kbd>then</kbd> call off of <kbd>resolve</kbd>, and attach rocket boosters to the passed object:</li>
</ol>
<pre style="padding-left: 60px">export function main () { 
  Promise.resolve({})<strong>.then(function (rocket) {<br/></strong><strong>      console.log('attaching boosters');<br/></strong><strong>      rocket.boosters = [{<br/></strong><strong>        count: 2,<br/></strong><strong>        fuelType: 'solid'<br/></strong><strong>      }, {<br/></strong><strong>        count: 1,<br/></strong><strong>        fuelType: 'liquid'<br/></strong><strong>      }];<br/></strong><strong>      return rocket;<br/></strong><strong>    })<br/>}<br/></strong></pre>
<ol start="6">
<li>Add a final <kbd>then</kbd> call to the chain that lets you know when the <kbd>boosters</kbd> have been added:</li>
</ol>
<pre style="padding-left: 60px">export function main () { 
  Promise.resolve({}) 
    .then(function (rocket) { 
      console.log('attaching boosters'); 
      rocket.boosters = [{ 
        count: 2, 
        fuelType: 'solid' 
      }, { 
        count: 1, 
        fuelType: 'liquid' 
      }]; 
      return rocket; 
    }) 
<strong>    .then(function (rocket) {<br/></strong><strong>      console.log('boosters attached');<br/></strong><strong>      console.log(rocket);<br/></strong><strong>    })<br/>}<br/></strong></pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="8">
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/98a3cf67-7a70-4730-8851-b09312f9362b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>Promise.resolve</kbd> creates a new promise that resolves the value passed to it. The subsequent <kbd>then</kbd> method will receive that resolved value as it's argument. This method can seem a little roundabout but can be very helpful for composing asynchronous functions. In effect, the constituents of the promise chain don't need to be aware that they are in the chain (including the first step). This makes transitioning from code that doesn't use promises to code that does much easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Promise.all to resolve multiple promises</h1>
                </header>
            
            <article>
                
<p>So far, we've seen how to use promises to perform asynchronous operations in sequence. This is useful when the individual steps are long-running operations. However, this might not always be the more efficient configuration. Quite often, we can perform multiple asynchronous operations at the same time.</p>
<p>In this recipe, we'll see how to use <kbd>Promise.all</kbd> to start multiple asynchronous operations, without waiting for the previous one to complete.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>3-06-using-promise-all</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that creates an object named <kbd>rocket</kbd>, and calls <kbd>Promise.all</kbd> with an empty array as the first argument:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
  console.log('Before promise created'); 
 
  const rocket = {}; 
  Promise.all([]) 
 
  console.log('After promise created'); 
}  </pre>
<ol start="5">
<li>Create a function named <kbd>addBoosters</kbd> that creates an object with <kbd>boosters</kbd> to an object:</li>
</ol>
<pre style="padding-left: 60px">function addBoosters (rocket) { 
  console.log('attaching boosters'); 
  rocket.boosters = [{ 
    count: 2, 
    fuelType: 'solid' 
  }, { 
    count: 1, 
    fuelType: 'liquid' 
  }]; 
  return rocket;  
}   </pre>
<ol start="6">
<li>Create a function named <kbd>performGuidanceDiagnostic</kbd> that returns a promise of a successfully completed task:</li>
</ol>
<pre style="padding-left: 60px">function performGuidanceDiagnostic (rocket) { 
  console.log('performing guidance diagnostic'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function () { 
      console.log('guidance diagnostic complete'); 
      rocket.guidanceDiagnostic = 'Completed'; 
      resolve(rocket); 
    }, 2000); 
  }); 
}    </pre>
<ol start="7">
<li>Create a function named <kbd>loadCargo</kbd> that adds a payload to the <kbd>cargoBay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">function loadCargo (rocket) { 
  console.log('loading satellite'); 
  rocket.cargoBay = [{ name: 'Communication Satellite' }] 
  return rocket; 
}  </pre>
<ol start="8">
<li>Use <kbd>Promise.resolve</kbd> to pass the <kbd>rocket</kbd> object to these functions within <kbd>Promise.all</kbd>:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
 
  const rocket = {}; 
<strong>  Promise.all([<br/></strong><strong>    Promise.resolve(rocket).then(addBoosters),<br/></strong><strong>    Promise.resolve(rocket).then(performGuidanceDiagnostic),<br/></strong><strong>    Promise.resolve(rocket).then(loadCargo)<br/></strong><strong>  ]);</strong> 
 
  console.log('After promise created'); 
} </pre>
<ol start="9">
<li>Attach a <kbd>then</kbd> call to the chain and log that the rocket is ready for launch:</li>
</ol>
<pre style="padding-left: 60px">  const rocket = {}; 
  Promise.all([ 
    Promise.resolve(rocket).then(addBoosters), 
    Promise.resolve(rocket).then(performGuidanceDiagnostic), 
    Promise.resolve(rocket).then(loadCargo) 
<strong>  ]).then(function (results) {<br/></strong><strong>    console.log('Rocket ready for launch');<br/></strong><strong>    console.log(results);<br/></strong><strong>  });</strong></pre>
<ol start="10">
<li>
<p>Start your Python web server and open the following link in your browser: <br/>
<span><kbd>http://localhost:8000/</kbd>.</span></p>
</li>
</ol>
<ol start="11">
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b12bfb42-682b-46de-8112-3776f098ffc0.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root"><kbd>Promise.all</kbd> is similar to <kbd>Promise.resolve</kbd>; the arguments are resolved as promises. The difference is that instead of a single result, <kbd>Promise.all</kbd> accepts an <strong>iterable</strong> argument, each member of which is resolved individually.</p>
<p>In the preceding example, you can see that each of the promises is initiated immediately. Two of them are able to complete while <kbd>performGuidanceDiagnostic</kbd> continues. The promise returned by <kbd>Promise.all</kbd> is fulfilled when all the constituent promises have been resolved.</p>
<p>The results of the promises are combined into an array and propagated down the chain. You can see that three references to <kbd>rocket</kbd> are packed into the <kbd>results</kbd> argument. And you can see that the operations of each promise have been performed on the resulting object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>As you may have guessed, the results of the constituent promises don't have to return the same value. This can be useful, for example, when performing multiple independent network requests. The index of the result for each promise corresponds to the index of the operation within the argument to <kbd>Promise.all</kbd>. In these cases, it can be useful to use array destructuring to name the argument of the <kbd>then</kbd> callback:</p>
<pre> Promise.all([ 
  findAstronomers, 
  findAvailableTechnicians, 
  findAvailableEquipment 
]).then(function ([astronomers, technicians, equipment]) { 
  // use results for astronomers, technicians, and equipment 
}); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors with Promise.catch</h1>
                </header>
            
            <article>
                
<p>In a previous recipe, we saw how to fulfill a promise with an error state using <kbd>reject</kbd>, and we saw that this triggers the next <kbd>catch</kbd> callback in the promise chain. Because promises are relatively easy to compose, we need to be able to handle errors that are reported in different ways. Luckily promises are able to handle this seamlessly.</p>
<p>In this recipe, we'll see how <kbd>Promises.catch</kbd> can handle errors that are reported by being thrown or through rejection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li> Create a new folder named <kbd>3-07-handle-errors-promise-catch</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file with a <kbd>main</kbd> function that creates an object named <kbd>rocket</kbd>:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
 
  const rocket = {}; 
 
  console.log('After promise created'); 
} </pre>
<ol start="5">
<li>Create a function <kbd>addBoosters</kbd> that throws an error:</li>
</ol>
<pre style="padding-left: 60px">function addBoosters (rocket) { 
  throw new Error('Unable to add Boosters'); 
} </pre>
<ol start="6">
<li>Create a function <kbd>performGuidanceDiagnostic</kbd> that returns a promise that rejects an error:</li>
</ol>
<pre style="padding-left: 60px">function performGuidanceDiagnostic (rocket) { 
  return new Promise(function (resolve, reject) { 
    reject(new Error('Unable to finish guidance diagnostic')); 
  }); 
} </pre>
<ol start="7">
<li>Use <kbd>Promise.resolve</kbd> to pass the rocket object to these functions, and chain a <kbd>catch</kbd> off each of them:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
 
  const rocket = {}; 
<strong>  Promise.resolve(rocket).then(addBoosters)<br/></strong><strong>    .catch(console.error);<br/>  </strong><strong>Promise.resolve(rocket).then(performGuidanceDiagnostic)<br/></strong><strong>    .catch(console.error);</strong>
 
  console.log('After promise created'); 
}  </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="9">
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b439577-7ac8-4d07-8f84-a3c6163bea50.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As we saw before, when a promise is fulfilled in a rejected state, the callback of the <kbd>catch</kbd> functions is triggered. In the preceding recipe, we see that this can happen when the <kbd>reject</kbd> method is called (as with <kbd>performGuidanceDiagnostic</kbd>). It also happens when a function in the chain throws an error (as will <kbd>addBoosters</kbd>).</p>
<p>This has similar benefit to how <kbd>Promise.resolve</kbd> can normalize asynchronous functions. This handling allows asynchronous functions to not know about the promise chain, and announce error states in a way that is familiar to developers who are new to promises.</p>
<p>This makes expanding the use of promises much easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simulating finally with the promise API</h1>
                </header>
            
            <article>
                
<p>In a previous recipe, we saw how <kbd>catch</kbd> can be used to handle errors, whether a promise has rejected, or a callback has thrown an error. Sometimes, it is desirable to execute code whether or not an error state has been detected. In the context of <kbd>try</kbd>/<kbd>catch</kbd> blocks, the <kbd>finally</kbd> block can be used for this purpose. We have to do a little more work to get the same behavior when working with promises</p>
<p>In this recipe, we'll see how a final <kbd>then</kbd> call to execute some code in both successful and failing fulfillment states.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li> Create a new folder named <kbd>3-08-simulating-finally</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file with a <kbd>main</kbd> function that logs out messages for before and after promise creation:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
 
  console.log('After promise created'); 
} </pre>
<ol start="5">
<li>Create a function named <kbd>addBoosters</kbd> that throws an error if its first parameter is <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 60px">function addBoosters(shouldFail) { 
  if (shouldFail) { 
    throw new Error('Unable to add Boosters'); 
  } 
 
  return { 
    boosters: [{ 
      count: 2, 
      fuelType: 'solid' 
    }, { 
      count: 1, 
      fuelType: 'liquid' 
    }] 
  }; 
} </pre>
<ol start="6">
<li>Use <kbd>Promise.resolve</kbd> to pass a Boolean value that is <kbd>true</kbd> if a random number is greater than <kbd>0.5</kbd> to <kbd>addBoosters</kbd>:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
 
<strong>  Promise.resolve(Math.random() &gt; 0.5)<br/></strong><strong>    .then(addBoosters)</strong> 
 
  console.log('After promise created'); 
} </pre>
<ol start="7">
<li>Add a <kbd>then</kbd> function to the chain that logs a success message:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
  Promise.resolve(Math.random() &gt; 0.5) 
    .then(addBoosters) 
<strong>       .then(() =&gt; console.log('Ready for launch: <img src="assets/4a46c1bc-b445-489e-8cfc-b55eda1f0b5b.png" style="width:1.08em;height:1.08em;"/>'))</strong> 
 
  console.log('After promise created'); 
} </pre>
<ol start="8">
<li>Add a <kbd>catch</kbd> to the chain and log out the error if thrown:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
  console.log('Before promise created'); 
  Promise.resolve(Math.random() &gt; 0.5) 
    .then(addBoosters) 
    .then(() =&gt; console.log('Ready for launch: <img src="assets/4a46c1bc-b445-489e-8cfc-b55eda1f0b5b.png" style="width:1.08em;height:1.08em;"/>')) 
<strong>       .catch(console.error)</strong> 
  console.log('After promise created'); 
} </pre>
<ol start="9">
<li>Add a <kbd>then</kbd> after the <kbd>catch</kbd>, and log out that we need to make an announcement:</li>
</ol>
<pre style="padding-left: 60px">export function main() { 
 
  console.log('Before promise created'); 
  Promise.resolve(Math.random() &gt; 0.5) 
    .then(addBoosters) 
    .then(() =&gt; console.log('Ready for launch: <img src="assets/4a46c1bc-b445-489e-8cfc-b55eda1f0b5b.png" style="width:1.17em;height:1.17em;"/>')) 
    .catch(console.error)<br/>    .<strong>then(() =&gt; console.log('Time to inform the press.'));</strong> 
  console.log('After promise created'); 
} </pre>
<ol start="10">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>If you are lucky and the boosters are added successfully, you'll see the following output:</li>
</ol>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/8ee3df3b-4965-4107-98e1-3296c2962066.png"/></p>
<ol start="12">
<li>If you are unlucky, you'll see an error message like the following:</li>
</ol>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a58e2a09-c5ad-4405-bf52-42ac53443e84.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We can see in the preceding output that whether or not the asynchronous function completes in an error state, the last <kbd>then</kbd> callback is executed. This is possible because the <kbd>catch</kbd> method doesn't stop the promise chain. It simply catches any error states from the previous links in the chain, and then propagates a new value forward.</p>
<p>The final <kbd>then</kbd> is then protected from being bypassed by an error state by this <kbd>catch</kbd>. And so, regardless of the fulfillment state of prior links in the chain, we can be sure that the callback of this final <kbd>then</kbd> will be executed.</p>


            </article>

            
        </section>
    </body></html>