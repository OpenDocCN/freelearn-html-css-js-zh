["```js\n\"war AND peace\" => \"War And Peace\"\n\"Catcher in the Rye\" => \"Catcher In The Rye\"\n \"tO kILL A mOCKINGBIRD\" => \"To Kill A MockingBird\"\n```", "```js\n    function toTitleCase (input:string) : string {\n    ```", "```js\n        // split the string into an array on every occurrence of \n        //  the space character     const words = input.split(\" \");\n    ```", "```js\n        const titleWords = [];    // loop through each word     for (const word of words) {\n    ```", "```js\n        // take the first character using `slice` and convert it to uppercase     const initial = word.slice(0, 1).toLocaleUpperCase();    // take the rest of the character using `slice` and convert them to lowercase     const rest = word.slice(1).toLocaleLowerCase();    // join the initial and the rest and add them to the resulting array     titleWords.push(`${initial}${rest}`);\n    ```", "```js\n        // join all the processed words     const result = titleWords.join(\" \");    return result;}\n    ```", "```js\n    console.log(`toTitleCase(\"war AND peace\"):`);console.log(toTitleCase(\"war AND peace\")); console.log(`toTitleCase(\"Catcher in the Rye\"):`);console.log(toTitleCase(\"Catcher in the Rye\"));console.log(`toTitleCase(\"tO kILL A mOCKINGBIRD\"):`);console.log(toTitleCase(\"tO kILL A mOCKINGBIRD\"));\n    ```", "```js\n    toTitleCase(\"war AND peace\"):War And Peace toTitleCase(\"Catcher in the Rye\"):Catcher In The Rye toTitleCase(\"tO kILL A mOCKINGBIRD\"):To Kill A Mockingbird\n    ```", "```js\n    \"War and Peace\" => 3 \n    \"catcher-in-the-rye\" => 4 \n    \"for_whom the-bell-tolls\" => 5\n    ```", "```js\n    function countWords (input: string): number {\n    ```", "```js\n        const words = input.split(/[ _-]/);\n    ```", "```js\n        return words.length;\n    }\n    ```", "```js\n    console.log(`countWords(\"War and Peace\"):`);\n    console.log(countWords(\"War and Peace\"));\n\n    console.log(`countWords(\"catcher-in-the-rye\"):`);\n    console.log(countWords(\"catcher-in-the-rye\"));\n    console.log(`countWords(\"for_whom the-bell-tolls\"):`);\n    console.log(countWords(\"for_whom the-bell-tolls\"));\n    ```", "```js\n\"War and Peace\" => [War, and, peace]\n\"catcher-in-the-rye\" => [catcher, in, the, rye]\n\"for_whom the-bell-tolls\" => [for, whom, the, bell, tolls]\n```", "```js\n    function toWords (input: string): string[] {\n    ```", "```js\n       const words = input.split(/[ _-]/);\n    ```", "```js\n        // return the words that were split     return words;}\n    ```", "```js\n    console.log(`toWords(\"War and Peace\"):`);console.log(toWords(\"War and Peace\")); console.log(`toWords(\"catcher-in-the-rye\"):`);console.log(toWords(\"catcher-in-the-rye\"));console.log(`toWords(\"for_whom the-bell-tolls\"):`);console.log(toWords(\"for_whom the-bell-tolls\"));\n    ```", "```js\n    toWords(\"War and Peace\"):[ 'War', 'and', 'Peace' ]toWords(\"catcher-in-the-rye\"):[ 'catcher', 'in', 'the', 'rye' ]toWords(\"for_whom the-bell-tolls\"):[ 'for', 'whom', 'the', 'bell', 'tolls' ]\n    ```", "```js\n„War\", 3 => „WarWarWar\"\n„rye\", 1 => „rye\"\n„bell\", 0 => „\"\n```", "```js\n    function repeat (input: string, times: number): string {\n    ```", "```js\n        // create a new array that with length of `times`    // and set each element to the value of the `input` string     const instances = new Array(times).fill(input);\n    ```", "```js\n        // join the elements of the array together     const result = instances.join(\"\");    return result;}\n    ```", "```js\n    console.log(`repeat(\"War\", 3 ):`);console.log(repeat(\"War\", 3 )); console.log(`repeat(\"rye\", 1):`);console.log(repeat(\"rye\", 1));console.log(`repeat(\"bell\", 0):`);console.log(repeat(\"bell\", 0));\n    ```", "```js\n    repeat(\"War\", 3 ):WarWarWar repeat(\"rye\", 1):rye repeat(\"bell\", 0):\n    ```", "```js\n\"War and Peace\" => false\n\"Atonement\" => true\n\"1Q84\" => false\n```", "```js\n    function isAlpha (input: string): boolean {\n    ```", "```js\n    // regex that will match any string that only has upper and  //lowercase letters     const alphaRegex = /^[a-z]*$/i\n    ```", "```js\n        // test our input using the regex     const result = alphaRegex.test(input);    return result;}\n    ```", "```js\n    console.log(`isAlpha(\"War and Peace\"):`);console.log(isAlpha(\"War and Peace\")); console.log(`isAlpha(\"Atonement\"):`);console.log(isAlpha(\"Atonement\"));console.log(`isAlpha(\"1Q84\"):`);console.log(isAlpha(\"1Q84\"));\n    ```", "```js\n    isAlpha(\"War and Peace\"):false isAlpha(\"Atonement\"):true isAlpha(\"1Q84\"):false\n    ```", "```js\n\"War and Peace\" => false\n\"       \" => true\n\"\" => true\n```", "```js\n    function isBlank (input: string): boolean {\n    ```", "```js\n    // test if the first character of our input is an empty space     while (input[0] === \" \") {// successively slice off the first character of the input         input = input.slice(1);    }\n    ```", "```js\n    // the loop will stop on the first character that is not a //space.// if we're left with an empty string, we only have spaces in // the input     const result = input === \"\";    return result;\n    ```", "```js\n    console.log(`isBlank(\"War and Peace\"):`);console.log(isBlank(\"War and Peace\")); console.log(`isBlank(\"       \"):`);console.log(isBlank(\"       \"));console.log(`isBlank(\"\"):`);console.log(isBlank(\"\"));\n    ```", "```js\n    isBlank(\"War and Peace\"):false isBlank(\"       \"):true isBlank(\"\"):true\n    ```", "```js\n    cd activity-starter\n    ```", "```js\n    npm install\n    ```", "```js\n    declare module \"HeatMapTypes\" {\n      export interface Pitcher {\n        batterHotZones: Array<Array<number>>;\n        pitcherHotZones: Array<Array<number>>;\n        coordinateMap?: Array<any>;\n      }\n    }\n    ```", "```js\n    /// <reference path=\"./types/HeatMapTypes.d.ts\"/>\n    import hmt = require('HeatMapTypes');\n    import _ = require('lodash');\n    export let data: hmt.Pitcher;\n    ```", "```js\n    data = {\n      batterHotZones: [[12.2, -3], [10.2, -5], [3, 2]],\n      pitcherHotZones: [[3, 2], [-12.2, 3], [-10.2, 5]],\n    };\n    ```", "```js\n    export const findMatch = (batterHotZones, pitcherHotZones) => {\n      return _.intersectionWith(batterHotZones, pitcherHotZones, _.isEqual);\n    };\n    data.coordinateMap = findMatch(data.batterHotZones, data.pitcherHotZones);\n    console.log(data.coordinateMap);\n    ```", "```js\n    tsc heat_map_data.ts\n    node heat_map_data.js\n    ```", "```js\n    [[3,2]]\n    ```", "```js\n    data = {\n      batterHotZones: [[12.2, -3], [10.2, -5], [3, 2]],\n      pitcherHotZones: [[3, 2], [-12.2, 3], [10.2, -5]],\n    };\n    ```", "```js\n    tsc heat_map_data.ts\n    node heat_map_data.js\n    ```", "```js\n    [[10.2, -5], [3, 2]]\n    ```", "```js\n    npx ts-node index.ts Not implemented!\n    ```", "```js\n    export const checkAvailability = (\n      flight: Flight,\n      seatsRequested: number\n    ): boolean => seatsRequested <= flight.seatsRemaining - flight.seatsHeld;\n    ```", "```js\n    export const holdSeats = (flight: Flight, seatsRequested: number): Flight => {\n      if (flight.seatsRemaining - flight.seatsHeld < seatsRequested) {\n        throw new Error('Not enough seats remaining!');\n      }\n      flight.seatsHeld += seatsRequested;\n      return flight;\n    };\n    ```", "```js\n    export const reserveSeats = (\n      flight: Flight,\n      seatsRequested: number\n    ): Flight => {\n      if (flight.seatsHeld < seatsRequested) {\n        throw new Error('Seats were not held!');\n      }\n      flight.seatsHeld -= seatsRequested;\n      flight.seatsRemaining -= seatsRequested;\n      return flight;\n    };\n    ```", "```js\n    const bookingsFactory = (bookingNumber: number) => (\n      flight: Flight,\n      seatsHeld: number\n    ): Booking => ({\n      bookingNumber: bookingNumber++,\n      flight,\n      paid: false,\n      seatsHeld,\n      seatsReserved: 0,\n    });\n    ```", "```js\n    const createBooking = bookingsFactory(1);\n    ```", "```js\n      export const startBooking = (\n      flight: Flight,\n      seatsRequested: number\n    ): Booking => {\n      if (checkAvailability(flight, seatsRequested)) {\n        holdSeats(flight, seatsRequested);\n        return createBooking(flight, seatsRequested);\n      }\n      throw new Error('Booking not available!');\n    };\n    ```", "```js\n    export const processPayment = (booking: Booking): Booking => {\n      booking.paid = true;\n      return booking;\n    };\n    ```", "```js\n    export const completeBooking = (booking: Booking): Booking => {\n    reserveSeats(booking.flight, booking.seatsHeld);\n    booking.seatsReserved = booking.seatsHeld;\n    booking.seatsHeld = 0;\n    return booking;\n    };\n    ```", "```js\n    npx ts-node index.ts\n    Booked to Lagos {\n      bookingNumber: 1,\n      flight: {\n        destination: 'Lagos',\n        flightNumber: 1,\n        seatsHeld: 0,\n        seatsRemaining: 29,\n        time: '5:30'\n      },\n      paid: true,\n      seatsHeld: 0,\n      seatsReserved: 1\n    }\n    //...\n    Istanbul flight {\n      destination: 'Istanbul',\n      flightNumber: 7,\n      seatsHeld: 0,\n      seatsRemaining: 0,\n      time: '14:30'\n    }\n    Booking not available!\n    ```", "```js\n      test('get destinations', () => {\n        expect(destinations).toHaveLength(7);\n      });\n    ```", "```js\n      test('checking availability', () => {\n        const destinations = getDestinations();\n        expect(checkAvailability(destinations[0], 3)).toBeTruthy();\n        expect(checkAvailability(destinations[1], 5)).toBeFalsy();\n        expect(checkAvailability(destinations[2], 300)).toBeFalsy();\n        expect(checkAvailability(destinations[3], 3)).toBeTruthy();\n      });\n    ```", "```js\n      test('hold seats', () => {\n        expect.assertions(3);\n        flight = holdSeats(flight, 3);\n        expect(flight.seatsHeld).toBe(3);\n        flight = holdSeats(flight, 13);\n        expect(flight.seatsHeld).toBe(16);\n        try {\n          holdSeats(flight, 15);\n        } catch (e) {\n          expect(e.message).toBe('Not enough seats remaining!');\n        }\n      });\n    ```", "```js\n      test('reserve seats', () => {\n        expect.assertions(3);\n        flight = reserveSeats(flight, 3);\n        expect(flight.seatsRemaining).toBe(27);\n        flight = reserveSeats(flight, 13);\n        expect(flight.seatsRemaining).toBe(14);\n        try {\n          reserveSeats(flight, 1);\n        } catch (e) {\n          expect(e.message).toBe('Seats were not held!');\n        }\n      });\n    ```", "```js\n    describe('bookings tests', () => {\n      test('create a booking', () => {\n        const booking = startBooking(destinations[0], 3);\n        expect(booking).toEqual({\n          bookingNumber: 1,\n          flight: destinations[0],\n          paid: false,\n          seatsHeld: 3,\n          seatsReserved: 0,\n        });\n      });\n      test('pay for a booking', () => {\n        let booking = startBooking(destinations[0], 3);\n        booking = processPayment(booking);\n        expect(booking.paid).toBe(true);\n      });\n      test('complete a booking', () => {\n        let booking = startBooking(destinations[0], 3);\n        booking = processPayment(booking);\n        booking = completeBooking(booking);\n        expect(booking.paid).toBe(true);\n        expect(booking.seatsReserved).toBe(3);\n      });\n    });\n    ```", "```js\n    npm test\n    > jest --coverage --testRegex=\"^((?!-solution).)*\\\\.test\\\\.tsx?$\"\n     PASS  ./bookings.test.ts\n     PASS  ./flights.test.ts\n    -------------|---------|----------|---------|---------|-------------------\n    File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n    -------------|---------|----------|---------|---------|-------------------\n    All files    |   97.14 |    83.33 |     100 |   96.97 |\n     bookings.ts |   94.74 |       50 |     100 |   94.44 | 34\n     flights.ts  |     100 |      100 |     100 |     100 |\n    -------------|---------|----------|---------|---------|-------------------\n    Test Suites: 2 passed, 2 total\n    Tests:       7 passed, 7 total\n    Snapshots:   0 total\n    Time:        1.782 s\n    Ran all test suites.\n    ```", "```js\n    describe('error scenarios', () => {\n      test('booking must have availability', () => {\n        expect.assertions(1);\n        try {\n          startBooking(destinations[6], 8);\n        } catch (e) {\n          expect(e.message).toBe('Booking not available!');\n        }\n      });\n    });\n    ```", "```js\n    npm test\n    > jest --coverage --testRegex=\"^((?!-solution).)*\\\\.test\\\\.tsx?$\" PASS  ./bookings-solution.test.ts\n     PASS  ./flights-solution.test.ts\n    -------------|---------|----------|---------|---------|-------------------\n    File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n    -------------|---------|----------|---------|---------|-------------------\n    All files    |     100 |      100 |     100 |     100 |\n     bookings.ts |     100 |      100 |     100 |     100 |\n     flights.ts  |     100 |      100 |     100 |     100 |\n    -------------|---------|----------|---------|---------|-------------------\n    Test Suites: 2 passed, 2 total\n    Tests:       8 passed, 8 total\n    Snapshots:   0 total\n    Time:        0.694 s, estimated 1 s\n    Ran all test suites.\n    ```", "```js\n    npm install\n    ```", "```js\n    interface ILogin{\n        email: string;\n        password:string;\n    }\n    ```", "```js\n    export class Login{\n        email: string;\n        password: string;\n        constructor(args: ILogin){\n            this.email = args.email;\n            this.password = args.password;\n        }\n    }\n    ```", "```js\n    interface IAuth{\n        user: Login;\n        source: string;\n    } \n    ```", "```js\n    export default class Auth{\n        user: Login;\n        source: string;\n        constructor(args: IAuth){\n            this.user = args.user;\n            this.source = args.source;\n        }\n    }\n    ```", "```js\n    validUser(): string{\n        const { email, password } = this.user;\n        if(email === \"admin@example.com\"       && password === \"secret123\"){\n            return `Validating user…User is authenticated: true`;\n        } else {\n            return `Validating user…User is authenticated: false`;\n        }\n    }\n    ```", "```js\n    const goodUser = new Login({\n        email: \"admin@example.com\",\n        password: \"secret123\"\n    });\n    const badUser = new Login({\n        email: \"admin@example.com\",\n        password: \"whoops\"\n    });\n    ```", "```js\n    const authAttemptFromGoodUser = new Auth({\n        user: goodUser,\n        source: \"Google\"\n    });\n    console.log(authAttemptFromGoodUser.validUser());\n    const authAttemptFromBadUser = new Auth({\n        user: badUser,\n        source: \"Google\"\n    });\n    console.log(authAttemptFromBadUser.validUser());\n    ```", "```js\n    tsc auth.ts\n    node auth.js\n    ```", "```js\n    Validating user…User is authenticated: true\n    Validating user…User is authenticated: false\n    ```", "```js\n    interface UserObj {\n        email: string\n        loginAt?: number\n        token?: string\n    }\n    ```", "```js\n    interface UserClass {\n        user: UserObj\n        getUser(): UserObj\n        login(user: UserObj, password: string):UserObj\n    }\n    ```", "```js\n    class User implements UserClass {\n\n        user:UserObj\n        getUser(): UserObj {\n            return this.user\n        }\n        login(user:  UserObj, password: string): UserObj {\n            // set props user object\n            return this.user = user\n        }\n    }\n    ```", "```js\n    const newUserClass:UserClass = new User()\n    ```", "```js\n    const newUser: UserObj = {\n        email: \"home@home.com\",\n        loginAt: new Date().getTime(),\n        token: \"123456\"\n    }\n    ```", "```js\n    console.log(\n        newUserClass.login(newUser, \"password123\")\n    )\n    console.log(\n        newUserClass.getUser()\n    )\n    ```", "```js\n    { email: 'home@home.com', loginAt: 1614068072515, token: '123456' }\n    { email: 'home@home.com', loginAt: 1614068072515, token: '123456' }\n    ```", "```js\n    class Motor {\n        private name: string\n        wheels: number\n        bodyType: string\n        constructor(name: string, wheels: number, bodyType: string) {\n            this.name = name\n            this.wheels = wheels\n            this.bodyType = bodyType\n        }\n        protected getName(): string {\n            return this.name\n        }\n        buildMotor() {\n            return {\n                wheels: this.wheels,\n                bodyType: this.bodyType,\n                name: this.name\n            }\n        }\n    }\n    ```", "```js\n    class Car extends Motor {\n        rideHeight: number\n        constructor(name: string, wheels: number, bodyType: string, rideHeight: number) {\n            super(name, wheels, bodyType)\n            this.rideHeight = rideHeight\n        }\n        _buildMotor() {\n            return {\n                ...super.buildMotor,\n                rideHeight: this.rideHeight\n            }\n        }\n    }\n    class Truck extends Motor {\n        offRoad: boolean\n        constructor(name: string, wheels: number, bodyType: string, offRoad: boolean) {\n            super(name, wheels, bodyType)\n            this.offRoad = offRoad\n        }\n        _buildMotor() {\n            return {\n                wheels: this.wheels,\n                bodyType: this.bodyType,\n                offRoad: this.offRoad\n            }\n        }\n    }\n    ```", "```js\n    class Suv extends Truck {\n        roofRack: boolean\n        thirdRow: boolean\n        constructor(name: string, wheels: number, bodyType: string, \n            offRoad: boolean, roofRack: boolean, thirdRow: boolean) {\n            super(name, wheels, bodyType, offRoad)\n            this.roofRack = roofRack;\n            this.thirdRow = thirdRow\n        }\n    }\n    ```", "```js\n    const car: Car = new Car('blueBird', 4, 'sedan', 14)\n    const truck: Truck = new Truck('blueBird', 4, 'sedan', true)\n    const suv: Suv = new Suv('xtrail', 4, 'box', true, true, true)\n    ```", "```js\n    console.log(car)\n    console.log(truck)\n    console.log(suv)\n    ```", "```js\n    Car { name: 'blueBird', wheels: 4, bodyType: 'sedan', rideHeight: 14 }\n    Truck { name: 'blueBird', wheels: 4, bodyType: 'sedan', offRoad: true }\n    Suv {\n      name: 'xtrail',\n      wheels: 4,\n      bodyType: 'box',\n      offRoad: true,\n      roofRack: true,\n      thirdRow: true\n    }\n    ```", "```js\n    type Motor = {\n        color: string;\n        doors: number;\n        wheels: number;\n        fourWheelDrive: boolean;\n    }\n    ```", "```js\n    type Truck = {\n        doubleCab: boolean;\n        winch: boolean;\n    } \n    ```", "```js\n    type PickUpTruck = Motor & Truck;\n    ```", "```js\n    function TruckBuilder (truck: PickUpTruck): PickUpTruck {\n        return truck\n    }\n    const pickUpTruck: PickUpTruck = {\n        color: 'red',\n        doors: 4,\n        doubleCab: true,\n        wheels: 4,\n        fourWheelDrive: true,\n        winch: true\n    }\n    ```", "```js\n    console.log (\n        TruckBuilder(pickUpTruck)\n    )\n    ```", "```js\n    {\n      color: 'red',\n      doors: 4,\n      doubleCab: true,\n      wheels: 4,\n      fourWheelDrive: true,\n      winch: true\n    }\n    ```", "```js\n    type LandPack = {\n        height: number,\n        weight: number,\n        type: \"land\",\n        label?: string };\n    type AirPack = {\n        height: number,\n        weight: number,\n        type : \"air\",\n        label?: string };\n    ```", "```js\n    type ComboPack = LandPack | AirPack\n    ```", "```js\n    class Shipping {\n        Process(pack: ComboPack) {\n            // check package type\n            if(pack.type === \"land\") {\n                return this.ToLand(pack);\n            } else {\n                return this.ToAir(pack);\n            }\n        }\n        ToAir(pack: AirPack): AirPack {\n            pack.label = \"air cargo\"\n            return pack;\n        }\n        ToLand(pack: LandPack): LandPack {\n            pack.label = \"land cargo\"\n            return pack;\n        }\n    }\n    ```", "```js\n    const airPack: AirPack = {\n        height: 5,\n        weight: 10,\n        type: \"air\",\n    };\n    const landPack: LandPack = {\n        height: 5,\n        weight: 10,\n        type: \"land\",\n    };\n    const shipping = new Shipping;\n    console.log(\n        shipping.Process(airPack)\n    );\n    console.log(\n        shipping.Process(landPack)\n    );\n    ```", "```js\n    { height: 5, weight: 10, type: 'air', label: 'air cargo' }\n    { height: 5, weight: 10, type: 'land', label: 'land cargo' } \n    ```", "```js\n    interface PackageStatus { \n        [status: string]: boolean;}\n    ```", "```js\n    type Package = {\n        packageStatus: PackageStatus,\n        barcode:  number,\n        weight: number\n    }\n    ```", "```js\n    class PackageProcess {\n\n        pack: Package\n        constructor(pack: Package) {\n            this.pack = pack;\n        }\n\n        Status () {\n            return this.pack.packageStatus;\n        }\n        UpdateStatus(status: string, state: boolean) {\n            this.pack.packageStatus[status] = state;\n            return this.Status();}\n    }\n    ```", "```js\n    const pack: Package = {\n        packageStatus: {\"shipped\": false, \"packed\": true, \"delivered\": true},\n        barcode: 123456,\n        weight: 28 \n    };\n    ```", "```js\n    const processPack = new PackageProcess(pack)\n    ```", "```js\n    console.log(processPack.Status());\n    ```", "```js\n    console.log(\n        processPack.UpdateStatus(\"shipped\", true)\n    );\n    ```", "```js\n    { shipped: false, packed: true, delivered: true }\n    { shipped: true, packed: true, delivered: true }\n    ```", "```js\n    class Person {\n             constructor (public firstName: string, \n                         public lastName: string, \n                         public birthDate: Date) {\n             }\n    }\n    ```", "```js\n        private _title: string;\n        public get title() {\n            return this._title;\n        }\n        public set title(value: string) {\n            this._title = value;\n        }\n    ```", "```js\n        public getFullName() {\n            return `${this.firstName} ${this.lastName}`;\n        }\n    ```", "```js\n        public getAge() {\n            // only sometimes accurate\n            const now = new Date();\n            return now.getFullYear() – this.birthDate.getFullYear();\n        }\n    ```", "```js\n    const count = {};\n    ```", "```js\n    type Constructable = { new (...args: any[]): {} };\n    function CountClass(counterName: string) {\n        return function <T extends Constructable>(constructor: T) {\n            // wrapping code here\n        }\n    }\n    ```", "```js\n        const wrappedConstructor: any = function (...args: any[]) {\n            const result = new constructor(...args);\n            if (count[counterName]) {\n                count[counterName]+=1;\n            } else {\n                count[counterName]=1;\n            }\n            return result;\n        };\n        wrappedConstructor.prototype = constructor.prototype;\n        return wrappedConstructor;\n    ```", "```js\n    function CountMethod(counterName: string) {\n        return function (target: any, propertyName: string, \n                         descriptor: PropertyDescriptor) {\n            // method wrapping code here\n        }\n    }\n    ```", "```js\n        if (descriptor.value) {\n            // method decoration code\n        }\n        if (descriptor.get) {\n            // get property accessor decoration code\n        }\n        if (descriptor.set) {\n            // set property accessor decoration code\n        }\n    ```", "```js\n        // method decoration code\n        const original = descriptor.value;\n        descriptor.value = function (...args: any[]) {\n            // counter management code here\n            return original.apply(this, args);\n        }\n        // get property accessor decoration code\n        const original = descriptor.get;\n        descriptor.get = function () {\n            // counter management code here\n            return original.apply(this, []);\n        }\n        // set property accessor decoration code\n        const original = descriptor.set;\n        descriptor.set = function (value: any) {\n            // counter management code here\n            return original.apply(this, [value]);\n        }\n    ```", "```js\n            // counter management code\n            if (count[counterName]) {\n                count[counterName]+=1;\n            } else {\n                count[counterName]=1;\n            }          \n    ```", "```js\n    @CountClass('person')\n    class Person{\n    ```", "```js\n        @CountMethod('person-full-name')\n        public getFullName() {\n        @CountMethod('person-age')\n        public getAge() {\n        @CountMethod('person-title')\n        public get title() {\n    ```", "```js\n    const first = new Person(\"Brendan\", \"Eich\", new Date(1961,6,4));\n    const second = new Person(\"Anders\", \"Hejlsberg \", new Date(1960,11,2));\n    const third = new Person(\"Alan\", \"Turing\", new Date(1912,5,23));\n    ```", "```js\n    const fname = first.getFullName();\n    const sname = second.getFullName();\n    const tname = third.getFullName();\n    const fage = first.getAge();\n    const sage = second.getAge();\n    const tage = third.getAge();\n    ```", "```js\n    if (!first.title) {\n        first.title = \"Mr.\"\n    }\n    if (!second.title) {\n        second.title = \"Mr.\"\n    }\n    if (!third.title) {\n        third.title = \"Mr.\"\n    }\n    ```", "```js\n    console.log(count);\n    ```", "```js\n    {\n      person: 3,\n      'person-full-name': 3,\n      'person-age': 3,\n      'person-title': 6\n    }\n    ```", "```js\n        interface Team {\n            score: number;\n            name: string;\n        }\n        class BasketBallGame {\n            private team1: Team;\n            private team2: Team;\n            constructor(teamName1: string, teamName2: string) {\n                this.team1 = { score: 0, name: teamName1 };\n                this.team2 = { score: 0, name: teamName2 };\n            }\n            getScore() {\n                return `${this.team1.score}:${this.team2.score}`;\n            }\n            updateScore(byPoints: number, updateTeam1: boolean) {\n                if (updateTeam1) {\n                    this.team1.score += byPoints;\n                } else {\n                    this.team2.score += byPoints;\n                }\n            }\n        }\n    ```", "```js\n        type Constructable = { new (...args: any[]): {} };\n        function Authenticate(permission: string) {\n            return function <T extends Constructable>(constructor: T) {\n                const wrappedConstructor: any = function (...args: any[]) {\n                    if (Reflect.hasMetadata(\"permissions\", wrappedConstructor)) {\n                        const permissions = Reflect.getMetadata(\"permissions\", \n                                                         wrappedConstructor) as string[];\n                        if (!permissions.includes(permission)) {\n                            throw Error(`Permission ${permission} not present`);\n                        }\n                    }\n                    const result = new constructor(...args);\n                    return result;\n                };\n                wrappedConstructor.prototype = constructor.prototype;\n                return wrappedConstructor;\n            };\n        }\n    ```", "```js\n        Reflect.defineMetadata(\"permissions\", [\"canUpdateScore\"], BasketBallGame);\n    ```", "```js\n        @Authenticate(\"canUpdateScore\")\n        class BasketBallGame {\n    ```", "```js\n        function MeasureDuration() {\n            return function (target: any, propertyName: string, \n                                         descriptor: PropertyDescriptor) {\n                if (descriptor.value) {\n                    const original = descriptor.value;\n                    descriptor.value = function (...args: any[]) {\n                        const start = Date.now();\n                        const result = original.apply(this, args);\n                        const end = Date.now();\n                        const duration = end-start;\n                        if (Reflect.hasMetadata(\"durations\", target, propertyName)) {\n                          const existing = Reflect.getMetadata(\"durations\", \n                                                       target, propertyName) as number[];\n                          Reflect.defineMetadata(\"durations\", existing.concat(duration),\n                                                       target, propertyName);\n                        } else {\n                          Reflect.defineMetadata(\"durations\", [duration], \n                                                       target, propertyName)\n                        }\n                        return result;\n                    }\n                }\n            }\n        }\n    ```", "```js\n        @MeasureDuration()\n        updateScore(byPoints: number, updateTeam1: boolean) {\n    ```", "```js\n        function Audit(message: string) {\n            return function (target: any, propertyName: string, \n                                          descriptor: PropertyDescriptor) {\n              if (descriptor.value) {\n                const original = descriptor.value;\n                descriptor.value = function (...args: any[]) {\n                  const result = original.apply(this, args);\n                  console.log(`[AUDIT] ${message} (${propertyName}) called with:`)\n                  console.log(\"[AUDIT]\", args);\n                  console.log(\"[AUDIT] and returned result:\")\n                  console.log(\"[AUDIT]\", result);\n                  return result;\n                }\n              }\n           }\n        }\n    ```", "```js\n        @MeasureDuration()\n        @Audit(\"Updated score\")\n        updateScore(byPoints: number, updateTeam1: boolean) {\n    ```", "```js\n        function OneTwoThree(target: any, propertyKey: string, \n                                          parameterIndex: number) {\n            if (Reflect.hasMetadata(\"one-two-three\", target, propertyKey)) {\n                const existing = Reflect.getMetadata(\"one-two-three\",\n                                               target, propertyKey) as number[];\n                Reflect.defineMetadata(\"one-two-three\", \n                           existing.concat(parameterIndex), target, propertyKey);\n            } else {\n                Reflect.defineMetadata(\"one-two-three\", \n                                          [parameterIndex], target, propertyKey);\n            }\n        }\n    ```", "```js\n        function Validate() {\n          return function (target: any, propertyKey:string, \n                                          descriptor: PropertyDescriptor) {\n                const original = descriptor.value;\n                descriptor.value = function (...args: any[]) {\n                    // validate parameters\n                    if (Reflect.hasMetadata(\"one-two-three\", \n                                            target, propertyKey)) {\n                        const markedParams = Reflect.getMetadata(\"one-two-three\",\n                                            target, propertyKey) as number[];\n                        for (const marked of markedParams) {\n                            if (![1,2,3].includes(args[marked])) {\n                                throw Error(`The parameter at position ${marked} can only be 1, 2 or 3`);\n                            }\n                        }\n                    }\n                    return original.apply(this, args);\n                }\n            }\n        }\n    ```", "```js\n        @MeasureDuration()\n        @Audit(\"Updated score\")\n        @Validate()\n        updateScore(@OneTwoThree byPoints: number, updateTeam1: boolean) {\n    ```", "```js\n    const game = new BasketBallGame(\"LA Lakers\", \"Boston Celtics\");\n    game.updateScore(3, true);\n    game.updateScore(2, false);\n    game.updateScore(2, true);\n    game.updateScore(2, false);\n    game.updateScore(2, false);\n    game.updateScore(2, true);\n    game.updateScore(2, false);\n    ```", "```js\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 3, true ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, false ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, true ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, false ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, false ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, true ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, false ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    7:8\n    ```", "```js\n    export interface Operator {\n        readonly symbol: string;\n        evaluate(a: number, b: number): number;\n    }\n    ```", "```js\n    import { Operator } from '../interfaces/operator.interface';\n    export class AddOperator implements Operator {\n        readonly symbol = '+';\n        public evaluate(a: number, b: number) {\n        return a + b;\n        }\n    }\n    ```", "```js\n    import { injectable } from 'inversify';\n    import { Operator } from '../interfaces/operator.interface';\n    @injectable()\n    export class AddOperator implements Operator {\n        readonly symbol = '+';\n        public evaluate(a: number, b: number) {\n            return a + b;\n        }\n    }\n    ```", "```js\n    export const TYPES = {\n        AddOperator: Symbol.for('AddOperator'),\n    };\n    ```", "```js\n    import { injectable, inject } from 'inversify';\n    import { TYPES } from '../types';\n    import { AddOperator } from '../operators/add.operator';\n    @injectable()\n    export class Calculator {\n        constructor(@inject(TYPES.AddOperator) private addOperator: AddOperator) {}\n        evaluate(expression: string) {\n            const expressionParts = expression.match(/[\\d\\.]+|\\D+/g);\n            if (expressionParts === null) return null;\n            // for now, we're only going to support basic expressions: X+Y\n            const [operandA, operator, operandB] = expressionParts;\n            if (operator !== this.addOperator.symbol) {\n                throw new Error(`Unsupported operator. Expected ${this.addOperator.symbol}, received: ${operator}.`);\n            }\n            const result = this.addOperator.evaluate(Number(operandA), Number(operandB));\n            return result;\n        }\n    }\n    ```", "```js\n    import { Container } from 'inversify';\n    import { Calculator } from './calculator/index';\n    import { Operator } from './interfaces/operator.interface';\n    import { AddOperator } from './operators/add.operator';\n    import { TYPES } from './types';\n    export const container = new Container();\n    container.bind<Operator>(TYPES.AddOperator).to(AddOperator);\n    container.bind(Calculator).toSelf();\n    ```", "```js\n    import 'reflect-metadata';\n    import { Calculator } from './calculator/index';\n    import { container } from './ioc.config';\n    const calculator = container.get(Calculator);\n    try {\n        const result = calculator.evaluate('13+5');\n        console.log('result is', result);\n    } catch (err) {\n        console.error(err);\n    }\n    ```", "```js\n    result is 18\n    ```", "```js\n    // operators/subtract.operator.ts\n    import { injectable } from 'inversify';\n    import { Operator } from '../interfaces/operator.interface';\n    @injectable()\n    export class SubtractOperator implements Operator {\n        readonly symbol = '-';\n        public evaluate(a: number, b: number) {\n            return a - b;\n        }\n    }\n    ```", "```js\n    // operators/multiply.operator.ts\n    import { injectable } from 'inversify';\n    import { Operator } from '../interfaces/operator.interface';\n    @injectable()\n    export class MultiplyOperator implements Operator {\n        readonly symbol = '*';\n        public evaluate(a: number, b: number) {\n            return a * b;\n        }\n    }\n    ```", "```js\n    // operators/divide.operator.ts\n    import { injectable } from 'inversify';\n    import { Operator } from '../interfaces/operator.interface';\n    @injectable()\n    export class DivideOperator implements Operator {\n        readonly symbol = '/';\n        public evaluate(a: number, b: number) {\n            return a / b;\n        }\n    }\n    ```", "```js\n    export const TYPES = {\n        Operator: Symbol.for('Operator'),\n    };\n    ```", "```js\n    import { injectable, tryParseNumberString and tryParseOperatorSymbol. Both these functions are created in the math.ts file placed in the src/utils folder.\n    ```", "```js\n    import { Container } from 'inversify';\n    import { Calculator } from './calculator';\n    import { Operator } from './interfaces/operator.interface';\n    import { AddOperator } from './operators/add.operator';\n    import { DivideOperator } from './operators/divide.operator';\n    import { MultiplyOperator } from './operators/multiply.operator';\n    import { SubtractOperator } from './operators/subtract.operator';\n    import { TYPES } from './types';\n    export const container = new Container();\n    container.bind<Operator>(TYPES.Operator).to(AddOperator);\n    container.bind<Operator>(TYPES.Operator).to(SubtractOperator);\n    container.bind<Operator>(TYPES.Operator).to(MultiplyOperator);\n    container.bind<Operator>(TYPES.Operator).to(DivideOperator);\n    container.bind(Calculator).toSelf();\n    ```", "```js\n    evaluate(expression: string) {\n        // ...\n        const { result } = parsedExpressionParts.reduce<{ result: number; queuedOperator: Operator | null }>((acc, part) => {\n            if (typeof part === 'number') {\n                // this is the first number we've encountered, just set the result to that.\n                if (acc.queuedOperator === null) {\n                    return { ...acc, result: part };\n                }\n                // there's a queued operator – evaluate the previous result with this and\n                // clear the queued one.\n                return {\n                    queuedOperator: null,\n                    result: acc.queuedOperator.evaluate(acc.result, part),\n                  };\n            }\n            // this is an operator – queue it for later execution\n            return {\n                ...acc,\n                queuedOperator: part,\n            };\n        }, { result: 0, queuedOperator: null });\n        return result;\n    }\n    ```", "```js\n    // operators/index.ts\n    export * from './add.operator';\n    export * from './divide.operator';\n    export * from './multiply.operator';\n    export * from './subtract.operator';\n    ```", "```js\n    // ioc.config.ts\n    import { Container } from 'inversify';\n    import { Calculator } from './calculator';\n    import { Operator } from './interfaces/operator.interface';\n    import * as Operators from './operators';\n    import { TYPES } from './types';\n    export const container = new Container();\n    Object.values(Operators).forEach(Operator => {\n        container.bind<Operator>(TYPES.Operator).to(Operator);\n    });\n    container.bind(Calculator).toSelf();\n    ```", "```js\n    import 'reflect-metadata';\n    import { Calculator } from './calculator';\n    import { container } from './ioc.config';\n    const calculator = container.get(Calculator);\n    try {\n        const result = calculator.evaluate('13*10+20');\n        console.log('result is', result);\n    } catch (err) {\n        console.error(err);\n    }\n    ```", "```js\n    result is 150\n    ```", "```js\n    export interface Logger {\n        log(message: string, ...args: any[]): void;\n        warn(message: string, ...args: any[]): void;\n        error(message: string, ...args: any[]): void;\n    }\n    ```", "```js\n    import { injectable } from 'inversify';\n    import { Logger } from '../interfaces/logger.interface';\n    @injectable()\n    export class ConsoleLogger implements Logger {\n        log(message: string, ...args: any[]) {\n            console.log('[LOG]', message, ...args);\n        }\n        warn(message: string, ...args: any[]) {\n            console.warn('[WARN]', message, ...args);\n        }\n        error(message: string, ...args: any[]) {\n            console.error('[ERROR]', message, ...args);\n        }\n    }\n    ```", "```js\n    // types/index.ts\n    export const TYPES = {\n        Operator: Symbol.for('Operator'),\n        Logger: Symbol.for('Logger'),\n    };\n    ```", "```js\n    // ioc.config.ts\n    import { Container } from 'inversify';\n    import { Calculator } from './calculator';\n    import { Logger } from './interfaces/logger.interface';\n    import { Operator } from './interfaces/operator.interface';\n    import { ConsoleLogger } from './logger/console.logger';\n    import * as Operators from './operators';\n    import { TYPES } from './types';\n    export const container = new Container();\n    Object.values(Operators).forEach(Operator => {\n        container.bind<Operator>(TYPES.Operator).to(Operator);\n    });\n    container.bind(Calculator).toSelf();\n    container.bind<Logger>(TYPES.Logger).to(ConsoleLogger);\n    ```", "```js\n    import { injectable, multiInject, inject, optional } from 'inversify';\n    import { Operator } from '../interfaces/operator.interface';\n    import { TYPES } from '../types';\n    import { tryParseNumberString, tryParseOperatorSymbol } from '../utils/math';\n    import { Logger } from '../interfaces/logger.interface';\n    @injectable()\n    export class Calculator {\n        constructor(\n            @multiInject(TYPES.Operator) private operators: Operator[],\n            @inject(TYPES.Logger) @optional() private logger?: Logger\n        ) {}\n        evaluate(expression: string) {\n            // ...\n            const { result } = parsedExpressionParts.reduce<{ result: number; queuedOperator: Operator | null }>( ... );\n            this.logger && this.logger.log(`Calculated result of expression: ${expression} to be: ${result}`);\n            return result;\n        }\n    }\n    ```", "```js\n    [LOG] Calculated result of expression:13*10+20 is 150\n    ```", "```js\n    import fs from 'fs';\n    import { injectable } from 'inversify';\n    import { Logger } from '../interfaces/logger.interface';\n    @injectable()\n    export class FileLogger implements Logger {\n        private readonly loggerPath: string = '/tmp/calculator.log';\n        log(message: string, ...args: any[]) {\n            this.logInternal('LOG', message, args);\n        }\n        warn(message: string, ...args: any[]) {\n            this.logInternal('WARN', message, args);\n        }\n        error(message: string, ...args: any[]) {\n            this.logInternal('ERROR', message, args);\n        }\n        private logInternal(level: string, message: string, ...args: any[]) {\n            fs.appendFileSync(this.loggerPath, this.logLineFormatter(level, message, args));\n        }\n        private logLineFormatter(level: string, message: string, ...args: any[]) {\n            return `[${level}]: ${message}${args}\\n`;\n        }\n    }\n    ```", "```js\n    container.bind<Logger>(TYPES.Logger).to(ConsoleLogger);\n    ```", "```js\n    container.bind<Logger>(TYPES.Logger).to(FileLogger);\n    ```", "```js\n    type PartialPrimitive = string | number | boolean | symbol | bigint | Function | Date;\n    ```", "```js\n    type DeepPartial<T> = T extends PartialPrimitive ? T : Partial<T>;\n    ```", "```js\n    type DeepPartial<T> =\n         T extends PartialPrimitive\n         ? T\n         : T extends Array<infer U>\n         ? Array<DeepPartial<U>>\n         : Partial<T>;\n    ```", "```js\n    interface DeepPartialArray<T> extends Array<DeepPartial<T>> {}\n    type DeepPartial<T> =\n         T extends PartialPrimitive\n         ? T\n         : T extends Array<infer U>\n         ? DeepPartialArray<U>\n         : Partial<T>;\n    ```", "```js\n    interface DeepPartialArray<T> extends Array<DeepPartial<T>> {}\n    interface DeepPartialSet<T> extends Set<DeepPartial<T>> {}\n    type DeepPartial<T> = T extends PartialPrimitive\n        ? T\n        : T extends Array<infer U>\n        ? DeepPartialArray<U>\n        : T extends Set<infer U>\n        ? DeepPartialSet<U>\n        : Partial<T>;\n    ```", "```js\n    interface DeepPartialArray<T> extends Array<DeepPartial<T>> {}\n    interface DeepPartialSet<T> extends Set<DeepPartial<T>> {}\n    interface DeepPartialMap<K, V> extends Map<DeepPartial<K>, DeepPartial<V>> {}\n    type DeepPartial<T> = T extends PartialPrimitive\n        ? T\n        : T extends Array<infer U>\n        ? DeepPartialArray<U>\n        : T extends Map<infer K, infer V>\n        ? DeepPartialMap<K, V>\n        : T extends Set<infer U>\n        ? DeepPartialSet<U>\n        : Partial<T>;\n    ```", "```js\n    type DeepPartial<T> = T extends PartialPrimitive\n        ? T\n        : T extends Array<infer U>\n        ? DeepPartialArray<U>\n        : T extends Map<infer K, infer V>\n        ? DeepPartialMap<K, V>\n        : T extends Set<infer U>\n        ? DeepPartialSet<U>\n        : T extends {}\n        ? { [K in keyof T]?: DeepPartial<T[K]> }\n        : Partial<T>;\n    ```", "```js\n    import express from 'express';\n    const app = express();\n    app.patch('/users/:userId', async (req, res) => {\n        const userId = req.params.userId;\n        const userUpdateData: DeepPartial<User> = req.body;\n        const user = await User.getById(userId);\n        await user.update(userUpdateData);\n        await user.save();\n        res.status(200).end(user);\n    });\n    ```", "```js\n        const xhr = new XMLHttpRequest();\n    ```", "```js\n        const url = getSearchUrl(value);\n    ```", "```js\n        xhr.open('GET', url);    xhr.send();\n    ```", "```js\n        xhr.onload = function() {        const data = JSON.parse(this.response) as SearchResultApi;    }\n    ```", "```js\n        if (data.results.length === 0) {        clearResults(value);    } \n    ```", "```js\n        else {        const resultMovie = data.results[0];    }\n    ```", "```js\n        const movieXhr = new XMLHttpRequest();\n    ```", "```js\n        const movieUrl = getMovieUrl(resultMovie.id);\n    ```", "```js\n        movieXhr.open('GET', movieUrl);    movieXhr.send();\n    ```", "```js\n        movieXhr.onload = function () {        const movieData: MovieResultApi = JSON.parse(this.response);\n    ```", "```js\n        const peopleXhr = new XMLHttpRequest();\n    ```", "```js\n        const peopleUrl = getPeopleUrl(resultMovie.id);\n    ```", "```js\n        peopleXhr.open('GET', peopleUrl);    peopleXhr.send();\n    ```", "```js\n        const data = JSON.parse(this.response) as PeopleResultApi;\n    ```", "```js\n        data.cast.sort((f, s) => f.order - s.order);    const mainActors = data.cast.slice(0, 6);\n    ```", "```js\n        const characters: Character[] = mainActors.map(actor => ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))\n    ```", "```js\n        const directors = data.crew         .filter(person => person.department === \"Directing\" && person.job === \"Director\")        .map(person => person.name)    const directedBy = directors.join(\" & \");\n    ```", "```js\n        const writers = data.crew         .filter(person => person.department === \"Writing\" && person.job === \"Writer\")        .map(person => person.name);    const writtenBy = writers.join(\" & \");\n    ```", "```js\n        const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,\n            characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }\n    ```", "```js\n        showResults(movie);\n    ```", "```js\n    const getJsonData = (url: string):Promise<any> => {}\n    ```", "```js\n    const getJsonData = (url: string):Promise<any> => {    return fetch(url)        .then(response => response.json());}\n    ```", "```js\n        const searchUrl = getSearchUrl(value);\n    ```", "```js\n        return getJsonData(searchUrl)\n    ```", "```js\n        return getJsonData(url)        .then((data:SearchResultApi) => {        }\n    ```", "```js\n        .then((data:SearchResultApi) => {        if (data.results.length === 0) {            throw Error(\"Not found\");        }        return data.results[0];    })\n    ```", "```js\n        })    .then(movieResult => {        const movieUrl = getMovieUrl(movieResult.id);        const peopleUrl = getPeopleUrl(movieResult.id);    })\n    ```", "```js\n        const movieUrl = getMovieUrl(movieResult.id);    const peopleUrl = getPeopleUrl(movieResult.id);    const dataPromise: Promise<MovieResultApi> = getJsonData(movieUrl);    const peoplePromise: Promise<PeopleResultApi> = getJsonData(peopleUrl);\n    ```", "```js\n        const resultPromise = Promise.all([dataPromise, peoplePromise]);\n    ```", "```js\n            return resultPromise;    })\n    ```", "```js\n        })    .then(dataResult => {    });\n    ```", "```js\n        const [movieData, peopleData] = dataResult // we can actually let TypeScripts type inference pick out the types\n    ```", "```js\n        peopleData.cast.sort((f, s) => f.order - s.order);    const mainActors = peopleData.cast.slice(0, 6);\n    ```", "```js\n        const characters :Character[] = mainActors.map(actor => ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))\n    ```", "```js\n        const directors = peopleData.crew         .filter(person => person.department === \"Directing\" && person.job === \"Director\")        .map(person => person.name)    const directedBy = directors.join(\" & \");\n    ```", "```js\n        const writers = peopleData.crew         .filter(person => person.department === \"Writing\" && person.job === \"Writer\")        .map(person => person.name);    const writtenBy = writers.join(\" & \");\n    ```", "```js\n        const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }\n    ```", "```js\n            return movie;    });\n    ```", "```js\n        search(movieTitle)        .then(movie => showResults(movie))        .catch(_ => clearResults(value));\n    ```", "```js\n    const getJsonData = (url: string):Promise<any> => {}\n    ```", "```js\n    const getJsonData = (url: string):Promise<any> => {    const response = await fetch(url);    return response.json();}\n    ```", "```js\n        const url = getSearchUrl(value);\n    ```", "```js\n        const data: SearchResultApi = await getJsonData(url);\n    ```", "```js\n        if (data.results.length === 0) {        throw Error(\"Not found\");    }    const movieResult = data.results[0];\n    ```", "```js\n        const movieUrl = getMovieUrl(movieResult.id);    const peopleUrl = getPeopleUrl(movieResult.id);\n    ```", "```js\n        const dataPromise: Promise<MovieResultApi> = getJsonData(movieUrl);    const peoplePromise: Promise<PeopleResultApi> = getJsonData(peopleUrl);\n    ```", "```js\n        const dataArray = await Promise.all([dataPromise, peoplePromise]);\n    ```", "```js\n         const [movieData, peopleData] = dataArray;\n    ```", "```js\n        peopleData.cast.sort((f, s) => f.order - s.order);    const mainActors = peopleData.cast.slice(0, 6);\n    ```", "```js\n        const characters :Character[] = mainActors.map(actor => ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))\n    ```", "```js\n        const directors = peopleData.crew         .filter(person => person.department === \"Directing\" && person.job === \"Director\")        .map(person => person.name)    const directedBy = directors.join(\" & \");\n    ```", "```js\n        const writers = peopleData.crew         .filter(person => person.department === \"Writing\" && person.job === \"Writer\")        .map(person => person.name);    const writtenBy = writers.join(\" & \");\n    ```", "```js\n        const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }\n    ```", "```js\n        return movie; \n    ```", "```js\n        try {        const movie = await search(movieTitle);        showResults(movie);    } catch {        clearResults(movieTitle);    }\n    ```", "```js\n    type UnaryFunction<T, R> = T extends void ? () => R : (arg: T) => R;\n    ```", "```js\n    function pipe<R>(fn: UnaryFunction<void, R>): UnaryFunction<void, R>;\n    function pipe<T, R = T>(fn: UnaryFunction<T, R>): UnaryFunction<T, R> {\n        return fn;\n    }\n    ```", "```js\n    function pipe<R>(fn: UnaryFunction<void, R>): UnaryFunction<void, R>;\n    function pipe<T, R = T>(fn: UnaryFunction<T, R>): UnaryFunction<T, R>;\n    function pipe<T, A, R>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, R>): UnaryFunction<T, R>;\n    function pipe<T, A, R>(fn1: UnaryFunction<T, A>, fn2?: UnaryFunction<A, R>) {\n      // TODO: Support two functions\n    }\n    ```", "```js\n    function pipe<R>(fn: UnaryFunction<void, R>): UnaryFunction<void, R>;\n    function pipe<T, R = T>(fn: UnaryFunction<T, R>): UnaryFunction<T, R>;\n    function pipe<T, A, R>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, R>): UnaryFunction<T, R>;\n    function pipe<T, A, R>(fn1: UnaryFunction<T, A>, fn2?: UnaryFunction<A, R>) {\n      if (fn2 === undefined) {\n        return fn1;\n      }\n      return (arg: T) => {\n        return fn2(fn1(arg));\n      };\n    }\n    ```", "```js\n    function pipe<R>(fn: UnaryFunction<void, R>): UnaryFunction<void, R>;\n    function pipe<T, R = T>(fn: UnaryFunction<T, R>): UnaryFunction<T, R>;\n    function pipe<T, A, R>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, R>): UnaryFunction<T, R>;\n    function pipe<T>(...fns: UnaryFunction<any, any>[]): UnaryFunction<any, any> {\n      return (arg: T) => {\n        return fns.reduce((prev, fn) => fn(prev), arg);\n      };\n    }\n    ```", "```js\n    function pipe<T, A, B, R>(\n      fn1: UnaryFunction<T, A>,\n      fn2: UnaryFunction<A, B>,\n      fn3: UnaryFunction<B, R>,\n    ): UnaryFunction<T, R>;\n    ```", "```js\n    function pipe<T, A, B, C, R>(\n      fn1: UnaryFunction<T, A>,\n      fn2: UnaryFunction<A, B>,\n      fn3: UnaryFunction<B, C>,\n      fn4: UnaryFunction<C, R>,\n    ): UnaryFunction<T, R>;\n    ```", "```js\n    function pipe<T, A, B, C, D, R>(\n      fn1: UnaryFunction<T, A>,\n      fn2: UnaryFunction<A, B>,\n      fn3: UnaryFunction<B, C>,\n      fn4: UnaryFunction<C, D>,\n      fn5: UnaryFunction<D, R>,\n    ): UnaryFunction<T, R>;\n    ```", "```js\n    const composedFn = pipe(\n      (x: string) => x.toUpperCase(),\n      x => [x, x].join(','),\n      x => x.length,\n      x => x.toString(),\n      x => Number(x),\n    );\n    console.log('result is:', composedFn('hello'))\n    ```", "```js\n    result is: 11\n    ```", "```js\n    npm i\n    ```", "```js\n    <html>\n      <head>\n        <title>The TypeScript Workshop - Activity 12.1</title>\n        <link href=\"styles.css\" rel=\"stylesheet\"></link>\n      </head>\n      <body>\n        <input type=\"text\" placeholder=\"What promise will you make?\" id=\"promise-input\"> <button id=\"promise-save\">save</button>\n        <div>\n            <table id=\"promise-table\"></ul>\n        </div>\n      </body>\n      <script type=\"module\" src=\"img/app.js\"></script>\n    </html>\n    ```", "```js\n    body {\n      font-family: Arial, Helvetica, sans-serif;\n      font-size: 12px;\n    }\n    input {\n      width: 200;\n    }\n    table {\n      border: 1px solid;\n    }\n    td {\n      overflow: hidden;\n      white-space: nowrap;\n      text-overflow: ellipsis;\n    }\n    ```", "```js\n    interface PromiseModel {\n      id?: number;\n      desc: string;\n    }\n    const fetchClient = (url: string) => (resource: string) => (method: string) => (\n      body?: PromiseModel\n    ) => {\n      return fetch(`${url}/${resource}`, {\n        body: body && JSON.stringify(body),\n        headers: { \"Content-Type\": \"application/json\" },\n        method,\n      });\n    };\n    ```", "```js\n    const api = fetchClient(\"http://localhost:3000\");\n    const resource = api(\"promise\");\n    const getAction = resource(\"get\");\n    const postAction = resource(\"post\");\n    ```", "```js\n    const deleteItem = (id: number) => {\n      const resource = api(`promise/${id}`);\n      resource(\"delete\")().then(loadItems);\n    };\n    const loadItems = () => {\n      getAction().then((res) => res.json().then(renderList));\n    };\n    const saveItem = () => {\n      const input = document.getElementById(\"promise-input\") as HTMLInputElement;\n      if (input.value) {\n        postAction({ desc: input.value }).then(loadItems);\n        input.value = \"\";\n      }\n    };\n    ```", "```js\n    const renderList = (data: PromiseModel[]) => {\n      const table = document.getElementById(\"promise-table\");\n      if (table) {\n        table.innerHTML = \"\";\n        let tr = document.createElement(\"tr\");\n        [\"Promise\", \"Delete\"].forEach((label) => {\n          const th = document.createElement(\"th\");\n          th.innerText = label;\n          tr.appendChild(th);\n        });\n        table.appendChild(tr);\n        data.forEach((el) => {\n          table.appendChild(renderRow(el));\n        });\n      }\n    };\n    const renderRow = (el: PromiseModel) => {\n      const tr = document.createElement(\"tr\");\n      const td1 = document.createElement(\"td\");\n      td1.innerHTML = el.desc;\n      tr.appendChild(td1);\n      const td2 = document.createElement(\"td\");\n      const deleteButton = document.createElement(\"button\");\n      deleteButton.innerText = \"delete\";\n      deleteButton.onclick = () => deleteItem(el.id!);\n      td2.appendChild(deleteButton);\n      tr.appendChild(td2);\n      return tr;\n    };\n    document.getElementById(\"promise-save\")?.addEventListener(\"click\", saveItem);\n    loadItems();\n    ```", "```js\n    interface PromiseModel {\n      id?: number;\n      desc: string;\n    }\n    const fetchClient = (url: string) => (resource: string) => (method: string) => (\n      body?: PromiseModel\n    ) => {\n      return fetch(`${url}/${resource}`, {\n        body: body && JSON.stringify(body),\n        headers: { \"Content-Type\": \"application/json\" },\n        method,\n      });\n    };\n    const api = fetchClient(\"http://localhost:3000\");\n    const resource = api(\"promise\");\n    const getAction = resource(\"get\");\n    const postAction = resource(\"post\");\n    const deleteItem = (id: number) => {\n      const resource = api(`promise/${id}`);\n      resource(\"delete\")().then(loadItems);\n    };\n    const loadItems = () => {\n      getAction().then((res) => res.json().then(renderList));\n    };\n    const saveItem = () => {\n      const input = document.getElementById(\"promise-input\") as HTMLInputElement;\n      if (input.value) {\n        postAction({ desc: input.value }).then(loadItems);\n        input.value = \"\";\n      }\n    };\n    const renderList = (data: PromiseModel[]) => {\n      const table = document.getElementById(\"promise-table\");\n      if (table) {\n        table.innerHTML = \"\";\n        let tr = document.createElement(\"tr\");\n        [\"Promise\", \"Delete\"].forEach((label) => {\n          const th = document.createElement(\"th\");\n          th.innerText = label;\n          tr.appendChild(th);\n        });\n        table.appendChild(tr);\n        data.forEach((el) => {\n          table.appendChild(renderRow(el));\n        });\n      }\n    };\n    const renderRow = (el: PromiseModel) => {\n      const tr = document.createElement(\"tr\");\n      const td1 = document.createElement(\"td\");\n      td1.innerHTML = el.desc;\n      tr.appendChild(td1);\n      const td2 = document.createElement(\"td\");\n      const deleteButton = document.createElement(\"button\");\n      deleteButton.innerText = \"delete\";\n      deleteButton.onclick = () => deleteItem(el.id!);\n      td2.appendChild(deleteButton);\n      tr.appendChild(td2);\n      return tr;\n    };\n    document.getElementById(\"promise-save\")?.addEventListener(\"click\", saveItem);\n    loadItems();\n    ```", "```js\n    npx tsc -w. \n    ```", "```js\n    const renderAll = async () => {\n    ```", "```js\n    export class El {\n      constructor(private name: string) {}\n      render = () => {\n        return new Promise((resolve) =>\n          setTimeout(\n            () => resolve(`${this.name} is resolved`),\n            Math.random() * 1000\n          )\n        );\n      };\n    }\n    const e1 = new El('header');\n    const e2 = new El('body');\n    const e3 = new El('footer');\n    const renderAll = async () => {\n      console.log(await e1.render());\n      console.log(await e2.render());\n      console.log(await e3.render());\n    };\n    renderAll();\n    ```", "```js\n    header is resolved\n    body is resolved\n    footer is resolved\n    ```", "```js\n    import firebase from 'firebase';const config = {  apiKey: 'abc123',  authDomain: 'blog-xxx.firebaseapp.com',  projectId: 'https://blog-xxx.firebaseio.com',  storageBucket: 'blog-xxx.appspot.com',  messagingSenderId: '999',  appId: '1:123:web:123abc',};firebase.initializeApp(config);export const auth = firebase.auth();export const db = firebase.firestore();\n    ```", "```js\n    import firebase from 'firebase';\n    import React, { createContext, ReactNode, useEffect, useState } from 'react';\n    import { auth } from '../services/firebase';\n    interface ContextProps {\n      children: ReactNode;\n    }\n    export const UserContext = createContext<Partial<firebase.User | undefined>>(\n      {}\n    );\n    export const UserProvider = (props: ContextProps) => {\n      const [user, setUser] = useState<firebase.User>();\n      useEffect(() => {\n        auth.onAuthStateChanged((userAuth) => {\n          setUser(userAuth ?? undefined);\n        });\n      });\n      return (\n        <UserContext.Provider value={user}>{props.children}</UserContext.Provider>\n      );\n    };\n    ```", "```js\n    export interface CommentModel {  comment: string;  timestamp: number;  user: string;}export interface StoryModel {  comments: CommentModel[];  id: string;  link: string;  title: string;  user: string;}\n    ```", "```js\n    const storiesDB = db.collection('stories');\n    ```"]