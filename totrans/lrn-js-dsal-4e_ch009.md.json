["```js\nclass Dictionary {\n  #items = {};\n  #size = 0;\n}\n```", "```js\n#elementToString(data) {\n  if (typeof data === 'object' && data !== null) {\n    return JSON.stringify(data);\n  } else {\n    return data.toString();\n  }\n}\n```", "```js\nhasKey(key) {\n  return this.#items[this.#elementToString(key)] != null;\n}\n```", "```js\nset(key, value) {\n  if (key != null && value != null) {\n    const tableKey = this.#elementToString(key);\n    this.#items[tableKey] = value;\n    this.#size++;\n    return true;\n  }\n  return false;\n}\n```", "```js\ndelete(value) {\n  if (this.has(value)) {\n    delete this.#items[value];\n    this.#size--;\n    return true;\n  }\n  return false;\n}\n```", "```js\nclear() {\n  this.#items = {};\n  this.#size = 0;\n}\n```", "```js\n get size() {\n    return this.#size;\n  }\n```", "```js\nisEmpty() {\n  return this.#size === 0;\n}\n```", "```js\n get(key) {\n  return this.#items[this.#elementToString(key)];\n}\n```", "```js\nvalues() {\n  return Object.values(this.#items);\n}\n```", "```js\nkeys() {\n  return Object.keys(this.#items);\n}\n```", "```js\nforEach(callbackFn) {\n  for (const key in this.#items) {\n    if (this.#items.hasOwnProperty(key)) {\n      callbackFn(this.#items[key], key);\n    }\n  }\n}\n```", "```js\nconst translations = new Dictionary();\n// Add some translations - English to Portuguese\ntranslations.set(\"hello\", \"olá\");\ntranslations.set(\"thank you\", \"obrigado\");\ntranslations.set(\"book\", \"livro\"); \ntranslations.set(\"cat\", \"gato\");\ntranslations.set(\"computer\", \"computador\");\n```", "```js\nfunction translateWord(word) {\n  if (translations.hasKey(word)) {\n    const translation = translations.get(word);\n    console.log(`The translation of \"${word}\" is \"${translation}\"`);\n  } else {\n    console.log(`Sorry, no translation found for \"${word}\"`);\n  }\n}\n```", "```js\ntranslateWord(\"hello\"); // Output: The translation of \"hello\" is \"olá\"\ntranslateWord(\"dog\");  // Output: Sorry, no translation found for \"dog\"\n```", "```js\nconsole.log(\"All translations:\", translations.values());\n// All translations: [ 'olá', 'obrigado', 'livro', 'gato', 'computador' ]\n```", "```js\nconsole.log(\"All words:\", translations.keys());\n// All words: [ 'hello', 'thank you', 'book', 'cat', 'computer' ]\n```", "```js\ntranslations.forEach((value, key) => {\n  console.log(`${key}: ${value}`);\n});\n```", "```js\nhello: olá\nthank you: obrigado\nbook: livro\ncat: gato\ncomputer: computador\n```", "```js\nconst translations = new Map();\ntranslations.set(\"hello\", \"olá\");\ntranslations.set(\"thank you\", \"obrigado\");\ntranslations.set(\"book\", \"livro\"); \ntranslations.set(\"cat\", \"gato\");\ntranslations.set(\"computer\", \"computador\");\n```", "```js\nconst privateData = new WeakMap();\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    privateData.set(this, { ssn: 'XXX-XX-XXXX', medicalHistory: [] });\n  }\n  getSSN() {\n    return privateData.get(this)?.ssn;\n  }\n}\n```", "```js\nclass HashTable {\n  #table = [];\n}\n```", "```js\nhash(key) {\n  return this.#loseLoseHashCode(key);\n}\n```", "```js\n#loseLoseHashCode(key) {\n  if (typeof key !== 'string') {\n    key = this.#elementToString(key);\n  }\n  const calcASCIIValue = (acc, char) => acc + char.charCodeAt(0);\n  const hash = key.split('').reduce((acc, char) => calcASCIIValue, 0);\n  return hash % 37; // mod to reduce the hash code\n}\n```", "```js\nput(key, value) {\n  if (key == null && value == null)  {\n    return false;\n  }\n  const index = this.hash(key);\n  this.#table[index] = value;\n  return true;\n}\n```", "```js\nget(key) {\n  if (key == null) {\n    return undefined;\n  }\n  const index = this.hash(key);\n  return this.#table[index];\n}\n```", "```js\nremove(key) {\n  if (key == null) {\n    return false;\n  }\n  const index = this.hash(key);\n  if (this.#table[index]) {\n    delete this.#table[index];\n    return true;\n  }\n  return false;\n}\n```", "```js\nconst addressBook = new HashTable();\n// Add contacts\naddressBook.put('Gandalf', 'gandalf@email.com');\naddressBook.put('John', 'johnsnow@email.com');\naddressBook.put('Tyrion', 'tyrion@email.com');\n```", "```js\nconsole.log(addressBook.hash('Gandalf')); // 19\nconsole.log(addressBook.hash('John')); // 29\nconsole.log(addressBook.hash('Tyrion')); // 16\n```", "```js\nconsole.log(addressBook.get('Gandalf')); // gandalf@email.com\nconsole.log(addressBook.get('Loiane')); // undefined\n```", "```js\nconsole.log(addressBook.remove('Gandalf')); // true\nconsole.log(addressBook.get('Gandalf')); // undefined\n```", "```js\nconst addressBook = new HashTable();\naddressBook.put('Ygritte', 'ygritte@email.com');\naddressBook.put('Jonathan', 'jonathan@email.com');\naddressBook.put('Jamie', 'jamie@email.com');\naddressBook.put('Jack', 'jack@email.com');\naddressBook.put('Jasmine', 'jasmine@email.com');\naddressBook.put('Jake', 'jake@email.com');\naddressBook.put('Nathan', 'nathan@email.com');\naddressBook.put('Athelstan', 'athelstan@email.com');\naddressBook.put('Sue', 'sue@email.com');\naddressBook.put('Aethelwulf', 'aethelwulf@email.com');\naddressBook.put('Sargeras', 'sargeras@email.com');\n```", "```js\n4 - Ygritte\n5 - Jonathan\n5 - Jamie\n7 - Jack\n8 - Jasmine\n9 - Jake\n10 - Nathan\n7 - Athelstan\n5 - Sue\n5 - Aethelwulf\n10 - Sargeras\n```", "```js\ntoString() {\n  const keys = Object.keys(this.#table);\n  let objString = `{${keys[0]} => ${this.#table[keys[0]].toString()}}`;\n  for (let i = 1; i < keys.length; i++) {\n    const value = this.#elementToString(this.#table[keys[i]]).toString();\n    objString = `${objString}\\n{${keys[i]} => ${value}}`;\n  }\n  return objString;\n}\n```", "```js\n{4 => ygritte@email.com}\n{5 => aethelwulf@email.com}\n{7 => athelstan@email.com}\n{8 => jasmine@email.com}\n{9 => jake@email.com}\n{10 => sargeras@email.com}\n```", "```js\nconst LinkedList = require('../06-linked-list/linked-list');\nclass HashTableSeparateChaining {\n  #table = [];\n} \n```", "```js\nput(key, value) {\n  if (key != null && value != null) {\n    const index = this.hash(key);\n    if (this.#table[index] == null) {\n      this.#table[index] = new LinkedList();\n    }\n    this.#table[index].append({key, value});\n    return true;\n  }\n  return false;\n}\n```", "```js\nget(key) {\n  const index = this.hash(key);\n  const linkedList = this.#table[index];\n  if (linkedList != null) {\n    linkedList.forEach((element) => {\n      if (element.key === key) {\n        return element.value;\n      }\n    });\n  }\n  return undefined; // key not found\n}\n```", "```js\nforEach(callback) {\n  let current = this.#head;\n  let index = 0;\n  while (current) {\n    callback(current.data, index);\n    current = current.next;\n    index++;\n  }\n}\n```", "```js\nremove(key) {\n  const index = this.hash(key);\n  const linkedList = this.#table[index];\n  if (linkedList != null) {\n    const compareFunction = (a, b) => a.key === b.key;\n    const toBeRemovedIndex = linkedList.indexOf({key}, compareFunction);\n    if (toBeRemovedIndex >= 0) {\n      linkedList.removeAt(toBeRemovedIndex);\n      if (linkedList.isEmpty()) {\n        this.#table[index] = undefined;\n      }\n      return true;\n    }\n  }\n  return false; // key not found\n}\n```", "```js\nclass HashTableLinearProbing {\n  #table = [];\n} \n```", "```js\nput(key, value) {\n  if (key != null && value != null) {\n    let index = this.hash(key);\n    // linear probing to find an empty slot\n    while (this.#table[index] != null) {\n      if (this.#table[index].key === key) {\n        this.#table[index].value = value;\n        return true;\n      }\n      index++;\n      index %= this.#table.length;\n    }\n    this.#table[index] = {key, value};\n    return true;\n  }\n  return false;\n}\n```", "```js\nget(key) {\n  let index = this.hash(key);\n  while (this.#table[index] != null) {\n    if (this.#table[index].key === key) {\n      return this.#table[index].value;\n    }\n    index++;\n    index %= this.#table.length;\n  }\n  return undefined;\n}\n```", "```js\nremove(key) {\n  let index = this.hash(key);\n  while (this.#table[index] != null) {\n    if (this.#table[index].key === key) {\n      delete this.#table[index];\n      this.#verifyRemoveSideEffect(key, index);\n      return true;\n    }\n    index++;\n    index %= this.#table.length;\n  }\n  return false;\n}\n```", "```js\n#verifyRemoveSideEffect(key, removedPosition) {\n  const size = this.#table.length;\n  let index = removedPosition + 1;\n  while (this.#table[index] != null) {\n    const currentKey = this.#table[index].key;\n    const currentHash = this.hash(currentKey);\n    // check if the element should be repositioned\n    if (currentHash <= removedPosition) {\n      this.#table[removedPosition] = this.#table[index];\n      delete this.#table[index];\n      removedPosition = index;\n    }\n    index++;\n    index %= size;\n  }\n}\n```", "```js\n#djb2HashCode(key) {\n  if (typeof key !== 'string') {\n    key = this.#elementToString(key);\n  }\n  const calcASCIIValue = (acc, char) => (acc * 33) + char.charCodeAt(0);\n  const hash = key.split('').reduce((acc, char) => calcASCIIValue, 5381);\n  return hash % 1013;\n}\n```", "```js\nclass HashTable<V> {\n  private table: V[] = [];\n  private loseLoseHashCode(key: string): number { }\n  hash(key: string): number { }\n  put(key: string, value: V): boolean { }\n  get(key: string): V { }\n  remove(key: string): boolean { }\n}\n```", "```js\nprivaye loseLoseHashCode(key: string) {\n  const calcASCIIValue = (acc, char) => acc + char.charCodeAt(0);\n  const hash = key.split('').reduce(calcASCIIValue, 0);\n  return hash % 37;\n}\n```", "```js\nfunction intToRoman(num: number): string {\n  const romanMap = {\n    M:1000, CM:900, D:500, CD:400, C:100, XC:90,\n    L:50, XL:40, X:10, IX:9, V:5, IV:4, I:1\n  };\n  let result = '';\n  for(let romanNum in romanMap){\n    while (num >= romanMap[romanNum]) {\n      result += romanNum;\n      num -= romanMap[romanNum];\n    }\n  }\n  return result;\n}\n```"]