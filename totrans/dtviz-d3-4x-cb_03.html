<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Dealing with Data</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Binding an array as data</li><li class="listitem" style="list-style-type: disc">Binding object literals as data</li><li class="listitem" style="list-style-type: disc">Binding functions as data</li><li class="listitem" style="list-style-type: disc">Working with arrays</li><li class="listitem" style="list-style-type: disc">Filtering with data</li><li class="listitem" style="list-style-type: disc">Sorting with data</li><li class="listitem" style="list-style-type: disc">Loading data from a server</li><li class="listitem" style="list-style-type: disc">Asynchronous data loading using queue</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Introduction</h1></div></div></div><p>In this chapter, we will explore the most essential question in any data visualization project: how data can be represented in both programming constructs, and its visual metaphor. Before we start on this topic, some discussion on data visualization is necessary. In order to understand what data visualization is, first we will need to understand the difference between data and information.</p><div><blockquote class="blockquote"><p>
<em>Data consists of raw facts. The word raw indicates that the facts have not yet been processed to reveal their meaning...Information is the result of processing raw data to reveal its meaning.</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>   -Rob P., S. Morris, and Coronel C. 2009</em>
</p></blockquote></div><p>This is how data and information are traditionally defined in the digital information world. However, data visualization provides a much richer interpretation of this definition since information is no longer the mere result of processed raw facts but rather a visual metaphor of the facts. As stated by <em>Manuel Lima</em>, in his <em>Information Visualization Manifesto</em>, design in the material world, where form is regarded to follow function.</p><p>The same dataset can generate any number of visualizations, which may lay equal claim in terms of validity. In a sense, visualization is more about communicating the creator's insight into data than anything else. On a more provocative note, Card, McKinlay, and Shneiderman suggested that the practice of information visualization can be described as follows:</p><div><blockquote class="blockquote"><p>
<em>The use of computer-supported, interactive, visual representations of abstract data to amplify cognition.</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em> -"Card S. and Mackinly J.", and Shneiderman B. 1999</em>
</p></blockquote></div><p>In the following sections, we will explore various techniques D3 provides to bridge the data with the visual domain. It is the very first step we need to take before we can create a <em>cognition amplifier</em> with our data.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>The enter-update-exit pattern</h2></div></div></div><p>The task of matching each datum with its visual representation, for example, drawing a single bar for every data point you have in your dataset, updating the bars when the data points change, and then eventually removing the bars when certain data points no longer exist, seems to be a complicated and tedious task. This is precisely why D3 was designed, to provide an ingenious way of simplifying the implementation of this task. This way of defining the connection between data and its visual representation is usually referred to as the <em>enter-update-exit</em> pattern in D3. This pattern is profoundly different from the typical <em>imperative method</em> most developers are familiar with. However, the understanding of this pattern is crucial to your effectiveness with the D3 library; and therefore, in this section, we will focus on explaining the concept behind this pattern. First, let's take a look at the following conceptual illustration of the two domains:</p><p>
</p><div><img src="img/image_03_001.jpg" alt="The enter-update-exit pattern"/></div><p>
</p><p>Data and visual set</p><p>In the preceding illustration, the two circles represent two joined sets. Set <strong>A</strong> depicts your dataset, whereas set <strong>B</strong> represents the visual elements. This is essentially how D3 sees the connection between your data and visual elements. You might be asking how set theory will help your data visualization effort here. Let me explain.</p><p>First, let us consider the question <em>how can I find all visual elements that currently represent their corresponding data point?</em> The answer is <em>A∩B</em>; this denotes the intersection of sets <strong>A</strong> and <strong>B</strong>, the elements that exist in both Data and Visual domains.</p><p>
</p><div><img src="img/image_03_002.jpg" alt="The enter-update-exit pattern"/></div><p>
</p><p>Update mode</p><p>In the preceding diagram, the shaded area represents the intersection between the two sets, <strong>A</strong> and <strong>B</strong>. In D3, the <code class="literal">selection.data</code> function can be used to select this intersection, <em>A</em>
<em>∩</em>
<em>B</em>.</p><p>The <code class="literal">selection.data(data)</code> function, upon selection, sets up the connection between the data domain and visual domain, as we discussed in the previous paragraph. The initial selection forms the visual set <strong>B</strong>, whereas the data provided in the <code class="literal">data</code> function form dataset <strong>A</strong>. The return result of this function is a new selection (a data-bound selection) of all elements existing in this intersection. Now, you can invoke the modifier function on this new selection to update all the existing elements. This mode of selection is usually referred to as the <strong>Update mode</strong>.</p><p>The second question we will need to answer here is <em>how can I target data points that have not yet been visualized?</em> The answer is the set difference of <strong>A</strong> and <strong>B</strong>, denoted as <em>A\B</em>, which can be seen visually through the following illustration:</p><p>
</p><div><img src="img/image_03_003.jpg" alt="The enter-update-exit pattern"/></div><p>
</p><p>Enter mode</p><p>The shaded area in set <strong>A</strong> represents the data points that have not yet been visualized. In order to gain access to this <em>A\B</em> subset, the following functions need to be performed on a data-bound D3 selection (a selection returned by the <code class="literal">data</code> function).</p><p>The <code class="literal">selection.data(data).enter()</code> function returns a new selection representing the <em>A\B</em> subset, which contains all the pieces of data that has not yet been represented in the visual domain. The regular modifier function can then be chained to this new selection method to create new visual elements that represent the given data elements. This mode of selection is simply referred to as the <strong>Enter mode</strong>.</p><p>The third case in our discussion covers the visual elements that exist in our dataset but no longer have any corresponding data element associated with them. You might ask how this kind of visual element can exist in the first place. This is usually caused by removing the elements from the dataset; that is, if you initially visualized all data points within your dataset, and removed some data points after that. Now, you have certain visual elements that are no longer representing any valid data point in your dataset. This subset can be discovered using an inverse of the Update difference, denoted as <em>B\A</em>.</p><p>
</p><div><img src="img/image_03_004.jpg" alt="The enter-update-exit pattern"/></div><p>
</p><p>Exit mode</p><p>The shaded area in the preceding illustration represents the difference we just discussed. The subset can be selected using the <code class="literal">selection.exit</code> function on a data-bound selection.</p><p>The <code class="literal">selection.data(data).exit</code> function, when invoked on a data-bound D3 <code class="literal">selectioncomputes</code> a new selection which contains all visual elements that are no longer associated with any valid data element. As a valid D3 selection object, the modifier function can then be chained to this selection to update and remove these visual elements that are no longer required as part of our visualization. This mode of selection is called the <strong>Exit mode</strong>.</p><p>Together, the three different selection modes cover all possible cases of interaction between the data and its visual domain.</p><p>Additionally, D3 also offers a fourth selection mode that is very handy when you need to avoid duplicating visualization code or the so-called <em>DRY</em> up your code. This fourth mode is called merge mode. It can be invoked using the <code class="literal">selection.merge</code> function. This function merges the given selection passed to the <code class="literal">merge</code> function with the selection where the function is invoked and returns a new selection that is a union of both. In the <em>enter-update-exit</em> pattern, the <code class="literal">merge</code> function is commonly used to construct a selection that covers both the Enter and Update modes since that's where most code duplication would otherwise live.</p><p>
</p><div><img src="img/image_03_005.jpg" alt="The enter-update-exit pattern"/></div><p>
</p><p>Merge mode</p><p>The shaded area in this illustration shows the data points targeted by merge mode that combines both Enter and Update modes, which is essentially the entire set A. This is very convenient since now a single chain of modifiers can be utilized to style both modes and thus lead to less code duplication. We will demonstrate how to leverage merge mode in each recipe of this chapter.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>In software engineering, <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) is a principle of software development, aimed at reducing repetition of information of all kinds (Wikipedia, August 2016). You can also read Mike Bostock's post on <em>What Makes Software Good?</em> for more insight on reasons behind this design change at <a class="ulink" href="https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp">https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp
</a>.</p></div></div><p>The <em>enter-update-exit</em> pattern is the cornerstone of any D3-driven visualization. In the following recipes of this chapter, we will cover the topics on how these selection methods can be utilized to generate data-driven visual elements efficiently and easily.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Binding an array as data</h1></div></div></div><p>One of the most common and popular ways to define data in D3 visualization is through the use of JavaScript arrays; for example, say you have multiple data elements stored in an array, and you want to generate corresponding visual elements to represent each and every one of them. Additionally, when the data array gets updated, you would want your visualization to reflect such changes immediately. In this recipe, we will accomplish this common approach.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>How to do it...</h2></div></div></div><p>The first and most natural solution that might come to mind is iterating through the data array elements and generating their corresponding visual elements on the page. This is definitely a valid solution, and it will work with D3; however, the enter-update-exit pattern we discussed in the introduction provides a much easier and more efficient way to generate visual elements. Let's take a look at how we can do that:</p><pre class="programlisting">var data = [10, 15, 30, 50, 80, 65, 55, 30, 20, 10, 8]; // &lt;- A 
    function render(data) { // &lt;- B 
        var bars = d3.select("body").selectAll("div.h-bar") // &lt;- C 
                .data(data); // Update &lt;- D 
        // Enter 
        bars.enter() // &lt;- E 
                .append("div") // &lt;- F 
                    .attr("class", "h-bar") // &lt;- G 
            .merge(bars) // Enter + Update &lt;- H 
                .style("width", function (d) { 
                    return (d * 3) + "px"; // &lt;- I 
                }) 
                .text(function (d) { 
                    return d; // &lt;- J 
                }); 
        // Exit 
        bars.exit() // &lt;- K 
                .remove(); 
    } 
    setInterval(function () { // &lt;- L 
        data.shift(); 
        data.push(Math.round(Math.random() * 100)); 
        render(data); 
    }, 1500); 
    render(data); 
</pre><p>This recipe generates the following visual output:</p><p>
</p><div><img src="img/image_03_006.jpg" alt="How to do it..."/></div><p>
</p><p>Data as array</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>How it works...</h2></div></div></div><p>In this example, data (a list of integers in this case) is stored in a simple JavaScript array as shown on the line <code class="literal">A</code> in the preceding code. The <code class="literal">render</code> function is defined on the line marked as <code class="literal">B</code> so that it can be repeatedly invoked to update our visualization. The selection starts on the line marked as <code class="literal">C</code>, which selects all <code class="literal">div</code> elements on the web page with the <code class="literal">h-bar</code> CSS class. You are probably wondering why we are selecting these <code class="literal">div</code> elements since they don't even exist on the web page yet. This is in fact true; however, the selection at this point is used to define the visual set we discussed in the introduction. By issuing this selection, that we made in the previous line, we essentially declare that there should be a set of the <code class="literal">div.h-bar</code> elements on the web page to form our visual set. On the line marked as <code class="literal">D</code>, we invoke the <code class="literal">data</code> function on this initial selection to bind the array as our dataset to the to-be-created visual elements. Once the two sets are defined, the <code class="literal">enter()</code> function on line <code class="literal">E</code> can be used to select all pieces of data elements that are not yet visualized. When the <code class="literal">render</code> function is invoked for the very first time, it returns all elements in the data array, as shown in the following code snippet:</p><pre class="programlisting">        var bars = d3.select("body") 
                       .selectAll("div.h-bar") // &lt;- C 
                       .data(data); // Update &lt;- D 
        // Enter 
        bars.enter() // &lt;- E 
            .append("div") // &lt;- F 
            .attr("class", "h-bar") // &lt;- G 
</pre><p>On line <code class="literal">F</code>, a new <code class="literal">div</code> element is created and appended to the <code class="literal">body</code> element of each data element selected in the <code class="literal">enter</code> function; this essentially creates one <code class="literal">div</code> element for each datum. Finally, on line <code class="literal">G</code>, we set its CSS class to <code class="literal">h-bar</code>. At this point, we basically created the skeleton of our visualization, including the empty <code class="literal">div</code> elements. Next step is to change the visual attributes of our elements based on the given data.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>D3 injects a property to the DOM element named <code class="literal">__data__</code> to make data sticky with visual elements so when selections are made using a modified dataset, D3 can compute the difference and intersection correctly. You can see this property easily if you inspect the DOM element either visually using a debugger or programmatically.
</p><div><img src="img/image_03_007.jpg" alt="How it works..."/></div><p>
As illustrated by the preceding screenshot, this is very useful to know when debugging.</p></div></div><p>In the following code snippet, on line <code class="literal">H</code>, the merge function is invoked with the selection as its parameter. This function call essentially merges the enter selection with the update selection and returns the union of both selections, thus allowing us to chain modifiers for both enter and update scenarios. Without the merge function, we would need to repeat the code here for both enter and update scenarios. Then, on line <code class="literal">I</code>, we applied a dynamic style attribute <code class="literal">width</code> to be three times the integer value associated with each visual element, as shown in the following code snippet:</p><pre class="programlisting">        bars.enter() // &lt;- E 
                .append("div") // &lt;- F 
                    .attr("class", "h-bar") // &lt;- G 
            .merge(bars) // Enter + Update &lt;- H 
                .style("width", function (d) { 
                    return (d * 3) + "px"; // &lt;- I 
                }) 
                .text(function (d) { 
                    return d; // &lt;- J 
                }); 
</pre><p>All D3 modifier functions accept this type of dynamic function to compute its value on the fly. This is precisely what it means to <em>data drive</em> your visualization. Hence, it is crucial to understand what this function is designed to achieve in our example. This function receives a parameter <code class="literal">d</code>, which is the datum associated with the current element. In our example, the first <code class="literal">div</code> bar has the value <code class="literal">10</code> associated as its datum, the second bar has <code class="literal">15</code>, and so on. Therefore, this function essentially computes a numeric value that is three times the datum for each bar and returns it as the element's <code class="literal">width</code> in pixels. While, on line <code class="literal">J</code>, we used a similar approach to change the text content of the <code class="literal">div</code> element to the datum value associated with each element.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>The dynamic modifier function actually accepts two parameters, <code class="literal">d</code> and <code class="literal">i</code>. The first parameter <code class="literal">d</code> is the associated datum we just discussed, and <code class="literal">i</code> is a zero-based index number for the current element. Some recipes in the previous chapter relied on this index, and in the rest of this chapter, we will take look at other recipes that utilize this index in different ways.</p></div></div><p>The following is the raw HTML code that resulted from this update process:</p><pre class="programlisting">&lt;div class="h-bar" style="width: 30px;"&gt; 
    10 
&lt;/div&gt; 
&lt;div class="h-bar" style="width: 45px;"&gt; 
    15 
&lt;/div&gt; 
.... 
&lt;div class="h-bar" style="width: 24px;"&gt; 
    8 
&lt;/div&gt; 
</pre><p>The following last section, <code class="literal">Exit</code> section, is fairly simple:</p><pre class="programlisting">bars.exit() // &lt;- K 
    .remove(); 
</pre><div><div><h3 class="title"><a id="note30"/>Note</h3><p>The selection returned by the <code class="literal">exit()</code> function is just like any other selection. Therefore, although <code class="literal">remove</code> is the most common action used against the <code class="literal">exit</code> selection, you can also apply other modifiers or transitions to this selection. We will explore some of these options in later chapters</p></div></div><p>On line <code class="literal">K</code> in the preceding code snippet, the <code class="literal">exit()</code> function is called to compute the set difference of all visual elements that are no longer associated with any data. Finally, the <code class="literal">remove()</code> function is called on this selection to remove all the elements selected by the <code class="literal">exit()</code> function. This way, as long as you call the <code class="literal">render()</code> function after you change our data, you can always ensure that our visual representation and data are kept synchronized.</p><p>Now, let's implement the following last block of code as follows:</p><pre class="programlisting">setInterval(function () { // &lt;- L 
        data.shift(); 
        data.push(Math.round(Math.random() * 100)); 
        render(data); 
    }, 1500); 
</pre><p>On line <code class="literal">L</code>, a simple anonymous function was created to remove the top element in the data array using the <code class="literal">shift</code> function while appending a random integer to the data array using the <code class="literal">push()</code> function every 1.5 seconds. Once the data array is updated, the <code class="literal">render()</code> function is called again to update our visualization to keep it synchronized with the new dataset. This is what gives our example its animated bar chart look.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Binding object literals as data</h1></div></div></div><p>With a more complex visualization, each element we have in a data array might not be a primitive integer value or a string, but a JavaScript object itself. In this recipe, we will discuss how this more complex data structure can be leveraged to drive your visualization using D3.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>How to do it...</h2></div></div></div><p>JavaScript object literal is probably the most common data structure you will encounter when you load data sources on the Web. In this recipe, we will take a look at how these JavaScript objects can be leveraged to generate rich visualization. The following code illustrates how to do it:</p><pre class="programlisting">var data = [ // &lt;- A 
        {width: 10, color: 23},{width: 15, color: 33}, 
        {width: 30, color: 40},{width: 50, color: 60}, 
        {width: 80, color: 22},{width: 65, color: 10}, 
        {width: 55, color: 5},{width: 30, color: 30}, 
        {width: 20, color: 60},{width: 10, color: 90}, 
        {width: 8, color: 10} 
    ]; 
     
    var colorScale = d3.scaleLinear() 
        .domain([0, 100]) 
        .range(["#add8e6", "blue"]); // &lt;- B 
    function render(data) { 
        var bars = d3.select("body").selectAll("div.h-bar") 
                .data(data); // Update 
        // Enter 
        bars.enter() 
                .append("div") 
                .attr("class", "h-bar") 
                .merge(bars) // Enter + Update 
                .style("width", function (d) { // &lt;- C 
                    return (d.width * 5) + "px"; // &lt;- D 
                }) 
                .style("background-color", function(d){ 
                    return colorScale(d.color); // &lt;- E 
                }) 
                .text(function (d) { 
                    return d.width; // &lt;- F 
                }); 
        // Exit 
        bars.exit().remove(); 
    } 
    function randomValue() { 
        return Math.round(Math.random() * 100); 
    } 
    setInterval(function () { 
        data.shift(); 
        data.push({width: randomValue(), color: randomValue()}); 
        render(data); 
    }, 1500); 
    render(data); 
</pre><p>This recipe generates  the following visu alization:</p><p>
</p><div><img src="img/image_03_008.jpg" alt="How to do it..."/></div><p>
</p><p>Data as object</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>This recipe is built on top of the previous recipe, so if you are not familiar with the fundamental enter-update-exit selection pattern, please take a look at the previous recipe first.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>How it works...</h2></div></div></div><p>In this recipe, instead of simple integers as shown in the previous recipe, now our data array is filled with objects (refer to the line marked as <code class="literal">A</code> with an arrow left to it). Each data object contains two attributes: <code class="literal">width</code> and <code class="literal">color</code>, that are both integers in this case:</p><pre class="programlisting">        {width: 10, color: 23}, 
        {width: 15, color: 33}, 
... 
        {width: 8, color: 10} 
    ]; 
 
</pre><div><div><h3 class="title"><a id="note32"/>Note</h3><p>On line <code class="literal">B</code>, we have a complicated-looking <code class="literal">color</code> scale defined:
<code class="literal">...</code>
<code class="literal">.range(["#add8e6", "blue"]); // &lt;- B</code>
<code class="literal">...</code>
Scales, including color scale, will be discussed in depth in the next chapter, so for now let us just assume this is a scale function we can use to produce CSS-compatible color code, given some integer input value. This is sufficient for the purpose of this recipe.</p></div></div><p>The major difference between this recipe and the previous one is the way the data is handled as shown on line <code class="literal">C</code> in the following code snippet:</p><pre class="programlisting">function (d) { // &lt;- C 
    return (d.width * 5) + "px"; // &lt;- D 
} 
</pre><p>As we can see in the preceding code snippet, in this recipe, the datum associated with each visual element is actually an object, not an integer. Therefore, we can access the <code class="literal">d.width</code> attribute on line <code class="literal">D</code>.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>If your object has functions of its own, you can also access them here in a dynamic modifier function. This is a convenient way to add some data-specific helper functions in your data source. However, beware that since dynamic functions are usually invoked numerous times during visualization, the function you rely on should be implemented as efficiently as possible. If this is not possible, then it is best to preprocess your data before binding it to your visualization process.</p></div></div><p>Similarly, on line <code class="literal">E</code> in the following code snippet, the <code class="literal">background-color</code> style can be computed using the <code class="literal">d.color</code> attribute with the color scale we defined earlier:</p><pre class="programlisting">.style("background-color", function(d){ 
  return colorScale(d.color); // &lt;- E 
}) 
.text(function (d) { 
  return d.width; // &lt;- F 
}); 
</pre><p>Again, on line <code class="literal">F</code>, we set the text of each bar to display its width.</p><p>This recipe demonstrates how JavaScript objects can easily be bound to visual elements using exactly the same method discussed in the previous recipe. This is one of the most powerful capabilities of the D3 library; it allows you to reuse the same pattern and method to handle different types of data, whether simple or complex. We will see more examples on this topic in the next recipe.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Binding functions as data</h1></div></div></div><p>One of the benefits of D3's excellent support for functional-style JavaScript programming is that it allows functions to be treated as data as well. This particular feature can offer some very powerful capabilities under certain circumstances. This is a more advanced recipe. Don't worry about it if you are new to D3 and have some difficulty understanding it at first. Over time, this functional programming usage will become natural to you.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>How to do it...</h2></div></div></div><p>In this recipe, we will explore the possibility of binding functions as data to your visual elements. This capability is extremely powerful and flexible, if used correctly:</p><pre class="programlisting">&lt;div id="container"&gt;&lt;/div&gt; 
 
&lt;script type="text/javascript"&gt; 
    var data = []; // &lt;- A 
    var datum = function (x) { // &lt;- B 
        return 15 + x * x; 
    }; 
     
    var newData = function () { // &lt;- C 
        data.push(datum); 
        return data; 
    }; 
    function render(){ 
        var divs = d3.select("#container") 
                    .selectAll("div") 
                    .data(newData); // &lt;- D 
        divs.enter().append("div").append("span"); 
        divs.attr("class", "v-bar") 
            .style("height", function (d, i) { 
                return d(i) + "px"; // &lt;- E 
            }) 
            .select("span") // &lt;- F 
                .text(function(d, i){  
                    return d(i); // &lt;- G 
                }); 
        divs.exit().remove(); 
    } 
     
    setInterval(function () { 
        render(); 
    }, 1000); 
    render(); 
&lt;/script&gt; 
</pre><p>This preceding code produces the following bar chart:</p><p>
</p><div><img src="img/image_03_009.jpg" alt="How to do it..."/></div><p>
</p><p>Data as function</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/>How it works...</h2></div></div></div><p>In this recipe, we chose to visualize the output of formula <code class="literal">15 + x * x</code> using a series of vertical bars, each of them annotated with its representing integral value. This visualization adds a new bar to the right of the previous one every one and a half seconds. We can of course implement this visualization using the techniques we discussed in the previous two recipes, where we generated an array of integers using the formula, and then just appended a new integer from <em>n</em> to <em>n+1</em> every 1.5 seconds before re-rendering the visualization. However, in this recipe, we decided to take a more functional approach.</p><p>This time we started with an empty data array on line <code class="literal">A</code>. On line <code class="literal">B</code>, a simple <code class="literal">datum</code> function was defined to calculate the result of this formula <em>15+x^2</em>. Then, on line <code class="literal">C</code>, another function <code class="literal">newData</code> was created to generate the current dataset, which contains <em>n+1</em> references to the <code class="literal">next</code> function. The following is the code for a functional data definition:</p><pre class="programlisting">    var data = []; // &lt;- A 
    var datum = function (x) { // &lt;- B 
        return 15 + x * x; 
    }; 
     
    var newData = function () { // &lt;- C 
        data.push(datum); 
        return data; 
    }; 
</pre><p>This seems to be a strange setup to achieve our goal. Let's take a look at how we can leverage all these functions in our visualization code. On line <code class="literal">D</code>, we bound our data to a selection of <code class="literal">div</code> elements, just as we did in the previous recipes. However, this time, the data is not an array, but rather the <code class="literal">newData</code> function:</p><pre class="programlisting">        var divs = d3.select("#container") 
                   .selectAll("div") 
                   .data(newData); // &lt;- D 
</pre><p>D3 is pretty flexible when it comes to data. If you provide a function to the <code class="literal">data</code> function, D3 will simply invoke the given function and use the returned value of this function as a parameter of the <code class="literal">data</code> function. In this case, the data being returned by the <code class="literal">newData</code> function is an array of function references. As the result of this, now in our dynamic modifier function, on lines <code class="literal">E</code> and <code class="literal">G</code>, the datum <code class="literal">d</code> that is being passed into these functions is actually a reference to the <code class="literal">next</code> function, as shown in the following code:</p><pre class="programlisting">         divs.attr("class", "v-bar") 
            .style("height", function (d, i) { 
                return d(i) + "px"; // &lt;- E 
            }) 
            .select("span") // &lt;- F 
                .text(function(d, i){  
                    return d(i); // &lt;- G 
                });  
</pre><p>As a reference to a function, <code class="literal">d</code> can now be invoked with index <code class="literal">i</code> as the parameter, which in turn will generate the output of the formula needed for our visualization.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>In JavaScript, functions are special objects, so semantically this is exactly the same as binding objects as data. Additionally data can also be considered as functions. Constant values such as integers can be thought of as an identity function that simply returns what it receives with no modification made.</p></div></div><p>This technique might not be the most commonly used technique in visualization; but when used properly, it is extremely flexible and powerful, especially when you have a fluid dataset.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>Datum function typically needs to be <em>idempotent</em> to make sense. Idempotence is the property of being able to apply the same function with the same inputs multiple times without changing the result beyond the initial application. For more detail on idempotence, visit <a class="ulink" href="http://en.wikipedia.org/wiki/Idempotence">http://en.wikipedia.org/wiki/Idempotence
</a>.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Working with arrays</h1></div></div></div><p>Most of our data is stored in arrays, and we spend a lot of our effort working with arrays to format and restructure data. This is why D3 provides a rich set of array-oriented utilities functions, making this task a lot easier. In this recipe, we will explore some of the most common and helpful utilities in this aspect.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>How to do it...</h2></div></div></div><p>The following code example shows some of the most common and helpful array utility functions offered by the D3 library and their effects:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    // Static html code were omitted due to space constraint 
 
    var array = [3, 2, 11, 7, 6, 4, 10, 8, 15]; 
    d3.select("#min").text(d3.min(array)); 
    d3.select("#max").text(d3.max(array)); 
    d3.select("#extent").text(d3.extent(array)); 
    d3.select("#sum").text(d3.sum(array)); 
    d3.select("#median").text(d3.median(array)); 
    d3.select("#mean").text(d3.mean(array)); 
    d3.select("#quantile").text( 
            d3.quantile(array.sort(d3.ascending), 0.25) 
    ); 
    d3.select("#deviation").text(d3.deviation(array)); 
    d3.select("#asc").text(array.sort(d3.ascending)); 
    d3.select("#desc").text(array.sort(d3.descending)); 
    d3.select("#bisect").text( 
        d3.bisect(array.sort(d3.ascending), 6) 
    ); 
    var records = [ 
        {quantity: 2, total: 190, tip: 100, type: "tab"}, 
        {quantity: 2, total: 190, tip: 100, type: "tab"}, 
        {quantity: 1, total: 300, tip: 200, type: "visa"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 1, total: 100, tip: 0, type: "cash"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 200, tip: 0, type: "cash"}, 
        {quantity: 1, total: 200, tip: 100, type: "visa"} 
    ]; 
    var nest = d3.nest() 
            .key(function (d) { // &lt;- A 
                return d.type; 
            }) 
            .key(function (d) { // &lt;- B 
                return d.tip; 
            }) 
            .entries(records); // &lt;- C 
    d3.select("#nest").html(printNest(nest, "")); 
     
    // Utility function to generate HTML  
    // representation of nested tip data  
    function printNest(nest, out, i) { 
        """""""" 
 
    }"""""""" 
&lt;/script&gt;  
</pre><p>The preceding code produces the following output:</p><pre class="programlisting">d3.min =&gt; 2 
d3.max =&gt; 15 
d3.extent =&gt; 2,15 
d3.sum =&gt; 66 
d3.median =&gt; 7 
d3.mean =&gt; 7.333333333333333 
array.sort(d3.ascending) =&gt; 2,3,4,6,7,8,10,11,15 
array.sort(d3.descending) =&gt; 15,11,10,8,7,6,4,3,2 
d3.quantile(array.sort(d3.ascending), 0.25) =&gt; 4 
d3.deviation(array) =&gt; 4.18 
d3.bisect(array.sort(d3.ascending), 6) =&gt; 4 
 
tab 
 100 
  {quantity: 2, total: 190, tip: 100, type: tab, } 
  {quantity: 2, total: 190, tip: 100, type: tab, } 
 0 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
visa 
  200 
   {quantity: 1, total: 300, tip: 200, type: visa, } 
  100 
    {quantity: 1, total: 200, tip: 100, type: visa, } 
cash, } 
   0 
    {quantity: 1, total: 100, tip: 0, type: cash, } 
    {quantity: 2, total: 200, tip: 0, type: cash, } 
</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec56"/>How it works...</h2></div></div></div><p>D3 provides a variety of utility functions to help perform operations on JavaScript arrays. Most of them are pretty intuitive and straightforward; however, there are a few intrinsic ones. We will discuss them briefly in this section.</p><p>Given our array as <code class="literal">[3, 2, 11, 7, 6, 4, 10, 8, 15]</code>, the following will be its utility function:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.min</code>: This function retrieves the smallest element, that is, <code class="literal">2</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.max</code>: This function retrieves the largest element, that is, <code class="literal">15</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.extent</code>: This function retrieves both the smallest and the largest elements, that is, <code class="literal">[2, 15]</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.sum</code>: This function retrieves the addition of all elements in the array, that is, <code class="literal">66</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.medium</code>: This function finds the medium, that is, <code class="literal">7</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.mean</code>: This function calculates the mean value, that is, <code class="literal">7.33</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.ascending</code>/<code class="literal">d3.descending</code>: The <code class="literal">d3</code> object comes with a built-in comparator function that you can use to sort the JavaScript array:</li></ul></div><pre class="programlisting">     d3.ascending = function(a, b) {  return a &lt; b ? -1 : a &gt;  
       b ? 1 : 0; } 
     d3.descending = function(a, b) {  return b &lt; a ? -1 : b  
       &gt; a ? 1 : 0; } 
</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.quantile</code>: This function calculates the quantile on an array that is already sorted in an ascending order, for example, the quantile of <code class="literal">0.25</code> will be <code class="literal">4</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.deviation</code>: This function calculates the standard deviation of the array, in our case that will be <code class="literal">4.18</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.bisect</code>: This function finds an insertion point that comes after (to the right of) any existing element of an already-sorted array, that is, bisect (array, <code class="literal">6</code>) will produce <code class="literal">4</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.nest</code>: D3's nest function can be used to build an algorithm that transforms a flat array-based data structure into a hierarchical nested structure that is particularly suitable for some types of visualization. D3's nest function can be configured using the key function chained to <code class="literal">nest</code>, as seen on lines <code class="literal">A</code> and <code class="literal">B</code>:</li></ul></div><pre class="programlisting">         var nest = d3.nest() 
                 .key(function (d) { // &lt;- A 
                     return d.type; 
                 }) 
                 .key(function (d) { // &lt;- B 
                     return d.tip; 
                 }) 
                 .entries(records); // &lt;- C 
</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Multiple <code class="literal">key</code> functions can be provided to generate multiple levels of nesting. In our case, the nesting consists of two levels, first by the <code class="literal">type</code> amount and then by the <code class="literal">tip</code> amount, as demonstrated in the following output:</li></ul></div><pre class="programlisting">     tab 
      100 
       {quantity: 2, total: 190, tip: 100, type: tab, } 
       {quantity: 2, total: 190, tip: 100, type: tab, } 
</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Finally, the <code class="literal">entries()</code> function is used to supply the flat array-based dataset as shown on line <code class="literal">C</code>.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Filtering with data</h1></div></div></div><p>Imagine you need to filter D3 selection based on the associated data elements so that you can hide or show different subdatasets based on the user's input. D3 selection provides a filter function to perform this kind of data-driven filtering. In this recipe, we will show you how this can be leveraged to filter visual elements in a data-driven fashion.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec58"/>How to do it...</h2></div></div></div><p>The following example code shows how data-based filtering can be leveraged to highlight different visual elements based on its categorization:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var data = [ // &lt;-A 
        {expense: 10, category: "Retail"}, 
        {expense: 15, category: "Gas"}, 
        {expense: 30, category: "Retail"}, 
        {expense: 50, category: "Dining"}, 
        {expense: 80, category: "Gas"}, 
        {expense: 65, category: "Retail"}, 
        {expense: 55, category: "Gas"}, 
        {expense: 30, category: "Dining"}, 
        {expense: 20, category: "Retail"}, 
        {expense: 10, category: "Dining"}, 
        {expense: 8, category: "Gas"} 
    ]; 
    function render(data, category) { 
        var bars = d3.select("body").selectAll("div.h-bar") // &lt;-B 
                .data(data); 
        // Enter 
        bars.enter() 
            .append("div") // &lt;-C 
                .attr("class", "h-bar") 
                .style("width", function (d) { 
                    return (d.expense * 5) + "px";} 
                ) 
                .append("span") // &lt;-D 
                .text(function (d) { 
                    return d.category; 
                }); 
        // Update 
        d3.selectAll("div.h-bar").attr("class", "h-bar"); 
        // Filter 
        bars.filter(function (d, i) { // &lt;-E 
                return d.category == category; 
            }) 
            .classed("selected", true); 
    } 
    render(data); 
    function select(category) { 
        render(data, category); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="select('Retail')"&gt; 
        Retail 
    &lt;/button&gt; 
    &lt;button onclick="select('Gas')"&gt; 
        Gas 
    &lt;/button&gt; 
    &lt;button onclick="select('Dining')"&gt; 
        Dining 
    &lt;/button&gt; 
    &lt;button onclick="select()"&gt; 
        Clear 
    &lt;/button&gt; 
&lt;/div&gt; 
</pre><p>The preceding code generates the following visual output once you click on the <strong>Dining</strong> button:</p><p>
</p><div><img src="img/image_03_010.jpg" alt="How to do it..."/></div><p>
</p><p>Data-based Filtering</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>How it works...</h2></div></div></div><p>In this recipe, we have a dataset that consists of a list of personal expense records with <code class="literal">expense</code> and <code class="literal">category</code> as attributes, which is shown on the block of code marked as <code class="literal">A</code>. On lines <code class="literal">B</code>, <code class="literal">C</code>, and <code class="literal">D</code>, a set of horizontal bars (HTML <code class="literal">div</code>) was created using the standard enter-update-exit pattern to represent the expense records. So far, this recipe is similar to the <em>Binding object literals as data</em> recipe. Now let's take a look at line <code class="literal">E</code>:</p><pre class="programlisting">bars.filter(function (d, i) { // &lt;-E 
    return d.category == category; 
}).classed("selected", true); 
</pre><p>D3's <code class="literal">selection.filter</code> function takes a function as its parameter. It applies the function against every element in the existing selection. The given function for <code class="literal">filter</code> takes two parameters with a hidden <code class="literal">this</code> reference:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d</code>: It is the datum associated with the current element</li><li class="listitem" style="list-style-type: disc"><code class="literal">i</code>: It is a zero-based index for the current element</li><li class="listitem" style="list-style-type: disc"><code class="literal">this</code>: This has the hidden reference points to the current DOM element</li></ul></div><p>D3's <code class="literal">selection.filter</code> function expects the given function to return a Boolean value. If the returned value is <code class="literal">true</code>, the corresponding element will be included into the new selection that is returned by the <code class="literal">filter</code> function. In our example, the <code class="literal">filter</code> function essentially selects all bars that match the user-selected category and applies a CSS class <code class="literal">selected</code> to each one of them. This method provides you a powerful way to filter and generate data-driven sub-selection, which you can further manipulate or dissect to generate focused visualization.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>D3's <code class="literal">selection.filter</code> function treats the returned value using JavaScript as <em>truthy</em> and <em>falsy tests</em>, thus not exactly expecting a strict Boolean value. What this means is that <code class="literal">false</code>, <code class="literal">null</code>, <code class="literal">0</code>, <code class="literal">""</code>, <code class="literal">undefined</code>, and <strong>NaN</strong> (<strong>not a number</strong>) are all treated as <code class="literal">false</code>, while other things are considered <code class="literal">true</code>.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Sorting with data</h1></div></div></div><p>In many cases, it is desirable to sort your visual elements according to the data they represent so that you can highlight the significance of different elements visually. In this recipe, we will explore how this can be achieved in D3.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>How to do it...</h2></div></div></div><p>Let's take a look at how data-driven sorting and further manipulation can be performed using D3. In this example, we will sort the bar chart we created in the previous recipe based on either expense (width) or category, using a user's input:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var data = [ // &lt;-A 
        {expense: 10, category: "Retail"}, 
        {expense: 15, category: "Gas"}, 
        {expense: 30, category: "Retail"}, 
        {expense: 50, category: "Dining"}, 
        {expense: 80, category: "Gas"}, 
        {expense: 65, category: "Retail"}, 
        {expense: 55, category: "Gas"}, 
        {expense: 30, category: "Dining"}, 
        {expense: 20, category: "Retail"}, 
        {expense: 10, category: "Dining"}, 
        {expense: 8, category: "Gas"} 
    ]; 
    function render(data, comparator) { 
        var bars = d3.select("body").selectAll("div.h-bar") // &lt;-B 
                .data(data); 
        // Enter 
        bars.enter().append("div") // &lt;-C 
                .attr("class", "h-bar") 
                .append("span"); 
        // Update 
        d3.selectAll("div.h-bar") // &lt;-D 
                .style("width", function (d) { 
                    return (d.expense * 5) + "px"; 
                }) 
                .select("span") 
                .text(function (d) { 
                    return d.category; 
                }); 
        // Sort 
        if(comparator) 
            bars.sort(comparator); // &lt;-E 
    } 
    var compareByExpense = function (a, b) {  // &lt;-F 
        return a.expense &lt; b.expense?-1:1; 
    }; 
    var compareByCategory = function (a, b) {  // &lt;-G 
        return a.category &lt; b.category?-1:1; 
}; 
 
    render(data); 
     
    function sort(comparator) { 
        render(data, comparator); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="sort(compareByExpense)"&gt; 
        Sort by Expense 
    &lt;/button&gt; 
    &lt;button onclick="sort(compareByCategory)"&gt; 
        Sort by Category 
    &lt;/button&gt; 
    &lt;button onclick="sort()"&gt; 
        Reset 
    &lt;/button&gt; 
&lt;/div&gt; 
</pre><p>This preceding code generates sorted horizontal bars as shown in the following screenshot:</p><p>
</p><div><img src="img/image_03_011.jpg" alt="How to do it..."/></div><p>
</p><p>Data-based Sorting</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>How it works...</h2></div></div></div><p>In this recipe, we set up a simple row-based visualization (in lines <code class="literal">B</code>, <code class="literal">C</code>, and <code class="literal">D</code>) of some simulated personal expense records containing two attributes, <code class="literal">expense</code> and <code class="literal">category</code>, that are defined on line <code class="literal">A</code>. This is almost exactly the same as the previous recipe and quite similar to what we have done in the <em>Binding object literals as data</em> recipe. Once the basics are done, we then select all existing bars on line <code class="literal">E</code> and perform sorting using D3's <code class="literal">selection.sort</code> function:</p><pre class="programlisting">        // Sort 
        if(comparator) 
            bars.sort(comparator); // &lt;-E 
</pre><p>The <code class="literal">selection.sort</code> function accepts a comparator function:</p><pre class="programlisting">var compareByExpense = function (a, b) {  // &lt;-F 
    return a.expense &lt; b.expense?-1:1; 
}; 
var compareByCategory = function (a, b) {  // &lt;-G 
    return a.category &lt; b.category?-1:1; 
}; 
</pre><p>The <code class="literal">comparator</code> function receives two data elements: <code class="literal">a</code> and <code class="literal">b</code>, to compare, returning either a negative, positive, or zero value. If the value is negative, <code class="literal">a</code> will be placed before <code class="literal">b</code>; if positive, <code class="literal">a</code> will be placed after <code class="literal">b</code>; otherwise, <code class="literal">a</code> and <code class="literal">b </code>are considered equal and the order is <em>arbitrary</em>. The <code class="literal">sort()</code> function returns a new selection with all elements sorted in an order that is determined by the specified comparator function. The newly returned selection can then be manipulated further to generate the desired visualization.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>As <code class="literal">a</code> and <code class="literal">b</code> are placed arbitrarily when they are equal, D3 <code class="literal">selection.sort</code> is not guaranteed to be stable; however, it is guaranteed to be consistent with your browser's built-in <code class="literal">sort</code> method on arrays.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Loading data from a server</h1></div></div></div><p>It is probably very rare that you will only be visualizing static local data. The power of data visualization usually lays on the ability to visualize dynamic data typically generated by a server-side program. Since this is a common use case, D3 comes with some handy helper functions to make this task as easy as possible. In this recipe, we will see how a remote dataset can be loaded dynamically and will update an existing visualization once it is loaded.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>How to do it...</h2></div></div></div><p>In the code example of the <code class="literal">asyn-data-load.html</code> file, we will load data dynamically from the server on the user's request, and once the data is loaded, we will also update our visualization to reflect the new expanded dataset. The following is the code for its implementation:</p><pre class="programlisting">&lt;div id="chart"&gt;&lt;/div&gt; 
 
&lt;script type="text/javascript"&gt; 
    function render(data) { 
        var bars = d3.select("#chart").selectAll("div.h-bar") // &lt;-A 
                .data(data); 
        bars.enter().append("div") // &lt;-B 
            .attr("class", "h-bar") 
                .style("width", function (d) { 
                    return (d.expense * 5) + "px"; 
                }) 
            .append("span") 
                .text(function (d) { 
                    return d.category; 
                }); 
    } 
    function load(){ // &lt;-C 
        d3.json("data.json", function(error, json){ // &lt;-D 
            render(json); 
        }); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="load()"&gt;Load Data from JSON feed&lt;/button&gt; 
&lt;/div&gt; 
</pre><p>Here is what our <code class="literal">data.json</code> file looks like:</p><pre class="programlisting">[ 
 {"expense": 15,  "category": "Retail"}, 
 {"expense": 18,  "category": "Gas"}, 
 ... 
 {"expense": 15, "category": "Gas"} 
] 
</pre><p>This recipe generates the following visual output after you click on the <strong>Load Data from JSON feed</strong> button once:</p><p>
</p><div><img src="img/image_03_012.jpg" alt="How to do it..."/></div><p>
</p><p>Data Loading from server</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>How it works...</h2></div></div></div><p>In this recipe, we created a <code class="literal">render</code> function to generate a horizontal bar-based visualization very similar to what we did in the last couple of recipes. The <code class="literal">load</code> function is defined on line <code class="literal">C</code> that responds to the user's click on the <strong>Load Data from JSON feed</strong> button, which loads the data from a separate file (<code class="literal">data.json</code>) served by the server. This is achieved using the <code class="literal">d3.json</code> function as shown on line <code class="literal">F</code>:</p><pre class="programlisting">    function load(){ // &lt;-C 
        d3.json("data.json", function(error, json){ // &lt;-D 
            render(json); 
        }); 
    } 
</pre><p>Since loading a remote dataset from a JSON file could take some time, it is performed asynchronously. Once loaded, the dataset will be passed to the given anonymous callback function defined on line <code class="literal">D</code>. In this function, we simply pass the newly loaded dataset to the <code class="literal">render</code> function in order to generate the visualization.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT, HTML, and XML data a simple task.</p></div></div><p>If a more customized and specific control is required, the <code class="literal">d3.request</code> function can be used to further customize the MIME type and request headers. Behind the scenes, <code class="literal">d3.json</code> and <code class="literal">d3.csv</code> both use <code class="literal">d3.request</code> to generate the actual request.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>MIME media type are a two part identifier for file format transmitted on the internet. The common registered top-level types are: application, text, audio, image, video.</p></div></div><p>Of course, this is by no means the only way to load remote data from the server. D3 does not dictate how data should be loaded from the remote server. You are free to use your favorite JavaScript libraries, such as jQuery or Zepto.js, to issue an Ajax request and load a remote dataset.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Asynchronous data loading using queue</h1></div></div></div><p>In this recipe, we will demonstrate another very useful technique commonly used to process or generate data in large data visualization projects. It is usually necessary in complex visualization project to load and merge multiple datasets from different sources before proceeding to visualizing. The challenge in this kind of asynchronous loading is the difficulty in waiting to know when all datasets have been successfully loaded since only then the visualization can begin. D3 provides a very convenient <code class="literal">queue</code> interface to help organize these types of asynchronous tasks and helps you coordinate among them, which is the focus of this recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>How to do it...</h2></div></div></div><p>In the code example of the <code class="literal">queue.html</code> file, we will simulate loading and merging multiple data points using the <code class="literal">setTimeout</code> function. The <code class="literal">setTimeout</code> function executes the given function after a set period of delay; in our case, we set the delay to 500 milliseconds:</p><pre class="programlisting">&lt;div id="chart"&gt;&lt;/div&gt; 
 
&lt;script type="text/javascript"&gt; 
    function render(data) { 
        var bars = d3.select("#chart").selectAll("div.h-bar") // &lt;-B 
                .data(data); 
        bars.enter().append("div") // &lt;-C 
                .attr("class", "h-bar") 
                .style("width", function (d) { 
                    return (d.number) + "px"; 
                }) 
                .append("span") 
                .text(function (d) { 
                    return d.number; 
                }); 
    } 
    function generateDatum(callback) { 
        setInterval(function(){ 
            callback(null, {number: Math.ceil(Math.random() * 500)}); // &lt;-D 
        }, 500); 
    } 
    function load() { // &lt;-E 
        var q = d3.queue(); // &lt;-F 
        for (var i = 0; i &lt; 10; i++) 
            q.defer(generateDatum); // &lt;-G 
        q.awaitAll(function (error, data) { // &lt;-H 
            render(data); // &lt;- I 
        }); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="load()"&gt;Generate Data Set&lt;/button&gt; 
&lt;/div&gt; 
</pre><p>This recipe generates the following output after clicking on the <strong>Generate Data Set</strong> button:</p><p>
</p><div><img src="img/image_03_013.jpg" alt="How to do it..."/></div><p>
</p><p>Asynchronous Data Generation using D3 Queue</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>How it works...</h2></div></div></div><p>In this recipe, we have a pretty standard <code class="literal">render</code> function that generates horizontal bar visualization using the standard enter-update-exit pattern shown on lines <code class="literal">B</code> and <code class="literal">C</code>. This pattern by now should be very familiar to you. However, the data generation part, which is also our focus here, is a bit different in this recipe. On line <code class="literal">D</code>, we have a simple random datum generation function called <code class="literal">generateDatum(callback)</code>, which receives a single parameter callback. This is a very standard template for task function in D3 queue interface, as shown in the following code snippet:</p><pre class="programlisting">function generateDatum(callback) { 
        setInterval(function(){ 
            callback(null, {number: Math.ceil(Math.random() * 500)}); // &lt;-D 
        }, 500); 
} 
</pre><p>In this function, we use the <code class="literal">setInterval</code> function to simulate asynchronous data generation with a 500 milliseconds delay. Each task function can perform arbitrary logic and calculation in its body, for example, loading data or computing results asynchronously. However, once the task is done, it has to invoke the callback function to notify the queue that it has finished its task and pass back the result as shown on line <code class="literal">D</code>. The callback function takes two parameters: error and result; in this case, we pass <code class="literal">null</code> as error signaling since it has completed successfully with the random number in second parameter. On line <code class="literal">E</code>, we have the <code class="literal">load</code> function defined that leverages <code class="literal">d3.queue</code> to execute the tasks. Let's take a closer look at the <code class="literal">load</code> function:</p><pre class="programlisting">    function load() { // &lt;-E 
        var q = d3.queue(); // &lt;-F 
        for (var i = 0; i &lt; 10; i++) 
            q.defer(generateDatum); // &lt;-G 
            q.awaitAll(function (error, data) { // &lt;-H 
            render(data); // &lt;- I 
        }); 
    } 
</pre><p>D3 Queue can be instantiated using the <code class="literal">d3.queue</code> function as shown on line <code class="literal">F</code>. Once created, it can register any number of tasks using the <code class="literal">defer</code> function as shown on line <code class="literal">G</code>. In our case, we used a <code class="literal">for</code> loop to register <code class="literal">10</code> asynchronous random datum generation tasks in our queue as shown on line <code class="literal">G</code>.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>D3 Queue does not provide multithreading internally as <strong>Web Worker</strong> offers. All tasks are handled synchronously; however, the task function can perform, and typically is designed to perform, asynchronous task as we demonstrated here. For more information on Web Worker, refer to <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
</a>.</p></div></div><p>The <code class="literal">d3.queue.awaitAll</code> function shown on line <code class="literal">H</code> is used to wait for all tasks to be completed. This callback function passed to the <code class="literal">awaitAll</code> function will only be invoked once all tasks are completed or when an error occurs (only the first error is captured and passed to the callback). In our example, we have to wait till all the 10 random data points are successfully produced before calling the render function to generate the visualization on line <code class="literal">I</code>.</p><div><div><h3 class="title"><a id="tip41"/>Tip</h3><p>The <code class="literal">d3.queue</code> function also takes a parameter to define the maximum concurrency allowed when executing tasks. If not provided, it puts no limitation on concurrency.</p></div></div><p>In this chapter we covered the fundamental aspect of using D3 - binding data with the visual elements and how to keep them in synchronization. On top of that we have also covered various topics on data loading and manipulation. In next chapter we will introduce another fundamental concept in D3 to our readers - scales which powers many other higher level D3 features such as animation and shape generator for example.</p></div></div></div></div></body></html>