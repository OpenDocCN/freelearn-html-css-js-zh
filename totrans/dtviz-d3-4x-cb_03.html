<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 3. Dealing with Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/><span class="koboSpan" id="kobo.1.1">Chapter 3. Dealing with Data</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we will cover:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.3.1">Binding an array as data</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Binding object literals as data</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Binding functions as data</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Working with arrays</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Filtering with data</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Sorting with data</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.9.1">Loading data from a server</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.10.1">Asynchronous data loading using queue</span></li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/><span class="koboSpan" id="kobo.11.1">Introduction</span></h1></div></div></div><p><span class="koboSpan" id="kobo.12.1">In this chapter, we will explore the most essential question in any data visualization project: how data can be represented in both programming constructs, and its visual metaphor. </span><span class="koboSpan" id="kobo.12.2">Before we start on this topic, some discussion on data visualization is necessary. </span><span class="koboSpan" id="kobo.12.3">In order to understand what data visualization is, first we will need to understand the difference between data and information.</span></p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">Data consists of raw facts. </span><span class="koboSpan" id="kobo.13.2">The word raw indicates that the facts have not yet been processed to reveal their meaning...Information is the result of processing raw data to reveal its meaning.</span></em></span>
</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">   -Rob P., S. </span><span class="koboSpan" id="kobo.14.2">Morris, and Coronel C. </span><span class="koboSpan" id="kobo.14.3">2009</span></em></span>
</p></blockquote></div><p><span class="koboSpan" id="kobo.15.1">This is how data and information are traditionally defined in the digital information world. </span><span class="koboSpan" id="kobo.15.2">However, data visualization provides a much richer interpretation of this definition since information is no longer the mere result of processed raw facts but rather a visual metaphor of the facts. </span><span class="koboSpan" id="kobo.15.3">As stated by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Manuel Lima</span></em></span><span class="koboSpan" id="kobo.17.1">, in his </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">Information Visualization Manifesto</span></em></span><span class="koboSpan" id="kobo.19.1">, design in the material world, where form is regarded to follow function.</span></p><p><span class="koboSpan" id="kobo.20.1">The same dataset can generate any number of visualizations, which may lay equal claim in terms of validity. </span><span class="koboSpan" id="kobo.20.2">In a sense, visualization is more about communicating the creator's insight into data than anything else. </span><span class="koboSpan" id="kobo.20.3">On a more provocative note, Card, McKinlay, and Shneiderman suggested that the practice of information visualization can be described as follows:</span></p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em><span class="koboSpan" id="kobo.21.1">The use of computer-supported, interactive, visual representations of abstract data to amplify cognition.</span></em></span>
</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em><span class="koboSpan" id="kobo.22.1"> -"Card S. </span><span class="koboSpan" id="kobo.22.2">and Mackinly J.", and Shneiderman B. </span><span class="koboSpan" id="kobo.22.3">1999</span></em></span>
</p></blockquote></div><p><span class="koboSpan" id="kobo.23.1">In the following sections, we will explore various techniques D3 provides to bridge the data with the visual domain. </span><span class="koboSpan" id="kobo.23.2">It is the very first step we need to take before we can create a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.24.1">cognition amplifier</span></em></span><span class="koboSpan" id="kobo.25.1"> with our data.</span></p><div class="section" title="The enter-update-exit pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/><span class="koboSpan" id="kobo.26.1">The enter-update-exit pattern</span></h2></div></div></div><p><span class="koboSpan" id="kobo.27.1">The task of matching each datum with its visual representation, for example, drawing a single bar for every data point you have in your dataset, updating the bars when the data points change, and then eventually removing the bars when certain data points no longer exist, seems to be a complicated and tedious task. </span><span class="koboSpan" id="kobo.27.2">This is precisely why D3 was designed, to provide an ingenious way of simplifying the implementation of this task. </span><span class="koboSpan" id="kobo.27.3">This way of defining the connection between data and its visual representation is usually referred to as the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">enter-update-exit</span></em></span><span class="koboSpan" id="kobo.29.1"> pattern in D3. </span><span class="koboSpan" id="kobo.29.2">This pattern is profoundly different from the typical </span><span class="emphasis"><em><span class="koboSpan" id="kobo.30.1">imperative method</span></em></span><span class="koboSpan" id="kobo.31.1"> most developers are familiar with. </span><span class="koboSpan" id="kobo.31.2">However, the understanding of this pattern is crucial to your effectiveness with the D3 library; and therefore, in this section, we will focus on explaining the concept behind this pattern. </span><span class="koboSpan" id="kobo.31.3">First, let's take a look at the following conceptual illustration of the two domains:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.32.1"><img src="graphics/image_03_001.jpg" alt="The enter-update-exit pattern"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.33.1">Data and visual set</span></p><p><span class="koboSpan" id="kobo.34.1">In the preceding illustration, the two circles represent two joined sets. </span><span class="koboSpan" id="kobo.34.2">Set </span><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">A</span></strong></span><span class="koboSpan" id="kobo.36.1"> depicts your dataset, whereas set </span><span class="strong"><strong><span class="koboSpan" id="kobo.37.1">B</span></strong></span><span class="koboSpan" id="kobo.38.1"> represents the visual elements. </span><span class="koboSpan" id="kobo.38.2">This is essentially how D3 sees the connection between your data and visual elements. </span><span class="koboSpan" id="kobo.38.3">You might be asking how set theory will help your data visualization effort here. </span><span class="koboSpan" id="kobo.38.4">Let me explain.</span></p><p><span class="koboSpan" id="kobo.39.1">First, let us consider the question </span><span class="emphasis"><em><span class="koboSpan" id="kobo.40.1">how can I find all visual elements that currently represent their corresponding data point?</span></em></span><span class="koboSpan" id="kobo.41.1"> The answer is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.42.1">A∩B</span></em></span><span class="koboSpan" id="kobo.43.1">; this denotes the intersection of sets </span><span class="strong"><strong><span class="koboSpan" id="kobo.44.1">A</span></strong></span><span class="koboSpan" id="kobo.45.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.46.1">B</span></strong></span><span class="koboSpan" id="kobo.47.1">, the elements that exist in both Data and Visual domains.</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.48.1"><img src="graphics/image_03_002.jpg" alt="The enter-update-exit pattern"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.49.1">Update mode</span></p><p><span class="koboSpan" id="kobo.50.1">In the preceding diagram, the shaded area represents the intersection between the two sets, </span><span class="strong"><strong><span class="koboSpan" id="kobo.51.1">A</span></strong></span><span class="koboSpan" id="kobo.52.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.53.1">B</span></strong></span><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">In D3, the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">selection.data</span></code><span class="koboSpan" id="kobo.56.1"> function can be used to select this intersection, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.57.1">A</span></em></span>
<span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">∩</span></em></span>
<span class="emphasis"><em><span class="koboSpan" id="kobo.59.1">B</span></em></span><span class="koboSpan" id="kobo.60.1">.</span></p><p><span class="koboSpan" id="kobo.61.1">The </span><code class="literal"><span class="koboSpan" id="kobo.62.1">selection.data(data)</span></code><span class="koboSpan" id="kobo.63.1"> function, upon selection, sets up the connection between the data domain and visual domain, as we discussed in the previous paragraph. </span><span class="koboSpan" id="kobo.63.2">The initial selection forms the visual set </span><span class="strong"><strong><span class="koboSpan" id="kobo.64.1">B</span></strong></span><span class="koboSpan" id="kobo.65.1">, whereas the data provided in the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">data</span></code><span class="koboSpan" id="kobo.67.1"> function form dataset </span><span class="strong"><strong><span class="koboSpan" id="kobo.68.1">A</span></strong></span><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">The return result of this function is a new selection (a data-bound selection) of all elements existing in this intersection. </span><span class="koboSpan" id="kobo.69.3">Now, you can invoke the modifier function on this new selection to update all the existing elements. </span><span class="koboSpan" id="kobo.69.4">This mode of selection is usually referred to as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.70.1">Update mode</span></strong></span><span class="koboSpan" id="kobo.71.1">.</span></p><p><span class="koboSpan" id="kobo.72.1">The second question we will need to answer here is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.73.1">how can I target data points that have not yet been visualized?</span></em></span><span class="koboSpan" id="kobo.74.1"> The answer is the set difference of </span><span class="strong"><strong><span class="koboSpan" id="kobo.75.1">A</span></strong></span><span class="koboSpan" id="kobo.76.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.77.1">B</span></strong></span><span class="koboSpan" id="kobo.78.1">, denoted as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.79.1">A\B</span></em></span><span class="koboSpan" id="kobo.80.1">, which can be seen visually through the following illustration:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.81.1"><img src="graphics/image_03_003.jpg" alt="The enter-update-exit pattern"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.82.1">Enter mode</span></p><p><span class="koboSpan" id="kobo.83.1">The shaded area in set </span><span class="strong"><strong><span class="koboSpan" id="kobo.84.1">A</span></strong></span><span class="koboSpan" id="kobo.85.1"> represents the data points that have not yet been visualized. </span><span class="koboSpan" id="kobo.85.2">In order to gain access to this </span><span class="emphasis"><em><span class="koboSpan" id="kobo.86.1">A\B</span></em></span><span class="koboSpan" id="kobo.87.1"> subset, the following functions need to be performed on a data-bound D3 selection (a selection returned by the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">data</span></code><span class="koboSpan" id="kobo.89.1"> function).</span></p><p><span class="koboSpan" id="kobo.90.1">The </span><code class="literal"><span class="koboSpan" id="kobo.91.1">selection.data(data).enter()</span></code><span class="koboSpan" id="kobo.92.1"> function returns a new selection representing the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.93.1">A\B</span></em></span><span class="koboSpan" id="kobo.94.1"> subset, which contains all the pieces of data that has not yet been represented in the visual domain. </span><span class="koboSpan" id="kobo.94.2">The regular modifier function can then be chained to this new selection method to create new visual elements that represent the given data elements. </span><span class="koboSpan" id="kobo.94.3">This mode of selection is simply referred to as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.95.1">Enter mode</span></strong></span><span class="koboSpan" id="kobo.96.1">.</span></p><p><span class="koboSpan" id="kobo.97.1">The third case in our discussion covers the visual elements that exist in our dataset but no longer have any corresponding data element associated with them. </span><span class="koboSpan" id="kobo.97.2">You might ask how this kind of visual element can exist in the first place. </span><span class="koboSpan" id="kobo.97.3">This is usually caused by removing the elements from the dataset; that is, if you initially visualized all data points within your dataset, and removed some data points after that. </span><span class="koboSpan" id="kobo.97.4">Now, you have certain visual elements that are no longer representing any valid data point in your dataset. </span><span class="koboSpan" id="kobo.97.5">This subset can be discovered using an inverse of the Update difference, denoted as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.98.1">B\A</span></em></span><span class="koboSpan" id="kobo.99.1">.</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.100.1"><img src="graphics/image_03_004.jpg" alt="The enter-update-exit pattern"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.101.1">Exit mode</span></p><p><span class="koboSpan" id="kobo.102.1">The shaded area in the preceding illustration represents the difference we just discussed. </span><span class="koboSpan" id="kobo.102.2">The subset can be selected using the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">selection.exit</span></code><span class="koboSpan" id="kobo.104.1"> function on a data-bound selection.</span></p><p><span class="koboSpan" id="kobo.105.1">The </span><code class="literal"><span class="koboSpan" id="kobo.106.1">selection.data(data).exit</span></code><span class="koboSpan" id="kobo.107.1"> function, when invoked on a data-bound D3 </span><code class="literal"><span class="koboSpan" id="kobo.108.1">selectioncomputes</span></code><span class="koboSpan" id="kobo.109.1"> a new selection which contains all visual elements that are no longer associated with any valid data element. </span><span class="koboSpan" id="kobo.109.2">As a valid D3 selection object, the modifier function can then be chained to this selection to update and remove these visual elements that are no longer required as part of our visualization. </span><span class="koboSpan" id="kobo.109.3">This mode of selection is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.110.1">Exit mode</span></strong></span><span class="koboSpan" id="kobo.111.1">.</span></p><p><span class="koboSpan" id="kobo.112.1">Together, the three different selection modes cover all possible cases of interaction between the data and its visual domain.</span></p><p><span class="koboSpan" id="kobo.113.1">Additionally, D3 also offers a fourth selection mode that is very handy when you need to avoid duplicating visualization code or the so-called </span><span class="emphasis"><em><span class="koboSpan" id="kobo.114.1">DRY</span></em></span><span class="koboSpan" id="kobo.115.1"> up your code. </span><span class="koboSpan" id="kobo.115.2">This fourth mode is called merge mode. </span><span class="koboSpan" id="kobo.115.3">It can be invoked using the </span><code class="literal"><span class="koboSpan" id="kobo.116.1">selection.merge</span></code><span class="koboSpan" id="kobo.117.1"> function. </span><span class="koboSpan" id="kobo.117.2">This function merges the given selection passed to the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">merge</span></code><span class="koboSpan" id="kobo.119.1"> function with the selection where the function is invoked and returns a new selection that is a union of both. </span><span class="koboSpan" id="kobo.119.2">In the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.120.1">enter-update-exit</span></em></span><span class="koboSpan" id="kobo.121.1"> pattern, the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">merge</span></code><span class="koboSpan" id="kobo.123.1"> function is commonly used to construct a selection that covers both the Enter and Update modes since that's where most code duplication would otherwise live.</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.124.1"><img src="graphics/image_03_005.jpg" alt="The enter-update-exit pattern"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.125.1">Merge mode</span></p><p><span class="koboSpan" id="kobo.126.1">The shaded area in this illustration shows the data points targeted by merge mode that combines both Enter and Update modes, which is essentially the entire set A. </span><span class="koboSpan" id="kobo.126.2">This is very convenient since now a single chain of modifiers can be utilized to style both modes and thus lead to less code duplication. </span><span class="koboSpan" id="kobo.126.3">We will demonstrate how to leverage merge mode in each recipe of this chapter.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/><span class="koboSpan" id="kobo.127.1">Note</span></h3><p><span class="koboSpan" id="kobo.128.1">In software engineering, </span><span class="strong"><strong><span class="koboSpan" id="kobo.129.1">Don't Repeat Yourself</span></strong></span><span class="koboSpan" id="kobo.130.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.131.1">DRY</span></strong></span><span class="koboSpan" id="kobo.132.1">) is a principle of software development, aimed at reducing repetition of information of all kinds (Wikipedia, August 2016). </span><span class="koboSpan" id="kobo.132.2">You can also read Mike Bostock's post on </span><span class="emphasis"><em><span class="koboSpan" id="kobo.133.1">What Makes Software Good?</span></em></span><span class="koboSpan" id="kobo.134.1"> for more insight on reasons behind this design change at </span><a class="ulink" href="https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp"><span class="koboSpan" id="kobo.135.1">https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp
</span></a><span class="koboSpan" id="kobo.136.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.137.1">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.138.1">enter-update-exit</span></em></span><span class="koboSpan" id="kobo.139.1"> pattern is the cornerstone of any D3-driven visualization. </span><span class="koboSpan" id="kobo.139.2">In the following recipes of this chapter, we will cover the topics on how these selection methods can be utilized to generate data-driven visual elements efficiently and easily.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Binding an array as data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/><span class="koboSpan" id="kobo.1.1">Binding an array as data</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">One of the most common and popular ways to define data in D3 visualization is through the use of JavaScript arrays; for example, say you have multiple data elements stored in an array, and you want to generate corresponding visual elements to represent each and every one of them. </span><span class="koboSpan" id="kobo.2.2">Additionally, when the data array gets updated, you would want your visualization to reflect such changes immediately. </span><span class="koboSpan" id="kobo.2.3">In this recipe, we will accomplish this common approach.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">The first and most natural solution that might come to mind is iterating through the data array elements and generating their corresponding visual elements on the page. </span><span class="koboSpan" id="kobo.8.2">This is definitely a valid solution, and it will work with D3; however, the enter-update-exit pattern we discussed in the introduction provides a much easier and more efficient way to generate visual elements. </span><span class="koboSpan" id="kobo.8.3">Let's take a look at how we can do that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">var data = [10, 15, 30, 50, 80, 65, 55, 30, 20, 10, 8]; // &lt;- A 
    function render(data) { // &lt;- B 
        var bars = d3.select("body").selectAll("div.h-bar") // &lt;- C 
                .data(data); // Update &lt;- D 
        // Enter 
        bars.enter() // &lt;- E 
                .append("div") // &lt;- F 
                    .attr("class", "h-bar") // &lt;- G 
            .merge(bars) // Enter + Update &lt;- H 
                .style("width", function (d) { 
                    return (d * 3) + "px"; // &lt;- I 
                }) 
                .text(function (d) { 
                    return d; // &lt;- J 
                }); 
        // Exit 
        bars.exit() // &lt;- K 
                .remove(); 
    } 
    setInterval(function () { // &lt;- L 
        data.shift(); 
        data.push(Math.round(Math.random() * 100)); 
        render(data); 
    }, 1500); 
    render(data); 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This recipe generates the following visual output:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_03_006.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Data as array</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/><span class="koboSpan" id="kobo.13.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">In this example, data (a list of integers in this case) is stored in a simple JavaScript array as shown on the line </span><code class="literal"><span class="koboSpan" id="kobo.15.1">A</span></code><span class="koboSpan" id="kobo.16.1"> in the preceding code. </span><span class="koboSpan" id="kobo.16.2">The </span><code class="literal"><span class="koboSpan" id="kobo.17.1">render</span></code><span class="koboSpan" id="kobo.18.1"> function is defined on the line marked as </span><code class="literal"><span class="koboSpan" id="kobo.19.1">B</span></code><span class="koboSpan" id="kobo.20.1"> so that it can be repeatedly invoked to update our visualization. </span><span class="koboSpan" id="kobo.20.2">The selection starts on the line marked as </span><code class="literal"><span class="koboSpan" id="kobo.21.1">C</span></code><span class="koboSpan" id="kobo.22.1">, which selects all </span><code class="literal"><span class="koboSpan" id="kobo.23.1">div</span></code><span class="koboSpan" id="kobo.24.1"> elements on the web page with the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">h-bar</span></code><span class="koboSpan" id="kobo.26.1"> CSS class. </span><span class="koboSpan" id="kobo.26.2">You are probably wondering why we are selecting these </span><code class="literal"><span class="koboSpan" id="kobo.27.1">div</span></code><span class="koboSpan" id="kobo.28.1"> elements since they don't even exist on the web page yet. </span><span class="koboSpan" id="kobo.28.2">This is in fact true; however, the selection at this point is used to define the visual set we discussed in the introduction. </span><span class="koboSpan" id="kobo.28.3">By issuing this selection, that we made in the previous line, we essentially declare that there should be a set of the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">div.h-bar</span></code><span class="koboSpan" id="kobo.30.1"> elements on the web page to form our visual set. </span><span class="koboSpan" id="kobo.30.2">On the line marked as </span><code class="literal"><span class="koboSpan" id="kobo.31.1">D</span></code><span class="koboSpan" id="kobo.32.1">, we invoke the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">data</span></code><span class="koboSpan" id="kobo.34.1"> function on this initial selection to bind the array as our dataset to the to-be-created visual elements. </span><span class="koboSpan" id="kobo.34.2">Once the two sets are defined, the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">enter()</span></code><span class="koboSpan" id="kobo.36.1"> function on line </span><code class="literal"><span class="koboSpan" id="kobo.37.1">E</span></code><span class="koboSpan" id="kobo.38.1"> can be used to select all pieces of data elements that are not yet visualized. </span><span class="koboSpan" id="kobo.38.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">render</span></code><span class="koboSpan" id="kobo.40.1"> function is invoked for the very first time, it returns all elements in the data array, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">        var bars = d3.select("body") 
                       .selectAll("div.h-bar") // &lt;- C 
                       .data(data); // Update &lt;- D 
        // Enter 
        bars.enter() // &lt;- E 
            .append("div") // &lt;- F 
            .attr("class", "h-bar") // &lt;- G 
</span></pre><p><span class="koboSpan" id="kobo.42.1">On line </span><code class="literal"><span class="koboSpan" id="kobo.43.1">F</span></code><span class="koboSpan" id="kobo.44.1">, a new </span><code class="literal"><span class="koboSpan" id="kobo.45.1">div</span></code><span class="koboSpan" id="kobo.46.1"> element is created and appended to the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">body</span></code><span class="koboSpan" id="kobo.48.1"> element of each data element selected in the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">enter</span></code><span class="koboSpan" id="kobo.50.1"> function; this essentially creates one </span><code class="literal"><span class="koboSpan" id="kobo.51.1">div</span></code><span class="koboSpan" id="kobo.52.1"> element for each datum. </span><span class="koboSpan" id="kobo.52.2">Finally, on line </span><code class="literal"><span class="koboSpan" id="kobo.53.1">G</span></code><span class="koboSpan" id="kobo.54.1">, we set its CSS class to </span><code class="literal"><span class="koboSpan" id="kobo.55.1">h-bar</span></code><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">At this point, we basically created the skeleton of our visualization, including the empty </span><code class="literal"><span class="koboSpan" id="kobo.57.1">div</span></code><span class="koboSpan" id="kobo.58.1"> elements. </span><span class="koboSpan" id="kobo.58.2">Next step is to change the visual attributes of our elements based on the given data.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/><span class="koboSpan" id="kobo.59.1">Tip</span></h3><p><span class="koboSpan" id="kobo.60.1">D3 injects a property to the DOM element named </span><code class="literal"><span class="koboSpan" id="kobo.61.1">__data__</span></code><span class="koboSpan" id="kobo.62.1"> to make data sticky with visual elements so when selections are made using a modified dataset, D3 can compute the difference and intersection correctly. </span><span class="koboSpan" id="kobo.62.2">You can see this property easily if you inspect the DOM element either visually using a debugger or programmatically.
</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.63.1"><img src="graphics/image_03_007.jpg" alt="How it works..."/></span></div><p><span class="koboSpan" id="kobo.64.1">
As illustrated by the preceding screenshot, this is very useful to know when debugging.</span></p></div></div><p><span class="koboSpan" id="kobo.65.1">In the following code snippet, on line </span><code class="literal"><span class="koboSpan" id="kobo.66.1">H</span></code><span class="koboSpan" id="kobo.67.1">, the merge function is invoked with the selection as its parameter. </span><span class="koboSpan" id="kobo.67.2">This function call essentially merges the enter selection with the update selection and returns the union of both selections, thus allowing us to chain modifiers for both enter and update scenarios. </span><span class="koboSpan" id="kobo.67.3">Without the merge function, we would need to repeat the code here for both enter and update scenarios. </span><span class="koboSpan" id="kobo.67.4">Then, on line </span><code class="literal"><span class="koboSpan" id="kobo.68.1">I</span></code><span class="koboSpan" id="kobo.69.1">, we applied a dynamic style attribute </span><code class="literal"><span class="koboSpan" id="kobo.70.1">width</span></code><span class="koboSpan" id="kobo.71.1"> to be three times the integer value associated with each visual element, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.72.1">        bars.enter() // &lt;- E 
                .append("div") // &lt;- F 
                    .attr("class", "h-bar") // &lt;- G 
            .merge(bars) // Enter + Update &lt;- H 
                .style("width", function (d) { 
                    return (d * 3) + "px"; // &lt;- I 
                }) 
                .text(function (d) { 
                    return d; // &lt;- J 
                }); 
</span></pre><p><span class="koboSpan" id="kobo.73.1">All D3 modifier functions accept this type of dynamic function to compute its value on the fly. </span><span class="koboSpan" id="kobo.73.2">This is precisely what it means to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.74.1">data drive</span></em></span><span class="koboSpan" id="kobo.75.1"> your visualization. </span><span class="koboSpan" id="kobo.75.2">Hence, it is crucial to understand what this function is designed to achieve in our example. </span><span class="koboSpan" id="kobo.75.3">This function receives a parameter </span><code class="literal"><span class="koboSpan" id="kobo.76.1">d</span></code><span class="koboSpan" id="kobo.77.1">, which is the datum associated with the current element. </span><span class="koboSpan" id="kobo.77.2">In our example, the first </span><code class="literal"><span class="koboSpan" id="kobo.78.1">div</span></code><span class="koboSpan" id="kobo.79.1"> bar has the value </span><code class="literal"><span class="koboSpan" id="kobo.80.1">10</span></code><span class="koboSpan" id="kobo.81.1"> associated as its datum, the second bar has </span><code class="literal"><span class="koboSpan" id="kobo.82.1">15</span></code><span class="koboSpan" id="kobo.83.1">, and so on. </span><span class="koboSpan" id="kobo.83.2">Therefore, this function essentially computes a numeric value that is three times the datum for each bar and returns it as the element's </span><code class="literal"><span class="koboSpan" id="kobo.84.1">width</span></code><span class="koboSpan" id="kobo.85.1"> in pixels. </span><span class="koboSpan" id="kobo.85.2">While, on line </span><code class="literal"><span class="koboSpan" id="kobo.86.1">J</span></code><span class="koboSpan" id="kobo.87.1">, we used a similar approach to change the text content of the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">div</span></code><span class="koboSpan" id="kobo.89.1"> element to the datum value associated with each element.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/><span class="koboSpan" id="kobo.90.1">Note</span></h3><p><span class="koboSpan" id="kobo.91.1">The dynamic modifier function actually accepts two parameters, </span><code class="literal"><span class="koboSpan" id="kobo.92.1">d</span></code><span class="koboSpan" id="kobo.93.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.94.1">i</span></code><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">The first parameter </span><code class="literal"><span class="koboSpan" id="kobo.96.1">d</span></code><span class="koboSpan" id="kobo.97.1"> is the associated datum we just discussed, and </span><code class="literal"><span class="koboSpan" id="kobo.98.1">i</span></code><span class="koboSpan" id="kobo.99.1"> is a zero-based index number for the current element. </span><span class="koboSpan" id="kobo.99.2">Some recipes in the previous chapter relied on this index, and in the rest of this chapter, we will take look at other recipes that utilize this index in different ways.</span></p></div></div><p><span class="koboSpan" id="kobo.100.1">The following is the raw HTML code that resulted from this update process:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.101.1">&lt;div class="h-bar" style="width: 30px;"&gt; 
    10 
&lt;/div&gt; 
&lt;div class="h-bar" style="width: 45px;"&gt; 
    15 
&lt;/div&gt; 
.... 
</span><span class="koboSpan" id="kobo.101.2">&lt;div class="h-bar" style="width: 24px;"&gt; 
    8 
&lt;/div&gt; 
</span></pre><p><span class="koboSpan" id="kobo.102.1">The following last section, </span><code class="literal"><span class="koboSpan" id="kobo.103.1">Exit</span></code><span class="koboSpan" id="kobo.104.1"> section, is fairly simple:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.105.1">bars.exit() // &lt;- K 
    .remove(); 
</span></pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/><span class="koboSpan" id="kobo.106.1">Note</span></h3><p><span class="koboSpan" id="kobo.107.1">The selection returned by the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">exit()</span></code><span class="koboSpan" id="kobo.109.1"> function is just like any other selection. </span><span class="koboSpan" id="kobo.109.2">Therefore, although </span><code class="literal"><span class="koboSpan" id="kobo.110.1">remove</span></code><span class="koboSpan" id="kobo.111.1"> is the most common action used against the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">exit</span></code><span class="koboSpan" id="kobo.113.1"> selection, you can also apply other modifiers or transitions to this selection. </span><span class="koboSpan" id="kobo.113.2">We will explore some of these options in later chapters</span></p></div></div><p><span class="koboSpan" id="kobo.114.1">On line </span><code class="literal"><span class="koboSpan" id="kobo.115.1">K</span></code><span class="koboSpan" id="kobo.116.1"> in the preceding code snippet, the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">exit()</span></code><span class="koboSpan" id="kobo.118.1"> function is called to compute the set difference of all visual elements that are no longer associated with any data. </span><span class="koboSpan" id="kobo.118.2">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">remove()</span></code><span class="koboSpan" id="kobo.120.1"> function is called on this selection to remove all the elements selected by the </span><code class="literal"><span class="koboSpan" id="kobo.121.1">exit()</span></code><span class="koboSpan" id="kobo.122.1"> function. </span><span class="koboSpan" id="kobo.122.2">This way, as long as you call the </span><code class="literal"><span class="koboSpan" id="kobo.123.1">render()</span></code><span class="koboSpan" id="kobo.124.1"> function after you change our data, you can always ensure that our visual representation and data are kept synchronized.</span></p><p><span class="koboSpan" id="kobo.125.1">Now, let's implement the following last block of code as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.126.1">setInterval(function () { // &lt;- L 
        data.shift(); 
        data.push(Math.round(Math.random() * 100)); 
        render(data); 
    }, 1500); 
</span></pre><p><span class="koboSpan" id="kobo.127.1">On line </span><code class="literal"><span class="koboSpan" id="kobo.128.1">L</span></code><span class="koboSpan" id="kobo.129.1">, a simple anonymous function was created to remove the top element in the data array using the </span><code class="literal"><span class="koboSpan" id="kobo.130.1">shift</span></code><span class="koboSpan" id="kobo.131.1"> function while appending a random integer to the data array using the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">push()</span></code><span class="koboSpan" id="kobo.133.1"> function every 1.5 seconds. </span><span class="koboSpan" id="kobo.133.2">Once the data array is updated, the </span><code class="literal"><span class="koboSpan" id="kobo.134.1">render()</span></code><span class="koboSpan" id="kobo.135.1"> function is called again to update our visualization to keep it synchronized with the new dataset. </span><span class="koboSpan" id="kobo.135.2">This is what gives our example its animated bar chart look.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Binding object literals as data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/><span class="koboSpan" id="kobo.1.1">Binding object literals as data</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">With a more complex visualization, each element we have in a data array might not be a primitive integer value or a string, but a JavaScript object itself. </span><span class="koboSpan" id="kobo.2.2">In this recipe, we will discuss how this more complex data structure can be leveraged to drive your visualization using D3.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">JavaScript object literal is probably the most common data structure you will encounter when you load data sources on the Web. </span><span class="koboSpan" id="kobo.8.2">In this recipe, we will take a look at how these JavaScript objects can be leveraged to generate rich visualization. </span><span class="koboSpan" id="kobo.8.3">The following code illustrates how to do it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">var data = [ // &lt;- A 
        {width: 10, color: 23},{width: 15, color: 33}, 
        {width: 30, color: 40},{width: 50, color: 60}, 
        {width: 80, color: 22},{width: 65, color: 10}, 
        {width: 55, color: 5},{width: 30, color: 30}, 
        {width: 20, color: 60},{width: 10, color: 90}, 
        {width: 8, color: 10} 
    ]; 
     
    var colorScale = d3.scaleLinear() 
        .domain([0, 100]) 
        .range(["#add8e6", "blue"]); // &lt;- B 
    function render(data) { 
        var bars = d3.select("body").selectAll("div.h-bar") 
                .data(data); // Update 
        // Enter 
        bars.enter() 
                .append("div") 
                .attr("class", "h-bar") 
                .merge(bars) // Enter + Update 
                .style("width", function (d) { // &lt;- C 
                    return (d.width * 5) + "px"; // &lt;- D 
                }) 
                .style("background-color", function(d){ 
                    return colorScale(d.color); // &lt;- E 
                }) 
                .text(function (d) { 
                    return d.width; // &lt;- F 
                }); 
        // Exit 
        bars.exit().remove(); 
    } 
    function randomValue() { 
        return Math.round(Math.random() * 100); 
    } 
    setInterval(function () { 
        data.shift(); 
        data.push({width: randomValue(), color: randomValue()}); 
        render(data); 
    }, 1500); 
    render(data); 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This recipe generates  the following visu alization:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_03_008.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Data as object</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/><span class="koboSpan" id="kobo.13.1">Note</span></h3><p><span class="koboSpan" id="kobo.14.1">This recipe is built on top of the previous recipe, so if you are not familiar with the fundamental enter-update-exit selection pattern, please take a look at the previous recipe first.</span></p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/><span class="koboSpan" id="kobo.15.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">In this recipe, instead of simple integers as shown in the previous recipe, now our data array is filled with objects (refer to the line marked as </span><code class="literal"><span class="koboSpan" id="kobo.17.1">A</span></code><span class="koboSpan" id="kobo.18.1"> with an arrow left to it). </span><span class="koboSpan" id="kobo.18.2">Each data object contains two attributes: </span><code class="literal"><span class="koboSpan" id="kobo.19.1">width</span></code><span class="koboSpan" id="kobo.20.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.21.1">color</span></code><span class="koboSpan" id="kobo.22.1">, that are both integers in this case:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">        {width: 10, color: 23}, 
        {width: 15, color: 33}, 
... 
        </span><span class="koboSpan" id="kobo.23.2">{width: 8, color: 10} 
    ]; 
 
</span></pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/><span class="koboSpan" id="kobo.24.1">Note</span></h3><p><span class="koboSpan" id="kobo.25.1">On line </span><code class="literal"><span class="koboSpan" id="kobo.26.1">B</span></code><span class="koboSpan" id="kobo.27.1">, we have a complicated-looking </span><code class="literal"><span class="koboSpan" id="kobo.28.1">color</span></code><span class="koboSpan" id="kobo.29.1"> scale defined:
</span><code class="literal"><span class="koboSpan" id="kobo.30.1">...</span></code>
<code class="literal"><span class="koboSpan" id="kobo.31.1">.range(["#add8e6", "blue"]); // &lt;- B</span></code>
<code class="literal"><span class="koboSpan" id="kobo.32.1">...</span></code><span class="koboSpan" id="kobo.33.1">
Scales, including color scale, will be discussed in depth in the next chapter, so for now let us just assume this is a scale function we can use to produce CSS-compatible color code, given some integer input value. </span><span class="koboSpan" id="kobo.33.2">This is sufficient for the purpose of this recipe.</span></p></div></div><p><span class="koboSpan" id="kobo.34.1">The major difference between this recipe and the previous one is the way the data is handled as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.35.1">C</span></code><span class="koboSpan" id="kobo.36.1"> in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">function (d) { // &lt;- C 
    return (d.width * 5) + "px"; // &lt;- D 
} 
</span></pre><p><span class="koboSpan" id="kobo.38.1">As we can see in the preceding code snippet, in this recipe, the datum associated with each visual element is actually an object, not an integer. </span><span class="koboSpan" id="kobo.38.2">Therefore, we can access the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">d.width</span></code><span class="koboSpan" id="kobo.40.1"> attribute on line </span><code class="literal"><span class="koboSpan" id="kobo.41.1">D</span></code><span class="koboSpan" id="kobo.42.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/><span class="koboSpan" id="kobo.43.1">Note</span></h3><p><span class="koboSpan" id="kobo.44.1">If your object has functions of its own, you can also access them here in a dynamic modifier function. </span><span class="koboSpan" id="kobo.44.2">This is a convenient way to add some data-specific helper functions in your data source. </span><span class="koboSpan" id="kobo.44.3">However, beware that since dynamic functions are usually invoked numerous times during visualization, the function you rely on should be implemented as efficiently as possible. </span><span class="koboSpan" id="kobo.44.4">If this is not possible, then it is best to preprocess your data before binding it to your visualization process.</span></p></div></div><p><span class="koboSpan" id="kobo.45.1">Similarly, on line </span><code class="literal"><span class="koboSpan" id="kobo.46.1">E</span></code><span class="koboSpan" id="kobo.47.1"> in the following code snippet, the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">background-color</span></code><span class="koboSpan" id="kobo.49.1"> style can be computed using the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">d.color</span></code><span class="koboSpan" id="kobo.51.1"> attribute with the color scale we defined earlier:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">.style("background-color", function(d){ 
  return colorScale(d.color); // &lt;- E 
}) 
.text(function (d) { 
  return d.width; // &lt;- F 
}); 
</span></pre><p><span class="koboSpan" id="kobo.53.1">Again, on line </span><code class="literal"><span class="koboSpan" id="kobo.54.1">F</span></code><span class="koboSpan" id="kobo.55.1">, we set the text of each bar to display its width.</span></p><p><span class="koboSpan" id="kobo.56.1">This recipe demonstrates how JavaScript objects can easily be bound to visual elements using exactly the same method discussed in the previous recipe. </span><span class="koboSpan" id="kobo.56.2">This is one of the most powerful capabilities of the D3 library; it allows you to reuse the same pattern and method to handle different types of data, whether simple or complex. </span><span class="koboSpan" id="kobo.56.3">We will see more examples on this topic in the next recipe.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Binding functions as data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/><span class="koboSpan" id="kobo.1.1">Binding functions as data</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">One of the benefits of D3's excellent support for functional-style JavaScript programming is that it allows functions to be treated as data as well. </span><span class="koboSpan" id="kobo.2.2">This particular feature can offer some very powerful capabilities under certain circumstances. </span><span class="koboSpan" id="kobo.2.3">This is a more advanced recipe. </span><span class="koboSpan" id="kobo.2.4">Don't worry about it if you are new to D3 and have some difficulty understanding it at first. </span><span class="koboSpan" id="kobo.2.5">Over time, this functional programming usage will become natural to you.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In this recipe, we will explore the possibility of binding functions as data to your visual elements. </span><span class="koboSpan" id="kobo.8.2">This capability is extremely powerful and flexible, if used correctly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;div id="container"&gt;&lt;/div&gt; 
 
&lt;script type="text/javascript"&gt; 
    var data = []; // &lt;- A 
    var datum = function (x) { // &lt;- B 
        return 15 + x * x; 
    }; 
     
    var newData = function () { // &lt;- C 
        data.push(datum); 
        return data; 
    }; 
    function render(){ 
        var divs = d3.select("#container") 
                    .selectAll("div") 
                    .data(newData); // &lt;- D 
        divs.enter().append("div").append("span"); 
        divs.attr("class", "v-bar") 
            .style("height", function (d, i) { 
                return d(i) + "px"; // &lt;- E 
            }) 
            .select("span") // &lt;- F 
                .text(function(d, i){  
                    return d(i); // &lt;- G 
                }); 
        divs.exit().remove(); 
    } 
     
    setInterval(function () { 
        render(); 
    }, 1000); 
    render(); 
&lt;/script&gt; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This preceding code produces the following bar chart:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_03_009.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Data as function</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/><span class="koboSpan" id="kobo.13.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">In this recipe, we chose to visualize the output of formula </span><code class="literal"><span class="koboSpan" id="kobo.15.1">15 + x * x</span></code><span class="koboSpan" id="kobo.16.1"> using a series of vertical bars, each of them annotated with its representing integral value. </span><span class="koboSpan" id="kobo.16.2">This visualization adds a new bar to the right of the previous one every one and a half seconds. </span><span class="koboSpan" id="kobo.16.3">We can of course implement this visualization using the techniques we discussed in the previous two recipes, where we generated an array of integers using the formula, and then just appended a new integer from </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">n</span></em></span><span class="koboSpan" id="kobo.18.1"> to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">n+1</span></em></span><span class="koboSpan" id="kobo.20.1"> every 1.5 seconds before re-rendering the visualization. </span><span class="koboSpan" id="kobo.20.2">However, in this recipe, we decided to take a more functional approach.</span></p><p><span class="koboSpan" id="kobo.21.1">This time we started with an empty data array on line </span><code class="literal"><span class="koboSpan" id="kobo.22.1">A</span></code><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">On line </span><code class="literal"><span class="koboSpan" id="kobo.24.1">B</span></code><span class="koboSpan" id="kobo.25.1">, a simple </span><code class="literal"><span class="koboSpan" id="kobo.26.1">datum</span></code><span class="koboSpan" id="kobo.27.1"> function was defined to calculate the result of this formula </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">15+x^2</span></em></span><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">Then, on line </span><code class="literal"><span class="koboSpan" id="kobo.30.1">C</span></code><span class="koboSpan" id="kobo.31.1">, another function </span><code class="literal"><span class="koboSpan" id="kobo.32.1">newData</span></code><span class="koboSpan" id="kobo.33.1"> was created to generate the current dataset, which contains </span><span class="emphasis"><em><span class="koboSpan" id="kobo.34.1">n+1</span></em></span><span class="koboSpan" id="kobo.35.1"> references to the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">next</span></code><span class="koboSpan" id="kobo.37.1"> function. </span><span class="koboSpan" id="kobo.37.2">The following is the code for a functional data definition:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">    var data = []; // &lt;- A 
    var datum = function (x) { // &lt;- B 
        return 15 + x * x; 
    }; 
     
    var newData = function () { // &lt;- C 
        data.push(datum); 
        return data; 
    }; 
</span></pre><p><span class="koboSpan" id="kobo.39.1">This seems to be a strange setup to achieve our goal. </span><span class="koboSpan" id="kobo.39.2">Let's take a look at how we can leverage all these functions in our visualization code. </span><span class="koboSpan" id="kobo.39.3">On line </span><code class="literal"><span class="koboSpan" id="kobo.40.1">D</span></code><span class="koboSpan" id="kobo.41.1">, we bound our data to a selection of </span><code class="literal"><span class="koboSpan" id="kobo.42.1">div</span></code><span class="koboSpan" id="kobo.43.1"> elements, just as we did in the previous recipes. </span><span class="koboSpan" id="kobo.43.2">However, this time, the data is not an array, but rather the </span><code class="literal"><span class="koboSpan" id="kobo.44.1">newData</span></code><span class="koboSpan" id="kobo.45.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.46.1">        var divs = d3.select("#container") 
                   .selectAll("div") 
                   .data(newData); // &lt;- D 
</span></pre><p><span class="koboSpan" id="kobo.47.1">D3 is pretty flexible when it comes to data. </span><span class="koboSpan" id="kobo.47.2">If you provide a function to the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">data</span></code><span class="koboSpan" id="kobo.49.1"> function, D3 will simply invoke the given function and use the returned value of this function as a parameter of the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">data</span></code><span class="koboSpan" id="kobo.51.1"> function. </span><span class="koboSpan" id="kobo.51.2">In this case, the data being returned by the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">newData</span></code><span class="koboSpan" id="kobo.53.1"> function is an array of function references. </span><span class="koboSpan" id="kobo.53.2">As the result of this, now in our dynamic modifier function, on lines </span><code class="literal"><span class="koboSpan" id="kobo.54.1">E</span></code><span class="koboSpan" id="kobo.55.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.56.1">G</span></code><span class="koboSpan" id="kobo.57.1">, the datum </span><code class="literal"><span class="koboSpan" id="kobo.58.1">d</span></code><span class="koboSpan" id="kobo.59.1"> that is being passed into these functions is actually a reference to the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">next</span></code><span class="koboSpan" id="kobo.61.1"> function, as shown in the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">         divs.attr("class", "v-bar") 
            .style("height", function (d, i) { 
                return d(i) + "px"; // &lt;- E 
            }) 
            .select("span") // &lt;- F 
                .text(function(d, i){  
                    return d(i); // &lt;- G 
                });  
</span></pre><p><span class="koboSpan" id="kobo.63.1">As a reference to a function, </span><code class="literal"><span class="koboSpan" id="kobo.64.1">d</span></code><span class="koboSpan" id="kobo.65.1"> can now be invoked with index </span><code class="literal"><span class="koboSpan" id="kobo.66.1">i</span></code><span class="koboSpan" id="kobo.67.1"> as the parameter, which in turn will generate the output of the formula needed for our visualization.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/><span class="koboSpan" id="kobo.68.1">Note</span></h3><p><span class="koboSpan" id="kobo.69.1">In JavaScript, functions are special objects, so semantically this is exactly the same as binding objects as data. </span><span class="koboSpan" id="kobo.69.2">Additionally data can also be considered as functions. </span><span class="koboSpan" id="kobo.69.3">Constant values such as integers can be thought of as an identity function that simply returns what it receives with no modification made.</span></p></div></div><p><span class="koboSpan" id="kobo.70.1">This technique might not be the most commonly used technique in visualization; but when used properly, it is extremely flexible and powerful, especially when you have a fluid dataset.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/><span class="koboSpan" id="kobo.71.1">Note</span></h3><p><span class="koboSpan" id="kobo.72.1">Datum function typically needs to be </span><span class="emphasis"><em><span class="koboSpan" id="kobo.73.1">idempotent</span></em></span><span class="koboSpan" id="kobo.74.1"> to make sense. </span><span class="koboSpan" id="kobo.74.2">Idempotence is the property of being able to apply the same function with the same inputs multiple times without changing the result beyond the initial application. </span><span class="koboSpan" id="kobo.74.3">For more detail on idempotence, visit </span><a class="ulink" href="http://en.wikipedia.org/wiki/Idempotence"><span class="koboSpan" id="kobo.75.1">http://en.wikipedia.org/wiki/Idempotence
</span></a><span class="koboSpan" id="kobo.76.1">.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Working with arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/><span class="koboSpan" id="kobo.1.1">Working with arrays</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Most of our data is stored in arrays, and we spend a lot of our effort working with arrays to format and restructure data. </span><span class="koboSpan" id="kobo.2.2">This is why D3 provides a rich set of array-oriented utilities functions, making this task a lot easier. </span><span class="koboSpan" id="kobo.2.3">In this recipe, we will explore some of the most common and helpful utilities in this aspect.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">The following code example shows some of the most common and helpful array utility functions offered by the D3 library and their effects:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;script type="text/javascript"&gt; 
    // Static html code were omitted due to space constraint 
 
    var array = [3, 2, 11, 7, 6, 4, 10, 8, 15]; 
    d3.select("#min").text(d3.min(array)); 
    d3.select("#max").text(d3.max(array)); 
    d3.select("#extent").text(d3.extent(array)); 
    d3.select("#sum").text(d3.sum(array)); 
    d3.select("#median").text(d3.median(array)); 
    d3.select("#mean").text(d3.mean(array)); 
    d3.select("#quantile").text( 
            d3.quantile(array.sort(d3.ascending), 0.25) 
    ); 
    d3.select("#deviation").text(d3.deviation(array)); 
    d3.select("#asc").text(array.sort(d3.ascending)); 
    d3.select("#desc").text(array.sort(d3.descending)); 
    d3.select("#bisect").text( 
        d3.bisect(array.sort(d3.ascending), 6) 
    ); 
    var records = [ 
        {quantity: 2, total: 190, tip: 100, type: "tab"}, 
        {quantity: 2, total: 190, tip: 100, type: "tab"}, 
        {quantity: 1, total: 300, tip: 200, type: "visa"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 1, total: 100, tip: 0, type: "cash"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 90, tip: 0, type: "tab"}, 
        {quantity: 2, total: 200, tip: 0, type: "cash"}, 
        {quantity: 1, total: 200, tip: 100, type: "visa"} 
    ]; 
    var nest = d3.nest() 
            .key(function (d) { // &lt;- A 
                return d.type; 
            }) 
            .key(function (d) { // &lt;- B 
                return d.tip; 
            }) 
            .entries(records); // &lt;- C 
    d3.select("#nest").html(printNest(nest, "")); 
     
    // Utility function to generate HTML  
    // representation of nested tip data  
    function printNest(nest, out, i) { 
        """""""" 
 
    }"""""""" 
&lt;/script&gt;  
</span></pre><p><span class="koboSpan" id="kobo.10.1">The preceding code produces the following output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">d3.min =&gt; 2 
d3.max =&gt; 15 
d3.extent =&gt; 2,15 
d3.sum =&gt; 66 
d3.median =&gt; 7 
d3.mean =&gt; 7.333333333333333 
array.sort(d3.ascending) =&gt; 2,3,4,6,7,8,10,11,15 
array.sort(d3.descending) =&gt; 15,11,10,8,7,6,4,3,2 
d3.quantile(array.sort(d3.ascending), 0.25) =&gt; 4 
d3.deviation(array) =&gt; 4.18 
d3.bisect(array.sort(d3.ascending), 6) =&gt; 4 
 
tab 
 100 
  {quantity: 2, total: 190, tip: 100, type: tab, } 
  {quantity: 2, total: 190, tip: 100, type: tab, } 
 0 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
   {quantity: 2, total: 90, tip: 0, type: tab, } 
visa 
  200 
   {quantity: 1, total: 300, tip: 200, type: visa, } 
  100 
    {quantity: 1, total: 200, tip: 100, type: visa, } 
cash, } 
   0 
    {quantity: 1, total: 100, tip: 0, type: cash, } 
    {quantity: 2, total: 200, tip: 0, type: cash, } 
</span></pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/><span class="koboSpan" id="kobo.12.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.13.1">D3 provides a variety of utility functions to help perform operations on JavaScript arrays. </span><span class="koboSpan" id="kobo.13.2">Most of them are pretty intuitive and straightforward; however, there are a few intrinsic ones. </span><span class="koboSpan" id="kobo.13.3">We will discuss them briefly in this section.</span></p><p><span class="koboSpan" id="kobo.14.1">Given our array as </span><code class="literal"><span class="koboSpan" id="kobo.15.1">[3, 2, 11, 7, 6, 4, 10, 8, 15]</span></code><span class="koboSpan" id="kobo.16.1">, the following will be its utility function:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.17.1">d3.min</span></code><span class="koboSpan" id="kobo.18.1">: This function retrieves the smallest element, that is, </span><code class="literal"><span class="koboSpan" id="kobo.19.1">2</span></code><span class="koboSpan" id="kobo.20.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.21.1">d3.max</span></code><span class="koboSpan" id="kobo.22.1">: This function retrieves the largest element, that is, </span><code class="literal"><span class="koboSpan" id="kobo.23.1">15</span></code><span class="koboSpan" id="kobo.24.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.25.1">d3.extent</span></code><span class="koboSpan" id="kobo.26.1">: This function retrieves both the smallest and the largest elements, that is, </span><code class="literal"><span class="koboSpan" id="kobo.27.1">[2, 15]</span></code><span class="koboSpan" id="kobo.28.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.29.1">d3.sum</span></code><span class="koboSpan" id="kobo.30.1">: This function retrieves the addition of all elements in the array, that is, </span><code class="literal"><span class="koboSpan" id="kobo.31.1">66</span></code><span class="koboSpan" id="kobo.32.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.33.1">d3.medium</span></code><span class="koboSpan" id="kobo.34.1">: This function finds the medium, that is, </span><code class="literal"><span class="koboSpan" id="kobo.35.1">7</span></code><span class="koboSpan" id="kobo.36.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.37.1">d3.mean</span></code><span class="koboSpan" id="kobo.38.1">: This function calculates the mean value, that is, </span><code class="literal"><span class="koboSpan" id="kobo.39.1">7.33</span></code><span class="koboSpan" id="kobo.40.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.41.1">d3.ascending</span></code><span class="koboSpan" id="kobo.42.1">/</span><code class="literal"><span class="koboSpan" id="kobo.43.1">d3.descending</span></code><span class="koboSpan" id="kobo.44.1">: The </span><code class="literal"><span class="koboSpan" id="kobo.45.1">d3</span></code><span class="koboSpan" id="kobo.46.1"> object comes with a built-in comparator function that you can use to sort the JavaScript array:</span></li></ul></div><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">     d3.ascending = function(a, b) {  return a &lt; b ? </span><span class="koboSpan" id="kobo.47.2">-1 : a &gt;  
       b ? </span><span class="koboSpan" id="kobo.47.3">1 : 0; } 
     d3.descending = function(a, b) {  return b &lt; a ? </span><span class="koboSpan" id="kobo.47.4">-1 : b  
       &gt; a ? </span><span class="koboSpan" id="kobo.47.5">1 : 0; } 
</span></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.48.1">d3.quantile</span></code><span class="koboSpan" id="kobo.49.1">: This function calculates the quantile on an array that is already sorted in an ascending order, for example, the quantile of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">0.25</span></code><span class="koboSpan" id="kobo.51.1"> will be </span><code class="literal"><span class="koboSpan" id="kobo.52.1">4</span></code><span class="koboSpan" id="kobo.53.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.54.1">d3.deviation</span></code><span class="koboSpan" id="kobo.55.1">: This function calculates the standard deviation of the array, in our case that will be </span><code class="literal"><span class="koboSpan" id="kobo.56.1">4.18</span></code><span class="koboSpan" id="kobo.57.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.58.1">d3.bisect</span></code><span class="koboSpan" id="kobo.59.1">: This function finds an insertion point that comes after (to the right of) any existing element of an already-sorted array, that is, bisect (array, </span><code class="literal"><span class="koboSpan" id="kobo.60.1">6</span></code><span class="koboSpan" id="kobo.61.1">) will produce </span><code class="literal"><span class="koboSpan" id="kobo.62.1">4</span></code><span class="koboSpan" id="kobo.63.1">.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.64.1">d3.nest</span></code><span class="koboSpan" id="kobo.65.1">: D3's nest function can be used to build an algorithm that transforms a flat array-based data structure into a hierarchical nested structure that is particularly suitable for some types of visualization. </span><span class="koboSpan" id="kobo.65.2">D3's nest function can be configured using the key function chained to </span><code class="literal"><span class="koboSpan" id="kobo.66.1">nest</span></code><span class="koboSpan" id="kobo.67.1">, as seen on lines </span><code class="literal"><span class="koboSpan" id="kobo.68.1">A</span></code><span class="koboSpan" id="kobo.69.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.70.1">B</span></code><span class="koboSpan" id="kobo.71.1">:</span></li></ul></div><pre class="programlisting"><span class="koboSpan" id="kobo.72.1">         var nest = d3.nest() 
                 .key(function (d) { // &lt;- A 
                     return d.type; 
                 }) 
                 .key(function (d) { // &lt;- B 
                     return d.tip; 
                 }) 
                 .entries(records); // &lt;- C 
</span></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.73.1">Multiple </span><code class="literal"><span class="koboSpan" id="kobo.74.1">key</span></code><span class="koboSpan" id="kobo.75.1"> functions can be provided to generate multiple levels of nesting. </span><span class="koboSpan" id="kobo.75.2">In our case, the nesting consists of two levels, first by the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">type</span></code><span class="koboSpan" id="kobo.77.1"> amount and then by the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">tip</span></code><span class="koboSpan" id="kobo.79.1"> amount, as demonstrated in the following output:</span></li></ul></div><pre class="programlisting"><span class="koboSpan" id="kobo.80.1">     tab 
      100 
       {quantity: 2, total: 190, tip: 100, type: tab, } 
       {quantity: 2, total: 190, tip: 100, type: tab, } 
</span></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.81.1">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">entries()</span></code><span class="koboSpan" id="kobo.83.1"> function is used to supply the flat array-based dataset as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.84.1">C</span></code><span class="koboSpan" id="kobo.85.1">.</span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Filtering with data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/><span class="koboSpan" id="kobo.1.1">Filtering with data</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Imagine you need to filter D3 selection based on the associated data elements so that you can hide or show different subdatasets based on the user's input. </span><span class="koboSpan" id="kobo.2.2">D3 selection provides a filter function to perform this kind of data-driven filtering. </span><span class="koboSpan" id="kobo.2.3">In this recipe, we will show you how this can be leveraged to filter visual elements in a data-driven fashion.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">The following example code shows how data-based filtering can be leveraged to highlight different visual elements based on its categorization:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;script type="text/javascript"&gt; 
    var data = [ // &lt;-A 
        {expense: 10, category: "Retail"}, 
        {expense: 15, category: "Gas"}, 
        {expense: 30, category: "Retail"}, 
        {expense: 50, category: "Dining"}, 
        {expense: 80, category: "Gas"}, 
        {expense: 65, category: "Retail"}, 
        {expense: 55, category: "Gas"}, 
        {expense: 30, category: "Dining"}, 
        {expense: 20, category: "Retail"}, 
        {expense: 10, category: "Dining"}, 
        {expense: 8, category: "Gas"} 
    ]; 
    function render(data, category) { 
        var bars = d3.select("body").selectAll("div.h-bar") // &lt;-B 
                .data(data); 
        // Enter 
        bars.enter() 
            .append("div") // &lt;-C 
                .attr("class", "h-bar") 
                .style("width", function (d) { 
                    return (d.expense * 5) + "px";} 
                ) 
                .append("span") // &lt;-D 
                .text(function (d) { 
                    return d.category; 
                }); 
        // Update 
        d3.selectAll("div.h-bar").attr("class", "h-bar"); 
        // Filter 
        bars.filter(function (d, i) { // &lt;-E 
                return d.category == category; 
            }) 
            .classed("selected", true); 
    } 
    render(data); 
    function select(category) { 
        render(data, category); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="select('Retail')"&gt; 
        Retail 
    &lt;/button&gt; 
    &lt;button onclick="select('Gas')"&gt; 
        Gas 
    &lt;/button&gt; 
    &lt;button onclick="select('Dining')"&gt; 
        Dining 
    &lt;/button&gt; 
    &lt;button onclick="select()"&gt; 
        Clear 
    &lt;/button&gt; 
&lt;/div&gt; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">The preceding code generates the following visual output once you click on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">Dining</span></strong></span><span class="koboSpan" id="kobo.12.1"> button:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.13.1"><img src="graphics/image_03_010.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.14.1">Data-based Filtering</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/><span class="koboSpan" id="kobo.15.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">In this recipe, we have a dataset that consists of a list of personal expense records with </span><code class="literal"><span class="koboSpan" id="kobo.17.1">expense</span></code><span class="koboSpan" id="kobo.18.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.19.1">category</span></code><span class="koboSpan" id="kobo.20.1"> as attributes, which is shown on the block of code marked as </span><code class="literal"><span class="koboSpan" id="kobo.21.1">A</span></code><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">On lines </span><code class="literal"><span class="koboSpan" id="kobo.23.1">B</span></code><span class="koboSpan" id="kobo.24.1">, </span><code class="literal"><span class="koboSpan" id="kobo.25.1">C</span></code><span class="koboSpan" id="kobo.26.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.27.1">D</span></code><span class="koboSpan" id="kobo.28.1">, a set of horizontal bars (HTML </span><code class="literal"><span class="koboSpan" id="kobo.29.1">div</span></code><span class="koboSpan" id="kobo.30.1">) was created using the standard enter-update-exit pattern to represent the expense records. </span><span class="koboSpan" id="kobo.30.2">So far, this recipe is similar to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.31.1">Binding object literals as data</span></em></span><span class="koboSpan" id="kobo.32.1"> recipe. </span><span class="koboSpan" id="kobo.32.2">Now let's take a look at line </span><code class="literal"><span class="koboSpan" id="kobo.33.1">E</span></code><span class="koboSpan" id="kobo.34.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">bars.filter(function (d, i) { // &lt;-E 
    return d.category == category; 
}).classed("selected", true); 
</span></pre><p><span class="koboSpan" id="kobo.36.1">D3's </span><code class="literal"><span class="koboSpan" id="kobo.37.1">selection.filter</span></code><span class="koboSpan" id="kobo.38.1"> function takes a function as its parameter. </span><span class="koboSpan" id="kobo.38.2">It applies the function against every element in the existing selection. </span><span class="koboSpan" id="kobo.38.3">The given function for </span><code class="literal"><span class="koboSpan" id="kobo.39.1">filter</span></code><span class="koboSpan" id="kobo.40.1"> takes two parameters with a hidden </span><code class="literal"><span class="koboSpan" id="kobo.41.1">this</span></code><span class="koboSpan" id="kobo.42.1"> reference:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.43.1">d</span></code><span class="koboSpan" id="kobo.44.1">: It is the datum associated with the current element</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.45.1">i</span></code><span class="koboSpan" id="kobo.46.1">: It is a zero-based index for the current element</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.47.1">this</span></code><span class="koboSpan" id="kobo.48.1">: This has the hidden reference points to the current DOM element</span></li></ul></div><p><span class="koboSpan" id="kobo.49.1">D3's </span><code class="literal"><span class="koboSpan" id="kobo.50.1">selection.filter</span></code><span class="koboSpan" id="kobo.51.1"> function expects the given function to return a Boolean value. </span><span class="koboSpan" id="kobo.51.2">If the returned value is </span><code class="literal"><span class="koboSpan" id="kobo.52.1">true</span></code><span class="koboSpan" id="kobo.53.1">, the corresponding element will be included into the new selection that is returned by the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">filter</span></code><span class="koboSpan" id="kobo.55.1"> function. </span><span class="koboSpan" id="kobo.55.2">In our example, the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">filter</span></code><span class="koboSpan" id="kobo.57.1"> function essentially selects all bars that match the user-selected category and applies a CSS class </span><code class="literal"><span class="koboSpan" id="kobo.58.1">selected</span></code><span class="koboSpan" id="kobo.59.1"> to each one of them. </span><span class="koboSpan" id="kobo.59.2">This method provides you a powerful way to filter and generate data-driven sub-selection, which you can further manipulate or dissect to generate focused visualization.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/><span class="koboSpan" id="kobo.60.1">Note</span></h3><p><span class="koboSpan" id="kobo.61.1">D3's </span><code class="literal"><span class="koboSpan" id="kobo.62.1">selection.filter</span></code><span class="koboSpan" id="kobo.63.1"> function treats the returned value using JavaScript as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.64.1">truthy</span></em></span><span class="koboSpan" id="kobo.65.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.66.1">falsy tests</span></em></span><span class="koboSpan" id="kobo.67.1">, thus not exactly expecting a strict Boolean value. </span><span class="koboSpan" id="kobo.67.2">What this means is that </span><code class="literal"><span class="koboSpan" id="kobo.68.1">false</span></code><span class="koboSpan" id="kobo.69.1">, </span><code class="literal"><span class="koboSpan" id="kobo.70.1">null</span></code><span class="koboSpan" id="kobo.71.1">, </span><code class="literal"><span class="koboSpan" id="kobo.72.1">0</span></code><span class="koboSpan" id="kobo.73.1">, </span><code class="literal"><span class="koboSpan" id="kobo.74.1">""</span></code><span class="koboSpan" id="kobo.75.1">, </span><code class="literal"><span class="koboSpan" id="kobo.76.1">undefined</span></code><span class="koboSpan" id="kobo.77.1">, and </span><span class="strong"><strong><span class="koboSpan" id="kobo.78.1">NaN</span></strong></span><span class="koboSpan" id="kobo.79.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.80.1">not a number</span></strong></span><span class="koboSpan" id="kobo.81.1">) are all treated as </span><code class="literal"><span class="koboSpan" id="kobo.82.1">false</span></code><span class="koboSpan" id="kobo.83.1">, while other things are considered </span><code class="literal"><span class="koboSpan" id="kobo.84.1">true</span></code><span class="koboSpan" id="kobo.85.1">.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Sorting with data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/><span class="koboSpan" id="kobo.1.1">Sorting with data</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In many cases, it is desirable to sort your visual elements according to the data they represent so that you can highlight the significance of different elements visually. </span><span class="koboSpan" id="kobo.2.2">In this recipe, we will explore how this can be achieved in D3.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec60"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">Let's take a look at how data-driven sorting and further manipulation can be performed using D3. </span><span class="koboSpan" id="kobo.8.2">In this example, we will sort the bar chart we created in the previous recipe based on either expense (width) or category, using a user's input:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;script type="text/javascript"&gt; 
    var data = [ // &lt;-A 
        {expense: 10, category: "Retail"}, 
        {expense: 15, category: "Gas"}, 
        {expense: 30, category: "Retail"}, 
        {expense: 50, category: "Dining"}, 
        {expense: 80, category: "Gas"}, 
        {expense: 65, category: "Retail"}, 
        {expense: 55, category: "Gas"}, 
        {expense: 30, category: "Dining"}, 
        {expense: 20, category: "Retail"}, 
        {expense: 10, category: "Dining"}, 
        {expense: 8, category: "Gas"} 
    ]; 
    function render(data, comparator) { 
        var bars = d3.select("body").selectAll("div.h-bar") // &lt;-B 
                .data(data); 
        // Enter 
        bars.enter().append("div") // &lt;-C 
                .attr("class", "h-bar") 
                .append("span"); 
        // Update 
        d3.selectAll("div.h-bar") // &lt;-D 
                .style("width", function (d) { 
                    return (d.expense * 5) + "px"; 
                }) 
                .select("span") 
                .text(function (d) { 
                    return d.category; 
                }); 
        // Sort 
        if(comparator) 
            bars.sort(comparator); // &lt;-E 
    } 
    var compareByExpense = function (a, b) {  // &lt;-F 
        return a.expense &lt; b.expense?-1:1; 
    }; 
    var compareByCategory = function (a, b) {  // &lt;-G 
        return a.category &lt; b.category?-1:1; 
}; 
 
    render(data); 
     
    function sort(comparator) { 
        render(data, comparator); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="sort(compareByExpense)"&gt; 
        Sort by Expense 
    &lt;/button&gt; 
    &lt;button onclick="sort(compareByCategory)"&gt; 
        Sort by Category 
    &lt;/button&gt; 
    &lt;button onclick="sort()"&gt; 
        Reset 
    &lt;/button&gt; 
&lt;/div&gt; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This preceding code generates sorted horizontal bars as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_03_011.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Data-based Sorting</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/><span class="koboSpan" id="kobo.13.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">In this recipe, we set up a simple row-based visualization (in lines </span><code class="literal"><span class="koboSpan" id="kobo.15.1">B</span></code><span class="koboSpan" id="kobo.16.1">, </span><code class="literal"><span class="koboSpan" id="kobo.17.1">C</span></code><span class="koboSpan" id="kobo.18.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.19.1">D</span></code><span class="koboSpan" id="kobo.20.1">) of some simulated personal expense records containing two attributes, </span><code class="literal"><span class="koboSpan" id="kobo.21.1">expense</span></code><span class="koboSpan" id="kobo.22.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.23.1">category</span></code><span class="koboSpan" id="kobo.24.1">, that are defined on line </span><code class="literal"><span class="koboSpan" id="kobo.25.1">A</span></code><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">This is almost exactly the same as the previous recipe and quite similar to what we have done in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.27.1">Binding object literals as data</span></em></span><span class="koboSpan" id="kobo.28.1"> recipe. </span><span class="koboSpan" id="kobo.28.2">Once the basics are done, we then select all existing bars on line </span><code class="literal"><span class="koboSpan" id="kobo.29.1">E</span></code><span class="koboSpan" id="kobo.30.1"> and perform sorting using D3's </span><code class="literal"><span class="koboSpan" id="kobo.31.1">selection.sort</span></code><span class="koboSpan" id="kobo.32.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">        // Sort 
        if(comparator) 
            bars.sort(comparator); // &lt;-E 
</span></pre><p><span class="koboSpan" id="kobo.34.1">The </span><code class="literal"><span class="koboSpan" id="kobo.35.1">selection.sort</span></code><span class="koboSpan" id="kobo.36.1"> function accepts a comparator function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">var compareByExpense = function (a, b) {  // &lt;-F 
    return a.expense &lt; b.expense?-1:1; 
}; 
var compareByCategory = function (a, b) {  // &lt;-G 
    return a.category &lt; b.category?-1:1; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.38.1">The </span><code class="literal"><span class="koboSpan" id="kobo.39.1">comparator</span></code><span class="koboSpan" id="kobo.40.1"> function receives two data elements: </span><code class="literal"><span class="koboSpan" id="kobo.41.1">a</span></code><span class="koboSpan" id="kobo.42.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.43.1">b</span></code><span class="koboSpan" id="kobo.44.1">, to compare, returning either a negative, positive, or zero value. </span><span class="koboSpan" id="kobo.44.2">If the value is negative, </span><code class="literal"><span class="koboSpan" id="kobo.45.1">a</span></code><span class="koboSpan" id="kobo.46.1"> will be placed before </span><code class="literal"><span class="koboSpan" id="kobo.47.1">b</span></code><span class="koboSpan" id="kobo.48.1">; if positive, </span><code class="literal"><span class="koboSpan" id="kobo.49.1">a</span></code><span class="koboSpan" id="kobo.50.1"> will be placed after </span><code class="literal"><span class="koboSpan" id="kobo.51.1">b</span></code><span class="koboSpan" id="kobo.52.1">; otherwise, </span><code class="literal"><span class="koboSpan" id="kobo.53.1">a</span></code><span class="koboSpan" id="kobo.54.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.55.1">b </span></code><span class="koboSpan" id="kobo.56.1">are considered equal and the order is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.57.1">arbitrary</span></em></span><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">The </span><code class="literal"><span class="koboSpan" id="kobo.59.1">sort()</span></code><span class="koboSpan" id="kobo.60.1"> function returns a new selection with all elements sorted in an order that is determined by the specified comparator function. </span><span class="koboSpan" id="kobo.60.2">The newly returned selection can then be manipulated further to generate the desired visualization.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/><span class="koboSpan" id="kobo.61.1">Note</span></h3><p><span class="koboSpan" id="kobo.62.1">As </span><code class="literal"><span class="koboSpan" id="kobo.63.1">a</span></code><span class="koboSpan" id="kobo.64.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.65.1">b</span></code><span class="koboSpan" id="kobo.66.1"> are placed arbitrarily when they are equal, D3 </span><code class="literal"><span class="koboSpan" id="kobo.67.1">selection.sort</span></code><span class="koboSpan" id="kobo.68.1"> is not guaranteed to be stable; however, it is guaranteed to be consistent with your browser's built-in </span><code class="literal"><span class="koboSpan" id="kobo.69.1">sort</span></code><span class="koboSpan" id="kobo.70.1"> method on arrays.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Loading data from a server"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/><span class="koboSpan" id="kobo.1.1">Loading data from a server</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">It is probably very rare that you will only be visualizing static local data. </span><span class="koboSpan" id="kobo.2.2">The power of data visualization usually lays on the ability to visualize dynamic data typically generated by a server-side program. </span><span class="koboSpan" id="kobo.2.3">Since this is a common use case, D3 comes with some handy helper functions to make this task as easy as possible. </span><span class="koboSpan" id="kobo.2.4">In this recipe, we will see how a remote dataset can be loaded dynamically and will update an existing visualization once it is loaded.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In the code example of the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">asyn-data-load.html</span></code><span class="koboSpan" id="kobo.10.1"> file, we will load data dynamically from the server on the user's request, and once the data is loaded, we will also update our visualization to reflect the new expanded dataset. </span><span class="koboSpan" id="kobo.10.2">The following is the code for its implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">&lt;div id="chart"&gt;&lt;/div&gt; 
 
&lt;script type="text/javascript"&gt; 
    function render(data) { 
        var bars = d3.select("#chart").selectAll("div.h-bar") // &lt;-A 
                .data(data); 
        bars.enter().append("div") // &lt;-B 
            .attr("class", "h-bar") 
                .style("width", function (d) { 
                    return (d.expense * 5) + "px"; 
                }) 
            .append("span") 
                .text(function (d) { 
                    return d.category; 
                }); 
    } 
    function load(){ // &lt;-C 
        d3.json("data.json", function(error, json){ // &lt;-D 
            render(json); 
        }); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="load()"&gt;Load Data from JSON feed&lt;/button&gt; 
&lt;/div&gt; 
</span></pre><p><span class="koboSpan" id="kobo.12.1">Here is what our </span><code class="literal"><span class="koboSpan" id="kobo.13.1">data.json</span></code><span class="koboSpan" id="kobo.14.1"> file looks like:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">[ 
 {"expense": 15,  "category": "Retail"}, 
 {"expense": 18,  "category": "Gas"}, 
 ... 
 </span><span class="koboSpan" id="kobo.15.2">{"expense": 15, "category": "Gas"} 
] 
</span></pre><p><span class="koboSpan" id="kobo.16.1">This recipe generates the following visual output after you click on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">Load Data from JSON feed</span></strong></span><span class="koboSpan" id="kobo.18.1"> button once:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.19.1"><img src="graphics/image_03_012.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.20.1">Data Loading from server</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/><span class="koboSpan" id="kobo.21.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.22.1">In this recipe, we created a </span><code class="literal"><span class="koboSpan" id="kobo.23.1">render</span></code><span class="koboSpan" id="kobo.24.1"> function to generate a horizontal bar-based visualization very similar to what we did in the last couple of recipes. </span><span class="koboSpan" id="kobo.24.2">The </span><code class="literal"><span class="koboSpan" id="kobo.25.1">load</span></code><span class="koboSpan" id="kobo.26.1"> function is defined on line </span><code class="literal"><span class="koboSpan" id="kobo.27.1">C</span></code><span class="koboSpan" id="kobo.28.1"> that responds to the user's click on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.29.1">Load Data from JSON feed</span></strong></span><span class="koboSpan" id="kobo.30.1"> button, which loads the data from a separate file (</span><code class="literal"><span class="koboSpan" id="kobo.31.1">data.json</span></code><span class="koboSpan" id="kobo.32.1">) served by the server. </span><span class="koboSpan" id="kobo.32.2">This is achieved using the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">d3.json</span></code><span class="koboSpan" id="kobo.34.1"> function as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.35.1">F</span></code><span class="koboSpan" id="kobo.36.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">    function load(){ // &lt;-C 
        d3.json("data.json", function(error, json){ // &lt;-D 
            render(json); 
        }); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.38.1">Since loading a remote dataset from a JSON file could take some time, it is performed asynchronously. </span><span class="koboSpan" id="kobo.38.2">Once loaded, the dataset will be passed to the given anonymous callback function defined on line </span><code class="literal"><span class="koboSpan" id="kobo.39.1">D</span></code><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">In this function, we simply pass the newly loaded dataset to the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">render</span></code><span class="koboSpan" id="kobo.42.1"> function in order to generate the visualization.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/><span class="koboSpan" id="kobo.43.1">Note</span></h3><p><span class="koboSpan" id="kobo.44.1">Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT, HTML, and XML data a simple task.</span></p></div></div><p><span class="koboSpan" id="kobo.45.1">If a more customized and specific control is required, the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">d3.request</span></code><span class="koboSpan" id="kobo.47.1"> function can be used to further customize the MIME type and request headers. </span><span class="koboSpan" id="kobo.47.2">Behind the scenes, </span><code class="literal"><span class="koboSpan" id="kobo.48.1">d3.json</span></code><span class="koboSpan" id="kobo.49.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.50.1">d3.csv</span></code><span class="koboSpan" id="kobo.51.1"> both use </span><code class="literal"><span class="koboSpan" id="kobo.52.1">d3.request</span></code><span class="koboSpan" id="kobo.53.1"> to generate the actual request.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/><span class="koboSpan" id="kobo.54.1">Note</span></h3><p><span class="koboSpan" id="kobo.55.1">MIME media type are a two part identifier for file format transmitted on the internet. </span><span class="koboSpan" id="kobo.55.2">The common registered top-level types are: application, text, audio, image, video.</span></p></div></div><p><span class="koboSpan" id="kobo.56.1">Of course, this is by no means the only way to load remote data from the server. </span><span class="koboSpan" id="kobo.56.2">D3 does not dictate how data should be loaded from the remote server. </span><span class="koboSpan" id="kobo.56.3">You are free to use your favorite JavaScript libraries, such as jQuery or Zepto.js, to issue an Ajax request and load a remote dataset.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Asynchronous data loading using queue"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/><span class="koboSpan" id="kobo.1.1">Asynchronous data loading using queue</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this recipe, we will demonstrate another very useful technique commonly used to process or generate data in large data visualization projects. </span><span class="koboSpan" id="kobo.2.2">It is usually necessary in complex visualization project to load and merge multiple datasets from different sources before proceeding to visualizing. </span><span class="koboSpan" id="kobo.2.3">The challenge in this kind of asynchronous loading is the difficulty in waiting to know when all datasets have been successfully loaded since only then the visualization can begin. </span><span class="koboSpan" id="kobo.2.4">D3 provides a very convenient </span><code class="literal"><span class="koboSpan" id="kobo.3.1">queue</span></code><span class="koboSpan" id="kobo.4.1"> interface to help organize these types of asynchronous tasks and helps you coordinate among them, which is the focus of this recipe.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/><span class="koboSpan" id="kobo.5.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html"><span class="koboSpan" id="kobo.7.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html
</span></a><span class="koboSpan" id="kobo.8.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/><span class="koboSpan" id="kobo.9.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.10.1">In the code example of the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">queue.html</span></code><span class="koboSpan" id="kobo.12.1"> file, we will simulate loading and merging multiple data points using the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">setTimeout</span></code><span class="koboSpan" id="kobo.14.1"> function. </span><span class="koboSpan" id="kobo.14.2">The </span><code class="literal"><span class="koboSpan" id="kobo.15.1">setTimeout</span></code><span class="koboSpan" id="kobo.16.1"> function executes the given function after a set period of delay; in our case, we set the delay to 500 milliseconds:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">&lt;div id="chart"&gt;&lt;/div&gt; 
 
&lt;script type="text/javascript"&gt; 
    function render(data) { 
        var bars = d3.select("#chart").selectAll("div.h-bar") // &lt;-B 
                .data(data); 
        bars.enter().append("div") // &lt;-C 
                .attr("class", "h-bar") 
                .style("width", function (d) { 
                    return (d.number) + "px"; 
                }) 
                .append("span") 
                .text(function (d) { 
                    return d.number; 
                }); 
    } 
    function generateDatum(callback) { 
        setInterval(function(){ 
            callback(null, {number: Math.ceil(Math.random() * 500)}); // &lt;-D 
        }, 500); 
    } 
    function load() { // &lt;-E 
        var q = d3.queue(); // &lt;-F 
        for (var i = 0; i &lt; 10; i++) 
            q.defer(generateDatum); // &lt;-G 
        q.awaitAll(function (error, data) { // &lt;-H 
            render(data); // &lt;- I 
        }); 
    } 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="load()"&gt;Generate Data Set&lt;/button&gt; 
&lt;/div&gt; 
</span></pre><p><span class="koboSpan" id="kobo.18.1">This recipe generates the following output after clicking on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">Generate Data Set</span></strong></span><span class="koboSpan" id="kobo.20.1"> button:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.21.1"><img src="graphics/image_03_013.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.22.1">Asynchronous Data Generation using D3 Queue</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec68"/><span class="koboSpan" id="kobo.23.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.24.1">In this recipe, we have a pretty standard </span><code class="literal"><span class="koboSpan" id="kobo.25.1">render</span></code><span class="koboSpan" id="kobo.26.1"> function that generates horizontal bar visualization using the standard enter-update-exit pattern shown on lines </span><code class="literal"><span class="koboSpan" id="kobo.27.1">B</span></code><span class="koboSpan" id="kobo.28.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.29.1">C</span></code><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">This pattern by now should be very familiar to you. </span><span class="koboSpan" id="kobo.30.3">However, the data generation part, which is also our focus here, is a bit different in this recipe. </span><span class="koboSpan" id="kobo.30.4">On line </span><code class="literal"><span class="koboSpan" id="kobo.31.1">D</span></code><span class="koboSpan" id="kobo.32.1">, we have a simple random datum generation function called </span><code class="literal"><span class="koboSpan" id="kobo.33.1">generateDatum(callback)</span></code><span class="koboSpan" id="kobo.34.1">, which receives a single parameter callback. </span><span class="koboSpan" id="kobo.34.2">This is a very standard template for task function in D3 queue interface, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">function generateDatum(callback) { 
        setInterval(function(){ 
            callback(null, {number: Math.ceil(Math.random() * 500)}); // &lt;-D 
        }, 500); 
} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">In this function, we use the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">setInterval</span></code><span class="koboSpan" id="kobo.38.1"> function to simulate asynchronous data generation with a 500 milliseconds delay. </span><span class="koboSpan" id="kobo.38.2">Each task function can perform arbitrary logic and calculation in its body, for example, loading data or computing results asynchronously. </span><span class="koboSpan" id="kobo.38.3">However, once the task is done, it has to invoke the callback function to notify the queue that it has finished its task and pass back the result as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.39.1">D</span></code><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">The callback function takes two parameters: error and result; in this case, we pass </span><code class="literal"><span class="koboSpan" id="kobo.41.1">null</span></code><span class="koboSpan" id="kobo.42.1"> as error signaling since it has completed successfully with the random number in second parameter. </span><span class="koboSpan" id="kobo.42.2">On line </span><code class="literal"><span class="koboSpan" id="kobo.43.1">E</span></code><span class="koboSpan" id="kobo.44.1">, we have the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">load</span></code><span class="koboSpan" id="kobo.46.1"> function defined that leverages </span><code class="literal"><span class="koboSpan" id="kobo.47.1">d3.queue</span></code><span class="koboSpan" id="kobo.48.1"> to execute the tasks. </span><span class="koboSpan" id="kobo.48.2">Let's take a closer look at the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">load</span></code><span class="koboSpan" id="kobo.50.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">    function load() { // &lt;-E 
        var q = d3.queue(); // &lt;-F 
        for (var i = 0; i &lt; 10; i++) 
            q.defer(generateDatum); // &lt;-G 
            q.awaitAll(function (error, data) { // &lt;-H 
            render(data); // &lt;- I 
        }); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.52.1">D3 Queue can be instantiated using the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">d3.queue</span></code><span class="koboSpan" id="kobo.54.1"> function as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.55.1">F</span></code><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Once created, it can register any number of tasks using the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">defer</span></code><span class="koboSpan" id="kobo.58.1"> function as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.59.1">G</span></code><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">In our case, we used a </span><code class="literal"><span class="koboSpan" id="kobo.61.1">for</span></code><span class="koboSpan" id="kobo.62.1"> loop to register </span><code class="literal"><span class="koboSpan" id="kobo.63.1">10</span></code><span class="koboSpan" id="kobo.64.1"> asynchronous random datum generation tasks in our queue as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.65.1">G</span></code><span class="koboSpan" id="kobo.66.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/><span class="koboSpan" id="kobo.67.1">Note</span></h3><p><span class="koboSpan" id="kobo.68.1">D3 Queue does not provide multithreading internally as </span><span class="strong"><strong><span class="koboSpan" id="kobo.69.1">Web Worker</span></strong></span><span class="koboSpan" id="kobo.70.1"> offers. </span><span class="koboSpan" id="kobo.70.2">All tasks are handled synchronously; however, the task function can perform, and typically is designed to perform, asynchronous task as we demonstrated here. </span><span class="koboSpan" id="kobo.70.3">For more information on Web Worker, refer to </span><a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"><span class="koboSpan" id="kobo.71.1">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
</span></a><span class="koboSpan" id="kobo.72.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.73.1">The </span><code class="literal"><span class="koboSpan" id="kobo.74.1">d3.queue.awaitAll</span></code><span class="koboSpan" id="kobo.75.1"> function shown on line </span><code class="literal"><span class="koboSpan" id="kobo.76.1">H</span></code><span class="koboSpan" id="kobo.77.1"> is used to wait for all tasks to be completed. </span><span class="koboSpan" id="kobo.77.2">This callback function passed to the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">awaitAll</span></code><span class="koboSpan" id="kobo.79.1"> function will only be invoked once all tasks are completed or when an error occurs (only the first error is captured and passed to the callback). </span><span class="koboSpan" id="kobo.79.2">In our example, we have to wait till all the 10 random data points are successfully produced before calling the render function to generate the visualization on line </span><code class="literal"><span class="koboSpan" id="kobo.80.1">I</span></code><span class="koboSpan" id="kobo.81.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/><span class="koboSpan" id="kobo.82.1">Tip</span></h3><p><span class="koboSpan" id="kobo.83.1">The </span><code class="literal"><span class="koboSpan" id="kobo.84.1">d3.queue</span></code><span class="koboSpan" id="kobo.85.1"> function also takes a parameter to define the maximum concurrency allowed when executing tasks. </span><span class="koboSpan" id="kobo.85.2">If not provided, it puts no limitation on concurrency.</span></p></div></div><p><span class="koboSpan" id="kobo.86.1">In this chapter we covered the fundamental aspect of using D3 - binding data with the visual elements and how to keep them in synchronization. </span><span class="koboSpan" id="kobo.86.2">On top of that we have also covered various topics on data loading and manipulation. </span><span class="koboSpan" id="kobo.86.3">In next chapter we will introduce another fundamental concept in D3 to our readers - scales which powers many other higher level D3 features such as animation and shape generator for example.</span></p></div></div></div></div></body></html>