<html><head></head><body>
		<div id="_idContainer035">
			<h1 id="_idParaDest-81"><em class="italic"><a id="_idTextAnchor140"/>Chapter 7:</em> Findings from TestCafe</h1>
			<p>The main learning goal in this chapter is to optimize our test actions with functions and get familiar with how to use npm scripts to run the tests. We will also review the main direction of TestCafe framework development, along with some references to useful resources. </p>
			<p>This knowledge will give us some additional ideas on how to refactor tests, how to run them more efficiently, and where to search for further improvements.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Taking a final step with test functions.</li>
				<li>Wrapping up the test project with npm scripts.</li>
				<li>Exploring TestCafe development and future plans.</li>
				<li>Additional references to useful resources.</li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor141"/>Technical requirements</h1>
			<p>All code examples for this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor142"/>Taking a final step with test functions</h1>
			<p>The tests that we created consist of chains <a id="_idIndexMarker254"/>of actions. Some of them, such as the <strong class="source-inline">Creating a new project</strong> test, are still being repeated. So, one final logical step to take will be to separate such sequences of actions into the functions. Let's see how this can be achieved with the <strong class="source-inline">createNewProject</strong>, <strong class="source-inline">createNewIssue</strong>, and <strong class="source-inline">uploadFile</strong> functions inside <strong class="source-inline">redmine-page.js</strong>:</p>
			<p class="source-code">const { Selector, ClientFunction, Role, t } = require('testcafe');const { stamp } = require('js-automation-tools');// ...redminePage.getPageUrl = ClientFunction(() =&gt; {    return window.location.href;});redminePage.regularUser = Role(redminePage.urlRedmine, async (t) =&gt; {    await t.click(redminePage.linkLogin)        .typeText(redminePage.inputUsername, redminePage.emailRegularUser)        .typeText(redminePage.inputPassword, redminePage.         passwordRegularUser)        .click(redminePage.buttonLogin);});</p>
			<p>As you can see, we moved <strong class="source-inline">getPageUrl</strong> and <strong class="source-inline">regularUser</strong> to <strong class="source-inline">redmine-page.js</strong> as it is quite<a id="_idIndexMarker255"/> convenient to have all the utility functions concentrated in one file.</p>
			<p>Now, let's add the <strong class="source-inline">createNewProject</strong> function, which will contain all the actions to create a new project:</p>
			<p class="source-code">redminePage.createNewProject = async (textProjectName) =&gt; {    await t.click(redminePage.linkProjects)        .click(redminePage.iconAdd)        .typeText(redminePage.inputProjectName, textProjectName)        .click(redminePage.buttonCreate);};</p>
			<p>There is one more function to add, which will contain all the actions to create a new issue:</p>
			<p class="source-code">redminePage.createNewIssue = async (    linkTestProject, textIssueName, textIssueDescription     ) =&gt; {    await t.click(redminePage.linkProjects)        .click(linkTestProject)        .click(redminePage.linkNewIssue)        .typeText(redminePage.inputIssueSubject, textIssueName)        .typeText(redminePage.inputIssueDescription, textIssueDescription)        .click(redminePage.dropdownIssuePriority)        .click(Selector(redminePage.optionIssuePriority).withText(redminePage.textHigh))        .click(redminePage.buttonCreate);};</p>
			<p>And finally, add the function that <a id="_idIndexMarker256"/>contains all the actions to upload a file:</p>
			<p class="source-code">redminePage.uploadFile = async (linkTestProject) =&gt; {    await t.click(redminePage.linkProjects)        .click(linkTestProject)        .click(redminePage.linkFiles)        .click(redminePage.iconAdd)        .setFilesToUpload(redminePage.inputChooseFiles, redminePage.pathToFile)        .click(redminePage.buttonAdd);};module.exports = redminePage;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also review and download this file on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/redmine-page4.js">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/redmine-page4.js</a>.</p>
			<p>Now, the updated <strong class="source-inline">Create a new project</strong> test will look like this:</p>
			<p class="source-code">const { Selector } = require('testcafe');const redminePage = require('./redmine-page.js');// ...fixture('Redmine entities creation tests')    .page(redminePage.urlRedmine)    .beforeEach(async (t) =&gt; {        await t.useRole(redminePage.regularUser);    });test('Create a new project', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text1ProjectName);    await t.expect(Selector(redminePage.blockNotification).innerText).eql(redminePage.textSuccessfulCreation)        .expect(redminePage.getPageUrl()).contains(redminePage.urlProjectSettings);});</p>
			<p>As you probably noticed, now, only <strong class="source-inline">Selector</strong> is required from <strong class="source-inline">testcafe</strong>, as <strong class="source-inline">ClientFunction</strong>, <strong class="source-inline">Role</strong>, and <strong class="source-inline">t</strong> were moved to <strong class="source-inline">redmine-page.js</strong>. In addition, we are now using <strong class="source-inline">redminePage.regularUser</strong> instead of just <strong class="source-inline">regularUser </strong>- this is due to moving the <strong class="source-inline">regularUser</strong> function to <strong class="source-inline">redmine-page.js</strong>.</p>
			<p>The <a id="_idIndexMarker257"/>updated <strong class="source-inline">Create a new issue</strong> test will look like this:</p>
			<p class="source-code">test('Create a new issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text2ProjectName);    await redminePage.createNewIssue(        redminePage.link2TestProject,        redminePage.text2IssueName,        redminePage.text2IssueDescription     );    await t.expect(Selector(redminePage.blockNotification).innerText).contains(redminePage.textCreated);});</p>
			<p>The <strong class="source-inline">Verify that the issue is displayed on a project page</strong> test will also look shorter now, as we are using the <strong class="source-inline">createNewProject</strong> and <strong class="source-inline">createNewIssue</strong> functions inside it to create corresponding entities:</p>
			<p class="source-code">test('Verify that the issue is displayed on a project page', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text3ProjectName);    await redminePage.createNewIssue(        redminePage.link3TestProject,        redminePage.text3IssueName,        redminePage.text3IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link3TestProject)        .click(redminePage.linkIssues)        .expect(Selector(redminePage.linkIssueName).innerText).contains(redminePage.text3IssueName);});</p>
			<p>In the <strong class="source-inline">Upload a file</strong> test, we will utilize the <strong class="source-inline">createNewProject</strong> and <strong class="source-inline">uploadFile</strong> functions so that it will look <a id="_idIndexMarker258"/>more compact, too:</p>
			<p class="source-code">test('Upload a file', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text4ProjectName);    await redminePage.uploadFile(redminePage.link4TestProject);    await t.expect(Selector(redminePage.linkFileName).innerText).eql(redminePage.textFileName)        .expect(Selector(redminePage.blockDigest).innerText).eql(redminePage.textChecksum);});</p>
			<p>Here is how the updated <strong class="source-inline">Edit the issue</strong> test with the <strong class="source-inline">createNewProject</strong> and <strong class="source-inline">createNewIssue</strong> functions will appear:</p>
			<p class="source-code">// ...test('Edit the issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text5ProjectName);    await redminePage.createNewIssue(        redminePage.link5TestProject,        redminePage.text5IssueName,        redminePage.text5IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link5TestProject)        .click(redminePage.linkIssues)        .click(Selector(redminePage.linkIssueName).withText(redminePage.text5IssueName))        .click(redminePage.iconEdit)        .selectText(redminePage.inputIssueSubject)        .pressKey(redminePage.keyDelete)        .typeText(redminePage.inputIssueSubject, redminePage.text5IssueNameUpdated)        .click(redminePage.dropdownIssuePriority)        .click(Selector(redminePage.optionIssuePriority).withText(redminePage.textNormal))        .click(redminePage.buttonSubmit)        .expect(Selector(redminePage.blockNotification).innerText).eql(redminePage.textSuccessfulUpdate);});</p>
			<p>And the refactored <strong class="source-inline">Verify that the updated issue is displayed on a project page</strong> test with the <strong class="source-inline">createNewProject</strong> and <strong class="source-inline">createNewIssue</strong> functions will now<a id="_idIndexMarker259"/> look like this:</p>
			<p class="source-code">test('Verify that the updated issue is displayed on a project page', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text6ProjectName);    await redminePage.createNewIssue(        redminePage.link6TestProject,        redminePage.text6IssueName,        redminePage.text6IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link6TestProject)        .click(redminePage.linkIssues)        .click(Selector(redminePage.linkIssueName).  withText(redminePage.text6IssueName))        .click(redminePage.iconEdit)        .selectText(redminePage.inputIssueSubject)        .pressKey(redminePage.keyDelete)        .typeText(redminePage.inputIssueSubject, redminePage.text6IssueNameUpdated)        .click(redminePage.dropdownIssuePriority)        .click(Selector(redminePage.optionIssuePriority).withText(redminePage.textNormal))        .click(redminePage.buttonSubmit)        .click(redminePage.linkIssues)        .expect(Selector(redminePage.linkIssueName).innerText).eql(redminePage.text6IssueNameUpdated);});</p>
			<p>The <strong class="source-inline">Search for the issue</strong> test will also benefit from utilizing the <strong class="source-inline">createNewProject</strong> and <strong class="source-inline">createNewIssue</strong> functions as it will become significantly shorter:</p>
			<p class="source-code">test('Search for the issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text7ProjectName);    await redminePage.createNewIssue(        redminePage.link7TestProject,        redminePage.text7IssueName,        redminePage.text7IssueDescription     );    await t.navigateTo(redminePage.urlRedmineSearch)        .typeText(redminePage.inputSearch, redminePage.text7IssueName)        .click(redminePage.buttonSubmit)        .expect(Selector(redminePage.blockSearchResults).innerText).contains(redminePage.text7IssueName);});</p>
			<p>And finally, here is <a id="_idIndexMarker260"/>what the refactored <strong class="source-inline">Delete the issue</strong> and <strong class="source-inline">Delete the file</strong> tests will look like:</p>
			<p class="source-code">// ...test('Delete the issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text8ProjectName);    await redminePage.createNewIssue(        redminePage.link8TestProject,        redminePage.text8IssueName,        redminePage.text8IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link8TestProject)        .click(redminePage.linkIssues)        .click(Selector(redminePage.linkIssueName).withText(redminePage.text8IssueName))        .setNativeDialogHandler(() =&gt; true)        .click(redminePage.iconDelete)        .expect(Selector(redminePage.linkIssueName).withText(redminePage.text8IssueName).exists).notOk()        .expect(Selector(redminePage.blockNoData).innerText).eql(redminePage.textNoData);});test('Delete the file', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text9ProjectName);    await redminePage.uploadFile(redminePage.link9TestProject);    await t.click(redminePage.linkProjects)        .click(redminePage.link9TestProject)        .click(redminePage.linkFiles)        .setNativeDialogHandler(() =&gt; true)        .click(Selector(redminePage.linkFileName).withText(redminePage.textFileName).parent(redminePage.blockFile).find(redminePage.buttonAction).withAttribute('data-method', redminePage.dataMethodDelete))        .expect(Selector(redminePage.linkFileName).withText(redminePage.textFileName).exists).notOk()        .expect(Selector(redminePage.blockDigest).withText(redminePage.textChecksum).exists).notOk();});</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also review and download this file on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/basic-tests22.js">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/basic-tests22.js</a>.</p>
			<p>So, we have<a id="_idIndexMarker261"/> optimized our set of tests to be granular and utilize functions instead of repeated actions. Now, let's wrap up the test project with npm scripts.</p>
			<p>Wrapping up the test project with npm scripts</p>
			<p>As we have finished<a id="_idIndexMarker262"/> refactoring our tests, let's see how to run them more efficiently. As we recall from <a href="B16280_03_Final_JM_ePub.xhtml#_idTextAnchor043"><em class="italic">Chapter 3</em></a><em class="italic">, Setting Up the Environment</em>, where we initiated <strong class="source-inline">package.json</strong>, and <a href="B16280_04_Final_JM_ePub.xhtml#_idTextAnchor099"><em class="italic">Chapter 4</em></a><em class="italic">, Building a Test Suite with TestCafe</em>, where we added the <strong class="source-inline">js-automation-tools</strong> library, our basic <strong class="source-inline">package.json</strong> file currently looks like this:</p>
			<p class="source-code">{  "name": "test-project",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "js-automation-tools": "^1.0.5",    "testcafe": "^1.8.7"  }}</p>
			<p>We are currently running our tests<a id="_idIndexMarker263"/> by executing the following command:</p>
			<p class="source-code">$ npx testcafe chrome tests/basic-tests.js</p>
			<p>Or, as we discussed in <a href="B16280_05_Final_JM_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 5</em></a>, <em class="italic">Improving the Tests</em>, we utilize a double dash debug-on-fail flag to make our life easier while developing new tests (this will pause the test when it fails and will allow you to view the tested page and determine the cause of the fail):</p>
			<p class="source-code">$ npx testcafe chrome tests/basic-tests.js --debug-on-fail</p>
			<p>We can also use one additional flag:<strong class="source-inline">--speed</strong> (sets the rate of test execution) – to reduce the test execution speed for debugging:</p>
			<p class="source-code">$ npx testcafe chrome tests/basic-tests.js --debug-on-fail --speed 0.8</p>
			<p>It is starting to look quite long now, isn't it? To overcome this problem, we can use npm scripts. Let's create a <strong class="source-inline">test-debug</strong> alias inside <strong class="source-inline">package.json</strong> to launch tests with debugging flags:</p>
			<p class="source-code">{  "name": "test-project",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test-debug": "testcafe chrome tests/basic-tests.js --debug-on-fail --speed 0.8"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "js-automation-tools": "^1.0.5",    "testcafe": "^1.8.7"  }}</p>
			<p>So, now we can run our tests with<strong class="bold"> debugging flags</strong> by executing a <a id="_idIndexMarker264"/>short command with the alias that we just created:</p>
			<p class="source-code">$ npm run test-debug</p>
			<p>As we have discussed how to use npm scripts to add commands for local test debugging, let's now imagine that we will also <a id="_idIndexMarker265"/>need to run our tests on a <strong class="bold">continuous integration system</strong> (<strong class="bold">CI system</strong>). It would be <a id="_idIndexMarker266"/>good to rerun any failed test three times, just to be on the safe side and eliminate any possible flakiness. So, let's add a <strong class="source-inline">--quarantine-mode</strong> flag:</p>
			<p class="source-code">{  "name": "test-project",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test-ci": "testcafe chrome tests/basic-tests.js --quarantine-mode",    "test-debug": "testcafe chrome tests/basic-tests.js --debug-on-fail --speed 0.8"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "js-automation-tools": "^1.0.5",    "testcafe": "^1.8.7"  }}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also review and download this file on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/package.json">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/package.json</a>.</p>
			<p>So, now we can run our tests on CI by executing a short and simple command:</p>
			<p class="source-code">$ npm run test-ci</p>
			<p>To sum up, in this section, we discussed how to create short aliases for the local and remote (continuous integration) commands with npm scripts.</p>
			<p>Now, let's explore how to <a id="_idIndexMarker267"/>keep a finger on the pulse of TestCafe development and where to look for further improvements.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor143"/>Exploring TestCafe development and future plans</h1>
			<p>The birth of TestCafe can be<a id="_idIndexMarker268"/> traced back to early 2010, when developers from DevExpress started working on it. Initially, when released in 2013, it was a commercial testing framework. In 2016, it was decided to open source the core of TestCafe. Since then, there have been <a id="_idIndexMarker269"/>more than 760,000 downloads per month and the figures are still growing. DevExpress also released a commercial testing IDE called TestCafe Studio (<a href="https://www.devexpress.com/products/testcafestudio/">https://www.devexpress.com/products/testcafestudio/</a>), which was built on top of the open source <a id="_idIndexMarker270"/>TestCafe core. So, it looks like TestCafe is here to stay. DevExpress will keep developing it because this will add new features to TestCafe Studio.</p>
			<p>Let's recap some of the <a id="_idIndexMarker271"/>advantages of TestCafe:</p>
			<ul>
				<li>Open source.</li>
				<li>Easy and fast installation.</li>
				<li>Headless testing.</li>
				<li>Cross-platform and cross-browser out of the box.</li>
				<li>Supports one of the most popular programming languages for web development: JavaScript/TypeScript.</li>
				<li>A clear, flexible, and well-documented API.</li>
				<li>Smart assertion and automatic waiting mechanisms out of the box.</li>
				<li>Free custom plugins for browser providers, framework-specific selectors, custom reporters, Cucumber support, and so on.</li>
			</ul>
			<p>As for the future direction of development for TestCafe, according<a id="_idIndexMarker272"/> to the roadmap (<a href="https://devexpress.github.io/testcafe/roadmap/">https://devexpress.github.io/testcafe/roadmap/</a>), there is a plan to support API testing by adding methods for sending HTTP requests and checking the response details. In addition to this, the TestCafe team is actively working on multiple browser windows feature and a plan is afoot to<a id="_idIndexMarker273"/> improve the TestCafe debugging flow further.</p>
			<p>One more piece of advice that is definitely worth mentioning: keep an eye on TestCafe changelog (<a href="https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md">https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md</a>). It contains tons of useful information about new features and updates. This way, you will always know when a new version gets released, and what to expect from it.</p>
			<p>As we have reviewed the development of TestCafe and touched on its future plans, let's now explore some resources that can be of use in terms of further test automation with TestCafe.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor144"/>Additional references to useful resources</h1>
			<p>Here are some great <a id="_idIndexMarker274"/>sources of information on TestCafe:</p>
			<ul>
				<li><strong class="bold">TestCafe documentation</strong>: <a href="https://devexpress.github.io/testcafe/documentation/reference/">https://devexpress.github.io/testcafe/documentation/reference/</a>.</li>
				<li><strong class="bold">TestCafe changelog</strong>: <a href="https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md">https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md</a>.</li>
				<li><strong class="bold">TestCafe future roadmap</strong>: <a href="https://devexpress.github.io/testcafe/roadmap/">https://devexpress.github.io/testcafe/roadmap/</a> and <a href="https://github.com/DevExpress/testcafe/projects">https://github.com/DevExpress/testcafe/projects</a>.</li>
				<li><strong class="bold">TestCafe Team Blog</strong>: <a href="https://devexpress.github.io/testcafe/media/team-blog/">https://devexpress.github.io/testcafe/media/team-blog/</a>.</li>
				<li><strong class="bold">Stack Overflow filter for the most recent questions regarding TestCafe</strong>: <a href="https://stackoverflow.com/questions/tagged/testcafe">https://stackoverflow.com/questions/tagged/testcafe</a>.</li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor145"/>Summary</h1>
			<p>In this chapter, we explored how to optimize test actions with functions, and how to use npm scripts to run the tests. We also reviewed the development of the TestCafe framework, and some references to useful resources. These skills and lessons are intended to help you with any further test automation development by highlighting a number of ideas on how to refactor tests, how to run them more effectively, and where to look for further improvements.</p>
			<p>This wraps up our fruitful exploration of TestCafe, the rising star of test automation. I hope that you enjoyed it and will continue using this magnificent tool in your future projects!</p>
		</div>
	</body></html>