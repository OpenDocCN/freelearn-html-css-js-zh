<html><head></head><body>
		<div><h1 id="_idParaDest-81"><em class="italic"><a id="_idTextAnchor140"/>Chapter 7:</em> Findings from TestCafe</h1>
			<p>The main learning goal in this chapter is to optimize our test actions with functions and get familiar with how to use npm scripts to run the tests. We will also review the main direction of TestCafe framework development, along with some references to useful resources. </p>
			<p>This knowledge will give us some additional ideas on how to refactor tests, how to run them more efficiently, and where to search for further improvements.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Taking a final step with test functions.</li>
				<li>Wrapping up the test project with npm scripts.</li>
				<li>Exploring TestCafe development and future plans.</li>
				<li>Additional references to useful resources.</li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor141"/>Technical requirements</h1>
			<p>All code examples for this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor142"/>Taking a final step with test functions</h1>
			<p>The tests that we created consist of chains <a id="_idIndexMarker254"/>of actions. Some of them, such as the <code>Creating a new project</code> test, are still being repeated. So, one final logical step to take will be to separate such sequences of actions into the functions. Let's see how this can be achieved with the <code>createNewProject</code>, <code>createNewIssue</code>, and <code>uploadFile</code> functions inside <code>redmine-page.js</code>:</p>
			<pre>const { Selector, ClientFunction, Role, t } = require('testcafe');const { stamp } = require('js-automation-tools');// ...redminePage.getPageUrl = ClientFunction(() =&gt; {    return window.location.href;});redminePage.regularUser = Role(redminePage.urlRedmine, async (t) =&gt; {    await t.click(redminePage.linkLogin)        .typeText(redminePage.inputUsername, redminePage.emailRegularUser)        .typeText(redminePage.inputPassword, redminePage.         passwordRegularUser)        .click(redminePage.buttonLogin);});</pre>
			<p>As you can see, we moved <code>getPageUrl</code> and <code>regularUser</code> to <code>redmine-page.js</code> as it is quite<a id="_idIndexMarker255"/> convenient to have all the utility functions concentrated in one file.</p>
			<p>Now, let's add the <code>createNewProject</code> function, which will contain all the actions to create a new project:</p>
			<pre>redminePage.createNewProject = async (textProjectName) =&gt; {    await t.click(redminePage.linkProjects)        .click(redminePage.iconAdd)        .typeText(redminePage.inputProjectName, textProjectName)        .click(redminePage.buttonCreate);};</pre>
			<p>There is one more function to add, which will contain all the actions to create a new issue:</p>
			<pre>redminePage.createNewIssue = async (    linkTestProject, textIssueName, textIssueDescription     ) =&gt; {    await t.click(redminePage.linkProjects)        .click(linkTestProject)        .click(redminePage.linkNewIssue)        .typeText(redminePage.inputIssueSubject, textIssueName)        .typeText(redminePage.inputIssueDescription, textIssueDescription)        .click(redminePage.dropdownIssuePriority)        .click(Selector(redminePage.optionIssuePriority).withText(redminePage.textHigh))        .click(redminePage.buttonCreate);};</pre>
			<p>And finally, add the function that <a id="_idIndexMarker256"/>contains all the actions to upload a file:</p>
			<pre>redminePage.uploadFile = async (linkTestProject) =&gt; {    await t.click(redminePage.linkProjects)        .click(linkTestProject)        .click(redminePage.linkFiles)        .click(redminePage.iconAdd)        .setFilesToUpload(redminePage.inputChooseFiles, redminePage.pathToFile)        .click(redminePage.buttonAdd);};module.exports = redminePage;</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also review and download this file on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/redmine-page4.js">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/redmine-page4.js</a>.</p>
			<p>Now, the updated <code>Create a new project</code> test will look like this:</p>
			<pre>const { Selector } = require('testcafe');const redminePage = require('./redmine-page.js');// ...fixture('Redmine entities creation tests')    .page(redminePage.urlRedmine)    .beforeEach(async (t) =&gt; {        await t.useRole(redminePage.regularUser);    });test('Create a new project', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text1ProjectName);    await t.expect(Selector(redminePage.blockNotification).innerText).eql(redminePage.textSuccessfulCreation)        .expect(redminePage.getPageUrl()).contains(redminePage.urlProjectSettings);});</pre>
			<p>As you probably noticed, now, only <code>Selector</code> is required from <code>testcafe</code>, as <code>ClientFunction</code>, <code>Role</code>, and <code>t</code> were moved to <code>redmine-page.js</code>. In addition, we are now using <code>redminePage.regularUser</code> instead of just <code>regularUser </code>- this is due to moving the <code>regularUser</code> function to <code>redmine-page.js</code>.</p>
			<p>The <a id="_idIndexMarker257"/>updated <code>Create a new issue</code> test will look like this:</p>
			<pre>test('Create a new issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text2ProjectName);    await redminePage.createNewIssue(        redminePage.link2TestProject,        redminePage.text2IssueName,        redminePage.text2IssueDescription     );    await t.expect(Selector(redminePage.blockNotification).innerText).contains(redminePage.textCreated);});</pre>
			<p>The <code>Verify that the issue is displayed on a project page</code> test will also look shorter now, as we are using the <code>createNewProject</code> and <code>createNewIssue</code> functions inside it to create corresponding entities:</p>
			<pre>test('Verify that the issue is displayed on a project page', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text3ProjectName);    await redminePage.createNewIssue(        redminePage.link3TestProject,        redminePage.text3IssueName,        redminePage.text3IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link3TestProject)        .click(redminePage.linkIssues)        .expect(Selector(redminePage.linkIssueName).innerText).contains(redminePage.text3IssueName);});</pre>
			<p>In the <code>Upload a file</code> test, we will utilize the <code>createNewProject</code> and <code>uploadFile</code> functions so that it will look <a id="_idIndexMarker258"/>more compact, too:</p>
			<pre>test('Upload a file', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text4ProjectName);    await redminePage.uploadFile(redminePage.link4TestProject);    await t.expect(Selector(redminePage.linkFileName).innerText).eql(redminePage.textFileName)        .expect(Selector(redminePage.blockDigest).innerText).eql(redminePage.textChecksum);});</pre>
			<p>Here is how the updated <code>Edit the issue</code> test with the <code>createNewProject</code> and <code>createNewIssue</code> functions will appear:</p>
			<pre>// ...test('Edit the issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text5ProjectName);    await redminePage.createNewIssue(        redminePage.link5TestProject,        redminePage.text5IssueName,        redminePage.text5IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link5TestProject)        .click(redminePage.linkIssues)        .click(Selector(redminePage.linkIssueName).withText(redminePage.text5IssueName))        .click(redminePage.iconEdit)        .selectText(redminePage.inputIssueSubject)        .pressKey(redminePage.keyDelete)        .typeText(redminePage.inputIssueSubject, redminePage.text5IssueNameUpdated)        .click(redminePage.dropdownIssuePriority)        .click(Selector(redminePage.optionIssuePriority).withText(redminePage.textNormal))        .click(redminePage.buttonSubmit)        .expect(Selector(redminePage.blockNotification).innerText).eql(redminePage.textSuccessfulUpdate);});</pre>
			<p>And the refactored <code>Verify that the updated issue is displayed on a project page</code> test with the <code>createNewProject</code> and <code>createNewIssue</code> functions will now<a id="_idIndexMarker259"/> look like this:</p>
			<pre>test('Verify that the updated issue is displayed on a project page', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text6ProjectName);    await redminePage.createNewIssue(        redminePage.link6TestProject,        redminePage.text6IssueName,        redminePage.text6IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link6TestProject)        .click(redminePage.linkIssues)        .click(Selector(redminePage.linkIssueName).  withText(redminePage.text6IssueName))        .click(redminePage.iconEdit)        .selectText(redminePage.inputIssueSubject)        .pressKey(redminePage.keyDelete)        .typeText(redminePage.inputIssueSubject, redminePage.text6IssueNameUpdated)        .click(redminePage.dropdownIssuePriority)        .click(Selector(redminePage.optionIssuePriority).withText(redminePage.textNormal))        .click(redminePage.buttonSubmit)        .click(redminePage.linkIssues)        .expect(Selector(redminePage.linkIssueName).innerText).eql(redminePage.text6IssueNameUpdated);});</pre>
			<p>The <code>Search for the issue</code> test will also benefit from utilizing the <code>createNewProject</code> and <code>createNewIssue</code> functions as it will become significantly shorter:</p>
			<pre>test('Search for the issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text7ProjectName);    await redminePage.createNewIssue(        redminePage.link7TestProject,        redminePage.text7IssueName,        redminePage.text7IssueDescription     );    await t.navigateTo(redminePage.urlRedmineSearch)        .typeText(redminePage.inputSearch, redminePage.text7IssueName)        .click(redminePage.buttonSubmit)        .expect(Selector(redminePage.blockSearchResults).innerText).contains(redminePage.text7IssueName);});</pre>
			<p>And finally, here is <a id="_idIndexMarker260"/>what the refactored <code>Delete the issue</code> and <code>Delete the file</code> tests will look like:</p>
			<pre>// ...test('Delete the issue', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text8ProjectName);    await redminePage.createNewIssue(        redminePage.link8TestProject,        redminePage.text8IssueName,        redminePage.text8IssueDescription     );    await t.click(redminePage.linkProjects)        .click(redminePage.link8TestProject)        .click(redminePage.linkIssues)        .click(Selector(redminePage.linkIssueName).withText(redminePage.text8IssueName))        .setNativeDialogHandler(() =&gt; true)        .click(redminePage.iconDelete)        .expect(Selector(redminePage.linkIssueName).withText(redminePage.text8IssueName).exists).notOk()        .expect(Selector(redminePage.blockNoData).innerText).eql(redminePage.textNoData);});test('Delete the file', async (t) =&gt; {    await redminePage.createNewProject(redminePage.text9ProjectName);    await redminePage.uploadFile(redminePage.link9TestProject);    await t.click(redminePage.linkProjects)        .click(redminePage.link9TestProject)        .click(redminePage.linkFiles)        .setNativeDialogHandler(() =&gt; true)        .click(Selector(redminePage.linkFileName).withText(redminePage.textFileName).parent(redminePage.blockFile).find(redminePage.buttonAction).withAttribute('data-method', redminePage.dataMethodDelete))        .expect(Selector(redminePage.linkFileName).withText(redminePage.textFileName).exists).notOk()        .expect(Selector(redminePage.blockDigest).withText(redminePage.textChecksum).exists).notOk();});</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also review and download this file on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/basic-tests22.js">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/tests/basic-tests22.js</a>.</p>
			<p>So, we have<a id="_idIndexMarker261"/> optimized our set of tests to be granular and utilize functions instead of repeated actions. Now, let's wrap up the test project with npm scripts.</p>
			<p>Wrapping up the test project with npm scripts</p>
			<p>As we have finished<a id="_idIndexMarker262"/> refactoring our tests, let's see how to run them more efficiently. As we recall from <a href="B16280_03_Final_JM_ePub.xhtml#_idTextAnchor043"><em class="italic">Chapter 3</em></a><em class="italic">, Setting Up the Environment</em>, where we initiated <code>package.json</code>, and <a href="B16280_04_Final_JM_ePub.xhtml#_idTextAnchor099"><em class="italic">Chapter 4</em></a><em class="italic">, Building a Test Suite with TestCafe</em>, where we added the <code>js-automation-tools</code> library, our basic <code>package.json</code> file currently looks like this:</p>
			<pre>{  "name": "test-project",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "js-automation-tools": "^1.0.5",    "testcafe": "^1.8.7"  }}</pre>
			<p>We are currently running our tests<a id="_idIndexMarker263"/> by executing the following command:</p>
			<pre>$ npx testcafe chrome tests/basic-tests.js</pre>
			<p>Or, as we discussed in <a href="B16280_05_Final_JM_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 5</em></a>, <em class="italic">Improving the Tests</em>, we utilize a double dash debug-on-fail flag to make our life easier while developing new tests (this will pause the test when it fails and will allow you to view the tested page and determine the cause of the fail):</p>
			<pre>$ npx testcafe chrome tests/basic-tests.js --debug-on-fail</pre>
			<p>We can also use one additional flag:<code>--speed</code> (sets the rate of test execution) – to reduce the test execution speed for debugging:</p>
			<pre>$ npx testcafe chrome tests/basic-tests.js --debug-on-fail --speed 0.8</pre>
			<p>It is starting to look quite long now, isn't it? To overcome this problem, we can use npm scripts. Let's create a <code>test-debug</code> alias inside <code>package.json</code> to launch tests with debugging flags:</p>
			<pre>{  "name": "test-project",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test-debug": "testcafe chrome tests/basic-tests.js --debug-on-fail --speed 0.8"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "js-automation-tools": "^1.0.5",    "testcafe": "^1.8.7"  }}</pre>
			<p>So, now we can run our tests with<strong class="bold"> debugging flags</strong> by executing a <a id="_idIndexMarker264"/>short command with the alias that we just created:</p>
			<pre>$ npm run test-debug</pre>
			<p>As we have discussed how to use npm scripts to add commands for local test debugging, let's now imagine that we will also <a id="_idIndexMarker265"/>need to run our tests on a <code>--quarantine-mode</code> flag:</p>
			<pre>{  "name": "test-project",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test-ci": "testcafe chrome tests/basic-tests.js --quarantine-mode",    "test-debug": "testcafe chrome tests/basic-tests.js --debug-on-fail --speed 0.8"  },  "keywords": [],  "author": "",  "license": "ISC",  "devDependencies": {    "js-automation-tools": "^1.0.5",    "testcafe": "^1.8.7"  }}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also review and download this file on GitHub: <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/package.json">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch7/test-project/package.json</a>.</p>
			<p>So, now we can run our tests on CI by executing a short and simple command:</p>
			<pre>$ npm run test-ci</pre>
			<p>To sum up, in this section, we discussed how to create short aliases for the local and remote (continuous integration) commands with npm scripts.</p>
			<p>Now, let's explore how to <a id="_idIndexMarker267"/>keep a finger on the pulse of TestCafe development and where to look for further improvements.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor143"/>Exploring TestCafe development and future plans</h1>
			<p>The birth of TestCafe can be<a id="_idIndexMarker268"/> traced back to early 2010, when developers from DevExpress started working on it. Initially, when released in 2013, it was a commercial testing framework. In 2016, it was decided to open source the core of TestCafe. Since then, there have been <a id="_idIndexMarker269"/>more than 760,000 downloads per month and the figures are still growing. DevExpress also released a commercial testing IDE called TestCafe Studio (<a href="https://www.devexpress.com/products/testcafestudio/">https://www.devexpress.com/products/testcafestudio/</a>), which was built on top of the open source <a id="_idIndexMarker270"/>TestCafe core. So, it looks like TestCafe is here to stay. DevExpress will keep developing it because this will add new features to TestCafe Studio.</p>
			<p>Let's recap some of the <a id="_idIndexMarker271"/>advantages of TestCafe:</p>
			<ul>
				<li>Open source.</li>
				<li>Easy and fast installation.</li>
				<li>Headless testing.</li>
				<li>Cross-platform and cross-browser out of the box.</li>
				<li>Supports one of the most popular programming languages for web development: JavaScript/TypeScript.</li>
				<li>A clear, flexible, and well-documented API.</li>
				<li>Smart assertion and automatic waiting mechanisms out of the box.</li>
				<li>Free custom plugins for browser providers, framework-specific selectors, custom reporters, Cucumber support, and so on.</li>
			</ul>
			<p>As for the future direction of development for TestCafe, according<a id="_idIndexMarker272"/> to the roadmap (<a href="https://devexpress.github.io/testcafe/roadmap/">https://devexpress.github.io/testcafe/roadmap/</a>), there is a plan to support API testing by adding methods for sending HTTP requests and checking the response details. In addition to this, the TestCafe team is actively working on multiple browser windows feature and a plan is afoot to<a id="_idIndexMarker273"/> improve the TestCafe debugging flow further.</p>
			<p>One more piece of advice that is definitely worth mentioning: keep an eye on TestCafe changelog (<a href="https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md">https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md</a>). It contains tons of useful information about new features and updates. This way, you will always know when a new version gets released, and what to expect from it.</p>
			<p>As we have reviewed the development of TestCafe and touched on its future plans, let's now explore some resources that can be of use in terms of further test automation with TestCafe.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor144"/>Additional references to useful resources</h1>
			<p>Here are some great <a id="_idIndexMarker274"/>sources of information on TestCafe:</p>
			<ul>
				<li><strong class="bold">TestCafe documentation</strong>: <a href="https://devexpress.github.io/testcafe/documentation/reference/">https://devexpress.github.io/testcafe/documentation/reference/</a>.</li>
				<li><strong class="bold">TestCafe changelog</strong>: <a href="https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md">https://github.com/DevExpress/testcafe/blob/master/CHANGELOG.md</a>.</li>
				<li><strong class="bold">TestCafe future roadmap</strong>: <a href="https://devexpress.github.io/testcafe/roadmap/">https://devexpress.github.io/testcafe/roadmap/</a> and <a href="https://github.com/DevExpress/testcafe/projects">https://github.com/DevExpress/testcafe/projects</a>.</li>
				<li><strong class="bold">TestCafe Team Blog</strong>: <a href="https://devexpress.github.io/testcafe/media/team-blog/">https://devexpress.github.io/testcafe/media/team-blog/</a>.</li>
				<li><strong class="bold">Stack Overflow filter for the most recent questions regarding TestCafe</strong>: <a href="https://stackoverflow.com/questions/tagged/testcafe">https://stackoverflow.com/questions/tagged/testcafe</a>.</li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor145"/>Summary</h1>
			<p>In this chapter, we explored how to optimize test actions with functions, and how to use npm scripts to run the tests. We also reviewed the development of the TestCafe framework, and some references to useful resources. These skills and lessons are intended to help you with any further test automation development by highlighting a number of ideas on how to refactor tests, how to run them more effectively, and where to look for further improvements.</p>
			<p>This wraps up our fruitful exploration of TestCafe, the rising star of test automation. I hope that you enjoyed it and will continue using this magnificent tool in your future projects!</p>
		</div>
	</body></html>