- en: Chapter 5. Divide and Conquer – Modularizing Everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After explaining in detail in [Chapter 4](ch04.html "Chapter 4. Managing Views"),
    *Managing Views*, how to implement regions in `Marionette.js` to manage your views,
    it is time to understand how to deal with complex JavaScript projects and learn
    how to create a framework that would be extensible in subapplications and should
    require minimal effort to scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains the main topics that we will cover in this chapter
    and that we should consider while building modular and scalable single-page apps
    using `Marionette.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subapplications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the divide and conquer principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complexity is the enemy of software, and building complex JavaScript applications
    can easily get out of hand. There are multiple ways to deal with complexity, but
    the most effective method is by using the principle of divide and conquer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Directly through its module definition, `Marionette.js` allows us to split
    our code into smaller and more single responsibility blocks. If we do not break
    our code into smaller pieces, we will slow down development and make our application
    difficult to maintain. The easiest starting point to structure the code is the
    `Marionette.Application`. The application''s primary responsibility is to start
    and stop subapplications and, if necessary, mediate cross subapplication communication.
    The following image shows how we can start from the application object to modularize
    our solution in subapplications and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the divide and conquer principle](img/4252OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the **Single-page application** (**SPA**) example that we are building,
    we probably will not need a lot of subapplications right from the beginning. But
    it is really important to know how to use this powerful feature that helps to
    break up an app into smaller and single responsibility units. The subapplication
    modules are independent parts of our app and they can consist of routers, controllers,
    models, layouts, and views.
  prefs: []
  type: TYPE_NORMAL
- en: All modules can be loaded on demand, so they do not need to be created from
    the beginning. For example, we can start them when the subapplication route matches
    specific patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing single-page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a base architecture for single-page apps is not trivial. SPAs are
    opposite to traditional web apps that often have full-page reloads. They are dynamic
    page applications running in one page and usually, require spending some time
    on designing foundations. They are designed more like desktop apps since we store
    the application state in the client, but managing it quickly becomes a problem.
    As we have learned from the divide and conquer principle, a problem can be divided
    in several parts, so that each part can be handled independently. Having said
    that, let's explore how we can implement an application that will load single
    responsibility subapplications on demand, each of them has the ability to stop
    and start modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | "Beauty of style and harmony and grace and good rhythm depends on simplicity."
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | -- Plato |'
  prefs: []
  type: TYPE_TB
- en: By understanding the concept of divide and conquer, we should agree that the
    modularization of code is tremendously important. Modules are small, simple, and
    well-encapsulated packages that have a singular focus with well-defined functions;
    they can be used in conjunction with other modules to create an entire system.
    In `Marionette.js`, a module provides a high-level piece of functionality and
    manages objects that really provide implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a module with no functionality to continue with the examples
    from the book store, where we will create the module that will contain the cart
    and order history subapplications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The modules of `Marionette.js` are loaded and defined after the `app.start()`
    call and they are fully instantiated objects. As you can see, Marionette''s modules
    hang from our application. Let''s now define a real-world module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an explanation of the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Books`: This is the main application object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HistoryApp`: This is the name module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startWithParent`: This should be false if we wish to manually start a module
    instead of having the application start it. We have to tell the module definition
    not to start with the parent, and that is exactly our scenario since we do not
    want to start all the subapplications from the beginning. This concept will be
    explained in detail when we get into the *Working with* *subapplications* section
    of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An explanation of the function arguments is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App`: This is the application central object that manage the module life cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Backbone`: This is the reference to the `Backbone` library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette`: This is the reference to the `Backbone.Marionette` library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: This is the reference to the DOM library, jQuery in this case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_`: This is a reference to underscore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the arguments explained, you can pass custom arguments to this
    function definition. Now we have a very simple module ready to encapsulate some
    of the functionality required.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting modules into multiple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a module is so long for a single file that we want to split the definition
    across multiple files. But it is pretty common for the subapplication modules
    to contain controllers, routers, and views, among others, so we do not want to
    put them all together in a file. This is made really simple by `Marionette.js`
    modules, so let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example code from a controller file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An example code from a router file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have created two files, one for the controller and other for the router,
    both of them are contained in the same module HistoryApp but located in separated
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing initializers and finalizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules have initializers and finalizers similar to application objects. Initializers
    are run when the module is started and finalizers are run when a module is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an initializer and a finalizer to our existing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how we can create definitions inside a module. We added a
    controller in this case, without actually creating any objects—just the definition—and
    then we let the initializer start creating the objects and set them up when the
    module is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Working with subapplications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our book's sample app is a single application that can contains several smaller
    applications, for example, shopping cart and order history. Each of them are independent
    but managed by the same application and are able to interact with other modules
    if necessary. The next diagram describes the concept of two subapplications being
    managed by a central application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with subapplications](img/4252OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each subapplication is usually related with a screen from the SPA. They are
    responsible for doing what is required for screen changes using a controller that
    starts and stops modules and deals with their communication. They also manage
    the layout manipulating regions to display or hide views. Take a look at the code
    related to the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore how to define two subapplications, each of them is also located
    in different file as we just learned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our first application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our second application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These applications are managed by the central application (`App`) that is passed
    as a parameter. Both the modules contain a controller definition as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code snippet demonstrates how the main application is capable of starting
    and stopping subapplications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the main application is defined in a self-invoking function.
    It runs automatically/immediately when we create it, and note that calling the
    function returns the main `App` object.
  prefs: []
  type: TYPE_NORMAL
- en: The function `startSubApp` is what provides the ability to start and stop a
    module. This function will be called probably when the user clicks on the button
    to open the history or when a user navigates directly to this specific route.
    The next step is to understand how to call this function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the route filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have understood how to divide the application into subapplications; however,
    we still need to decide when and how we will tell the main application that we
    need to start a specific subapplication. To accomplish that, each module should
    be associated with a specific router that needs to be active from the beginning.
    This is different from modules that can be lazy loaded when a route matches. The
    creator of `Marionette.js` solves this scenario perfectly with his `BBCloneMail`
    example app that we mentioned before. For that purpose, he included a library
    called `routefilter.js`. As with any other library, this library is installed
    by adding the path reference in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Route filter can be found at [https://github.com/boazsender/backbone.routefilter](https://github.com/boazsender/backbone.routefilter).
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when we use SPA composed by subapplications, just one subapp is active
    at the same time, and our example application is not the exception. It is important
    to mention this in order to understand the next code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for the `cart` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, each subapplication generally has a router associated
    with it. This router will be the point of entrance for that application and will
    be responsible to lazy load it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain what the pieces of the code means. Here, `before` is a function
    that is defined with the magic of `routefilter.js`. This function is executed
    before any function that maps the particular route. What it means is that the
    router will know when we are trying to access the specific subapplication and
    will start it by calling the function that we visited before, which is located
    at the main application (`App.startSubApp('CartApp')`). Other pieces that we are
    already familiar with are the module initializer and the route definition.
  prefs: []
  type: TYPE_NORMAL
- en: So, what if we want to start the history application now? Easy, just create
    a router associated with that subapplication, define that router, and we are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code puts this concept into practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Memory considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major challenges in single-page applications is to eliminate the
    memory leaks. The main problem is that we never do full-page reloads to flush
    the memory. So, applications need to handle closing subapplications when a new
    one is put in place to simulate a page load, thus unbinding all the events and
    objects associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: But, we can still mess up the memory with zombies if we do not clean up references
    correctly. So like the main application, all subapplications should close old
    views and this is where Marionette's Region comes in to play. This especially
    ensures the unbinding of all the events when an object is disposed or when we
    switch viewsin a region.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of subapplications, there are multiple ways to clean up the memory.
    To illustrate this, let's revisit some lines of code from the *Working with subapplications*
    section. This function is designed to stop and start subapplications as needed.
    We are using this technique to have just one subapplication running at the same
    time; once a subapplication is stopped, all its objects and events are disposed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our example, if the application was stopped, the router provides the functionality
    to call this function to start the subapplication again, if required. The next
    code is from the *Using the route filter* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As an important note, we need to develop discipline to remember that every time
    we create objects, we should be writing the proper code to remove them, always
    taking advantage of the `Marionette.js` capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By far, the main problem that we have in creating a software is complexity.
    An easy starting point for a model view structure is provided by `Backbone.js`,
    but it offers mainly low-level patterns. In the case of a more complex application,
    we can take advantage of some other frameworks to provide the missing parts on
    top of `Backbone.js`. For each part of your system, find a way to solve it and
    combine the solutions of the parts to obtain the solution of the original problem.
    Always strive for readability and maintainability when you implement your modules,
    and try to encapsulate behavior and not just state code with no reason.
  prefs: []
  type: TYPE_NORMAL
- en: Modules address the larger scale needs for encapsulation, while controllers,
    views, routers, and regions address the more detailed aspects of the matter.
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer is a principle that has been used for years and is one of
    the most useful concepts when dealing with large and complex system structures.
    Keep up with all the best practices that we have learned and try to make them
    an integral part of your applications. The next step is to learn about messaging
    with `Marionette.js`.
  prefs: []
  type: TYPE_NORMAL
