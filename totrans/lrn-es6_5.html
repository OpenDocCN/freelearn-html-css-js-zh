<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Implementing the Reflect API</h1></div></div></div><p>ES6 introduced a new API, the <strong>Reflect API</strong><a id="id291" class="indexterm"/> for the object reflection (that is, inspecting and manipulating the properties of objects). Although ES5 already had APIs for the object reflection, these APIs were not well organized and on failure, they used to throw exception. The ES6 Reflect API is well organized and makes it easier to read and write code, as it doesn't throw exceptions on failure. Instead, it returns the Boolean value, representing if the operation was true or false. Since developers are adapting to the Reflect API for the object reflection, it's important to learn this API in depth.</p><p>In this chapter, we'll cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calling a function with a given <code class="literal">this</code> value</li><li class="listitem" style="list-style-type: disc">Invoking a constructor with the <code class="literal">prototype</code> property of another constructor</li><li class="listitem" style="list-style-type: disc">Defining or modifying the attributes of the object properties</li><li class="listitem" style="list-style-type: disc">Enumerating over the properties of an object using an iterator object</li><li class="listitem" style="list-style-type: disc">Retrieving and setting the internal <code class="literal">[[prototype]]</code> property of an object</li><li class="listitem" style="list-style-type: disc">And a lot of other operations related to inspecting and manipulating methods and properties of objects.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>The Reflect object</h1></div></div></div><p>The ES6 global <code class="literal">Reflect</code> object<a id="id292" class="indexterm"/> exposes all the new methods for the object reflection. <code class="literal">Reflect</code> is not a function object therefore, you cannot invoke the <code class="literal">Reflect</code> object. Also, you cannot use it with the <code class="literal">new</code> operator.</p><p>All the methods of the ES6 Reflect API are wrapped in the <code class="literal">Reflect</code> object to make it look well organized.</p><p>The <code class="literal">Reflect</code> object provides many methods, which overlaps the global <code class="literal">Object</code> object's methods in terms of functionality.</p><p>Let's see the various methods provided by the <code class="literal">Reflect</code> object for object reflection.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>The Reflect.apply(function, this, args) method</h2></div></div></div><p>The <code class="literal">Reflect.apply()</code> method is<a id="id293" class="indexterm"/> used to invoke a <a id="id294" class="indexterm"/>function with a given <code class="literal">this</code> value. The function invoked by <code class="literal">Reflect.apply()</code> is called as the target function. It's same as the <code class="literal">apply()</code> method of the function object.</p><p>The <code class="literal">Reflect.apply()</code> method takes three arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first argument represents the target function.</li><li class="listitem" style="list-style-type: disc">The second argument represents the value of this inside the target function. This argument is optional.</li><li class="listitem" style="list-style-type: disc">The third argument is an array object, specifying the arguments of the target function. This argument is optional.</li></ul></div><p>The <code class="literal">Reflect.apply()</code> method returns whatever the target function returns.</p><p>Here is code example to demonstrate how to use the <code class="literal">Reflect.apply()</code> method:</p><div><pre class="programlisting">function function_name(a, b, c)
{
  return this.value + a + b + c;
}

var returned_value = Reflect.apply(function_name, {value: 100}, [10, 20, 30]);

console.log(returned_value); //Output "160"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>The Reflect.construct(constructor, args, prototype) method</h2></div></div></div><p>The <code class="literal">Reflect.construct()</code> method is<a id="id295" class="indexterm"/> used to <a id="id296" class="indexterm"/>invoke a function as a constructor. It's similar to the <code class="literal">new</code> operator. The <a id="id297" class="indexterm"/>function that will be invoked as a constructor is called as the <strong>target constructor</strong>.</p><p>One special reason why you may want to use the <code class="literal">Reflect.construct()</code> method instead of <code class="literal">new</code> operator is when you want the target the constructor's <code class="literal">prototype</code> to match the <code class="literal">prototype</code> an another constructor.</p><p>The <code class="literal">Reflect.construct()</code> method takes three arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first argument is the target constructor.</li><li class="listitem" style="list-style-type: disc">The second argument is an array, specifying the arguments of the target constructor. This argument is optional.</li><li class="listitem" style="list-style-type: disc">The third argument is another constructor whose <code class="literal">prototype</code> will be used as the <code class="literal">prototype</code> of the target constructor. This argument is optional.</li></ul></div><p>The <code class="literal">Reflect.construct()</code> method returns the new instance created by the target constructor.</p><p>Here is the code example, to <a id="id298" class="indexterm"/>demonstrate <a id="id299" class="indexterm"/>how to use the <code class="literal">Reflect.constructor()</code> method:</p><div><pre class="programlisting">function constructor1(a, b)
{
  this.a = a;
  this.b = b;

  this.f = function(){
    return this.a + this.b + this.c;
  }
}

function constructor2(){}
constructor2.prototype.c = 100;

var myObject = Reflect.construct(constructor1, [1,2], constructor2);

console.log(myObject.f()); //Output "103"</pre></div><p>In the preceding example, we used the <code class="literal">prototype</code> of <code class="literal">consturctor2</code> as the <code class="literal">prototype</code> of <code class="literal">constructor1</code> while invoking <code class="literal">constructor1</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec82"/>The Reflect.defineProperty(object, property, descriptor) method</h2></div></div></div><p>The <code class="literal">Reflect.defineProperty()</code> method defines a new property directly on an object, or modifies an<a id="id300" class="indexterm"/> existing property on an object. It<a id="id301" class="indexterm"/> returns a Boolean value indicating whether the operation was successful or not.</p><p>It's similar to the <code class="literal">Object.defineProperty()</code> method. The difference is that the <code class="literal">Reflect.defineProperty()</code> method returns a Boolean, whereas the <code class="literal">Object.defineProperty()</code> returns the modified object. If the <code class="literal">Object.defineProperty()</code> method fails to modify or define an object property, then it throws exception, whereas the <code class="literal">Reflect.defineProperty()</code> method returns <code class="literal">false</code> result.</p><p>The <code class="literal">Reflect.defineProperty()</code> method takes in three arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first argument is the object that is used to define or modify a property</li><li class="listitem" style="list-style-type: disc">The second argument is the symbol or name of the property that is to be defined or modified</li><li class="listitem" style="list-style-type: disc">The <a id="id302" class="indexterm"/>third <a id="id303" class="indexterm"/>argument is the descriptor for the property that being defined or modified</li></ul></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Understanding the data properties and accessor properties</h3></div></div></div><p>Since ES5, every object property is either a data property or an accessor property. A data property has a value, which may or may not be writable, whereas an accessor property has getter-setter pair of functions to set and retrieve the property value.</p><p>The attributes of a data property are value, writable, enumerable, and configurable. On the other hand, the attributes of an accessor property are <code class="literal">set</code>, <code class="literal">get</code>, <code class="literal">enumerable</code>, and <code class="literal">configurable</code>.</p><p>A <strong>descriptor</strong> is an object that describes the attributes of a property. When creating a property using the <code class="literal">Reflect.defineProperty()</code> method, the <code class="literal">Object.defineProperty()</code> method, the <code class="literal">Object.defineProperties()</code> method, or the <code class="literal">Object.create()</code> method, we need to pass a descriptor for the property.</p><p>A data property's descriptor object has the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Value</strong>: This is the value<a id="id304" class="indexterm"/> associated with the property. The default value is <code class="literal">undefined</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Writable</strong>: If this<a id="id305" class="indexterm"/> is <code class="literal">true</code>, then the property value can be changed with an assignment operator. The default value is <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Configurable</strong>: If<a id="id306" class="indexterm"/> this is <code class="literal">true</code>, then the property attributes can be changed, and the property may be deleted. The default value is <code class="literal">false</code>. Remember that when the configurable attribute is <code class="literal">false</code> and writable is <code class="literal">true</code>, the value and the writable attributes can be changed.</li><li class="listitem" style="list-style-type: disc"><strong>Enumerable</strong>: If <a id="id307" class="indexterm"/>this is <code class="literal">true</code>, then the property shows up in the <code class="literal">for…in</code> loop and the <code class="literal">Object.keys()</code> method. The default value is <code class="literal">false</code>.</li></ul></div><p>An accessor property's descriptor has the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Get</strong>: This is a <a id="id308" class="indexterm"/>function that returns the property value. The function has no parameters and default value is undefined.</li><li class="listitem" style="list-style-type: disc"><strong>Set</strong>: This is a <a id="id309" class="indexterm"/>function that sets the property value. The function will receive the new value that is being assigned to the property.</li><li class="listitem" style="list-style-type: disc"><strong>Configurable</strong>: If this<a id="id310" class="indexterm"/> is <code class="literal">true</code>, then the property descriptor can be changed and the property may be deleted. The default value is <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><strong>enumerable</strong>: If this is <a id="id311" class="indexterm"/>true, then the property shows up in <code class="literal">for…in</code> loop and the <code class="literal">Object.keys()</code> method. The default value is <code class="literal">false</code>.</li></ul></div><p>Depending on the properties of the descriptor object, JavaScript decides whether the property is a data property or an accessor property.</p><p>If you add a property without using the <code class="literal">Reflect.defineProperty()</code> method, the <code class="literal">Object.defineProperty()</code> method, the <code class="literal">Object.defineProperties()</code> method, or the <code class="literal">Object.create()</code> method, then the property is a data property and the <code class="literal">writable</code>, <code class="literal">enumerable</code>, and the <code class="literal">configurable</code> attributes are all set to <code class="literal">true</code>. After the property is added, you can modify its attributes.</p><p>If an object already has a property with the specified name while calling the <code class="literal">Reflect.defineProperty()</code> method, the <code class="literal">Object.defineProperty()</code> method or the <code class="literal">Object.defineProperties()</code> method, then the property is modified. The attributes that are not specified in the descriptor remain the same.</p><p>You can change a data property to an accessor property, and vice-versa. If you do this, the <code class="literal">configurable</code> and the <code class="literal">enumerable</code> attributes that are not specified in the descriptor will be preserved in the property. Other attributes that are not specified in the descriptor are set to their default values.</p><p>Here is an example code that demonstrates how to create a data property using the <code class="literal">Reflect.defineProperty()</code> method:</p><div><pre class="programlisting">var obj = {}

Reflect.defineProperty(obj, "name", {
  value: "Eden",
  writable: true,
  configurable: true,
  enumerable: true
});

console.log(obj.name); //Output "Eden"</pre></div><p>Here is another example code that demonstrates how to create a accessor property using the <code class="literal">Reflect.defineProperty()</code> method:</p><div><pre class="programlisting">var obj = {
  __name__: "Eden"
}

Reflect.defineProperty(obj, "name", {
  get: function(){
    return this.__name__;
  },
  set: function(newName){
    this.__name__ = newName;
  },
  configurable: true,
  enumerable: true
});

obj.name = "John";
console.log(obj.name);      //Output "John"</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec83"/>The Reflect.deleteProperty(object, property) method</h2></div></div></div><p>The <code class="literal">Reflect.deleteProperty()</code> method is used to delete a property of an object. It's the same as the <code class="literal">delete</code> operator.</p><p>This method takes <a id="id312" class="indexterm"/>two arguments, that is, the <a id="id313" class="indexterm"/>first argument is the reference to the object and the second argument is the name of the property to delete. The <code class="literal">Reflect.deleteProperty()</code> method returns <code class="literal">true</code> if it has deleted the property successfully. Otherwise, it returns <code class="literal">false</code>.</p><p>Here is code example that demonstrates how to delete a property using the <code class="literal">Reflect.deleteProperty()</code> method:</p><div><pre class="programlisting">var obj = {
  name: "Eden"
}

console.log(obj.name);      //Output "Eden"

Reflect.deleteProperty(obj, "name");

console.log(obj.name);      //Output "undefined"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec84"/>The Reflect.enumerate(object) method</h2></div></div></div><p>The <code class="literal">Reflect.enumerate()</code> method<a id="id314" class="indexterm"/> takes an object as argument and <a id="id315" class="indexterm"/>returns an iterator object that represents the enumerable properties of the object. It also returns the enumerable inherited properties of an object.</p><p>The <code class="literal">Reflect.enumerate()</code> method is similar to the <code class="literal">for…in</code> loop. The <code class="literal">Reflect.enumerate()</code> method returns an iterator, whereas the <code class="literal">for…in</code> loop iterates over enumerable properties.</p><p>Here is an example to demonstrate how to use the <code class="literal">Reflect.enumerate()</code> method:</p><div><pre class="programlisting">var obj = {
  a: 1,
  b: 2,
  c: 3
};

var iterator = Reflect.enumerate(obj);

console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().done);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">a
b
c
true</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec85"/>The Reflect.get(object, property, this) method</h2></div></div></div><p>The <code class="literal">Reflect.get()</code> method is used <a id="id316" class="indexterm"/>to retrieve the <a id="id317" class="indexterm"/>value of an object's property. The first argument is the object and the second argument is the property name. If the property is an accessor property, then we can provide a third argument which will be the value of <code class="literal">this</code> inside the <code class="literal">get</code> function.</p><p>Here is code example that demonstrates how to use the <code class="literal">Reflect.get()</code> method:</p><div><pre class="programlisting">var obj = {
  __name__: "Eden"
};

Reflect.defineProperty(obj, "name", {
  get: function(){
    return this.__name__;
  }
});

console.log(obj.name);      //Output "Eden"

var name = Reflect.get(obj, "name", {__name__: "John"});

console.log(name);      //Output "John"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec86"/>The Reflect.set(object, property, value, this) method</h2></div></div></div><p>The <code class="literal">Reflect.set()</code> method is used to set<a id="id318" class="indexterm"/> the value of an object's <a id="id319" class="indexterm"/>property. The first argument is the object, the second argument is the property name, and the third argument is the property value. If the property is an accessor property, then we can provide a fourth argument which will be the value of <code class="literal">this</code> inside the <code class="literal">set</code> function.</p><p>The <code class="literal">Reflect.set()</code> method returns <code class="literal">true</code> if the property value was set successfully. Otherwise, it returns <code class="literal">false</code>.</p><p>Here is code example that demonstrates how to use the <code class="literal">Reflect.set()</code> method:</p><div><pre class="programlisting">var obj1 = {
  __name__: "Eden"
};

Reflect.defineProperty(obj1, "name", {
  set: function(newName){
    this.__name__ = newName;
  },

  get: function(){
    return this.__name__;
  }
});

var obj2 = {
  __name__: "John"
};

Reflect.set(obj1, "name", "Eden", obj2);

console.log(obj1.name); //Output "Eden"
console.log(obj2.__name__); //Output "Eden"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec87"/>The Reflect.getOwnPropertyDescriptor(object, property) method</h2></div></div></div><p>The <code class="literal">Reflect.getOwnPropertyDescriptor()</code> method is<a id="id320" class="indexterm"/> used to retrieve the descriptor of an object's <a id="id321" class="indexterm"/>property.</p><p>The <code class="literal">Reflect.getOwnPropertyDescriptor()</code> method is same as the <code class="literal">Object.getOwnPropertyDescriptor()</code> method. The <code class="literal">Reflect.getOwnPropertyDescriptor()</code> method takes two arguments. The first argument is the object and the second argument is the property name.</p><p>Here is an example to demonstrate the <code class="literal">Reflect.getOwnPropertyDescriptor()</code> method:</p><div><pre class="programlisting">var obj = {
  name: "Eden"
};

var descriptor = Reflect.getOwnPropertyDescriptor(obj, "name");

console.log(descriptor.value);
console.log(descriptor.writable);
console.log(descriptor.enumerable);
console.log(descriptor.configurable);</pre></div><p>The output is as the following:</p><div><pre class="programlisting">Eden
true
true
true</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec88"/>The Reflect.getPrototypeOf(object) method</h2></div></div></div><p>The <code class="literal">Reflect.getPrototypeOf()</code> method<a id="id322" class="indexterm"/> is used to retrieve <a id="id323" class="indexterm"/>prototype of an object that is, the value of the internal <code class="literal">[[prototype]]</code> property of an object.</p><p>The <code class="literal">Reflect.getPrototypeOf()</code> method is same as the <code class="literal">Object.getPrototypeOf()</code> method.</p><p>Here is the<a id="id324" class="indexterm"/> code example that demonstrates how to<a id="id325" class="indexterm"/> use the <code class="literal">Reflect.getPrototypeOf()</code> method:</p><div><pre class="programlisting">var obj1 = {
  __proto__: {
    name: "Eden"
  }
};

var obj2 = Reflect.getPrototypeOf(obj1);

console.log(obj2.name); //Output "Eden"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec89"/>The Reflect.setPrototypeOf(object, prototype) method</h2></div></div></div><p>The <code class="literal">Reflect.setPrototypeOf()</code> is used to <a id="id326" class="indexterm"/>set the<a id="id327" class="indexterm"/> internal <code class="literal">[[prototype]]</code> property's value of an object. The <code class="literal">Reflect.setPrototypeOf()</code> method will return <code class="literal">true</code> if the internal <code class="literal">[[prototype]]</code> property's value was set successfully. Otherwise, it will return <code class="literal">false</code>.</p><p>Here is a code example, which demonstrates how to use it:</p><div><pre class="programlisting">var obj = {};

Reflect.setPrototypeOf(obj, {
  name: "Eden"
});

console.log(obj.name); //Output "Eden"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>The Reflect.has(object, property) method</h2></div></div></div><p>The <code class="literal">Reflect.has()</code> is used to<a id="id328" class="indexterm"/> check if a property exists in an<a id="id329" class="indexterm"/> object. It also checks for the inherited properties. It returns <code class="literal">true</code> if the property exists. Otherwise it'd return as <code class="literal">false</code>.</p><p>It's same as the <code class="literal">in</code> operator.</p><p>Here is code example that demonstrates how to use the <code class="literal">Reflect.has()</code> method:</p><div><pre class="programlisting">var obj = {
  __proto__: {
    name: "Eden"
  },
  age: 12
};

console.log(Reflect.has(obj, "name")); //Output "true"
console.log(Reflect.has(obj, "age")); //Output "true"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>The Reflect.isExtensible(object) method</h2></div></div></div><p>The <code class="literal">Reflect.isExtensible()</code> method<a id="id330" class="indexterm"/> is used to check if an object is <a id="id331" class="indexterm"/>extensible or not, that is, if we can add new properties to an object.</p><p>An object can be marked as non-extensible using the <code class="literal">Object.preventExtensions()</code>, <code class="literal">Object.freeze()</code> and the <code class="literal">Object.seal()</code> methods.</p><p>The <code class="literal">Reflect.isExtensible()</code> method is same as the <code class="literal">Object.isExtensible()</code> method.</p><p>Here is code example, which demonstrates how to use the <code class="literal">Reflect.isExtensible()</code> method:</p><div><pre class="programlisting">var obj = {
  name: "Eden"
};

console.log(Reflect.isExtensible(obj)); //Output "true"

Object.preventExtensions(obj);

console.log(Reflect.isExtensible(obj)); //Output "false"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec92"/>The Reflect.preventExtensions(object) method</h2></div></div></div><p>The <code class="literal">Reflect.preventExtensions()</code> is used <a id="id332" class="indexterm"/>to mark an object as <a id="id333" class="indexterm"/>non-extensible. It returns a Boolean, indicating whether the operation was successful or not.</p><p>It's same as the <code class="literal">Object.preventExtensions()</code> method:</p><div><pre class="programlisting">var obj = {
  name: "Eden"
};

console.log(Reflect.isExtensible(obj)); //Output "true"

console.log(Reflect.preventExtensions(obj)); //Output "true"

console.log(Reflect.isExtensible(obj)); //Output "false"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec93"/>The Reflect.ownKeys(object) method</h2></div></div></div><p>The <code class="literal">Reflect.ownKeys()</code> method returns an <a id="id334" class="indexterm"/>array whose <a id="id335" class="indexterm"/>values represent the keys of the properties of an provided object. It ignores the inherited properties.</p><p>Here is the example code to demonstrate this method:</p><div><pre class="programlisting">var obj = {
  a: 1,
  b: 2,
  __proto__: {
    c: 3
  }
};

var keys = Reflect.ownKeys(obj);

console.log(keys.length); //Output "2"
console.log(keys[0]); //Output "a"
console.log(keys[1]); //Output "b"</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we learned what the object reflection is, and how to use the ES6 Reflect API for the object reflection. We saw various methods of the <code class="literal">Reflect</code> object with examples. Overall, this chapter introduced the ES6 Reflect API to inspect and manipulate the properties of objects.</p><p>In the next chapter, we will learn about the ES6 proxies and their uses.</p></div></body></html>