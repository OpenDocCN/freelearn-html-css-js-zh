<html><head></head><body>
		<div id="_idContainer040">
			<h1 id="_idParaDest-129" class="chapter-number"><a id="_idTextAnchor128"/>7</h1>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Transforming Functions – Currying and Partial Application</h1>
			<p>In <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, we saw several ways of manipulating functions to get new versions with some changes in their functionality. In this chapter, we will go into a particular kind of transformation, a sort of <strong class="bold">factory method</strong> that lets you produce new versions of any <span class="No-Break">given function.</span></p>
			<p>We will be considering <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Currying</strong>: A classic FP theoretical function<a id="_idIndexMarker519"/> that transforms a function with many parameters into a sequence of <span class="No-Break">unary functions</span></li>
				<li><strong class="bold">Partial application</strong>: Another time-honored FP transformation, which<a id="_idIndexMarker520"/> produces new versions of functions by fixing some of <span class="No-Break">their arguments</span></li>
				<li><strong class="bold">Partial currying</strong> (a name of my own): Can be seen as a mixture<a id="_idIndexMarker521"/> of the two <span class="No-Break">previous transformations</span></li>
			</ul>
			<p>The techniques in this chapter will provide you with a different way of producing functions from other functions. To be fair, we’ll also see that some of these techniques can be emulated, possibly with greater clarity, by simple arrow functions. However, since you are liable to find currying and partial application in all sorts of texts and web pages on FP, it is important that you know their meaning and usage, even if you opt for a simpler way out. We’ll look at several applications of the ideas in the <span class="No-Break">following sections.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>A bit of theory</h1>
			<p>The concepts we’ll discuss in this chapter are in some ways very similar, and in other ways quite different. It’s common to find confusion about their real meanings, and plenty of web pages misuse terms. You could even say that all the transformations in this chapter are roughly equivalent since they let you transform a function into another one that fixes some parameters, leaving other parameters free, and eventually leading to the same result. Okay, I agree; this isn’t very clear! So, let’s start by clearing the air and providing some short definitions, which we will expand on later. (If you feel your eyes are glazing over, please skip this section and return to it later!) Yes, you may find the following descriptions a bit perplexing, but bear with us—we’ll go into more detail in just <span class="No-Break">a bit:</span></p>
			<ul>
				<li><em class="italic">Currying</em> is transforming an <em class="italic">m</em>-ary function (that is, a function of arity <em class="italic">m</em>) into<a id="_idIndexMarker522"/> a sequence of <em class="italic">m</em> unary functions, each receiving one argument of the original function, from left to right. (The first function receives the first argument of the original function and returns a second function, which receives the second argument and returns a third function, which receives the third argument, and so on.) Upon being called with an argument, each function produces the next one in the sequence, and the last one does the <span class="No-Break">actual calculations.</span></li>
				<li><em class="italic">Partial application</em> is providing <em class="italic">n</em> arguments<a id="_idIndexMarker523"/> to an <em class="italic">m</em>-ary function, with <em class="italic">n</em> less than or equal to <em class="italic">m</em>, to transform it into a function with (<em class="italic">m</em>-<em class="italic">n</em>) parameters. Each time you provide some arguments, a new function is produced, with smaller arity. When you provide the last arguments, the actual calculations <span class="No-Break">are performed.</span></li>
				<li><em class="italic">Partial currying</em> is a mixture of both preceding<a id="_idIndexMarker524"/> ideas: you provide <em class="italic">n</em> arguments (from left to right) to an <em class="italic">m</em>-ary function and produce a new function of arity (<em class="italic">m-n</em>). When this new function receives some other arguments, also from left to right, it will produce yet another function. When the last parameters are provided, the function produces the <span class="No-Break">correct calculations.</span></li>
			</ul>
			<p>In this chapter, we will see these three transformations, what they require, and ways of <span class="No-Break">implementing them.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Currying</h1>
			<p>We already mentioned <em class="italic">currying</em> back<a id="_idIndexMarker525"/> in the <em class="italic">Arrow functions</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Becoming Functional,</em> and in the <em class="italic">One argument or many?</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, but let’s be more thorough here. Currying is a technique that enables you to only work with single-variable functions, even if you need a <span class="No-Break">multi-variable one.</span></p>
			<p class="callout-heading">Currying by any other name?</p>
			<p class="callout">The idea of converting a multi-variable function into a series of single-variable functions (or, more rigorously, reducing operators with several operands to a sequence of applications of a single operand operator) was worked on by Moses Schönfinkel. Some authors suggest, not necessarily tongue-in-cheek, that currying would be more correctly <span class="No-Break">named </span><span class="No-Break"><em class="italic">Schönfinkeling</em></span><span class="No-Break">!</span></p>
			<p>In the following sections, we will first see how to deal with functions with many parameters, and then move on to how to curry by hand or by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bind()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Dealing with many parameters</h2>
			<p>The idea of currying, by itself, is<a id="_idIndexMarker526"/> simple. If you need<a id="_idIndexMarker527"/> a function with, say, three parameters, you could write something like the following by using <span class="No-Break">arrow functions:</span></p>
			<pre class="source-code">
// curryByHand.ts
const make3 = (a: string, b: number, c: string): string =&gt;
  `${a}:${b}:${c}`;</pre>
			<p>Alternatively, you can have a sequence of functions, each with a single parameter, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
// continued...
const make3curried =
  (a: string) =&gt; (b: number) =&gt; (c: string) =&gt;
    `${a}:${b}:${c}`;</pre>
			<p>Alternatively, you might want to consider them as nested functions, like the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
// continued...
const make3curried2 = function (a: string) {
  return function (b: number) {
    return function (c: string) {
      return `${a}:${b}:${c}`;
    };
  };
};</pre>
			<p>In terms of usage, there’s an essential<a id="_idIndexMarker528"/> difference in how you’d use<a id="_idIndexMarker529"/> each function. While you would call the first in the usual fashion, such as <strong class="source-inline">make3("A",2,"Z")</strong>, that wouldn’t work with the second definition. Let’s work out why: <strong class="source-inline">make3curried()</strong> is a unary (single parameter), so we should write <strong class="source-inline">make3curried("A")</strong>. But what does this return? According to the preceding definition, this also returns a unary function—and that function also returns a unary function! So, the correct call to get the same result as with the ternary function would be <strong class="source-inline">make3curried("A")(2)("Z")</strong>! See <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_7.1_B19301.jpg" alt="Figure 7.1 – The diﬀerence between a common function and a curried equivalent"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The diﬀerence between a common function and a curried equivalent</p>
			<p>Study this carefully—we have the first function, and when we apply an argument to it, we get a second function. Applying an argument to it produces a third function, and a final application produces the desired result. This can be seen as a needless exercise in theoretical computing, but it actually brings some advantages because you can then always work with unary functions, even if you need functions with <span class="No-Break">more parameters.</span></p>
			<p class="callout-heading">Currying versus uncurrying</p>
			<p class="callout">Since there is a currying<a id="_idIndexMarker530"/> transformation, there<a id="_idIndexMarker531"/> is also an uncurrying one! In our case, we would write <strong class="source-inline">make3uncurried = (a, b, c) =&gt; make3curried(a)(b)(c)</strong> to reverse the currying process and make it usable once again, to provide all parameters in <span class="No-Break">one sitting.</span></p>
			<p>In some languages, such as Haskell, functions are only allowed to take a single parameter—but then again, the language’s syntax allows you to invoke functions as if multiple parameters were permitted. For our example, in Haskell, writing <strong class="source-inline">make3curried "A" 2 "Z"</strong> would have produced <strong class="source-inline">"A:2:Z"</strong> without anybody even needing to be aware that it involved three function calls, each with one of our arguments. Since you don’t write parentheses around parameters and don’t separate them with commas, you cannot tell that you are not providing a triplet of values instead of three <span class="No-Break">singular ones.</span></p>
			<p>Currying is basic in Scala<a id="_idIndexMarker532"/> or Haskell, which are fully functional<a id="_idIndexMarker533"/> languages, but JavaScript has enough features to allow us to define and use currying in our work. It won’t be as easy since, after all, it’s not built-in—but we’ll be able <span class="No-Break">to manage.</span></p>
			<p>So, to review the basic concepts, the key differences between our original <strong class="source-inline">make3()</strong> and <strong class="source-inline">make3curried()</strong> functions are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">make3()</strong> is a ternary function, but <strong class="source-inline">make3curried()</strong> <span class="No-Break">is unary</span></li>
				<li><strong class="source-inline">make3()</strong> returns a string; <strong class="source-inline">make3curried()</strong> returns another function—which itself returns a second function, which returns yet a third function, which finally does return <span class="No-Break">a string</span></li>
				<li>You can produce a string by writing something like <strong class="source-inline">make3("A",2,"Z")</strong>, which returns <strong class="source-inline">"A:2:Z"</strong>, but you’ll have to write <strong class="source-inline">make3curried("A")(2)("Z")</strong> to get the <span class="No-Break">same result</span></li>
			</ul>
			<p>Why would you go<a id="_idIndexMarker534"/> to all this bother? Let’s look at a simple<a id="_idIndexMarker535"/> example, and further on, we will look at more examples. Suppose you had a function that calculated the value-added tax (VAT) for an amount, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
// continued...
const addVAT = (rate: number, amount: number): number =&gt;
  amount * (1 + rate / 100);
addVAT(20, 500); // 600 -- that is, 500 + 20%
addVAT(15, 200); // 230 -- 200 +15%</pre>
			<p>If you had to apply a single, constant rate, you could curry the <strong class="source-inline">addVAT()</strong> function to produce a more specialized version that always applied your given rate. For example, if your national rate was 6%, you could then have something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const addVATcurried =
  (rate: number) =&gt;
  (amount: number): number =&gt;
    amount * (1 + rate / 100);
const addNationalVAT = <strong class="bold">addVATcurried(6)</strong>;
addNationalVAT(1500); // 1590 -- 1500 + 6%</pre>
			<p>The first line defines a curried version of our VAT-calculating function. Given a tax rate, <strong class="source-inline">addVATcurried()</strong> returns a new function, which, when given an amount of money, finally adds the original tax rate to it. So, if the national tax rate were 6%,  <strong class="source-inline">addNationalVAT()</strong> would be a function that added 6% to any amount given to it. For example, if we were to calculate <strong class="source-inline">addNationalVAT(1500)</strong>, as in the preceding code, the result would be <strong class="source-inline">1590</strong>: $1,500, plus <span class="No-Break">6% tax.</span></p>
			<p>Of course, you are justified in saying that this currying thing is a bit too much just to add a 6% tax, but the simplification is what counts. Let’s look at one more example. In your application, you may want to include some logging with a function such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
function myLog(severity: string, logText?: string) {
  // display logText in an appropriate way,
  // according to its severity
  // ("NORMAL", "WARNING", or "ERROR")
}</pre>
			<p>However, with this approach, every time you wanted to display a normal log message, you would write <strong class="source-inline">myLog("NORMAL", "some normal text")</strong>, and for warnings, you’d write <strong class="source-inline">myLog("WARNING", "some warning text")</strong>. You could simplify this a bit with currying, by fixing the first parameter of <strong class="source-inline">myLog()</strong> as follows, with a <strong class="source-inline">curry()</strong> function that we’ll look at later. Our code could then be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">myLog = curry(myLog)</strong>;
const myNormalLog = <strong class="bold">myLog("NORMAL")</strong>;
const myWarningLog = myLog("WARNING");
const myErrorLog = myLog("ERROR");</pre>
			<p>What do you gain? Now, you can write <strong class="source-inline">myNormalLog("some normal text")</strong> or <strong class="source-inline">myWarningLog("some warning text")</strong> because you have curried <strong class="source-inline">myLog()</strong> and then fixed its argument, making for simpler, <span class="No-Break">easier-to-read code!</span></p>
			<p>By the way, if you prefer, you could have also achieved the same result in a single step, with the original uncurried <strong class="source-inline">myLog()</strong> function, by currying it case <span class="No-Break">by case:</span></p>
			<pre class="source-code">
// continued...
const myNormalLog2 = <strong class="bold">curry(myLog)("NORMAL")</strong>;
const myWarningLog2 = curry(myLog)("WARNING");
const myErrorLog2 = curry(myLog)("ERROR");</pre>
			<p>So, having a <strong class="source-inline">curry()</strong> function lets you fix<a id="_idIndexMarker536"/> some arguments while leaving<a id="_idIndexMarker537"/> others still open; let’s see how to do this in three <span class="No-Break">different ways.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Currying by hand</h2>
			<p>Before trying more complex things, we<a id="_idIndexMarker538"/> could curry a function by hand, without any special auxiliary functions or anything else. And, in fact, if we want to implement currying for a particular case, there’s no need to do anything complex because we can manage with simple arrow functions. We saw that with both <strong class="source-inline">make3curried()</strong> and <strong class="source-inline">addVATcurried()</strong>, so there’s no need to revisit <span class="No-Break">that idea.</span></p>
			<p>Instead, let’s look into some ways of doing that automatically, so we can produce an equivalent curried version of any function, even without knowing its arity beforehand. Going further, we should code a more intelligent version of a function that could work differently depending on the number of received arguments. For example, we could have a <strong class="source-inline">sum(x,y)</strong> function that behaved as in the <span class="No-Break">following examples:</span></p>
			<pre class="source-code">
<strong class="bold">sum(3, 5)</strong>; // 8; did you expect otherwise?
const add3 = sum(3);
<strong class="bold">add3(5)</strong>;   // 8
<strong class="bold">sum(3)(5)</strong>; // 8</pre>
			<p>We can achieve that behavior by hand. Our function would be something like the following – and since we won’t be using this style, let’s stay with plain JavaScript, with <span class="No-Break">no typing:</span></p>
			<pre class="source-code">
// continued...
const sum = (x, y) =&gt; {
  if (x !== undefined &amp;&amp; y !== undefined) {
    return x + y;
  } else if (x !== undefined &amp;&amp; y == undefined) {
    return (z) =&gt; sum(x, z);
  } else {  // x,y both undefined
    return sum;
  }
};</pre>
			<p>Let’s recap what we did here. Our curried-by-hand function has <span class="No-Break">this behavior:</span></p>
			<ul>
				<li>If we call it with two arguments, it adds them and returns the sum; this provides our first use case, as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">sum(3,5)===8</strong></span><span class="No-Break">.</span></li>
				<li>If only one argument is provided, it returns a new function. This new function expects a single argument and will return the sum of that argument and the original one: this behavior is what we expected in the other two use cases, such as <strong class="source-inline">add2(3)===5</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">sum(2)(7)===9</strong></span><span class="No-Break">.</span></li>
				<li>Finally, if no arguments are provided, it returns itself. This means that we would be able to write <strong class="source-inline">sum()(1)(2)</strong> if we desired. (No, I cannot think of a reason for wanting to <span class="No-Break">write that.)</span></li>
			</ul>
			<p>So, we can incorporate currying<a id="_idIndexMarker539"/> in the definition itself of a function. However, you’ll have to agree that dealing with all the special cases in each function could quickly become troublesome and error-prone. So, let’s work out some generic ways of accomplishing the same result without any <span class="No-Break">particular coding.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Currying with bind()</h2>
			<p>We can find<a id="_idIndexMarker540"/> a solution to currying by using the <strong class="source-inline">bind()</strong> method, which we have already applied<a id="_idIndexMarker541"/> in several places in this book. This allows us to fix one argument (or more, if need be; we won’t need to do that here, but later on we will use it) and provide a function with that fixed argument. Of course, many libraries (such as Lodash, Underscore, Ramda, and others) provide this functionality, but we want to see how to implement <span class="No-Break">that ourselves.</span></p>
			<h3>A plain JavaScript version</h3>
			<p>Our implementation is relatively<a id="_idIndexMarker542"/> short but will require some explanation. First, let’s see a JavaScript version and deal with <span class="No-Break">TypeScript later:</span></p>
			<pre class="source-code">
// curry.js
function curry(fn) {
  return fn.length === 0
    ? fn()
    : (x) =&gt; curryByBind(fn.bind(null, x));
}</pre>
			<p>Start by noticing that <strong class="source-inline">curryByBind()</strong> always returns a new function, which depends on the <strong class="source-inline">fn</strong> function given as its parameter. If the function has no (more) parameters left (when <strong class="source-inline">fn.length===0</strong>) because all parameters have already been bound, we can evaluate it by using <strong class="source-inline">fn()</strong>. Otherwise, the result of currying<a id="_idIndexMarker543"/> the function will be a new function that receives a single argument and produces a newly curried function with another fixed argument. Let’s see this in action, with a detailed example, using the <strong class="source-inline">make3()</strong> function we saw at the beginning of this chapter <span class="No-Break">once again:</span></p>
			<pre class="source-code">
// continued...
const make3 = (a, b, c) =&gt; `${a}:${b}:${c}`;
// f1 is the curried version of make3
const f1 = curry(<strong class="bold">make3</strong>);
// f2 is a function that will fix make3's 1st parameter
const f2 = <strong class="bold">f1("A")</strong>;
// f3 is a function that will fix make3's 2nd parameter
const f3 = <strong class="bold">f2(2)</strong>;
// "A2Z" will be now calculated, since we are providing
// the 3rd (last) make3's parameter
const f4 = <strong class="bold">f3("Z")</strong>;
console.log(f4);</pre>
			<p>The explanation of this code is <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The first function, <strong class="source-inline">f1()</strong>, has yet to receive any arguments. When called with an argument, it will produce a curried version of <strong class="source-inline">make3()</strong>, with its first <span class="No-Break">argument fixed.</span></li>
				<li>Calling <strong class="source-inline">f1("A")</strong> produces a new unary function, <strong class="source-inline">f2()</strong>, which will itself produce a curried version of <strong class="source-inline">make3()</strong>—but with its first argument set to <strong class="source-inline">"A"</strong>, so actually, the new function will end up fixing the second parameter <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">make3()</strong></span><span class="No-Break">.</span></li>
				<li>Similarly, calling <strong class="source-inline">f2(2)</strong> produces a third unary function, <strong class="source-inline">f3()</strong>, which will produce a version of <strong class="source-inline">make3()</strong>, but fixing its third argument, since the first two have already <span class="No-Break">been fixed.</span></li>
				<li>Finally, when we calculate <strong class="source-inline">f3("Z")</strong>, this fixes the last parameter of <strong class="source-inline">make3()</strong> to <strong class="source-inline">"Z"</strong>, and since there are no more arguments left, the thrice-bound <strong class="source-inline">make3()</strong> function is called and the <strong class="source-inline">"A:2:Z"</strong> result <span class="No-Break">is produced.</span></li>
			</ul>
			<p>You can do other call sequences as well, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const f2b = <strong class="bold">f1("TEA")(4)</strong>;
const f3b = <strong class="bold">f2b("TWO")</strong>;
// "TEA:4:TWO"
const f1c = f1("IN")(10)("TION");
// "IN":10:"TION"</pre>
			<p>To curry the function by hand, you could use JavaScript’s <strong class="source-inline">.bind()</strong> method. The sequence would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued…
const step1 = make3<strong class="bold">.bind(null, "A")</strong>;
const step2 = step1<strong class="bold">.bind(null, 2)</strong>;
const step3 = step2<strong class="bold">.bind(null, "Z")</strong>;
console.log(step3()); // "A:2:Z"</pre>
			<p>In each step, we provide an additional parameter. (The <strong class="source-inline">null</strong> value is required, to provide context. If it were a method attached to an object, we would provide that object as the first parameter to <strong class="source-inline">.bind()</strong>. Since that’s not the case, <strong class="source-inline">null</strong> is expected.) This is equivalent<a id="_idIndexMarker544"/> to what our code does, except that the last time, <strong class="source-inline">curryByBind()</strong> does the actual calculation instead of making you do it, as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">step3()</strong></span><span class="No-Break">.</span></p>
			<h3>A TypeScript version</h3>
			<p>Now that have implemented this in JavaScript, let’s see how to define types for currying. We have to work recursively<a id="_idIndexMarker545"/> and consider <span class="No-Break">two cases:</span></p>
			<ul>
				<li>If we curry a function with just one parameter, the function will directly produce the <span class="No-Break">desired result</span></li>
				<li>If we curry a function with two or more parameters, we’ll create a unary function (with the first parameter) that will return a (curried!) function that will deal with the rest of <span class="No-Break">the parameters:</span></li>
			</ul>
			<pre class="source-code">
// curry.ts
type Curry&lt;P, R&gt; = P extends [infer H]
  ? (arg: H) =&gt; R // only 1 arg
  : P extends [infer H, ...infer T] // 2 or more args
  ? (arg: H) =&gt; Curry&lt;[...T], R&gt;
  : never;</pre>
			<p>We will have a generic type with two inputs: <strong class="source-inline">P</strong>, representing the parameters of the function to process, and <strong class="source-inline">R</strong>, standing for the result type of that function. If <strong class="source-inline">P</strong> has just one type, <strong class="source-inline">H</strong>, we return a function that, given an argument of the <strong class="source-inline">H</strong> type, returns a result of the <strong class="source-inline">R</strong> type. If <strong class="source-inline">P</strong> is formed by a first <strong class="source-inline">H</strong> type (“head”) and some other <strong class="source-inline">T</strong> types (“tail”), we return a function that will return a (curried) function with <strong class="source-inline">T</strong> types <span class="No-Break">as arguments.</span></p>
			<p>Using this type has an added complexity. TypeScript cannot verify that our <strong class="source-inline">curryByBind()</strong> function works correctly because it cannot deduce that, for every function, we’ll eventually produce a result instead of yet another curried function. There’s a tricky solution involving an overloaded function with just <em class="italic">one</em> signature. The key is that the implementation is checked more loosely, and you can use <strong class="source-inline">any</strong> types to get by. Of course, working like this isn’t precisely type-safe; it’s up to you to ensure that the function is type-correct because you are essentially bypassing TypeScript’s checks. We’ll have to do this kind of trick more than once in <span class="No-Break">this chapter:</span></p>
			<pre class="source-code">
// continued…
<strong class="bold">function curry&lt;A extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...args: A) =&gt; R</strong>
<strong class="bold">): Curry&lt;A, R&gt;;</strong>
function curry(fn: (...args: any) =&gt; any) {
  return fn.length === 0
    ? fn()
    : (x: any) =&gt; curry(fn.bind(null, x));
}</pre>
			<p>Let’s go back to our <strong class="source-inline">make3()</strong> example. Types work out <span class="No-Break">perfectly well:</span></p>
			<pre class="source-code">
const f1 = curry(make3);
// <strong class="bold">(arg: string) =&gt; (arg: number) =&gt; (arg: string) =&gt; string</strong>
const f2 = f1("A");
// <strong class="bold">(arg: number) =&gt; (arg: string) =&gt; string</strong>
const f3 = f2(2);
// <strong class="bold">(arg: string) =&gt; string</strong>
const f4 = f3("Z");
// <strong class="bold">string</strong></pre>
			<p>The type of <strong class="source-inline">f1</strong> is key; it shows that our recursive typing<a id="_idIndexMarker546"/> worked as expected. The types of <strong class="source-inline">f2</strong> and <strong class="source-inline">f3</strong> are shorter, and the type of <strong class="source-inline">f4</strong> is the type of the final <span class="No-Break">result, </span><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break">.</span></p>
			<h3>Currying tests</h3>
			<p>Testing this transformation<a id="_idIndexMarker547"/> is rather simple because there are not many possible ways <span class="No-Break">of currying:</span></p>
			<pre class="source-code">
// curry.test.js
describe("with curry", function () {
  it("you fix arguments one by one", () =&gt; {
    const make3a = curry(make3);
    const make3b = make3a("A")(2);
    const make3c = make3b("Z");
    expect(make3c).toBe(make3("A", 2, "Z"));
  });
});</pre>
			<p>What else could you test? Maybe functions with just one parameter could be added, but there are no more <span class="No-Break">to try.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Partial application</h1>
			<p>The second transformation<a id="_idIndexMarker548"/> we will be considering lets you fix some of the function’s parameters, creating a new function that will receive the rest of them. Let’s make this clear with a nonsense example. Imagine you have a function with five parameters. You might want to fix the second and fifth parameters, and partial application would produce a new version of the function that fixed those two parameters but left the other three open for new calls. If you called the resulting function with the three required arguments, it would produce the correct answer by using the original two fixed parameters plus the newly <span class="No-Break">provided three.</span></p>
			<p class="callout-heading">Projecting parameters</p>
			<p class="callout">The idea of specifying only some parameters in function application, producing a function<a id="_idIndexMarker549"/> of the remaining parameters, is called <strong class="bold">projection</strong>: you are said to be projecting the function onto the remaining arguments. We will not use this term, but I wanted to cite it in case you find <span class="No-Break">it elsewhere.</span></p>
			<p>Let’s consider an example using the <strong class="source-inline">fetch()</strong> API, widely considered the modern way to go for Ajax calls. You might want to fetch several resources, always specifying the same parameters for the call (for example, request headers) and only changing the URL to search. By using partial application, you could create a new <strong class="source-inline">myFetch()</strong> function that would always provide <span class="No-Break">fixed parameters.</span></p>
			<p class="callout-heading">On fetching</p>
			<p class="callout">You can read more on <strong class="source-inline">fetch()</strong> at <a href="http://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch</a>. According to <a href="http://caniuse.com/#search=fetch">caniuse.com/#search=fetch</a>, you can use it in most browsers except for (oh, surprise!) Internet Explorer, but you can get around this limitation with a polyfill, such as the one found <span class="No-Break">at </span><a href="http://github.com/github/fetch"><span class="No-Break">github.com/github/fetch</span></a><span class="No-Break">.</span></p>
			<p>Let’s assume we have a <strong class="source-inline">partial()</strong> function that implements this kind of application and let’s see how we’d use that to produce our new, specialized version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">fetch()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const myFetch = <strong class="bold">partial(fetch, undefined, myParameters)</strong>;
// undefined means the first argument for fetch
// is not yet defined; the second argument for
// fetch() is set to myParameters
myFetch("a/first/url")
  .then(/* do something */)
  .catch(/* on error */);
myFetch("a/second/url")
  .then(/* do something else */)
  .catch(/* on error */);</pre>
			<p>Currying would have worked if the request parameters had been the first argument for <strong class="source-inline">fetch()</strong>. (We’ll have more to say about the order of parameters later.) With partial application, you can replace any arguments, no matter which, so in this case, <strong class="source-inline">myFetch()</strong> ends up as a unary function. This new function will get data from any URL you wish, always passing<a id="_idIndexMarker550"/> the same set of parameters for the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> operation.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Partial application with arrow functions</h2>
			<p>Trying to do partial application<a id="_idIndexMarker551"/> by hand, as we did with<a id="_idIndexMarker552"/> currying, is too complicated. For instance, for a function with 5 parameters, you would have to write code allowing the user to provide any of the 32 possible combinations of fixed and unfixed parameters – 32 being equal to 2 raised to the fifth power. Even if you could simplify the problem, it would still remain hard to write and maintain. See <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em> for one of many <span class="No-Break">possible combinations:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_7.2_B19301.jpg" alt="Figure 7.2 – Partial application may let you ﬁrst provide some parameters, and then provide the rest, to ﬁnally get the result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Partial application may let you ﬁrst provide some parameters, and then provide the rest, to ﬁnally get the result</p>
			<p>Doing partial application with arrow functions, however, is much simpler. With the example we mentioned previously, we would have something like the following code. In this case, we will assume we want to fix the second parameter to <strong class="source-inline">22</strong> and the fifth parameter <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1960</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const nonsense = (a, b, c, d, e) =&gt;
  `${a}/${b}/${c}/${d}/${e}`;
const fix2and5 = (a, c, d) =&gt; nonsense(a, 22, c, d, 1960);</pre>
			<p>Doing partial application this way is quite simple, though we may want to find a more general solution. You can set any number of parameters, by creating a new function out of the previous one but fixing some more parameters. (Wrappers, as in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, could be used.) For instance, you might now want to also fix the last parameter of the new <strong class="source-inline">fix2and5()</strong> function to <strong class="source-inline">9</strong>, as shown in the following code; there’s <span class="No-Break">nothing easier:</span></p>
			<pre class="source-code">
const fixLast = (a, c) =&gt; fix2and5(a, c, 9);</pre>
			<p>You might also have written <strong class="source-inline">nonsense(a, 22, c, 9, 1960)</strong> if you wished to, but the fact remains<a id="_idIndexMarker553"/> that fixing parameters by using arrow functions<a id="_idIndexMarker554"/> is simple. Let’s now consider, as we said, a more <span class="No-Break">general solution.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Partial application with closures</h2>
			<p>If we want to be able to do partial application<a id="_idIndexMarker555"/> fixing of any combination of parameters, we must have a way to specify which arguments are to be left free and which will be fixed from that point on. Some libraries, such as Underscore and Lodash, use a special <strong class="source-inline">_</strong>  object to signify an omitted parameter. In this fashion, still using the same <strong class="source-inline">nonsense()</strong> function, we would write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const fix2and5 = _.partial(nonsense)(_, 22, _, _, 1960);</pre>
			<p>We could do the same sort of thing by having a global variable that would represent a pending, not yet fixed argument, but let’s make it simpler and just use <strong class="source-inline">undefined</strong> to represent a <span class="No-Break">missing parameter.</span></p>
			<p class="callout-heading">Careful comparison</p>
			<p class="callout">When checking for <strong class="source-inline">undefined</strong>, remember to always use the <strong class="source-inline">===</strong> operator; with <strong class="source-inline">==</strong>, it happens that <strong class="source-inline">null==undefined</strong>, and you don’t want that. See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined</a> for more <span class="No-Break">on this.</span></p>
			<p>We want to write a function that will partially<a id="_idIndexMarker556"/> apply some arguments and leave the rest open for the future. We want to write code similar to the following and produce a new function in the same fashion as we did earlier with <span class="No-Break">arrow functions:</span></p>
			<pre class="source-code">
const nonsense = (a, b, c, d, e) =&gt;
  `${a}/${b}/${c}/${d}/${e}`;
const fix2and5 = <strong class="bold">partial(nonsense)</strong>(
  undefined,
  22,
  undefined,
  undefined,
  1960
);
// fix2and5 would become
//     (X0, X2, X3) =&gt; nonsense(X0, 22, X2, X3, 1960);</pre>
			<p>How will we do this? Our implementation will use closures. (You may want to review that topic in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>.) This way of doing partial application will behave in a fashion somewhat reminiscent of currying in the sense that each function will produce a new one with some more fixed parameters. Our new implementation would be as follows – and once again, let’s start with <span class="No-Break">plain JavaScript:</span></p>
			<pre class="source-code">
// partial.js
function partial(fn) {
  const partialize =
    (...args1) =&gt;
    (...args2) =&gt; {
      for (
        let i = 0;
        i &lt; args1.length &amp;&amp; args2.length;
        i++
      ) {
        if (args1[i] === undefined) {
          args1[i] = args2.shift();
        }
      }
      const allParams = [...args1, ...args2];
      return allParams.includes(undefined) ||
        allParams.length &lt; fn.length
        ? partialize(...allParams)
        : fn(...allParams);
    };
  return partialize();
}</pre>
			<p>Wow—a longish bit of code! The key<a id="_idIndexMarker557"/> is the inner <strong class="source-inline">partialize()</strong> function. Given a list of parameters (<strong class="source-inline">args1</strong>), it produces a function that receives a second list of <span class="No-Break">parameters (</span><span class="No-Break"><strong class="source-inline">args2</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li>First, it replaces all possible <strong class="source-inline">undefined</strong> values in <strong class="source-inline">args1</strong> with values <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">args2</strong></span></li>
				<li>Then, if any parameters are left in <strong class="source-inline">args2</strong>, it also appends them to those of <strong class="source-inline">args1</strong>, <span class="No-Break">producing </span><span class="No-Break"><strong class="source-inline">allParams</strong></span></li>
				<li>Finally, if <strong class="source-inline">allParams</strong> does not include any more <strong class="source-inline">undefined</strong> values and is sufficiently long, it calls the <span class="No-Break">original function</span></li>
				<li>Otherwise, it partializes itself to wait for <span class="No-Break">more parameters</span></li>
			</ul>
			<p>An example will make it more clear. Let’s go back to our trusty <strong class="source-inline">make3()</strong> function and construct a partial version <span class="No-Break">of it:</span></p>
			<pre class="source-code">
const make3 = (a: string, b: number, c: string): string =&gt;
  `${a}:${b}:${c}`;
const f0 = <strong class="bold">partial(make3)</strong>;
const f1 = <strong class="bold">f0(undefined, 2)</strong>;</pre>
			<p>The <strong class="source-inline">f1()</strong> functio<a id="_idTextAnchor138"/>n gets <strong class="source-inline">[undefined, 2]</strong> as parameters. Now, let’s create a <span class="No-Break">new function:</span></p>
			<pre class="source-code">
const f2 = <strong class="bold">f1("A")</strong>;</pre>
			<p>What happens? The previous list of parameters (<strong class="source-inline">[undefined, 2]</strong>) gets merged with the new list (a single element—in this case, <strong class="source-inline">["A"]</strong>), producing a function that now receives <strong class="source-inline">"A"</strong> and <strong class="source-inline">2</strong> as its first two arguments. However, this isn’t yet ready, because the original function requires three arguments. We can write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const f3 = <strong class="bold">f2("Z")</strong>;</pre>
			<p>Then, the current list of arguments would be merged with the new argument, producing <strong class="source-inline">["A",2,"Z"]</strong>. Since the list is now complete, the original function will be evaluated, producing <strong class="source-inline">"A:2:Z"</strong> as the <span class="No-Break">final result.</span></p>
			<p>There are significant similarities between the structure of this code and the other higher-order function we wrote earlier in the <em class="italic">Currying with </em><span class="No-Break"><em class="italic">bind()</em></span><span class="No-Break"> section:</span></p>
			<ul>
				<li>If all the arguments have been provided, the original function <span class="No-Break">is called</span></li>
				<li>Otherwise, if some arguments are still required (when currying, it’s just a matter of counting arguments by checking the function’s <strong class="source-inline">length</strong> property; when doing partial application, you must also consider the possibility of having some <strong class="source-inline">undefined</strong> parameters), the higher-order function calls itself to produce a new version<a id="_idIndexMarker558"/> of the function, which will wait for the <span class="No-Break">missing arguments</span></li>
			</ul>
			<p>Let’s get now to a TypeScript version with its <span class="No-Break">data typing.</span></p>
			<h3>Partial data types</h3>
			<p>We’ll use<a id="_idIndexMarker559"/> an auxiliary type, <strong class="source-inline">Partialize&lt;P,A&gt;</strong>. If <strong class="source-inline">P</strong> is the tuple of the parameter types for the function, and <strong class="source-inline">A</strong> is the tuple of the argument types for a function call, <strong class="source-inline">Partialize&lt;&gt;</strong> will return a tuple with the types in <strong class="source-inline">P</strong> for which there is an <strong class="source-inline">undefined</strong> type <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// partial.ts
type Partialize&lt;
  P extends any[],
  A extends any[]
&gt; = 0 extends P["length"]
  ? []
  : 0 extends A["length"]
  ? P
  : [P, A] extends [
      [infer PH, ...infer PT],
      [infer AH, ...infer AT]
    ]
  ? AH extends undefined
    ? [PH, ...Partialize&lt;PT, AT&gt;]
    : [...Partialize&lt;PT, AT&gt;]
  : never;</pre>
			<p>How does <span class="No-Break">this work?</span></p>
			<ul>
				<li>If <strong class="source-inline">P</strong> is empty, the output is empty <span class="No-Break">as well.</span></li>
				<li>If <strong class="source-inline">A</strong> is empty (there are no more arguments left), the output <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">P</strong></span><span class="No-Break">.</span></li>
				<li>If <strong class="source-inline">P</strong> is split in <strong class="source-inline">PH</strong> (head) and <strong class="source-inline">PT</strong> (tail), and <strong class="source-inline">A</strong> is similarly split in <strong class="source-inline">AH</strong> and <strong class="source-inline">AT</strong>, then if <strong class="source-inline">AH</strong> is <strong class="source-inline">undefined</strong>, we return a new type that includes <strong class="source-inline">PH</strong> (because no value was given for it) and <strong class="source-inline">Partialize&lt;PT,AT&gt;</strong>, to recursively process the rest of both tuples. Otherwise, if <strong class="source-inline">AH</strong> is not <strong class="source-inline">undefined</strong>, we provide a value for the corresponding parameter, so the result is <strong class="source-inline">Partialize&lt;PT,AT&gt;</strong>; we don’t have to care about the parameter corresponding <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PH</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Using recursion makes this harder<a id="_idIndexMarker560"/> to understand; let’s see <span class="No-Break">some examples:</span></p>
			<pre class="source-code">
// continued...
type p00 = Partialize&lt;
  [boolean, number, string],
  [undefined, undefined, undefined]
&gt;; // <strong class="bold">[boolean, number, string]</strong>
type p01 = Partialize&lt;
  [boolean, number, string],
  [boolean, undefined, undefined]
&gt;; // <strong class="bold">[number, string]</strong>
type p02 = Partialize&lt;
  [boolean, number, string],
  [undefined, string, undefined]
&gt;; // <strong class="bold">[boolean, string]</strong>
type p03 = Partialize&lt;
  [boolean, number, string],
  [undefined, undefined, string]
&gt;; // <strong class="bold">[boolean, number]</strong>
type p04 = Partialize&lt;
  [boolean, number, string],
  [boolean, undefined, string]
&gt;; // <strong class="bold">[number]</strong>
type p05 = Partialize&lt;[boolean, number, string], [boolean]&gt;;
// <strong class="bold">[number, string]</strong>
type p06 = Partialize&lt;[boolean, number, string], []&gt;;
// <strong class="bold">[boolean, number, string]</strong></pre>
			<p>For instance, the <strong class="source-inline">p04</strong> type shows<a id="_idIndexMarker561"/> that if you have a function that expects three parameters – <strong class="source-inline">boolean</strong>, <strong class="source-inline">number</strong>, and <strong class="source-inline">string</strong> – and you call it with a <strong class="source-inline">boolean</strong>, an <strong class="source-inline">undefined</strong> value, and a <strong class="source-inline">string</strong>, the partialized function will have just a <strong class="source-inline">number</strong> parameter. The <strong class="source-inline">p05</strong> type shows that if you had called that function with just a <strong class="source-inline">boolean</strong>, the partialized function would have a <strong class="source-inline">number</strong> and a <strong class="source-inline">string</strong> <span class="No-Break">as parameters.</span></p>
			<p>This isn’t totally right, however. Let’s say we had written the <span class="No-Break">following instead:</span></p>
			<pre class="source-code">
type p04 = Partialize&lt;
  [boolean, number, string],
  [<strong class="bold">string</strong>, undefined, <strong class="bold">number</strong>]
&gt;; // <strong class="bold">[number]</strong></pre>
			<p>The result would have been the same; we are checking that we have the right number of arguments, but not their types. Let’s have another auxiliary <span class="No-Break">type check:</span></p>
			<pre class="source-code">
// continued...
type TypesMatch&lt;
  P extends any[],
  A extends any[]
&gt; = 0 extends P["length"]
  ? boolean
  : 0 extends A["length"]
  ? boolean
  : [P, A] extends [
      [infer PH, ...infer PT],
      [infer AH, ...infer AT]?
    ]
  ? AH extends undefined
    ? TypesMatch&lt;PT, AT&gt;
    : PH extends AH
    ? TypesMatch&lt;PT, AT&gt;
    : never
  : never;</pre>
			<p><strong class="source-inline">TypesMatch</strong> gets two lists of types, <strong class="source-inline">P</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>If any of the lists <a id="_idIndexMarker562"/>is empty, <span class="No-Break">that’s OK.</span></li>
				<li>If both lists are not empty, it splits them in head and tail as <strong class="source-inline">PH</strong> and <strong class="source-inline">PT</strong>, and <strong class="source-inline">AH</strong> and <strong class="source-inline">AT</strong>. If <strong class="source-inline">AH</strong> is <strong class="source-inline">undefined</strong>, or if it matches <strong class="source-inline">PH</strong>, then <strong class="source-inline">TypesMatch&lt;&gt;</strong> keeps going to analyze <span class="No-Break">both tails.</span></li>
				<li>If <strong class="source-inline">AH</strong> isn’t <strong class="source-inline">undefined</strong> but doesn’t match <strong class="source-inline">PH</strong>, <strong class="source-inline">never</strong> (which implies an error) <span class="No-Break">is generated.</span></li>
			</ul>
			<p>We can now write the <strong class="source-inline">Partial&lt;&gt;</strong> generic type using this <span class="No-Break">auxiliary definition:</span></p>
			<pre class="source-code">
// continued...
type Partial&lt;P extends any[], R&gt; = &lt;A extends any[]&gt;(
  ...x: A
) =&gt; TypesMatch&lt;P, A&gt; extends never
  ? never
  : P extends any[]
  ? 0 extends Partialize&lt;P, A&gt;["length"]
    ? (...x: [...P]) =&gt; R
    : Partial&lt;Partialize&lt;P, A&gt;, R&gt;
  : never;</pre>
			<p>Here, <strong class="source-inline">P</strong> stands for the types of the function’s parameters, <strong class="source-inline">R</strong> for its result type, and <strong class="source-inline">A</strong> for the types of the function’s arguments. We first check whether <strong class="source-inline">P</strong> and <strong class="source-inline">A</strong> match types. If so, if <strong class="source-inline">Partialize&lt;P,A&gt;</strong> is empty, we return a <strong class="source-inline">(...x: [...P]) =&gt; R</strong> function; otherwise, we (recursively) return a function with <strong class="source-inline">Partialize&lt;P,A&gt;</strong> <span class="No-Break">parameter types.</span></p>
			<p>Finally, we have all we need for our TypeScript version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">partial()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">function partial&lt;P extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...a: P) =&gt; R</strong>
<strong class="bold">): Partial&lt;P, R&gt;;</strong>
<strong class="bold">function partial(fn: (...a: any) =&gt; any) </strong>{
  const partialize =
    (...args1: any[]) =&gt;
    (...args2: any[]) =&gt; {
      for (
        let i = 0;
        i &lt; args1.length &amp;&amp; args2.length;
        i++
      ) {
        if (args1[i] === undefined) {
          args1[i] = args2.shift();
        }
      }
      const allParams = [...args1, ...args2];
      return allParams.includes(undefined) ||
        allParams.length &lt; fn.length
        ? partialize(...allParams)
        : fn(...allParams);
    };
  return partialize();
}</pre>
			<p>It’s worth noting that, as in the currying examples, we use several <strong class="source-inline">any</strong> types because TypeScript isn’t really<a id="_idIndexMarker563"/> very good at working with recursion. This implies that we must be extra careful with our code because there will be no way of <span class="No-Break">detecting errors.</span></p>
			<h3>Partial testing</h3>
			<p>Let’s finish this section<a id="_idIndexMarker564"/> by writing some tests. Here are some things we <span class="No-Break">should consider:</span></p>
			<ul>
				<li>When we do partial application, the arity of the produced function <span class="No-Break">should decrease</span></li>
				<li>The original function should be called when arguments are in the <span class="No-Break">correct order</span></li>
			</ul>
			<p>We could write something like the following, allowing the fixing of arguments in different places. Instead of using a spy or mock, we can directly work with the <strong class="source-inline">nonsense()</strong> function we had because it’s <span class="No-Break">quite efficient:</span></p>
			<pre class="source-code">
// partial.test.ts
function nonsense(
  a: number,
  b: number,
  c: number,
  d: number,
  e: number
) {
  return `${a}/${b}/${c}/${d}/${e}`;
}
describe("with partial()", function () {
  it("you could fix no arguments", () =&gt; {
    const nonsensePC0 = partial(nonsense);
    expect(nonsensePC0(0, 1, 2, 3, 4)).toBe(
      nonsense(0, 1, 2, 3, 4)
    );
  });
  it("you could fix only some initial arguments", () =&gt; {
    const nonsensePC1 = partial(nonsense)(1, 2, 3);
    expect(nonsensePC1(4, 5)).toBe(nonsense(1, 2, 3, 4,
      5));
  });
  it("you could skip some arguments", () =&gt; {
    const nonsensePC2 = partial(nonsense)(
      undefined,
      22,
      undefined,
      44
    );
    expect(nonsensePC2(11, 33, 55)).toBe(
      nonsense(11, 22, 33, 44, 55)
    );
  });
  it("you could fix only some last arguments", () =&gt; {
    const nonsensePC3 = partial(nonsense)(
      undefined,
      undefined,
      undefined,
      444,
      555
    );
    expect(nonsensePC3(111, 222, 333)).toBe(
      nonsense(111, 222, 333, 444, 555)
    );
  });
  it("you could fix ALL the arguments", () =&gt; {
    const nonsensePC4 = partial(nonsense)(6, 7, 8, 9, 0);
    expect(nonsensePC4).toBe(nonsense(6, 7, 8, 9, 0));
  });
  it("you could work in steps - (a)", () =&gt; {
    const nonsensePC5 = partial(nonsense);
    const nn = nonsensePC5(undefined, 2, 3);
    const oo = nn(undefined, undefined, 5);
    const pp = oo(1, undefined);
    const qq = pp(4);
    expect(qq).toBe(nonsense(1, 2, 3, 4, 5));
  });
  it("you could work in steps - (b)", () =&gt; {
    const nonsensePC6 = partial(nonsense)(undefined, 2, 3)(
      undefined,
      undefined,
      5
    )(
      1,
      undefined
    )(4);
    expect(nonsensePC6).toBe(nonsense(1, 2, 3, 4, 5));
  });
});</pre>
			<p>We have now seen currying and partial application; let’s see our third and last transformation, a hybrid of our <span class="No-Break">previous ones.</span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/>Partial currying</h1>
			<p>The last transformation<a id="_idIndexMarker565"/> we will look at is a mixture of currying and partial application. If you google it, in some places, you will find it called currying, and in others, partial application, but as it happens, it fits neither, so I’m sitting on the fence and calling it <span class="No-Break"><em class="italic">partial currying</em></span><span class="No-Break">!</span></p>
			<p>Given a function, the idea is to fix its first few arguments and produce a new function that will receive the rest of them. However, if that new function is given fewer arguments, it will fix whatever it was given and produce a newer function to receive the rest of them, until all the arguments are given and the final result can be calculated. See <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_7.3_B19301.jpg" alt="Figure 7.3 – Partial currying is a mixture of currying and partial application. You may provide arguments from the left, in any quantity, until all have been provided, and then the result is calculated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Partial currying is a mixture of currying and partial application. You may provide arguments from the left, in any quantity, until all have been provided, and then the result is calculated</p>
			<p>To look<a id="_idIndexMarker566"/> at an example, let’s go back to the <strong class="source-inline">nonsense()</strong> function we have been using in previous sections, as follows. Assume we already have a <span class="No-Break"><strong class="source-inline">partialCurry()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
const nonsense = (a, b, c, d, e) =&gt;
  `${a}/${b}/${c}/${d}/${e}`;
const pcNonsense = partialCurry(nonsense);
const fix1And2 = <strong class="bold">pcNonsense(9, 22)</strong>;
// fix1And2 is now a ternary function
const fix3 = <strong class="bold">fix1And2(60)</strong>;
// fix3 is a binary function
const fix4and5 = <strong class="bold">fix3(12, 4)</strong>;
// fix4and5 === nonsense(9,22,60,12,4), "9/22/60/12/4"</pre>
			<p>The original function had an arity of <strong class="source-inline">5</strong>. When we partially curry that function and give it arguments of <strong class="source-inline">9</strong> and <strong class="source-inline">22</strong>, it becomes a ternary function, because out of the original five parameters, two have become fixed. If we take that ternary function and give it a single argument, <strong class="source-inline">(60)</strong>, the result is yet another function: in this case, a binary one, because now we have fixed the first three of the original five parameters. The final call, providing the last two arguments, then does the job of actually calculating the <span class="No-Break">desired result.</span></p>
			<p>There are some points in common with currying and partial application, but also some differences, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The original function is transformed into a series of functions, each producing the next one until the last in the series actually carries out <span class="No-Break">its calculations.</span></li>
				<li>You always provide parameters starting from the first one (the leftmost one), as in currying, but you can provide more than one, as in <span class="No-Break">partial application.</span></li>
				<li>When currying a function, all the intermediate functions are unary, but with partial currying, that need not be so. However, if in each instance we were to provide a single argument, then the result would require as many steps as <span class="No-Break">plain currying.</span></li>
			</ul>
			<p>So, we have our definition—let’s now<a id="_idIndexMarker567"/> see how we can implement our new higher-order function; we’ll probably be reusing a few concepts from the previous sections in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>Partial currying with bind()</h2>
			<p>Similar to what<a id="_idIndexMarker568"/> we did with<a id="_idIndexMarker569"/> currying, there’s a simple way to do partial currying. We will take advantage of the fact that <strong class="source-inline">bind()</strong> can actually fix many arguments at once, and we’ll look at JavaScript code first <span class="No-Break">for clarity:</span></p>
			<pre class="source-code">
// partialCurry.js
function partialCurry(fn) {
  return fn.length === 0
    ? fn()
    : (<strong class="bold">...x</strong>) =&gt; partialCurry(fn.bind(null, <strong class="bold">...x</strong>));
}</pre>
			<p>Compare the code to the previous <strong class="source-inline">curry()</strong> function and you’ll see the main, but very <span class="No-Break">small, differences:</span></p>
			<pre class="source-code">
function curry(fn) {
  return fn.length === 0
    ? fn()
    : (<strong class="bold">x</strong>) =&gt; curry(fn.bind(null, <strong class="bold">x</strong>));
}</pre>
			<p>The mechanism is exactly the same. The only difference is that in our new function, we can bind many arguments simultaneously, while in <strong class="source-inline">curry()</strong>, we always bind <span class="No-Break">just one.</span></p>
			<p>In a sense, the TypeScript version is akin to the one for <strong class="source-inline">partial()</strong>. The provided arguments must match the types of the original function parameters, so we’ll use again our <strong class="source-inline">TypesMatch&lt;&gt;</strong> type from the previous section. If the original function had several parameters, and we provide a few of them, we need to figure out the rest – our <strong class="source-inline">Minus&lt;&gt;</strong> type will <span class="No-Break">do that:</span></p>
			<pre class="source-code">
// partialCurry.ts
type Minus&lt;X, Y&gt; = [X, Y] extends [
  [any, ...infer XT],
  [any, ...infer YT]
]
  ? Minus&lt;XT, YT&gt;
  : X;</pre>
			<p>Basically, if both types have<a id="_idIndexMarker570"/> more than one element, we ignore the first ones<a id="_idIndexMarker571"/> and process the tails of both types; otherwise, we return the first. With this, we can write the <span class="No-Break"><strong class="source-inline">PartialCurry&lt;&gt;</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
// partialCurry.ts
type PartialCurry&lt;P extends any[], R&gt; = &lt;A extends any[]&gt;(
  ...x: A
) =&gt; TypesMatch&lt;P, A&gt; extends never
  ? never
  : P extends any[]
  ? A["length"] extends P["length"]
    ? R
    : PartialCurry&lt;Minus&lt;P, A&gt;, R&gt;
  : never;</pre>
			<p>If types don’t match (a wrong type argument was provided), the result is an error, <strong class="source-inline">never</strong>. Otherwise, if we’ve provided enough arguments, the original <strong class="source-inline">R</strong> result type will be produced; if not, we’ll produce a new function with fewer parameters by recursion and <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Minus&lt;&gt;</strong></span><span class="No-Break">.</span></p>
			<p>We can revisit our earlier example with the <strong class="source-inline">make3()</strong> function, and the only difference is that we can get results in fewer steps – or more, as in the little sensical <span class="No-Break"><strong class="source-inline">h7</strong></span><span class="No-Break"> example!</span></p>
			<pre class="source-code">
const h1 = partialCurryByBind(make3);
const h2 = h1("A");
const h3 = h2(2, "Z");
console.log(h3); // <strong class="bold">A:2:Z</strong>
const h5 = h1("BE", 4);
const h6 = h5("YOU");
console.log(h6); // <strong class="bold">BE:4:YOU</strong>
const h7 = h5()()()("ME");
console.log(h7); // <strong class="bold">B:4:ME</strong></pre>
			<p>By the way, and just to be aware of the existing possibilities, you can fix some parameters when currying, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
const h8 = partialCurryByBind(make3)("I",8);
const h9 = h8("SOME");
console.log(h9); // <strong class="bold">I:8:SOME</strong></pre>
			<p>Testing this function<a id="_idIndexMarker572"/> is easy, and the examples we provided are a very good <a id="_idIndexMarker573"/>starting point. Note, however, that since we allow fixing any number of arguments, we cannot test the arity of the intermediate functions. Our tests could be as <span class="No-Break">follows, then:</span></p>
			<pre class="source-code">
// partialCurry.test.ts
describe("with partialCurryByBind", function () {
  it("you could fix arguments in several steps", () =&gt; {
    const make3a = partialCurryByBind(make3);
    const make3b = make3a("MAKE", 1);
    const make3c = make3b("TRY");
    expect(make3c).toBe(make3("MAKE", 1, "TRY"));
  });
  it("you could fix arguments in a single step", () =&gt; {
    const make3a = partialCurryByBind(make3);
    const make3b = make3a("SET", 2, "IT");
    expect(make3b).toBe(make3("SET", 2, "IT"));
  });
  it("you could fix ALL the arguments", () =&gt; {
    const make3all = partialCurryByBind(make3);
    expect(make3all("SOME", 1, "KNOWS")).toBe(
      make3("SOME", 1, "KNOWS")
    );
  });
  it("you could fix one argument at a time", () =&gt; {
    const make3one =
      partialCurryByBind(make3)("READY")(2)("GO");
    expect(make3one).toBe(make3("READY", 2, "GO"));
  });
});</pre>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/>Partial currying with closures</h2>
			<p>As with partial application, there’s a solution<a id="_idIndexMarker574"/> that works with closures. Since<a id="_idIndexMarker575"/> we have gone over many of the required details, let’s jump directly into the code, the JavaScript <span class="No-Break">version first:</span></p>
			<pre class="source-code">
// partialCurry.js
const partialCurryByClosure = (fn) =&gt; {
  const curryize =
    (...args1) =&gt;
    (...args2) =&gt; {
      const allParams = [...args1, ...args2];
      return allParams.length &lt; fn.length
        ? curryize(...allParams)
        : fn(...allParams);
    };
  return curryize();
};</pre>
			<p>If you compare <strong class="source-inline">partialCurryByClosure()</strong> and <strong class="source-inline">partial()</strong>, the main difference is that with partial currying, since we are always providing arguments from the left and there is no way to skip some, you concatenate whatever arguments you had with the new ones, and check whether you got enough. If the new list of arguments has reached the expected arity of the original function, you can call it and get the final result. In other cases, you just use <strong class="source-inline">curryize()</strong> (in <strong class="source-inline">partial()</strong>, we had a similar <strong class="source-inline">partialize()</strong> function) to get a new intermediate function, which will wait for <span class="No-Break">more arguments.</span></p>
			<p>With TypeScript, we don’t need any new types since the function just works (internally) in a different way, but produces the <span class="No-Break">same results:</span></p>
			<pre class="source-code">
// partialCurry.ts
<strong class="bold">function partialByClosure&lt;P extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...a: P) =&gt; R</strong>
<strong class="bold">): PartialCurry&lt;P, R&gt;;</strong>
<strong class="bold">function partialByClosure(fn: (...a: any) =&gt; any) </strong>{
  const curryize =
    (...args1: any[]) =&gt;
    (...args2: any[]) =&gt; {
      const allParams = [...args1, ...args2];
      return allParams.length &lt; fn.length
        ? curryize(...allParams)
        : fn(...allParams);
    };
  return curryize();
}</pre>
			<p>The results are exactly<a id="_idIndexMarker576"/> the same as in the previous section, so it’s not worth<a id="_idIndexMarker577"/> repeating them. You can change the tests we wrote to use <strong class="source-inline">partialCurryByClosure()</strong> instead of <strong class="source-inline">partialCurryByBind()</strong>, and they <span class="No-Break">will work.</span></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Final thoughts</h1>
			<p>Let’s finish this chapter with some short topics. First, we should consider how we’d apply the methods in this chapter to a function with a variable number of parameters – not a trivial point, as all the code we’ve seen strongly depends on the <span class="No-Break">function’s arity.</span></p>
			<p>Then we’ll finish with two more philosophical considerations regarding currying and partial application, which may cause a bit of <span class="No-Break">a discussion:</span></p>
			<ul>
				<li>First, many libraries are just wrong about the order of their parameters, making them harder <span class="No-Break">to use</span></li>
				<li>Second, I don’t usually even use the higher-order functions in this chapter, going for simpler <span class="No-Break">JavaScript code</span></li>
			</ul>
			<p>That’s probably not what you were expecting at this time, so let’s first solve the problem with the functions with an unknown number of parameters, and then go over the last two points in more detail, so you’ll see it’s not a matter of <em class="italic">do as I say, not as I do</em>... or as the <span class="No-Break">libraries do!</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>Variable number of parameters</h2>
			<p>How can we work with functions<a id="_idIndexMarker578"/> that allow for a variable (possibly undefined, indeterminate) number of parameters? This is a problem because all the code we developed in the chapter depends on <strong class="source-inline">fn.length</strong>, the arity of the function to be processed. You could want to curry the <strong class="source-inline">reduce()</strong> function, but you’d find that its arity is <strong class="source-inline">1</strong>, so the curried function would not accept a second argument. Another case: you could have a <strong class="source-inline">sumAll()</strong> function as follows, and you’d want to apply <strong class="source-inline">partial()</strong> to it and get a function with, say, three parameters, but <strong class="source-inline">sumAll.length</strong> is <strong class="source-inline">0</strong> because all its parameters <span class="No-Break">are optional:</span></p>
			<pre class="source-code">
const sumAll = (...args: number[]): number =&gt;
  args.reduce((x, y) =&gt; x + y, 0);</pre>
			<p>In the two previous editions of this book, I added an extra parameter to <strong class="source-inline">curry()</strong> and the rest so I could override the <strong class="source-inline">length</strong> attribute of the <span class="No-Break">input function:</span></p>
			<pre class="source-code">
const curry = (fn, <strong class="bold">len = fn.length</strong>) =&gt;
  len === 0
    ? fn()
    : (p) =&gt; curry(fn.bind(null, p), <strong class="bold">len - 1</strong>);</pre>
			<p>However, currently, I don’t think this is best. First, TypeScript cannot understand how many arguments the function will have, and that’s not very good. And, second, we don’t really need this! Given the functions that we saw in the <em class="italic">Arity changing</em> section of the previous chapter, if you have an <strong class="source-inline">fn()</strong> function that you want to curry for just two parameters, you can do <strong class="source-inline">curry(binary(fn))</strong> – and that solves <span class="No-Break">the issue!</span></p>
			<p>I think combining functions is a better solution than twiddling with already good implementations, so from now on, I’m recommending this new approach. Check the <em class="italic">Being functional</em> section later in this chapter for more examples of <span class="No-Break">this usage.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>Parameter order</h2>
			<p>There’s a problem that’s common<a id="_idIndexMarker579"/> to not only functions such as Underscore’s or Lodash’s <strong class="source-inline">_.map(list, mappingFunction)</strong> or <strong class="source-inline">_.reduce(list, reducingFunction, initialValue)</strong> but also to some that we have produced in this book, such as the result of <strong class="source-inline">demethodize()</strong>, for example. (See the <em class="italic">Demethodizing – turning methods into functions</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Producing Functions,</em> to review that higher-order function.) The problem is that the order of their parameters doesn’t really help <span class="No-Break">with currying.</span></p>
			<p>When currying a function, you will probably want to store intermediate results. When we do something as in the code that follows, we assume that you are going to reuse the curried function with the fixed argument, and that means that the first argument to the original function is the least likely to change. Let’s now consider a specific case. Answer this question: what’s more likely—that you’ll use <strong class="source-inline">map()</strong> to apply the same function to several different arrays or that you’ll apply several different functions to the same array? With validations or transformations, the former is more likely, but that’s not what <span class="No-Break">we get!</span></p>
			<p>We can write a simple function<a id="_idIndexMarker580"/> to flip the parameters for a binary function, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
const flip2 = fn =&gt; <strong class="bold">(p1, p2) =&gt; fn(p2, p1)</strong>;</pre>
			<p>With this, you could then write code <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const myMap = curry(<strong class="bold">flip2(demethodize(map))</strong>);
const makeString = (v) =&gt; String(v);
const stringify = myMap(makeString);
let x = stringify(anArray);
let y = stringify(anotherArray);
let z = stringify(yetAnotherArray);</pre>
			<p>The most common use case is that you’ll want to apply the function to several different lists; neither the library functions nor our own de-methodized ones provide that. However, by using <strong class="source-inline">flip2()</strong>, we can work in the fashion <span class="No-Break">we prefer.</span></p>
			<p>(Yes, in this particular case, we might have solved our problem by using partial application instead of currying; with that, we could fix the second argument to <strong class="source-inline">map()</strong> without any further bother. However, flipping arguments to produce new functions that have a different order of parameters is also an often-used technique, and you must be aware <span class="No-Break">of it.)</span></p>
			<p>For situations such as with <strong class="source-inline">reduce()</strong>, which usually receives three arguments (the list, the function, and the initial value), we may opt <span class="No-Break">for this:</span></p>
			<pre class="source-code">
const flip3 = (fn) =&gt; <strong class="bold">(p1, p2, p3) =&gt; fn(p2, p3, p1)</strong>;
const myReduce = partialCurry(
  <strong class="bold">flip3(demethodize(Array.prototype.reduce))</strong>
);
const sum = (x, y) =&gt; x + y;
const sumAll = myReduce(sum, 0);
sumAll(anArray);
sumAll(anotherArray);</pre>
			<p>Here, we used partial currying to simplify the expression for <strong class="source-inline">sumAll()</strong>. The alternative would have been using common currying, and then we would have defined <strong class="source-inline">sumAll = </strong><span class="No-Break"><strong class="source-inline">myReduce(sum)(0)</strong></span><span class="No-Break">.</span></p>
			<p>You can also go for more esoteric parameter<a id="_idIndexMarker581"/> rearranging functions if you want, but you usually won’t need more than these two. For really complex situations, you may instead opt for using arrow functions (as we did when defining <strong class="source-inline">flip2()</strong> and <strong class="source-inline">flip3()</strong>) and make it clear what kind of reordering <span class="No-Break">you need.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/>Being functional</h2>
			<p>Now that we are nearing<a id="_idIndexMarker582"/> the end of this chapter, a confession is in order: I do not always use currying and partial application, as shown previously! Don’t misunderstand me, I do apply those techniques—but sometimes they make for longer, less clear, not necessarily better code. Let me show you what I’m <span class="No-Break">talking about.</span></p>
			<p>If I’m writing my own function and then I want to curry it to fix the first parameter, currying, partial application, or partial currying don’t really make a difference compared to arrow functions. I’d have to write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const myFunction = (a, b, c) =&gt; { ... };
const myCurriedFn = <strong class="bold">curry(myFunction)(fix1st)</strong>;
// and later in the code...
<strong class="bold">myCurriedFn(set2nd)(set3rd)</strong>;</pre>
			<p>Currying the function and giving it a first parameter, all in the same line, may be considered not so clear; the alternative calls for an added variable and one more line of code. Later, the future call isn’t so good either; however, partial currying makes it more straightforward, with something like <span class="No-Break"><strong class="source-inline">myPartiallyCurriedFn(set2nd, set3rd)</strong></span><span class="No-Break">.</span></p>
			<p>In any case, when I compare the final<a id="_idIndexMarker583"/> code with the use of arrow functions, I think the other solutions aren’t really any better; make your own evaluation of the sample <span class="No-Break">that follows:</span></p>
			<pre class="source-code">
const myFunction = (a, b, c) =&gt; { ... };
const myFixedFirst = <strong class="bold">(b, c) =&gt; myFn(fix1st, b, c)</strong>;
// and later...
myFixedFirst(set2nd, set3rd);</pre>
			<p>Where I do think that currying and partial application is quite good is in my small library of de-methodized, pre-curried, basic higher-order functions. I have my own set of functions, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const <strong class="bold">_plainMap = demethodize(Array.prototype.map)</strong>;
const myMap = curry(binary(_plainMap));
const myMapX = curry(flipTwo(_plainMap));
const <strong class="bold">_plainReduce = demethodize(Array.prototype.reduce)</strong>;
const myReduce = curry(ternary(_plainReduce));
const myReduceX = curry(flip3(_plainReduce));
const <strong class="bold">_plainFilter = demethodize(Array.prototype.filter)</strong>;
const myFilter = curry(binary(_plainFilter));
const myFilterX = curry(flipTwo(_plainFilter));
// ...and more functions in the same vein</pre>
			<p>Here are some points to note about <span class="No-Break">the code:</span></p>
			<ul>
				<li>I have these functions in a separate module, and I only export the <strong class="source-inline">myXXX()</strong> <span class="No-Break">named ones.</span></li>
				<li>The other functions are private, and I use the leading underscore to remind me <span class="No-Break">of that.</span></li>
				<li>I use the <strong class="source-inline">my...</strong> prefix to remember that these are my functions, not the normal JavaScript ones. Some people would rather keep familiar names such as <strong class="source-inline">map()</strong> or <strong class="source-inline">filter()</strong>, but I prefer <span class="No-Break">distinct names.</span></li>
				<li>Since most of the JavaScript methods have a variable arity, I fixed that as described in the <em class="italic">Variable number of </em><span class="No-Break"><em class="italic">parameters</em></span><span class="No-Break"> section.</span></li>
				<li>I always provide the third argument (the initial value for reducing) to <strong class="source-inline">reduce()</strong>, so the arity I chose for that function <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></li>
				<li>When currying flipped functions, you don’t need to specify the number of parameters because flipping<a id="_idIndexMarker584"/> already does that <span class="No-Break">for you.</span></li>
			</ul>
			<p>Ultimately, it all comes down to a personal decision; experiment with the techniques we’ve looked at in this chapter and see which ones <span class="No-Break">you prefer!</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/>Summary</h1>
			<p>In this chapter, we have considered a new way of producing functions by fixing arguments to an existing function in several different ways: currying, which originally came from computer theory; partial application,  which is more flexible; and partial currying, which combines good aspects from both of the previous methods. Using these transformations, you can simplify your coding because you can generate more specialized versions of general functions without <span class="No-Break">any hassle.</span></p>
			<p>In <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>, we will turn back to some concepts we looked at in the chapter on pure functions, and we will consider ways of ensuring that functions cannot become impure by accident, by seeking ways to make their arguments immutable, making them impossible <span class="No-Break">to mutate.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor147"/>Questions</h1>
			<p>7.1 <strong class="bold">Hard by hand</strong>: With our “curried by hand” <strong class="source-inline">sum()</strong> function, we could write <strong class="source-inline">sum()(3)(5)</strong> and get <strong class="source-inline">8</strong>. But what happens if we write <span class="No-Break"><strong class="source-inline">sum(3)()(5)</strong></span><span class="No-Break"> instead?</span></p>
			<p>7.2 <strong class="bold">Sum as you will</strong>: The following exercise will help you understand some of the concepts we dealt with in this chapter, even if you solve it without using any of the functions we looked at. Write a <strong class="source-inline">sumMany()</strong> function that lets you sum an indeterminate quantity of numbers in the following fashion. Note that when the function is called with no arguments, the sum <span class="No-Break">is returned:</span></p>
			<pre class="source-code">
let result = sumMany(9)(2)(3)(1)(4)(3)();
// 22</pre>
			<p>7.3 <strong class="bold">Curry with eval?</strong> You could also produce a curried version of a function by using <strong class="source-inline">eval()</strong> – yes, the unsafe, dangerous <strong class="source-inline">eval()</strong>! If you are willing to avoid the potential security headaches that <strong class="source-inline">eval()</strong> can bring, you could use it to transform a function such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const make3 = (a: string, b: number, c: string): string =&gt;
  `${a}:${b}:${c}`;</pre>
			<p>You could transform it into a <span class="No-Break">curried equivalent:</span></p>
			<pre class="source-code">
const make3curried = x1 =&gt; x2 =&gt; x3 =&gt; make3(x1, x2, x3);</pre>
			<p>Give it a try! A tip: using the <strong class="source-inline">range()</strong> function we wrote back in the <em class="italic">Working with ranges</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Programming Declaratively,</em> may shorten your code. Also, remember that <strong class="source-inline">fn.length</strong> tells you the arity of the <span class="No-Break"><strong class="source-inline">fn()</strong></span><span class="No-Break"> function.</span></p>
			<p>7.4 <strong class="bold">Uncurrying the curried</strong>: Write an <strong class="source-inline">unCurry(fn, arity)</strong> function that receives as arguments a (curried) function and its expected arity, and returns an uncurried version of <strong class="source-inline">fn()</strong> – that is, a function that will receive all arguments at once and produce a result (providing the expected arity is needed because you have no way of determining it on <span class="No-Break">your own):</span></p>
			<pre class="source-code">
const make3 = (a, b, c) =&gt; String(100 * a + 10 * b + c);
const make3c = curry(make3);
console.log(make3c(1)(2)(3)); // 123
const remake3 = uncurry(make3c, 3);
console.log(remake3(1, 2, 3)); // 123</pre>
			<p>7.5 <strong class="bold">Let me count the ways</strong>: If you curry a function with three parameters, there’s only one way of using it: <strong class="source-inline">(a) =&gt; (b) =&gt; (c) =&gt; result</strong>. However, if you use partial curry, there are some more ways of using it: <strong class="source-inline">(a,b) =&gt; (c) =&gt; result</strong>, <strong class="source-inline">(a) =&gt; (b,c) =&gt; result</strong>, and even <strong class="source-inline">(a,b,c) =&gt; result</strong>. In how many ways can you use a partially curried function with <span class="No-Break"><em class="italic">n</em></span><span class="No-Break"> parameters?</span></p>
			<p>7.6 <strong class="bold">Currying by prototype</strong>: Modify <strong class="source-inline">Function.prototype</strong> to provide a <strong class="source-inline">curry()</strong> method that will work like the <strong class="source-inline">curry()</strong> function we saw in the chapter. Completing the following code should produce the <span class="No-Break">following results:</span></p>
			<pre class="source-code">
Function.prototype.curry = function () {
  // ...your code goes here...
};
const sum3 = (a, b, c) =&gt; 100 * a + 10 * b + c;
sum3.curry()(1)(2)(4); // 124
const sum3C = sum3.curry()(2)(2);
sum3C(9); // 229</pre>
			<p>7.7 <strong class="bold">Shorter typing</strong>: A reader commented that the <strong class="source-inline">Curry&lt;&gt;</strong> type could be written in an equivalent but shorter way if you first tested for two or more arguments. Can you implement <span class="No-Break">this change?</span></p>
			<p>7.8 <strong class="bold">Counting arguments</strong>: When we wrote the <strong class="source-inline">Curry&lt;&gt;</strong> type, we tested whether a single argument was provided by writing <strong class="source-inline">P extends [infer H]</strong> – can you rewrite the code to work with <strong class="source-inline">["length"]</strong> instead? A hint: we did this kind of thing when we defined the <span class="No-Break"><strong class="source-inline">Partial&lt;&gt;</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
type Curry&lt;P, R&gt; = <strong class="bold">P extends [infer H]</strong>
  ? (arg: H) =&gt; R // only 1 arg
  : P extends [infer H, ...infer T] // 2 or more args
  ? (arg: H) =&gt; Curry&lt;[...T], R&gt;
  : never;</pre>
			<p>7.9 <strong class="bold">Working stylishly</strong>: Write an <strong class="source-inline">applyStyle()</strong> function that will let you apply basic styling to strings in the following way. Use either currying or <span class="No-Break">partial application:</span></p>
			<pre class="source-code">
const makeBold = applyStyle("b");
document.getElementById("myCity").innerHTML =
  makeBold("Montevideo");
// &lt;b&gt;Montevideo&lt;/b&gt;, to produce Montevideo
const makeUnderline = applyStyle("u");
document.getElementById("myCountry").innerHTML =
  makeUnderline("Uruguay");
// &lt;u&gt;Uruguay&lt;/u&gt;, to produce Uruguay</pre>
			<p>7.10 <strong class="bold">Mystery questions function</strong>: What does the following function, purposefully written in an unhelpful way, <span class="No-Break">actually do?</span></p>
			<pre class="source-code">
const what = (who) =&gt; (...why) =&gt; who.length &lt;= why.length
  ? who(...why) : (...when) =&gt; what(who)(...why, ...when);</pre>
			<p>7.11 <strong class="bold">Partial transformations</strong>: Modify the prototype for functions, so both <strong class="source-inline">partial()</strong> and <strong class="source-inline">partialCurry()</strong> will be available <span class="No-Break">as methods.</span></p>
			<p>7.12 <strong class="bold">Yet more curry!</strong> Here is another proposal for a currying-style function: can you see why it works? A hint – the code is related to something we saw in <span class="No-Break">the chapter:</span></p>
			<pre class="source-code">
const curryN =
  (fn) =&gt;
  (...args) =&gt;
    args.length &gt;= fn.length
      ? fn(...args)
      : curryN(fn.bind(null, ...args));</pre>
		</div>
	</body></html>