<html><head></head><body>
		<div><h1 id="_idParaDest-129" class="chapter-number"><a id="_idTextAnchor128"/>7</h1>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Transforming Functions – Currying and Partial Application</h1>
			<p>In <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, we saw several ways of manipulating functions to get new versions with some changes in their functionality. In this chapter, we will go into a particular kind of transformation, a sort of <strong class="bold">factory method</strong> that lets you produce new versions of any given function.</p>
			<p>We will be considering the following:</p>
			<ul>
				<li><strong class="bold">Currying</strong>: A classic FP theoretical function<a id="_idIndexMarker519"/> that transforms a function with many parameters into a sequence of unary functions</li>
				<li><strong class="bold">Partial application</strong>: Another time-honored FP transformation, which<a id="_idIndexMarker520"/> produces new versions of functions by fixing some of their arguments</li>
				<li><strong class="bold">Partial currying</strong> (a name of my own): Can be seen as a mixture<a id="_idIndexMarker521"/> of the two previous transformations</li>
			</ul>
			<p>The techniques in this chapter will provide you with a different way of producing functions from other functions. To be fair, we’ll also see that some of these techniques can be emulated, possibly with greater clarity, by simple arrow functions. However, since you are liable to find currying and partial application in all sorts of texts and web pages on FP, it is important that you know their meaning and usage, even if you opt for a simpler way out. We’ll look at several applications of the ideas in the following sections.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>A bit of theory</h1>
			<p>The concepts we’ll discuss in this chapter are in some ways very similar, and in other ways quite different. It’s common to find confusion about their real meanings, and plenty of web pages misuse terms. You could even say that all the transformations in this chapter are roughly equivalent since they let you transform a function into another one that fixes some parameters, leaving other parameters free, and eventually leading to the same result. Okay, I agree; this isn’t very clear! So, let’s start by clearing the air and providing some short definitions, which we will expand on later. (If you feel your eyes are glazing over, please skip this section and return to it later!) Yes, you may find the following descriptions a bit perplexing, but bear with us—we’ll go into more detail in just a bit:</p>
			<ul>
				<li><em class="italic">Currying</em> is transforming an <em class="italic">m</em>-ary function (that is, a function of arity <em class="italic">m</em>) into<a id="_idIndexMarker522"/> a sequence of <em class="italic">m</em> unary functions, each receiving one argument of the original function, from left to right. (The first function receives the first argument of the original function and returns a second function, which receives the second argument and returns a third function, which receives the third argument, and so on.) Upon being called with an argument, each function produces the next one in the sequence, and the last one does the actual calculations.</li>
				<li><em class="italic">Partial application</em> is providing <em class="italic">n</em> arguments<a id="_idIndexMarker523"/> to an <em class="italic">m</em>-ary function, with <em class="italic">n</em> less than or equal to <em class="italic">m</em>, to transform it into a function with (<em class="italic">m</em>-<em class="italic">n</em>) parameters. Each time you provide some arguments, a new function is produced, with smaller arity. When you provide the last arguments, the actual calculations are performed.</li>
				<li><em class="italic">Partial currying</em> is a mixture of both preceding<a id="_idIndexMarker524"/> ideas: you provide <em class="italic">n</em> arguments (from left to right) to an <em class="italic">m</em>-ary function and produce a new function of arity (<em class="italic">m-n</em>). When this new function receives some other arguments, also from left to right, it will produce yet another function. When the last parameters are provided, the function produces the correct calculations.</li>
			</ul>
			<p>In this chapter, we will see these three transformations, what they require, and ways of implementing them.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Currying</h1>
			<p>We already mentioned <em class="italic">currying</em> back<a id="_idIndexMarker525"/> in the <em class="italic">Arrow functions</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Becoming Functional,</em> and in the <em class="italic">One argument or many?</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, but let’s be more thorough here. Currying is a technique that enables you to only work with single-variable functions, even if you need a multi-variable one.</p>
			<p class="callout-heading">Currying by any other name?</p>
			<p class="callout">The idea of converting a multi-variable function into a series of single-variable functions (or, more rigorously, reducing operators with several operands to a sequence of applications of a single operand operator) was worked on by Moses Schönfinkel. Some authors suggest, not necessarily tongue-in-cheek, that currying would be more correctly named <em class="italic">Schönfinkeling</em>!</p>
			<p>In the following sections, we will first see how to deal with functions with many parameters, and then move on to how to curry by hand or by using <code>bind()</code>.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Dealing with many parameters</h2>
			<p>The idea of currying, by itself, is<a id="_idIndexMarker526"/> simple. If you need<a id="_idIndexMarker527"/> a function with, say, three parameters, you could write something like the following by using arrow functions:</p>
			<pre class="source-code">
// curryByHand.ts
const make3 = (a: string, b: number, c: string): string =&gt;
  `${a}:${b}:${c}`;</pre>
			<p>Alternatively, you can have a sequence of functions, each with a single parameter, as shown here:</p>
			<pre class="source-code">
// continued...
const make3curried =
  (a: string) =&gt; (b: number) =&gt; (c: string) =&gt;
    `${a}:${b}:${c}`;</pre>
			<p>Alternatively, you might want to consider them as nested functions, like the following code snippet:</p>
			<pre class="source-code">
// continued...
const make3curried2 = function (a: string) {
  return function (b: number) {
    return function (c: string) {
      return `${a}:${b}:${c}`;
    };
  };
};</pre>
			<p>In terms of usage, there’s an essential<a id="_idIndexMarker528"/> difference in how you’d use<a id="_idIndexMarker529"/> each function. While you would call the first in the usual fashion, such as <code>make3("A",2,"Z")</code>, that wouldn’t work with the second definition. Let’s work out why: <code>make3curried()</code> is a unary (single parameter), so we should write <code>make3curried("A")</code>. But what does this return? According to the preceding definition, this also returns a unary function—and that function also returns a unary function! So, the correct call to get the same result as with the ternary function would be <code>make3curried("A")(2)("Z")</code>! See <em class="italic">Figure 7</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_7.1_B19301.jpg" alt="Figure 7.1 – The diﬀerence between a common function and a curried equivalent"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The diﬀerence between a common function and a curried equivalent</p>
			<p>Study this carefully—we have the first function, and when we apply an argument to it, we get a second function. Applying an argument to it produces a third function, and a final application produces the desired result. This can be seen as a needless exercise in theoretical computing, but it actually brings some advantages because you can then always work with unary functions, even if you need functions with more parameters.</p>
			<p class="callout-heading">Currying versus uncurrying</p>
			<p class="callout">Since there is a currying<a id="_idIndexMarker530"/> transformation, there<a id="_idIndexMarker531"/> is also an uncurrying one! In our case, we would write <code>make3uncurried = (a, b, c) =&gt; make3curried(a)(b)(c)</code> to reverse the currying process and make it usable once again, to provide all parameters in one sitting.</p>
			<p>In some languages, such as Haskell, functions are only allowed to take a single parameter—but then again, the language’s syntax allows you to invoke functions as if multiple parameters were permitted. For our example, in Haskell, writing <code>make3curried "A" 2 "Z"</code> would have produced <code>"A:2:Z"</code> without anybody even needing to be aware that it involved three function calls, each with one of our arguments. Since you don’t write parentheses around parameters and don’t separate them with commas, you cannot tell that you are not providing a triplet of values instead of three singular ones.</p>
			<p>Currying is basic in Scala<a id="_idIndexMarker532"/> or Haskell, which are fully functional<a id="_idIndexMarker533"/> languages, but JavaScript has enough features to allow us to define and use currying in our work. It won’t be as easy since, after all, it’s not built-in—but we’ll be able to manage.</p>
			<p>So, to review the basic concepts, the key differences between our original <code>make3()</code> and <code>make3curried()</code> functions are as follows:</p>
			<ul>
				<li><code>make3()</code> is a ternary function, but <code>make3curried()</code> is unary</li>
				<li><code>make3()</code> returns a string; <code>make3curried()</code> returns another function—which itself returns a second function, which returns yet a third function, which finally does return a string</li>
				<li>You can produce a string by writing something like <code>make3("A",2,"Z")</code>, which returns <code>"A:2:Z"</code>, but you’ll have to write <code>make3curried("A")(2)("Z")</code> to get the same result</li>
			</ul>
			<p>Why would you go<a id="_idIndexMarker534"/> to all this bother? Let’s look at a simple<a id="_idIndexMarker535"/> example, and further on, we will look at more examples. Suppose you had a function that calculated the value-added tax (VAT) for an amount, as shown here:</p>
			<pre class="source-code">
// continued...
const addVAT = (rate: number, amount: number): number =&gt;
  amount * (1 + rate / 100);
addVAT(20, 500); // 600 -- that is, 500 + 20%
addVAT(15, 200); // 230 -- 200 +15%</pre>
			<p>If you had to apply a single, constant rate, you could curry the <code>addVAT()</code> function to produce a more specialized version that always applied your given rate. For example, if your national rate was 6%, you could then have something like the following:</p>
			<pre class="source-code">
// continued...
const addVATcurried =
  (rate: number) =&gt;
  (amount: number): number =&gt;
    amount * (1 + rate / 100);
const addNationalVAT = <strong class="bold">addVATcurried(6)</strong>;
addNationalVAT(1500); // 1590 -- 1500 + 6%</pre>
			<p>The first line defines a curried version of our VAT-calculating function. Given a tax rate, <code>addVATcurried()</code> returns a new function, which, when given an amount of money, finally adds the original tax rate to it. So, if the national tax rate were 6%,  <code>addNationalVAT()</code> would be a function that added 6% to any amount given to it. For example, if we were to calculate <code>addNationalVAT(1500)</code>, as in the preceding code, the result would be <code>1590</code>: $1,500, plus 6% tax.</p>
			<p>Of course, you are justified in saying that this currying thing is a bit too much just to add a 6% tax, but the simplification is what counts. Let’s look at one more example. In your application, you may want to include some logging with a function such as the following:</p>
			<pre class="source-code">
// continued...
function myLog(severity: string, logText?: string) {
  // display logText in an appropriate way,
  // according to its severity
  // ("NORMAL", "WARNING", or "ERROR")
}</pre>
			<p>However, with this approach, every time you wanted to display a normal log message, you would write <code>myLog("NORMAL", "some normal text")</code>, and for warnings, you’d write <code>myLog("WARNING", "some warning text")</code>. You could simplify this a bit with currying, by fixing the first parameter of <code>myLog()</code> as follows, with a <code>curry()</code> function that we’ll look at later. Our code could then be as follows:</p>
			<pre class="source-code">
// continued...
<strong class="bold">myLog = curry(myLog)</strong>;
const myNormalLog = <strong class="bold">myLog("NORMAL")</strong>;
const myWarningLog = myLog("WARNING");
const myErrorLog = myLog("ERROR");</pre>
			<p>What do you gain? Now, you can write <code>myNormalLog("some normal text")</code> or <code>myWarningLog("some warning text")</code> because you have curried <code>myLog()</code> and then fixed its argument, making for simpler, easier-to-read code!</p>
			<p>By the way, if you prefer, you could have also achieved the same result in a single step, with the original uncurried <code>myLog()</code> function, by currying it case by case:</p>
			<pre class="source-code">
// continued...
const myNormalLog2 = <strong class="bold">curry(myLog)("NORMAL")</strong>;
const myWarningLog2 = curry(myLog)("WARNING");
const myErrorLog2 = curry(myLog)("ERROR");</pre>
			<p>So, having a <code>curry()</code> function lets you fix<a id="_idIndexMarker536"/> some arguments while leaving<a id="_idIndexMarker537"/> others still open; let’s see how to do this in three different ways.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Currying by hand</h2>
			<p>Before trying more complex things, we<a id="_idIndexMarker538"/> could curry a function by hand, without any special auxiliary functions or anything else. And, in fact, if we want to implement currying for a particular case, there’s no need to do anything complex because we can manage with simple arrow functions. We saw that with both <code>make3curried()</code> and <code>addVATcurried()</code>, so there’s no need to revisit that idea.</p>
			<p>Instead, let’s look into some ways of doing that automatically, so we can produce an equivalent curried version of any function, even without knowing its arity beforehand. Going further, we should code a more intelligent version of a function that could work differently depending on the number of received arguments. For example, we could have a <code>sum(x,y)</code> function that behaved as in the following examples:</p>
			<pre class="source-code">
<strong class="bold">sum(3, 5)</strong>; // 8; did you expect otherwise?
const add3 = sum(3);
<strong class="bold">add3(5)</strong>;   // 8
<strong class="bold">sum(3)(5)</strong>; // 8</pre>
			<p>We can achieve that behavior by hand. Our function would be something like the following – and since we won’t be using this style, let’s stay with plain JavaScript, with no typing:</p>
			<pre class="source-code">
// continued...
const sum = (x, y) =&gt; {
  if (x !== undefined &amp;&amp; y !== undefined) {
    return x + y;
  } else if (x !== undefined &amp;&amp; y == undefined) {
    return (z) =&gt; sum(x, z);
  } else {  // x,y both undefined
    return sum;
  }
};</pre>
			<p>Let’s recap what we did here. Our curried-by-hand function has this behavior:</p>
			<ul>
				<li>If we call it with two arguments, it adds them and returns the sum; this provides our first use case, as in <code>sum(3,5)===8</code>.</li>
				<li>If only one argument is provided, it returns a new function. This new function expects a single argument and will return the sum of that argument and the original one: this behavior is what we expected in the other two use cases, such as <code>add2(3)===5</code> or <code>sum(2)(7)===9</code>.</li>
				<li>Finally, if no arguments are provided, it returns itself. This means that we would be able to write <code>sum()(1)(2)</code> if we desired. (No, I cannot think of a reason for wanting to write that.)</li>
			</ul>
			<p>So, we can incorporate currying<a id="_idIndexMarker539"/> in the definition itself of a function. However, you’ll have to agree that dealing with all the special cases in each function could quickly become troublesome and error-prone. So, let’s work out some generic ways of accomplishing the same result without any particular coding.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Currying with bind()</h2>
			<p>We can find<a id="_idIndexMarker540"/> a solution to currying by using the <code>bind()</code> method, which we have already applied<a id="_idIndexMarker541"/> in several places in this book. This allows us to fix one argument (or more, if need be; we won’t need to do that here, but later on we will use it) and provide a function with that fixed argument. Of course, many libraries (such as Lodash, Underscore, Ramda, and others) provide this functionality, but we want to see how to implement that ourselves.</p>
			<h3>A plain JavaScript version</h3>
			<p>Our implementation is relatively<a id="_idIndexMarker542"/> short but will require some explanation. First, let’s see a JavaScript version and deal with TypeScript later:</p>
			<pre class="source-code">
// curry.js
function curry(fn) {
  return fn.length === 0
    ? fn()
    : (x) =&gt; curryByBind(fn.bind(null, x));
}</pre>
			<p>Start by noticing that <code>curryByBind()</code> always returns a new function, which depends on the <code>fn</code> function given as its parameter. If the function has no (more) parameters left (when <code>fn.length===0</code>) because all parameters have already been bound, we can evaluate it by using <code>fn()</code>. Otherwise, the result of currying<a id="_idIndexMarker543"/> the function will be a new function that receives a single argument and produces a newly curried function with another fixed argument. Let’s see this in action, with a detailed example, using the <code>make3()</code> function we saw at the beginning of this chapter once again:</p>
			<pre class="source-code">
// continued...
const make3 = (a, b, c) =&gt; `${a}:${b}:${c}`;
// f1 is the curried version of make3
const f1 = curry(<strong class="bold">make3</strong>);
// f2 is a function that will fix make3's 1st parameter
const f2 = <strong class="bold">f1("A")</strong>;
// f3 is a function that will fix make3's 2nd parameter
const f3 = <strong class="bold">f2(2)</strong>;
// "A2Z" will be now calculated, since we are providing
// the 3rd (last) make3's parameter
const f4 = <strong class="bold">f3("Z")</strong>;
console.log(f4);</pre>
			<p>The explanation of this code is as follows:</p>
			<ul>
				<li>The first function, <code>f1()</code>, has yet to receive any arguments. When called with an argument, it will produce a curried version of <code>make3()</code>, with its first argument fixed.</li>
				<li>Calling <code>f1("A")</code> produces a new unary function, <code>f2()</code>, which will itself produce a curried version of <code>make3()</code>—but with its first argument set to <code>"A"</code>, so actually, the new function will end up fixing the second parameter of <code>make3()</code>.</li>
				<li>Similarly, calling <code>f2(2)</code> produces a third unary function, <code>f3()</code>, which will produce a version of <code>make3()</code>, but fixing its third argument, since the first two have already been fixed.</li>
				<li>Finally, when we calculate <code>f3("Z")</code>, this fixes the last parameter of <code>make3()</code> to <code>"Z"</code>, and since there are no more arguments left, the thrice-bound <code>make3()</code> function is called and the <code>"A:2:Z"</code> result is produced.</li>
			</ul>
			<p>You can do other call sequences as well, such as the following:</p>
			<pre class="source-code">
// continued...
const f2b = <strong class="bold">f1("TEA")(4)</strong>;
const f3b = <strong class="bold">f2b("TWO")</strong>;
// "TEA:4:TWO"
const f1c = f1("IN")(10)("TION");
// "IN":10:"TION"</pre>
			<p>To curry the function by hand, you could use JavaScript’s <code>.bind()</code> method. The sequence would be as follows:</p>
			<pre class="source-code">
// continued…
const step1 = make3<strong class="bold">.bind(null, "A")</strong>;
const step2 = step1<strong class="bold">.bind(null, 2)</strong>;
const step3 = step2<strong class="bold">.bind(null, "Z")</strong>;
console.log(step3()); // "A:2:Z"</pre>
			<p>In each step, we provide an additional parameter. (The <code>null</code> value is required, to provide context. If it were a method attached to an object, we would provide that object as the first parameter to <code>.bind()</code>. Since that’s not the case, <code>null</code> is expected.) This is equivalent<a id="_idIndexMarker544"/> to what our code does, except that the last time, <code>curryByBind()</code> does the actual calculation instead of making you do it, as in <code>step3()</code>.</p>
			<h3>A TypeScript version</h3>
			<p>Now that have implemented this in JavaScript, let’s see how to define types for currying. We have to work recursively<a id="_idIndexMarker545"/> and consider two cases:</p>
			<ul>
				<li>If we curry a function with just one parameter, the function will directly produce the desired result</li>
				<li>If we curry a function with two or more parameters, we’ll create a unary function (with the first parameter) that will return a (curried!) function that will deal with the rest of the parameters:</li>
			</ul>
			<pre class="source-code">
// curry.ts
type Curry&lt;P, R&gt; = P extends [infer H]
  ? (arg: H) =&gt; R // only 1 arg
  : P extends [infer H, ...infer T] // 2 or more args
  ? (arg: H) =&gt; Curry&lt;[...T], R&gt;
  : never;</pre>
			<p>We will have a generic type with two inputs: <code>P</code>, representing the parameters of the function to process, and <code>R</code>, standing for the result type of that function. If <code>P</code> has just one type, <code>H</code>, we return a function that, given an argument of the <code>H</code> type, returns a result of the <code>R</code> type. If <code>P</code> is formed by a first <code>H</code> type (“head”) and some other <code>T</code> types (“tail”), we return a function that will return a (curried) function with <code>T</code> types as arguments.</p>
			<p>Using this type has an added complexity. TypeScript cannot verify that our <code>curryByBind()</code> function works correctly because it cannot deduce that, for every function, we’ll eventually produce a result instead of yet another curried function. There’s a tricky solution involving an overloaded function with just <em class="italic">one</em> signature. The key is that the implementation is checked more loosely, and you can use <code>any</code> types to get by. Of course, working like this isn’t precisely type-safe; it’s up to you to ensure that the function is type-correct because you are essentially bypassing TypeScript’s checks. We’ll have to do this kind of trick more than once in this chapter:</p>
			<pre class="source-code">
// continued…
<strong class="bold">function curry&lt;A extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...args: A) =&gt; R</strong>
<strong class="bold">): Curry&lt;A, R&gt;;</strong>
function curry(fn: (...args: any) =&gt; any) {
  return fn.length === 0
    ? fn()
    : (x: any) =&gt; curry(fn.bind(null, x));
}</pre>
			<p>Let’s go back to our <code>make3()</code> example. Types work out perfectly well:</p>
			<pre class="source-code">
const f1 = curry(make3);
// <strong class="bold">(arg: string) =&gt; (arg: number) =&gt; (arg: string) =&gt; string</strong>
const f2 = f1("A");
// <strong class="bold">(arg: number) =&gt; (arg: string) =&gt; string</strong>
const f3 = f2(2);
// <strong class="bold">(arg: string) =&gt; string</strong>
const f4 = f3("Z");
// <strong class="bold">string</strong></pre>
			<p>The type of <code>f1</code> is key; it shows that our recursive typing<a id="_idIndexMarker546"/> worked as expected. The types of <code>f2</code> and <code>f3</code> are shorter, and the type of <code>f4</code> is the type of the final result, <code>string</code>.</p>
			<h3>Currying tests</h3>
			<p>Testing this transformation<a id="_idIndexMarker547"/> is rather simple because there are not many possible ways of currying:</p>
			<pre class="source-code">
// curry.test.js
describe("with curry", function () {
  it("you fix arguments one by one", () =&gt; {
    const make3a = curry(make3);
    const make3b = make3a("A")(2);
    const make3c = make3b("Z");
    expect(make3c).toBe(make3("A", 2, "Z"));
  });
});</pre>
			<p>What else could you test? Maybe functions with just one parameter could be added, but there are no more to try.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Partial application</h1>
			<p>The second transformation<a id="_idIndexMarker548"/> we will be considering lets you fix some of the function’s parameters, creating a new function that will receive the rest of them. Let’s make this clear with a nonsense example. Imagine you have a function with five parameters. You might want to fix the second and fifth parameters, and partial application would produce a new version of the function that fixed those two parameters but left the other three open for new calls. If you called the resulting function with the three required arguments, it would produce the correct answer by using the original two fixed parameters plus the newly provided three.</p>
			<p class="callout-heading">Projecting parameters</p>
			<p class="callout">The idea of specifying only some parameters in function application, producing a function<a id="_idIndexMarker549"/> of the remaining parameters, is called <strong class="bold">projection</strong>: you are said to be projecting the function onto the remaining arguments. We will not use this term, but I wanted to cite it in case you find it elsewhere.</p>
			<p>Let’s consider an example using the <code>fetch()</code> API, widely considered the modern way to go for Ajax calls. You might want to fetch several resources, always specifying the same parameters for the call (for example, request headers) and only changing the URL to search. By using partial application, you could create a new <code>myFetch()</code> function that would always provide fixed parameters.</p>
			<p class="callout-heading">On fetching</p>
			<p class="callout">You can read more on <code>fetch()</code> at <a href="http://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch</a>. According to <a href="http://caniuse.com/#search=fetch">caniuse.com/#search=fetch</a>, you can use it in most browsers except for (oh, surprise!) Internet Explorer, but you can get around this limitation with a polyfill, such as the one found at <a href="http://github.com/github/fetch">github.com/github/fetch</a>.</p>
			<p>Let’s assume we have a <code>partial()</code> function that implements this kind of application and let’s see how we’d use that to produce our new, specialized version of <code>fetch()</code>:</p>
			<pre class="source-code">
const myFetch = <strong class="bold">partial(fetch, undefined, myParameters)</strong>;
// undefined means the first argument for fetch
// is not yet defined; the second argument for
// fetch() is set to myParameters
myFetch("a/first/url")
  .then(/* do something */)
  .catch(/* on error */);
myFetch("a/second/url")
  .then(/* do something else */)
  .catch(/* on error */);</pre>
			<p>Currying would have worked if the request parameters had been the first argument for <code>fetch()</code>. (We’ll have more to say about the order of parameters later.) With partial application, you can replace any arguments, no matter which, so in this case, <code>myFetch()</code> ends up as a unary function. This new function will get data from any URL you wish, always passing<a id="_idIndexMarker550"/> the same set of parameters for the <code>GET</code> operation.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Partial application with arrow functions</h2>
			<p>Trying to do partial application<a id="_idIndexMarker551"/> by hand, as we did with<a id="_idIndexMarker552"/> currying, is too complicated. For instance, for a function with 5 parameters, you would have to write code allowing the user to provide any of the 32 possible combinations of fixed and unfixed parameters – 32 being equal to 2 raised to the fifth power. Even if you could simplify the problem, it would still remain hard to write and maintain. See <em class="italic">Figure 7</em><em class="italic">.2</em> for one of many possible combinations:</p>
			<div><div><img src="img/Figure_7.2_B19301.jpg" alt="Figure 7.2 – Partial application may let you ﬁrst provide some parameters, and then provide the rest, to ﬁnally get the result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Partial application may let you ﬁrst provide some parameters, and then provide the rest, to ﬁnally get the result</p>
			<p>Doing partial application with arrow functions, however, is much simpler. With the example we mentioned previously, we would have something like the following code. In this case, we will assume we want to fix the second parameter to <code>22</code> and the fifth parameter to <code>1960</code>:</p>
			<pre class="source-code">
const nonsense = (a, b, c, d, e) =&gt;
  `${a}/${b}/${c}/${d}/${e}`;
const fix2and5 = (a, c, d) =&gt; nonsense(a, 22, c, d, 1960);</pre>
			<p>Doing partial application this way is quite simple, though we may want to find a more general solution. You can set any number of parameters, by creating a new function out of the previous one but fixing some more parameters. (Wrappers, as in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, could be used.) For instance, you might now want to also fix the last parameter of the new <code>fix2and5()</code> function to <code>9</code>, as shown in the following code; there’s nothing easier:</p>
			<pre class="source-code">
const fixLast = (a, c) =&gt; fix2and5(a, c, 9);</pre>
			<p>You might also have written <code>nonsense(a, 22, c, 9, 1960)</code> if you wished to, but the fact remains<a id="_idIndexMarker553"/> that fixing parameters by using arrow functions<a id="_idIndexMarker554"/> is simple. Let’s now consider, as we said, a more general solution.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Partial application with closures</h2>
			<p>If we want to be able to do partial application<a id="_idIndexMarker555"/> fixing of any combination of parameters, we must have a way to specify which arguments are to be left free and which will be fixed from that point on. Some libraries, such as Underscore and Lodash, use a special <code>_</code>  object to signify an omitted parameter. In this fashion, still using the same <code>nonsense()</code> function, we would write the following:</p>
			<pre class="source-code">
const fix2and5 = _.partial(nonsense)(_, 22, _, _, 1960);</pre>
			<p>We could do the same sort of thing by having a global variable that would represent a pending, not yet fixed argument, but let’s make it simpler and just use <code>undefined</code> to represent a missing parameter.</p>
			<p class="callout-heading">Careful comparison</p>
			<p class="callout">When checking for <code>undefined</code>, remember to always use the <code>===</code> operator; with <code>==</code>, it happens that <code>null==undefined</code>, and you don’t want that. See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined</a> for more on this.</p>
			<p>We want to write a function that will partially<a id="_idIndexMarker556"/> apply some arguments and leave the rest open for the future. We want to write code similar to the following and produce a new function in the same fashion as we did earlier with arrow functions:</p>
			<pre class="source-code">
const nonsense = (a, b, c, d, e) =&gt;
  `${a}/${b}/${c}/${d}/${e}`;
const fix2and5 = <strong class="bold">partial(nonsense)</strong>(
  undefined,
  22,
  undefined,
  undefined,
  1960
);
// fix2and5 would become
//     (X0, X2, X3) =&gt; nonsense(X0, 22, X2, X3, 1960);</pre>
			<p>How will we do this? Our implementation will use closures. (You may want to review that topic in <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>.) This way of doing partial application will behave in a fashion somewhat reminiscent of currying in the sense that each function will produce a new one with some more fixed parameters. Our new implementation would be as follows – and once again, let’s start with plain JavaScript:</p>
			<pre class="source-code">
// partial.js
function partial(fn) {
  const partialize =
    (...args1) =&gt;
    (...args2) =&gt; {
      for (
        let i = 0;
        i &lt; args1.length &amp;&amp; args2.length;
        i++
      ) {
        if (args1[i] === undefined) {
          args1[i] = args2.shift();
        }
      }
      const allParams = [...args1, ...args2];
      return allParams.includes(undefined) ||
        allParams.length &lt; fn.length
        ? partialize(...allParams)
        : fn(...allParams);
    };
  return partialize();
}</pre>
			<p>Wow—a longish bit of code! The key<a id="_idIndexMarker557"/> is the inner <code>partialize()</code> function. Given a list of parameters (<code>args1</code>), it produces a function that receives a second list of parameters (<code>args2</code>):</p>
			<ul>
				<li>First, it replaces all possible <code>undefined</code> values in <code>args1</code> with values from <code>args2</code></li>
				<li>Then, if any parameters are left in <code>args2</code>, it also appends them to those of <code>args1</code>, producing <code>allParams</code></li>
				<li>Finally, if <code>allParams</code> does not include any more <code>undefined</code> values and is sufficiently long, it calls the original function</li>
				<li>Otherwise, it partializes itself to wait for more parameters</li>
			</ul>
			<p>An example will make it more clear. Let’s go back to our trusty <code>make3()</code> function and construct a partial version of it:</p>
			<pre class="source-code">
const make3 = (a: string, b: number, c: string): string =&gt;
  `${a}:${b}:${c}`;
const f0 = <strong class="bold">partial(make3)</strong>;
const f1 = <strong class="bold">f0(undefined, 2)</strong>;</pre>
			<p>The <code>f1()</code> functio<a id="_idTextAnchor138"/>n gets <code>[undefined, 2]</code> as parameters. Now, let’s create a new function:</p>
			<pre class="source-code">
const f2 = <strong class="bold">f1("A")</strong>;</pre>
			<p>What happens? The previous list of parameters (<code>[undefined, 2]</code>) gets merged with the new list (a single element—in this case, <code>["A"]</code>), producing a function that now receives <code>"A"</code> and <code>2</code> as its first two arguments. However, this isn’t yet ready, because the original function requires three arguments. We can write the following:</p>
			<pre class="source-code">
const f3 = <strong class="bold">f2("Z")</strong>;</pre>
			<p>Then, the current list of arguments would be merged with the new argument, producing <code>["A",2,"Z"]</code>. Since the list is now complete, the original function will be evaluated, producing <code>"A:2:Z"</code> as the final result.</p>
			<p>There are significant similarities between the structure of this code and the other higher-order function we wrote earlier in the <em class="italic">Currying with </em><em class="italic">bind()</em> section:</p>
			<ul>
				<li>If all the arguments have been provided, the original function is called</li>
				<li>Otherwise, if some arguments are still required (when currying, it’s just a matter of counting arguments by checking the function’s <code>length</code> property; when doing partial application, you must also consider the possibility of having some <code>undefined</code> parameters), the higher-order function calls itself to produce a new version<a id="_idIndexMarker558"/> of the function, which will wait for the missing arguments</li>
			</ul>
			<p>Let’s get now to a TypeScript version with its data typing.</p>
			<h3>Partial data types</h3>
			<p>We’ll use<a id="_idIndexMarker559"/> an auxiliary type, <code>Partialize&lt;P,A&gt;</code>. If <code>P</code> is the tuple of the parameter types for the function, and <code>A</code> is the tuple of the argument types for a function call, <code>Partialize&lt;&gt;</code> will return a tuple with the types in <code>P</code> for which there is an <code>undefined</code> type in <code>A</code>:</p>
			<pre class="source-code">
// partial.ts
type Partialize&lt;
  P extends any[],
  A extends any[]
&gt; = 0 extends P["length"]
  ? []
  : 0 extends A["length"]
  ? P
  : [P, A] extends [
      [infer PH, ...infer PT],
      [infer AH, ...infer AT]
    ]
  ? AH extends undefined
    ? [PH, ...Partialize&lt;PT, AT&gt;]
    : [...Partialize&lt;PT, AT&gt;]
  : never;</pre>
			<p>How does this work?</p>
			<ul>
				<li>If <code>P</code> is empty, the output is empty as well.</li>
				<li>If <code>A</code> is empty (there are no more arguments left), the output is <code>P</code>.</li>
				<li>If <code>P</code> is split in <code>PH</code> (head) and <code>PT</code> (tail), and <code>A</code> is similarly split in <code>AH</code> and <code>AT</code>, then if <code>AH</code> is <code>undefined</code>, we return a new type that includes <code>PH</code> (because no value was given for it) and <code>Partialize&lt;PT,AT&gt;</code>, to recursively process the rest of both tuples. Otherwise, if <code>AH</code> is not <code>undefined</code>, we provide a value for the corresponding parameter, so the result is <code>Partialize&lt;PT,AT&gt;</code>; we don’t have to care about the parameter corresponding to <code>PH</code>.</li>
			</ul>
			<p>Using recursion makes this harder<a id="_idIndexMarker560"/> to understand; let’s see some examples:</p>
			<pre class="source-code">
// continued...
type p00 = Partialize&lt;
  [boolean, number, string],
  [undefined, undefined, undefined]
&gt;; // <strong class="bold">[boolean, number, string]</strong>
type p01 = Partialize&lt;
  [boolean, number, string],
  [boolean, undefined, undefined]
&gt;; // <strong class="bold">[number, string]</strong>
type p02 = Partialize&lt;
  [boolean, number, string],
  [undefined, string, undefined]
&gt;; // <strong class="bold">[boolean, string]</strong>
type p03 = Partialize&lt;
  [boolean, number, string],
  [undefined, undefined, string]
&gt;; // <strong class="bold">[boolean, number]</strong>
type p04 = Partialize&lt;
  [boolean, number, string],
  [boolean, undefined, string]
&gt;; // <strong class="bold">[number]</strong>
type p05 = Partialize&lt;[boolean, number, string], [boolean]&gt;;
// <strong class="bold">[number, string]</strong>
type p06 = Partialize&lt;[boolean, number, string], []&gt;;
// <strong class="bold">[boolean, number, string]</strong></pre>
			<p>For instance, the <code>p04</code> type shows<a id="_idIndexMarker561"/> that if you have a function that expects three parameters – <code>boolean</code>, <code>number</code>, and <code>string</code> – and you call it with a <code>boolean</code>, an <code>undefined</code> value, and a <code>string</code>, the partialized function will have just a <code>number</code> parameter. The <code>p05</code> type shows that if you had called that function with just a <code>boolean</code>, the partialized function would have a <code>number</code> and a <code>string</code> as parameters.</p>
			<p>This isn’t totally right, however. Let’s say we had written the following instead:</p>
			<pre class="source-code">
type p04 = Partialize&lt;
  [boolean, number, string],
  [<strong class="bold">string</strong>, undefined, <strong class="bold">number</strong>]
&gt;; // <strong class="bold">[number]</strong></pre>
			<p>The result would have been the same; we are checking that we have the right number of arguments, but not their types. Let’s have another auxiliary type check:</p>
			<pre class="source-code">
// continued...
type TypesMatch&lt;
  P extends any[],
  A extends any[]
&gt; = 0 extends P["length"]
  ? boolean
  : 0 extends A["length"]
  ? boolean
  : [P, A] extends [
      [infer PH, ...infer PT],
      [infer AH, ...infer AT]?
    ]
  ? AH extends undefined
    ? TypesMatch&lt;PT, AT&gt;
    : PH extends AH
    ? TypesMatch&lt;PT, AT&gt;
    : never
  : never;</pre>
			<p><code>TypesMatch</code> gets two lists of types, <code>P</code> and <code>A</code>:</p>
			<ul>
				<li>If any of the lists <a id="_idIndexMarker562"/>is empty, that’s OK.</li>
				<li>If both lists are not empty, it splits them in head and tail as <code>PH</code> and <code>PT</code>, and <code>AH</code> and <code>AT</code>. If <code>AH</code> is <code>undefined</code>, or if it matches <code>PH</code>, then <code>TypesMatch&lt;&gt;</code> keeps going to analyze both tails.</li>
				<li>If <code>AH</code> isn’t <code>undefined</code> but doesn’t match <code>PH</code>, <code>never</code> (which implies an error) is generated.</li>
			</ul>
			<p>We can now write the <code>Partial&lt;&gt;</code> generic type using this auxiliary definition:</p>
			<pre class="source-code">
// continued...
type Partial&lt;P extends any[], R&gt; = &lt;A extends any[]&gt;(
  ...x: A
) =&gt; TypesMatch&lt;P, A&gt; extends never
  ? never
  : P extends any[]
  ? 0 extends Partialize&lt;P, A&gt;["length"]
    ? (...x: [...P]) =&gt; R
    : Partial&lt;Partialize&lt;P, A&gt;, R&gt;
  : never;</pre>
			<p>Here, <code>P</code> stands for the types of the function’s parameters, <code>R</code> for its result type, and <code>A</code> for the types of the function’s arguments. We first check whether <code>P</code> and <code>A</code> match types. If so, if <code>Partialize&lt;P,A&gt;</code> is empty, we return a <code>(...x: [...P]) =&gt; R</code> function; otherwise, we (recursively) return a function with <code>Partialize&lt;P,A&gt;</code> parameter types.</p>
			<p>Finally, we have all we need for our TypeScript version of <code>partial()</code>:</p>
			<pre class="source-code">
// continued...
<strong class="bold">function partial&lt;P extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...a: P) =&gt; R</strong>
<strong class="bold">): Partial&lt;P, R&gt;;</strong>
<strong class="bold">function partial(fn: (...a: any) =&gt; any) </strong>{
  const partialize =
    (...args1: any[]) =&gt;
    (...args2: any[]) =&gt; {
      for (
        let i = 0;
        i &lt; args1.length &amp;&amp; args2.length;
        i++
      ) {
        if (args1[i] === undefined) {
          args1[i] = args2.shift();
        }
      }
      const allParams = [...args1, ...args2];
      return allParams.includes(undefined) ||
        allParams.length &lt; fn.length
        ? partialize(...allParams)
        : fn(...allParams);
    };
  return partialize();
}</pre>
			<p>It’s worth noting that, as in the currying examples, we use several <code>any</code> types because TypeScript isn’t really<a id="_idIndexMarker563"/> very good at working with recursion. This implies that we must be extra careful with our code because there will be no way of detecting errors.</p>
			<h3>Partial testing</h3>
			<p>Let’s finish this section<a id="_idIndexMarker564"/> by writing some tests. Here are some things we should consider:</p>
			<ul>
				<li>When we do partial application, the arity of the produced function should decrease</li>
				<li>The original function should be called when arguments are in the correct order</li>
			</ul>
			<p>We could write something like the following, allowing the fixing of arguments in different places. Instead of using a spy or mock, we can directly work with the <code>nonsense()</code> function we had because it’s quite efficient:</p>
			<pre class="source-code">
// partial.test.ts
function nonsense(
  a: number,
  b: number,
  c: number,
  d: number,
  e: number
) {
  return `${a}/${b}/${c}/${d}/${e}`;
}
describe("with partial()", function () {
  it("you could fix no arguments", () =&gt; {
    const nonsensePC0 = partial(nonsense);
    expect(nonsensePC0(0, 1, 2, 3, 4)).toBe(
      nonsense(0, 1, 2, 3, 4)
    );
  });
  it("you could fix only some initial arguments", () =&gt; {
    const nonsensePC1 = partial(nonsense)(1, 2, 3);
    expect(nonsensePC1(4, 5)).toBe(nonsense(1, 2, 3, 4,
      5));
  });
  it("you could skip some arguments", () =&gt; {
    const nonsensePC2 = partial(nonsense)(
      undefined,
      22,
      undefined,
      44
    );
    expect(nonsensePC2(11, 33, 55)).toBe(
      nonsense(11, 22, 33, 44, 55)
    );
  });
  it("you could fix only some last arguments", () =&gt; {
    const nonsensePC3 = partial(nonsense)(
      undefined,
      undefined,
      undefined,
      444,
      555
    );
    expect(nonsensePC3(111, 222, 333)).toBe(
      nonsense(111, 222, 333, 444, 555)
    );
  });
  it("you could fix ALL the arguments", () =&gt; {
    const nonsensePC4 = partial(nonsense)(6, 7, 8, 9, 0);
    expect(nonsensePC4).toBe(nonsense(6, 7, 8, 9, 0));
  });
  it("you could work in steps - (a)", () =&gt; {
    const nonsensePC5 = partial(nonsense);
    const nn = nonsensePC5(undefined, 2, 3);
    const oo = nn(undefined, undefined, 5);
    const pp = oo(1, undefined);
    const qq = pp(4);
    expect(qq).toBe(nonsense(1, 2, 3, 4, 5));
  });
  it("you could work in steps - (b)", () =&gt; {
    const nonsensePC6 = partial(nonsense)(undefined, 2, 3)(
      undefined,
      undefined,
      5
    )(
      1,
      undefined
    )(4);
    expect(nonsensePC6).toBe(nonsense(1, 2, 3, 4, 5));
  });
});</pre>
			<p>We have now seen currying and partial application; let’s see our third and last transformation, a hybrid of our previous ones.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/>Partial currying</h1>
			<p>The last transformation<a id="_idIndexMarker565"/> we will look at is a mixture of currying and partial application. If you google it, in some places, you will find it called currying, and in others, partial application, but as it happens, it fits neither, so I’m sitting on the fence and calling it <em class="italic">partial currying</em>!</p>
			<p>Given a function, the idea is to fix its first few arguments and produce a new function that will receive the rest of them. However, if that new function is given fewer arguments, it will fix whatever it was given and produce a newer function to receive the rest of them, until all the arguments are given and the final result can be calculated. See <em class="italic">Figure 7</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_7.3_B19301.jpg" alt="Figure 7.3 – Partial currying is a mixture of currying and partial application. You may provide arguments from the left, in any quantity, until all have been provided, and then the result is calculated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Partial currying is a mixture of currying and partial application. You may provide arguments from the left, in any quantity, until all have been provided, and then the result is calculated</p>
			<p>To look<a id="_idIndexMarker566"/> at an example, let’s go back to the <code>nonsense()</code> function we have been using in previous sections, as follows. Assume we already have a <code>partialCurry()</code> function:</p>
			<pre class="source-code">
const nonsense = (a, b, c, d, e) =&gt;
  `${a}/${b}/${c}/${d}/${e}`;
const pcNonsense = partialCurry(nonsense);
const fix1And2 = <strong class="bold">pcNonsense(9, 22)</strong>;
// fix1And2 is now a ternary function
const fix3 = <strong class="bold">fix1And2(60)</strong>;
// fix3 is a binary function
const fix4and5 = <strong class="bold">fix3(12, 4)</strong>;
// fix4and5 === nonsense(9,22,60,12,4), "9/22/60/12/4"</pre>
			<p>The original function had an arity of <code>5</code>. When we partially curry that function and give it arguments of <code>9</code> and <code>22</code>, it becomes a ternary function, because out of the original five parameters, two have become fixed. If we take that ternary function and give it a single argument, <code>(60)</code>, the result is yet another function: in this case, a binary one, because now we have fixed the first three of the original five parameters. The final call, providing the last two arguments, then does the job of actually calculating the desired result.</p>
			<p>There are some points in common with currying and partial application, but also some differences, as follows:</p>
			<ul>
				<li>The original function is transformed into a series of functions, each producing the next one until the last in the series actually carries out its calculations.</li>
				<li>You always provide parameters starting from the first one (the leftmost one), as in currying, but you can provide more than one, as in partial application.</li>
				<li>When currying a function, all the intermediate functions are unary, but with partial currying, that need not be so. However, if in each instance we were to provide a single argument, then the result would require as many steps as plain currying.</li>
			</ul>
			<p>So, we have our definition—let’s now<a id="_idIndexMarker567"/> see how we can implement our new higher-order function; we’ll probably be reusing a few concepts from the previous sections in this chapter.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>Partial currying with bind()</h2>
			<p>Similar to what<a id="_idIndexMarker568"/> we did with<a id="_idIndexMarker569"/> currying, there’s a simple way to do partial currying. We will take advantage of the fact that <code>bind()</code> can actually fix many arguments at once, and we’ll look at JavaScript code first for clarity:</p>
			<pre class="source-code">
// partialCurry.js
function partialCurry(fn) {
  return fn.length === 0
    ? fn()
    : (<strong class="bold">...x</strong>) =&gt; partialCurry(fn.bind(null, <strong class="bold">...x</strong>));
}</pre>
			<p>Compare the code to the previous <code>curry()</code> function and you’ll see the main, but very small, differences:</p>
			<pre class="source-code">
function curry(fn) {
  return fn.length === 0
    ? fn()
    : (<strong class="bold">x</strong>) =&gt; curry(fn.bind(null, <strong class="bold">x</strong>));
}</pre>
			<p>The mechanism is exactly the same. The only difference is that in our new function, we can bind many arguments simultaneously, while in <code>curry()</code>, we always bind just one.</p>
			<p>In a sense, the TypeScript version is akin to the one for <code>partial()</code>. The provided arguments must match the types of the original function parameters, so we’ll use again our <code>TypesMatch&lt;&gt;</code> type from the previous section. If the original function had several parameters, and we provide a few of them, we need to figure out the rest – our <code>Minus&lt;&gt;</code> type will do that:</p>
			<pre class="source-code">
// partialCurry.ts
type Minus&lt;X, Y&gt; = [X, Y] extends [
  [any, ...infer XT],
  [any, ...infer YT]
]
  ? Minus&lt;XT, YT&gt;
  : X;</pre>
			<p>Basically, if both types have<a id="_idIndexMarker570"/> more than one element, we ignore the first ones<a id="_idIndexMarker571"/> and process the tails of both types; otherwise, we return the first. With this, we can write the <code>PartialCurry&lt;&gt;</code> type:</p>
			<pre class="source-code">
// partialCurry.ts
type PartialCurry&lt;P extends any[], R&gt; = &lt;A extends any[]&gt;(
  ...x: A
) =&gt; TypesMatch&lt;P, A&gt; extends never
  ? never
  : P extends any[]
  ? A["length"] extends P["length"]
    ? R
    : PartialCurry&lt;Minus&lt;P, A&gt;, R&gt;
  : never;</pre>
			<p>If types don’t match (a wrong type argument was provided), the result is an error, <code>never</code>. Otherwise, if we’ve provided enough arguments, the original <code>R</code> result type will be produced; if not, we’ll produce a new function with fewer parameters by recursion and using <code>Minus&lt;&gt;</code>.</p>
			<p>We can revisit our earlier example with the <code>make3()</code> function, and the only difference is that we can get results in fewer steps – or more, as in the little sensical <code>h7</code> example!</p>
			<pre class="source-code">
const h1 = partialCurryByBind(make3);
const h2 = h1("A");
const h3 = h2(2, "Z");
console.log(h3); // <strong class="bold">A:2:Z</strong>
const h5 = h1("BE", 4);
const h6 = h5("YOU");
console.log(h6); // <strong class="bold">BE:4:YOU</strong>
const h7 = h5()()()("ME");
console.log(h7); // <strong class="bold">B:4:ME</strong></pre>
			<p>By the way, and just to be aware of the existing possibilities, you can fix some parameters when currying, as shown here:</p>
			<pre class="source-code">
const h8 = partialCurryByBind(make3)("I",8);
const h9 = h8("SOME");
console.log(h9); // <strong class="bold">I:8:SOME</strong></pre>
			<p>Testing this function<a id="_idIndexMarker572"/> is easy, and the examples we provided are a very good <a id="_idIndexMarker573"/>starting point. Note, however, that since we allow fixing any number of arguments, we cannot test the arity of the intermediate functions. Our tests could be as follows, then:</p>
			<pre class="source-code">
// partialCurry.test.ts
describe("with partialCurryByBind", function () {
  it("you could fix arguments in several steps", () =&gt; {
    const make3a = partialCurryByBind(make3);
    const make3b = make3a("MAKE", 1);
    const make3c = make3b("TRY");
    expect(make3c).toBe(make3("MAKE", 1, "TRY"));
  });
  it("you could fix arguments in a single step", () =&gt; {
    const make3a = partialCurryByBind(make3);
    const make3b = make3a("SET", 2, "IT");
    expect(make3b).toBe(make3("SET", 2, "IT"));
  });
  it("you could fix ALL the arguments", () =&gt; {
    const make3all = partialCurryByBind(make3);
    expect(make3all("SOME", 1, "KNOWS")).toBe(
      make3("SOME", 1, "KNOWS")
    );
  });
  it("you could fix one argument at a time", () =&gt; {
    const make3one =
      partialCurryByBind(make3)("READY")(2)("GO");
    expect(make3one).toBe(make3("READY", 2, "GO"));
  });
});</pre>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/>Partial currying with closures</h2>
			<p>As with partial application, there’s a solution<a id="_idIndexMarker574"/> that works with closures. Since<a id="_idIndexMarker575"/> we have gone over many of the required details, let’s jump directly into the code, the JavaScript version first:</p>
			<pre class="source-code">
// partialCurry.js
const partialCurryByClosure = (fn) =&gt; {
  const curryize =
    (...args1) =&gt;
    (...args2) =&gt; {
      const allParams = [...args1, ...args2];
      return allParams.length &lt; fn.length
        ? curryize(...allParams)
        : fn(...allParams);
    };
  return curryize();
};</pre>
			<p>If you compare <code>partialCurryByClosure()</code> and <code>partial()</code>, the main difference is that with partial currying, since we are always providing arguments from the left and there is no way to skip some, you concatenate whatever arguments you had with the new ones, and check whether you got enough. If the new list of arguments has reached the expected arity of the original function, you can call it and get the final result. In other cases, you just use <code>curryize()</code> (in <code>partial()</code>, we had a similar <code>partialize()</code> function) to get a new intermediate function, which will wait for more arguments.</p>
			<p>With TypeScript, we don’t need any new types since the function just works (internally) in a different way, but produces the same results:</p>
			<pre class="source-code">
// partialCurry.ts
<strong class="bold">function partialByClosure&lt;P extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...a: P) =&gt; R</strong>
<strong class="bold">): PartialCurry&lt;P, R&gt;;</strong>
<strong class="bold">function partialByClosure(fn: (...a: any) =&gt; any) </strong>{
  const curryize =
    (...args1: any[]) =&gt;
    (...args2: any[]) =&gt; {
      const allParams = [...args1, ...args2];
      return allParams.length &lt; fn.length
        ? curryize(...allParams)
        : fn(...allParams);
    };
  return curryize();
}</pre>
			<p>The results are exactly<a id="_idIndexMarker576"/> the same as in the previous section, so it’s not worth<a id="_idIndexMarker577"/> repeating them. You can change the tests we wrote to use <code>partialCurryByClosure()</code> instead of <code>partialCurryByBind()</code>, and they will work.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Final thoughts</h1>
			<p>Let’s finish this chapter with some short topics. First, we should consider how we’d apply the methods in this chapter to a function with a variable number of parameters – not a trivial point, as all the code we’ve seen strongly depends on the function’s arity.</p>
			<p>Then we’ll finish with two more philosophical considerations regarding currying and partial application, which may cause a bit of a discussion:</p>
			<ul>
				<li>First, many libraries are just wrong about the order of their parameters, making them harder to use</li>
				<li>Second, I don’t usually even use the higher-order functions in this chapter, going for simpler JavaScript code</li>
			</ul>
			<p>That’s probably not what you were expecting at this time, so let’s first solve the problem with the functions with an unknown number of parameters, and then go over the last two points in more detail, so you’ll see it’s not a matter of <em class="italic">do as I say, not as I do</em>... or as the libraries do!</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>Variable number of parameters</h2>
			<p>How can we work with functions<a id="_idIndexMarker578"/> that allow for a variable (possibly undefined, indeterminate) number of parameters? This is a problem because all the code we developed in the chapter depends on <code>fn.length</code>, the arity of the function to be processed. You could want to curry the <code>reduce()</code> function, but you’d find that its arity is <code>1</code>, so the curried function would not accept a second argument. Another case: you could have a <code>sumAll()</code> function as follows, and you’d want to apply <code>partial()</code> to it and get a function with, say, three parameters, but <code>sumAll.length</code> is <code>0</code> because all its parameters are optional:</p>
			<pre class="source-code">
const sumAll = (...args: number[]): number =&gt;
  args.reduce((x, y) =&gt; x + y, 0);</pre>
			<p>In the two previous editions of this book, I added an extra parameter to <code>curry()</code> and the rest so I could override the <code>length</code> attribute of the input function:</p>
			<pre class="source-code">
const curry = (fn, <strong class="bold">len = fn.length</strong>) =&gt;
  len === 0
    ? fn()
    : (p) =&gt; curry(fn.bind(null, p), <strong class="bold">len - 1</strong>);</pre>
			<p>However, currently, I don’t think this is best. First, TypeScript cannot understand how many arguments the function will have, and that’s not very good. And, second, we don’t really need this! Given the functions that we saw in the <em class="italic">Arity changing</em> section of the previous chapter, if you have an <code>fn()</code> function that you want to curry for just two parameters, you can do <code>curry(binary(fn))</code> – and that solves the issue!</p>
			<p>I think combining functions is a better solution than twiddling with already good implementations, so from now on, I’m recommending this new approach. Check the <em class="italic">Being functional</em> section later in this chapter for more examples of this usage.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>Parameter order</h2>
			<p>There’s a problem that’s common<a id="_idIndexMarker579"/> to not only functions such as Underscore’s or Lodash’s <code>_.map(list, mappingFunction)</code> or <code>_.reduce(list, reducingFunction, initialValue)</code> but also to some that we have produced in this book, such as the result of <code>demethodize()</code>, for example. (See the <em class="italic">Demethodizing – turning methods into functions</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, Producing Functions,</em> to review that higher-order function.) The problem is that the order of their parameters doesn’t really help with currying.</p>
			<p>When currying a function, you will probably want to store intermediate results. When we do something as in the code that follows, we assume that you are going to reuse the curried function with the fixed argument, and that means that the first argument to the original function is the least likely to change. Let’s now consider a specific case. Answer this question: what’s more likely—that you’ll use <code>map()</code> to apply the same function to several different arrays or that you’ll apply several different functions to the same array? With validations or transformations, the former is more likely, but that’s not what we get!</p>
			<p>We can write a simple function<a id="_idIndexMarker580"/> to flip the parameters for a binary function, as shown here:</p>
			<pre class="source-code">
const flip2 = fn =&gt; <strong class="bold">(p1, p2) =&gt; fn(p2, p1)</strong>;</pre>
			<p>With this, you could then write code as follows:</p>
			<pre class="source-code">
const myMap = curry(<strong class="bold">flip2(demethodize(map))</strong>);
const makeString = (v) =&gt; String(v);
const stringify = myMap(makeString);
let x = stringify(anArray);
let y = stringify(anotherArray);
let z = stringify(yetAnotherArray);</pre>
			<p>The most common use case is that you’ll want to apply the function to several different lists; neither the library functions nor our own de-methodized ones provide that. However, by using <code>flip2()</code>, we can work in the fashion we prefer.</p>
			<p>(Yes, in this particular case, we might have solved our problem by using partial application instead of currying; with that, we could fix the second argument to <code>map()</code> without any further bother. However, flipping arguments to produce new functions that have a different order of parameters is also an often-used technique, and you must be aware of it.)</p>
			<p>For situations such as with <code>reduce()</code>, which usually receives three arguments (the list, the function, and the initial value), we may opt for this:</p>
			<pre class="source-code">
const flip3 = (fn) =&gt; <strong class="bold">(p1, p2, p3) =&gt; fn(p2, p3, p1)</strong>;
const myReduce = partialCurry(
  <strong class="bold">flip3(demethodize(Array.prototype.reduce))</strong>
);
const sum = (x, y) =&gt; x + y;
const sumAll = myReduce(sum, 0);
sumAll(anArray);
sumAll(anotherArray);</pre>
			<p>Here, we used partial currying to simplify the expression for <code>sumAll()</code>. The alternative would have been using common currying, and then we would have defined <code>sumAll = </code><code>myReduce(sum)(0)</code>.</p>
			<p>You can also go for more esoteric parameter<a id="_idIndexMarker581"/> rearranging functions if you want, but you usually won’t need more than these two. For really complex situations, you may instead opt for using arrow functions (as we did when defining <code>flip2()</code> and <code>flip3()</code>) and make it clear what kind of reordering you need.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/>Being functional</h2>
			<p>Now that we are nearing<a id="_idIndexMarker582"/> the end of this chapter, a confession is in order: I do not always use currying and partial application, as shown previously! Don’t misunderstand me, I do apply those techniques—but sometimes they make for longer, less clear, not necessarily better code. Let me show you what I’m talking about.</p>
			<p>If I’m writing my own function and then I want to curry it to fix the first parameter, currying, partial application, or partial currying don’t really make a difference compared to arrow functions. I’d have to write the following:</p>
			<pre class="source-code">
const myFunction = (a, b, c) =&gt; { ... };
const myCurriedFn = <strong class="bold">curry(myFunction)(fix1st)</strong>;
// and later in the code...
<strong class="bold">myCurriedFn(set2nd)(set3rd)</strong>;</pre>
			<p>Currying the function and giving it a first parameter, all in the same line, may be considered not so clear; the alternative calls for an added variable and one more line of code. Later, the future call isn’t so good either; however, partial currying makes it more straightforward, with something like <code>myPartiallyCurriedFn(set2nd, set3rd)</code>.</p>
			<p>In any case, when I compare the final<a id="_idIndexMarker583"/> code with the use of arrow functions, I think the other solutions aren’t really any better; make your own evaluation of the sample that follows:</p>
			<pre class="source-code">
const myFunction = (a, b, c) =&gt; { ... };
const myFixedFirst = <strong class="bold">(b, c) =&gt; myFn(fix1st, b, c)</strong>;
// and later...
myFixedFirst(set2nd, set3rd);</pre>
			<p>Where I do think that currying and partial application is quite good is in my small library of de-methodized, pre-curried, basic higher-order functions. I have my own set of functions, such as the following:</p>
			<pre class="source-code">
const <strong class="bold">_plainMap = demethodize(Array.prototype.map)</strong>;
const myMap = curry(binary(_plainMap));
const myMapX = curry(flipTwo(_plainMap));
const <strong class="bold">_plainReduce = demethodize(Array.prototype.reduce)</strong>;
const myReduce = curry(ternary(_plainReduce));
const myReduceX = curry(flip3(_plainReduce));
const <strong class="bold">_plainFilter = demethodize(Array.prototype.filter)</strong>;
const myFilter = curry(binary(_plainFilter));
const myFilterX = curry(flipTwo(_plainFilter));
// ...and more functions in the same vein</pre>
			<p>Here are some points to note about the code:</p>
			<ul>
				<li>I have these functions in a separate module, and I only export the <code>myXXX()</code> named ones.</li>
				<li>The other functions are private, and I use the leading underscore to remind me of that.</li>
				<li>I use the <code>my...</code> prefix to remember that these are my functions, not the normal JavaScript ones. Some people would rather keep familiar names such as <code>map()</code> or <code>filter()</code>, but I prefer distinct names.</li>
				<li>Since most of the JavaScript methods have a variable arity, I fixed that as described in the <em class="italic">Variable number of </em><em class="italic">parameters</em> section.</li>
				<li>I always provide the third argument (the initial value for reducing) to <code>reduce()</code>, so the arity I chose for that function is <code>3</code>.</li>
				<li>When currying flipped functions, you don’t need to specify the number of parameters because flipping<a id="_idIndexMarker584"/> already does that for you.</li>
			</ul>
			<p>Ultimately, it all comes down to a personal decision; experiment with the techniques we’ve looked at in this chapter and see which ones you prefer!</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/>Summary</h1>
			<p>In this chapter, we have considered a new way of producing functions by fixing arguments to an existing function in several different ways: currying, which originally came from computer theory; partial application,  which is more flexible; and partial currying, which combines good aspects from both of the previous methods. Using these transformations, you can simplify your coding because you can generate more specialized versions of general functions without any hassle.</p>
			<p>In <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>, we will turn back to some concepts we looked at in the chapter on pure functions, and we will consider ways of ensuring that functions cannot become impure by accident, by seeking ways to make their arguments immutable, making them impossible to mutate.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor147"/>Questions</h1>
			<p>7.1 <code>sum()</code> function, we could write <code>sum()(3)(5)</code> and get <code>8</code>. But what happens if we write <code>sum(3)()(5)</code> instead?</p>
			<p>7.2 <code>sumMany()</code> function that lets you sum an indeterminate quantity of numbers in the following fashion. Note that when the function is called with no arguments, the sum is returned:</p>
			<pre class="source-code">
let result = sumMany(9)(2)(3)(1)(4)(3)();
// 22</pre>
			<p>7.3 <code>eval()</code> – yes, the unsafe, dangerous <code>eval()</code>! If you are willing to avoid the potential security headaches that <code>eval()</code> can bring, you could use it to transform a function such as the following:</p>
			<pre class="source-code">
const make3 = (a: string, b: number, c: string): string =&gt;
  `${a}:${b}:${c}`;</pre>
			<p>You could transform it into a curried equivalent:</p>
			<pre class="source-code">
const make3curried = x1 =&gt; x2 =&gt; x3 =&gt; make3(x1, x2, x3);</pre>
			<p>Give it a try! A tip: using the <code>range()</code> function we wrote back in the <em class="italic">Working with ranges</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, Programming Declaratively,</em> may shorten your code. Also, remember that <code>fn.length</code> tells you the arity of the <code>fn()</code> function.</p>
			<p>7.4 <code>unCurry(fn, arity)</code> function that receives as arguments a (curried) function and its expected arity, and returns an uncurried version of <code>fn()</code> – that is, a function that will receive all arguments at once and produce a result (providing the expected arity is needed because you have no way of determining it on your own):</p>
			<pre class="source-code">
const make3 = (a, b, c) =&gt; String(100 * a + 10 * b + c);
const make3c = curry(make3);
console.log(make3c(1)(2)(3)); // 123
const remake3 = uncurry(make3c, 3);
console.log(remake3(1, 2, 3)); // 123</pre>
			<p>7.5 <code>(a) =&gt; (b) =&gt; (c) =&gt; result</code>. However, if you use partial curry, there are some more ways of using it: <code>(a,b) =&gt; (c) =&gt; result</code>, <code>(a) =&gt; (b,c) =&gt; result</code>, and even <code>(a,b,c) =&gt; result</code>. In how many ways can you use a partially curried function with <em class="italic">n</em> parameters?</p>
			<p>7.6 <code>Function.prototype</code> to provide a <code>curry()</code> method that will work like the <code>curry()</code> function we saw in the chapter. Completing the following code should produce the following results:</p>
			<pre class="source-code">
Function.prototype.curry = function () {
  // ...your code goes here...
};
const sum3 = (a, b, c) =&gt; 100 * a + 10 * b + c;
sum3.curry()(1)(2)(4); // 124
const sum3C = sum3.curry()(2)(2);
sum3C(9); // 229</pre>
			<p>7.7 <code>Curry&lt;&gt;</code> type could be written in an equivalent but shorter way if you first tested for two or more arguments. Can you implement this change?</p>
			<p>7.8 <code>Curry&lt;&gt;</code> type, we tested whether a single argument was provided by writing <code>P extends [infer H]</code> – can you rewrite the code to work with <code>["length"]</code> instead? A hint: we did this kind of thing when we defined the <code>Partial&lt;&gt;</code> type:</p>
			<pre class="source-code">
type Curry&lt;P, R&gt; = <strong class="bold">P extends [infer H]</strong>
  ? (arg: H) =&gt; R // only 1 arg
  : P extends [infer H, ...infer T] // 2 or more args
  ? (arg: H) =&gt; Curry&lt;[...T], R&gt;
  : never;</pre>
			<p>7.9 <code>applyStyle()</code> function that will let you apply basic styling to strings in the following way. Use either currying or partial application:</p>
			<pre class="source-code">
const makeBold = applyStyle("b");
document.getElementById("myCity").innerHTML =
  makeBold("Montevideo");
// &lt;b&gt;Montevideo&lt;/b&gt;, to produce Montevideo
const makeUnderline = applyStyle("u");
document.getElementById("myCountry").innerHTML =
  makeUnderline("Uruguay");
// &lt;u&gt;Uruguay&lt;/u&gt;, to produce Uruguay</pre>
			<p>7.10 <strong class="bold">Mystery questions function</strong>: What does the following function, purposefully written in an unhelpful way, actually do?</p>
			<pre class="source-code">
const what = (who) =&gt; (...why) =&gt; who.length &lt;= why.length
  ? who(...why) : (...when) =&gt; what(who)(...why, ...when);</pre>
			<p>7.11 <code>partial()</code> and <code>partialCurry()</code> will be available as methods.</p>
			<p>7.12 <strong class="bold">Yet more curry!</strong> Here is another proposal for a currying-style function: can you see why it works? A hint – the code is related to something we saw in the chapter:</p>
			<pre class="source-code">
const curryN =
  (fn) =&gt;
  (...args) =&gt;
    args.length &gt;= fn.length
      ? fn(...args)
      : curryN(fn.bind(null, ...args));</pre>
		</div>
	</body></html>