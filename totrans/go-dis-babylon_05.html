<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor103"/>5</h1>
<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/> Adding a Cut Scene and Handling Input</h1>
<p>Much of the work we’ve completed so far has contributed to the whole largely unseen and unheard. The only action we’ve required – or even listened for – from users is a single button click. How boring – and quiet. That’s all about to change, though! In this chapter, we’re going to add some flavor to our app’s launch by adding a Splash Screen that tells the world that everything they’re about to see is “Powered by Babylon.js” in the process of providing players with their first experience with Space-Truckers. We’ll also be giving users agency in the game world by adding inputs for multiple different device types, along with the logic to process inputs into actions in the game.</p>
<p>This seems like a lot to cover in such a short chapter, but thanks to how easy it can be to accomplish tasks in Babylon.js, progress can come faster than you might think. </p>
<p>In this chapter, we will cover the following topics: </p>
<ul>
<li>Space-Truckers – the Splash Screen</li>
<li>Designing the Input System</li>
</ul>
<p>Everything we’ll be doing will build from the work we’ve done in previous chapters, but it’s OK if you’re just picking things up from here – read on for technical details on how to obtain the source code to complete this chapter.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Technical Requirements</h1>
<p>This is the first time that we’re going to be expanding the technical requirements, but it should hardly be a surprise to anyone that to work with a particular type of input device – be it a mouse and keyboard, Xbox™ controller, Sony PlayStation™ controller, or even a VR joystick – it is necessary to either have one of such devices handy or (worst case) download and install a suitable emulator/simulation app. That said, Space-Truckers should be playable with the following input types:</p>
<ul>
<li>Keyboard and mouse</li>
<li>Virtual joysticks/touch screen</li>
<li>Xbox™ controller</li>
<li>Sony PlayStation™ controller</li>
<li>Generic gamepads</li>
</ul>
<p>An appropriate audio output device will be needed to play music and sounds. </p>
<p>This chapter will follow a similar pattern as previous chapters, where we will build out one or more PlayGround snippets before integrating them into the application’s code base. The code we’ll be starting from is at <a href="https://github.com/jelster/space-truckers/tree/ch4">https://github.com/jelster/space-truckers/tree/ch4</a> if you want a reference point or a place from where you can start your journey. Now, with that squared away, we can turn our full attention to our first task: building the Splash Screen!</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Space-Truckers – the Splash Screen</h1>
<p>Nothing gets <a id="_idIndexMarker261"/>the attention<a id="_idIndexMarker262"/> of an audience better than a splashy entrance, and nobody knew this better than good ol’ William Shakespeare. A glance at the first few pages of any of his plays uncovers a host of different exciting scenes from a street brawl between rival gangs in <em class="italic">Romeo and Juliet</em> to an interrupted wedding in <em class="italic">A Midsummer Night’s Dream</em>. The Bard knew how to get the attention of his audiences – a notable feat in those times – and just as he shamelessly plundered history and mythology (sometimes both at the same time!) for his stories, we’re going to shamelessly plunder the techniques he used in our work.</p>
<p>The specific inspiration from Mr. S. that we will examine is the idea of engaging the attention of an audience to prepare and prime them for what they’re about to experience. We don’t have a fancy fight scene or a fantasy wedding in the cards for Space-Truckers, but we do have our Splash Screen!</p>
<p>Looking at the Splash Screen in context, the user has just clicked the <strong class="bold">Launch</strong> button on the regular HTML web page, transitioning the page over to WebGL and rendering the animated Loading Screen we built back in <a href="B17266_02_Final_AM.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a><em class="italic">, Ramping up on Babylon.js</em>. Immediately following the completion of the Splash Screen (either because it ran to the end or because the user chose to skip through it), the user will be taken to the <strong class="bold">Main Menu</strong> screen that we built out in the previous chapter. Through a series of animated sequences and in conjunction with the audio <a id="_idIndexMarker263"/>soundtrack, users will be <a id="_idIndexMarker264"/>put solidly into the mood of a Space-Trucker.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Storyboarding the Scene</h2>
<p>While it’s easy to let <a id="_idIndexMarker265"/>the mind wander off into the potential avenues that a splash scene might show, we’ll Save It For A PR™ and instead start with something incredibly simple that we can then use as a base for expansion. A storyboard doesn’t have to be an immensely complicated and planned-out artifact. Time spent storyboarding is time that isn’t being spent trying out the ideas laid out by the storyboard, so don’t worry about making it look good, worry about the boards capturing a set of snapshots of what you want to happen. The following diagram shows the sketched-out series of panels that comprise the Splash Screen storyboard:</p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 5.1 – Storyboard for the Splash Screen sequence. Being a sketch, the numbers given for timings should not be taken at face value" height="1583" src="image/Figure_5.01_B17266.jpg" width="1448"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Storyboard for the Splash Screen sequence. Being a sketch, the numbers given for timings should not be taken at face value</p>
<p>Let’s break this<a id="_idIndexMarker266"/> diagram down a bit by walking through the scene in a temporal order. At time = 0, we have a blank stage (screen). After 2 seconds have passed, the first panel with the words “Powered By” is fully visible. Half (0.5) a second after that (or T+2.5s) marks the beginning of the exit sub-sequence, which completes with the panel fully hidden another half a second later. The total amount of time that the first panel depicts is 3 seconds. Armed with that explanation, the other three panels should also make sense. Each panel progresses the scene forward, starting at the top-left, moving right, and wrapping back to the left panel, respectively. The image shown in a panel fades in and out according to the given timings, but those numbers should be used as rough guide markers only – it’s important to tweak the values to what you like.</p>
<p>If you were to compare the storyboard with the final splash screen sequence, there are some gross similarities; the panels are all mostly the same and in the same order, the timings notated are roughly the same, and more. That shows the evolution of the design from start to finish and serves to drive home a central point of storyboarding – the boards are not the whole story! These admittedly crude sketches serve the purpose of putting a stake in the ground, giving loose definition to the basic elements and timings involved so that <a id="_idIndexMarker267"/>we can focus on other aspects of implementation – such as the code.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Building the Scene</h2>
<p>There is only one <a id="_idIndexMarker268"/>new concept that we haven’t encountered yet that we’ll need to learn to build out the Splash Screen in code. Everything else will use a combination of techniques that we’ve used in previous chapters in one way or another, so hopefully, this will seem pretty easy! For this part of the chapter, we’ll be working exclusively <a id="_idIndexMarker269"/>in the <strong class="bold">PlayGround</strong> (<strong class="bold">PG</strong>) – if you’re following along, this is where you’ll want to load up the PG with a new snippet. </p>
<p class="callout-heading">Important note</p>
<p class="callout">Code listings will continue to become less complete and more focused on specific aspects or areas of the code under discussion that are important, tricky, or non-obvious. The complete code for this chapter can be found at <a href="https://github.com/jelster/space-truckers/tree/ch5">https://github.com/jelster/space-truckers/tree/ch5</a>. Don’t hesitate to pull it up to compare your progress against it or check your work – sometimes, an explanation just won’t cut it and you need to see working code!</p>
<p>When we break out the various animated sequences outlined in the storyboard, there’s an immediate structure or way of ordering the cut scene that sticks out right away. Each board in the storyboard represents a distinct snapshot of what is happening at a given time in the scene, so we need to come up with a way to represent these cut scene segments in code. We want it to be a reusable component, and we want to be able to use The Power of <strong class="bold">Composition</strong> to assemble multiple segments into a greater whole. As with any flexible programming language, there are many ways we might fulfill these requirements. A class-based approach leverages ES6 language features to make it quick and easy to create new instances of a <strong class="source-inline">CutSceneSegment</strong>, and a new <strong class="source-inline">SplashScene</strong> class can be used to compose and manage those segments with proper timings and transitions.</p>
<h3>The CutSceneSegment Class</h3>
<p>The <strong class="source-inline">CutSceneSegment</strong> class is <a id="_idIndexMarker270"/>a simple container that can <a id="_idIndexMarker271"/>represent an atomic portion of the scene’s sequence, but although it is simple, it isn’t devoid of any behaviors. A <strong class="source-inline">CutSceneSegment</strong> should be able to <strong class="source-inline">start</strong> and <strong class="source-inline">stop</strong> its sequence, potentially looping playback. Similarly, other components may need to know when a segment completes, so a <strong class="source-inline">onEnd</strong> observable will make it easier for us to write controlling logic to manage multiple segments in sequence. Because we don’t hate ourselves and we don’t want to spend time debugging mysteriously misbehaving code, we’ll treat an instance of a <strong class="source-inline">CutSceneSegment</strong> as <strong class="bold">immutable</strong>. That is, once<a id="_idIndexMarker272"/> we’ve created the object, we’re not going to try to change it by say, swapping out the contained animations.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Can you keep a secret? Those who have experience with JavaScript may be thinking that the word “immutable” is incorrectly being applied. While it is true that from a strictly technical sense, the objects we’re dealing with are not immutable, the idea is that we simply pretend it is immutable. If we’re using it as-is, and if nobody tells, does it matter whether an object is immutable or not? Be warned, though – it’s easy to lose the distinction between ways of thinking about software and expressing those concepts in code, so don’t mistake this for language-specific guidance!</p>
<p>Although it would be useful to be able to control multiple target scene elements in a single <strong class="source-inline">CutSceneSegment</strong>, we don’t need that complexity to implement the scene from our storyboards. This decision, in conjunction with the previous decision regarding immutability, has two<a id="_idIndexMarker273"/> important implications for how we will write our classes’ <strong class="bold">constructor</strong>. </p>
<p>First, we’ll need to get a <strong class="source-inline">target</strong> against which the segment will operate. This can be anything capable of being animated, so, pretty much any BJS type you may want to animate can be used here (with the notable exception of the types in <strong class="bold">BABYLON.GUI.Controls</strong>). Second, the constructor<a id="_idIndexMarker274"/> will need to accept an array of arbitrary individual <strong class="bold">Animation</strong> instances as an <strong class="source-inline">animationSequence</strong>. Of course, the “ctor” (as the cool kids all call it) will need to take a reference to the current scene, which gives us the following signature for the method:</p>
<pre class="source-code">&#13;
class CutSceneSegment {&#13;
    //loopAnimation = false;&#13;
    //animationGroup;&#13;
    //onEnd = new Observable();&#13;
    constructor(target, scene, <strong class="bold">...animationSequence</strong>) { ... }</pre>
<p>You may be unfamiliar with the highlighted language construct. That’s OK because although it’s not uncommon, it’s also not something that you might encounter in your everyday JavaScript. The three periods (<strong class="source-inline">.</strong>) before <strong class="source-inline">animationSequence</strong> indicate that the parameter is treated as an arbitrary params-style array. This is merely a convenient piece of “syntactic sugar” that allows callers of the function to avoid the need to create and pass an <strong class="source-inline">Array</strong> and instead pass a comma-separated list of the elements comprising the Array. The following code fragment shows arrays being passed as the trailing three parameters:</p>
<pre class="source-code">&#13;
new CutSceneSegment(billboard, scene, fadeAnimation,&#13;
  scaleAnimation, rotateAnimation);</pre>
<p>In the <strong class="source-inline">CutSceneSegment</strong> constructor, there <a id="_idIndexMarker275"/>are two primary things we need to accomplish:</p>
<ol>
<li>Create a <strong class="source-inline">TargetedAnimation</strong> from each Animation in <strong class="source-inline">animationSequence</strong>.</li>
<li>Add the TargetedAnimations to a new <strong class="source-inline">AnimationGroup</strong>.</li>
</ol>
<p>Going in reverse order, <strong class="source-inline">AnimationGroup</strong> is something new to the project. Do not try to overthink it – it is and does exactly what its name suggests. Next, because we already have animations that just need targeting, we can loop through the <strong class="source-inline">animationSequence</strong> collection and use AnimationGroup’s <strong class="source-inline">addTargetedAnimation</strong> method to complete the binding. The Babylon.js Docs site at <a href="https://doc.babylonjs.com/divingDeeper/animation/groupAnimations">https://doc.babylonjs.com/divingDeeper/animation/groupAnimations</a> has more information on different aspects of the <strong class="source-inline">AnimationGroup</strong> properties and methods, but other than the previous looping logic, the usage of an <strong class="source-inline">AnimationGroup</strong> is very similar to an individual <strong class="source-inline">Animation</strong>. Having accomplished these tasks, all that’s left for the constructor is to delegate the <strong class="source-inline">CutSceneSegment.onEnd</strong> member property to <strong class="source-inline">AnimationGroup.onAnimationGroupEndObservable</strong>. Here’s what the entire <strong class="source-inline">constructor</strong> looks like:</p>
<pre class="source-code">&#13;
constructor(target, scene, ...animationSequence) {&#13;
    this._target = target;&#13;
    let ag = new AnimationGroup(target.name + &#13;
      "-animGroupCS", scene);&#13;
    for (var an of animationSequence) {&#13;
        ag.addTargetedAnimation(an, target);&#13;
    }&#13;
    this.animationGroup = ag;&#13;
    this.onEnd = ag.onAnimationGroupEndObservable;&#13;
    this._scene = scene;&#13;
}</pre>
<p>Finishing the <strong class="source-inline">CutSceneSegment</strong> class are the <strong class="source-inline">start</strong> and <strong class="source-inline">stop</strong> methods. These are extremely simple, and just call the appropriate function of <strong class="source-inline">this.animationGroup</strong>. When we want to loop a <strong class="source-inline">CutSceneSegment</strong> – not a typical usage – we can set the <strong class="source-inline">loopAnimation</strong> flag to true before calling <strong class="source-inline">start</strong>:</p>
<pre class="source-code">&#13;
start() {&#13;
    this.animationGroup.start(this.loopAnimation);&#13;
}&#13;
stop() {&#13;
    this.animationGroup.stop();&#13;
}</pre>
<p>This <a id="_idIndexMarker276"/>completes the <strong class="source-inline">CutSceneSegment</strong> class. It’s ready to be used in the code we’re just about to write for the <strong class="source-inline">SplashScene</strong> class, where we’ll be creating a segment for each panel in the storyboard before playing them in sequence. First, though, let’s add another set of building blocks for our scene – the animations driving the scene’s visuals.</p>
<h3>The Animations</h3>
<p>There are only three <a id="_idIndexMarker277"/>separate types of animations that <a id="_idIndexMarker278"/>we need for the scene. The keyframes and targets may be different, but the base property being animated is the same. Separate from any class declaration, add declarations for <strong class="source-inline">flipAnimation</strong>, <strong class="source-inline">fadeAnimation</strong>, and <strong class="source-inline">scaleAnimation</strong>. To keep the frame rates the same, we declare <strong class="source-inline">animationFps</strong> as <strong class="source-inline">const</strong>:</p>
<pre class="source-code">&#13;
const animationFps = 30;&#13;
const flipAnimation = new Animation("flip", "rotation.x",&#13;
  animationFps, Animation.ANIMATIONTYPE_FLOAT, &#13;
  ANIMATIONLOOPMODE_CONSTANT, <strong class="bold">true</strong>);&#13;
const fadeAnimation = new Animation("entranceAndExitFade",&#13;
  "visibility", animationFps,&#13;
  Animation.ANIMATIONTYPE_FLOAT,&#13;
  Animation.ANIMATIONLOOPMODE_CONSTANT, <strong class="bold">true</strong>);&#13;
const scaleAnimation = new BABYLON.Animation("scaleTarget",&#13;
  "scaling", animationFps, Animation.ANIMATIONTYPE_VECTOR3,&#13;
  Animation.ANIMATIONLOOPMODE_CYCLE, <strong class="bold">true</strong>);</pre>
<p>This should be pretty familiar by now, except for the highlighted <strong class="source-inline">true</strong> parameter; this instructs the Babylon.js animation engine to enable the animation to be blended with others. It’s not necessarily something we’re leveraging immediately in the scene, but it’s important to configure it correctly at the outset for when it’s needed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">In the BJS PlayGround, IntelliSense may sometimes confuse the <strong class="source-inline">BABYLON.Animation</strong> type with browser or DOM types with the same name. Adding the <strong class="source-inline">BABYLON</strong> prefix can help clear up confusion, but remember to remove it later – you won’t need it when the code is integrated locally.</p>
<p>The pieces have all been prepared and moved into place for us to start constructing the <strong class="source-inline">SplashScene</strong> class, where we’ll create and assemble CutSceneSegments into a complete scene. </p>
<h3>The SplashScene Class</h3>
<p>When designing<a id="_idIndexMarker279"/> a <a id="_idIndexMarker280"/>class or component’s code structure, a good way to start can be simply identifying and capturing any currently known variables of the state as class members, even if the value won’t be set until later. One such example of this is <strong class="source-inline">currentSegment</strong>. This property holds the currently playing <strong class="source-inline">CutSceneSegment</strong>. We’ll populate the various segments in the constructor, but by declaring the members outside of <strong class="source-inline">constructor</strong> (as opposed to defining it in <a id="_idIndexMarker281"/>the <strong class="bold">ctor</strong> – for example, <strong class="source-inline">this.foo = 3</strong>), we improve the readability of the code – something that is incredibly important in any code destined for production! Here are the class members that we’ll want to define:</p>
<ul>
<li><strong class="source-inline">currentSegment</strong></li>
<li><strong class="source-inline">poweredBy</strong></li>
<li><strong class="source-inline">babylonBillboard</strong></li>
<li><strong class="source-inline">communityProduction</strong></li>
<li><strong class="source-inline">dedication</strong></li>
<li><strong class="bold">onReadyObservable = new Observable()</strong></li>
<li><strong class="bold">skipRequested = false</strong></li>
</ul>
<p>Each of the preceding segments (save the highlighted ones, for obvious reasons) corresponds to a panel on the storyboard – in order of execution to help with readability. Though we won’t use it until later in this chapter, <strong class="source-inline">onReadyObservable</strong> is there to signal that all the assets have finished loading and the cutscene is ready to start. It’s a similar situation with <strong class="source-inline">skipRequested</strong> – later in this chapter, we’ll add the ability for players to skip the cut scene, so adding this now is legitimate. Adding the small pieces of code to hook it up is trivial too since we’re already working in that area, and it’s one less thing to worry about later. </p>
<p>There will be enough setup code in the constructor as it is, so a forward-thinker might consider adding method stubs to encapsulate each segment’s setup process! Turning our attention to the <strong class="source-inline">createScene</strong> function, we want to start seeing things as soon as possible, so let’s hook up one end of the logic, which will allow our segments to transition between each other.</p>
<p>Just as our previous PlayGround snippets have been structured, the <strong class="source-inline">SplashScene</strong> constructor needs a <strong class="source-inline">BABYLON.Engine</strong> instance passed as a parameter, which it uses to create the scene. Also similar is the sparse and simple <strong class="source-inline">createScene</strong> function, which is used purely in the PlayGround. In case a refresher is needed, here’s how to hook up the code with the Playground in the body of <strong class="source-inline">createScene</strong>:</p>
<pre class="source-code">&#13;
const splashScreen = new SplashScene(engine);&#13;
splashScreen.onReadyObservable.add(() =&gt;&#13;
  <strong class="bold">splashScreen.run()</strong>);&#13;
return splashScreen.scene;</pre>
<p>We need to be able to discretely control when <strong class="source-inline">SplashScene</strong> starts and stops, so the constructor isn’t going to be the place to start playing CutSceneSegments. Instead, we’ll add a <strong class="source-inline">run</strong> method (highlighted in the preceding snippet) to perform those duties in response to a signal from <strong class="source-inline">onReadyObservable</strong>. Now, as we enhance and expand <strong class="source-inline">SplashScene</strong>, we’ll be able to build off from this without having to worry about getting <a id="_idIndexMarker282"/>everything <a id="_idIndexMarker283"/>to start at the same time.</p>
<p>The <strong class="source-inline">SplashScreen.run()</strong> function looks very similar to the <strong class="source-inline">run</strong> function of the <strong class="source-inline">SpaceTruckerApplication</strong> run function if you squint enough and possibly stare unprotected at the sun for a bit.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Do not look directly at the sun without proper eye protection! Sunglasses, even ones that block UV radiation, are not sufficient protection for eyes, and permanent damage may result. On a related note, never take advice on what to do in the outdoors from a technical book on programming. HTH.</p>
<p>The reason they look similar to each other is that they both serve similar duties. Similar problems face similar solutions and all, so here we are:</p>
<pre class="source-code">&#13;
run() {&#13;
    this.currentSegment.start();&#13;
    let prior, curr = this.currentSegment;&#13;
    this.onUpdate = this.scene.onBeforeRenderObservable&#13;
    .add(() =&gt; {&#13;
        if (this.skipRequested) {&#13;
            this?.currentSegment.stop();&#13;
            this.currentSegment = null;&#13;
            return;&#13;
        }&#13;
        curr = this.currentSegment;&#13;
        if (prior !== curr) {&#13;
            this.currentSegment?.start();&#13;
        }&#13;
    });&#13;
}</pre>
<p>Even though this scene doesn’t use the <strong class="source-inline">function*</strong> generators that we saw in the previous chapter, it still qualifies as a simple type of state machine. The current state (represented by <strong class="source-inline">currentSegment</strong>) is polled on every frame and compared with the previous frame’s value. If they are different, then it means that a new segment has been swapped in and must have its <strong class="source-inline">start</strong> method invoked to continue the sequence. Because it’s so straightforward, and again because we’re already here, the logic for managing the use case where the player wishes to skip the cutscene and go straight to the Main Menu gets added as well. The only real items of note are the combination of setting <strong class="source-inline">this.currentSegment = null</strong> with the <strong class="source-inline">?.</strong> operators to prevent any attempt to<a id="_idIndexMarker284"/> call a<a id="_idIndexMarker285"/> method on an undefined value; if <strong class="source-inline">currentSegment</strong> is null (from the viewpoint of the code), then the cutscene either hasn’t started yet, or it has finished. </p>
<p>To provide a stable platform for creating the CutSceneSegments, there are still a few things that we need <a id="_idIndexMarker286"/>to add to the constructor logic, as shown in the following code:</p>
<pre class="source-code">&#13;
const scene = this.scene = new Scene(engine);&#13;
scene.clearColor = Color3.Black();&#13;
this.camera = new ArcRotateCamera("camera", 0, Math.PI / 2,&#13;
  5, Vector3.Zero(), scene);&#13;
this.light = new HemisphericLight("light", new Vector3(0,&#13;
  1, 0), scene);&#13;
this.light.groundColor = Color3.White();&#13;
this.light.intensity = 0.5;&#13;
const <strong class="bold">billboard</strong> = this.billboard =&#13;
  PlaneBuilder.CreatePlane("billboard", {&#13;
    width: 5,&#13;
    height: 3&#13;
}, scene);&#13;
billboard.rotation.z = Math.PI;&#13;
billboard.rotation.x = Math.PI;&#13;
billboard.rotation.y = Math.PI / 2;&#13;
const billMat = new StandardMaterial("stdMat", scene);&#13;
billboard.material = billMat;</pre>
<p>Setting up the scene, camera, and light should be pretty standard by now, and although the <strong class="source-inline">billboard</strong> <strong class="bold">Plane</strong> isn’t new either, it’s understandable to wonder at what role it plays in the scene. It’s pretty simple if you think about it. There’s <strong class="source-inline">camera</strong> to render the scene, there’s <strong class="source-inline">light</strong> to illuminate <strong class="source-inline">billboard</strong>, and there’s <strong class="source-inline">billboard</strong> to display our content – whatever that may be! We want the billboard to face perpendicular to the camera’s view, hence <a id="_idIndexMarker287"/>setting the initial rotations. The values may <a id="_idIndexMarker288"/>seem a bit weird, but they will all make sense shortly. Now that we have the framework to render the cutscene, it’s time to start defining the cutscene segments! We’ve gone quite a bit without saving (or not, if you’re well disciplined!), so now’s a good time to run the snippet and check for any obvious issues or errors before saving it for posterity. </p>
<h3>The “Powered By” CutScene Segment</h3>
<p>Referring to<a id="_idIndexMarker289"/> our initial storyboard, as our <a id="_idIndexMarker290"/>first segment, we’ve got a billboard displaying a stylized “Powered By” image. The timings make sense, and it’s perfectly serviceable. However, the problem with it is that it’s just plain outright <em class="italic">boring</em>. Let’s spice it up a bit by having the billboard spin around slowly throughout the segment using <strong class="source-inline">flipAnimation</strong> we created earlier. At the same time, we’ll apply <strong class="source-inline">fadeAnimation</strong> to fade the billboard in and out at the appropriate times. To keep the constructor to a manageable size, add a new class member function to <strong class="source-inline">SplashScene</strong> and call it <strong class="source-inline">buildPoweredByAnimations</strong>. Then, in the body of the function, start by declaring constants for each of the key timing events of the segment:</p>
<pre class="source-code">&#13;
        const start = 0;&#13;
        const enterTime = 2.5;&#13;
        const exitTime = enterTime + 2.5;&#13;
        const end = exitTime + 2.5;</pre>
<p>The values in the preceding snippet were arrived at through experimentation, so feel free to try out other values until you find something that works right for you. With absolute timing values computed, we can also compute the associated frame number for each timing event:</p>
<pre class="source-code">&#13;
        const entranceFrame = enterTime * animationFps;&#13;
        const beginExitFrame = exitTime * animationFps;&#13;
        const endFrame = end * animationFps;</pre>
<p>These frame numbers are important when we want to define the animations’ <strong class="bold">key frames</strong> array. Each separate animation will need a set of keyframes defined for it, so we’ll need a fade-in and fade-out set of keyframes and a set of rotation – or “flip” – keyframes. Remember, the value for fade animations corresponds to the <strong class="bold">alpha</strong> property, so it will be between 0 (completely transparent) and 1 (completely opaque). The <strong class="source-inline">flipKey</strong> values represent the <strong class="bold">y</strong> component of the target’s <strong class="bold">rotation</strong>:</p>
<pre class="source-code">&#13;
const keys = [&#13;
            { frame: start, value: 0 },&#13;
            { frame: entranceFrame, value: 1 },&#13;
            { frame: beginExitFrame, value: 0.998 },&#13;
            { frame: endFrame, value: 0 }&#13;
        ];&#13;
        <strong class="bold">fadeAnimation.setKeys(keys);</strong>&#13;
        const flipKeys = [&#13;
            { frame: start, value: Math.PI },&#13;
            { frame: entranceFrame, value: 0 },&#13;
            { frame: beginExitFrame, value: Math.PI },&#13;
            { frame: endFrame, value: 2 * Math.PI }&#13;
        ];&#13;
        <strong class="bold">flipAnimation.setKeys(flipKeys);</strong></pre>
<p>After defining each of the relevant keyframes according to the computed frame timings, it’s important to pass those keyframes onto the animation by calling <strong class="source-inline">setKeys</strong>. This works with our plan for reusing <strong class="source-inline">Animations</strong> because the keyframes are copied into the resulting <strong class="source-inline">TargetAnimation</strong> instance created when associated with its target; we can just call <strong class="source-inline">setKeys</strong> again <a id="_idIndexMarker291"/>with <a id="_idIndexMarker292"/>a new set of keyframes whenever needed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The pattern that we’re establishing here for this <strong class="source-inline">CutSceneSegment</strong> will be used for the rest of the segments. In other words, this will be on the test!</p>
<p>The final thing our <strong class="source-inline">buildPoweredByAnimations</strong> function needs to do is create and return a new <strong class="source-inline">CutSceneSegment</strong> that puts everything together:</p>
<pre class="source-code">&#13;
const seg0 = new CutSceneSegment(this.billboard,&#13;
  this.scene, fadeAnimation, flipAnimation);&#13;
return seg0;</pre>
<p>Back in the <strong class="source-inline">SplashScene</strong> constructor is where we’ll invoke the <strong class="source-inline">buildPoweredByAnimations</strong> function to create a <strong class="source-inline">poweredBy</strong> object variable. Assigning <strong class="source-inline">poweredBy</strong> to <strong class="source-inline">this.currentSegment</strong> will ensure that when <strong class="source-inline">run</strong> is called, the sequence is started. Following that, we need to load up the “Powered By” image as a texture that we can use with <strong class="source-inline">billMat</strong>. Since this involves an external image asset, add top-level declarations for the full URL to the image files (see the previous chapter for more on constructing the full GitHub URL for an asset). In this initial case, it’ll be a file called <a href="https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png">https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png</a>. Use that URL to construct a new <strong class="bold">texture</strong>, then assign the new <strong class="bold">texture</strong> to the previously-created <strong class="source-inline">billMat.diffuseTexture</strong> property. </p>
<p class="callout-heading">Important note</p>
<p class="callout">Make sure you load the texture before assigning it to the material!</p>
<p>When <a id="_idIndexMarker293"/>running, you<a id="_idIndexMarker294"/> should see the image on the surface of the billboard plane, which is a good way to test your work before saving it!</p>
<h3>Transitioning to the Next CutSceneSegment… and Beyond</h3>
<p>When a <strong class="source-inline">CutSceneSegment</strong> begins <a id="_idIndexMarker295"/>running, it may make certain assumptions about the current state of the different actors and set pieces involved in a scene. For instance, a lighting animation that dims a light in a specific pattern may need the intensity values to start at a specific level. At the same time, a given segment can’t “know” anything about other segments or their relationships – with a single crucial, albeit caveated exception. Upon completion of a <strong class="source-inline">CutSceneSegment</strong>, the <strong class="source-inline">onEnd</strong> <strong class="bold">observable</strong> notifies any interested parties of the fact, but the observer itself doesn’t know anything about its subscribers. This is why adding a delegate to handle the <strong class="source-inline">onEnd</strong> observable is the ideal solution – and at the same time is also the caveat! To keep some local variables in the constructor conveniently in scope, we can call <strong class="source-inline">onEnd.addOnce(() =&gt; { … })</strong>. The body of the function is where we want to tidy up objects in the scene, along with designating the next segment in the Splash Scene sequence:</p>
<pre class="source-code">&#13;
        poweredBy.onEnd.addOnce(() =&gt; {&#13;
            console.log("powered End");&#13;
            billMat.diffuseTexture = babylonTexture;&#13;
            billboard.rotation.x = Math.PI;&#13;
            this.light.intensity = 0.667;&#13;
            billboard.visibility = 0;&#13;
            this.currentSegment = babylonBillboard;&#13;
        });</pre>
<p>In our immediate case, the next segment is going to be the <strong class="source-inline">babylonBillboard</strong> segment, so make the last statement be <strong class="source-inline">this.currentSegment = babylonBillboard</strong> in the <strong class="source-inline">poweredBy.onEnd</strong> handler. Before that expression, we need to reset the <strong class="bold">rotation</strong> of the <strong class="bold">billboard</strong> to be front (perpendicular) facing to the camera, as well as swap <strong class="source-inline">billMat.diffuseTexture</strong> for the Babylon.js logo texture.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Before moving on to the next segment, it’s a good idea to try and run the PlayGround snippet to see how it looks and test it for any major errors. Opening the browser's Dev Tools to see logged messages can help you gain a sense of timing!</p>
<p>What’s that? The <a id="_idIndexMarker296"/>new segment doesn’t exist and neither does the <strong class="bold">Texture</strong>? That’s right – it’s time to Repeat the Process that we just did but this time, apply it to the next panel in the scene! “Repetition is the key to learning” is how the phrase commonly goes, and because it gets repeated so much it has got to make sense, so take the opportunity to review what we’ve just done and apply it using these values for the logic of the <strong class="source-inline">buildBabylonAnimation</strong> function: for the texture, use <a href="https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png">https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png</a> and for <strong class="source-inline">animationSequence</strong>, use <strong class="source-inline">fadeAnimation</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="" height="309" src="image/Table_5.01_B17266.jpg" width="1650"/>
</div>
</div>
<p>After adding the <strong class="source-inline">buildBabylonAnimation</strong> method, make sure to call it in the constructor so that you can subscribe to the new segment’s <strong class="source-inline">onEnd</strong> observable. In the <strong class="source-inline">babylonBillboard.onEnd</strong> handler, there’s no need to reposition the billboard since it didn’t move during this segment, but there is the matter of teeing up the next one, in what is hopefully a familiar cadence. </p>
<p>The next segment is called <strong class="source-inline">communityProduction</strong> and is functionally identical to the previous segment save for a different texture, located at <a href="https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png">https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png</a>. It is also just using <strong class="source-inline">fadeAnimation</strong>. Here are the main relevant <a id="_idIndexMarker297"/>timings and numbers needed:</p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="" height="311" src="image/Table_5.02_B17266.jpg" width="1650"/>
</div>
</div>
<p>Just like the previous segment, the <strong class="source-inline">communityProduction.onEnd</strong> handler will be responsible for setting the next segment – <strong class="source-inline">callToAction</strong> – and swapping <strong class="source-inline">billMat.diffuseTexture</strong> to the next one, which for lack of any better name will be called <strong class="source-inline">rigTexture</strong>. This texture is rendered onto the <strong class="source-inline">billboard</strong> mesh, where after fading in we’ll apply a looping animation to its <strong class="source-inline">scaling</strong> property to make it look more dynamic.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The storyboard indicates this panel is where copyright notices and such would go, but there’s no reason those can’t go someplace else that’s equally useful but less prominent. Instead, we’ll make the panel contain a Space-Trucker image, with the image slowly pulsing the scale and opacity in a ready-wait indication state, waiting for the player to interact.</p>
<p>In a short while, we will be adding some input management. To prepare for that, we’re going to need a way <a id="_idIndexMarker298"/>to display some appropriately formatted Text. In a block. A sort of <strong class="source-inline">TextBlock</strong>, as it were. Our <strong class="source-inline">SplashScreen</strong> is going to need to use the <strong class="bold">BABYLON.GUI</strong>.</p>
<h3>The Last Segment</h3>
<p>Our final <strong class="source-inline">CutSceneSegment</strong> – <strong class="source-inline">callToAction</strong> – follows a similar path that the others<a id="_idIndexMarker299"/> have taken, in that we use <strong class="source-inline">billBoard</strong> to display a <strong class="source-inline">diffuseTexture</strong> that fades into the scene. Here is where the segments start to diverge because instead of fading out again, we want it to fade in and then loop around without ever completely fading away. At the same time, we will use <strong class="source-inline">scaleAnimation</strong> to vary the scale of the <strong class="source-inline">billboard</strong> mesh along its <em class="italic">X</em>- and <em class="italic">Z</em>-axes. This will give the two-dimensional flat image a fake appearance of depth and scale as the animation cycles, which means that it looks cool! Here are the timings for each animation in the segment:</p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="" height="310" src="image/Table_5.03_B17266.jpg" width="1650"/>
</div>
</div>
<p>When the end timing is reached, we want <a id="_idIndexMarker300"/>our <strong class="bold">Call To Action</strong> (<strong class="bold">CTA</strong>) text to be made visible, inviting us to press a key or tap their touch screen to continue. In another of the Bard’s favorite tricks, here is some foreshadowing (not of the shading variety, the literary kind) – the <strong class="bold">CTA</strong> serves the subtle purpose of allowing the application to figure out what type of input the player wants to use. It’s an incredibly direct means of communication between two entities that otherwise have almost zero capability to understand each other, and it works because its binary (the irony! It burns!) simplicity conveys a user’s preference simply by them picking up the device and engaging an input. </p>
<p>Before we go there, we need to wrap up the implementation of the constructor by creating <strong class="source-inline">BABYLON.GUI.AdvancedDynamicTexture</strong> mentioned earlier: <strong class="source-inline">callToActionTexture</strong>. Creating, configuring the properties of, and adding a <strong class="source-inline">TextBlock</strong> to a GUI is a familiar exercise by now (though stick around for <a href="B17266_10_Final_AM.xhtml#_idTextAnchor207"><em class="italic">Chapter 10</em></a>, <em class="italic">Improving the Environment with Lighting and Materials,</em> where we’ll introduce <a id="_idIndexMarker301"/>the GUI Editor!), so the next listing should require very little explanation:</p>
<pre class="source-code">&#13;
// ... create billboard textures used in segments&#13;
let callToActionTexture = &#13;
    this.callToActionTexture =&#13;
      BABYLON.GUI.AdvancedDynamicTexture.&#13;
      CreateFullscreenUI("splashGui");&#13;
let ctaBlock = new TextBlock("ctaBlock", &#13;
    "Press any key or tap the screen to continue...");&#13;
ctaBlock.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;&#13;
ctaBlock.color = "white";&#13;
ctaBlock.fontSize = "16pt";&#13;
ctaBlock.verticalAlignment = &#13;
    ctaBlock.textVerticalAlignment =&#13;
      TextBlock.VERTICAL_ALIGNMENT_BOTTOM;&#13;
ctaBlock.paddingBottom = "12%";&#13;
<strong class="bold">ctaBlock.isVisible = false;</strong>&#13;
callToActionTexture.addControl(ctaBlock);&#13;
// ... call the builder functions&#13;
// ... Attach onEnd delegates</pre>
<p>One thing not to forget is to set the initial visibility of <strong class="source-inline">ctaBlock</strong> (highlighted) to <strong class="source-inline">false</strong>. If you want to display it sooner than in the handler for <strong class="source-inline">callToAction.onEnd</strong>, go ahead – it’s your game! Once you’ve gotten everything added to the constructor, give it a whirl and fix any errors that come up. Hit <strong class="bold">Save</strong>, then make sure you <a id="_idIndexMarker302"/>either put on headphones or can otherwise crank up your computer’s audio – it’s time to put in the theme song!</p>
<h3>Fading in the Title Music</h3>
<p>After working on<a id="_idIndexMarker303"/> this <strong class="source-inline">SplashScene</strong> for so long by <a id="_idIndexMarker304"/>now, it’s probably started to feel a bit bland, and that is something we will not accept any longer. In <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating the Application</em>, we added the Space-Truckers main theme song to the <strong class="bold">Main Menu</strong>. Here, we’ll be doing something very similar, but with a <strong class="source-inline">SplashScene</strong> twist. </p>
<p>Recall what was hopefully not-so-long-ago, when you read this gem?</p>
<p class="author-quote">“Though we won’t use it until later in this chapter, onReadyObservable is there to signal that all the assets have finished loading and the cutscene is ready to start.”</p>
<p>Well, “later in this chapter” starts right now. Since we’ve already put everything else into place, there are only four tasks left to wrap up this bad boy and take ‘er home:</p>
<ol>
<li value="1">Add a string to hold the URL to the song (or substitute your own) at <a href="https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a">https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a</a>.</li>
<li>Create a new <strong class="bold">Sound</strong> in the constructor, calling <strong class="source-inline">SplashScene.onReadyObservable.notifyObservers</strong> in the <strong class="bold">Sound’s</strong> <strong class="source-inline">readyToPlayCallback</strong>. Set the volume really low – <strong class="source-inline">0.01</strong> works nicely – to give the volume room to grow.</li>
<li>Add a call to <strong class="source-inline">this.music.play()</strong> in the <strong class="source-inline">SplashScene.run</strong> method.</li>
<li>Crank up the volume (also in the <strong class="source-inline">run</strong> method) over some time by calling <strong class="source-inline">this.music.setVolume(0.998, 500)</strong>.</li>
</ol>
<p>Do the usual drill of running, fixing issues, repeating as needed, and then saving. If you run into trouble or want to compare your results with a known “working” snippet, check out <a href="https://playground.babylonjs.com/#DSALXR">https://playground.babylonjs.com/#DSALXR</a>. Still can’t seem to get things working? Head over to the Space-Truckers GitHub Discussion boards at <a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a> and get help from the community, leave feedback or bug reports, and catch any updates to the code since this book was published. Having a runnable sample of what you want to accomplish in the PG is a great way to play around with ideas and concepts, but now, it’s time to metaphorically remove our more abstract and theoretical game designer’s hat and put on our more<a id="_idIndexMarker305"/> concrete and pragmatic software engineer’s <a id="_idIndexMarker306"/>work helmet – we’ll need those qualities as we integrate our PG code with the application.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Integrating the SplashScene</h2>
<p>The integration<a id="_idIndexMarker307"/> phase of the work is where the shiny, pretty, elegant PG Snippet meets the hard-faced ugly truth of reality. It’s the part where things are most likely to go wrong, and also where bugs in the application code can be uncovered. The reason this happens has little to do with the character and attributes of the person writing the code, even though it might feel that way sometimes. Any bugs or defects uncovered at this point are reflections of what wasn’t known at the time the original code was written, and that means there’s an opportunity to improve it!</p>
<h3>Seeing the Difference</h3>
<p>Because you <a id="_idIndexMarker308"/>have the benefit of this text to help guide your efforts, you’ll be spared having to track down and fix two issues uncovered in the <strong class="source-inline">SpaceTruckerApplication.js</strong> component, along with some other changes we’ll make structurally to the class. Including the two issues just mentioned, here is a list of the things we need to do to integrate <strong class="source-inline">SplashScreen</strong>:</p>
<ul>
<li>Add new files to <strong class="source-inline">/src - cutSceneSegment.js</strong> and <strong class="source-inline">splashScene.js</strong></li>
<li>Add appropriate imports to new files and copy over class definitions</li>
</ul>
<p>The <strong class="source-inline">spaceTruckerApplication.js</strong> file will see the greatest changes with these tasks:</p>
<ul>
<li>Remove the placeholder <strong class="source-inline">Promises</strong> that were used to simulate loading times in <strong class="source-inline">spaceTruckerApplication</strong>. With those gone, we can also remove the <strong class="source-inline">async</strong> designator from their hosting functions.</li>
<li>Instantiate the Scenes in the <strong class="source-inline">initialize</strong> method instead of previous locations.</li>
<li>Register an Observer in <strong class="source-inline">goToOpeningCutscene</strong> that listens for the <strong class="bold">SplashScreen’s</strong> <strong class="source-inline">onReady</strong> event.</li>
</ul>
<p>And finally, the two issues that would otherwise prevent the application from correctly progressing and rendering are as follows:</p>
<ul>
<li>(Issue) <strong class="source-inline">AppStateMachine</strong> should yield <strong class="source-inline">currentState</strong>.</li>
<li>(Issue) Logic in the <strong class="source-inline">engine.runRenderLoop</strong> callback needs to be a class-level function to access <strong class="source-inline">this</strong> properly. The problem can be resolved by extracting the arrow function into a class-level function – that is, <strong class="source-inline">this._engine.runRenderLoop(() =&gt; this.onRender());</strong>.</li>
</ul>
<p>The best way to <a id="_idIndexMarker309"/>visualize the changes is to view a <strong class="bold">diff</strong>, or difference, report between two revisions. The Git <strong class="bold">Source Control Management</strong> (<strong class="bold">SCM</strong>) system <a id="_idIndexMarker310"/>offers a huge amount of functionality when it comes to comparing the contents of a repository at two (or more) points in time, so let’s leverage that to help understand what needs to change to integrate <strong class="source-inline">SplashScreen</strong> into the app. </p>
<p>However it is accessed, the range of revisions we need to compare can be represented with the <strong class="source-inline">ch4...6db9f7e</strong> expression. Use this as an argument to <strong class="source-inline">git diff</strong> or paste it into a browser as the trailing path to <strong class="source-inline">&lt;repo URL&gt;/compare/&lt;revision range&gt;</strong>, or in this case, <a href="https://github.com/jelster/space-truckers/compare/ch4...6db9f7e">https://github.com/jelster/space-truckers/compare/ch4...6db9f7e</a>. </p>
<p>Depending on the particulars of your development environment, a <strong class="bold">diff</strong> will be displayed in a varying number of (pardon the pun) different ways. Regardless of the specific tool, almost every <strong class="bold">diff</strong> will organize its report by individual files that have changed between the given range of revisions. <strong class="bold">VSCode’s</strong> <strong class="bold">Timeline</strong> feature will show the commit history for an opened file; the diff can be viewed by clicking the revision in the <strong class="bold">Timeline</strong> pane.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Making a habit of examining these diffs closely before each commit or merge can improve your coding abilities, together with the quality of your code. A good sign that you are trying to do too much in a single commit is having a complicated and long changeset. Break the work into smaller components and commit each separately, and not only will any reviewers of<a id="_idIndexMarker311"/> your <strong class="bold">Pull Request</strong> (<strong class="bold">PR</strong>) thank you, but you’ll find yourself moving faster and with greater confidence.</p>
<p>The <strong class="bold">GitHub</strong> web interface can also be useful for viewing differences between <strong class="bold">revisions</strong>, <strong class="bold">branches</strong>, and even <strong class="bold">forks</strong> (also <a id="_idIndexMarker312"/>known as <strong class="bold">upstream repositories</strong>). Navigating through and understanding the different reports is a key skill for people who wish to become skilled in software development, but it can be tough to block out the inevitable noise that <a id="_idIndexMarker313"/>comes with viewing so much information. GitHub will try to do some of this for you, by collapsing large diffs by default, for instance, but the best way to deal with poor a signal:noise ratio is unfortunately not retroactive; it is only useful when applied at the time of <strong class="bold">commit</strong> or <strong class="bold">push</strong>. This solution is to be mindful of and structure commits with a high signal:noise ratio from the beginning. Here are some tips for helping with that:</p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="" height="271" src="image/Table_5.04_B17266.jpg" width="1650"/>
</div>
</div>
<p>Using the diff as a reference guide when needed, try to accomplish the activities listed earlier on your own. Of course, since you’re already looking at the diff, you should feel free to simply pull down the code at <strong class="bold">commit 6db9f7e</strong> if you’d simply like to resume following along right away. The following figure shows a still capture of where you should end up after running the application, clicking the <strong class="bold">Launch</strong> button, and after the conclusion of the<a id="_idIndexMarker314"/> Splash Screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 5.2 – Splash Screen finished and waiting for user input&#13;&#10;" height="995" src="image/Figure_5.02_B17266.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Splash Screen finished and waiting for user input</p>
<p>We’ll get into the nitty-gritty details of all of the items – some familiar, some new – contained in that commit’s <strong class="bold">patch</strong> soon enough, but before we do, let’s quickly recap what we’ve accomplished so far.</p>
<p>Starting with a set of storyboard panels depicting snapshots of the scene at various points in time, we used the boards to pin down timings for the various animations and transitions involved. Then, we crafted some reusable code to define a <strong class="source-inline">CutSceneSegment</strong>, along with other logic relating to animating objects. Finally, we wrote the containing <strong class="source-inline">SplashScreen</strong> class and its attendant asset and <strong class="source-inline">CutSceneSegment</strong> orchestration logic that comprises the full timeline of the scene. That’s a lot to accomplish – don’t neglect to acknowledge that!</p>
<p>Next, we’ll be moving on to one of the more under-appreciated areas of game development: input <a id="_idIndexMarker315"/>systems. Because of its importance, we’ll be devoting the rest of this chapter to going over how the Space-Truckers input system functions and how it is implemented.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Designing the Input System</h1>
<p>The topic of<a id="_idIndexMarker316"/> the <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) often focuses quite<a id="_idIndexMarker317"/> heavily on visual elements, layout, and design. For the majority of web applications, the basics of tracking a pointer, touches, or taps along with keyboard input are handled by the web browser, which in turn delegates many responsibilities, such as hardware driver interfacing to the underlying <strong class="bold">Operating System</strong> (<strong class="bold">OS</strong>). When <a id="_idIndexMarker318"/>using a web-native application library such as Babylon.js, developers can take advantage of these already-present abstractions to make it quick and easy to add user interaction elements to their scenes. In this section, we’ll learn how to add the application scaffolding that can support multiple types of inputs on-the-fly, followed by implementing a way to map arbitrary inputs to actions or commands in the game.</p>
<p>It’s said that imitation is the sincerest form of flattery, so let’s flatter the Babylon.js team by “stealing” (called “researching” in polite company) the camera input management code. Using<a id="_idIndexMarker319"/> the <strong class="bold">FreeCamera</strong> as an example (read about it at <a href="https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts">https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts</a>), here is how the data flows between the controller and the application:</p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 5.3 – Flow of input from a Human Input Device (HID) through the Web Browser’s APIs, to the HTML/Canvas and into Babylon.js and the various components of the FreeCamera’s input system" height="1143" src="image/Figure_5.03_B17266.jpg" width="1198"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Flow of input from a Human Input Device (HID) through the Web Browser’s APIs, to the HTML/Canvas and into Babylon.js and the various components of the FreeCamera’s input system</p>
<p>Data starts at the top <a id="_idIndexMarker320"/>with the device itself sending data to the connected host OS, which (via its device driver interface) translates that raw input data into structures compatible and familiar to the web browser or native host interfaces. Eventually, it makes its way into Babylon.js, where it is massaged, processed, filtered down, and passed around until it reaches the target of its affections: the <strong class="bold">FreeCamera</strong>. Here is a PG that represents a slightly simplified <a id="_idIndexMarker321"/>version of the actual input system we’ll be discussing now – use it as a working reference if you get lost: <a href="https://playground.babylonjs.com/%2378MJJ8%2364">https://playground.babylonjs.com/#78MJJ8#64</a>.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Defining the Main Menu Control Scheme</h2>
<p>Although we won’t<a id="_idIndexMarker322"/> be defining <a id="_idIndexMarker323"/>control maps for the game phases at this time, the foundations we’ll establish with this pattern will make it quick, painless, and easy to add whatever arbitrary control maps later as they become necessary. The table shows the various inputs and actions that we’ll be interested in handling in the Menu system:</p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 5.4 – Menu controls mapped to various inputs&#13;&#10;" height="513" src="image/Figure_5.04_B17266.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Menu controls mapped to various inputs</p>
<p>When it comes to the basic keyboard and (mouse) pointer interactions, the Babylon.js <strong class="bold">Scene</strong> offers the <strong class="source-inline">onKeyboardObservable</strong> and <strong class="source-inline">onPointerObservable</strong> properties to allow subscribers to be notified of keyboard and mouse (touch) interactions, respectively. <strong class="source-inline">GamepadManager</strong> (accessible from a scene’s <strong class="source-inline">gamepadManager</strong> property) and <strong class="source-inline">VirtualJoystick</strong> are useful for adding gamepads and their virtual touch equivalents for when mouse and keyboard aren’t the goal. You can read<a id="_idIndexMarker324"/> more about <a id="_idIndexMarker325"/>these in the Babylon.js docs at <a href="https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks">https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks</a> and <a href="https://doc.babylonjs.com/divingDeeper/input/gamepads">https://doc.babylonjs.com/divingDeeper/input/gamepads</a>. </p>
<p class="callout-heading">Important note</p>
<p class="callout">As alluded to earlier, the topic of input handling is sufficiently complex that it would take a great deal of the finite space available in these pages to review all the code line by line, so the code that is listed will be highlighted in sections under a particular area of discussion. Don’t worry about not being able to follow along, though – you can still examine the full source code and the links to PG snippets won’t be going away either! </p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Mapping Input Data</h2>
<p>Although the <a id="_idIndexMarker326"/>table of controls from the previous section is something that would work well in the game or application’s user manual, it’s less clear how the information in that table can be leveraged in this application. </p>
<p>A JavaScript <strong class="bold">object map</strong> (or <strong class="bold">hashmap</strong>) refers <a id="_idIndexMarker327"/>to a regular JS object where the string name <a id="_idIndexMarker328"/>for each property is the key to its value. Using object-key notation (for example, accessing an object’s values, as in <strong class="source-inline">foo[“property”]</strong>), indices will be represented in the new source file we’ll call <strong class="source-inline">inputActionMaps.js</strong>. In it, we will define all the various object constants and helper functions relating to – as suggested by the name – mapping inputs to actions: </p>
<pre class="source-code">&#13;
const inputControlsMap = {&#13;
    /* Keyboard Mappings */&#13;
    w: 'MOVE_UP', 87: 'MOVE_UP',&#13;
    s: 'MOVE_DOWN', 83: 'MOVE_DOWN',&#13;
    a: 'MOVE_LEFT', 65: 'MOVE_LEFT',&#13;
    d: 'MOVE_RIGHT', 68: 'MOVE_RIGHT',&#13;
    //...&#13;
    PointerTap: 'ACTIVATE',&#13;
    //...&#13;
    button1: 'ACTIVATE', buttonStart: 'ACTIVATE',&#13;
    buttonBack: 'GO_BACK', button2: 'GO_BACK',&#13;
    dPadDown: 'MOVE_DOWN', lStickDown: 'MOVE_DOWN',&#13;
};&#13;
export default { inputControlsMap, ...};</pre>
<p>On the left-hand side (the property name or <strong class="bold">key</strong>) of the object map is every unique potential input index that we are interested in handling. We include every potential combination of input codes that should apply to this action; this includes the integer codes, as well as the character keys, to allow interchangeability between different types of keyboard input events; this will also make it easier to add additional input methods in the future. You’ll notice that we’ve defined our own input indexes as well, in the form of the <strong class="source-inline">button1</strong> and <strong class="source-inline">buttonStart</strong> members. Although it seems duplicative and redundant, having a layer of indirection between the actual device codes and the logic handling them<a id="_idIndexMarker329"/> gives the system a ton of flexibility. </p>
<p>When it comes to handling the various types of gamepad input, indirection comes in handy once again. The <strong class="source-inline">BABYLON.DeviceType</strong> enumeration defines constants for each supported type of gamepad device. We’ll use another object map to store how each particular device’s inputs matches up to our defined <strong class="source-inline">inputControlsMap</strong>:</p>
<pre class="source-code">&#13;
const gamePadControlMap = {&#13;
    /* deviceType */&#13;
    2: [&#13;
        { 0: 'button1' }, // BABYLON.Xbox360Button.A&#13;
        { 1: 'button2' },&#13;
        { 2: 'button3' },&#13;
        { 3: 'button4' }&#13;
    ]&#13;
};</pre>
<p>The preceding code is what the mapping for the Xbox360 controller looks like at a very basic level. As the comment indicates, each object in the <strong class="source-inline">deviceType</strong> array corresponds to a different input index on the controller. </p>
<p>In a moment, we’ll learn how to use this mapping information at runtime to resolve inputs from connected devices, but first, let’s get a bit of a wider perspective by taking a small step back – not too far, we don’t want to get overwhelmed in it all! The following diagram illustrates <a id="_idIndexMarker330"/>the different concerns we’ll need to address to be able to handle input in Space-Truckers:</p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 5.5 – Handling input Part 1 of 4. This section covers mapping input data from multiple devices and types into standardized structures that can be resolved to game or application-level actions&#13;&#10;" height="1024" src="image/Figure_5.05_B17266.jpg" width="835"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Handling input Part 1 of 4. This section covers mapping input data from multiple devices and types into standardized structures that can be resolved to game or application-level actions</p>
<p>Entire books can be written just on the topic of designing the input models and such, but the important thing to take away here is that the goal of the code we’re writing or are about to write is to hide<a id="_idIndexMarker331"/> away (or <strong class="bold">abstract</strong>) the details of how inputs are processed from the game’s core logic. The game logic doesn’t care or need to know about whether a user wants <a id="_idIndexMarker332"/>to move their truck with a keyboard or a gamepad – it just needs to know that the user wants to move their truck and in what direction!</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Input Management</h2>
<p>When it comes <a id="_idIndexMarker333"/>to managing the specific inputs and devices, <strong class="source-inline">SpaceTruckerInputManager</strong> (follow along with the code at <a href="https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js">https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js</a>) is responsible for managing the lower-level device management tasks of subscribing and unsubscribing to/from device events, retrieving input from the underlying Babylon.js input abstraction layers, and preparing it for being processed into actions.</p>
<p><strong class="bold">Coalescing</strong>, or<a id="_idIndexMarker334"/> aggregating input from multiple devices, can be both tricky and tedious – not the best combination for anything requiring concentration and recall as coding does. Tackling the tricky part by breaking down the complexity is the first step; the second step is paradoxically (or perhaps ironically) more complicated than the first step because it is more up to the individual involved to find ways to keep chugging through to the end. </p>
<h3>Addressing Inputs</h3>
<p>One of the most<a id="_idIndexMarker335"/> common decisions that needs to be made about a potential software design is where (in the code) to assign various responsibilities. It can sometimes be tempting to just put all the logic, data, and code into a single file for convenience’s sake, but unless this is all taking place in the PG, enhancing and maintaining the application will quickly become an uncontrollable nightmare in every practical respect. </p>
<p>One way that <a id="_idIndexMarker336"/>the <strong class="bold">SpaceTruckerInputManager</strong> (<strong class="bold">STIM</strong>) manages complexity is by maintaining individual and separate device-specific registration logic. Different devices present their data in different ways; some types of inputs lend themselves to Observables that can be subscribed to receive input events:</p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 5.6 – Observables propagating events – onKeyDownObservable in this case" height="231" src="image/Figure_5.06_B17266.jpg" width="1011"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Observables propagating events – onKeyDownObservable in this case</p>
<p>Others are more <a id="_idIndexMarker337"/>suited to have their state polled on a frame-by-frame basis:</p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 5.7 – Analog inputs (joystick axis, triggers, and more) need to be polled to get the current state of the device" height="395" src="image/Figure_5.07_B17266.jpg" width="998"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Analog inputs (joystick axis, triggers, and more) need to be polled to get the current state of the device</p>
<p>To make things more fun, many devices mix paradigms, with some inputs exposed via observable events and some only available via polling! All this data is aggregated into an <strong class="source-inline">inputMap</strong> <strong class="bold">hashmap</strong> (there <a id="_idIndexMarker338"/>it is again!) that contains the current state of all registered inputs. </p>
<p>The Input Manager must deal with either scenario with aplomb and grace according to Etiquette, and so it shall. Leaving a subscription dangling after the subscriber has gone away is considered poor form, so we must ensure the Input Manager also cleans up after itself like a good houseguest. That means we need to track our subscriptions and their sources so that we can use <strong class="source-inline">Observable.remove</strong>. Fortunately, we also have a parallel need for <a id="_idIndexMarker339"/>the Input Manager to have access to a given Scene.</p>
<h3>Input Registration</h3>
<p>Whenever <a id="_idIndexMarker340"/>a <strong class="bold">Scene</strong> wants to be able to accept input, it must register that intent. From the perspective of <strong class="source-inline">SpaceTruckerInputManager</strong>, it doesn’t matter who is invoking <strong class="source-inline">registerInputForScene</strong>, it just needs <strong class="source-inline">sceneToRegister</strong> into its <strong class="source-inline">inputSubscriptions</strong> array. The object map that’s added to the list is keyed by the scene being registered because the lifetime of <strong class="source-inline">SpaceTruckerInputManager</strong> follows a <strong class="bold">Singleton</strong> pattern (for <a id="_idIndexMarker341"/>example, there is only one instance of the <strong class="bold">STIM</strong> in the application). We do this because we want to be able to control when and how a particular scene is routed input at runtime, and to be good neighbors, we hook ourselves up to <strong class="source-inline">Scene.onDisposeObservable</strong> (highlighted). The subscriptions array contains the returned set of <strong class="bold">Observers</strong> from each of the enabled device types (<strong class="source-inline">enableKeyboard</strong>, <strong class="source-inline">enableMouse</strong>, and <strong class="source-inline">enableGamePad</strong>):</p>
<pre class="source-code">&#13;
registerInputForScene(sceneToRegister) {&#13;
    logger.logInfo("registering input for scene",&#13;
      sceneToRegister);&#13;
    const inputSubscriptions = this.inputSubscriptions;&#13;
    const registration = {&#13;
        scene: sceneToRegister, subscriptions: [&#13;
            this.enableKeyboard(sceneToRegister),&#13;
            this.enableMouse(sceneToRegister),&#13;
            this.enableGamepad(sceneToRegister)&#13;
        ]&#13;
    };&#13;
    <strong class="bold">sceneToRegister.onDisposeObservable</strong>.add(() =&gt;&#13;
      this.unregisterInputForScene(sceneToRegister));&#13;
    inputSubscriptions.push(registration);&#13;
    sceneToRegister.attachControl();&#13;
}</pre>
<p>The aforementioned device-enable functions return an object with a very specific shape – and that shape is one of the keys (pardon the deep-running pun here) to making everything <a id="_idIndexMarker342"/>come together smoothly.</p>
<h3>Checking Inputs</h3>
<p>To deal with inputs<a id="_idIndexMarker343"/> requiring polling, each type of device needs to have a <strong class="source-inline">checkInput</strong> method that knows how to retrieve input and place it into the <strong class="source-inline">SpaceTruckerInputManager.inputMap</strong> hash map. For devices that exclusively utilize observables in their input surfacing, the <strong class="source-inline">checkInput</strong> function can be a no-op or empty function that does nothing. Devices with mixed or solely axis inputs (for example, thumbsticks, joysticks, triggers – any input type that returns an input that isn’t always a 0 or 1) implement <strong class="source-inline">checkInput</strong> to read the gamepad’s state every time it is called (every frame). Since things such as normalizing input are concerns shared across different models of gamepads, the utility functions in <strong class="source-inline">inputActionMap.js</strong> (referenced as <strong class="source-inline">SpaceTruckerControls</strong> in the following code block) are leveraged to ensure that axis input values are in the range of <em class="italic">-1 &lt;= value &lt;= 1</em>. Other functions take those normalized values and map them to a particular input direction based on the inputs crossing a threshold value:</p>
<pre class="source-code">&#13;
const checkInputs = () =&gt; {&#13;
    const iMap = this.inputMap;&#13;
    if (!this.gamepad) { return; }&#13;
// handle quantitative or input that reads between 0 and 1&#13;
//(on/off) inputs are handled by the onButton/ondPad Observables&#13;
    let LSValues = <strong class="bold">SpaceTruckerControls</strong>&#13;
<strong class="bold">        .normalizeJoystickInputs(this.gamepad.leftStick);</strong>&#13;
    <strong class="bold">SpaceTruckerControls</strong>&#13;
<strong class="bold">        .mapStickTranslationInputToActions(LSValues, iMap);</strong>&#13;
    let RSValues = SpaceTruckerControls&#13;
        .normalizeJoystickInputs(this.gamepad.rightStick);&#13;
    &#13;
    SpaceTruckerControls&#13;
        .mapStickRotationInputToActions(RSValues, iMap);&#13;
};</pre>
<p>The preceding code block is from <strong class="source-inline">spaceTruckerInput.js</strong> and is contained as part of the <strong class="source-inline">checkInputs</strong> function object defined in the <strong class="source-inline">enableGamepads</strong> method. For any type of analog input device, there will be a certain amount of imprecision and noise in the inputs. To<a id="_idIndexMarker344"/> deal with that, the input is “normalized” (that is, values that are reported are in the range of <strong class="source-inline">-1 &lt;= x &lt;= 1</strong>) using static methods.</p>
<h3>Disposing Input Subscriptions</h3>
<p>The other <a id="_idIndexMarker345"/>property of the <strong class="source-inline">enableDevice</strong> contract is the <strong class="source-inline">dispose</strong> method. This is a function, like <strong class="source-inline">checkInputs</strong>, that contains all the specific logic needed to unsubscribe any observers and clean up after itself. Those two properties allow the consumers of <strong class="source-inline">inputManager</strong> to remain completely ignorant about the specifics of how input is collected by the application. This makes the code simpler and gives us more attention to focus on accomplishing other things (such as getting through the rest of this chapter). This is what the return value of the <strong class="source-inline">enableGamepad</strong> method looks like:</p>
<pre class="source-code">&#13;
return {&#13;
            checkInputs,&#13;
            dispose: () =&gt; {&#13;
                this.gamepad = null;&#13;
                manager.onGamepadConnectedObservable&#13;
                   .remove(gamepadConnectedObserver);&#13;
                manager.onGamepadDisconnectedObservable&#13;
                   .remove(gamepadDisconnectedObserver);&#13;
            }&#13;
        };</pre>
<p>All this talk about observers, observables, and subscriptions can be confusing. That’s the complexity you’re tasting, but hopefully, that taste will yield to a more pleasing robust, functional<a id="_idIndexMarker346"/> flavor as we discuss the final piece of the <strong class="bold">STIM</strong>: the <strong class="source-inline">getInputs</strong> method.</p>
<h3>The getInputs Method</h3>
<p>Although <a id="_idIndexMarker347"/>we <a id="_idIndexMarker348"/>want a scene to check inputs every frame, we haven’t defined what will invoke that logic yet, or where it will occur in the application. For the <strong class="bold">STIM</strong>, that is a largely irrelevant question. The <strong class="source-inline">getInputs</strong> function takes a Scene as its sole parameter. The <strong class="bold">Scene</strong> is used to look up the inputSubscriptions registered to that scene, captured as the <strong class="source-inline">sceneInputHandler</strong> local constant. Each of the subscriptions in the <strong class="source-inline">sceneInputHandler.subscriptions</strong> array has its <strong class="source-inline">checkInputs</strong> function invoked as part of a <strong class="source-inline">forEach</strong> loop; recall that each subscription represents a specific input type and that the <strong class="source-inline">checkInputs</strong> function populates <strong class="source-inline">SpaceTruckerInputManager.inputMap</strong> with the latest values. </p>
<p>With <strong class="source-inline">inputMap</strong> containing all the various inputs to the Screen, an array of entries is iterated across and mapped into an input event structure containing the <strong class="bold">action</strong> name or <strong class="bold">key</strong>, along with any contextual event information in the form of the <strong class="source-inline">lastEvent</strong> property:</p>
<pre class="source-code">&#13;
getInputs(scene) {&#13;
    const sceneInputHandler = <strong class="bold">this.inputSubscriptions</strong>&#13;
<strong class="bold">          .find(is =&gt; is.scene === scene);</strong>&#13;
    if (!sceneInputHandler) {&#13;
        return;&#13;
    }&#13;
    sceneInputHandler.subscriptions&#13;
        .forEach(s =&gt; <strong class="bold">s.checkInputs()</strong>);&#13;
    const im = this.inputMap;&#13;
    const ik = Object.keys(im);&#13;
    const inputs = ik&#13;
        .map((key) =&gt; {&#13;
            <strong class="bold">return { </strong>&#13;
<strong class="bold">                action: controlsMap[key], </strong>&#13;
<strong class="bold">                lastEvent: im[key] </strong>&#13;
<strong class="bold">            };</strong>&#13;
        });&#13;
    if (inputs &amp;&amp; inputs.length &gt; 0) {&#13;
        this.onInputAvailableObservable&#13;
            .notifyObservers(inputs);&#13;
    }&#13;
    <strong class="bold">return inputs;</strong>&#13;
}</pre>
<p>The resulting <a id="_idIndexMarker349"/>inputs<a id="_idIndexMarker350"/> array is then returned to callers, as well as getting syndicated via <strong class="source-inline">onInputAvailableObservable</strong> (currently unused). Note the large gap in this discussion, namely the question as to where and who calls the <strong class="source-inline">getInputs</strong> function. This is indeed a good question, but it is not one that <strong class="source-inline">SpaceTruckerInputManager</strong> needs to concern itself with – that is a matter for our next topic: Input Processing:</p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 5.8 – Two of the four components covered so far" height="1391" src="image/Figure_5.08_B17266.jpg" width="1142"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Two of the four components covered so far</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Input Processing</h2>
<p>Mapping raw inputs <a id="_idIndexMarker351"/>to game or application inputs is a crucial part of Input Management, the two components of our input system that we’ve covered so far. That’s potentially enough to be sufficient for a relatively simple application or game, but Space-Truckers has different needs. It needs to be able to selectively route the input to Screens without needing to know anything about the details of that input. It also needs to handle input state – not just the current, but past as well. </p>
<p>There is a point whereupon it becomes rude to ask additional favors from a distinguished houseguest, and if our houseguest is <strong class="source-inline">SpaceTruckerInputManager</strong>, then asking it to take on these responsibilities is… well, it’s just too much. We need another component to take up the burden: <strong class="source-inline">SpaceTruckerInputProcessor</strong>. </p>
<h3>Attaching Controls</h3>
<p>Similar <a id="_idIndexMarker352"/>to the <strong class="source-inline">registerInputForScene</strong> and <strong class="source-inline">unRegisterInputForScene</strong> methods of its sibling, <strong class="source-inline">SpaceTruckerInputManager</strong>, the <strong class="bold">SpaceTruckerInputProcessor</strong> (<strong class="bold">STIP</strong>) has<a id="_idIndexMarker353"/> the <strong class="source-inline">attachControl</strong> and <strong class="source-inline">detachControl</strong> functions. Unlike <a id="_idIndexMarker354"/>its <a id="_idIndexMarker355"/>sibling, though, the STIP functions do not accept a <strong class="bold">Scene</strong> as a parameter. That is because a given STIP instance is tied to a given <strong class="bold">Screen</strong> that it will be performing input processing against. It is the <strong class="source-inline">SpaceTruckerInputProcessor.attachControl</strong> method that calls <strong class="source-inline">registerInputForScene</strong> in the first place:</p>
<pre class="source-code">&#13;
attachControl() {&#13;
    if (!this.controlsAttached) {&#13;
        this.scene.attachControl();&#13;
        <strong class="bold">this.inputManager.registerInputForScene(this.scene);</strong>&#13;
        this.onInputObserver =&#13;
          this.inputManager.onInputAvailableObservable&#13;
        .add((inputs) =&gt; {&#13;
           this.inputAvailableHandler(inputs);&#13;
        });&#13;
        this.controlsAttached = true;&#13;
    }&#13;
}</pre>
<p>Also, as part of attaching control to the Screen, <strong class="source-inline">inputManager.onInputObservable</strong> gets <strong class="source-inline">SpaceTruckerInputProcessor.inputAvailableHandler</strong> subscribed to be notified when a new set of inputs has been received. It’s a simple little method that just pushes received <a id="_idIndexMarker356"/>inputs into <strong class="source-inline">inputQueue</strong>, which is processed as part of the <strong class="source-inline">update</strong> method.</p>
<h3>Update</h3>
<p>This is where <a id="_idIndexMarker357"/>the <a id="_idIndexMarker358"/>magic happens. After a quick check to ensure that it’s OK to be handling inputs, <strong class="source-inline">inputManager.getInputs</strong> is invoked, which, in turn, triggers an out-of-function process that ends up populating <strong class="source-inline">inputQueue</strong> with information. This may not happen in time for the rest of the update function logic, but that’s OK because it will just be handled in the next frame:</p>
<pre class="source-code">&#13;
update() {&#13;
    if (!this.controlsAttached) {&#13;
        return;&#13;
    }&#13;
    <strong class="bold">this.inputManager.getInputs(this.scene);</strong>&#13;
    <strong class="bold">this.lastActionState = this.actionState;</strong>&#13;
    const inputQueue = this.inputQueue;&#13;
    while (inputQueue.length &gt; 0) {&#13;
        let input = inputQueue.pop();&#13;
        <strong class="bold">this.inputCommandHandler(input);</strong>&#13;
    }&#13;
}</pre>
<p>The current map of actions to state (<strong class="source-inline">this.actionState</strong>) is copied into <strong class="source-inline">this.lastActionState</strong> to preserve it for later usage in processing inputs. Then, <strong class="source-inline">inputQueue</strong> is drained of <a id="_idIndexMarker359"/>items one by one and<a id="_idIndexMarker360"/> dispatched by <strong class="source-inline">inputCommandHandler</strong>.</p>
<h3>InputCommandHandler</h3>
<p>This deceptively <a id="_idIndexMarker361"/>simple method does a <a id="_idIndexMarker362"/>lot more than it might seem at first glance. That’s all due to the power of (third time’s the<a id="_idIndexMarker363"/> charm!) <strong class="bold">hashmaps</strong>. In this case, there are a couple of layers of this type of shenanigans going on, but right now, we’ll focus solely on <strong class="source-inline">actionMap</strong>. The <strong class="source-inline">actionMap</strong> class member is an object map that relates a game action (<strong class="source-inline">ACTIVATE</strong>) to an executable function in the hosting Screen – a topic we’ll delve into shortly – which it uses to look up and invoke the game logic attached to the given action:</p>
<pre class="source-code">&#13;
inputCommandHandler(input) {&#13;
    input.forEach(i =&gt; {&#13;
        const inputParam = i.lastEvent;&#13;
        const actionFn = this.actionMap[i.action];&#13;
        if (actionFn) {&#13;
            const priorState = this.lastActionState &#13;
                ? this.lastActionState[i.action] : null;                  &#13;
            this.actionState[i.action] =&#13;
              actionFn({priorState}, inputParam);&#13;
        }&#13;
    });&#13;
}</pre>
<p>By convention, we pass an object with <strong class="source-inline">lastActionState</strong>, along with the event object passed along from <strong class="source-inline">inputManager</strong>, and store the return value in a previously mentioned object map, <strong class="source-inline">actionState</strong>. Each individual <strong class="source-inline">actionFn</strong> decides what to return, as well as what to do with the passed-in state value without <strong class="source-inline">inputProcessor</strong> ever needing to deal <a id="_idIndexMarker364"/>with the specifics – nice <a id="_idIndexMarker365"/>and tidy!</p>
<h3>The buildActionMap Function</h3>
<p>What <strong class="source-inline">buildActionMap</strong> does<a id="_idIndexMarker366"/> is what <a id="_idIndexMarker367"/>is <a id="_idIndexMarker368"/>known as <strong class="bold">metaprogramming</strong> or writing code that writes code. Going through each of the action parameters passed in <strong class="source-inline">actionList</strong>, the <strong class="source-inline">actionDef.action</strong> string property is used to look up a function with the same name in the <strong class="source-inline">SpaceTruckerInputProcessor.screen</strong> object:</p>
<pre class="source-code">&#13;
buildActionMap(actionList, createNew) {&#13;
    if (createNew) {&#13;
        this.actionMap = {};&#13;
    }&#13;
    actionList.forEach(actionDef =&gt; {&#13;
      const action = actionDef.action;&#13;
        const actionFn = this.screen[action];&#13;
        if (!actionFn) {&#13;
            return;&#13;
        }&#13;
        this.actionMap[action] = actionDef.shouldBounce() ? &#13;
             bounce(actionFn, 250, this) : actionFn;&#13;
    });&#13;
}</pre>
<p>If located, <strong class="source-inline">actionMap</strong> is populated with the located function after optionally wrapping it with a pre-processing <strong class="source-inline">bounce</strong> function to prevent it from being invoked too many times in a given period… which<a id="_idIndexMarker369"/> brings<a id="_idIndexMarker370"/> us to the final component of our input system: Action Handling:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><img alt="Figure 5.9 – Input Processing, Input Management, and Mapping of Input data covered. Just Action Handling remains" height="1416" src="image/Figure_5.09_B17266.png" width="1160"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Input Processing, Input Management, and Mapping of Input data covered. Just Action Handling remains</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Action Handling</h2>
<p>We’ve spent<a id="_idIndexMarker371"/> the last few pages diving through multiple levels of abstraction and indirection, and we’re now finally at the point where it all starts to do something – the Action Handling. While the previous steps were confined to a specific class or instance type, the action handlers are the screens themselves.</p>
<h3>Conventional Actions</h3>
<p>Sounds like the <a id="_idIndexMarker372"/>name of a bad early 2000s cover band, but it’s a term for how we go about naming and describing our action functions on a given screen. It’s a lot simpler than it sounds: for every action that a <strong class="bold">Screen</strong> would like to handle, create a <strong class="bold">function</strong> with the same name as the action. If you want to track the previous state of the given action, accept a <strong class="source-inline">state</strong> parameter. Should you need to get more information about the input event, add a second parameter to the function to accept an <strong class="source-inline">inputEvent</strong>. </p>
<p class="callout-heading">Important note</p>
<p class="callout">Remember, an action is a game-specific concept, such as <strong class="source-inline">MOVE_UP</strong>, or <strong class="source-inline">ACTIVATE</strong>. Those are just the names given for this game; you are free to name them whatever you want!</p>
<p>Using <strong class="source-inline">SpaceTruckerMainMenuScreen</strong> as an example, the <strong class="source-inline">MOVE_UP</strong> and <strong class="source-inline">MOVE_DOWN</strong> actions should increment or decrement <strong class="source-inline">selectedItemIndex</strong> for the menu items. An <strong class="source-inline">ACTIVATE</strong> action should invoke the menu item. Here’s what that looks like when we code up the <strong class="source-inline">MOVE_UP</strong> action:</p>
<pre class="source-code">&#13;
MOVE_UP(state) {&#13;
    logger.logInfo("MOVE_UP");&#13;
    const lastState = state.priorState;&#13;
    if (!lastState) {&#13;
        const oldIdx = this.selectedItemIndex;&#13;
        const newIdx = oldIdx - 1;&#13;
        this.selectedItemIndex = newIdx;&#13;
    }&#13;
    return true;&#13;
}</pre>
<p>Similarly, <strong class="source-inline">ACTIVATE</strong> retrieves <strong class="source-inline">selectedItem</strong> before simulating a click event by calling its <strong class="source-inline">onPointerClickObservable.notifyObservers</strong> method to invoke whatever <a id="_idIndexMarker373"/>result is indicated by the particular button selected.</p>
<h3>Skipping the Splash Screen</h3>
<p>As part of <a id="_idIndexMarker374"/>constructing the Splash screen <a id="_idIndexMarker375"/>earlier in this chapter, we added a <strong class="source-inline">skipRequested</strong> flag to the scene, but there wasn’t ever anything that would change that value… until now! The <strong class="source-inline">ACTIVATE</strong> action doesn’t need to know what key was pressed – it only needs to know that it happened at all; just that a key was pressed in the first place. That makes this a pretty simple piece of logic:</p>
<pre class="source-code">&#13;
ACTIVATE(state) {&#13;
    const lastState = state.priorState;&#13;
    if (!this.skipRequested &amp;&amp; !lastState) {&#13;
        logger.logInfo("Key press detected. Skipping cut&#13;
          scene.");&#13;
        this.skipRequested = true;&#13;
        return true;&#13;
    }&#13;
    return false;&#13;
}</pre>
<p>The <strong class="source-inline">SpaceTruckerSplashScreen.update</strong> function, where the <strong class="source-inline">actionProcessor.update</strong> function is invoked, is, in turn, called during <strong class="source-inline">SpaceTruckerApplication.Render</strong>, but only if it is the currently active screen.</p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 5.10 – All four components of the input system&#13;&#10;" height="1351" src="image/Figure_5.10_B17266.jpg" width="1103"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – All four components of the input system</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/>Summary</h1>
<p>Glancing back through the previous pages in this chapter, it might be easy to think that we haven’t accomplished a whole lot, but never sell yourself short – the things we’ve covered in this chapter aren’t the most straightforward to understand or wrap your brain around! Constructing and orchestrating the sequencing of <strong class="source-inline">SplashScreen</strong> starts to ramp up the complexity of our code, not counting the mental whiplash induced by pivoting from that to input in the space of a page.</p>
<p>As stated earlier and not redundantly stated again now, entire thick textbooks can and have been written on the topic of input handling, something we’re trying to cram into a mere fraction of that. Not only that, but we are now able to approach future features with a much clearer picture of how all of the non-game-specific tasks are to be managed and handled.  </p>
<p>That statement could be expanded to cover this and the other chapters in this section as well – we’ve gotten much of the supporting application in place now, which leaves us far more attention to focus on the topics in our next section! In section two, we’ll build the gameplay mechanics, set up lighting and materials, and much, much more.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Extended Topics</h1>
<p>Where to start? There are simply so many interesting things and possibilities to explore! Here are just a few ideas for things you can do to further your learning and enhance <strong class="source-inline">SplashScreen</strong>:</p>
<ul>
<li>Add a camera animation to the beginning portion that has the camera moving and rotating along a path in such a way that the <strong class="source-inline">billboard</strong> panel grows in apparent size at about the same rate as the volume of the music rises</li>
<li>Add background environmental effects to the Scene, similar to what we did with the Main Menu and the Procedural Starfield texture</li>
<li>Replace the final static image with a mesh, texture, material, or something else</li>
</ul>
<p>The input system is also a great source of ideas. Here are a few to consider:</p>
<ul>
<li>Implement support for your favorite gamepad or joystick device. Use this testing site to see the various inputs and values emitted by your device: <a href="https://luser.github.io/gamepadtest/">https://luser.github.io/gamepadtest/</a></li>
<li>Modify the input system to allow for multiple simultaneously connected users – that is, local multiplayer</li>
<li>Expose the joystick sensitivity settings to the application so that they can be edited in-game by the player</li>
</ul>
</div>
<div>
<div id="_idContainer054">
</div>
</div>
</div>

<div id="sbo-rt-content"><div>
<div class="Basic-Graphics-Frame" id="_idContainer055">
</div>
</div>
<div>
<div id="_idContainer056">
</div>
</div>
<div class="Content" id="_idContainer057">
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>Part 2: Constructing the Game</h1>
<p>In this second part of the book, we will build on the foundations of the first part to implement the primary components that comprise <strong class="bold">Space-Truckers: The Video Game</strong>. The pace picks up, as there’s far more material to cover than there is space to contain it. </p>
<p>This section comprises the following chapters:</p>
<ul>
<li><em class="italic"><a id="_idTextAnchor119"/></em><a href="B17266_06_Final_AM.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing the Game Mechanics</em></li>
<li><a href="B17266_07_Final_AM.xhtml#_idTextAnchor142"><em class="italic">Chapter 7</em></a>, <em class="italic">Processing Route Data</em></li>
<li><a href="B17266_08_Final_AM.xhtml#_idTextAnchor166"><em class="italic">Chapter 8</em></a>, <em class="italic">Building the Driving Game</em></li>
<li><a href="B17266_09_Final_AM.xhtml#_idTextAnchor186"><em class="italic">Chapter 9</em></a>, <em class="italic">Calculating and Displaying Scoring Results</em></li>
<li><a href="B17266_10_Final_AM.xhtml#_idTextAnchor207"><em class="italic">Chapter 10</em></a>, <em class="italic">Improving the Environment with Lighting and Materials</em> </li>
</ul>
</div>
</div></body></html>