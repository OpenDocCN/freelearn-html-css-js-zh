- en: Chapter 2. Your First Spec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about the basics, and we are going to guide you through how
    to write your first spec, think in test-first terms for development, and also
    show you all the available global Jasmine functions. By the end of the chapter,
    you should know how Jasmine works and be ready to start doing your first tests
    by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The Investment Tracker application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get you started, we need an example scenario: consider that you are developing
    an application to track investments in the stock market.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of the form illustrates how a user might create a
    new investment on this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Investment Tracker application](img/B04138_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a form to add investments
  prefs: []
  type: TYPE_NORMAL
- en: 'This form will allow the input of three values that define an investment:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will input **Symbol**, which represents which company (stock) the
    user is investing in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will input how many **Shares** the user has bought (or invested in)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will input how much the user has paid for each share (**Share price**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with how the stock market works, imagine you are shopping
    for groceries. To make a purchase, you must specify what you are buying, how many
    items you are buying, and how much you are going to pay. These concepts translate
    to an investment as:'
  prefs: []
  type: TYPE_NORMAL
- en: A stock, which is defined by a symbol, such as `PETO`, can be understood to
    be a grocery type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of shares is the quantity of items you have purchased
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The share price is the unit price of each item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the user has added an investment, it must be listed along with their other
    investments, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Investment Tracker application](img/B04138_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a form and list of investments
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to display how well their investments are going. Since the prices
    of the stocks fluctuate over time, the difference between the price the user has
    paid and the current price indicates whether it is a good (profit) or a bad (loss)
    investment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that the user has two investments:'
  prefs: []
  type: TYPE_NORMAL
- en: One is in the `AOUE` stock, which is scoring a profit of `101.80%`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another is in the `PETO` stock, which is scoring a loss of `-42.34%`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very simple application, and we will get a deeper understanding of
    its functionality as we go on with its development.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine basics and thinking in BDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the application presented previously, we can start writing acceptance
    criteria that define investment:'
  prefs: []
  type: TYPE_NORMAL
- en: Given an investment, it should be of a stock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, it should have the invested shares' quantity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, it should have the share price paid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, it should have a cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the standalone distribution downloaded in the previous chapter, the first
    thing we need to do is create a new spec file. This file can be created anywhere,
    but it is a good idea to stick to a convention, and Jasmine already has a good
    one: specs should be in the `/spec` folder. Create an `InvestmentSpec.js` file
    and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `describe` function is a global Jasmine function used to define test contexts.
    When used as the first call in a spec, it creates a new test suite (a collection
    of test cases). It accepts two parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the test suite—in this case, `Investment`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `function` that will contain all its specs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, to translate the first acceptance criterion (given an investment, it
    should be of a stock) into a Jasmine spec (or test case), we are going to use
    another global Jasmine function called `it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It also accepts two parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The title of the spec—in this case, `should be of a stock`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that will contain the spec code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run this spec, add it to the runner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the spec by opening the runner on the browser. The following output
    can be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the first spec's passing result on the browser
  prefs: []
  type: TYPE_NORMAL
- en: It might sound strange to have an empty spec passing, but in Jasmine, as with
    other test frameworks, a failed assertion is required to make the spec fail.
  prefs: []
  type: TYPE_NORMAL
- en: An **assertion** (or expectation) is a comparison between two values that must
    result in a boolean value. The assertion is only considered a success if the result
    of the comparison is true.
  prefs: []
  type: TYPE_NORMAL
- en: In Jasmine, assertions are written using the global Jasmine function `expect`,
    along with a **matcher** that indicates what comparison must be made with the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the current spec (it is expected that the investment is of a stock),
    in Jasmine this translates to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add the preceding highlighted code to the `InvestmentSpec.js` file. The `expect`
    function takes only one parameter, which defines the **actual value**, or in other
    words, what is going to be tested—`investment.stock`—and expects the chaining
    call to a matcher function, which in this case is `toBe`. That defines the **expected
    value**, `stock`, and the comparison method to be performed (to be the same).
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, Jasmine makes a comparison to check whether the actual value
    (`investment.stock`) and expected value (`stock`) are the same, and if they are
    not, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the assertion written, the spec that previously passed has now failed,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the first spec's failure results
  prefs: []
  type: TYPE_NORMAL
- en: This spec failed because, as the error message states, `investment is not defined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is to do only what the error is indicating us to do, so although
    you might feel the urge to write something else, for now let''s just create this
    `investment` variable with an `Investment` instance in the `InvestmentSpec.js`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry that the `Investment()` function doesn''t exist yet; the spec
    is about to ask for it on the next run, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here the spec asks for an Investment class
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the error has changed to `Investment is not defined`. It now
    asks for the `Investment` function. So, create a new `Investment.js` file in the
    `src` folder and add it to the runner, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To define `Investment`, write the following constructor function in the `Investment.js`
    file inside the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the error change. It now complains about the missing `stock` variable,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows a missing stock error
  prefs: []
  type: TYPE_NORMAL
- en: 'One more time, we feed the code it is asking for into the `InvestmentSpec.js`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The error changes again; this time it is about the missing `Stock` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here the spec asks for a Stock class
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `src` folder, name it `Stock.js`, and add it to the
    runner. Since the `Stock` function is going to be a dependency of `Investment`,
    we should add it just before `Investment.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `Stock` constructor function to the `Stock.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the error is about the expectation, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The expectation is undefined to be Stock
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this and complete this exercise, open the `Investment.js` file inside
    the `src` folder, and add the reference to the `stock` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the spec file, pass `stock` as a parameter to the `Investment` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you will have a passing spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows an Investment spec that passes
  prefs: []
  type: TYPE_NORMAL
- en: This exercise was meticulously conducted to show how a developer works by feeding
    the spec with what it wants when doing test-first development.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The drive to write code must come from a spec that has failed. You must not
    write code unless its purpose is to fix a failed spec.
  prefs: []
  type: TYPE_NORMAL
- en: Setup and teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three more acceptance criteria to be implemented. The next in the
    list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Given an investment, it should have the invested shares'' quantity."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing it should be as simple as the previous spec was. In the `InvestmentSpec.js`
    file inside the `spec` folder, you can translate this new criterion into a new
    spec called `should have the invested shares'' quantity`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see that apart from having written the new spec, we have also changed
    the call to the `Investment` constructor to support the new `shares` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we used an object as a single parameter in the constructor to simulate
    named parameters, a feature JavaScript doesn't have natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this in the `Investment` function is pretty simple—instead of
    having multiple parameters on the function declaration, it has only one, which
    is expected to be an object. Then, the function probes each of its expected parameters
    from this object, making the proper assignments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is now refactored. We can run the tests to see that only the new spec
    fails, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](img/B04138_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the failing shares spec
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, change the `Investment` constructor to make the assignment to
    the `shares` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, everything on your screen is green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](img/B04138_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the passing shares spec
  prefs: []
  type: TYPE_NORMAL
- en: 'But as you can see, the following code, which instantiates `Stock` and `Investment`,
    is duplicated on both specs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To eliminate this duplication, Jasmine provides another global function called
    `beforeEach` that, as the name states, is executed once before each spec. So,
    for these two specs, it will run twice—once before each spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the previous specs by extracting the setup code using the `beforeEach`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This looks much cleaner; we not only removed the code duplication, but also
    simplified the specs. They became much easier to read and maintain since their
    only responsibility now is to fulfill the expectation.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a **teardown** function (`afterEach`) that sets the code to be
    executed after each spec. It is very useful in situations where a cleanup is required
    after each spec. We will see an example of its application in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the specification of `Investment`, add the remaining two specs to
    the `InvestmentSpec.js` file, inside the `spec` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the specs to see them fail, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](img/B04138_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the failing cost and price specs
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to fix them in the `Investment.js` file inside the `src`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the specs for the last time to see them pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup and teardown](img/B04138_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows all four Investment specs passing
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to always see a spec fail before writing the code to fix it;
    otherwise, how would you know that you really need to fix it? Imagine this as
    a way to test the test.
  prefs: []
  type: TYPE_NORMAL
- en: Nested describes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Nested describes** are useful when you want to describe similar behavior
    between specs. Suppose we want the following two new acceptance criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Given an investment, when its stock share price valorizes, it should have a
    positive **return on investment** (**ROI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an investment, when its stock share price valorizes, it should be a good
    investment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these criteria share the same behavior when the investment's stock share
    price valorizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To translate this into Jasmine, you can nest a call to the `describe` function
    inside the existing one in the `InvestmentSpec.js` file (I removed the rest of
    the code for the purpose of demonstration; it is still there):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It should behave just like the outer one, so you can add specs (`it`) and use
    the setup and teardown functions (`beforeEach`, `afterEach`).
  prefs: []
  type: TYPE_NORMAL
- en: Setup and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the setup and teardown functions, Jasmine respects the outer setup
    and teardown functions as well, so that they are run as expected. For each spec
    (`it`), the following actions are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine runs all setup functions (`beforeEach`) from the outside in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jasmine runs a spec code (`it`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jasmine runs all the teardown functions (`afterEach`) from the inside out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can add a setup function to this new `describe` function that changes
    the share price of the stock, so that it''s greater than the share price of the
    investment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Coding a spec with shared behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the shared behavior implemented, we can start coding the acceptance
    criteria described earlier. Each is, just as before, a call to the global Jasmine
    function `it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the missing functions to `Investment` in the `Investment.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the specs and see that they pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding a spec with shared behavior](img/B04138_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the nested describe specs pass
  prefs: []
  type: TYPE_NORMAL
- en: Understanding matchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you've already seen plenty of usage examples for matchers and probably
    can feel how they work.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to use the `toBe` and `toEqual` matchers. These are the two
    base built-in matchers available in Jasmine, but we can extend Jasmine by writing
    matchers of our own.
  prefs: []
  type: TYPE_NORMAL
- en: So, to really understand how Jasmine matchers work, we need to create one ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Custom matchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this expectation from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it works, it is not very expressive. Imagine if we could instead rewrite
    it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a much better relation with the acceptance criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: So, here "should be a good investment" becomes "expect investment to be a good
    investment".
  prefs: []
  type: TYPE_NORMAL
- en: Implementing it is quite simple. You do so by calling the `jasmine.addMatchers`
    function—ideally inside a setup step (`beforeEach`).
  prefs: []
  type: TYPE_NORMAL
- en: Although you can put this new matcher definition inside the `InvestmentSpec.js`
    file, Jasmine already has a default place to add custom matchers, the `SpecHelper.js`
    file, inside the `spec` folder. If you are using Standalone Distribution, it already
    comes with a sample custom matcher; delete it and let's start from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addMatchers` function accepts a single parameter—an object where each
    attribute corresponds to a new matcher. So, to add the following new matcher,
    change the contents of the `SpecHelper.js` file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The function being defined here is not the matcher itself but a factory function
    to build the matcher. Its purpose, once called is to return an object containing
    a compare function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `compare` function will contain the actual matcher implementation, and as
    can be observed by its signature, it receives both values being compared (the
    `actual` and `expected` values).
  prefs: []
  type: TYPE_NORMAL
- en: For the given example, the `investment` object will be available in the `actual`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Then, Jasmine expects, as the result of this `compare` function, an object with
    a `pass` attribute with a boolean value `true` to indicate that the expectation
    passes and `false` if the expectation fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following valid implementation of the `toBeAGoodInvestment`
    matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, this matcher is ready to be used by the specs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After the change, the specs should still pass. But what happens if a spec fails?
    What is the error message that Jasmine reports?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see it by deliberately breaking the `investment.isGood` implementation
    in the `Investment.js` file, in the `src` folder to always return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the specs again, Jasmine generates an error message stating `Expected
    { stock: { sharePrice: 40 }, shares: 100, sharePrice: 20, cost: 2000 } to be a
    good investment`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](img/B04138_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the custom matcher's message
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine does a great job generating this error message, but it also allows
    its customization via the `result.message` property of the object returned as
    the result of the matcher. Jasmine expects this property to be a string with the
    following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the specs again and the error message should change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](img/B04138_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the custom matcher's custom message
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider another acceptance criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Given an investment, when its stock share price devalorizes, it should be
    a bad investment."'
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to create a new custom matcher (`toBeABadInvestment`),
    Jasmine allows the negation of any matcher by chaining `not` before the matcher
    call. So, we can write that "a bad investment" is "not a good investment"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement this new acceptance criterion in the `InvestmentSpec.js` file inside
    the `spec` folder by adding new and nested `describe` and `spec`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'But there is a catch! Let''s break the `investment` implementation in the `Investment.js`
    file code so that it is always a good investment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the specs again, you can see that this new spec fails, but the
    error message, `Expected investment to be a good investment`, is wrong, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](img/B04138_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the custom matcher's wrong custom negated message
  prefs: []
  type: TYPE_NORMAL
- en: That is the message that was hardcoded inside the matcher. To fix this, you
    need to make the message dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine only shows the message if the matcher fails, so the proper way of making
    this message dynamic is to consider what message is supposed to be shown when
    the given comparison is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This fixes the message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom matchers](img/B04138_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the custom matcher's custom dynamic message
  prefs: []
  type: TYPE_NORMAL
- en: Now this matcher can be used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing in the chapter, change the `isGood` method back again to
    its correct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'What this example lacked was a way to show how to pass an expected value to
    a matcher like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that a matcher can receive any number of expected values as parameters.
    So, for instance, the preceding matcher could be implemented in the `SpecHelper.js`
    file, inside the `spec` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By implementing any matcher, check first whether there is one available that
    already does what you want.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, check the official documentation at the Jasmine website
    [http://jasmine.github.io/2.1/custom_matcher.html](http://jasmine.github.io/2.1/custom_matcher.html).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in matchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine comes with a bunch of default matchers covering the basis of value checking
    in the JavaScript language. To understand how they work and where to use them
    properly is a journey of how JavaScript handles type.
  prefs: []
  type: TYPE_NORMAL
- en: The toEqual built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `toEqual` matcher is probably the most commonly used matcher, and you should
    use it whenever you want to check equality between two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works for all primitive values (number, string, and boolean) as well as
    any object (including arrays), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The toBe built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `toBe` matcher has a very similar behavior to the `toEqual` matcher; in
    fact, it gives the same result while comparing primitive values, but the similarities
    stop there.
  prefs: []
  type: TYPE_NORMAL
- en: While the `toEqual` matcher has a complex implementation (you should take a
    look at the Jasmine source code) that checks whether all attributes of an object
    and all elements of an array are the same, here it is a simple use of the **strict
    equals operator** (`===`).
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with the strict equals operator, its main difference from
    the **equals operator** (`==`) is that the latter performs type coercion if the
    compared values aren't of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The strict equals operator always considers false any comparison between values
    of distinct types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how this matcher (and the strict equals operator)
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is advised that you use the `toEqual` operator in most cases and resort to
    the `toBe` matcher only when you want to check whether two variables reference
    the same object.
  prefs: []
  type: TYPE_NORMAL
- en: The toBeTruthy and toBeFalsy matchers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides its primitive boolean type, everything else in the JavaScript language
    also has an inherent boolean value, which is generally known to be either **truthy**
    or **falsy**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily in JavaScript, there are only a few values that are identified as falsy,
    as shown in the following examples for the `toBeFalsy` matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else is considered truthy, as demonstrated by the following examples
    of the `toBeTruthy` matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But, if you want to check whether something is equal to an actual boolean value,
    it might be a better idea to use the `toEqual` matcher.
  prefs: []
  type: TYPE_NORMAL
- en: The toBeUndefined, toBeNull, and toBeNaN built-in matchers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These matchers are pretty straightforward and should be used to check for `undefined`,
    `null`, and `NaN` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Both `toBeNull` and `toBeUndefined` can be written as `toBe(null)` and `toBe(undefined)`
    respectively, but that is not the case with `toBeNaN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the `NaN` value is not equal to any value, not even `NaN`. So,
    trying to compare it to itself is always `false`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As good practice, try to use these matchers instead of their `toBe` counterparts
    whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: The toBeDefined built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This matcher is useful if you want to check whether a variable is defined and
    you don''t care about its value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Anything except `undefined` will pass under this matcher, even `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The toContain built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, it is desirable to check whether an array contains an element, or
    whether a string can be found inside another string. For these use cases, you
    can use the `toContain` matcher, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The toMatch built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the `toContain` and `toEqual` matchers can be used in most string
    comparisons, sometimes the only way to assert whether a string value is correct
    is through a regular expression. For these cases, you can use the `toMatch` matcher
    along with a regular expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The matcher works by testing the actual value (`"My big matched string"`) against
    the expected regular expression (`/My(.+)string/`).
  prefs: []
  type: TYPE_NORMAL
- en: The toBeLessThan and toBeGreaterThan built-in matchers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `toBeLessThan` and `toBeGreaterThan` matchers are simple and used to perform
    numeric comparisons—something that is best described by the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The toBeCloseTo built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a special matcher used to compare floating-point numbers with a defined
    set of precision—something that is best explained by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the number being compared, and the second is the precision
    in the number of decimal cases.
  prefs: []
  type: TYPE_NORMAL
- en: The toThrow built-in matcher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Exceptions are a language's way of demonstrating when something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, while coding an API, you might decide to throw an exception
    when a parameter is passed incorrectly. So, how do you test this code?
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine has the built-in `toThrow` matcher that can be used to verify that an
    exception has been thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The way it works is a little bit different from the other matchers. Since the
    matcher has to run a piece of code and check whether it throws an exception, the
    matcher's **actual** value must be a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When the test is run, the anonymous function is executed, and if it throws the
    `Some exception` exception, the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to think in BDD and drive your code from your
    specs. You also became acquainted with the basic Jasmine global functions (`describe`,
    `it`, `beforeEach`, and `afterEach`) and have a good understanding of what is
    required to create a spec in Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: You got familiar with Jasmine matchers and know how powerful they are in describing
    a spec intent. You even learned to create a matcher of your own.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be familiar with creating new specs and driving the development
    of your new application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at how we can use the concepts
    learned in this chapter to start testing web applications, which are most commonly
    jQuery and HTML forms.
  prefs: []
  type: TYPE_NORMAL
