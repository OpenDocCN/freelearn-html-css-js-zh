["```js\npromise.then(onFulfilled, onRejected) \n```", "```js\nasyncOperation(arg, (err, result) => {\n  if(err) {\n    // handle the error\n  }\n  // do stuff with the result\n}) \n```", "```js\nasyncOperationPromise(arg)\n  .then(result => {\n    // do stuff with result\n  }, err => {\n    // handle the error\n  }) \n```", "```js\nasyncOperationPromise(arg)\n  .then(result1 => {\n    // returns another promise\n    return asyncOperationPromise(arg2)\n  })\n  .then(result2 => {\n    // returns a value\n    return 'done'\n  })\n  .then(undefined, err => {\n    // any error in the chain is caught here\n  }) \n```", "```js\nfunction delay (milliseconds) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(new Date())\n    }, milliseconds)\n  })\n} \n```", "```js\nconsole.log(`Delaying...${new Date().getSeconds()}s`)\ndelay(1000)\n  .then(newDate => {\n    console.log(`Done ${newDate.getSeconds()}s`)\n  }) \n```", "```js\nfunction promisify (callbackBasedApi) {\n  return function promisified (...args) {\n    return new Promise((resolve, reject) => {              // (1)\n      const newArgs = [\n        ...args,\n        function (err, result) {                           // (2)\n          if (err) {\n            return reject(err)\n          }\n          resolve(result)\n        }\n      ]\n      callbackBasedApi(...newArgs)                         // (3)\n    })\n  }\n} \n```", "```js\nimport { randomBytes } from 'crypto'\nconst randomBytesP = promisify(randomBytes)\nrandomBytesP(32)\n  .then(buffer => {\n    console.log(`Random bytes: ${buffer.toString()}`)\n  }) \n```", "```js\nimport { promises as fsPromises } from 'fs'                // (1)\nimport { dirname } from 'path'\nimport superagent from 'superagent'\nimport mkdirp from 'mkdirp'\nimport { urlToFilename, getPageLinks } from './utils.js'\nimport { promisify } from 'util'\nconst mkdirpPromises = promisify(mkdirp)                   // (2) \n```", "```js\nfunction download (url, filename) {\n  console.log(`Downloading ${url}`)\n  let content\n  return superagent.get(url)                               // (1)\n    .then((res) => {\n      content = res.text                                   // (2)\n      return mkdirpPromises(dirname(filename))\n    })\n    .then(() => fsPromises.writeFile(filename, content))\n    .then(() => {\n      console.log(`Downloaded and saved: ${url}`)\n      return content                                       // (3)\n    })\n} \n```", "```js\nfunction spiderLinks (currentUrl, content, nesting) {\n  let promise = Promise.resolve()                            // (1)\n  if (nesting === 0) {\n    return promise\n  }\n  const links = getPageLinks(currentUrl, content)\n  for (const link of links) {\n    promise = promise.then(() => spider(link, nesting - 1))  // (2)\n  }\n  return promise\n} \n```", "```js\nexport function spider (url, nesting) {\n  const filename = urlToFilename(url)\n  return fsPromises.readFile(filename, 'utf8')\n    .catch((err) => {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n      // The file doesn't exist, so let's download it\n      return download(url, filename)\n    })\n    .then(content => spiderLinks(url, content, nesting))\n} \n```", "```js\nspider(url, nesting)\n  .then(() => console.log('Download complete'))\n  .catch(err => console.error(err)) \n```", "```js\nconst promise = tasks.reduce((prev, task) => {\n  return prev.then(() => {\n    return task()\n  })\n}, Promise.resolve()) \n```", "```js\nfunction spiderLinks (currentUrl, content, nesting) {\n  if (nesting === 0) {\n    return Promise.resolve()\n  }\n  const links = getPageLinks(currentUrl, content)\n  const promises = links.map(link => spider(link, nesting - 1))\n  return Promise.all(promises)\n} \n```", "```js\nnext () {\n  while (this.running < this.concurrency && this.queue.length) {\n    const task = this.queue.shift()\n    task().finally(() => {\n      this.running--\n      this.next()\n    })\n    this.running++\n  }\n} \n```", "```js\nrunTask (task) {\n  return new Promise((resolve, reject) => {                // (1)\n    this.queue.push(() => {                                // (2)\n      return task().then(resolve, reject)                  // (4)\n    })\n    process.nextTick(this.next.bind(this))                 // (3)\n  })\n} \n```", "```js\nfunction spiderLinks (currentUrl, content, nesting, queue) {\n  if (nesting === 0) {\n    return Promise.resolve()\n  }\n  const links = getPageLinks(currentUrl, content)\n  const promises = links\n    .map(link => spiderTask(link, nesting - 1, queue))\n  return Promise.all(promises)                             // (2)\n}\nconst spidering = new Set()\nfunction spiderTask (url, nesting, queue) {\n  if (spidering.has(url)) {\n    return Promise.resolve()\n  }\n  spidering.add(url)\n  const filename = urlToFilename(url)\n  return queue\n    .runTask(() => {                                       // (1)\n      return fsPromises.readFile(filename, 'utf8')\n        .catch((err) => {\n          if (err.code !== 'ENOENT') {\n            throw err\n          }\n          // The file doesn't exists, so let's download it\n          return download(url, filename)\n        })\n    })\n    .then(content => spiderLinks(url, content, nesting, queue))\n}\nexport function spider (url, nesting, concurrency) {\n  const queue = new TaskQueue(concurrency)\n  return spiderTask(url, nesting, queue)\n} \n```", "```js\nasync function playingWithDelays () {\n  console.log('Delaying...', new Date())\n  const dateAfterOneSecond = await delay(1000)\n  console.log(dateAfterOneSecond)\n  const dateAfterThreeSeconds = await delay(3000)\n  console.log(dateAfterThreeSeconds)\n  return 'done'\n} \n```", "```js\nplayingWithDelays()\n  .then(result => {\n    console.log(`After 4 seconds: ${result}`)\n  }) \n```", "```js\nfunction delayError (milliseconds) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(`Error after ${milliseconds}ms`))\n    }, milliseconds)\n  })\n} \n```", "```js\nasync function playingWithErrors (throwSyncError) {\n  try {\n    if (throwSyncError) {\n      throw new Error('This is a synchronous error')\n    }\n    await delayError(1000)\n  } catch (err) {\n    console.error(`We have an error: ${err.message}`)\n  } finally {\n    console.log('Done')\n  }\n} \n```", "```js\nplayingWithErrors(true) \n```", "```js\nWe have an error: This is a synchronous error\nDone \n```", "```js\nplayingWithErrors(false) \n```", "```js\nWe have an error: Error after 1000ms\nDone \n```", "```js\nasync function errorNotCaught () {\n  try {\n    return delayError(1000)\n  } catch (err) {\n    console.error('Error caught by the async function: ' +\n      err.message)\n  }\n}\nerrorNotCaught()\n  .catch(err => console.error('Error caught by the caller: ' +\n    err.message)) \n```", "```js\nError caught by the caller: Error after 1000ms \n```", "```js\nasync function errorCaught () {\n  try {\n    return await delayError(1000)\n  } catch (err) {\n    console.error('Error caught by the async function: ' +\n      err.message) }\n}\nerrorCaught()\n  .catch(err => console.error('Error caught by the caller: ' +\n    err.message)) \n```", "```js\nError caught by the async function: Error after 1000ms \n```", "```js\nasync function download (url, filename) {\n  console.log(`Downloading ${url}`)\n  const { text: content } = await superagent.get(url)\n  await mkdirpPromises(dirname(filename))\n  await fsPromises.writeFile(filename, content)\n  console.log(`Downloaded and saved: ${url}`)\n  return content\n} \n```", "```js\nasync function spiderLinks (currentUrl, content, nesting) {\n  if (nesting === 0) {\n    return\n  }\n  const links = getPageLinks(currentUrl, content)\n  for (const link of links) {\n    await spider(link, nesting - 1)\n  }\n} \n```", "```js\nexport async function spider (url, nesting) {\n  const filename = urlToFilename(url)\n  let content\n  try {\n    content = await fsPromises.readFile(filename, 'utf8')\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n    content = await download(url, filename)\n  }\n  return spiderLinks(url, content, nesting)\n} \n```", "```js\nlinks.forEach(async function iteration(link) {\n  await spider(link, nesting - 1)\n}) \n```", "```js\nasync function spiderLinks (currentUrl, content, nesting) {\n  if (nesting === 0) {\n    return\n  }\n  const links = getPageLinks(currentUrl, content)\n  const promises = links.map(link => spider(link, nesting - 1))\n  for (const promise of promises) {\n    await promise\n  }\n} \n```", "```js\nconst results = await Promise.all(promises) \n```", "```js\nasync function spiderLinks (currentUrl, content, nesting) {\n  if (nesting === 0) {\n    return\n  }\n  const links = getPageLinks(currentUrl, content)\n  const promises = links.map(link => spider(link, nesting - 1))\n  return Promise.all(promises)\n} \n```", "```js\nexport class TaskQueuePC {\n  constructor (concurrency) {\n    this.taskQueue = []\n    this.consumerQueue = []\n    // spawn consumers\n    for (let i = 0; i < concurrency; i++) {\n      this.consumer()\n    }\n  }\n  // ... \n```", "```js\nasync consumer () {\n  while (true) {                                           // (1)\n    try {\n      const task = await this.getNextTask()                // (2)\n      await task()                                         // (3)\n    } catch (err) {\n      console.error(err)                                   // (4)\n    }\n  }\n} \n```", "```js\nasync getNextTask () {\n  return new Promise((resolve) => {\n    if (this.taskQueue.length !== 0) {\n      return resolve(this.taskQueue.shift())               // (1)\n    }\n    this.consumerQueue.push(resolve)                       // (2)\n  })\n} \n```", "```js\nrunTask (task) {\n  return new Promise((resolve, reject) => {\n    const taskWrapper = () => {                            // (1)\n      const taskPromise = task()\n      taskPromise.then(resolve, reject)\n      return taskPromise\n    }\n    if (this.consumerQueue.length !== 0) {                 // (2)\n      const consumer = this.consumerQueue.shift()\n      consumer(taskWrapper)\n    } else {                                               // (3)\n      this.taskQueue.push(taskWrapper)\n    }\n  })\n} \n```", "```js\nfunction leakingLoop () {\n  return delay(1)\n    .then(() => {\n      console.log(`Tick ${Date.now()}`)\n      return leakingLoop()\n    })\n} \n```", "```js\nfor (let i = 0; i < 1e6; i++) {\n  leakingLoop()\n} \n```", "```js\nfunction nonLeakingLoop () {\n  delay(1)\n    .then(() => {\n      console.log(`Tick ${Date.now()}`)\n      nonLeakingLoop()\n    })\n} \n```", "```js\nfunction nonLeakingLoopWithErrors () {\n  return new Promise((resolve, reject) => {\n    (function internalLoop () {\n      delay(1)\n        .then(() => {\n          console.log(`Tick ${Date.now()}`)\n          internalLoop()\n        })\n        .catch(err => {\n          reject(err)\n        })\n    })()\n  })\n} \n```", "```js\nasync function nonLeakingLoopAsync () {\n  while (true) {\n    await delay(1)\n    console.log(`Tick ${Date.now()}`)\n  }\n} \n```", "```js\nasync function leakingLoopAsync () {\n  await delay(1)\n  console.log(`Tick ${Date.now()}`)\n  return leakingLoopAsync()\n} \n```"]