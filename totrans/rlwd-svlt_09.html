<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor135"/><a id="_idTextAnchor136"/>9</h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Implementing Custom Stores</h1>
<p>In the last chapter, we learned that a Svelte store is any object that follows a Svelte store contract, and encapsulating data within a Svelte store allows the data to be shared and used across multiple Svelte components reactively. The Svelte component keeps the DOM up to date with the data, even though the data is modified outside of the Svelte component.</p>
<p>We learned about two of Svelte’s built-in methods for creating a Svelte store—namely <code>readable()</code> and <code>writable()</code>, which create a readable and writable store. The two methods follow the Svelte contract and create a very basic Svelte store. However, besides using a Svelte store to encapsulate data, we can also encapsulate logic with the data, making the Svelte store modular and highly reusable.</p>
<p>In this chapter, we will be creating custom Svelte stores—Svelte stores that encapsulate custom data logic. We will go through three distinct examples; each example will serve as a guide, brimming with tips and tricks for creating your own custom Svelte stores.</p>
<p>First up, we’ll examine how to turn user events into store values, specifically turning click counts into a Svelte store.</p>
<p>Second, we’ll explore a custom store that goes beyond the basic <code>set</code> method to modify its value. We’ll look at an undo/redo store, which incorporates additional methods for reverting or redoing changes to its value.</p>
<p>Lastly, we’ll turn our attention to higher-order stores. While not a custom store in itself, a higher-order store is a function that accepts a Svelte store as input and returns an enhanced version of it. This chapter includes sections on the following topics:</p>
<ul>
<li>Creating a Svelte store from user events</li>
<li>Creating an undo/redo store</li>
<li>Creating a debounced higher-order Svelte store</li>
</ul>
<p>So, without further ado, let’s dive into creating our first custom Svelte store.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor138"/>Technical requirements</h1>
<p>All the code in this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09</a><a href="https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter09%20"/></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor139"/>Creating a Svelte store from user events</h1>
<p>A Svelte store stores data, but where does the data come from?</p>
<p>It could be <a id="_idIndexMarker332"/>from user interaction or user input, which calls an event handler that updates the store value by calling <code>store.set()</code>.</p>
<p>What if we can encapsulate the user events and event handler logic into the store so that we do not need to call <code>store.set()</code> manually?</p>
<p>For example, we are going to have a Svelte store to calculate how many times the user clicks on the screen. Instead of manually adding an event listener on the document, if there’s a way to create a Svelte store and update it every time there’s a new click, how would that look? In short, how about having a custom Svelte store that can do all of that for us?</p>
<p>It would be great if we could reuse this Svelte store the next time we have a similar need, instead of having to manually set it up again.</p>
<p>So, let’s try to implement this click counter custom Svelte store.</p>
<p>Let's first scaffold the Svelte store:</p>
<pre class="source-code">
const subscribers = [];
let clickCount = 0;
const store = {
  subscribe: (fn) =&gt; {
    fn(clickCount);
    subscribers.push(fn);
    return () =&gt; {
      subscribers.splice(subscribers.indexOf(fn), 1);
    }
  },
}</pre> <p>In the <a id="_idIndexMarker333"/>preceding code snippet, we created a basic Svelte store based on the Svelte store contract with just a <code>subscribe()</code> method. The value of the store is stored in a variable called <code>clickCount</code>, and in the <code>subscribe()</code> method, we keep track of all the subscribers using the <code>subscribers</code> array.</p>
<p>Notice that we need to synchronously call <code>fn</code> in the <code>subscribe()</code> method with the value of the store; this lets the subscriber know the current value of the store.</p>
<p>If you use this store in a Svelte component right now (as shown in the following code snippet), you will see <code>0</code> on the screen. That is the current value of the store at this point:</p>
<pre class="source-code">
&lt;script&gt;
  import { store } from './store.js';
&lt;/script&gt;
{$store}</pre> <p>In the preceding code snippet, we import <code>store</code> into a Svelte component and display the <code>store</code> value using <code>$store</code>. Now, let’s listen to the <code>click</code> events to update the <code>count</code> value of the store. Instead of listening to the <code>click</code> events at the start of our program, we should start subscribing only when there’s a subscriber.</p>
<p>Here’s the updated code:</p>
<pre class="source-code">
const store = {
  subscribe: (fn) =&gt; {
    // ...
    <strong class="bold">document.addEventListener('click', () =&gt; {</strong>
      <strong class="bold">clickCount++;</strong>
      <strong class="bold">// notify subscribers</strong>
      <strong class="bold">subscribers.forEach(subscriber =&gt;</strong> <strong class="bold">subscriber(clickCount));</strong>
<strong class="bold">    });</strong>
  },
};</pre> <p>In the <a id="_idIndexMarker334"/>preceding code snippet, we add the <code>click</code> event listener inside the <code>subscribe</code> method, and whenever the <code>document</code> is clicked, we increment the <code>clickCount</code> value by <code>1</code> and notify all the subscribers of the latest value of <code>clickCount</code>.</p>
<p>If you try to use this Svelte store in multiple Svelte components right now, you will realize that every time you click, the store value increments by more than one.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Ensuring the event listener is only added once</h2>
<p>Why is the<a id="_idIndexMarker335"/> store value incremented more than once when it is only clicked once?</p>
<p>If you look at the current implementation closely, you will realize that we call <code>document.addEventListener</code> on every <code>subscribe</code> method call. When you use the Svelte store in multiple Svelte components, each Svelte component subscribes to the store changes individually. If there are five components subscribed to the store, then five <code>click</code> event listeners will be added to <code>document</code>. As a result, a single click on <code>document</code> will trigger five event listeners, causing the <code>clickCount</code> value to increase by five each time. This means the <code>store</code> value will go up by more than one for every click. To fix this behavior, we can still call <code>addEventListener</code> within the <code>subscribe</code> method, but we need to only call <code>addEventListener</code> once, even though the <code>subscribe</code> method could be called more than once.</p>
<p>We can use a flag to indicate if we have already called <code>addEventListener</code>, and make sure not to call <code>addEventListener</code> again when the flag is set to <code>true</code>, as shown here:</p>
<pre class="source-code">
<strong class="bold">let called = false;</strong>
const store = {
  subscribe: (fn) =&gt; {
    // ...
    <strong class="bold">if (!called) {</strong>
      <strong class="bold">called = true;</strong>
      document.addEventListener('click', () =&gt; {... });
    <strong class="bold">}</strong>
  },
};</pre> <p>In the<a id="_idIndexMarker336"/> preceding code snippet, we add a variable named <code>called</code> and use it to prevent <code>document</code> from adding click event listeners more than once.</p>
<p>This works, but there’s a better way to implement this.</p>
<p>Instead of having a new flag to indicate whether we have called <code>addEventListener</code>, we can use any existing variables to determine if we should call <code>addEventListener</code>. We know that we should call <code>addEventListener</code> once the <code>subscribe</code> method is being called, and it should not be called subsequently when we are adding more subscribers; we can use the length of the <code>subscribers</code> array to determine if we should call the <code>addEventListener</code> method.</p>
<p>If there are no subscribers currently, then we know this is the first time the <code>subscribe</code> method is being called. In this case, we should call <code>addEventListener</code>. On the other hand, if there are existing subscribers—that is, the length of <code>subscribers</code> is more than zero, we know that the <code>subscribe</code> method has been called before, and therefore we should not call <code>addEventListener</code> again.</p>
<p>So, here’s the updated code to use the length of the <code>subscribers</code> array instead of the variable called to determine if the document should add click event listeners:</p>
<pre class="source-code">
const store = {
  subscribe: (fn) =&gt; {
    // ...
    <strong class="bold">if (subscribers.length === 0) {</strong>
      document.addEventListener('click', () =&gt; {... });
    <strong class="bold">}</strong>
  },
};</pre> <p>In the preceding code snippet , we replaced the <code>!called</code> condition with <code>subscribers.length === </code><code>0</code>.</p>
<p>Now <a id="_idIndexMarker337"/>that we have added a click event listener when a subscriber is subscribing to our Svelte store, we need to clean it up when all subscribers have unsubscribed from the Svelte store.</p>
<p>To clean it up, we are going to call <code>removeEventListener</code> to remove the <code>click</code> event listeners from <code>document</code>. The <code>unsubscribe</code> function can be called multiple times, but we should only call <code>removeEventListener</code> when there are no more subscribers in the <code>subscribers</code> array:</p>
<pre class="source-code">
const store = {
  subscribe: (fn) =&gt; {
    return () =&gt; {
      subscribers.splice(subscribers.indexOf(fn), 1);
<strong class="bold">      if (subscribers.length === 0) {</strong>
<strong class="bold">        document.removeEventListener('click', () =&gt; {...});</strong>
<strong class="bold">      }</strong>
    };
  },
};</pre> <p>In the preceding code snippet, the <code>return</code> function of the <code>subscribe</code> method is used for unsubscribing the store. In the function, we added a check to see if the number of <code>subscribers</code> has dropped to zero; if so, we will remove the <code>click</code> event listeners from <code>document</code>.</p>
<p>It is common that when you are creating a Svelte store, you need to keep track of the <code>subscribers</code> list, ensure that you only set up the event listeners once, and clean it up only after there are no more subscribers.</p>
<p>As you’ve<a id="_idIndexMarker338"/> seen in this and the previous section, we've been through a lot of steps to create a Svelte store from user events, manage a <code>subscribers</code> array, and decide when to add or remove click event listeners from document. In the next section, we’ll explore a simpler way to achieve the same goal using Svelte’s built-in methods and using Svelte’s built-in <code>readable()</code> function.</p>
<p>Svelte provides built-in methods such as <code>readable()</code> to make our lives easier when creating a Svelte store.</p>
<p>Since the store value is only updated from <code>click</code> events, and not from elsewhere, <code>readable()</code>, out of the two most important methods—<code>readable()</code> and <code>writable()</code>—is good enough for our use case.</p>
<p>We will use the <code>readable()</code> function to create our click event store. There are two arguments for the <code>readable()</code> function. The first argument is for the initial value of the store. The second argument of the <code>readable()</code> function takes in a function that will be called when there’s a first subscriber and not be called for the subsequent subscribers. If the function returns another function, the returned function will be called when the last subscriber unsubscribes from the store. This is perfect for us to add and remove <code>click</code> event listeners on <code>document</code>.</p>
<p>Let’s take a look at the updated code rewritten using <code>readable</code>:</p>
<pre class="source-code">
let clickCount = 0;
const store = readable(clickCount, (set) =&gt; {
  const onClick = () =&gt; set(++clickCount);
  document.addEventListener('click', onClick);
  return () =&gt; {
    document.removeEventListener('click', onClick);
  };
});</pre> <p>In the preceding code snippet, we utilize <code>readable()</code> to handle both the creation and the cleanup of the <code>click</code> event listener, making our code cleaner and more efficient.</p>
<p>Comparing it with<a id="_idIndexMarker339"/> our implementation in the last section, where we managed the <code>subscribers</code> list ourselves, you can see how using <code>readable()</code> allows us to declutter away from maintaining the <code>subscribers</code> array manually and focus on implementing the logic.</p>
<p>It is good to know the Svelte contract and how to implement a Svelte store from scratch. But in most real-world scenarios, it is easier to create a Svelte store out of <code>readable()</code> or <code>writable()</code> and leave the nitty-gritty detail to the built-in function.</p>
<p>Now that you have learned how to create a Svelte store out of click events, let's practice with an exercise.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor141"/>Exercise</h2>
<p>Let’s begin our exercise, where <a id="_idIndexMarker340"/>we will implement a Svelte store in which the value of the store comes from the scroll position of the document:</p>
<pre class="source-code">
&lt;script&gt;
  const scrollPosition = createStore();
  function createStore() {
    // Your code here
  }
&lt;/script&gt;
Scroll position {$scrollPosition}</pre> <p>In the code snippet, a <code>scrollPosition</code> store is set up using a function called <code>createStore()</code>. Your task is to implement the <code>createStore()</code> function to actually create a <code>scrollPosition</code> store.</p>
<p>You can find the solution at the following link: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position</a><a href="https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter09/02-exercise-scroll-position%0D"/></p>
<p>Now that we have seen how to create a Svelte store where the store value comes from an event, let’s take a look at a different kind of Svelte store.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>Creating an undo/redo store</h1>
<p>Typically, we <a id="_idIndexMarker341"/>change a store’s value using the <code>set</code> method. However, the next custom Svelte store we’ll explore provides additional custom methods to update its store value. The next custom Svelte store that we are going to look at is an undo/redo store. It is similar to a writable store where you can subscribe to and set a new store value. But an undo/redo store also comes with two more methods, <code>undo</code> and <code>redo</code>, which revert the store value backward or forward, based on the history of the store value.</p>
<p>Here’s a snippet of how you would use an undo/redo store:</p>
<pre class="source-code">
&lt;script&gt;
  let value = createUndoRedoStore();
  $value = 123;
  $value = 456;
  $value = 789;
  value.undo(); // $value now goes back to 456
  value.undo(); // $value now goes back to 123
  value.redo(); // $value now turns to 456
&lt;/script&gt;
Value: {$value}</pre> <p>In the provided code snippet, the <code>createUndoRedoStore()</code> function generates an undo/redo store. Initially, we set the store’s value to <code>123</code>, followed by updates to <code>456</code> and then <code>789</code>. When we call the store’s <code>undo</code> method, the value reverts to <code>456</code> and then to <code>123</code>. Subsequently, using the <code>redo</code> method takes the store’s value back to <code>456</code>. Now that we understand how undo/redo store functions, how do we go about creating one in Svelte?</p>
<p>Firstly, the undo/redo store is going to have four methods: <code>subscribe</code>, <code>set</code>, <code>undo</code>, and <code>redo</code>. The <code>subscribe</code> and <code>set</code> methods are based on the Svelte store contract and are the reason an undo/redo store is considered a Svelte store. The <code>undo</code> and <code>redo</code> methods, on the other hand, are two additional methods that we define.</p>
<p>A <a id="_idIndexMarker342"/>JavaScript object can contain different methods and properties, but as long as it has the <code>subscribe</code> and <code>set</code> methods, with the method signature following the Svelte store contract, we consider the object a Svelte store. You can use a <code>$</code>-prefixed variable to auto-subscribe to the Svelte store and reference the Svelte store value.</p>
<p>Now, to implement this undo/redo store, we know that without the undo/redo feature, the store behaves just like a writable store. So, we are going to implement the undo/redo store based on a writable store, as shown in the following code snippet:</p>
<pre class="source-code">
function createUndoRedoStore() {
  const store = writable();
  return store;
}</pre> <p>In the preceding code snippet, we set the stage for our <code>createUndoRedoStore()</code> function. We start by using Svelte’s <code>writable()</code> function to create a writable store, which will be the base for our undo/redo store.</p>
<p>But as we are setting a new value into the undo/redo store, we need to keep track of the history of store values so that we can undo or redo them.</p>
<p>To do that, we are going to intercept the <code>set</code> method of the writable store, like so:</p>
<pre class="source-code">
function createUndoRedoStore() {
  const store = writable();
<strong class="bold">  function set(value) {</strong>
<strong class="bold">    store.set(value);</strong>
<strong class="bold">  }</strong>
  return {
    subscribe: store.subscribe,
<strong class="bold">    set: set,</strong>
  };
}</pre> <p>In the <a id="_idIndexMarker343"/>preceding code, I return a new object. While the <code>subscribe</code> method is the same as the original writable store’s <code>subscribe</code> method, the <code>set</code> method is now a new function. We still call the writable store’s <code>set</code> method in the <code>set</code> function, so the behavior has not changed much.</p>
<p>But now, when we call the <code>set</code> method of the undo/redo store, we are calling the <code>set</code> function first, before relaying this to the <code>set</code> method of the underlying writable store. This allows us to add additional logic into the <code>set</code> function that will be run whenever we are setting a new value to the undo/redo store.</p>
<p>Before we get ahead of ourselves, let’s not forget that we also need to add two more methods, <code>undo</code> and <code>redo</code>, into the undo/redo store. Here’s how we do this:</p>
<pre class="source-code">
function createUndoRedoStore() {
  const store = writable();
  function set(value) { store.set(value); }
<strong class="bold">  function undo() {}</strong>
<strong class="bold">  function redo() {}</strong>
  return {
    subscribe: store.subscribe,
    set: set,
<strong class="bold">    undo: undo,</strong>
<strong class="bold">    redo: redo,</strong>
  };
}</pre> <p>In the preceding code snippet, we add two additional methods, <code>undo</code> and <code>redo</code>, to the object returned by <code>createUndoRedoStore()</code>. We will go ahead and implement these methods in the next steps. And now, we have the basic structure of our undo/redo store.</p>
<p>You can treat<a id="_idIndexMarker344"/> the preceding code as a template for creating custom Svelte stores. We use a writable store as a base and return a new object. The returned object is considered a Svelte store because, by having the <code>subscribe</code> and <code>set</code> methods, it adheres to the Svelte store contract. If we want to add logic to the <code>subscribe</code> or <code>set</code> method, we can build a new function based on the original <code>subscribe</code> and <code>set</code> methods from the writable store. In addition to that, we can also add more methods to the returned object.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor143"/>Implementing the undo/redo logic</h2>
<p>Now, to<a id="_idIndexMarker345"/> implement the undo/redo logic, we are creating two arrays, <code>undoHistory</code> and <code>redoHistory</code>, to record the history of values that we can replay when we call <code>undo()</code> or <code>redo()</code>.</p>
<p>Whenever the <code>set</code> function is called, we will add the value as a new entry to <code>undoHistory</code> so that we can replay it later on when <code>undo()</code> is called. When <code>undo()</code> is called, we will push the latest entry in <code>undoHistory</code> into <code>redoHistory</code> so that we can redo what we’ve just undone.</p>
<p>Let’s go ahead and implement the logic we’ve just described:</p>
<pre class="source-code">
function createUndoRedoStore() {
  const store = writable();
<strong class="bold">  const undoHistory = [];</strong>
<strong class="bold">  const redoHistory = [];</strong>
  function set(value) {
<strong class="bold">    undoHistory.push(value);</strong>
<strong class="bold">    redoHistory.length = 0; // resets redoHistory</strong>
    store.set(value);
  }
  function undo() {
<strong class="bold">    if (undoHistory.length &lt;= 1) return;</strong>
<strong class="bold">    redoHistory.push(undoHistory.pop());</strong>
<strong class="bold">    store.set(undoHistory[undoHistory.length – 1]);</strong>
  }
  function redo() {
<strong class="bold">    if (redoHistory.length === 0) return;</strong>
<strong class="bold">    const value = redoHistory.pop();</strong>
<strong class="bold">    undoHistory.push(value);</strong>
<strong class="bold">    store.set(value);</strong>
  }
  // ...
}</pre> <p>In the<a id="_idIndexMarker346"/> preceding code snippet, we’ve implemented the <code>undo</code> and <code>redo</code> function using two arrays: <code>undoHistory</code> and <code>redoHistory</code>. We’ve also added checks to see if there are any values in these arrays before performing an undo or redo action. This ensures that we don’t attempt to undo or redo when there’s no history to revert to or advance from. So, you have now learned how to create a custom Svelte store that extends from a writable store and adds new behavior to the original <code>set</code> method, as well as adding new methods to the store.</p>
<p>It’s time to have an exercise.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor144"/>Exercise</h2>
<p>Now that we’ve learned how to create a custom store that provides custom methods to manipulate the underlying store values, let’s have an exercise to build another such custom store, a tweened store. A tweened store is a Svelte store that can contain only numeric values. When you set the value of a tweened Svelte store, the tweened Svelte store takes a fixed duration to update its store value to the set value.</p>
<p>For example, let’s suppose the tweened Svelte store is set to <code>0</code> initially:</p>
<pre class="source-code">
const store = createTweenedStore(0); // $store = 0</pre> <p>Then, you set the value of the store to <code>10</code>:</p>
<pre class="source-code">
$store = 10;</pre> <p>The store value is not set to <code>10</code> directly but increases from <code>0</code> to <code>10</code> over a configurable fixed duration—say, 1 second.</p>
<p>Now you’ve learned the behavior of a tweened store, let’s implement a tweened Svelte store. You can find the code for the tweened store on GitHub at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store</a>.</p>
<p>Now that we’ve learned how to create a custom store, let’s turn our attention to another concept, a higher-order store—a function that takes in a Svelte store as an input and returns a more specialized, custom store based on that input.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor145"/>Creating a debounced higher-order Svelte store</h1>
<p>The <a id="_idIndexMarker347"/>two preceding sections that we’ve seen so far each created a new Svelte store. In this section, we are going to look at how we can create a higher-order store.</p>
<p>The concept of a higher-order store is inspired by a higher-order function, where functions are treated just like any other data. This means that you can pass functions as arguments to other functions or return them as values.</p>
<p>In a similar concept, we are going to create a function that treats stores just like any data, taking a Svelte store as an argument and then returning a Svelte store.</p>
<p>The idea of a higher-order Svelte store is to create a function that enhances an existing Svelte store. A higher-order Svelte store is a function that takes in a Svelte store and returns a new Svelte store, an enhanced version of the input Svelte store.</p>
<p>The example that we are going to use to illustrate this idea will create a <code>debounce</code> higher-order Svelte store.</p>
<p>The <code>debounce</code> function that I am going to create will take in a Svelte store and return a new Svelte store that has its store value debounced based on the input Svelte store value:</p>
<pre class="source-code">
&lt;script&gt;
  function debounce(store) { ... }
  const store = writable();
  const debouncedStore = debounce(store);
&lt;/script&gt;
Store value: {$store}
Debounced store value: {$debouncedStore}</pre> <p>In the <a id="_idIndexMarker348"/>preceding code snippet, in the fourth line, I demonstrated how to use the <code>debounce</code> function that we’re going to implement in this section. This <code>debounce</code> function accepts a Svelte store as an argument and returns an enhanced version of it, which we’ll call <code>debouncedStore</code>. To showcase the debounce functionality, the values of both the original <code>store</code> and <code>debouncedStore</code> arguments are displayed side by side.</p>
<p>Before we start implementing the <code>debounce</code> function, let’s talk about what debounce is.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor146"/>Debouncing store value changes</h2>
<p>In engineering, debounce<a id="_idIndexMarker349"/> is the process of removing unwanted input noises from user input. In web development, debounce is used when there are too many user events, and we want to trigger an event handler or process the event only after the user event settles.</p>
<p>Here’s an example of debounce. When implementing an autocomplete search, we wouldn’t want to trigger the search for an autocomplete result on every character the user types; rather, we’d only start searching after the user stops typing. This saves resources as the autocomplete result may no longer be usable as soon as the user types the next character.</p>
<p>Applying the concept of debounce to a Svelte store, we are going to create a new debounced Svelte store based on an input Svelte store. When the input Svelte store value updates, the debounced Svelte store only updates after the Svelte store updates settle.</p>
<p>If we are going to create a debounced Svelte store from scratch, we can build it up based on a writable store. I showed you how to create a custom Svelte store from a writable store in the last section, so I hope you know how to do that. Do try it out yourself; when you are done, compare it with my implementation at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store</a>.</p>
<p>But in this section, we are going to create a higher-order store. We already have a Svelte store. It could be a writable store or an undo/redo store. Our debounce function is going to take in the Svelte store and return a debounced version of the Svelte store.</p>
<p>Let’s start with the basic structure of a <code>debounce</code> higher-order store.</p>
<p>The <code>debounce</code> function<a id="_idIndexMarker350"/> is going to return a new Svelte store. It is still much easier to build a new Svelte store based on a writable store than to implement it from scratch, create a subscribe function, and maintain an array of subscribers.</p>
<p>Here’s the basic outline of the <code>debounce</code> function:</p>
<pre class="source-code">
function debounce(store) {
  const debounced = writable();
  return {
    subscribe: debounced.subscribe,
    set: store.set,
  };
}</pre> <p>In the preceding code snippet, the returned Svelte store is going to be based on the writable store, so the <code>subscribe</code> method is going to be the writable store’s <code>subscribe</code> method.</p>
<p>The <code>set</code> method is going to be the original store’s <code>set</code> method, instead of a new <code>set</code> function. We are not going to create a separate <code>set</code> function where it sets the original store and tries to set out a debounced store with the debounce logic.</p>
<p>We are not going to do like it’s done in this snippet:</p>
<pre class="source-code">
function debounce(store) {
  const debounced = writable();
<strong class="bold">  function set(value) {</strong>
<strong class="bold">    store.set(value);</strong>
<strong class="bold">    // some debounce logic and call debounce.set(value);</strong>
<strong class="bold">  }</strong>
  return {
    subscribe: debounced.subscribe,
<strong class="bold">    set: set,</strong>
  };
}</pre> <p>In the <a id="_idIndexMarker351"/>preceding code snippet, we intercepted the <code>set</code> method and relayed it to both the original store and the debounced store. We are not going to do that because we want to preserve the original Svelte store logic. When a value is passed to the <code>set</code> method, it may undergo transformations, especially if the store is a custom Svelte store. The <code>value</code> argument in the <code>set</code> method may not be the same as the final store value. So instead, we let the original store handle these potential transformations and subscribe to the original Svelte store to get the final store value. We use the final store value and update the debounced store as the original store value changes, as illustrated in the following code snippet:</p>
<pre class="source-code">
function debounce(store) {
  const debounced = writable();
<strong class="bold">  store.subscribe(value =&gt; {</strong>
<strong class="bold">    // some debounce logic and call debounce.set(value);</strong>
<strong class="bold">  });</strong>
  // ...
}</pre> <p>In the preceding code snippet, I show how to subscribe to the original Svelte store rather than intercepting its <code>set</code> method. This approach allows us to keep the original store’s logic intact while still benefiting from its features. It also takes care of situations when the original Svelte store value could change by other methods. An example of this is the <code>undo()</code> and <code>redo()</code> methods of the undo/redo store. If we only intercepted the value from the <code>set</code> function, as in the preceding code snippet, then the debounced Svelte store would not change when the original undo/redo store was being undone or redone.</p>
<p>To<a id="_idIndexMarker352"/> implement the debounce logic, we are going to use a timeout to update the debounced Svelte store. If there are new changes to the original Svelte store within the timeout, then we are going to cancel the previous timeout and set a new timeout. If not, then we assume the changes have settled, and we update the <code>debounced</code> store.</p>
<p>Here’s the updated code snippet with the debounce logic:</p>
<pre class="source-code">
function debounce(store) {
  const debounced = writable();
<strong class="bold">  let timeoutId = null;</strong>
  store.subscribe(value =&gt; {
<strong class="bold">    if (timeoutId !== null) clearTimeout(timeoutId);</strong>
<strong class="bold">    timeoutId = setTimeout(() =&gt; {</strong>
<strong class="bold">      timeoutId = null;</strong>
<strong class="bold">      debounced.set(value);</strong>
<strong class="bold">    }, 200);</strong>
  });
  // ...
}</pre> <p>In the preceding code snippet, we use the <code>setTimeout</code> function within the <code>subscribe</code> callback to set a timeout for 200 ms. During this time, if the original store’s value changes again, the existing timeout will be cleared, and a new one will be set. But if there’s a new value within the 200 ms time period, we will update the <code>debounced</code> store with the latest value from the original store.</p>
<p>Try <a id="_idIndexMarker353"/>out the <code>debounced</code> store and see that the store value is now debounced from the changes.</p>
<p>One thing you might notice is that we subscribed to the original Svelte store but haven’t unsubscribed from it. Let’s address that next.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor147"/>Subscribing and unsubscribing original store on demand</h2>
<p>Before<a id="_idIndexMarker354"/> we wrap up, there’s one small issue with the <code>debounced</code> store that we’ve implemented so far. We subscribed to the original Svelte store at the creation of the <code>debounced</code> Svelte store and we <a id="_idIndexMarker355"/>never unsubscribed from it, even though the <code>debounced</code> Svelte store may no longer be in use. We should only start subscribing to the original Svelte store when there’s already a subscriber to the <code>debounced</code> Svelte store and unsubscribe when there is no longer any subscriber.</p>
<p>We could intercept the <code>subscribe</code> method and attempt to unsubscribe from the original Svelte store when the debounced Svelte store is being unsubscribed, like so:</p>
<pre class="source-code">
function debounce(store) {
  const debounced = writable();
<strong class="bold">  function subscribe(fn) {</strong>
<strong class="bold">    const debouncedUnsubscribe = debounced.subscribe(fn);</strong>
<strong class="bold">    const unsubscribe = store.subscribe(...);</strong>
<strong class="bold">    return () =&gt; {</strong>
<strong class="bold">      debouncedUnsubscribe();</strong>
<strong class="bold">      unsubscribe();</strong>
<strong class="bold">    };</strong>
<strong class="bold">  }</strong>
  // ...
  return {
<strong class="bold">    subscribe: subscribe,</strong>
    set: store.set,
  };
}</pre> <p>In the updated code snippet, the <code>subscribe</code> method now subscribes to both the <code>debounced</code> store and the original Svelte store. In the <code>return</code> function, which is used to unsubscribe from the <code>debounced</code> store, we also make sure to unsubscribe from the original Svelte store.</p>
<p>However, this<a id="_idIndexMarker356"/> is not quite right. Doing it this way means that we subscribe to the original store every time we <a id="_idIndexMarker357"/>subscribe to the debounced store and unsubscribe from the original store every time we unsubscribe from the debounced store.</p>
<p>We should aim to subscribe to the original store just once, regardless of how many subscribers there are. Similarly, we should unsubscribe from it only when there are no subscribers left. Does this sound familiar?</p>
<p>We ran into a similar conundrum in the previous section when we were trying to implement a click-counter Svelte store. We tried to maintain a list of subscribers before we found out that Svelte provides a built-in <code>writable()</code> function that neatly takes care of that for us.</p>
<p>So, is there a built-in function that allows us to only subscribe to another store once a store is being subscribed, and only unsubscribe from that store once there are no more subscribers in a store?</p>
<p>Yes—this is where <code>derived()</code> comes into play.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor148"/>Deriving a new Svelte store with the derived() function</h2>
<p><code>derived()</code> is a<a id="_idIndexMarker358"/> built-in function from Svelte that takes in one or multiple Svelte stores and returns a new Svelte store whose store value is based on the input Svelte stores.</p>
<p>For example, you can use <code>derived()</code> to define a Svelte store whose store value is always double that of another Svelte store, as seen in the following code snippet:</p>
<pre class="source-code">
import { writable, derived } from 'svelte/store';
const store = writable(1);
const double = derived(store, value =&gt; value * 2);</pre> <p>Or, this could be a Svelte store whose store value is the sum of two Svelte stores, as shown here:</p>
<pre class="source-code">
const store1 = writable(1);
const store2 = writable(2);
const sum = derived(
  [store1, store2],
  ([$store1, $store2]) =&gt; $store1 + $store2
);</pre> <p class="callout-heading">Note</p>
<p class="callout">You may notice that we are using a <code>$</code>-prefixed variable in the callback function of the <code>derived()</code> function; for example, <code>$store1</code> and <code>$store2</code>. However, it does not work the same way as the <code>$</code>-prefixed variable at the top level of the script, where it auto-subscribes to the store and is referenced as the store value.</p>
<p class="callout">In this case, it is merely a convention that some people use to denote that the variable is used to reference the value of a store. It is the same as any other variable name and nothing more.</p>
<p>When <a id="_idIndexMarker359"/>using <code>derived()</code>, Svelte only subscribes to the input Svelte stores—for example, <code>store1</code> and <code>store2</code>—only when the returned Svelte store—for example, <code>sum</code>—is being subscribed to, and will unsubscribe from the input Svelte stores when there are no more subscribers to the returned Svelte store.</p>
<p>Before we rewrite our <code>debounce</code> higher-order store using <code>derived()</code>, let’s dive a little bit more into the <code>derived()</code> function first.</p>
<p>The <code>derived()</code> function provides two approaches to determine the store value of the returned Svelte store: synchronous or asynchronous.</p>
<p>The synchronous approach means that as soon as any of the input Svelte store’s values change, the store value of the returned Svelte store is determined synchronously. By the same token, the asynchronous approach means it is determined asynchronously, which means the store value can be set later after the input Svelte store’s value has changed.</p>
<p>The two examples that I showed at the beginning of this section use the synchronous approach, where the store value of the returned Svelte store is synchronously calculated and set right after the input Svelte store has changed.</p>
<p>The <a id="_idIndexMarker360"/>asynchronous approach can be useful when the store value of the returned Svelte store is determined through some asynchronous operations.</p>
<p>To determine whether the derived store is using the synchronous or asynchronous approach, the <code>derived()</code> method looks at the function signature of the callback function. If it takes in one parameter, then it is considered a synchronous approach. If it takes in two, then it is an asynchronous approach. To get a better idea, check out the following code snippet:</p>
<pre class="source-code">
derived(store, ($store) =&gt; ...) // synchronous
derived(store, ($store, set) =&gt; ...) // asynchronous</pre> <p>In both cases, the callback function will be called every time any of the input Svelte store values change.</p>
<p>If the derived store uses the synchronous approach, the returned value of the callback function is used as the new store value of the returned Svelte store.</p>
<p>If the derived store uses the asynchronous approach, then the second parameter of the callback function is a <code>set</code> function. The <code>set</code> function can be used to set the value of the returned store at any time. The returned value of the callback function, however, will be treated as a cleanup function that will be called right before the callback function is called again.</p>
<p>Now that we are more familiar with the <code>derived()</code> function, let's rewrite our <code>debounce</code> higher-order store using <code>derived()</code>.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor149"/>Using the derived method</h2>
<p>Here is the <a id="_idIndexMarker361"/>updated code for our <code>debounced</code> store rewritten using the <code>derived()</code> method:</p>
<pre class="source-code">
function debounce(store) {
<strong class="bold">  const debounced = derived(store, (value, set) =&gt; {</strong>
<strong class="bold">    let timeoutId = setTimeout(() =&gt; {</strong>
<strong class="bold">      timeoutId = null;</strong>
<strong class="bold">      set(value);</strong>
<strong class="bold">    }, 200);</strong>
<strong class="bold">    return () =&gt; {</strong>
<strong class="bold">      if (timeoutId !== null) clearTimeout(timeoutId);</strong>
<strong class="bold">    };</strong>
  });
  return {
    subscribe: debounced.subscribe,
    set: store.set,
  };
}</pre> <p>Instead <a id="_idIndexMarker362"/>of creating a new <code>debounced</code> store using <code>writable()</code>, we derived it from the original store using the <code>derived()</code> method. We shifted the <code>setTimeout</code> function into the <code>derived()</code> method callback. When there’s a new value from the original Svelte store, we will clear the timeout and set a new timeout.</p>
<p>The <code>derived()</code> function will subscribe to the original Svelte store once only when the <code>debounced</code> store is being subscribed to and unsubscribe from the original Svelte store when there are no more subscribers for the <code>debounced</code> store.</p>
<p>Since we are only going to update the <code>debounced</code> store asynchronously after a timeout, we pass a callback function with two parameters into the <code>derived()</code> function. We call the <code>set</code> function to set the value of the <code>debounced</code> store after the timeout. If the value of the original Svelte store changes before the timeout, then the returned function of the callback function will be called first before the callback function is called again with the updated store value of the original Svelte store. In the returned function, we clear the timeout since we no longer need it anymore.</p>
<p>One last<a id="_idIndexMarker363"/> thing before we conclude—sometimes, the original Svelte store may contain additional methods, such as the <code>undo()</code> and <code>redo()</code> methods in the case of an undo/redo store. These methods should also be defined in the debounced store returned by our higher-order function. This ensures that the enhanced store maintains all the same methods and behaviors as the input store while adding the debouncing feature. You can see an illustration of this in the following code snippet:</p>
<pre class="source-code">
const value = createUndoRedoStore();
const debouncedValue = debounce(value);
$debouncedValue = 123;
$debouncedValue = 456;
debouncedValue.undo(); // $debouncedValue reverts to 123</pre> <p>To return all the methods from the original Svelte store, we use the spread operator (<code>...</code>) to spread all the methods from the original Svelte store:</p>
<pre class="source-code">
function debounce(store) {
  const debounced = derived(...);
  return {
    <strong class="bold">...store,</strong>
    subscribe: debounced.subscribe,
  };
}</pre> <p>In this case, we do not even need to have <code>set: store.set</code> since the <code>set</code> method will be spread into the returned Svelte store too!</p>
<p>That’s it! In this section, you’ve learned another trick—creating a higher-order store, a function that takes in an existing Svelte store and returns a new Svelte store enhanced with new behavior. Instead of building a custom Svelte store with all the logic in it, we can now create smaller well-encapsulated higher-order stores and put them into a custom Svelte store <a id="_idIndexMarker364"/>that you need.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/>Exercise</h2>
<p>Now, it’s time for an exercise.</p>
<p>The undo/redo store in the previous section is created as a custom Svelte store. Can you create an undo/redo higher-order store that turns any Svelte store into an undo/redo store with two additional methods, <code>undo()</code> and <code>redo()</code>?</p>
<p>Here’s an example of how the undo/redo higher-order store would be used:</p>
<pre class="source-code">
import { writable } from 'svelte/store';
const originalStore = writable(100);
const undoRedoStore = undoRedo(originalStore);
$undoRedoStore = 42;
undoRedoStore.undo(); // store value now goes back to 5</pre> <p>The preceding code snippet shows how we use the undo/redo higher-order store, <code>undoRedo</code>. The <code>undoRedo</code> function takes in a store, named <code>originalStore</code>, and returns a new store based on <code>originalStore</code> that has the undo/redo capability. For example, if we set a new value and then call the <code>undo</code> method, the store value will revert to its original state, which is <code>5</code> in this case.</p>
<p>You can find the solution for this exercise on GitHub here:</p>
<p><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store%0D">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store</a></p>
<p>In this section, we’ve explored the process of creating a <code>debounce</code> higher-order Svelte store using the <code>derived()</code> method. I look forward to you applying this knowledge in real-world scenarios.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Summary</h1>
<p>In this chapter, we looked at three different examples and learned three different techniques with a Svelte store.</p>
<p>We explored how to turn any user events into a data source for a Svelte store, learned how to create a Svelte store from scratch, and also learned how to use the built-in <code>readable()</code> function to make the process much simpler.</p>
<p>After that, we explored making a custom Svelte store with additional methods, building a new Svelte store based on the built-in writable store.</p>
<p>Lastly, we learned to create a higher-order store, a function that takes in a Svelte store and returns an enhanced version of the input store. In the example, we see how we can turn any Svelte store into a debounced version of itself.</p>
<p>By understanding these techniques, you’re now equipped to manage state in Svelte more effectively to craft more scalable and maintainable applications.</p>
<p>In the next chapter, we will look at state management in Svelte—namely, how to do state management with Svelte stores.</p>
</div>
</div></body></html>