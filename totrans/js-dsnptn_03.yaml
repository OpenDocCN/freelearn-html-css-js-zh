- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural design patterns give us tools to handle *connecting* different objects;
    in other words, managing the relationships between objects. This includes techniques
    to reduce memory usage and develop functionality with existing classes without
    modifying these existing classes. In addition, JavaScript features allow us to
    more effectively apply these patterns. Modern JavaScript includes some built-ins
    that allow us to implement structural design patterns in a more efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining structural design patterns as a whole, and proxy, decorator, flyweight,
    and adapter specifically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the proxy pattern with a class-based approach as well as
    an alternative using Proxy and Reflect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple implementations of the decorator pattern, leveraging JavaScript first-class
    support for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterative approach to implementing flyweight in JavaScript, including ergonomic
    improvements using modern JavaScript features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class- and function-based adapter implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll be able to make informed decisions on when
    and how to use structural design patterns in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  prefs: []
  type: TYPE_NORMAL
- en: What are structural design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building software, we want to be able to *connect* different pieces of
    code (e.g., classes and functions) and change how the parties involved in these
    connections and relationships interact without having to jump through multiple
    fragmented parts of the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns allow us to add, remove, and change functionality
    in modules and classes safely. The “structural” aspect of these patterns is due
    to the fact that we can play around with implementations if the exposed interfaces
    are stable.
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns are a good way to maintain the separation of concerns
    and loose coupling of different classes and modules while maintaining a high development
    velocity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at multiple approaches to implement the Proxy
    pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Proxy pattern with Proxy and Reflect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy pattern involves providing an object (the `subject`, or `real` object)
    that fulfills a certain interface. The `proxy` (a `placeholder` or `wrapper` object)
    controls access to the `subject`. This allows us to provide additional functionality
    on top of the subject without changing a consumer’s interactions with the `subject`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a proxy needs to provide an interface matching the `subject`.
  prefs: []
  type: TYPE_NORMAL
- en: By using the proxy pattern, we can intercept all operations on the original
    object and either pass them through or change their implementation. This follows
    the open/closed principle, where both the `subject` and `consumer` are closed
    for modification, but the proxy provides us with a hook to `extend`, which means
    the design is open to extension.
  prefs: []
  type: TYPE_NORMAL
- en: A redaction proxy implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start with the following implementation class that has a couple of methods
    that output strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s imagine that the `sensitive` string in the output should be redacted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how a `RedactionProxy` class could look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `RedactionProxy` does what we call a `someFn()` calls. In other
    words, `RedactionProxy#someFn` simply forwards the `someFn` call to `Implementation`.
    See the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to `sensitiveFn`, `RedactionProxy` implements the same interface
    as `Implementation` except it overrides the output, replacing `sensitive` with
    `[REDACTED]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means the interface for `RedactionProxy` and `Implementation` is the same,
    but `RedactionProxy` can control which method calls and fields are available along
    with their implementation. See the following example of this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proxy pattern allows us to intercept calls to an object (the `implementation`
    or `subject`) and augment them, either by manipulating the output or by adding
    a side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: Our example of redaction is a good use case for it, but any other type of instrumentation
    is also a good use case. The instrumentation could be concerned with measuring
    something about a function/field access (e.g. the time it takes) or ensuring access
    to a property triggers a certain effect. For example, the **reactivity** system
    of Vue.js and Alpine.js is based on proxies, where a JavaScript Proxy object is
    used to wrap the reactive data objects. This allows the library (Vue or Alpine)
    to detect when properties are changed and run things such as watchers, effects,
    and re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the proxy pattern in JavaScript with the Proxy and Reflect global
    objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back to our example, what happens when we need to redact more functions?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an `Implementation` class with three methods (`someFn`, `sensitiveFn`,
    and `otherSensitiveFn`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A naïve implementation of an extended proxy looks as follows, where each method
    calls the implementation’s method and then replaces `sensitive` in its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation of the `Proxy` works, as we can ensure with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One improvement we can make here is to extract a `#redact` private method to
    handle the replacement of `sensitive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The downside of this approach is that every method on the `Implementation` object
    (the subject) will require a change to our Proxy implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, JavaScript has a built-in class to programmatically manage these
    situations. The JavaScript class is aptly called `Proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the following plain JavaScript object (this also works for class
    instances) with both fields and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We want to be able to completely redact (i.e., keep none of the original output)
    those fields that contain `sensitive` in the field or method name. We also want
    to have a value redaction functionality when the output contains the string `sensitive`,
    where we replace `sensitive` with `[REDACTED]`.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we define a Proxy that will wrap our `obj` object. We instantiate
    the Proxy with a “get trap,” which allows us to intercept all property accesses
    (which includes function access).
  prefs: []
  type: TYPE_NORMAL
- en: The `get` function receives a `target` and `property`. The target is the object
    being wrapped (`obj`), `property` is the property being accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Based on whether `target[property]` is a function or not, we’ll replace it with
    a wrapper function that will collect all the arguments, call `target[property]`
    with those arguments, intercept the output, and replace `sensitive` with `[REDACTED]`.
    We also return `[REDACTED]` if the property name includes `sensitive` (in our
    case, using `sensitiveFn`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where `target[property]` is not a function, we’ll do a full redaction
    if the property name includes `sensitive` and also replace `sensitive` in the
    output for all other properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code ensures our Proxy implementation works as expected. `sensitive`
    is not present in any of the function output or in the `field` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One of the key benefits is the simplicity of the setup; all the redaction logic
    is contained in the `get` function, which keeps it localized.
  prefs: []
  type: TYPE_NORMAL
- en: As an effect of the co-located logic, we’ve been able to add redaction by property
    name in addition to redacting values.
  prefs: []
  type: TYPE_NORMAL
- en: There are still some slight issues with our current Proxy-based approach since
    we’re losing the `this` context on functions. We call `target[property](...args)`,
    which is fine as long as our object is not accessing `this`. We’ll further refactor
    our implementation to make further extension easier, as well as leveraging the
    `Reflect` global built-in object to simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: '`Reflect` provides functions with the same name as the `Proxy` trap with the
    same arguments; for example, `Reflect.get(target,` `property, receiver)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll extract a `redact` function, which takes a `propertyName` and a `redactionValue`.
    It will keep our redaction logic even more in sync by abstracting it to a separate
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use `redact` where necessary, use `Reflect.get()` as a shortcut
    to `target[property]`, and use `Reflect.apply` to maintain the `this` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our redaction still functions the same over values, function outputs, and property
    and function names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve delved into how to implement the proxy pattern, we’ll contrast
    it with the decorator pattern and which JavaScript tools we can use to implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern is similar to the proxy pattern in that it’s about “wrapping”
    an object. However, the decorator pattern is about adding functionality to an
    object at runtime. Different decorators can be applied to an object to add different
    functionalities to it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the following `HttpClient` class based on the `fetch` API, we want to
    instrument the requests made through this client. `HttpClient` implements `getJson`
    and returns JSON output if the `fetch` request succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`InstrumentedHttpClient`, which is a decorator, might look like the following,
    where we expose the same `getJson` method but have the added `requestTimings`
    field on the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When `getJson` is called, we track the start and end time of the `HttpClient#getJson`
    method call and add it to the instance’s `requestTimings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ensure that the `InstrumentedHttpClient` works as described with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decorator pattern, much like the proxy pattern, can be used to instrument
    or intercept operations on a “subject”.
  prefs: []
  type: TYPE_NORMAL
- en: One key difference is that the decorator is about adding “new members” to the
    class, not just maintaining the interface one to one. That’s why it’s normal for
    us to save an additional `requestTimings` field and access it from the “decorated”
    class, `InstrumentedHttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that multiple decorators can “stack” on top of each other. For example,
    we can have our `InstrumentedHttpClient`, which has `requestTimings`, and then
    create another decorator class that does something useful with the timing information.
    An example here is sending a “client-time” heuristic header that allows the server
    to stop processing a request once a certain amount time of time has passed since
    it knows the client will have aborted the connection by then.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements/limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to JavaScript’s first-class support for functions, we can use functions
    as the basis for decoration instead of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getJson` function could look as follows, with similar logic to the `HttpClient.getJson`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can then create an `addTiming` method that stores the request times in an
    `allOperationTimings` `Map` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using both aspects of first-class functions here – we’re passing a function
    as a parameter (`getJson`) and returning a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our decorator function is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke our instrumented function and check that it adds timings
    to our `allOperationTimings` `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One thing you might’ve noticed is that our `addTiming` *is* still aware of the
    `getJson` interface (it knows to pass a URL parameter and that `getJson` returns
    a Promise object). We’ll leave it as an exercise for the reader to implement,
    but it would be possible to turn `addTiming` into a function that can instrument
    the operation time of *any* JavaScript function; the tricky part is to find a
    good key for our operations map.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the chapter, we’ll look at the flyweight pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flyweight pattern is where the subset of object properties that have the
    same value are stored in shared “flyweight” objects.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern is useful when generating large quantities of objects
    that share a subset of the same values.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One concept from domain-driven design by Eric Evans is “value objects”. These
    value objects have the property that their contents matter more than their identity.
    Let’s take the example of a value object being a “coin” where, for the purposes
    of payment, two 50-cent coins are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects are interchangeable and immutable (a 50-cent coin can’t become
    a 10-cent coin). These types of objects are therefore a great fit for the Flyweight
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Not all properties of a “coin” are “value”-driven, for example, certain coins
    are made from certain materials and coins tend to be issued in a certain year.
    These two properties (material and year of issue) might be interesting to collectors
    and in this respect, real-world coins are not only value objects as two 1993 coins
    might be interesting in different ways in the context of a coin collection.
  prefs: []
  type: TYPE_NORMAL
- en: We therefore model our `Wallet` as containing a list of coins and our `Coin`
    as containing an amount (in cents or other “minor currency”), a currency, a year
    of issue, and a list of materials.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Class diagram where a Wallet has associated coins and methods
    to operate over them](img/B19109_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Class diagram where a Wallet has associated coins and methods to
    operate over them'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `CoinFlyweight` will be our “value object” and contain the `amount` and
    `currency`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The key benefit of the flyweight pattern is that we can reuse our flyweight
    objects. In order to do so, we need to control the instantiation of the flyweights
    with a factory (as covered in [*Chapter 1*](B19109_01.xhtml#_idTextAnchor018)*,
    Working with Creational Design Patterns*, The factory pattern in JavaScript section).
    We therefore define `CoinFlyweightFactory` with a static `get` method that takes
    the flyweight’s initialization parameters but only instantiates a new `CoinFlyweight`
    if one with the right amount and currency is not already present in memory. It
    also provides a `getCount` method to return the amount of flyweights currently
    instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another opportunity to use the Flyweight pattern is with materials. We can
    similarly create a `MaterialFlyweight` and reuse its values via a `MaterialFlyweightFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can implement the `Coin` and `Wallet` classes. Our `Coin` instance
    has a `flyweight` field, which is populated using the `CoinFlyweightFactory`.
    The `Coin#materials` field is populated with a regular array but the array’s contents
    are of `MaterialFlyweight`, loaded using the `MaterialFlyweightFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Wallet` is a plain JavaScript object. Its `add` method creates a new `Coin`
    instance and pushes it into the Wallet’s `coins` field. `getTotalValueForCurrency`
    sums the coin’s values for a given currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The wallet can be used as follows, adding GBP and USD of different denominations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that while the wallet instance contains eight coins, we’ve created six
    `CoinFlyweight` and five `MaterialFlyweight` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flyweight pattern is a normalization technique that reduces the memory footprint
    at the cost of cognitive overhead when accessing and running computations over
    objects using this pattern. Flyweight can be leveraged as a performance optimization
    when handling large numbers of objects.
  prefs: []
  type: TYPE_NORMAL
- en: It’s *very* well suited to modeling value objects as we’ve shown in the previous
    section. The only drawback was the `getTotalValueForCurrency`, where we had to
    read `coin.flyweight.currency` and `coin.flyweight.amount`.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements/limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few improvements we can make to our flyweight wallet/coin setup.
    A few of the improvements center on the “factories”. The `flyweights` shouldn’t
    really be accessed from outside of the `get` function, so we can make it a private
    field using `#flyweights`. We can also leverage the `Map` object, still with the
    same cache key, although `Map` has greater flexibility in terms of what keys can
    be used and a different property access interface (`.get(key)` instead of `[key]`
    access). Using a `Map` means we need to use `this.#flyweights.size` in `getCount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Another change we’ll make is in light of the fact that there were not any material
    gains by making `materials` a flyweight, so we’ll revert it to storing the list
    of strings per `Coin` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we want to make `#flyweight` private, this will change the interface
    of `Coin` since consumers will not be able to access `coin.#flyweight` (it’s a
    private field).
  prefs: []
  type: TYPE_NORMAL
- en: 'What we’ll do is tackle the mismatch of having to read `coin.flyweight.amount`
    and `coin.flyweight.currency`. We’ll supply two getters, `get amount()` and `get
    currency()`, which will return `this.#flyweight.amount` and `this.#flyweight.currency`
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, the interface of `Coin` doesn’t have a `flyweight` property so
    `getTotalValueForCurrency` will read from `Coin#currency` and `Coin#amount`. As
    far as `Wallet` is concerned, `currency` and `amount` are fields on the `Coin`
    instance, although they’re getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that our new `Wallet` and `Coin` implementations work as expected
    by using the same tests as in our earlier iteration of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen how the flyweight pattern can be used to optimize memory usage by
    using shared value objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the chapter, we’ll look at the last structural design pattern
    covered in this book, the adapter pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter pattern, similar to the other structural design patterns, focuses
    on interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In the adapter pattern’s case, it involves being able to use a new implementation
    without changing the consumer or the implementation’s interface. The “adapter”
    takes the new implementation and “adapts” the interface to match what the consumer
    expects.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not changing the implementation *or* the consumer; rather, we’re building
    an adapter to wrap the implementation and plug it into the consumer without changing
    either.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with a simple in-memory database that uses a naive `IdGenerator`
    to generate keys for the database entries by encoding the object as a string.
  prefs: []
  type: TYPE_NORMAL
- en: '`Database` has a `createEntry` method that stores given data using the `IdGenerator`
    to generate a key. `Database` also has a `get` method to recall entries by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By composing `Database` with an `IdGenerator` instance, we get a key-value
    lookup database instance with the key equal to the JSON representation of the
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the naive ID generation that encodes the whole entry value in the key
    is not ideal. An alternative is to use a UUID. Here’s a `UuidFactory` using the
    `uuid` npm module. The key operation it exposes is `generateUuid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `UuidFactory` with our `Database`, we would need a `get` method
    instead of a `generateUuid` method. This is where our adapter comes in – we can
    wrap the `UuidFactory` in a class that exposes `get(entry)` but calls `generateUuid`
    on the `UuidFactor` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UuidIdGeneratorAdapter` can then be passed as the `idGenerator` to `Database`.
    It all works as expected, where the entry IDs for the database are UUIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example that makes use of the fact that the `entry` is being passed
    to `idGenerator.get()` is to generate prefixed auto-incrementing IDs based on
    the `entry` contents. Here, `name` will be used as the prefix. We have a `Counter`
    class that implements `getAndIncrement(prefix)`, which generates incrementing
    IDs given a prefix (or no prefix):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, `getAndIncrement(prefix)` doesn’t match the `IdGenerator` interface
    (no `get` method). We can wrap `Counter` in a `PrefixedAutoIncrementIdGeneratorAdapter`
    to expose an `IdGenerator` interface but using the `Counter` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ensure the prefixing logic works as expected for the `Database` since
    it creates entries keyed by prefixed auto-incrementing IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that the case where no `name` field is set works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And the scenarios where a prefix is available also functions correctly per
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The adapter pattern is useful when you need to use two classes that weren’t
    specifically designed to work together. Consider, for example, a third-party library
    or module that exposes a function (such as the `uuid` module or even `UuidFactory`
    from our scenario). We want to abstract the implementation behind an interface,
    in our case the interface of `IdGenerator`, which is just a `get` method, so that
    any implementation can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Our example showcased the value of the adapter pattern. We were able to create
    very differently behaving databases without changing `UuidFactory`, `Counter`,
    or `Database` for that matter. This is very important when having to connect two
    third-party modules or modules which are self-contained and shouldn’t be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the adapter pattern therefore means that we can avoid changing difficult-to-understand
    code while delivering the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements/limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similarly, to the *Decorator in JavaScript - Improvements/limitations* section,
    one of the JavaScript features that can help when implementing structural design
    patterns is the first-class support for functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of an `IdGenerator` class, we can have a `defaultIdGenerator` function
    that takes an entry and returns a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Database` class would now look something as follows, where `this.idGenerator(entryData)`
    is called directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate that the naive implementation still works by serializing whatever
    is passed to it as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This approach shines when we need to plug in the UUID and prefix generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `uuidGenerator` function can call `uuidv4()`. We can validate that `uuidIdDatabase`
    uses UUIDs to key and recall the entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a `prefixAutoIncrementIdGenerator` would look as follows. We’re using
    module-scoped variables, which is another feature of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This code would be in a different module than its consumer, so it would be `export
    function prefixAutoIncrementIdGenerator` and its consumer would import `{prefixAutoIncrementIdGenerator}`
    from `'./path-to-module.js'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`prefixAutoIncrementIdGenerator` functions like the `PrefixedAutoIncrementIdGeneratorAdapter`
    class did, generating auto-incrementing IDs and prefixing them where possible
    by `entry.name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this final section of the chapter, we covered the adapter pattern and how
    to use it when the consumer expects a class but also a function in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at how structural design patterns enable the extension
    of functionality without needing to rework interfaces in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy design pattern is useful when we want to intercept calls to an object
    without changing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the decorator design pattern concerns itself with dynamically adding
    functionality through new instance members.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern can be used effectively for managing large numbers of
    objects, which is especially useful for value objects. There are workarounds in
    JavaScript for some of the ergonomic drawbacks of it.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern allows us to integrate multiple classes, modules, or functions
    with different opinions and interfaces without modifying them. The shape of the
    adapter is dictated by the existing modules and classes that we’re attempting
    to connect together.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to organize relationships between different objects and
    classes with structural design patterns, in the next chapter, we’ll cover how
    to use behavioral design patterns to organize communication between objects.
  prefs: []
  type: TYPE_NORMAL
