<html><head></head><body>
        

                            
                    <h1 class="header-title">Extending Types with New Behavior</h1>
                
            
            
                
<p>In the previous chapter, we have seen that Reason provides tools and techniques that open possibilities for programming generically. One is parametric polymorphism using type variables. Another one is the functor, which can take one or several modules as parameters and return a module.</p>
<p>In this chapter, we are going to look at ways of extending types themselves to add behavior to them. One such technique available in Reason is called <strong>subtyping</strong>. The idea is to have a hierarchical relation of types, with specific types being subtypes of more generic types. For example, a <em>cat</em> could be a subtype of <em>mammal</em>, which itself is a subtype of <em>vertebrate</em>.</p>
<p>We can find a definition about the subtyping approach in the OCaml documentation:</p>
<p>Subtyping governs when an object with one type A can be used in an expression that expects an object of another type B. When this is true, we say that A is a subtype of B. More concretely, subtyping restricts when the coercion operator <kbd>e :&gt; t</kbd> can be applied. This coercion works only if the type of e is a subtype of t.</p>
<p>In addition to subtyping, there are techniques similar to what we do with <strong>Object-Oriented Programming (OOP)</strong>-style inheritance, which can be useful.</p>
<p>Depending on the situation and use cases, you can leverage one or several of these techniques to improve your code's structure and make it easy to extend its features, while keeping your code type-safe.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Subtyping using polymorphic variants</li>
<li>Code reuse with OOP-style inheritance</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Subtyping using polymorphic variants</h1>
                
            
            
                
<p>As we have seen in <a href="d3723975-7a3c-4369-84fe-272b67870234.xhtml">Chapter 5</a>, <em>Putting Alternative Values in Types,</em> Reason has the concept of variant types, which can be leveraged in pattern matching and exhaustivity checking. Variant types have their more complex and powerful version called <strong>polymorphic variants</strong><em>.</em> They give us more flexibility than regular variants. Among other things, they are defined using a special syntax, such as <kbd>type color = [`Red | `Orange | `Yellow | `Green | `Blue ];</kbd>, and their constructors exist independently.</p>
<p>Let's see how they can be used for extending type behavior using subtyping.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reusing constructors for different types</h1>
                
            
            
                
<p>Since constructors exist independently, we can use the same constructor more than once. So, we can define a type, <kbd>rgb</kbd>, that uses the <kbd>Red</kbd>, <kbd>Green</kbd>, and <kbd>Blue</kbd> constructors that came with the definition for the type, <kbd>color</kbd>.</p>
<p>Here, we start with both type definitions, followed by a couple of bindings to use those types (<kbd>onegreen</kbd> and <kbd>othergreen</kbd>):</p>
<pre><strong>type color</strong> = [`Red | `Orange | `Yellow | `Green | `Blue ];<br/><strong>type rgb</strong> = [`Red | `Green | `Blue];<br/><br/>/* Bindings using the variants we defined */<br/>let <em>onegreen</em>: color = `Green;<br/>let <em>othergreen</em>: rgb = `Green;</pre>
<p>Let's also add code to show the values:</p>
<pre>/* Console log */<br/>Js.log(onegreen);<br/>Js.log(othergreen);</pre>
<p>At this point, if you try executing the JavaScript resulting from the compilation of this Reason code, you would get output similar to this:</p>
<pre>756711075<br/>756711075</pre>
<p>As we can see, the identifier printed is the same for both variables, which we could have had the intuition of, since we have used the same constructor (<kbd>`Green</kbd>).</p>
<p class="mce-root"/>
<p>Let's make this visually interesting by adding functions that stringify the values.</p>
<p>We add a function that gives a string value for each color, as follows:</p>
<pre>let <em>stringOfColor</em> = (c: color) : string =&gt; {<br/> switch (c) {<br/> |<em> `Red</em> =&gt; "red"<br/> | <em>`Orange</em> =&gt; "orange"<br/> | <em>`Yellow</em> =&gt; "yellow"<br/> | <em>`Green</em> =&gt; "green"<br/> | <em>`Blue</em> =&gt; "blue"<br/> }<br/>};</pre>
<p>We add a function that gives a string value for each <em>RGB color</em>, as follows:</p>
<pre>let <em>stringOfRgb</em> = (c: rgb) : string =&gt; {<br/> switch (c) {<br/> | <em>`Red</em> =&gt; "RGB red"<br/> | <em>`Green</em> =&gt; "RGB green"<br/> | <em>`Blue</em> =&gt; "RGB blue"<br/> }<br/>};</pre>
<p>And we add the same code that is useful to log the values, as follows:</p>
<pre>Js.log(stringOfColor(onegreen));<br/>Js.log(stringOfRgb(othergreen));</pre>
<p>So, what's the result of this new experiment? The compilation of the complete version of the code (in the <kbd>src/Ch09/Ch09_Example1.re</kbd> file) gives a JS code file which, when executed using the <kbd>node</kbd> command, would give an output similar to this:</p>
<pre>756711075<br/>756711075<br/>green<br/>RGB green</pre>
<p>As you would have guessed, using two different functions, we were able to differentiate the output based on the type of the input (and the constructor involved, for example, the polymorphic constructor, <kbd>Green</kbd>).</p>
<p>As an exercise left for the reader, add <kbd>Js.log(stringOfRgb(onegreen));</kbd> to the ReasonML code and see what you get as output for that call.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">An example of polymorphic variant type extension</h1>
                
            
            
                
<p>There is a more interesting trick of code reuse. It is possible to extend an existing polymorphic variant type to create a new one. Let's see this through another example.</p>
<p>Let's say we want to handle input for shoe categories, for both the general public and for women, and we started by defining the categories specific to women, as follows:</p>
<pre><strong>type onlyWomanShoe</strong> = [`Slingbacks | `HighHeels];</pre>
<p>We could define the polymorphic variants for all (women and men) by reusing that type definition and extending it, as follows:</p>
<pre><strong>type shoe </strong>= [onlyWomanShoe | `Moccasins | `Boots | `Sneakers | `Wingtips];</pre>
<p>We can see the result of these types with the code file, <kbd>src/Ch09/Ch09_Example2.re</kbd>. As usual, we add some console logging (with <kbd>Js.log()</kbd>) to make things interesting. The complete code is as follows:</p>
<pre><strong>type onlyWomanShoe</strong> = [`Slingbacks | `HighHeels];<br/><strong>type shoe</strong> = [onlyWomanShoe | `Moccasins | `Boots | `Sneakers | `Wingtips];<br/><br/>let <em>johndoe_shoe</em>: shoe = `Moccasins;<br/>let <em>janedoe_shoe</em>: shoe = `Slingbacks;<br/><br/>Js.log(johndoe_shoe);<br/>Js.log(janedoe_shoe);<br/><br/>let <em>infoAboutShoe</em> = (s: shoe) : string =&gt; {<br/> switch (s) {<br/> | <em>`Slingbacks</em> =&gt; "Slingbacks - Specific woman shoe"<br/> | <em>`HighHeels</em> =&gt; "High Heels - Specific woman shoe"<br/> | <em>`Moccasins</em> =&gt; "Moccasins"<br/> | <em>`Boots</em> =&gt; "Boots"<br/> | <em>`Sneakers</em> =&gt; "Sneakers"<br/> | <em>`Wingtips</em> =&gt; "Wingtips"<br/> }<br/>};<br/><br/>Js.log(infoAboutShoe(johndoe_shoe));<br/>Js.log(infoAboutShoe(janedoe_shoe)); </pre>
<p class="mce-root"/>
<p class="mce-root">Executing the JS code that results from the compilation gives an output similar to the following:</p>
<pre>265261402<br/>-594895036<br/>Moccasins<br/>Slingbacks - Specific woman shoe</pre>
<p>It is interesting to see what could happen at compile time if you make a mistake when binding the constructor to the <kbd>janedoe_shoe</kbd> variable, for example, writing the following:</p>
<pre>let <em>janedoe_shoe</em>: onlyWomanShoe = `Slingbacks;</pre>
<p>Try it, and during re-compilation, you will immediately see an error similar to the following:</p>
<pre>  This has type:<br/>    onlyWomanShoe<br/>  But somewhere wanted:<br/>    shoe<br/>  The first variant type does not allow tag(s)<br/>  `Boots, `Moccasins, `Sneakers, `Wingtips</pre>
<p>Now, back to our normal code! Could we improve our code here to write less? Could we leverage the variants type, <kbd>onlyWomanShoe</kbd>, in the <kbd>infoAboutShoe()</kbd> function, to avoid the two lines in the <kbd>switch</kbd> block for <kbd>Slingbacks</kbd> and <kbd>HighHeels</kbd>, and try to make this really powerful?</p>
<p>There is a trick to do that, using a syntax sugar within the <kbd>switch</kbd> block of the function: <kbd>#onlyWomanShoe</kbd>.</p>
<p>We will explain in detail later where this comes from, but basically we could write this almost-equivalent code (<kbd>src/Ch09/Ch09_Example2bis.re</kbd>), where we only change the body of the <kbd>infoAboutShoe</kbd> function, as follows:</p>
<pre>let <em>infoAboutShoe</em> = (s: shoe) : string =&gt; {<br/>    switch (s) {<br/>        | <em>#onlyWomanShoe</em> =&gt; "Woman shoe such as Sandals or High Heels"<br/>        | <em>`Moccasins</em> =&gt; "Moccasins"<br/>        | <em>`Boots</em> =&gt; "Boots"<br/>        | <em>`Sneakers</em> =&gt; "Sneakers"<br/>        | <em>`Wingtips</em> =&gt; "Wingtips"<br/>    }<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Executing the JS code produced by the compilation gives output such as the following:</p>
<pre>265261402<br/>-594895036<br/>Moccasins<br/>Woman shoe such as Slingbacks or High Heels</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">More about extending polymorphic variant types</h1>
                
            
            
                
<p>Suppose we have a type definition for websites and we want to extend it to all web apps (including personal productivity tools, social networks, and even APIs). We could first define the main things that characterize a website, such as the following:</p>
<ul>
<li>The domain</li>
<li>Whether there is an access by login or not (for the main content), that is, private or public access</li>
</ul>
<p>To get started, we can first define two utility types, <kbd>domain</kbd> and <kbd>accessType</kbd>, as follows:</p>
<pre class="mce-root"><strong>type domain</strong> = [ `Domain(string) ];<br/><strong>type accessType</strong> = [`Private | `Public];</pre>
<p class="mce-root">Then, we add a helper function to stringify the <kbd>accessType</kbd> values:</p>
<pre class="mce-root">let <em>accessTypeName</em> = (a: accessType) : string =&gt; {<br/> switch (a) {<br/> | <em>`Private</em> =&gt; "private"<br/> | <em>`Public</em> =&gt; "public"<br/> }<br/> };</pre>
<p class="mce-root">Now, let's define the variants type for websites:</p>
<pre><strong>type website</strong> = [<br/> | <em>`CorporateSite</em>(domain)<br/> | <em>`CommerceSite</em>(domain, accessType)<br/> | <em>`Blog</em>(domain, accessType)<br/> ];</pre>
<p class="mce-root"/>
<p>We then add a function that would return a short summary text containing the information for each website:</p>
<pre>let <em>siteSummary</em> = (app: website) : string =&gt; {<br/> switch (app) {<br/> | <em>`CorporateSite</em>(`Domain(s)) =&gt; s ++ " - corporate site (public)"<br/> | <em>`CommerceSite</em>(`Domain(s), a) =&gt; s ++ " - commerce site (" ++ accessTypeName(a) ++ ")"<br/> | <em>`Blog</em>(`Domain(s), a) =&gt; {<br/> switch (a) {<br/> | <em>`Private</em> =&gt; s ++ " - " ++ "corporate blog (" ++ accessTypeName(a) ++ ")"<br/> | <em>`Public</em> =&gt; s ++ " - blog (public - login-based access for authors)"<br/> }<br/> }<br/> }<br/>};</pre>
<p>As usual, for testing purposes, we add a few bindings and show the results in the console using <kbd>Js.log()</kbd>:</p>
<pre>let <em>mysite</em> = `CorporateSite(`Domain("www.acme.com"))<br/>Js.log(siteSummary(mysite))<br/><br/>let <em>myblog</em> = `Blog(`Domain("www.contentgardening.com"), `Public)<br/>Js.log(siteSummary(myblog))<br/><br/>let <em>corpinternalblog</em> = `Blog(`Domain("internalblog.acme.com"), `Private)<br/>Js.log(siteSummary(corpinternalblog))</pre>
<p>We can see that part working. But, we are not done yet. We also want to extend that code to apply to any webapp. So, we define a new type, for <em>web apps</em> (<kbd>webapp</kbd>, as you would guess) with the intent of being an extension of the <em>websites</em> one. The type definition is as follows:</p>
<pre><strong>type webapp</strong> = [<br/> | <em>`CorporateSite</em>(domain)<br/> | <em>`CommerceSite</em>(domain, accessType)<br/> | <em>`Blog</em>(domain, accessType)<br/> | <em>`SocialApp</em>(domain)<br/> ];</pre>
<p>After that, we add a new function (<kbd>appSummary()</kbd>) that will extend the previous one (<kbd>siteSummary()</kbd>). One technique we use here is the <kbd>as</kbd> keyword, allowing us (in the <kbd>switch</kbd> part of the function) to match a result to a constructor of the <kbd>website</kbd> variant type. For example, we can write <kbd>`CorporateSite(`Domain(s)) as ws</kbd>.</p>
<p class="mce-root"/>
<p>We can define the function as follows:</p>
<pre>let <em>appSummary</em> = (app: webapp) : string =&gt; {<br/> switch (app) {<br/> | <em>`CorporateSite</em>(`Domain(s)) as ws =&gt; siteSummary(ws)<br/> | <em>`CommerceSite</em>(`Domain(s), a) as ws =&gt; siteSummary(ws)<br/> | <em>`Blog</em>(`Domain(s), a) as ws =&gt; siteSummary(ws)<br/> | <em>`SocialApp</em>(`Domain(s)) =&gt; s ++ " - social app"<br/> }<br/>};</pre>
<p>Note that we can actually improve this a little bit; to avoid the compiler from complaining about the <kbd>s</kbd> and <kbd>a</kbd> variables not being used in the first three lines of the <kbd>switch</kbd> block, we can replace those variables by the <kbd>_</kbd>. The improved function is as follows:</p>
<pre>/* 1) the extended function **/<br/>let <em>appSummary</em> = (app: webapp) : string =&gt; {<br/> switch (app) {<br/> | <em>`CorporateSite</em>(`Domain(_)) as ws =&gt; siteSummary(ws)<br/> | <em>`CommerceSite</em>(`Domain(_), _) as ws =&gt; siteSummary(ws)<br/> | <em>`Blog</em>(`Domain(_), _) as ws =&gt; siteSummary(ws)<br/> | <em>`SocialApp</em>(`Domain(s)) =&gt; s ++ " - social app"<br/> }<br/>};</pre>
<p>We can finish by adding some testing code, as follows:</p>
<pre>Js.log("---")<br/>let <em>fb</em> = `SocialApp(`Domain("facebook.com"))<br/>Js.log(appSummary(fb))</pre>
<p>But wait, there is more improvement possible!</p>
<p>Another technique is to reuse the first type via the <kbd>#website as ws</kbd> syntax and that allows us to completely replace the lines related to the <kbd>website</kbd> variant type constructors in the pattern matching.</p>
<p>The final version of the function would then be as follows:</p>
<pre>/* 2) the extended function improved! **/<br/>let <em>appSummaryImproved</em> = (app: webapp) : string =&gt; {<br/> switch (app) {<br/> | #website as ws =&gt; siteSummary(ws)<br/> | <em>`SocialApp</em>(`Domain(s)) =&gt; s ++ " - social app"<br/> }<br/>};</pre>
<p>And, after this update, to make things interesting, here is the final testing and value display code:</p>
<pre>Js.log("------")<br/>Js.log(appSummaryImproved(mysite))<br/>Js.log(appSummaryImproved(myblog))<br/>Js.log(appSummaryImproved(corpinternalblog))<br/>Js.log(appSummaryImproved(fb))</pre>
<p>We can see that executing the JavaScript code produced by the compilation gives the following output:</p>
<pre>www.acme.com - corporate site (public)<br/>www.contentgardening.com - blog (public - login-based access for authors)<br/>internalblog.acme.com - corporate blog (private)<br/>---<br/>facebook.com - social app<br/>------<br/>www.acme.com - corporate site (public)<br/>www.contentgardening.com - blog (public - login-based access for authors)<br/>internalblog.acme.com - corporate blog (private)<br/>facebook.com - social app</pre>
<p>We just saw a nice type extension technique supported by Reason with polymorphic type variants.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code reuse with OOP-style inheritance</h1>
                
            
            
                
<p>Inheritance, as we have in object oriented programing languages, is not commonly used in Reason. However, we can find a couple of examples of techniques that resemble OOP-style inheritance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Opening a module</h1>
                
            
            
                
<p>Constantly referring to something in a module imposes a lot of writing on the developer. This is where <kbd>open</kbd> is handy.</p>
<p>Without this feature, let's say you have the <kbd>ColorExample</kbd> module (based on code we already used in the first example of this chapter), defined as follows:</p>
<pre>/* A module */<br/>module ColorExample = { <br/>  <strong>type color</strong> = [`Red | `Orange | `Yellow | `Green | `Blue ];<br/>  <strong>type rgb</strong> = [`Red | `Green | `Blue];<br/><br/>  let <em>onegreen</em>: color = `Green;<br/>  let <em>othergreen</em>: rgb = `Green;<br/><br/>  let <em>stringOfColor</em> = (c: color) : string =&gt; {<br/>    switch (c) {<br/>        | <em>`Red</em> =&gt; "red"<br/>        | <em>`Orange</em> =&gt; "orange"<br/>        | <em>`Yellow</em> =&gt; "yellow"<br/>        | <em>`Green</em> =&gt; "green"<br/>        | <em>`Blue</em> =&gt; "blue"<br/>    }<br/>  };<br/><br/>  let <em>stringOfRgb</em> = (c: rgb) : string =&gt; {<br/>    switch (c) {<br/>        | <em>`Red</em> =&gt; "RGB red"<br/>        | <em>`Green</em> =&gt; "RGB green"<br/>        | <em>`Blue</em> =&gt; "RGB blue"<br/>    }<br/>  };<br/>}</pre>
<p>You can use the function by using the <kbd>ColorExample.stringOfColor</kbd> reference and similarly for the values. So, some value display code would look like the following (as actually seen in the <kbd>src/Ch09/Ch09_Open_module.re</kbd> file):</p>
<pre>/* Use the module the default way */<br/>Js.log("1/ Use function and values inside the module...");<br/>Js.log(ColorExample.stringOfColor(ColorExample.onegreen));<br/>Js.log(ColorExample.stringOfRgb(ColorExample.othergreen));</pre>
<p>But, with the <kbd>open</kbd> solution for opening the module within a scope, we can write more compact code, as follows (in the same <kbd>src/Ch09/Ch09_Open_module.re</kbd> file):</p>
<pre>/* Open the module and use its content */<br/>Js.log("2/ Use function and values from the module after opening it...");<br/>let colorString = {<br/>  open ColorExample;<br/>  let oneblue: color = `Blue;<br/>  Js.log("String value of another color: " ++ stringOfColor(oneblue));<br/>};</pre>
<p class="mce-root"/>
<p>And things work as expected! The code file when executed gives the following output:</p>
<pre>1/ Use function and values inside the module...<br/>green<br/>RGB green<br/>2/ Use function and values from the module after opening it...<br/>String value of another color: blue</pre>
<p>What happens is that all of the contents of the module are magically accessible without the need to add the prefix that would normally be added (the <kbd>ColorExample.</kbd> part, in this case) when accessing the types, functions, and variables it contains. It brings the module's content into the current scope.</p>
<p>We could have done things in an alternative way: have the module in its own file for better separation of code. There are cases where you would want to do that if it better fits your way of organizing the code. So basically, let's move the module's code in the <kbd>src/Ch09/Ch09_OpenModulebisPart1.re</kbd> file, for example, as follows:</p>
<pre><strong>module</strong> ColorExample = { <br/>  <strong>type color</strong> = [`Red | `Orange | `Yellow | `Green | `Blue ];<br/>  <strong>type rgb</strong> = [`Red | `Green | `Blue];<br/><br/>  let <em>onegreen</em>: color = `Green;<br/>  let <em>othergreen</em>: rgb = `Green;<br/><br/>  let <em>stringOfColor</em> = (c: color) : string =&gt; {<br/>    <em>switch</em> (c) {<br/>        | <em>`Red</em> =&gt; "red"<br/>        | <em>`Orange</em> =&gt; "orange"<br/>        | <em>`Yellow</em> =&gt; "yellow"<br/>        | <em>`Green</em> =&gt; "green"<br/>        | <em>`Blue</em> =&gt; "blue"<br/>    }<br/>  };<br/><br/>  let <em>stringOfRgb </em>= (c: rgb) : string =&gt; {<br/>    switch (c) {<br/>        | <em>`Red</em> =&gt; "RGB red"<br/>        | <em>`Green</em> =&gt; "RGB green"<br/>        | <em>`Blue</em> =&gt; "RGB blue"<br/>    }<br/>  };<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Then, in another code file (<kbd>src/Ch09/Ch09_OpenModulebisPart2.re</kbd>, for example), we can open the module and access its functions and values, as follows:</p>
<pre>open Ch09_OpenModulebisPart1.ColorExample;<br/><br/>Js.log(stringOfColor(onegreen));<br/>Js.log(stringOfRgb(othergreen));<br/><br/>let <em>colorString</em> = {<br/>  let <em>oneblue</em>: color = `Blue;<br/> Js.log("String value of another color: " ++ stringOfColor(oneblue));<br/>};</pre>
<p>That's it! We have seen how to leverage <kbd>open</kbd> for opening modules in Reason. And, in code that you can find written by other developers, you can find it used a lot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Including a module</h1>
                
            
            
                
<p>Reason also provides a way to reuse a module already defined, and extend it like in OOP: the <kbd>include</kbd> keyword.</p>
<p>Regarding this feature, the documentation actually says the following:</p>
<p>Using <kbd>include</kbd> in a module, statically transfers a module's content into a new one. Thus often fulfills the role of inheritance or mixing.</p>
<p>Let's say we have a base module as follows:</p>
<pre><strong>module</strong> <em>Site</em> = {<br/> let <em>siteEnvMarker</em> = "TESTING";<br/> let <em>protocol</em> = (~secured) =&gt; secured ? "https" : "http";<br/> let <em>getInfo</em> = domainName =&gt; protocol(~secured=false) ++ "://" ++ domainName ++ " (" ++ siteEnvMarker ++ ")";<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Now, we reuse it in the following module, using the <kbd>include</kbd> technique, as follows:</p>
<pre><strong>module</strong> ProductionSite = {<br/> include Site;<br/> let <em>siteEnvMarker</em> = "production!";<br/> let <em>getPublicInfo</em> = domainName =&gt; {<br/> let <em>additionalText</em> = " (" ++ String.uppercase(siteEnvMarker) ++ ")";<br/> let <em>result</em> = protocol(~secured=true) ++ "://" ++ domainName ++ additionalText;<br/> Js.log(result);<br/> }<br/>};</pre>
<p>And, we can display information using a function from each module, in order to compare the behavior:</p>
<pre>Js.log(Site.getInfo("dev-acme.com"));<br/>print_newline();<br/>ProductionSite.getPublicInfo("acme.com");</pre>
<p>Executing the JS code produced by compiling our code (in the <kbd>src/Ch09/Ch09_Include_module.re</kbd> file) gives the following output:</p>
<pre>http://dev-acme.com (TESTING)<br/><br/>https://acme.com (PRODUCTION!)</pre>
<p>Interesting. You could already have the intuition of what happens here, but the ReasonML documentation about <kbd>include</kbd> stipulates that this technique copies over the definition of a module <em>statically</em>, then also performs <kbd>open</kbd>. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have now seen how you can leverage two types of techniques, subtyping using polymorphic variants and OOP-style inheritance with modules, to improve your code structure and make it easy to add behavior to types.</p>
<p>With polymorphic variant types, we can reuse constructors for different types because of their design. Furthermore, it is possible to extend a polymorphic variant type to create a new one.</p>
<p>With modules, we can open an existing module to use functions and bindings defined in it, and we can include it in a new module to extend its behavior line in OOP-style inheritance.</p>
<p>In the next and last chapter, we are going to go through a final example where we bring together the main techniques we have learned so far.</p>


            

            
        
    </body></html>