- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing npm Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before now, our main focus has been to learn everything about improving and
    contributing to existing projects, but quite often, this is not everything. Some
    projects will need to be initiated correctly by you and one part of this process
    is to decide which packages should actually be reused.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already learned that reusability in Node.js is primarily gained through
    the module system, which can be enhanced by third-party dependencies in the form
    of npm packages. In this chapter, you’ll learn how you can publish npm packages
    yourself. This way, a functionality implemented once can be shared among the team
    working on the same project or with anyone.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve our goal in this chapter, first, we’ll set up a simple library to
    serve our case well. Then, we publish this library to the official npm registry
    in a way that makes the code available to any Node.js developer. If you want to
    keep your library a bit less exposed, then the following sections will be interesting
    for you. In these, you will first learn how to select other registries before
    you actually select a local registry to use for publishing and installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll also look at ways to broaden the scope of our library – by making
    it **isomorphic** or exposing it as a tool. In summary, we’ll cover the following
    key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to the official registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting another npm registry via `.npmrc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Verdaccio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing isomorphic libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a cross-platform tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3UmhN4B](https://bit.ly/3UmhN4B).
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to the official registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by creating a small library that uses a structure that can be seen
    very often in Node.js projects. The structure consists of an `src` folder, where
    the original sources are located, and a `lib` folder, containing the output to
    be used by the target system. The target system could either be something such
    as a bundler for browser applications or a specific version of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize this kind of project, we can use the `npm` command-line utility
    as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll set everything up. First, we will install `esbuild` as a development
    dependency. This can be very helpful for transforming our source files into usable
    library files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we change `package.json` to fit our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Importantly, replace the chosen placeholder’s name (`florian-rappl` in the `name`
    field and `Florian Rappl` in the `author` field) with your name. For the `name`
    field, make sure to only use letters allowed for package name identifiers. Also,
    feel free to change the selected license.
  prefs: []
  type: TYPE_NORMAL
- en: Licenses
  prefs: []
  type: TYPE_NORMAL
- en: An important piece of information in every `package.json` is the `license` field.
    While the MIT License is a very good choice for many open-source projects, it
    is by no means the only one. Other popular choices include the Apache License
    2.0, BSD 3-Clause, and the ISC License.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll add some content to our source file:'
  prefs: []
  type: TYPE_NORMAL
- en: src/index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This file was written in a way that makes sense for us as developers, but cannot
    be run by Node.js directly. The problem is twofold. First, we are using ESM syntax
    without guaranteeing that Node.js supports this. Second, we are mixing ESM constructs
    such as `import` and `export` with CommonJS constructs such as `__dirname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we already installed `esbuild` to take care of this, with the defined
    `build` script actually using it for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have two directories in our project: `src`, containing the
    original sources, and `lib`, containing the CommonJS output. This is also reflected
    in `package.json`, where the source field points to `src/index.js` and the `main`
    field points to `lib/index.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as a reminder: the `main` field tells Node.js what module to use in case
    the package is included via `require` – for example, `require(''lib-test-florian-rappl'')`
    would reference and evaluate the `lib/index.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to publish this package now to the official npm registry.
    For this, you first need an account on [npmjs.com/signup](https://npmjs.com/signup).
    Once successfully registered and logged in, you should see a view similar to that
    in *Figure 8**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The view on npmjs.com once logged in ](img/Figure_8.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The view on npmjs.com once logged in
  prefs: []
  type: TYPE_NORMAL
- en: 'On your own machine, you can now authenticate to the official npm registry
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will request your username and password. Alternatively, you could authenticate
    using so-called access tokens. This is especially useful for scripts, such as
    automation running in a CI/CD pipeline. To generate a new access token, follow
    the link highlighted in *Figure 8**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have authenticated the `npm` utility, you can go ahead and publish
    your package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will package your project as a compressed archive. Then, the utility will
    upload the tarball to the official npm registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can go to [npmjs.com](https://npmjs.com) to look for your package
    name. You should see the package info page similar to *Figure 8**.2* with more
    details about the published package. Note that we did not include a `README.md`
    or any keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The details of the published package ](img/Figure_8.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The details of the published package
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you might consider is to give your package a scope. When you
    publish a package with a scope, then you’ll need to configure the access settings
    of the package. By default, non-scoped packages are public, and scoped packages
    are private.
  prefs: []
  type: TYPE_NORMAL
- en: For publishing a scoped package to the official npm registry, you’ll first need
    to be either a member or owner of an organization on the npm website. The organization
    name must match the name of the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Package scope
  prefs: []
  type: TYPE_NORMAL
- en: A good way to group packages is to put them in a common scope. The scope has
    to start with an “@” symbol, which is followed by the name of the scope. The rules
    for the name of the scope are identical to package names. Besides grouping packages,
    scopes can be used to place certain packages in a different registry without much
    trouble. Most importantly, scopes can be reserved on the official npm registry,
    such that only authorized accounts can publish new packages using a reserved scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'To consistently publish a scoped package such as `@foo/bar` with public access,
    you need to modify the `package.json`. The relevant configuration is stored in
    a property called `publishConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, the access configuration could also be set directly when using
    the `npm publish` command with the `--``access=publish` flag.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only discussed how we can publish something to the official
    npm registry. What about choosing some other npm registry? For this, we need to
    change the `.``npmrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting another npm registry via .npmrc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure the behavior of npm, a special file called `.npmrc` is used. We’ve
    already briefly touched on this file in [*Chapter 3*](B18989_03.xhtml#_idTextAnchor033),
    *Choosing a Package Manager*. This file can be used not only to determine the
    source of the packages but also to define where to publish to.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple modification might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: .npmrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This way, all installations and publish attempts will be performed at `https://mycustomregistry.example.org`
    instead of the official registry located at `https://registry.npmjs.org`.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, this extreme approach is unnecessary or even unwanted. Instead,
    you might only want to use another registry for a subset of the packages. In the
    most common case, the subset is already defined by a scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the `@foo` scope that we used in the previous section with the `@foo/bar`
    package should be bound to a custom registry, while all the other packages can
    still be resolved by the official one. The following `.npmrc` covers this:'
  prefs: []
  type: TYPE_NORMAL
- en: .npmrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the local `.npmrc` – that is, the one adjacent to a `package.json` of
    a project – should be used to define the registries, a global `.npmrc` – located
    in your home directory – should be used to provide information regarding authentication.
    Quite often, a private registry can only be used with such authentication information:'
  prefs: []
  type: TYPE_NORMAL
- en: ~/.npmrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `always-auth` setting is used to tell `npm` that even `GET` requests – that
    is, requests for resolving or downloading packages – need to use the provided
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to test custom configuration is to roll out your own npm registry.
    A good way of doing that locally is to use the open source project **Verdaccio**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Verdaccio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of commercial registry options out there. Arguably, the most
    popular option is to get a pro plan for the official npm registry. This way, you’ll
    be able to publish and manage private packages. Whatever option you pick, you
    will always have to use a cloud version for publishing your packages.
  prefs: []
  type: TYPE_NORMAL
- en: Especially for playing around with the publishing process, having a registry
    locally would be great. A great option is to leverage `npx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go for the `npx` approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Verdaccio is running, you can go to the URL shown in the console.
    You should see Verdaccio’s home page as shown in *Figure 8**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The home page of Verdaccio with publishing instructions ](img/Figure_8.3_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The home page of Verdaccio with publishing instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to publish the package we created earlier to Verdaccio instead
    of the official npm registry. The steps we need to follow are these:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate against the new registry (in Verdaccio, you can use whatever credentials
    you’d like by default, but `npm` requires you to authenticate)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either configure the URL to your running instance of Verdaccio via a `.npmrc`
    file or by explicitly using the `--registry` flag with the `npm` `publish` command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In practice, these two steps look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once published, the package is also listed on the website of the Verdaccio instance
    accessible at http://localhost:4873/. This, of course, is mostly useful for testing
    out a publishing process or for speeding up npm installations with a local cache.
    Most of the time, having a local npm registry is not really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'One question might come up at this point: how can we make sure that a published
    package can be used by most users? What requirements need to be fulfilled for
    actually using a package in a client-based application running in the browser,
    as well as in a server-based application running in Node.js?'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of being pretty much target-independent is called being isomorphic.
    The terminology itself does not go uncriticized and some people actually prefer
    to call it universal. Having isomorphic code is great for gaining flexibility.
    Let’s see what is needed to deploy isomorphic packages.
  prefs: []
  type: TYPE_NORMAL
- en: Writing isomorphic libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The holy grail of web development is the ability to write code not solely for
    the frontend or the backend but for both parts. Many frameworks and tools try
    to give us this capability.
  prefs: []
  type: TYPE_NORMAL
- en: To be accessible to multiple platforms, we not only need to ship multiple variants
    of our code but also only use APIs that are available on all supported platforms.
    For instance, if you want to make an HTTP request, then using `fetch` would be
    the right call for modern browsers. However, `fetch` was not available in less
    recent versions of Node.js. Therefore, you might need to solve this differently.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of HTTP requests, there are already isomorphic libraries available
    – that is, libraries that will just do the right thing depending on the target
    runtime. You should only depend on these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphic fetch
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request problem can be solved in many ways – that is, by choosing an
    isomorphic library such as `axios` or `isomorphic-fetch`, the issue can be delegated
    to a dependency. The advantage of this method is that we do not need to find out
    what ways we need to follow on each platform. Additionally, testing and verification
    are much simpler that way.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will focus on providing multiple variants. If we want to publish
    our library with support for multiple module formats – say CommonJS and ESM –
    we can do that by extending the `package.json`. Setting `type` to `module` will
    tell Node.js that the module referenced by the `main` field actually follows ESM.
    In addition, we can define all of the package’s exports explicitly – with an additional
    option to define what module to use depending on the used target platform and
    module system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of this kind of configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the case of our small library, there is a significant difference between
    the browser version and the non-browser version. However, for optimization, we’ve
    used minified modules for the browser, while all other platforms including Node.js
    will resolve to non-minified modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create output suitable for CommonJS, we can use the `build` script that
    we’ve derived already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for ESM is similar, but contains one important change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The crucial change is to avoid using the `__dirname` global variable, which
    only works in Node.js using CommonJS. Instead, we just use the current directory.
    The change is not perfect, but should get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, everything seems to be well prepared – but actually, it’s not. The
    most important thing is still missing – the removal of the Node.js inbuilt package
    references. Our simple library references `fs` and `path`, but these packages
    do not exist in the browser. They would not know how to work there. Luckily, in
    this case, we have multiple solutions. The best one is arguably to replace the
    dynamic file read with a static import of the package’s `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this kind of algorithmic change is not always possible. In the given
    scenario, we also benefit from `esbuild`’s bundle option, which will include the
    necessary parts from the referenced JSON file to produce an output file that matches
    our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes in mind, let’s see how the `build` scripts are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It makes sense to define the scripts so that they can be run independently but
    also conveniently together without much effort. In many cases, the tool you’ve
    chosen has to be configured extensively to have the desired behavior. In the case
    of our example, `esbuild` was already quite equipped for the task – everything
    that we needed could be done via the command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: One additional case that can be covered with an npm package is to actually provide
    a tool. Ideally, these are tools to be run with Node.js making it a cross-platform
    tool. Let’s see how we can write and publish this kind of tool.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a cross-platform tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js would not be so powerful without its ecosystem. As we learned in [*Chapter
    1*](B18989_01.xhtml#_idTextAnchor015), *Learning the Internals of Node.js*, relying
    on the power of its ecosystem was an elementary design decision. Here, npm takes
    the leading role by defining the package metadata in `package.json`, as well as
    the installation of packages.
  prefs: []
  type: TYPE_NORMAL
- en: During the installation of a package, a couple of things are happening. After
    the package has been downloaded, it will be copied to a target directory. For
    a local installation with `npm`, this is the `node_modules` folder. For a global
    installation with `npm`, the target will be globally available in your home directory.
    There is, however, one more thing to do. If the package contains a tool, then
    a reference to the tool will be put into a special directory, which is `node_modules/.bin`
    for a local installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to the code from the previous chapter, you will see that, for
    example, `jest` is available in `node_modules/.bin`. This is the same `jest` executable
    that we started with `npx`. Let’s take the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both will yield the same result. The reason is that `npx` for local installation
    is just a convenient tool to avoid writing out the path. As a reminder, you should
    opt for local installations over global installations.
  prefs: []
  type: TYPE_NORMAL
- en: npx and npm
  prefs: []
  type: TYPE_NORMAL
- en: '`npx` is another command that comes together with the installation of npm.
    From a command perspective, `npm` is used to manage the dependencies, while `npx`
    is used to run packages. The `npm` utility also has a `run` subcommand, which
    runs commands that are defined in the `scripts` section of `package.json`, whereas
    `npx` runs commands as defined in the `bin` section of npm packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the question is how can we create a package that also adds a script to
    the `.bin` folder so that it just works when installed? The answer lies in the
    `package.json` of our previous library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify `package.json` a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We added a `bin` section that defines a single script to be referenced from
    the `.bin` directory. The reference should be called `hello` and pointed to the
    `lib/hello.js` file within this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also add the script to run when `hello` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: hello.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will essentially check whether at least one argument was given and print
    a message in the console using the last argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the behavior when running directly via `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the package can be published as before – for example, by choosing our
    local Verdaccio instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new project, you can now install the dependency and run the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have seen the most crucial aspects regarding the publishing process
    of npm packages. Let’s recap what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about what it takes to publish a package to
    an npm registry – whether it is an official or private one. You also touched on
    a commonly used npm registry in the form of Verdaccio.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with the knowledge from this chapter, you should now be able to write
    reusable libraries that work in browser-based applications as well as in Node.js-based
    applications. You are also now capable of publishing tools that are based on Node.js.
    In a sense, these tools are just libraries with some additional fields in their
    associated package metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at a different approach to structuring
    code – placing multiple packages in a single repository known as a monorepo.
  prefs: []
  type: TYPE_NORMAL
