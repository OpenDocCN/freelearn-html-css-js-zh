<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating UI with React</h1>
                
            
            
                
<p class="mce-root">So far in this book, we have focused on the development of our back-end API; but our application won't be complete without an intuitive user interface (UI) our end-users can interact with. Thus, this chapter will focus on building a web application that consumes our API.</p>
<p class="mce-root">Specifically, by following this chapter, you will:</p>
<ul>
<li>Understand the pros and cons of different UI frameworks and libraries</li>
<li>Learn about the basics of <strong>React</strong>, including <strong>JSX</strong> and <strong>virtual DOM</strong></li>
<li>Bundle our code using <strong>Webpack</strong></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Picking a front-end framework/library</h1>
                
            
            
                
<p class="mce-root">As we've already discussed in <a href="47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml" target="_blank">Chapter 2</a>, <em>The State of JavaScript</em>, <strong>single-page applications</strong> (<strong>SPAs</strong>) are a great improvement over the more traditional <strong>multi-page applications</strong> (<strong>MPAs</strong>) that uses a <strong>client-server</strong> architecture. With SPAs, a lot of the logic that was traditionally done on the server has been delegated to the client. This means there'll be less load on the server, and the application can respond more quickly to user interaction. Therefore, for our client application, we will be building an SPA. Now, the next step is to pick a technology stack for our SPA.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vanilla JavaScript vs. frameworks</h1>
                
            
            
                
<p class="mce-root">SPAs are often discussed in conjunction with popular frameworks and libraries, such as <strong>AngularJS</strong>/<strong>Angular</strong>, <strong>React</strong>, <strong>Vue.js</strong>, <strong>Ember</strong>, and <strong>Meteor</strong>; but we should remember that SPAs can be written with vanilla HTML, CSS, and JavaScript alone. We may also choose to employ utility libraries, such as <strong>jQuery</strong>, to abstract away prickly web APIs, such as <kbd>XMLHttpRequest</kbd>, and to keep our code more readable.</p>
<p class="mce-root">However, without using a framework or library, we'd have to handle all the logic of:</p>
<ul>
<li class="mce-root"><strong>Routing</strong>: Navigating from one page to the next</li>
<li class="mce-root"><strong>DOM manipulation</strong>: Adding/removing components to/from the page</li>
<li class="mce-root"><strong>Data binding:</strong> Keeping the template updated with the data</li>
</ul>
<p class="mce-root">This may be manageable for simply fetch-and-display applications, such as a user directory, whose main logic is to fetch data from an API, substitute it into a template, and render it. For more complicated applications, we might find ourselves re-implementing much of the features provided by a framework/library anyways. Similar to how Express abstracts low-level details to make dealing with HTTP requests and routing easier, these frameworks/libraries can abstract away a lot of logic for us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing a framework/library</h1>
                
            
            
                
<p class="mce-root">There is a myriad of client-side frameworks/libraries available, including <strong>Aurelia</strong>, Ember, <strong>Polymer</strong>, <strong>Backbone</strong>, AngularJS/Angular, Vue.js, React, <strong>Preact</strong>, <strong>Knockout</strong>, jQuery, <strong>Mithril</strong>, <strong>Inferno</strong>, <strong>Riot</strong>, <strong>Svelte</strong>, and so on. However, three frameworks/libraries dominate: AngularJS/Angular, React, and Vue.js.</p>
<p class="mce-root">Let us examine each one based on different factors, in order for us to make an informed decision as to which library/ framework is best for our use case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Popularity/community</h1>
                
            
            
                
<p class="mce-root">Client-side web application frameworks, such as Knockout, Backbone, and Ember, existed before AngularJS was released in 2012, but AngularJS was the first to gain widespread adoption and has retained the title of "Most popular front-end framework" for many years. However, because it was the first, there were many rough edges that developers soon found annoying. According to the <em>State</em> <em>of JavaScript 2017</em> survey, out of all those who have used AngularJS (version 1), only 32.9% would use it again.</p>
<p class="mce-root">Therefore, when React was released in 2013, many Angular developers migrated to React, boosting React's popularity. Satisfaction among React developers is also high, with 93.1% of developers in the aforementioned survey saying they would use it again.</p>
<p class="mce-root"/>
<p class="mce-root">In 2014, the AngularJS team attempted to respond by promising to completely re-write the AngularJS framework. However, the new version (now called "Angular") would be incompatible with the old version (now called "AngularJS"), which means migration from AngularJS to Angular would require a complete rewrite of the application. This caused much backlash in the Angular community, further pushing more developers toward React. To add to the woes of Angular, there were many delays in the development of Angular 2, and the final version was released only 2 years later, in 2016. Two years is a very long period of time in the front-end ecosystem, and by then, React had already captured the lion's share of developers.</p>
<p class="mce-root">Vue.js is the newest kid on the block, and is designed with the lessons learned from both Angular and React (Vue.js's creator, Evan You, was an architect at Google). Since its release in 2014, it has, in a way, made the same impact on the ecosystem as when React first came out. It also has a high satisfaction rate, with 91.1% of developers saying they would use Vue.js again.</p>
<p class="mce-root">In terms of hard numbers, according to the same <em>State of JavaScript</em> survey, out of 23,704 respondents, 14,689 (62.0%) have used React, a slight gain from 57.1% in 2016. A total of 11,322 (47.8%) have used AngularJS 1, down from 63.6% in 2016, and 6,738 (28.4%) have used Angular 2, up from 20.5% in 2016. The biggest climber has been Vue.js, with 5,101 (21.5%) of respondents saying they've used it, almost doubling the figure from 10.8% in 2016.</p>
<p class="mce-root">In terms of contributors to the source code, 1,598 developers have contributed to Angular, 1,177 have contributed to React, and only 187 have contributed to Vue.js.</p>
<p class="mce-root">It's important to note that the most popular framework doesn't mean it is the best framework, and a developer should never choose a framework solely based on its popularity (a.k.a. <strong>hype-driven development</strong>). However, the more popular a framework is, the more developers use that framework, and thus there is likely to be more community support on forums and Q&amp;A sites, such as Stack Overflow. From the business' perspective, it'll also make it easier to hire developers.</p>
<p class="mce-root">Therefore, from the popularity/community/ecosystem point of view, Angular is in decline, Vue.js is on the rise, but React is still the obvious choice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Features</h1>
                
            
            
                
<p class="mce-root">When Angular first came out, it handled the routing, the (two-way) data-binding, and DOM manipulation. It was the first of its kind, and it set the standards of what a client-side web application framework should look like.</p>
<p class="mce-root">Then, when React came out, it redefined what that standard is. Whilst Angular promoted its two-way data binding as a killer feature, React shunted it and called it a source of bugs; instead, it promoted one-way data-binding.</p>
<p class="mce-root">But the biggest change in the paradigm with React is the introduction of the virtual DOM and JSX.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Virtual DOM</h1>
                
            
            
                
<p class="mce-root">The virtual DOM is a simplified abstraction of the real DOM. In React, instead of manually manipulating the real DOM, developers should instead manipulate the Virtual DOM. React would then compare the old Virtual DOM state with the new one, and calculate the most efficient way of manipulating the real DOM.</p>
<p class="mce-root">DOM manipulation is a heavy operation and humans often don't see the most efficient method of manipulating it. Therefore, having React automatically calculate the most efficient way makes updating the DOM much more efficient, and leads to a faster, more reactive UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JSX</h1>
                
            
            
                
<p class="mce-root">JSX is a new language that compiles down to JavaScript. It allows developers to define components of the UI in an HTML-like syntax. Instead of using <kbd>document.createElement()</kbd>, <kbd>React.createElement()</kbd>, or a templating engine, you can write your component in JSX. JSX is like a template, in the sense that you can add placeholders within the template that'll be substituted with real data. The difference is that JSX gets compiled down to plain JavaScript, which means you can use any JavaScript syntax directly inside a JSX file.</p>
<p class="mce-root">If you're familiar with <strong>CSS preprocessors</strong>, you can think of JSX as the preprocessor for HTML, similar to what <strong>Sass</strong> does for CSS. The introduction of JSX means developers have a much easier way to visualize their UI components in code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Post-React</h1>
                
            
            
                
<p class="mce-root">To say React revolutionized front-end development would not be an understatement. React introduced new concepts that other libraries and frameworks have copied. For instance, Vue.js also implements a Virtual DOM and supports the JSX syntax in its templates.</p>
<p class="mce-root">However, Angular has very much fallen behind the pack. The Angular team have stuck to the "Angular way" and have not moved alongside the community. Dare I say, their best is past them; the best they can do is play catch-up at the moment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flexibility</h1>
                
            
            
                
<p class="mce-root">Angular is a framework, which means you must commit to building the entirety of your application using the framework. As demonstrated when the Angular team rewrote Angular, changing a framework requires rewriting the entire application.</p>
<p class="mce-root">On the other hand, React and Vue.js are libraries, which means you can add them to your project and use them whenever is appropriate for you. You can also add additional libraries (for example, routers, state management) that will work with React/Vue.js.</p>
<p class="mce-root">Therefore, in terms of flexibility, React and Vue.js are the winners here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performance</h1>
                
            
            
                
<p class="mce-root">Stefan Krause has developed and published a series of benchmarks on some basic operations using each framework (available at <a href="https://github.com/krausest/js-framework-benchmark">github.com/krausest/js-framework-benchmark</a>). The results show that React is ever so slightly faster than Vue.js, especially in terms of making partial updates, but also consumes slightly more memory.</p>
<p class="mce-root">Angular performs about the same as React and Vue, but consumes noticeably more memory and has a longer initiation time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-platform</h1>
                
            
            
                
<p class="mce-root">A common mistake that companies make when choosing their technology stacks is that they are inconsistent. For instance, I have worked in a startup where we had four projects, and each one was using a different front-end stack:  AngularJS, Angular, Polymer, and React. The result was that developers working on Angular were unable to help with the project using React, and vice versa. Some developers ended up learning all of the frameworks, but the quality of the code was bad, as they became a "Jack of all trades, master of none". Therefore, having a consistent stack for all your front-end projects is important. Quite often, this might involve not only web applications, but also native mobile and desktop applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hybrid applications with Ionic</h1>
                
            
            
                
<p class="mce-root">Around 1 year after the release of AngularJS, <strong>Ionic</strong> was released. Ionic is a framework for building <strong>hybrid</strong> mobile applications.</p>
<p class="mce-root">Essentially, you build a web application using Angular, and then Ionic will use another tool called <strong>Cordova</strong> to wrap the complete application inside a <strong>WebView</strong> container. A WebView is basically a simplified web browser that native apps can add into their application. Therefore, a hybrid application is basically the same as using your web application through a browser that is inside the native app. With a hybrid application, you can "write once, run anywhere".</p>
<p class="mce-root">However, because there are so many layers, the response time of the UI was initially slow, giving the hybrid app a jittery feel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Native UI with React Native and Weex</h1>
                
            
            
                
<p class="mce-root">When Facebook announced <strong>React Native</strong> for iOS and Android in 2015, it was big news. It meant developers could now use the same React principles and syntax to develop the front-end for both web and mobile applications. It also meant that non-platform-specific logic could be shared, which prevents multiple implementations of the same logic in different languages (Java for Android and Swift/Objective-C for iOS).</p>
<p class="mce-root">This was also dubbed “Learn once, write everywhere”, and allows React developers to easily transition between a web developer and mobile developer. Nowadays, React Native can even be used for building Windows applications and virtual reality (VR) applications.</p>
<p class="mce-root">For Vue.js, they've been involved in an ongoing collaboration with the Alibaba Group to develop a similar cross-platform UI library called <strong>Weex</strong>. Soon, Vue.js will also support writing in <strong>NativeScript</strong>. However, as admitted by the Vue.js team themselves, Weex is still in active development and not as battle-tested as React Native, and NativeScript support is a community-driven effort that is not yet ready.</p>
<p class="mce-root">Therefore, in terms of using the same framework/library across multiple platforms, React has the most mature tooling and ecosystem.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning curve</h1>
                
            
            
                
<p class="mce-root">While this may be subjective, I, and many others, have found Angular to have the steepest learning curve. There are many Angular-specific concepts, such as their <strong>digest cycle</strong>, that you must understand before you can be productive with Angular. Angular also uses a lot of tools that developers may not be familiar with, including:</p>
<ul>
<li class="mce-root"><strong>TypeScript</strong>: Provides static typing to JavaScript</li>
<li class="mce-root"><strong>RxJS</strong>: Allows you to write functional reactive code</li>
<li class="mce-root"><strong>SystemJS</strong>:  A module loader</li>
<li class="mce-root"><strong>karma</strong>:  A tool for running unit tests</li>
<li class="mce-root"><strong>Protractor</strong>: An E2E test runner that allows you to run tests that interact with a real browser</li>
</ul>
<p class="mce-root">Although each of these tools brings a lot of value into the application, it no doubts adds to the already-steep learning curve for Angular.</p>
<p class="mce-root">React, on the other hand, is just a view rendering library, and so is much easier to understand. The basic idea is that you create components, pass in some inputs, and React will generate the final view and render it onto the page. You can arrange these components in different ways and nest them inside each other, as it's all composable. You may have to learn about the difference between states and props, and also the lifecycle methods, but that can be done in a few hours at most.</p>
<p class="mce-root">Perhaps what people are referring to when they say "React has a steep learning curve" is the ecosystem around it. The React ecosystem is organized in a way where you have many tools, each doing one specific thing. This is generally a good thing but it also means you'd have to spend the time to pick from the different options, and perhaps spend even more time debugging incompatibilities when you try to integrate them.</p>
<p class="mce-root">For instance, you may use React Router to route your pages. You'd need to learn Redux or MobX to manage your state. Most of the time, you'd use Webpack to bundle your application. However, many React developers also use libraries, such as ImmutableJS, Flow, TypeScript, Karma, and ESLint, which are not compulsory tools, but can often confuse new developers.</p>
<p class="mce-root">An alternative approach is to use a full-featured boilerplate, such as React Boilerplate (<a href="http://www.reactboilerplate.com/">reactboilerplate.com</a>), which has a shallower learning curve, but you'd still have to learn the conventions used by the boilerplate author. Furthermore, if there's a bug/issue with the boilerplate, it'll be much harder for you to debug.</p>
<p class="mce-root">In terms of concepts, React is much simpler than Angular. Even with the React ecosystem, the learning curve is still manageable. Personally, having to stitch your own stack together forces you to understand what each tool does, and how it interacts with other tools, which is a good thing.</p>
<p class="mce-root">Vue.js boasts an even simpler learning curve. It does not use JSX, but a simpler template-like syntax with its own domain-specific language (DSL). It does not require Webpack and developers can enable Vue.js just by including a typical <kbd>&lt;script&gt;</kbd> tag.</p>
<pre class="mce-root">&lt;script src="img/vue"&gt;&lt;/script&gt;</pre>
<p class="mce-root">Therefore, it's easier for developers not using a framework to migrate to Vue.js, as they can more easily convert their HTML into HTML-like templates, and can incrementally adapt the entire application to Vue.js.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conclusion</h1>
                
            
            
                
<p class="mce-root">In terms of community, richness, maturity of the ecosystem, features, flexibility, and cross-platform capabilities, React is the stand-out choice.</p>
<p class="mce-root">The one thing that Vue.js may have over React right now is the learning curve. In a year or two, however, we may see Vue.js overtake React in all the other factors. If not, another framework/library probably will.</p>
<p class="mce-root">Angular is unlikely to disappear altogether, as there are enough early-adaptors and hard-core advocates of Angular remaining, meaning that we'll still see Angular on the market for at least a few more years. But unless they do something drastically different (and better), it's safe to assume Angular will fade slowly into the background, just as its predecessors have done before it.</p>
<p class="mce-root">Therefore, for all the reasons listed so far, we will develop our client-side web application using React.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started with React</h1>
                
            
            
                
<p class="mce-root">As mentioned earlier, although React itself is quite simple, the ecosystem around it can be a little overwhelming. Tessa Thorton, a former senior front-end developer for Shopify, once wrote a blog post titled <em>How to learn web frameworks</em> (<a href="https://ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68">ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68</a>) In it, she reminded us that "Frameworks don’t exist to impress people or make your life harder. They exist to solve problems."</p>
<p class="mce-root">This reminds me of the first ever application I ever built, a clone of Amazon. It was built completely in vanilla JavaScript and PHP because I didn't even know there were frameworks available! However, there was a piece of animation I couldn't get right, and after Googling a lot (and finding the paradise that is Stack Overflow), I ended up using jQuery.</p>
<p class="mce-root">For learning how to program, this was not a bad strategy. It allowed me to understand what is possible without frameworks, and appreciate the framework more when I do use it.</p>
<p class="mce-root">Most tutorials will ask you to set up all the tools first, before explaining how to use them. We are going to take a different approach - we will build our page from scratch using the minimum set of tools, and introducing new concepts and tools <em>only when needed</em>.</p>
<p>In the following section, we will use this approach to build the Register page of our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is React?</h1>
                
            
            
                
<p class="mce-root">React is a library used for building client-facing user interfaces for applications. In principle, it works similar to other front-end frameworks: it takes some data, plugs it into some sort of template, and renders the combined view onto the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components</h1>
                
            
            
                
<p class="mce-root">In React, everything you build are <em>components</em>. Imagine a component as a LEGO brick; by combining components together, you get a complete UI. A button can be a component, an input field can be another component.</p>
<p>Many developers use the terms "element" and "components" interchangeably. Generally speaking, you should use "element" when referring to HTML elements, and "component" when describing React components.</p>
<p class="mce-root">Each component contains its own HTML, CSS, and JavaScript, so it is independent of other components. This includes methods to run when the component is first rendered on-screen, and methods to run when it is removed from view (collectively, these are called <em>lifecycle methods</em>).</p>
<p class="mce-root">Components can be combined to form new components. For example, we can take two <kbd>HobnobInput</kbd> components, add an <kbd>HobnobButton</kbd> component, and then wrap them inside a <kbd>&lt;form&gt;</kbd> element, and call that the <kbd>HobnobForm</kbd> component.</p>
<p>Every React application has a single <strong>root component</strong>, and you mount <strong>child components</strong> (which can have their own child components) into the root component. In the end, you build up a tree of components, similar to the DOM tree.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Virtual DOM</h1>
                
            
            
                
<p class="mce-root">React components actually exist inside a space called the <em>Virtual DOM</em>, an object that serves as a light-weight representation of the actual DOM. Essentially, when the page renders, React generates a Virtual DOM object from the data and the components, and then it translates this Virtual DOM into DOM elements and inserts them into the DOM.</p>
<p class="mce-root">So why not just translate the React components into the DOM nodes directly? The answer is performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How Virtual DOM improves performance</h1>
                
            
            
                
<p class="mce-root">HTML is a linear, string representation of the structure of a website/app. The string, in and of itself, conveys no information about hierarchy or structure. For the browser to understand and render the structure represented by the HTML, it parses this HTML and abstracts it into a tree-like representation called the <strong>Document Object Model</strong>, or <strong>DOM</strong>. Essentially, the tags in your linear HTML become nodes inside the DOM tree.</p>
<p class="mce-root">However, this parsing is relatively expensive. There are many layers of nesting, and each node has many properties and methods associated with them. So, if your application contains many (nested) components, your end users may notice a delay in the rendering. This is also true for DOM manipulation (when you move nodes around in the DOM), so it's best to keep DOM manipulation to a minimum.</p>
<p class="mce-root">React uses the concept of a Virtual DOM to minimize DOM manipulation. In React, when we try to render a component, React will pass the relevant data into the <kbd>render()</kbd> method of your component, and generate a lightweight representation of your view, which forms part of the Virtual DOM. The Virtual DOM is a JavaScript object and does not have all the unnecessary properties and methods that the real DOM elements have, and so manipulating them is much faster.</p>
<p class="mce-root"/>
<p class="mce-root">If this is the first time the page is rendered, the Virtual DOM will be translated into markup and injected into the document. Whenever the input to the component changes, the <kbd>render()</kbd> method could be called again, which produces another representation of your view. React then find the differences between the previous representation and the current representation ("diffing" the Virtual DOM), and generates the minimum set of changes to apply to the DOM.</p>
<p class="mce-root">This means that if the change in input does not require a re-render, then the DOM is not manipulated. Furthermore, it is often difficult to see the most efficient way to manipulate the DOM, especially for complex UIs. React's algorithms take care of that to find the most efficient way possible to achieve the new UI state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">React is declarative</h1>
                
            
            
                
<p class="mce-root">With a traditional application, you may have to listen for changes in the data, process it, and update the DOM yourself using something like jQuery. This is an imperative style, because you are specifying what and how the DOM should change based on the data. For example, on the user search page, when the results come in, it looks like this:</p>
<pre class="mce-root">listener('searchResult', function (users) {<br/>  users<br/>    .map(user =&gt; document.createTextNode(users.name.first + users.name.last))<br/>    .foreach(node =&gt; document.getElementById('userList').appendChild(node))<br/>});</pre>
<p class="mce-root">In contrast, React uses a declarative style, which means you don't need to handle the DOM update itself. You simply declare how you want the data to be processed and displayed, and React will figure out a way to reach that state.</p>
<pre class="mce-root">&lt;ul&gt;<br/>  { state.users.map(post =&gt; &lt;li&gt;users.name.first + users.name.last&lt;/li&gt;) }<br/>&lt;/ul&gt;<br/><br/>listener('searchResult', function (users) {<br/>  state.users = users;<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The declarative style encourages you to write deterministic UI components, whose job is simply to faithfully reflect the state. When done this way, the UI will always render in the same way when given the same state object. This makes the job of the developer much easier, as all he/she needs to do is to ensure the state has the correct values.</p>
<p>For instance, in the example above, all the developer needs to do is to ensure the <kbd>state.users</kbd> array contains the latest list of users, and update it when necessary. He/she never have to manually manipulate the DOM.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">React summary</h1>
                
            
            
                
<p class="mce-root">We have just covered everything we need to know to get started with React. Here's a short summary:</p>
<ul>
<li class="mce-root">React is a front-end framework that takes in data and outputs a user interface (UI)</li>
<li class="mce-root">A React application consists of components being rendered inside one another</li>
<li class="mce-root">These React components correspond to real DOM nodes</li>
<li class="mce-root">React is performant because it minimizes DOM manipulation by using the Virtual DOM</li>
<li class="mce-root">React is declarative; we do not need to handle DOM manipulation ourselves</li>
</ul>
<p class="mce-root">Next, we will start building our Register screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Starting a new repository</h1>
                
            
            
                
<p class="mce-root">Our back-end code is encapsulated and exposed only through the API. Therefore, our front-end web application must interact with our back-end code through this API. Because our back-end and front-end are well-decoupled, it makes sense for us to create a new repository for our front-end application.</p>
<pre class="mce-root">$ mkdir -p ~/projects/hobnob-client<br/>$ cd ~/projects/hobnob-client<br/>$ git init</pre>
<p>You may want to use ESLint to help keep your code tidy. You can use the same <kbd>eslint --init</kbd> wizard as before to generate the <kbd>.eslintrc</kbd> file. However, this time, when it asks you <kbd>Do you use React?</kbd>, pick <kbd>Yes</kbd> instead of <kbd>No</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding some boilerplate</h1>
                
            
            
                
<p class="mce-root">We're now ready to get started! Inside our new project directory, create a new <kbd>index.html</kbd> file. Inside it, add in the following boilerplate.</p>
<pre class="mce-root">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;<br/>  &lt;title&gt;Hobnob&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;<br/><br/></pre>
<p class="mce-root">We will be using two libraries: <kbd>react</kbd> and <kbd>react-dom</kbd>. <kbd>react</kbd> is the base package that allows you to define components; the <kbd>react-dom</kbd> package allows you to translate React components in the Virtual DOM to DOM elements, and mount those DOM nodes into the DOM itself.</p>
<p>The reason they are separated into two packages is because React is not only used for web applications, it can also be used in Native applications with React Native, or inside <kbd>&lt;canvas&gt;</kbd> elements with React Canvas. React simply provides a framework to create reusable components, and is oblivious to how those components are used and rendered.</p>
<p class="mce-root">So, let's add those two libraries inside our <kbd>index.html</kbd>'s <kbd>&lt;head&gt;</kbd> tag.</p>
<pre class="mce-root">...<br/>  &lt;title&gt;Hobnob&lt;/title&gt;<br/>  <strong>&lt;script crossorigin src="img/react.production.min.js"&gt;&lt;/script&gt;</strong><br/><strong>  &lt;script crossorigin src="img/react-dom.production.min.js"&gt;&lt;/script&gt;</strong><br/> &lt;/head&gt;<br/> ...</pre>
<p class="mce-root">This exposes <kbd>React</kbd> and <kbd>ReactDOM</kbd> as global variables, which we can use further down the page.</p>
<p class="mce-root">Open your HTML file on the browser, and open up the developer tools. In the console, start typing in the word <kbd>React</kbd>. You'll see that both <kbd>React</kbd> and <kbd>ReactDOM</kbd> are available.</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/b5b15d6d-337a-482a-b33e-31005bf713e6.png" style="width:16.50em;height:9.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our first component</h1>
                
            
            
                
<p class="mce-root">Now that we have everything set up, let's create our first component! For our Register form, we need to have a form element, inside of which are two input fields, one Register button, and an area to display errors. In React, we can create a new React element using the <kbd>createElement()</kbd> method, which takes three arguments:</p>
<pre class="mce-root">React.createElement(type, [props], [...children])</pre>
<p class="mce-root">The <kbd>type</kbd> can be an HTML tag name (for example, <kbd>div</kbd>, <kbd>span</kbd>, <kbd>form</kbd>), a React component class, or a React fragment type (more on the latter two later).</p>
<p class="mce-root"><kbd>props</kbd> are properties that we can pass into a React element and may alter it in some ways. This is similar to how you can specify attributes on an HTML element. In fact, if the element being created is a native HTML element, these props are used as tag attributes. <kbd>props</kbd> should be specified as an object.</p>
<p class="mce-root"><kbd>children</kbd> is a list of React elements that nest within this component. In our case, we would create a form element, and nest our <kbd>input</kbd> and <kbd>button</kbd> elements inside the form.</p>
<pre class="mce-root">&lt;body&gt;<br/>  <strong>&lt;script&gt;</strong><br/><strong>    const emailInput = React.createElement('input', { type: 'email' });</strong><br/><strong>    const passwordInput = React.createElement('input', { type: 'password' });</strong><br/><strong>    const registerButton = React.createElement('button', null, 'Register');</strong><br/><strong>    const registrationForm = React.createElement('form', null, emailInput, passwordInput, registerButton);</strong><br/><strong>  &lt;/script&gt;</strong><br/>&lt;/body&gt;</pre>
<p class="mce-root">Note how we passed in <kbd>{ type: 'email' }</kbd> as the <kbd>props</kbd> for <kbd>emailInput</kbd>; this will be rendered on the DOM as <kbd>&lt;input type="email"&gt;</kbd>. We also passed in the string <kbd>'Register'</kbd> into the <kbd>registerButton</kbd> element; this will cause the text to be rendered inside the <kbd>button</kbd> element, like <kbd>&lt;button&gt;Register&lt;/button&gt;</kbd>.</p>
<p class="mce-root">To display the <kbd>registerForm</kbd> element onto the page, we need to use the <kbd>ReactDOM.render()</kbd> method, which takes two arguments:</p>
<ul>
<li class="mce-root">The component to render</li>
<li class="mce-root">The DOM element to render it into</li>
</ul>
<p class="mce-root">Therefore, we should create a new HTML element inside our body and use <kbd>ReactDOM.render</kbd> to render our React component into it.</p>
<pre class="mce-root">&lt;body&gt;<br/>  <strong>&lt;div id="renderTarget"&gt;&lt;/div&gt;</strong><br/>  &lt;script&gt;<br/>    ,,,<br/>    const registrationForm = React.createElement(...);<br/>    <strong>ReactDOM.render(registrationForm, document.getElementById('renderTarget'));</strong><br/>  &lt;/script&gt;<br/>&lt;/body&gt;</pre>
<p class="mce-root">If you open <kbd>index.html</kbd> in the browser, you'll see the input boxes and button displayed.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/594f88e9-ce2e-4b1d-a12d-9991cad0cde3.png" style="width:32.33em;height:3.00em;"/></p>
<p class="mce-root">And upon a closer inspection of the HTML output, you'll see the props turning into HTML tag attributes, and that the children passed into <kbd>createElement()</kbd> are nested inside.</p>
<pre class="mce-root">&lt;div id="renderTarget"&gt;<br/>  &lt;form&gt;<br/>    &lt;input type="email"&gt;<br/>    &lt;input type="password"&gt;<br/>    &lt;button&gt;Register&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/div&gt;</pre>
<p>And because we have specified a <kbd>type</kbd> of <kbd>email</kbd>, most browsers will automatically validate the field for us.</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/265f6b6d-ec5d-4549-b72b-b716f9412a73.png" style="width:33.92em;height:10.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">JSX</h1>
                
            
            
                
<p class="mce-root">We have successfully rendered something on to the screen, but that was already a lot of code for such as simple form. And it is not going to get any better. To make it clear the role of each input element, we should attach a label to each one. If we add this label on top of the input, the code will look even more bloated:</p>
<pre class="mce-root">const emailInput = React.createElement('input', { type: 'email' });<br/>const emailField = React.createElement('label', null, 'Email', emailInput);<br/>const passwordInput = React.createElement('input', { type: 'password' });<br/>const passwordField = React.createElement('label', null, 'Password', passwordInput);<br/>const registerButton = React.createElement('button', null, 'Register');<br/>const registrationForm = React.createElement('form', null, emailField, passwordField, registerButton);</pre>
<p class="mce-root">A typical web application has thousands of moving parts. Using <kbd>createElement</kbd> thousands of times can make the code unreadable, so let's try an alternative: <em>JSX</em>.</p>
<p class="mce-root">JSX, or <strong>JavaScript XML</strong>, is a syntax that allows you to create React elements and components in XML format. For example, our <kbd>registrationForm</kbd> element would look like this in JSX:</p>
<pre class="mce-root">&lt;form&gt;<br/>  &lt;label&gt;<br/>    Email<br/>    &lt;input type="email" /&gt;<br/>  &lt;/label&gt;<br/>  &lt;label&gt;<br/>    Password<br/>    &lt;input type="password" /&gt;<br/>  &lt;/label&gt;<br/>  &lt;button&gt;Register&lt;/button&gt;<br/>&lt;/form&gt;</pre>
<p class="mce-root">The structure of our element is now immediately more clear. But you might be thinking, "But that's just HTML!", and you are not wrong. JSX is designed to look and work just like HTML. So let's try to replace the <kbd>registrationForm</kbd> element with the new JSX syntax and see what happens:</p>
<pre class="mce-root">&lt;script&gt;<br/>  <strong>const RegistrationForm = () =&gt; </strong><strong>(</strong><br/><strong>    &lt;form&gt;</strong><br/><strong>      &lt;label&gt;</strong><br/><strong>        Email</strong><br/><strong>        &lt;input type="email" /&gt;</strong><br/><strong>      &lt;/label&gt;</strong><br/><strong>      &lt;label&gt;</strong><br/><strong>        Password</strong><br/><strong>        &lt;input type="password" /&gt;</strong><br/><strong>      &lt;/label&gt;</strong><br/><strong>      &lt;button&gt;Register&lt;/button&gt;</strong><br/><strong>    &lt;/form&gt;</strong><br/><strong>  );</strong><br/>  ReactDOM.render(<strong>&lt;RegistrationForm /&gt;</strong>, document.getElementById('renderTarget'));<br/>&lt;/script&gt;</pre>
<p class="mce-root">When we open <kbd>index.html</kbd> on the browser, it will now throw an error message on the console which reads:</p>
<pre class="mce-root">Uncaught SyntaxError: Unexpected token &lt;</pre>
<p class="mce-root">That's because JSX is not valid JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transpiling JSX</h1>
                
            
            
                
<p class="mce-root">If you've ever used <strong>CoffeeScript</strong>, JSX is similar to that. You can't run CoffeeScript in the browser; you must first transpile it to JavaScript. Or if you've used a CSS preprocessor, such as Sass, JSX is also similar. Sass features such as <kbd>@include</kbd> or <kbd>@extend</kbd> are not valid CSS, and you must use a preprocessor to transform Sass to CSS. The same is true for JSX;  we must use a transpiler/preprocessor to transform it into plain JavaScript.</p>
<p class="mce-root">For JSX, the most popular transpiler is the <strong>Babel</strong> transpiler, which we have already used when developing our API. In a way, you can think of JSX in the same way as newer ECMAScript syntax. Some ECMAScript features are not supported in the browser, and therefore we must transpile it down into JavaScript that the browser can understand. JSX is not supported in the browser, and therefore, we must transpile it down to JavaScript that is supported by the browser.</p>
<p class="mce-root">To see how Babel transforms JSX into JavaScript, we can use the Babel REPL, available at <a href="https://babeljs.io/repl/">babeljs.io/repl/</a>. Open it up, and paste in everything inside our <kbd>&lt;script&gt;</kbd> tag. You should see the transpiled JavaScript on the right:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/45ef51a1-b4eb-4f9b-9a9b-21d5f467949a.png"/></p>
<p class="mce-root"/>
<p class="mce-root">On the server, we used Babel to precompile our code from the <kbd>src/</kbd> directory to the <kbd>dist/</kbd> directory. On the client, we can transpile JSX directly inside the browser itself. To do that, we need to include the Babel Standalone Library as a script inside the <kbd>&lt;head&gt;</kbd> tag:<br/></p>
<pre class="mce-root">  ...<br/>  &lt;script crossorigin src="img/react-dom.production.min.js"&gt;&lt;/script&gt;<br/>  <strong>&lt;script src="img/babel.min.js"&gt;&lt;/script&gt;</strong><br/>&lt;/head&gt;<br/>...</pre>
<p class="mce-root">We also need to change our <kbd>&lt;script&gt;</kbd> tag to include the attribute <kbd>type="text/babel"</kbd>.</p>
<pre class="mce-root">&lt;body&gt;<br/>  &lt;div id="renderTarget"&gt;&lt;/div&gt;<br/>  &lt;script<strong> type="text/babel"</strong>&gt;<br/>    ...<br/>  &lt;/script&gt;<br/>&lt;/body&gt;</pre>
<p class="mce-root">The <kbd>type="text/babel"</kbd> attribute tells our browser to not treat what's inside as JavaScript, but as plain text. This means our JSX would no longer throw an error. The Babel Standalone Library we included in the <kbd>&lt;head&gt;</kbd> element would then search for any script tags with the type <kbd>text/babel</kbd> and transpile it to JavaScript, and then execute the transpiled JavaScript.</p>
<p class="mce-root">Open up your browser, and you should see the same thing as we had before, but now we are writing in JSX!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining React components</h1>
                
            
            
                
<p class="mce-root">Although we have made our React code much clearer by using JSX, it's still not as clean and DRY as it could be. For instance, we are defining the same input element twice, even though they have the same structure.</p>
<pre class="mce-root">&lt;label&gt;<br/>  Email<br/>  &lt;input type="email" /&gt;<br/>&lt;/label&gt;<br/>&lt;label&gt;<br/>  Password<br/>  &lt;input type="password" /&gt;<br/>&lt;/label&gt;</pre>
<p class="mce-root">This is not ideal because of the following factors:</p>
<ul>
<li class="mce-root">It can lead to inconsistency. To achieve a consistent user experience, we should apply a consistent style and layout for all components, including these input boxes. Defining input boxes without a standard template will make it difficult to do this.</li>
<li class="mce-root">It is difficult to update. If the designs change and we need to update all the input boxes to fit this new design, it'll be difficult to find all occurrences of the input box and update its style. Humans are error-prone and we might miss one or two.</li>
</ul>
<p>We should ensure our React code is DRY; therefore, we should define an independent component that we can reuse wherever an input field is needed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functional and class components</h1>
                
            
            
                
<p class="mce-root">A React component takes in <strong>props</strong> (input data) and returns a React element(s). In React, you can define a component in two ways:</p>
<ul>
<li class="mce-root"><strong>Functional components</strong></li>
<li class="mce-root"><strong>Class components</strong></li>
</ul>
<p class="mce-root">For instance, we can define an <kbd>Input</kbd> React component using the functional component syntax.</p>
<pre class="mce-root">function Input(props) {<br/>  return &lt;label&gt;{props.label}&lt;input type={props.type} /&gt;&lt;/label&gt;<br/>}</pre>
<p>The curly braces (<kbd>{}</kbd>) are JSX syntax. Whatever is between the braces are evaluated as JavaScript, and the value substituted in place.</p>
<p class="mce-root">Alternatively, we can define the same <kbd>Input</kbd> component using the class syntax, which uses ES6 classes.</p>
<pre class="mce-root">class Input extends React.Component {<br/>  render() {<br/>    return &lt;label&gt;{this.props.label}&lt;input type={this.props.type} /&gt;&lt;/label&gt;<br/>  }<br/>}</pre>
<p class="mce-root">Both are functionally equivalent, and can be used like this to create the <kbd>RegistrationForm</kbd> component:</p>
<pre class="mce-root">const RegistrationForm = () =&gt; (<br/>  &lt;form&gt;<br/>    &lt;Input label="Email" type="email" /&gt;<br/>    &lt;Input label="Password" type="password" /&gt;<br/>    &lt;button&gt;Register&lt;/button&gt;<br/>  &lt;/form&gt;<br/>);</pre>
<p class="mce-root">Here, we are passing in the <kbd>label</kbd> and <kbd>type</kbd> props into the <kbd>Input</kbd> component, which we then used in the component's <kbd>render</kbd> method.</p>
<p class="mce-root">So which syntax should you use to define React components? Functional components are simpler to understand; after all, they are just JavaScript functions. Class components have a more complex syntax, but supports more features, such as holding a state, and can make use of different life-cycle methods, which we will cover soon. Therefore, if your component does not need these additional features, then you should prefer the functional syntax over the class syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pure components</h1>
                
            
            
                
<p class="mce-root">Regardless of the syntax, all React components must be <em>pure</em>. A pure component is one where:</p>
<ul>
<li class="mce-root">The return value (the React element) is <strong>deterministic</strong>, based only on the component's input (props).</li>
<li class="mce-root">The component does not produce <strong>side-effects</strong>. For example, a pure component should not mutate the props.</li>
</ul>
<p class="mce-root">Pure functions and functional components are good because they are easier to understand and test. Therefore, when we have a large or heavily-nested component like our <kbd>Form</kbd> element, it's good practice to break it down into smaller pure functional components, and use these components to compose the element.</p>
<p class="mce-root">Try turning our button into its own (simple) component. The end result should look like this:</p>
<pre class="mce-root">function Input(props) {<br/>  return &lt;label&gt;{props.label}&lt;input type={props.type} /&gt;&lt;/label&gt;<br/>}<br/>function Button(props) {<br/>  return &lt;button&gt;{props.title}&lt;/button&gt;<br/>}<br/>const RegistrationForm = () =&gt; (<br/>  &lt;form&gt;<br/>    &lt;Input label="Email" type="email" /&gt;<br/>    &lt;Input label="Password" type="password" /&gt;<br/>    &lt;Button title="Register" /&gt;<br/>  &lt;/form&gt;<br/>);<br/>ReactDOM.render(&lt;RegistrationForm /&gt;, document.getElementById('renderTarget'));</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Maintaining the state and listening for events</h1>
                
            
            
                
<p class="mce-root">Let's work on the <kbd>Input</kbd> component a little more. When a user types inside the input box, it'd be great for user experience to validate the user's input and display an indicator next to it. The indicator can be colored green if the input is valid, or red if not.</p>
<p class="mce-root">Therefore, our <kbd>Input</kbd> component needs to:</p>
<ul>
<li class="mce-root">Listen and handle events, so that it can validate the input when the value changes.</li>
<li class="mce-root">Maintain the state, so the component can persist the result of the validation.</li>
</ul>
<p class="mce-root">Currently, our <kbd>Input</kbd> component is defined in the functional components style. This is preferred but it is limited in features; it cannot hold the state. Therefore, let's first convert the <kbd>Input</kbd> component into a class component:</p>
<pre class="mce-root">class Input extends React.Component {<br/>  render() {<br/>    return &lt;label&gt;{this.props.label}&lt;input type={this.props.type} /&gt;&lt;/label&gt;<br/>  }<br/>}</pre>
<p class="mce-root">Next, we can give each instance of the <kbd>Input</kbd> component a state. A state in React is simply a key-value store (that is, an object) that is internal (private) to the instance. For us, we will use the state to hold information about whether the input is valid.</p>
<p class="mce-root">We can define an initial state of the component inside the component class' <kbd>constructor</kbd> method, which is a special method that is called when the class is instantiated with the <kbd>new</kbd> keyword.</p>
<pre class="mce-root">class Input extends React.Component {<br/>  <strong>constructor() {</strong><br/><strong>    super();</strong><br/><strong>    this.state = { valid: null }</strong><br/><strong>  }</strong><br/>  render () { ... }<br/>}</pre>
<p class="mce-root">We are setting the state property <kbd>valid</kbd> to <kbd>null</kbd>, because before the user has entered anything, we don't want to say that it is valid or invalid.</p>
<p class="mce-root">Next, we need to add event listeners to the <kbd>input</kbd> HTML element. Event listeners in JSX are similar to the HTML ones, except that they are <kbd>camelCase</kbd> instead of lowercase. For instance, an <kbd>onchange</kbd> listener in HTML would be <kbd>onChange</kbd>. The value of the event handler prop should be an event handler function. Update the <kbd>input</kbd> element inside the label tag to include the <kbd>onChange</kbd> prop.</p>
<pre class="mce-root">render() {<br/>  return &lt;label&gt;{this.props.label}&lt;input <strong>onChange={this.validate}</strong> ... /&gt;&lt;/label&gt;<br/>}</pre>
<p class="mce-root">Now, whenever the value of the input changes, <kbd>this.validate</kbd> is invoked, passing in the event object as its only argument. Since this method doesn't exist yet, we must now define it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling events</h1>
                
            
            
                
<p class="mce-root">Inside a class method, <kbd>this</kbd> refers to the React element (which is an instance of this <kbd>Input</kbd> React component type). Therefore, we can define a method called <kbd>validate</kbd> that will validate the user input and update the state:</p>
<pre class="mce-root">&lt;script type="text/babel"&gt;<br/><strong>  const validator = {</strong><br/><strong>    email: (email) =&gt; /\S+@\S+\.\S+/.test(email),</strong><br/><strong>    password: (password) =&gt; password.length &gt; 11 &amp;&amp; password.length &lt; 48</strong><br/><strong>  }</strong><br/>  class Input extends React.Component {<br/>    constructor() { ... }<br/>    <strong>validate = (event) =&gt; {</strong><br/><strong>      const value = event.target.value;</strong><br/><strong>      const valid = validator[this.props.type](value);</strong><br/><strong>      this.setState({ value, valid });</strong><br/><strong>    }</strong><br/>    render() {<br/>      return &lt;label&gt;{this.props.label}&lt;input type={this.props.type}  onChange={this.validate} /&gt;&lt;/label&gt;<br/>    }<br/>  }<br/>  ...<br/>&lt;/script&gt;</pre>
<p class="mce-root">The <kbd>validate</kbd> method gets the value of the input box from <kbd>event.target.value</kbd>, and then uses an external <kbd>validator</kbd> object to actually validate the value. The <kbd>validator</kbd> method would return <kbd>true</kbd> if the value is valid, or <kbd>false</kbd> if it is not.</p>
<p class="mce-root">Lastly, the <kbd>validate</kbd> method updates the state using the <kbd>setState</kbd> method, which is available for all class components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">setState and immutability</h1>
                
            
            
                
<p class="mce-root">You should use <kbd>setState</kbd> to update the state instead of simply modifying the existing state:</p>
<pre class="mce-root">// Bad<br/>validate = (event) =&gt; {<br/>  const value = event.target.value;<br/>  const valid = validator[this.props.type](value);<br/>  <strong>this.state.value = value;</strong><br/><strong>  this.state.valid = valid;</strong><br/>}<br/>// Good<br/>validate = (event) =&gt; {<br/>  const value = event.target.value;<br/>  const valid = validator[this.props.type](value);<br/>  <strong>this.setState({ value, valid })</strong><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root">The end result is the same: <kbd>this.state</kbd> is changed to its new value. However, if we directly update the <kbd>this.state</kbd> object, then React must poll the value of <kbd>this.state</kbd> regularly to be notified of any changes. This is slow and inefficient, and not how React is implemented. Instead, by changing the state via the <kbd>this.setState</kbd> method, it will 'reactively' informs React that the state has changed, and React may opt to trigger a re-render of the view.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rendering the state</h1>
                
            
            
                
<p class="mce-root">Lastly, in our <kbd>render</kbd> method, let's add an indicator component. We will read from the state of the component to determine the color of our indicator.</p>
<pre class="mce-root">&lt;script type="text/babel"&gt;<br/>  ...<br/>  <strong>function getIndicatorColor (state) {</strong><br/><strong>    if (state.valid === null || state.value.length === 0) {</strong><br/><strong>      return 'transparent';</strong><br/><strong>    }</strong><br/><strong>    return state.valid ? 'green' : 'red';</strong><br/><strong>  }</strong><br/> <br/>  class Input extends React.Component {<br/>    constructor() { ... }<br/>    validate = (event) =&gt; { ... }<br/>    render () {<br/>      return (<br/>        &lt;label&gt;<br/>          {this.props.label}<br/>          &lt;input type={this.props.type} onChange={this.validate}/&gt;<br/>          <strong>&lt;div className="indicator" style={{</strong><br/><strong>            height: "20px",</strong><br/><strong>            width: "20px",</strong><br/><strong>            backgroundColor: getIndicatorColor(this.state)</strong><br/><strong>          }}&gt;&lt;/div&gt;</strong><br/>        &lt;/label&gt;<br/>      )<br/>    }<br/>  }<br/>  ...<br/>&lt;/script&gt;</pre>
<p class="mce-root">Now, open <kbd>index.html</kbd> on your browser, and try out the input boxes. If you enter an invalid email, or your password is too short/long, the indicator will show red.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/39555ef1-ff61-4e9c-ba7e-579c5fa9c422.png" style="width:23.50em;height:9.92em;"/></p>
<p class="mce-root">It is not very pretty, but "function over form" - let's care about the looks once we have the functionality in place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Submitting forms</h1>
                
            
            
                
<p class="mce-root">Now that we have our form ready, let's take the next logical step and figure out how to submit the data to our API.</p>
<p class="mce-root">The first thing we need to do is to add an <kbd>onSubmit</kbd> event handler to the form. The handler is specific to the registration form, and thus should be associated with <kbd>RegistrationForm</kbd>. The most obvious place to define it is as a class method. Update <kbd>RegistrationForm</kbd> to the following:</p>
<pre class="mce-root">class RegistrationForm extends React.Component {<br/>  <strong>handleRegistration = (event) =&gt; {</strong><br/><strong>    event.preventDefault();</strong><br/><strong>    event.stopPropagation();</strong><br/><strong>  }</strong><br/>  render() {<br/>    return (<br/>      &lt;form<strong> onSubmit={this.handleRegistration}</strong>&gt;<br/>        &lt;Input label="Email" type="email" /&gt;<br/>        &lt;Input label="Password" type="password" /&gt;<br/>        &lt;Button title="Register" /&gt;<br/>      &lt;/form&gt;<br/>    )<br/>  }<br/>}</pre>
<p class="mce-root"><kbd>this.handleRegistration</kbd> is triggered whenever the form is submitted (for example, when a user presses the Register button) and the event is passed in as its only parameter.</p>
<p class="mce-root">The default behavior for the form is to send an HTTP request to the URL specified in the <kbd>action</kbd> attribute of the form. Here, we are not specifying an <kbd>action</kbd> attribute because we want to handle the form differently. Thus, we are calling <kbd>event.preventDefault()</kbd> to stop the form from sending the request. We are also calling <kbd>event.stopPropagation()</kbd> to stop this event from <strong>capturing</strong> or <strong>bubbling</strong>; in other words, it prevents other event handlers from handling it.</p>
<p class="mce-root">Next, we need to figure out how to obtain the value of each input box, compose the request, and then send it to our API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Uncontrolled form elements</h1>
                
            
            
                
<p class="mce-root">Previously, we said that the state of each component is internal (private) to the component. However, there are no private class methods in JavaScript. Our only equivalent is the closure; therefore, our state isn't truly private. If we can obtain a reference to the React element, we can also get its state.</p>
<p class="mce-root">React supports a feature called <strong>ref</strong>. We can create refs using the <kbd>React.createRef()</kbd> method, and then attach that ref to any child DOM element or React element. We can then refer to that element using the ref.</p>
<pre class="mce-root">class RegistrationForm extends React.Component {<br/><strong>  constructor(props) {</strong><br/><strong>    super(props);</strong><br/><strong>    this.email = React.createRef();</strong><br/><strong>    this.password = React.createRef();</strong><br/><strong>  }</strong><br/>  handleRegistration = (event) =&gt; {<br/>    event.preventDefault();<br/>    event.stopPropagation();<br/><strong>    console.log(this.email.current);</strong><br/><strong>    console.log(this.password.current);</strong><br/>  }<br/>  render() {<br/>    return (<br/>      &lt;form onSubmit={this.handleRegistration}&gt;<br/>        &lt;Input label="Email" type="email"<strong> ref={this.email}</strong> /&gt;<br/>        &lt;Input label="Password" type="password"<strong> ref={this.password}</strong> /&gt;<br/>        &lt;Button title="Register" /&gt;<br/>      &lt;/form&gt;<br/>    )<br/>  }<br/>}</pre>
<p class="mce-root">In the preceding code, in the constructor of <kbd>RegistrationForm</kbd>, we created two refs, which we've assigned to <kbd>this.email</kbd> and <kbd>this.password</kbd>. We then attached these two refs to the two <kbd>Input</kbd> elements using the <kbd>ref</kbd> prop.</p>
<p>The <kbd>ref</kbd> prop is a special prop that is not passed down to the child element.</p>
<p class="mce-root">We can now obtain a reference to the email <kbd>Input</kbd> element using <kbd>this.email.current</kbd>. And we can obtain its <kbd>state</kbd> property using <kbd>this.email.current.state</kbd>. Try opening up the browser, type in some values in the input box and click Register; you should see each input box's current state in the console.</p>
<p class="mce-root">Next, let's update the <kbd>handleRegistration</kbd> method to first check the state object, to see whether the values are valid; if they are, extract and assign them to a variable.</p>
<pre class="mce-root">handleRegistration = (event) =&gt; {<br/>  event.preventDefault();<br/>  event.stopPropagation();<br/>  <strong>const hasValidParams = this.email.current.state.valid &amp;&amp; this.password.current.state.valid;</strong><br/><strong>  if (!hasValidParams) {</strong><br/><strong>    console.error('Invalid Parameters');</strong><br/><strong>    return;</strong><br/><strong>  }</strong><br/><strong>  const email = this.email.current.state.value;</strong><br/><strong>  const password = this.password.current.state.value;</strong><br/>}</pre>
<p class="mce-root">Next, we need to hash the password, compose the request, and send it to our API server. Let's define a <kbd>register</kbd> function, which will provide a layer of abstract and allow our <kbd>handleRegistration</kbd> method to remain easy to read.</p>
<pre>&lt;body&gt;<br/>  &lt;script type="text/babel"&gt;<br/><strong>    function register (email, digest) {</strong><br/><br/><strong>      // Send the credentials to the server</strong><br/><strong>      const payload = { email, digest };</strong><br/><strong>      const request = new Request('http://localhost:8080/users', {</strong><br/><strong>        method: 'POST',</strong><br/><strong>        headers: { 'Content-Type': 'application/json' },</strong><br/><strong>        mode: 'cors',</strong><br/><strong>        body: JSON.stringify(payload)</strong><br/><strong>      })</strong><br/><strong>      return fetch(request)</strong><br/><strong>        .then(response =&gt; {</strong><br/><strong>          if (response.status === 200) {</strong><br/><strong>            return response.text();</strong><br/><strong>          } else {</strong><br/><strong>            throw new Error('Error creating new user');</strong><br/><strong>          }</strong><br/><strong>        })</strong><br/><strong>    }</strong><br/>    ...<br/>  &lt;/script&gt;<br/>&lt;/body&gt;</pre>
<p class="mce-root">These two functions use the <strong>Fetch API</strong> to send the request to our API server (assuming to be running on <kbd>http://localhost:8080/</kbd>).</p>
<p class="mce-root">Next, we need to call the <kbd>register</kbd> functions we defined earlier to actually authenticate the user.</p>
<pre>handleRegistration = (event) =&gt; {<br/>  ...<br/>  const email = this.email.current.state.value;<br/>  const password = this.password.current.state.value;<br/>  <strong>const digest = bcrypt.hashSync(password, 10));<br/>  register(email, digest))<br/>    .then(console.log)<br/>    .catch(console.error)<br/></strong>}<strong><br/></strong></pre>
<p class="mce-root">Lastly, we are using <kbd>bcrypt.hashSync</kbd> to hash the password; therefore, we need to load the <kbd>bcryptjs</kbd> library, which we can get from the RawGit CDN via the following URL: <a href="https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js">https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js</a>.</p>
<pre class="mce-root">&lt;head&gt;<br/>  ...<br/>  <strong>&lt;script src="img/bcrypt.min.js"&gt;&lt;/script&gt;</strong><br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div id="renderTarget"&gt;&lt;/div&gt;<br/>  &lt;script type="text/babel"&gt;<br/>    <strong>const bcrypt = dcodeIO.bcrypt;</strong><br/>    ...<br/>  &lt;/script&gt;<br/>&lt;/body&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Resolving CORS issues</h1>
                
            
            
                
<p class="mce-root">Now, if we reload the page, fill in our details, and press the Register button, we'll encounter a CORS-related error. This is because our API server is currently only servicing requests from our Swagger documentation page (on <kbd>http://localhost:8100</kbd>); requests from other websites are rejected.</p>
<p>To resolve this, we need to provide the Hobnob API with information about the location of our client. We can do this by adding a few more environment variables. Add the following entries to the <kbd>envs/.env</kbd> and <kbd>envs/.env.example</kbd> files in our Hobnob API repository.</p>
<pre>CLIENT_PROTOCOL=http<br/>CLIENT_HOSTNAME=127.0.0.1<br/>CLIENT_PORT=8200</pre>
<p>Then, we need to add the client's origin to the list of origins our API should allow. We can do this by updating the CORS middleware to set the <kbd>Access-Control-Allow-Origin</kbd> header dynamically. Make the following change inside <kbd>src/index.js</kbd> of our Hobnob API repository:</p>
<pre>app.use((req, res, next) =&gt; {<br/>  <strong>const {</strong><br/><strong>    SWAGGER_UI_PROTOCOL, SWAGGER_UI_HOSTNAME, SWAGGER_UI_PORT,</strong><br/><strong>    CLIENT_PROTOCOL, CLIENT_HOSTNAME, CLIENT_PORT,</strong><br/><strong>  } = process.env;</strong><br/><strong>  const allowedOrigins = [</strong><br/><strong>    `${SWAGGER_UI_PROTOCOL}://${SWAGGER_UI_HOSTNAME}`,</strong><br/><strong>    `${SWAGGER_UI_PROTOCOL}://${SWAGGER_UI_HOSTNAME}:${SWAGGER_UI_PORT}`,</strong><br/><strong>    `${CLIENT_PROTOCOL}://${CLIENT_HOSTNAME}`,</strong><br/><strong>    `${CLIENT_PROTOCOL}://${CLIENT_HOSTNAME}:${CLIENT_PORT}`,</strong><br/><strong>  ];</strong><br/><strong>  if (allowedOrigins.includes(req.headers.origin)) {</strong><br/><strong>    res.setHeader('Access-Control-Allow-Origin', req.headers.origin);</strong><br/><strong>  }</strong><br/>  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');<br/>  next();<br/>});</pre>
<p>Lastly, coming back to our client application, we need to ensure that the client is serving at the port we specified, and also that CORS is enabled. We can do this simply by using the <kbd>-p</kbd> and <kbd>--cors</kbd> flag provided by the <kbd>http-server</kbd> package.</p>
<pre>$ http-server . <strong>-p 8200 --cors</strong></pre>
<p>Now, if we reload both our API server and our client, and try to register, we should get back a success response.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Disabling the Button component</h1>
                
            
            
                
<p class="mce-root">To make the user experience more intuitive, let's disable the Register button until both the email and password fields are valid. To do that, we need to provide a way for the <kbd>RegistrationForm</kbd> component to not just read the values of the <kbd>Input</kbd> components when the form is submitted, but after each time the value has changed.</p>
<p class="mce-root">A naive approach would be to poll the <kbd>valid</kbd> state of each component every 100 ms or so, but that will not be performant. Instead, we can pass a function (via the <kbd>onChange</kbd> prop) into the <kbd>Input</kbd> component that will get called whenever the value of the <kbd>Input</kbd> changes.</p>
<pre class="mce-root">&lt;Input label="Email" type="email" ref={this.email} <strong>onChange={this.handleInputChange}</strong> /&gt;<br/>&lt;Input label="Password" type="password" ref={this.password} <strong>onChange={this.handleInputChange}</strong> /&gt;</pre>
<p class="mce-root">And then inside the <kbd>validate</kbd> method of our <kbd>Input</kbd> component, we would call <kbd>this.props.onChange</kbd>:</p>
<pre class="mce-root">validate = (event) =&gt; {<br/>  const value = event.target.value;<br/>  const valid = validator[this.props.type](value);<br/>  <strong>this.setState({ value, valid }, () =&gt; {</strong><br/><strong>    if (this.props.onChange) {</strong><br/><strong>      this.props.onChange();</strong><br/><strong>    }</strong><br/><strong>  });</strong><br/>}</pre>
<p class="mce-root">The <kbd>setState</kbd> method accepts a callback as its second parameter, which only gets called after the state has been updated. This ensures that when the parent component (<kbd>RegistrationForm</kbd>) checks the <kbd>Input</kbd> elements' states, it will be the updated state.</p>
<p class="mce-root">Now, we need to define the <kbd>handleInputChange</kbd> method in <kbd>RegistrationForm</kbd>. It should check whether both inputs are valid, and store the result in the state of <kbd>RegistrationForm</kbd>.</p>
<pre class="mce-root">constructor(props) {<br/>  super(props);<br/>  this.email = React.createRef();<br/>  this.password = React.createRef();<br/>  <strong>this.state = {</strong><br/><strong>    valid: false</strong><br/><strong>  };</strong><br/>}<br/>...<br/><strong>handleInputChange = () =&gt; {</strong><br/><strong>  this.setState({</strong><br/><strong>    valid: !!(this.email.current.state.valid &amp;&amp; this.password.current.state.valid)</strong><br/><strong>  })</strong><br/><strong>}</strong></pre>
<p class="mce-root">Finally, we need to modify our <kbd>Button</kbd> component to accept a <kbd>disabled</kbd> prop, which should disable the button when <kbd>true</kbd>.</p>
<pre class="mce-root">function Button(props) {<br/>  return &lt;button <strong>disabled={props.disabled}</strong>&gt;{props.title}&lt;/button&gt;<br/>}<br/>class RegistrationForm extends React.Component {<br/>  ...<br/>  render() {<br/>    return (<br/>      &lt;form onSubmit={this.handleRegistration}&gt;<br/>        ...<br/>        &lt;Button title="Register"<strong> disabled={!this.state.valid} </strong>/&gt;<br/>      &lt;/form&gt;<br/>    )<br/>  }<br/>}</pre>
<p class="mce-root">Now, refresh the page and play around with the inputs. The Register button should now be disabled until both inputs are valid (that is, both indicators are green).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controlled form elements</h1>
                
            
            
                
<p class="mce-root">You now have some experience working with props, state and refs. However, there are several major flaws with our current implementation:</p>
<ul>
<li class="mce-root">We are holding states in multiple places. This is hard to manage because we have to remember where each state is stored.</li>
<li class="mce-root">We are duplicating the same states in multiple places. We are holding the <kbd>valid</kbd> state in both the <kbd>RegistrationForm</kbd> element as well as the <kbd>Input</kbd> elements. The <kbd>RegistrationForm</kbd>'s <kbd>valid</kbd> state can be derived from the states of the <kbd>Input</kbd> elements.</li>
</ul>
<p class="mce-root">To prevent both of these flaws, we should <strong>lift the state</strong> store to the closest common ancestor of the components that need it; for us, this will be the <kbd>RegistrationForm</kbd> component.</p>
<p class="mce-root">Here's how it would work. First, we turn the <kbd>Input</kbd> components back into stateless, dumb component, whose output depends solely on the props passed in. We are going to be passing down one new prop, <kbd>name</kbd>, which is a name that is used to identify the input. It is similar to the <kbd>name</kbd> attribute on a normal <kbd>input</kbd> HTML element. We will also change the signature of our <kbd>RegistrationForm.handleInputChange()</kbd> method to accept the <kbd>name</kbd> of the input as its first parameter.</p>
<pre class="mce-root"><strong>function Input (props) {</strong><br/><strong>  return (</strong><br/>    &lt;label&gt;<br/>      <strong>{props.label}</strong><br/>      &lt;input type={props.type} value={props.value} <strong>onChange={(event) =&gt; props.onChange(props.name, event)} </strong>/&gt;<br/>      &lt;div className="indicator" style={{ ... }}&gt;&lt;/div&gt;<br/>    &lt;/label&gt;<br/><strong>  )</strong><br/><strong>}</strong></pre>
<p class="mce-root">Our <kbd>Input</kbd> components are no longer holding any state, nor carrying out any validation. Instead, these tasks have been delegated to the component's closest common ancestor, which is the <kbd>RegistrationForm</kbd>. So, inside RegistrationForm, we can:</p>
<ul>
<li class="mce-root">Remove any references to these Input components - because they no longer hold any state, we have no reasons to hold on to these references</li>
<li class="mce-root">Update <kbd>this.state</kbd> to hold the values and validity information for the <kbd>Input</kbd> components.</li>
</ul>
<pre class="mce-root">class RegistrationForm extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    <strong>this.state = {</strong><br/><strong>      email: {</strong><br/><strong>        value: "",</strong><br/><strong>        valid: null</strong><br/><strong>      },</strong><br/><strong>      password: {</strong><br/><strong>        value: "",</strong><br/><strong>        valid: null</strong><br/><strong>      }</strong><br/><strong>    };</strong><br/>  }<br/>  ...<br/>}</pre>
<p class="mce-root">Next, update our JSX components to pass down states like <kbd>value</kbd> and <kbd>valid</kbd> to the <kbd>Input</kbd> components. We are also passing down a <kbd>name</kbd> prop that helps identify the element:</p>
<pre class="mce-root">render() {<br/>  return (<br/>    &lt;form onSubmit={this.handleRegistration}&gt;<br/>      &lt;Input label="Email" type="email" <strong>name="email" value={this.state.email.value} valid={this.state.email.valid}</strong> onChange={this.handleInputChange} /&gt;<br/>      &lt;Input label="Password" type="password" <strong>name="password" value={this.state.password.value} valid={this.state.password.valid}</strong> onChange={this.handleInputChange} /&gt;<br/>      &lt;Button title="Register" <strong>disabled={!(this.state.email.valid &amp;&amp; this.state.password.valid)} </strong>/&gt;<br/>    &lt;/form&gt;<br/>  )<br/>}</pre>
<p class="mce-root">Next, we will completely rewrite our <kbd>handleInputChange</kbd> method of <kbd>RegistrationForm</kbd> to validate the input and store both the value and its validity into the state. It will use the <kbd>name</kbd> and <kbd>event</kbd> parameters passed by the <kbd>onChange</kbd> event handler of <kbd>Input</kbd>.</p>
<pre class="mce-root">handleInputChange = (<strong>name, event</strong>) =&gt; {<br/>  <strong>const value = event.target.value;</strong><br/><strong>  const valid = validator[name](value);</strong><br/>  this.setState({<br/>    <strong>[name]: { value, valid }</strong><br/>  });<br/>}</pre>
<p class="mce-root">Lastly, we no longer need to use refs to get the values of the <kbd>Input</kbd> components and validate them, since they are already in the state. So, remove those lines from our <kbd>handleRegistration</kbd> method:</p>
<pre class="mce-root">handleRegistration = (event) =&gt; {<br/>  ...<br/>  const hasValidParams = <strong>this.state.email.valid &amp;&amp; this.state.password.valid;</strong><br/>  if (!hasValidParams) { ... }<br/><strong>  const email = this.state.email.value;</strong><br/><strong>  const password = this.state.password.value;</strong><br/>  ...<br/>}</pre>
<p class="mce-root">Now, refresh the page and everything should work as it did before.</p>
<p class="mce-root">In this section, we have lifted the state of our components and consolidated it into a single place. This makes our state easier to manage. However, the way we are changing the state is by passing down <kbd>onChange</kbd> props. Whilst this is fine for simple components like this, it gets much less performant once the components are heavily nested. A single change may invoke tens of functions and this is not sustainable. Therefore, as we continue to develop our application, we will use a state management tool, such as Redux or MobX.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modularizing React</h1>
                
            
            
                
<p class="mce-root">But for now, we must solve another pressing issue - our code is not very modular. Everything is defined inside a single <kbd>&lt;script&gt;</kbd> tag. Not only is this hard to read, but it is also not maintainable. We can't define every component in one file!</p>
<p>Furthermore, we are including libraries using <kbd>&lt;script&gt;</kbd> tags. Because some libraries depend on others (for example, <kbd>react-dom</kbd> depends on <kbd>react</kbd>), we must manually ensure our scripts are loaded in the right order.</p>
<p class="mce-root">We have already looked at CommonJS and ES6 modules when we discussed server-side modules. However, we must consider other factors when using modules on client-side code, such as:</p>
<ul>
<li class="mce-root">The size of each module. Dependencies are downloaded before the application is run. On the server, the application is only initialized once, after which it will keep running for a long time (weeks to years). Therefore, the initial time required for downloading dependencies is a one-time cost. On the client, however, these dependencies need to be downloaded each time a client loads the application. Therefore, it is much more important to keep the file size of the application and its dependencies to be as low as possible.</li>
</ul>
<ul>
<li class="mce-root">How many separate requests are made? On the server, all dependencies reside on the server, and therefore importing a dependency costs virtually nothing. On the client, each request to the server is a new HTTP request, which requires a new TCP handshake. All these operations take a relatively long time, and thus we must ensure that as few requests are made to the server as possible.</li>
<li class="mce-root">Asynchronous. We have already looked at CommonJS modules in <a href="76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml" target="_blank">Chapter 4</a>, <em>Setting Up Development Tools</em>. CommonJS modules are loaded synchronously, this means modules are loaded in the order they are required inside the file/module being run. As a module can have hundreds of dependencies, it means it can take a long time to resolve and download all dependencies. This is not a problem for server applications, because after the initial time requirement, the server application would run for a long time without interruption. On the client, if A depends on B, and B depends on C, C cannot be downloaded until B is downloaded, because we simply cannot know in advance that B depends on C.</li>
</ul>
<p class="mce-root">Because of these concerns, we need to use different tools to make our client-side application performant on the client. So let's spend some time to review them now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Client-side modules</h1>
                
            
            
                
<p class="mce-root">When we developed our server-side code, we used packages from the <a href="https://www.npmjs.com/">npmjs.com</a> registry. These packages were initially intended only for server-side code. Soon, front-end developers realized the power of all these server-side packages, and wanted to utilize them on the client.</p>
<p class="mce-root">This becomes an issue because CommonJS, with its synchronous loading, does not work well on the browser. It would take a long time to load because the modules that are required are not available on the client, and must be downloaded when the page is first accessed. So if a module has an extended dependency tree of over 100 modules, it'd have to download 100 modules before the page/application can be loaded. Since web pages are rarely kept open for a long period of time, the initial load would usually not be worthwhile to the end user, and they will abandon the site.</p>
<p class="mce-root">There are two different solutions to this issue:</p>
<ul>
<li class="mce-root">Module bundling</li>
<li class="mce-root">Asynchronous module loading</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Module bundling</h1>
                
            
            
                
<p class="mce-root">Instead of the client (the browser) resolving hundreds of dependencies and downloading them directly from the client, we would download all dependencies on the server, concatenate them in the right order into a single file (or <strong>bundle</strong>), and send that to the client. The bundle contains the application and <em>all</em> dependencies, and can be loaded like any regular script. Because all dependencies are resolved ahead of time, the time required to resolve dependencies on the client are eliminated.</p>
<p class="mce-root">But because everything is crammed into one file, the bundle may grow quite large, but the load time will be reduced as the client doesn't need to make hundreds of separate requests; now it's just one. Furthermore, if one of the external servers are down, it would not affect our bundled code, as this is served from our own server.</p>
<p class="mce-root">There are four module bundlers that you'll encounter in the wild: <strong>Browserify</strong>, <strong>Webpack</strong>, <strong>Rollup</strong>, and <strong>Parcel</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Browserify</h1>
                
            
            
                
<p class="mce-root">Browserify was the first module bundler and it changed the way frontend code was written. Browserify will analyze and follow the <kbd>require</kbd> calls from an entry point JavaScript file, build up a list of dependencies, download them, and then bundle everything into a single JavaScript file that can be injected using a single <kbd>&lt;script&gt;</kbd> tag. The modules are added recursively, meaning the innermost dependencies are added first. This ensures modules are bundled in the correct order.</p>
<p class="mce-root">To use it, you simply install the <kbd>browserify</kbd> package, and specify the entry point of your application as well as the location where you want the bundle to be placed.</p>
<pre class="mce-root"><strong>$ npm install -g browserify</strong><br/><strong>$ browserify entry.js &gt; bundle.js</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Webpack</h1>
                
            
            
                
<p class="mce-root">Webpack has essentially succeeded Browserify to become the <em>de facto</em> leader. Whilst Browserify did only module bundling, Webpack also tries to integrate features from popular <strong>task runners</strong>, such as <strong>Grunt</strong> or <strong>Gulp</strong>. With Webpack, you can preprocess files (for example, minifying JavaScript and transforming Sass files) before/after bundling them.</p>
<p class="mce-root"/>
<p class="mce-root">One of the standout features of Webpack is <strong>code splitting</strong>. This allows you to split the bundle into multiple files: those that are essential to the initialization and function of the app, and those that can be loaded later. You can then prioritize the transfer of the essential code first, giving your users a faster load time, and a better user experience. The non-essential code can be loaded later, or only on-demand.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rollup</h1>
                
            
            
                
<p class="mce-root">Browserify and Webpack focus on CommonJS modules, and require a Babel plugin to support ES6 modules. Rollup supports native ES6 modules out of the box.</p>
<p class="mce-root">Rollup also supports <strong>tree-shaking</strong>, a feature that eliminates unused code from the bundle. Let's say you are importing a large utility library supporting 100 functions, but are only using four of them; tree-shaking will remove the 96 that are not required for our app. This can significantly reduce bundle size for applications that have a lot of dependencies.</p>
<p class="mce-root">Traditionally, the community consensus is to use Webpack for applications, and Rollup for libraries. There are two reasons for this:</p>
<ul>
<li class="mce-root">Webpack generally produces more boilerplate and thus produces a noticeably larger bundle size that's unnecessary for libraries. This is especially true for earlier versions of Webpack, which would wrap every module inside its own function closures. Not only does this increase bundle size, but it also slows down performance. However, since Webpack 3, these modules are enclosed into one closure using a technique called <strong>scope hoisting</strong>.</li>
<li class="mce-root">Webpack supports code-splitting, which is useful for applications but doesn't really help with libraries</li>
</ul>
<p class="mce-root">However, since their inception, Webpack has added support for tree-shaking, and Rollup has added support for code-splitting, and so the similarities between the tools are increasing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parcel</h1>
                
            
            
                
<p class="mce-root">Lastly, a relatively new tool called Parcel has appeared whose selling point is a zero-configuration setup. Whilst this may speed up initial development, having zero-configuration also means it's likely to support fewer features, and you'll have less control over the final bundle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous module loading</h1>
                
            
            
                
<p class="mce-root">An alternative to module bundling is to load modules asynchronously on the client. Asynchronous module loading means the modules that do not depend on each other can be loaded in parallel. This partially alleviates the slow startup time that clients face when using CommonJS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AMD and Require.js</h1>
                
            
            
                
<p class="mce-root"><strong>Asynchronous Module Definition</strong> (<strong>AMD</strong>) is the most popular module specification that implements asynchronous module loading. AMD is actually an early fork of CommonJS, and also uses the <kbd>require</kbd> and <kbd>exports</kbd> syntax.</p>
<p class="mce-root">Just as there are module bundlers for CommonJS modules, there are <strong>module loaders</strong> for AMD modules. These tools are called loaders because they load the modules from the client directly. The most popular module loader is <strong>Require.js</strong>. Require.js provides you with a <kbd>define</kbd> function, which you can use to define your module. You can pass in a list of dependencies as its first argument. Let's look at an example:</p>
<pre class="mce-root">// greeter.js<br/>define(function () {<br/>  function helloWorld(name) {<br/>    process.stdout.write(`hello ${name}!\n`)<br/>  };<br/>  return { sayHello: helloWorld }<br/>});<br/><br/>// main.js<br/>define(["./greeter.js"], function (greeter) {<br/>  // Only ran after the `greeter` module is loaded<br/>  greeter.sayHello("Daniel");<br/>});</pre>
<p class="mce-root">When the <kbd>main</kbd> module is initiated, it will first load the <kbd>greeter</kbd> module, and pass the object returned into the function that defines the <kbd>main</kbd> module. This ensures that modules are loaded in the correct order.</p>
<p class="mce-root">Require.js handles the loading of these modules in the background, parallelizing them if possible. This means downstream code execution is not blocked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Universal Module Definition</h1>
                
            
            
                
<p class="mce-root"><strong>UMD</strong>, or <strong>Universal Module Definition</strong>, is a module definition format that aims to be compatible with both CommonJS and AMD. It also allows you to export the module as a global variable that you can include in your application through a simple <kbd>&lt;script&gt;</kbd> tag.</p>
<p class="mce-root">It does this by wrapping the modules in a boilerplate that checks the environment to detect how the module is used, and produces the correct exported object.</p>
<p class="mce-root">For example, the preceding <kbd>greeter</kbd> example would look like this with UMD:</p>
<pre class="mce-root">// greeter.js<br/>(function (root, factory) {<br/>  // Requirements are defined here<br/>}(this, function () {<br/>  function helloWorld(name) {<br/>    process.stdout.write(`hello ${name}!\n`<br/>  };<br/>  // Whatever you return is exposed<br/>  return {<br/>    helloWorld: helloWorld<br/>  }<br/>}));<br/><br/>// main.js<br/>(function (root, factory) {<br/>  if (typeof define === 'function' &amp;&amp; define.amd) {<br/>    // AMD<br/>    define(['./greeter.js'], factory);<br/>  } else if (typeof exports === 'object') {<br/>    // Node, CommonJS-like<br/>    module.exports = factory(require('./greeter.js'));<br/>  } else {<br/>    // Browser globals (root is window)<br/>    root.returnExports = factory(root.greeter);<br/>  }<br/>}(this, function (greeter) {<br/>  greeter.sayHello("Daniel");<br/>}));</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">SystemJS and the Loader specification</h1>
                
            
            
                
<p class="mce-root">The <strong>Loader specification</strong> (<a href="https://whatwg.github.io/loader/">whatwg.github.io/loader/</a>) is a work in progress specification that "describes the behavior of loading JavaScript modules from a JavaScript host environment". In other words, it describes a standard way to load JavaScript modules in both the browser and the server. It is developed by the WHATWG but not yet adopted as a living standard.</p>
<p class="mce-root"><strong>SystemJS</strong> is an implementation of the Loader specification that works on the browser. More specifically, SystemJS is a <strong>universal dynamic module loader</strong>. Here, "universal" means it can load not only CommonJS modules, but also ES6 modules, AMD, and global scripts. It does this through the <kbd>SystemJS.import</kbd> method, which is akin to a universal <kbd>require</kbd> that works for all major module definitions. The code for importing an <kbd>App</kbd> component and rendering it may look like this:</p>
<pre class="mce-root">var App = SystemJS.import('./components/App.jsx').then(App =&gt; {<br/>  ReactDOM.render(&lt;App /&gt;, document.getElementById('renderTarget'));<br/>});</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">jspm</h1>
                
            
            
                
<p class="mce-root">However, if SystemJS can import modules from any sources, how does it know where to find the modules? For instance, if we do <kbd>SystemJS.import('moment')</kbd>, should SystemJS fetch the package from the NPM registry? Or is it a custom repository? SystemJS can't know for sure. Therefore, to use SystemJS efficiently, we must use a package manager that can maintain a mapping between package names and their location. Luckily for us, there is <strong>jspm</strong>, which stands for <strong>JavaScript Package Manager</strong>.</p>
<p class="mce-root">jspm is similar to npm and yarn, but it can download modules/packages from anywhere, not just from npm. Furthermore, it will automatically create a SystemJS configuration file with all the package-to-location mapping we talked about previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Module bundler versus module loader</h1>
                
            
            
                
<p class="mce-root">After that brief overview of the tooling surrounding client-side modules, we are still left with the question - should we use a bundler or a loader? The status quo is to use a module bundler. With a loader, you may have to fire hundreds of HTTP requests to download all the dependencies. Even if these happen in the background, it can still lead to a slow load time. Therefore, using a module bundler is likely to allow the application to load quicker.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP/2</h1>
                
            
            
                
<p class="mce-root">However, this problem might be a non-issue once HTTP/2 becomes more widely adopted. With HTTP/1.1, we need to establish separate HTTP <em>and</em> TCP connections for each resource we want to retrieve, even when those resources reside on the same server. Establishing a TCP connection requires a <strong>three-way handshake</strong>, which is expensive.</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/41bca6bc-9aff-4433-8b90-0530bbf353a9.jpg" style="width:29.50em;height:16.50em;"/></p>
<p class="mce-root">With HTTP/2's multiplexing feature, a single TCP connection can be used to make multiple HTTP requests. Furthermore, multiple request and response messages can be sent in-flight simultaneously. Therefore, if HTTP/2 is widely adopted, making multiple requests would not be expensive anymore.</p>
<p class="mce-root">For HTTP/2 to work, it needs to be supported for both the browser and the server.</p>
<p class="mce-root">According to <kbd>caniuse.com</kbd> (<a href="https://caniuse.com/#feat=http2">caniuse.com/#feat=http2</a>), at the time of writing, only 84.53% of browsers support HTTP/2. And according to W3Techs (<a href="https://w3techs.com/technologies/details/ce-http2/all/all">w3techs.com/technologies/details/ce-http2/all/all</a>), at the time of writing, HTTP/2 is used by only 25.3% of all websites. Therefore, a significant segment of browser usage is still on HTTP/1.x browsers. On those browsers, we'd still have to make hundreds to thousands of TCP connections on each page load; this is unacceptable. Therefore, until HTTP/2 support is almost universal, the status quo is still to use a module bundler in order to reduce load speed.</p>
<p class="mce-root">As we have mentioned, the most mature and widely-adopted module bundler is Webpack, and so for the rest of this chapter, we will convert our application to using ES6 modules, and using Webpack to process and bundle our application together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Webpack</h1>
                
            
            
                
<p class="mce-root">We are going to use yarn to manage our dependencies, just like we did for the client-side code. So let's initiate a new configuration file and add the <kbd>webpack</kbd> package as a development dependency:</p>
<pre class="mce-root"><strong>$ yarn init</strong><br/><strong>$ vim .gitignore # Can use the same .gitignore as for our server app</strong><br/><strong>$ yarn add webpack webpack-cli --dev</strong></pre>
<p class="mce-root">Just like Babel, Webpack will take in source files, transforms them and output it somewhere. Therefore, let's also create two directories to separate them.</p>
<pre class="mce-root"><strong>$ mkdir src dist</strong><br/><strong>$ mv index.html src/</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Modularizing our components</h1>
                
            
            
                
<p class="mce-root">Next, we are going to completely gut out every JavaScript script inside our <kbd>src/index.html</kbd>. First, remove all the dependency <kbd>&lt;script&gt;</kbd> tags, such as React, ReactDOM, Babel, and bcryptjs. Then, we will use <kbd>yarn</kbd> to install them instead.</p>
<pre class="mce-root"><strong>$ yarn add react react-dom bcryptjs</strong><br/><strong>$ yarn add @babel/core @babel/preset-react @babel/preset-env @babel/plugin-proposal-class-properties --dev</strong></pre>
<p>Babel is split into multiple smaller packages. This allows developers to use just the one they want, and not include unnecessary features.</p>
<p class="mce-root">We can now use these packages by importing them, just as we did with our back-end code.</p>
<p class="mce-root">Next, we will split our JavaScript code within <kbd>index.html</kbd> into separate modules. We will create:</p>
<ul>
<li class="mce-root">A <kbd>utils</kbd> directory to hold utility functions that can be re-used.</li>
<li class="mce-root">A <kbd>components</kbd> directory to hold all our components.</li>
<li class="mce-root"><kbd>index.jsx</kbd> as the entry point. This will be where we import the overall <kbd>App</kbd> component and render it onto the DOM with <kbd>ReactDOM.render()</kbd>.</li>
</ul>
<p>Run the following on your terminal:</p>
<pre class="mce-root">$ mkdir -p \<br/>  src/utils/validator \<br/>  src/utils/register \<br/>  src/components/input \<br/>  src/components/button \<br/>  src/components/Registration-form<br/>$ touch \<br/>  src/index.jsx \<br/>  src/utils/validator/index.js \<br/>  src/utils/register/index.js \<br/>  src/components/input/index.jsx \<br/>  src/components/button/index.jsx \<br/>  src/components/Registration-form/index.jsx</pre>
<p>We are using the <kbd>.jsx</kbd> extension here to denote that this file contains JSX syntax. Later on, this convention will help Webpack to efficiently determine which files it needs to process.</p>
<p class="mce-root">First, let's move the <kbd>validator</kbd> object from the <kbd>src/index.html</kbd> file into <kbd>src/utils/validator/index.js</kbd> and export it.</p>
<pre class="mce-root">const validator = {<br/>  email: (email) =&gt; /\S+@\S+\.\S+/.test(email),<br/>  password: (password) =&gt; password.length &gt; 11 &amp;&amp; password.length &lt; 48<br/>}<br/><strong>export default validator;</strong></pre>
<p class="mce-root">Do the same for the <kbd>register</kbd> function. Then, extract each component into its own <kbd>index.jsx</kbd>. For instance, <kbd>src/components/button/index.jsx</kbd> would contain the code below.</p>
<pre class="mce-root"><strong>import React from 'react';</strong><br/>function Button(props) {<br/>  return &lt;button disabled={props.disabled}&gt;{props.title}&lt;/button&gt;<br/>}<br/><strong>export default Button;</strong></pre>
<p class="mce-root">And <kbd>src/components/input/index.jsx</kbd> would look like this:</p>
<pre class="mce-root"><strong>import React from 'react';</strong><br/>function getIndicatorColor (state) { ... }<br/>function Input (props) { ... }<br/><strong>export {</strong><br/><strong>  Input as default,</strong><br/><strong>  getIndicatorColor,</strong><br/><strong>}</strong></pre>
<div><kbd>react</kbd> must be imported into every module that uses React and JSX.</div>
<p class="mce-root">For the <kbd>RegistrationForm</kbd> component, which has external dependencies, we can <kbd>import</kbd> it at the top of the module:</p>
<pre class="mce-root"><strong>import React from 'react';</strong><br/><strong>import bcrypt from 'bcryptjs';</strong><br/><strong>import { validator } from '../../utils';<br/>import register from '../../utils/register';</strong><br/><strong>import Button from '../button/index.jsx';</strong><br/><strong>import Input from '../input/index.jsx';</strong><br/><br/>class RegistrationForm extends React.Component { ... }<br/><br/><strong>export default RegistrationForm;</strong></pre>
<p class="mce-root">Finally, in our <kbd>src/index.jsx</kbd>, import the <kbd>RegistrationForm</kbd> component and render it onto the DOM:</p>
<pre class="mce-root">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import RegistrationForm from './components/Registration-form/index.jsx';<br/>ReactDOM.render(&lt;RegistrationForm /&gt;, document.getElementById('renderTarget'));</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Entry/output</h1>
                
            
            
                
<p class="mce-root">As mentioned already, Webpack is a module bundler. It takes your application code, and all its dependencies, and bundles them into one or a small number of files. These files can then be transferred to the client and executed. More formally, it takes many source <strong>input</strong> files and bundles them into <strong>output</strong> file(s). With Webpack, the developer specifies one or several entry points, and Webpack will follow <kbd>require</kbd> or <kbd>import</kbd> statements in each file to build up a tree of dependencies.</p>
<p class="mce-root">Webpack's original selling point is its configurability. So let's begin by creating a configuration file at <kbd>webpack.config.js</kbd>.</p>
<pre class="mce-root">const webpack = require('webpack');<br/>module.exports = {<br/>  entry: {<br/>    app: './src/index.jsx',<br/>  },<br/>  output: {<br/>    filename: './dist/bundle.js',<br/>  },<br/>};</pre>
<p>In Webpack 4, sensible defaults have been set for the most common configurations. This means we can use Webpack without a <kbd>webpack.config.js</kbd> (they've marketed this as <strong>Zero configuration JavaScript</strong> (<strong>0CJS</strong>)). However, it is always better to be explicit rather than implicit, and so we will still maintain <kbd>webpack.config.js</kbd>.</p>
<p class="mce-root">Let's see what happens when we run the Webpack CLI.</p>
<pre class="mce-root"><strong>$ npx webpack</strong><br/><strong>Hash: 9100e670cdef864f62dd</strong><br/><strong>Version: webpack 4.6.0</strong><br/><strong>Time: 243ms</strong><br/><strong>Built at: 2018-04-24 18:44:49</strong><br/><strong>1 asset</strong><br/><strong>Entrypoint main = main.js</strong><br/><strong>[0] ./src/index.js 283 bytes {0} [built] [failed] [1 error]</strong><br/><br/><strong>ERROR in ./src/index.js</strong><br/><strong>Module parse failed: Unexpected token (3:16)</strong><br/><strong>You may need an appropriate loader to handle this file type.</strong><br/><strong>| import RegistrationForm from './components/Registration-form';</strong><br/><strong>|</strong><br/><strong>| ReactDOM.render(&lt;RegistrationForm /&gt;, document.getElementById('renderTarget'));</strong><br/><strong>|</strong></pre>
<p class="mce-root">The Webpack CLI is complaining that it does not understand the <kbd>import</kbd> syntax. This is because, by default, Webpack only fully-supports ES5 syntax, and doesn't support ES6 modules. To allow Webpack to understand ES6 syntax, we must use the <kbd>babel-loader</kbd> package.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Loaders</h1>
                
            
            
                
<p class="mce-root">Loaders are transformation programs that run on the source files <em>individually</em>. For example, you'd use loaders to transform CoffeeScript/TypeScript into ES5 before bundling them; in our case, we use it to transform ES2015+ syntax and JSX into ES5. First, let's install the loader using yarn.</p>
<pre class="mce-root"><strong>$ yarn add babel-loader --dev</strong></pre>
<p class="mce-root">Next, we will update <kbd>webpack.config.js</kbd> to instruct Webpack to use the loader. We can do this by defining loader specifications inside the <kbd>module.rules</kbd> property.</p>
<pre class="mce-root">const webpack = require('webpack');<br/><br/>module.exports = {<br/>  entry: { app: './src/index.jsx' },<br/>  output: { filename: 'bundle.js' },<br/>  module: {<br/>    rules: [{<br/>      test: /\.jsx?$/,<br/>      exclude: /node_modules/,<br/>      use: [{<br/>        loader: 'babel-loader',<br/>        options: {<br/>          presets: ['@babel/preset-env', '@babel/preset-react'],<br/>          plugins: [require('@babel/plugin-proposal-class-properties')],<br/>        },<br/>      }],<br/>    }],<br/>  },<br/>};</pre>
<p class="mce-root">Each loader specification contains two important sub-properties:</p>
<ul>
<li class="mce-root"><kbd>test</kbd> determines which files should be processed by this loader. Here, we are using a regular expression, <kbd>/\.jsx?$/</kbd>, to tell Webpack to use this loader to process all files with an extension of <kbd>.jsx</kbd>.</li>
<li class="mce-root"><kbd>use</kbd> specifies which loaders should be used to transform these files, plus any additional options to pass into the loaders. Here, we are instructing Webpack to use the <kbd>babel-loader</kbd> module we just installed, and Babel should use the React and <kbd>env</kbd> presets, as well as the Transform Class Properties plugin.</li>
</ul>
<p class="mce-root">Now, when we run <kbd>webpack</kbd> again, you will see that <kbd>dist/bundle.js</kbd> being created.</p>
<pre class="mce-root"><strong>$ npx webpack</strong><br/><strong>Hash: adbe083c08891bf4d5c7</strong><br/><strong>Version: webpack 4.6.0</strong><br/><strong>Time: 4933ms</strong><br/><strong>Built at: 2018-04-24 19:34:55</strong><br/><strong>Asset Size Chunks Chunk Names</strong><br/><strong>bundle.js 322 KiB 0 [emitted] [big] app</strong><br/><strong>Entrypoint app [big] = bundle.js</strong><br/><strong>[7] (webpack)/buildin/global.js 489 bytes {0} [built]</strong><br/><strong>[73] (webpack)/buildin/module.js 497 bytes {0} [built]</strong><br/><strong>[74] ./src/utils/index.js 324 bytes {0} [built]</strong><br/><strong>[120] crypto (ignored) 15 bytes {0} [optional] [built]</strong><br/><strong>[121] buffer (ignored) 15 bytes {0} [optional] [built]</strong><br/><strong>[153] util (ignored) 15 bytes {0} [built]</strong><br/><strong>[155] util (ignored) 15 bytes {0} [built]</strong><br/><strong>[162] ./src/index.jsx 327 bytes {0} [built]</strong><br/><strong>+ 155 hidden modules</strong></pre>
<p>It may also print some warnings regarding optimizing the build. We can ignore these for now.</p>
<p class="mce-root">Now that we have <kbd>bundle.js</kbd> at the root of the <kbd>dist/</kbd> directory, we should update our <kbd>src/index.html</kbd> to use the bundled script. Replace the <kbd>&lt;script type="text/babel"&gt;...&lt;/script&gt;</kbd> block with <kbd>&lt;script src="img/bundle.js"&gt;&lt;/script&gt;</kbd>.</p>
<p class="mce-root">However, the <kbd>index.html</kbd> is not copied across from the <kbd>src/</kbd> directory to the <kbd>dist/</kbd> directory. This is because Webpack only processes JavaScript (<kbd>.js</kbd> / <kbd>.mjs</kbd>), JSON, and WebAssembly files (<kbd>.wasm</kbd>). To copy the <kbd>index.html</kbd> file across, we need another type of tool called a <strong>plugin</strong>.</p>
<p>CSS and HTML modules are planned to be supported in Webpack 5, so some of the plugins we introduce here may not be necessary in the future.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Plugins</h1>
                
            
            
                
<p class="mce-root">Loaders work on transforming <em>individual</em> files, "in place", <em>before or during</em> the creation of the bundle. In contrast, plugins work on the output of the loaders and process the bundle as a whole <em>after</em> it's created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Copying files</h1>
                
            
            
                
<p class="mce-root">To copy our <kbd>src/index.html</kbd> file across, we can use the aptly-named Copy Webpack plugin (<kbd>copy-webpack-plugin</kbd>). As its name suggests, this plugin copies individual files or entire directories to the build directory. Let's install it with yarn.</p>
<pre class="mce-root"><strong>$ yarn add copy-webpack-plugin --dev</strong></pre>
<p class="mce-root">And add the plugin to our <kbd>webpack.config.js</kbd>.</p>
<pre class="mce-root">const webpack = require('webpack');<br/><strong>const CopyWebpackPlugin = require('copy-webpack-plugin');</strong><br/>module.exports = {<br/>  entry: { ... },<br/>  output: { ... },<br/>  module: { ... },<br/>  <strong>plugins: [</strong><br/><strong>    new CopyWebpackPlugin(['src/index.html'])</strong><br/><strong>  ],</strong><br/>};</pre>
<p class="mce-root">The <kbd>CopyWebpackPlugin</kbd> constructor has the following signature:</p>
<pre class="mce-root">CopyWebpackPlugin([ ...patterns ], options)</pre>
<p class="mce-root">Here,<kbd>patterns</kbd> specifies a set of matching files it should copy. We are simply specifying a single file.</p>
<p class="mce-root">Run <kbd>webpack</kbd> again and you'll see both <kbd>bundle.js</kbd> and <kbd>index.html</kbd> being written to the <kbd>dist/</kbd> directory. We can now use the <kbd>http-server</kbd> package to serve the <kbd>dist/</kbd> directory statically.</p>
<pre class="mce-root">$ http-server <strong>dist/</strong> -p 8200 --cors</pre>
<p class="mce-root">You should be presented with the same Registration form as before. But now our code is much more modular.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Final steps</h1>
                
            
            
                
<p class="mce-root">Before we finish, let's also document the commands we've run into npm scripts. This will make building and serving our application easier in the future.</p>
<p class="mce-root">In the <kbd>package.json</kbd>, define the build step with the following <kbd>scripts</kbd> property:</p>
<pre class="mce-root">"scripts": {<br/>  "build": "rm -rf dist/ &amp;&amp; webpack"<br/>}</pre>
<p class="mce-root">Then, we will write a script to serve our application. We'd like to specify the host and port of the application using environment variables (instead of hard-coding it), so let's create an <kbd>.env</kbd> and an <kbd>.env.example</kbd> file, and fill them with the following content:</p>
<pre class="mce-root">WEB_SERVER_PORT_TEST=8200<br/>WEB_SERVER_HOST_TEST=localhost</pre>
<p class="mce-root">Then, create a Bash script at <kbd>scripts/serve.sh</kbd> and give it the execute permission:</p>
<pre class="mce-root">$ mkdir scripts &amp;&amp; touch scripts/serve.sh<br/>$ chmod u+x scripts/serve.sh</pre>
<p class="mce-root">Inside the Bash script, we will simply load the environment variables, build the application, and use <kbd>htttp-server</kbd> to serve the bundled files:</p>
<pre class="mce-root">#!/usr/bin/env bash<br/># Set environment variables from .env and set NODE_ENV to test<br/>source &lt;(dotenv-export | sed 's/\\n/\n/g')<br/>export NODE_ENV=test<br/>yarn run build<br/>http-server dist/ -- -p $WEB_SERVER_PORT_TEST --cors</pre>
<p class="mce-root">Now, we just need to run our Bash script using an npm script:</p>
<pre class="mce-root">"serve": "./scripts/serve.sh"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have built a basic Registration form using React, and bundled it using Webpack. In the next chapter, we will look at how to perform E2E testing for front-end applications using <strong>Selenium</strong>.</p>


            

            
        
    </body></html>