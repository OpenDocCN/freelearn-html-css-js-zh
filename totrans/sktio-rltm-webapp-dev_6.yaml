- en: Chapter 6. Deploying and Scaling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。部署和扩展
- en: 'Running our application on the local server is fine, but making a web application
    really useful requires deploying it to a public server and making it accessible
    to others. To run our chat server application on Node.js, along with using protocols
    such as WebSocket, requires some special considerations. In this chapter, we will
    take a look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地服务器上运行我们的应用程序是可以的，但要使一个网络应用程序真正有用，需要将其部署到公共服务器并使其对他人可访问。要在 Node.js 上运行我们的聊天服务器应用程序，除了使用
    WebSocket 等协议外，还需要考虑一些特殊因素。在本章中，我们将探讨以下内容：
- en: Things to consider while deploying our application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署我们的应用程序时需要考虑的事项
- en: Recommendations for a production-ready deployment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产就绪部署的建议
- en: Reason why scaling of socket.io applications is different than other web applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 socket.io 应用程序的扩展与其他网络应用程序不同
- en: How we can scale our chat application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何扩展我们的聊天应用程序
- en: The production environment
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境
- en: 'The first thing we should do before running an application on a production
    server is to set the environment to `production`. Every modern server or framework
    has separate development and production modes and so does node. In fact, in node
    you can set the environment to any name and then have different configurations
    for that name in your code. To set the environment our node server runs in, we
    set an environment variable `NODE_ENV` to the environment we want to run node
    in. So, to run node in the `production` environment, we use the following line:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产服务器上运行应用程序之前，我们应该做的第一件事是将环境设置为 `production`。每个现代服务器或框架都有开发和生产模式，node 也不例外。实际上，在
    node 中，你可以将环境设置为任何名称，然后在代码中为该名称设置不同的配置。要设置我们的 node 服务器运行的环境，我们设置一个环境变量 `NODE_ENV`
    为我们想要运行 node 的环境。因此，要运行 node 在 `production` 环境中，我们使用以下行：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then run your node application. In [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Node.js"), *Getting Started with Node.js*, we saw how the first argument
    in `app.configure` is the environment variable we need to configure for:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行你的 node 应用程序。在 [第 2 章](ch02.html "Chapter 2. Getting Started with Node.js")
    中，*入门 Node.js*，我们看到了 `app.configure` 中的第一个参数是我们需要配置的环境变量：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this snippet we are setting the application to activate `express.errorHandler`
    in the `development` environment, which is the default environment. If we have
    set `NODE_ENV` to `production`, `express.errorHandler` will not be used.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们正在将应用程序设置为在 `development` 环境中激活 `express.errorHandler`，这是默认环境。如果我们已将
    `NODE_ENV` 设置为 `production`，则不会使用 `express.errorHandler`。
- en: Running the application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Running the application on the command line using node, like we have been doing
    until now, works during development; but on a production server where we connect
    remotely, it is generally not feasible or advisable to keep the console running.
    There are two ways to handle this, either we run node as a background process
    redirecting all console output to a file or we run it in a persistent console,
    to which we can reconnect, using `screen` or `byobu`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 node 在命令行上运行应用程序，就像我们到目前为止所做的那样，在开发期间是可行的；但在我们远程连接的生产服务器上，通常不切实际或建议保持控制台运行。有两种处理方式，要么我们将
    node 作为后台进程运行，将所有控制台输出重定向到文件，要么我们在持久控制台中运行它，我们可以使用 `screen` 或 `byobu` 重新连接到该控制台。
- en: 'To run node as a background process, like any other process on Linux, we will
    use the `&` operator and to make sure that it keeps running even after we log
    out, we will use `nohup`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要将节点作为后台进程运行，就像在 Linux 上的任何其他进程一样，我们将使用 `&` 操作符，并且为了确保我们在登出后它仍然继续运行，我们将使用 `nohup`：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command will redirect the `stdout` and `stderr` commands to `npmout.log`
    and will put the npm process in the background.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将重定向 `stdout` 和 `stderr` 命令到 `npmout.log`，并将 npm 进程置于后台。
- en: 'Another option is to run node on a long-lasting console, using utilities such
    as `screen` or `byobu`. To use this, start `screen` and then run your application,
    as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `screen` 或 `byobu` 等实用程序在持久控制台上运行 node。要使用此方法，启动 `screen`，然后运行你的应用程序，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can detach from this screen by using *Ctrl* +*a* and then hitting *d*.
    This will drop us to the default shell. We can then disconnect. When we connect
    back to the server, to see the server output, we can attach back to the screen
    by using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用 *Ctrl* +*a* 然后按 *d* 来断开与此屏幕的连接。这将使我们回到默认的 shell。然后我们可以断开连接。当我们再次连接到服务器时，为了查看服务器输出，我们可以使用以下命令重新连接到屏幕：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keeping it running
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持运行
- en: 'Not only do we want the application to run when we log out, we want our application
    to keep running reliably. The production servers are not frequently restarted,
    and in general we will like to ensure that they come back up as soon as possible
    when there is a crash, a failure, or an error. For node, generally it means restarting
    the process as soon as it fails. There are many ways to keep the node server running.
    In this section we will see two of them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅希望应用程序在我们登出时运行，我们还希望我们的应用程序能够可靠地持续运行。生产服务器不经常重启，通常我们希望它们在发生崩溃、故障或错误时尽快恢复。对于node，通常意味着在失败时立即重启进程。有许多方法可以保持node服务器运行。在本节中，我们将看到其中两种：
- en: Monit
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monit
- en: Forever
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Forever
- en: 'Here is how Monit is described on its website ([http://mmonit.com/monit/](http://mmonit.com/monit/)):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Monit在其网站上如何描述的（[http://mmonit.com/monit/](http://mmonit.com/monit/))：
- en: Monit is a free open source utility for managing and monitoring processes, programs,
    files, directories, and filesystems on a UNIX system. Monit conducts automatic
    maintenance and repair and can execute meaningful causal actions in error situations.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Monit是一个免费的开源实用程序，用于管理和监控UNIX系统上的进程、程序、文件、目录和文件系统。Monit执行自动维护和修复，并在错误情况下执行有意义的因果操作。
- en: 'Let us begin with installing Monit. On RPM-based or Yum-based systems such
    as RHEL, Fedora, or CentOS, you can install it using the `yum` command, as shown
    here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装Monit开始。在基于RPM或Yum的系统上，如RHEL、Fedora或CentOS，你可以使用`yum`命令安装它，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or on a Debian- or apt-get-based system, you can install Monit using `apt-get`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在基于Debian或apt-get的系统上，你可以使用`apt-get`安装Monit：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For other systems, you can check the installation instructions at the Monit
    website.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他系统，你可以在Monit网站上查看安装说明。
- en: 'Once Monit is installed, we can configure it to manage our node application.
    For this, we will create a configuration file (in our case we will call it `awesome-chat`)
    in `/etc/monit.d/` or `/etc/monit/conf.d/`, depending on your Monit installation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Monit，我们就可以配置它来管理我们的node应用程序。为此，我们将在`/etc/monit.d/`或`/etc/monit/conf.d/`中创建一个配置文件（在我们的例子中我们将称之为`awesome-chat`），具体取决于你的Monit安装：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this file, you should notice the highlighted section. We are emphasizing
    the program or more importantly, the commands to start/stop our application and
    then finally configuring Monit to restart the application in case of a failure.
    This is detected by sending an HTTP request to fetch the page at port `3000`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你应该注意到高亮的部分。我们强调的是程序，或者更重要的是，启动/停止我们的应用程序的命令，然后最终配置Monit在发生故障时重启应用程序。这是通过向端口`3000`发送HTTP请求来检测的。
- en: 'That is it; we can start our application with the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们可以使用以下命令启动我们的应用程序：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And stop it with the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码停止它：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In case of a crash, Monit will take care of restarting the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生崩溃的情况下，Monit将负责重启应用程序。
- en: Monit can be used to run and watch any daemon service. It also has a web interface
    in case you want to check the status, which by default runs on port `2812`. You
    can learn more about Monit on its website and in its manual online.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Monit可以用来运行和监控任何守护进程服务。它还有一个网页界面，如果你想要检查状态，默认情况下它运行在端口`2812`上。你可以在Monit的网站上及其在线手册中了解更多关于Monit的信息。
- en: 'Another, more node-specific way to keep our server up and running is **Forever**
    ([https://github.com/nodejitsu/forever](https://github.com/nodejitsu/forever)).
    Forever describes itself as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更具体的node方法来确保我们的服务器持续运行是**Forever** ([https://github.com/nodejitsu/forever](https://github.com/nodejitsu/forever))。Forever描述自己为：
- en: A simple CLI tool for ensuring that a given script runs continuously.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个简单的CLI工具，用于确保给定的脚本持续运行。
- en: 'And that''s what is does. Given your node application script, Forever will
    start it and make sure it keeps running continuously. Since Forever itself is
    a node application, we will use npm to install it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的作用。给定你的node应用程序脚本，Forever将启动它并确保它持续运行。由于Forever本身也是一个node应用程序，我们将使用npm来安装它：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, to start the application with Forever, it is just a matter of executing
    the `app.js` file with `forever`. Just run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用Forever启动应用程序，只需执行`app.js`文件并使用`forever`。只需运行以下命令：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see the list of applications running forever with the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看持续运行的应用程序列表：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To stop the application, use the `forever stop` command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止应用程序，请使用`forever stop`命令：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Visit Forever's github page for understanding more about Forever and its workings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Forever的GitHub页面，了解更多关于Forever及其工作原理的信息。
- en: There are several other tools on *nix systems to make node run as a daemon.
    Few of them are as follows
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *nix 系统上还有其他一些工具可以将 node 运行为守护进程。以下是一些：
- en: '[http://upstart.ubuntu.com/](http://upstart.ubuntu.com/))'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://upstart.ubuntu.com/](http://upstart.ubuntu.com/))'
- en: Supervisord ([http://supervisord.org/](http://supervisord.org/))
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Supervisord ([http://supervisord.org/](http://supervisord.org/))
- en: Daemontools ([http://cr.yp.to/daemontools.html](http://cr.yp.to/daemontools.html))
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Daemontools ([http://cr.yp.to/daemontools.html](http://cr.yp.to/daemontools.html))
- en: Scaling
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Now that we have made sure that our application will keep running and also
    will restart from failures, it''s time we start looking at ways to handle millions
    of users flocking to our chat room. To begin with this, the first step is to put
    up a load-balancer proxy in front of our server. There are lots of options in
    this, we can use the Apache HTTP server, Nginx, and so on. All these servers work
    very well with balancing traditional HTTP traffic, but still have some time to
    catch up to work with WebSockets. So we will use a server that works on load-balancing
    TCP/IP itself. This is **HAProxy** ([http://haproxy.1wt.eu/](http://haproxy.1wt.eu/)).
    This is how HAProxy is described in its official website:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确保了我们的应用程序将持续运行，并且可以从故障中恢复，是时候开始考虑如何处理成千上万用户涌入我们的聊天室了。首先，第一步是在服务器前设置一个负载均衡器代理。这里有多种选择，我们可以使用
    Apache HTTP 服务器、Nginx 等。所有这些服务器在平衡传统 HTTP 流量方面都工作得很好，但还需要一些时间才能赶上处理 WebSocket。因此，我们将使用一个本身就在负载均衡
    TCP/IP 上工作的服务器。这是 HAProxy 在其官方网站上的描述：
- en: HAProxy is a free, very fast and reliable solution offering high availability,
    load balancing, and proxying for TCP and HTTP-based applications. It is particularly
    suited for web sites crawling under very high loads while needing persistence
    or Layer7 processing. Supporting tens of thousands of connections is clearly realistic
    with today's hardware.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HAProxy 是一个免费、非常快速且可靠的解决方案，提供高可用性、负载均衡和 TCP 及 HTTP 应用程序的代理功能。它特别适合在需要持久性或第 7
    层处理的情况下，处理承受极高负载的网站。在今天硬件的支持下，显然可以支持数万个连接。
- en: 'HAProxy works with frontends and backends. These are configured using the HAProxy
    configuration file present at `/etc/haproxy/haproxy.cfg`. The following file creates
    a frontend listener at port `80` and forwards it to a single server at `3000`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy 与前端和后端一起工作。这些是通过位于 `/etc/haproxy/haproxy.cfg` 的 HAProxy 配置文件配置的。以下文件在端口
    `80` 创建了一个前端监听器，并将其转发到单个位于 `3000` 的服务器：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this file, we are defining a frontend listener at `0.0.0.0:80` with the default
    `www_Node.js` backend listening at `3000` on the same `127.0.0.1` server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们正在定义一个位于 `0.0.0.0:80` 的前端监听器，默认的 `www_Node.js` 后端在相同的 `127.0.0.1` 服务器上监听
    `3000`。
- en: 'But this configuration is not ready to handle WebSockets. To support and handle
    WebSockets, refer to the following code block:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但此配置尚未准备好处理 WebSocket。要支持和处理 WebSocket，请参考以下代码块：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing we did was to increase the client timeout value, so the client
    connection doesn't drop off if there is a long inactivity from the client. The
    `acl` lines of code instruct HAProxy to understand and check when we get a `websocket`
    request.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是增加客户端超时值，这样当客户端长时间无活动时，客户端连接不会断开。`acl` 代码行指示 HAProxy 理解并检查我们何时收到 `websocket`
    请求。
- en: By using the `use_backend` instruction, we configure HAProxy to use the `www_Node.js`
    backend to handle the `websocket` request. This is useful when you want to serve
    your static pages from any server, such as Apache HTTP, and want to use node exclusively
    to handle socket.io.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `use_backend` 指令，我们配置 HAProxy 使用 `www_Node.js` 后端来处理 `websocket` 请求。当你想从任何服务器（如
    Apache HTTP）提供静态页面，并希望仅使用 node 来处理 socket.io 时，这很有用。
- en: 'Now we come to the part where we would like the request to be handled by more
    than one node server/process. To do this, first we will tell the proxy to round
    robin the requests by adding the following instruction to the backend:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到想要请求由多个节点服务器/进程处理的环节。为此，首先我们将告诉代理通过添加以下指令到后端来实现请求的轮询：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we will add more server entries to the backend:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将向后端添加更多服务器条目：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here we are adding two new node instances: one is a new process listening on
    port `4000` on the same server, while the other one is running on another server,
    which is accessible to the load-balancer at `192.168.1.101` on port `3000`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了两个新的节点实例：一个是在同一服务器上监听端口 `4000` 的新进程，另一个运行在另一服务器上，该服务器可通过负载均衡器在 `192.168.1.101`
    的端口 `3000` 上访问。
- en: We are done configuring the servers and the incoming requests will now be routed
    between the three node instances that we have configured.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已完成服务器的配置，现在进入的请求将现在在配置的三个节点实例之间路由。
- en: The node cluster
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点集群
- en: Node now comes with its own completely rewritten cluster module. Cluster allows
    node to start multiple processes behind the cluster frontend and monitors and
    manages them. We will take a quick look at how to make an application cluster
    with this module, but note that this is only for creating multiple processes and
    we must still set up a tool to monitor the cluster master and also a proxy to
    forward requests to the node server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Node 现在自带完全重写的集群模块。集群模块允许节点在集群前端启动多个进程，并监控和管理它们。我们将快速查看如何使用此模块创建应用程序集群，但请注意，这只是为了创建多个进程，我们仍然需要设置一个工具来监控集群主进程，以及一个代理来将请求转发到节点服务器。
- en: Let us see how we can use the cluster module. The best part about the cluster
    module is you don't need to actually change your application. Cluster will run
    a master instance, and we can start multiple instances of our application and
    they will all listen to a shared port.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用集群模块。集群模块最好的部分是，你实际上不需要更改你的应用程序。集群将运行一个主实例，我们可以启动我们应用程序的多个实例，它们都将监听一个共享端口。
- en: 'Here is the script that we can use for clustering the `app.js` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们可以使用来集群化 `app.js` 文件的脚本：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, what's happening here? The first thing we do is use `require` on the `cluster`
    module. In the next line, we are checking whether the instance that is started
    is the master process or the worker.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？我们首先使用 `require` 引入 `cluster` 模块。在下一行，我们检查启动的实例是主进程还是工作进程。
- en: 'If it is the master process, we check if the `NODE_WORKERS` environment variable
    is set, else we get the number of processors available on the system our server
    is running on. To set the `NODE_WORKERS` environment variable, you can run the
    following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是主进程，我们检查是否设置了 `NODE_WORKERS` 环境变量，否则获取服务器运行系统上的处理器数量。要设置 `NODE_WORKERS` 环境变量，你可以运行以下命令：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous command will tell the cluster to start two nodes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将告诉集群启动两个节点。
- en: Now, in the loop, we call `fork` on the cluster. This calls `child_process.fork`
    so that the master and the started workers can communicate via IPC.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在循环中，我们在集群上调用 `fork`。这调用 `child_process.fork`，以便主进程和启动的工作进程可以通过 IPC 进行通信。
- en: When the cluster process is run from `fork`, `cluster.isMaster` is false and
    so our `app.js` script is in the current worker process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `fork` 运行集群进程时，`cluster.isMaster` 为 false，因此我们的 `app.js` 脚本位于当前工作进程。
- en: In our application, when we call `server.listen(3000)`, the worker serializes
    this and sends over the request to the server, the server checks if it already
    is listening on that port, and returns the handle for the listener, if it is present.
    Else, the server starts listening on the port and passes on the handle to the
    newly created listener.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，当我们调用 `server.listen(3000)` 时，工作进程将序列化此操作并将请求发送到服务器，服务器检查是否已经在该端口上监听，如果存在，则返回监听器的句柄。否则，服务器将开始在该端口上监听，并将句柄传递给新创建的监听器。
- en: Since all our workers request to listen on port `3000`, the server will start
    listening on the port when the first worker starts and will pass on the same handler
    to all the workers. When a request comes in, it will be handled by any worker
    that can take it up and process it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有我们的工作进程都请求监听端口 `3000`，服务器将在第一个工作进程启动时开始监听该端口，并将相同的处理程序传递给所有工作进程。当请求到来时，它将由任何可以处理并处理该请求的工作进程处理。
- en: 'Since our monitoring tool (Monit or Forever, or others) will now be monitoring
    only the master process, it becomes the master''s responsibility to monitor the
    workers. This means that the cluster should restart any worker that happens to
    die. We will do this, by adding the following event handler in the master process:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的监控工具（Monit 或 Forever，或其他）现在将仅监控主进程，因此监控工作进程成为主进程的责任。这意味着集群应该重新启动任何意外死亡的工作进程。我们将通过在主进程中添加以下事件处理程序来完成此操作：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Monitoring of the process is done by listening to the `exit` event on the socket.
    This is the event that will be triggered when any worker dies. The event handler
    will get the worker, its exit code, and the signal that caused the process to
    be killed. In the handler, we log the death and we start a new worker process
    using `cluster.fork()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过监听套接字的 `exit` 事件来监控进程。这是任何工作进程死亡时将触发的事件。事件处理程序将获取工作进程、其退出代码以及导致进程被杀死的信号。在处理程序中，我们记录死亡情况，并使用
    `cluster.fork()` 启动一个新的工作进程。
- en: 'Now we can start the new clustered application; we''ll run `cluster.js` instead
    of `app.js`. So change the `start` script in `package.json` to run `cluster.js`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动新的集群应用程序；我们将运行 `cluster.js` 而不是 `app.js`。因此，将 `package.json` 中的 `start`
    脚本更改为运行 `cluster.js`：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And then run the application with npm.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 npm 运行应用程序。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will start the application and everything will look just as it was. But
    when you start using it, you'll notice that there are errors while trying to connect
    to a room, or while sending messages. These errors are because we are using an
    in-memory store for our Express.js sessions and socket.io uses an in-memory store
    to store and transfer all the messages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序，一切看起来都和之前一样。但当你开始使用它时，你会注意到在尝试连接到房间或发送消息时出现了错误。这些错误是因为我们正在使用内存存储来存储
    Express.js 会话，而 socket.io 使用内存存储来存储和传输所有消息。
- en: Scaling up the application
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序扩展
- en: In the previous section we saw how we can cluster a Node.js app and how it remains
    restricted due to our application mechanisms. In its current state, the application
    uses an in-memory store to keep the session data. This store is local to the Node.js
    instance and so won't be accessible in any another clustered instance. Also, the
    data will be lost in a Node.js instance restart. So, what we need is a way to
    store the session in a persistent store. Also, we want to configure socket.io
    such that all its instances use a shared pub-sub and data store. The Connect framework
    has an extension mechanism so a new store can be plugged in, and there is one
    store that is persistent as well as excels at pub-sub. It is the **Redis** **Session
    Store**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了如何对 Node.js 应用程序进行集群化以及它如何由于我们的应用程序机制而受到限制。在其当前状态下，应用程序使用内存存储来保持会话数据。此存储是
    Node.js 实例本地的，因此不会在任何其他集群实例中可用。此外，数据将在 Node.js 实例重启时丢失。因此，我们需要一种将会话存储在持久存储中的方法。此外，我们希望配置
    socket.io，使其所有实例都使用共享的 pub-sub 和数据存储。Connect 框架有一个扩展机制，因此可以插入新的存储，并且有一个存储既持久又擅长
    pub-sub。它是 **Redis** **会话存储**。
- en: Redis ([http://redis.io/](http://redis.io/)) is a high performance, distributed,
    open source key-value store that can also be used as a queue. We will use Redis
    and corresponding Redis stores to provide a reliable, distributed, and shared
    store and pub-sub queue. Please check out the instructions to install the Redis
    server on your operating system and start it up.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Redis ([http://redis.io/](http://redis.io/)) 是一个高性能、分布式、开源的键值存储，也可以用作队列。我们将使用
    Redis 和相应的 Redis 存储来提供一个可靠、分布式和共享的存储和 pub-sub 队列。请查看在您的操作系统上安装 Redis 服务器并启动它的说明。
- en: 'Let''s make a few changes to our chat application, beginning with `package.json`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的聊天应用程序做一些更改，从 `package.json` 开始：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will add support for the Connect/Express.js Redis store and the Redis
    connection client. Let''s first get Express.js to use Redis; to do so, edit `app.js`
    by referring to the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为 Connect/Express.js Redis 存储和 Redis 连接客户端添加支持。让我们首先让 Express.js 使用 Redis；为此，通过以下代码片段编辑
    `app.js`：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So the two changes we make here are pulling in the Redis session store and then
    we can replace the session store to be an instance of `RedisStore`. That's all
    that is needed to get Express running using the Redis store.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里做的两个更改是引入 Redis 会话存储，然后我们可以将会话存储替换为 `RedisStore` 的实例。这就是 Express 使用
    Redis 存储运行所需的所有内容。
- en: 'The next thing we need to do is get socket.io using Redis. So, let us edit
    `socket.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要使用 Redis 来配置 socket.io。因此，让我们编辑 `socket.js`：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first thing in the preceding code snippet that we are doing is `require
    (''redis'')`, which provides the client and `redisStore` from socket.io, which
    provides redis backed for socket.io. Then we create three different Redis clients
    to use for pub-sub and the data store:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先执行的是 `require('redis')`，它提供了客户端和 socket.io 的 `redisStore`，后者为
    socket.io 提供了 Redis 支持。然后我们创建了三个不同的 Redis 客户端，用于 pub-sub 和数据存储：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous code snippet, we configure socket.io to use Redis for the queue
    and data store. And we are ready to go! Now run the application again using the
    following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们配置了 socket.io 使用 Redis 作为队列和数据存储。现在我们可以开始了！现在使用以下命令再次运行应用程序：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tips for node in production
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产中 node 的技巧
- en: 'Here are some tips to help us execute node in production:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些帮助我们执行 node 在生产中的技巧：
- en: Run the server in the `production` environment.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `生产` 环境中运行服务器。
- en: Never expose the node application directly on the Internet; always use a proxy.
    Servers such as Apache HTTP, Nginx, and HAProxy have been hardened and made robust
    over the years in production to make them secure against various kinds of attacks,
    especially DOS and DDOS. Node is new; it may become stable over time but today
    it is not recommended to be put directly on the front.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远不要直接将 node 应用程序暴露在互联网上；总是使用代理。例如 Apache HTTP、Nginx 和 HAProxy 这样的服务器在多年的生产中已经得到了加固和增强，以使其能够抵御各种类型的攻击，特别是
    DOS 和 DDOS。Node 是新的；它可能随着时间的推移而变得稳定，但今天不建议将其直接放在前端。
- en: Never run node as root. Well, that is the advice for any application server,
    and it applies to node too. If we run node as root, there are chances of hackers
    gaining root access or running some harmful code as root. So, never ever run it
    as root!
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远不要以 root 身份运行 node。嗯，这是对任何应用服务器的建议，也适用于 node。如果我们以 root 身份运行 node，黑客可能会获得
    root 访问权限或以 root 身份运行一些有害的代码。所以，永远不要以 root 身份运行它！
- en: Always run more than one node process. Node is a single-threaded, single-process
    application server. An error in the application can bring the server down. So,
    always have more than one process for reliability. Also, thinking in terms of
    1+ processes keeps us ready for scaling out when the need comes.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是运行多个节点进程。Node 是一个单线程、单进程的应用服务器。应用中的错误可能会导致服务器崩溃。因此，为了可靠性，总是要有多个进程。此外，以 1+
    进程的方式思考，使我们能够在需要时扩展。
- en: Always use a monitor. Monit, Forever, Upstart pick one you like, but always
    use it. Better safe than sorry.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是使用监控工具。Monit、Forever、Upstart 选择你喜欢的，但总是使用它。安全比抱歉更好。
- en: Never use `MemoryStore` in `production`; `MemoryStore` is for the `development`
    environment; I recommend using `RedisStore` even in `development`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远不要在 `生产` 环境中使用 `MemoryStore`；`MemoryStore` 是为 `开发` 环境准备的；我建议即使在 `开发` 环境中也使用
    `RedisStore`。
- en: Log all errors. Everything runs fine until it doesn't! And when something goes
    wrong, logs are your best friend. Try to catch exceptions as close to the cause
    as possible and log all the relevant information in the context. Don't just log
    some error message, log all the relevant objects.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录所有错误。一切运行顺利，直到它不顺利！当出现问题的时候，日志是你的最佳朋友。尽量在尽可能接近原因的地方捕获异常，并在上下文中记录所有相关信息。不要只记录一些错误消息，要记录所有相关的对象。
- en: Never block unless there is no alternative. Node runs on an event loop, and
    blocking for one request will cause unwanted overheads and degrade performance
    for all requests.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非没有其他选择，否则永远不要阻塞。Node 运行在事件循环上，对单个请求的阻塞将导致不必要的开销，并降低所有请求的性能。
- en: Always keep your server, node, and all dependency modules up-to-date.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是保持你的服务器、node 和所有依赖模块的最新状态。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we saw the work involved in putting our application to production.
    We must remember that these are not the only ways to do it. For every task we
    did, there are many other ways of doing them, and there is no one solution that
    fits all scenarios. But now that we know what is expected out of a `production`
    environment, we can research the options and choose one according to our requirements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了将我们的应用程序部署到生产环境所涉及的工作。我们必须记住，这些并不是唯一的方法。对于我们所做的每一项任务，都有许多其他的方法可以完成，没有一种解决方案适合所有场景。但既然我们已经知道了
    `生产` 环境的期望，我们就可以研究选项，并根据我们的需求选择一个。
