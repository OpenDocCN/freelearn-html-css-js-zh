- en: Applying Advanced Service Worker Cache Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to take our progressive web app capabilities up a notch. So far, you
    have learned how to add to the home screen experience, core service worker concepts,
    and how to make your site secure. In this chapter, we will dive into advanced
    service worker concepts and a brand new progressive web app, PWA tickets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is PWA tickets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run a local, mock API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PWA application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing utility libraries to a service worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service worker response manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced caching strategies and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching invalidation techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is PWA tickets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PWA tickets application is an example hosted service application designed
    to resemble an online ticket purchasing solution. While there are many aspects
    of this application I could have focused on, this book focuses on the consumer
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the PWA ticket home page, which displays a list
    of cards for upcoming events that the customer can purchase tickets for. Card
    refers to the UI metaphor that is used to style the block representing items in
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A real ticket service application would be a suite of apps including an administrative
    application and an app for ushers to validate tickets. For this book, I will focus
    on the consumer client experience.
  prefs: []
  type: TYPE_NORMAL
- en: The consumer version of the application features user login, profile management,
    access to a list of future events, the ability to buy tickets, and the user's
    ticket purchase history.
  prefs: []
  type: TYPE_NORMAL
- en: The application itself consists of a live API and static web pages, but the
    real area of focus for this chapter is some of the advanced service worker concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker evaluates each `fetch` request and processes it differently.
    The service worker pre-caches critical assets, but also defines custom rules for
    different routes.
  prefs: []
  type: TYPE_NORMAL
- en: Another new advanced concept is the idea of cache invalidation. This is where
    you define a rule that applies to cached responses and determines if a network
    request should be made and the cache invalidated. This is an important concept
    to understand because it gives you full control over your applications, caching
    rules and allows you to manage how much is stored in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PWA tickets application will demonstrate some new concepts and tactics,
    which will help you create professional progressive web apps, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Service worker templating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache invalidation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering different cache strategies based on a requested URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `importScripts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the PWA ticket application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take look at the different sections that our application will consist
    of. There are eight main page areas of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tickets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tickets and events both consist of two pages: one for a list and another for
    an item detail. The application also features our first pages, which make POST
    requests to an API rather than just a GET request. This introduces a new `fetch`
    method that our service worker must handle correctly'
  prefs: []
  type: TYPE_NORMAL
- en: The homepage lists 10 future events, followed by a list of user purchased tickets.
    Each item utilizes a card, which is styled using the bootstrap card classes. Each
    ticket card also has a button to show the item's details.
  prefs: []
  type: TYPE_NORMAL
- en: The user profile page list the user's contact information and some of their
    most recently purchased tickets. It also features a button to update the user
    profile. This will toggle the view from read-only to edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application''s navigation consists of Events, Tickets, Profile, Logout,
    and a Search field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A user can enter a search term and whatever page they are on will automatically
    update to show any matching events without making a round trip to load a new page.
    It does this by making an AJAX call and rendering the results in the browser and
    service worker.
  prefs: []
  type: TYPE_NORMAL
- en: The application's API is not representative of a production quality search feature,
    but serves our purpose. It will match any event that contains the phrase entered
    in the search box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The events page will list all future events that are available in the system.
    Again, each event is a card with a button to view the event''s details. The event''s
    details page shows a little more information and includes a list of tickets that
    are available to purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A true ticket service app would offer a more sophisticated way to find tickets,
    but I wanted to keep this simple for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: When a user buys a ticket, they must confirm the purchase and then it is added
    to their profile
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting the tickets link in the Now bar takes the user to a list of their
    purchased tickets. From here, they can view the details of any ticket, which includes
    a QR code. The QR code is meant to simulate what modern E-ticket solutions use
    for ushers and gate agents to scan when you enter a venue or when you need to
    find your seat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is where the usher's app would come into play. They could use their phone
    to scan the QR code to confirm the ticket and allow the customer into the venue.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a contact page where a user could submit a message to the system
    administrators. It is mostly used to demonstrate how to handle post messages using
    fetch and the service worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the entire application requires a user to be authenticated. Each page
    does a quick verification if the user is logged in, and if not, loads the login
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The user logs in by entering a username and password. The credentials are sent
    to the API for verification. The API returns the user's profile, which simulates
    an authentication token. The authentication token is persisted and `IndexedDB`
    (using `localForage`), and verified before each page load.
  prefs: []
  type: TYPE_NORMAL
- en: The user does not yet have a profile they can select. They can use the create
    new profile link and add themselves to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function is the application''s API call to log a user into the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the username and password are passed to the API using the `queryString`.
    I would not do this normally, but I needed a way to work with json-server and
    it did not seem to offer a way to match without a custom function using a POST.
  prefs: []
  type: TYPE_NORMAL
- en: You would not want to do this in production because it exposes credentials.
    When posting the credentials as part of the request body, they are shielded behind
    HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket application includes a minimal feature set, which I feel will
    help demonstrate the concepts covered in the last three chapters. This introduction
    to how the application works does not quite cover everything. I invite you to
    clone the source code ([https://github.com/docluv/pwa-ticket](https://github.com/docluv/pwa-ticket))
    and run it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JSON server for an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you build modern applications, the frontend almost always communicates
    with an API to interact with a date source. The API is the gateway to the backend
    application and can be consumed by any client application, such as a Progressive
    Web App.
  prefs: []
  type: TYPE_NORMAL
- en: Developing against an API can be rather tricky when you don't want to develop
    the entire API first. In the podcast application, we simply loaded a pre-rendered
    JSON to simulate an API. The podcast application only made a GET request and did
    not do any post requests or attempts to update the underlying data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PWA ticket application does make post requests and attempts to update the
    underlying data model, but rather than building out an entire infrastructure for
    this, I found a nice solution: json-server ([https://github.com/typicode/json-server](https://github.com/typicode/json-server)).
    This is a node module that works much like the http-server we used for the previous
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The real advantage of json-server is its built-in ability to create a fully
    functioning API based on a JSON data model. You must install the module like any
    other node module: by using `npm install` and including a reference to it in your
    `packages.json` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you execute the server, you must create a data source. This is just another
    JSON file. Rather than manually creating the data and the data model, I chose
    to write a script that uses the faker module ([https://github.com/marak/Faker.js/](https://github.com/marak/Faker.js/)).
    This can also be installed using the standard NPM tasks.
  prefs: []
  type: TYPE_NORMAL
- en: faker is a pretty cool node module that allows you to dynamically generate massive
    amounts of fake data for you to build your application around. This is one of
    the more troubling aspects of front and web development in my opinion, because
    you need large amounts of data to validate your application logic. However, that
    takes a long time to create. Faker eliminates this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Combining json-server and faker together allows you to create a very complex
    and deep API and data source. You can emulate just about every aspect of your
    potential API and backend with these two modules.
  prefs: []
  type: TYPE_NORMAL
- en: As I created the PWA ticket application, I modified the data model numerous
    times trying to get things just right. Rather than hand coding all of the data,
    I was able to write a script to rebuild the database from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project source repository includes a top-level folder called `utils`. In
    this folder, there are a couple of scripts: one to generate fake data and another
    to render the pages. The fake data script utilizes a combination of faker and
    some fixed data sources.'
  prefs: []
  type: TYPE_NORMAL
- en: Faker has the capability to generate data of all kinds, including images. However,
    I found the images that it generates and uses to be a slow, random image generation
    service. Rather than rely on those images, I chose to fix a small set of 8 venue
    images and 8 headshot images. The 16 images are stored under the website's `img`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice a method to generate QR codes. This is also done with
    a pair of node modules: one to generate a QR code image and another to save that
    image to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: A QR code is generated for each ticket and represents the ticket's unique identifier.
    Each barcode image that is generated is saved to the website in the barcodes folder.
    Each barcode image is a `.gif` file and has the extension appended to its name.
  prefs: []
  type: TYPE_NORMAL
- en: While these node modules are critical to running the PWA ticket application,
    they are not directly related to service workers and progressive web apps. I do
    want to take a little time to explain how they work so that you can use the source
    code locally.
  prefs: []
  type: TYPE_NORMAL
- en: Making a database and the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JSON server allows you to host a local REST API by supporting basic CRUD
    operations without writing any code. The node module works by reading a source
    file with a complete JSON object. The PWA ticket app relies on a JSON data structure,
    which is outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can configure the data source to include methods to return data based on
    supplied parameters. I chose not to do this in order to keep things simple. Hence,
    this explains the use of both the `futureEvents` and `pastEvents` arrays instead
    of creating these lists on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute `json-server`, run the command-line utility with the `--watch` switch.
    The watch switch causes `json-server` to update when the source data file updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The PWA ticket source code has the `db.json` data source file in the root folder.
    The server creates RESTful end points that map to the names of the top-level objects.
    It also doubles as a static file server. You just need to watch out for overlapping
    paths between the objects in the data file and pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'I ran into a scenario where I duplicated routes in the same site using `json-server`
    while creating this demonstration application. This forced me to run two instances
    of the web server: one for the API and one for the website.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For localhost-based servers, you can specify different port numbers to run
    multiple local servers. You can define the port number by adding the `-port` switch
    to the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I ran into some frustration trying to launch a static web server-only instance,
    so I chose to launch the API using `json-server` and the static website using
    `http-server`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run both local web servers from a command line, one console instance
    each, since they are running a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Another advantage of running the API server on a different port is that it helps
    emulate cross-domain access, or CORS.
  prefs: []
  type: TYPE_NORMAL
- en: CORS stands for **cross origin resource sharing** and was created to allow browsers
    to more securely request resources on external domains. It relies on the browser
    using extra headers to manage access to the external resource, typically via AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: CORS-specific headers are added by the server to tell the browser which domains
    are allowed to access the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the data, you can load a URI that corresponds to the API server
    and the name of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example URL returns an array of user objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are more advanced features available with json-server, but this should
    be enough for you to understand how to run the site locally.
  prefs: []
  type: TYPE_NORMAL
- en: Using faker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can host the API using json-server, you need the source data file.
    This is where the faker module is helpful. Creating enough data for a realistic
    test environment has always been one of my top challenges. Today, it seems like
    there are libraries or tools like faker available for most platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I use Node.js for the majority of my projects, faker stands out as a
    powerful tool. It just requires a script to generate the data. This script is
    in the `/utils` folder, `generate-fake-data.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This script helped me not only generate the file data set, but also allowed
    me to continually modify the source data as the overall model evolved.
  prefs: []
  type: TYPE_NORMAL
- en: This script generates a random number of users, events, and tickets, and maps
    them randomly together to create a complete database.
  prefs: []
  type: TYPE_NORMAL
- en: 'I won''t go into all of the details of possible data types available from `faker`.
    This is how the script generates a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `faker` object has different top-level data types with various methods to
    generate properly formatted, random data.
  prefs: []
  type: TYPE_NORMAL
- en: The data values generated by faker are in the correct or expected format. I
    love some of the text values it generates. I encourage you to read through some
    of them because they create some rather humorous values and combinations! For
    example, *Generic Plastic Cheese*.
  prefs: []
  type: TYPE_NORMAL
- en: The script is self-contained and will create a fresh database each time it runs.
    Plus, when you launch json-server using the `-watch` switch, the API will automatically
    update for the new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next aspect of the database remains: QR codes!'
  prefs: []
  type: TYPE_NORMAL
- en: Generating QR codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern ticketing solutions are more about barcodes and QR codes than the physical
    ticket. To create a life-like ticket application, I needed to create custom QR
    codes for each ticket. Again, a pair of node modules made this very straightforward:
    `qr-encode` ([http://cryptocoinjs.com/modules/misc/qr-encode/](http://cryptocoinjs.com/modules/misc/qr-encode/))
    and `ba64`([https://www.npmjs.com/package/ba64](https://www.npmjs.com/package/ba64)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'qr-encode converts strings into one of a variety of QR code options. The following
    code shows you how to use the `qr` method to generate `dataURI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `qr` method returns a `base64` encoded data buffer. You still need to convert
    this into a physical file. This is where `ba64` helps. It converts the `base64`
    encoded buffer into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `qrCodePath` points the local path to the `public/qrcodes` folder. The
    script will delete the existing QR image file and create the new QR codes as each
    ticket is generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The QR code encodes the ticket's unique identifier, which is a GUID generated
    by faker. This ensures that each ticket can be identified by scanning the QR code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the data is generated, and we have a way to serve both the API and
    website, we just need one more thing: the website.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 2048 and Podstr apps were based on static websites. While the Podstr app
    used some dynamically rendered pages, most of it was pre-rendered. It also had
    a script to create the HTML pages, but this was not as integral to the demonstration
    as the PWA ticket application.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket application has a script to render the core pages by combining
    an app shell and the individual pages markup for the actual page. This is handy
    because it allows you to update the app shell and the pages independently as well
    as customize the rendering script for different environments.
  prefs: []
  type: TYPE_NORMAL
- en: For example, before deploying to production, you will want to bundle and minify
    some style sheets and scripts. As you will see in the next chapter, you will also
    want to reduce the assets, such as styles using tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source markup files are in the site''s HTML folders, `/public/html` and
    `/public/html/pages`, respectively. The rendering script loops over these files
    and loads a corresponding data file defining page-specific configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The PWA ticket application has some simple configuration objects. The properties
    are used to define components in each page, like the route or folder to save the
    final rendered file to. These properties are used in the rendering pipeline to
    produce the final page based on a common template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is run from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The console will log each page as it is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket application is more advanced than the Podstr app because most
    of the pages are rendered on the client, not as a full static website. The reason
    the ticket application relies on client-side rendering is due to each page being
    tied to the user's profile and ticket purchase.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore these scenarios and how the service worker can enhance
    the overall experience.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket rendering architecture and logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced the concept of an app shell earlier in this book. As a quick recap,
    this is where the application uses a common markup file to manage the common `HEAD`
    and layout features. This shell is then combined with individual pages to compose
    each page.
  prefs: []
  type: TYPE_NORMAL
- en: The concept has a mass adoption due to the recent rise of single page applications.
    Progressive web apps can benefit from this concept, but do not need to rely on
    rendering the markup in the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the markup can be rendered in the service worker. The technique is
    similar: it uses `Mustache`, a JavaScript template library, to merge the data
    into the markup template. The rendered page markup is returned to the client.
    I will review the code for this later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique is the practical application of the final caching strategy, *Service
    Worker Templating*, which was discussed in the [Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d),
    *Service Worker Caching Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket JavaScript architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Podstr application, the PWA ticket app utilizes a combination
    of third-party libraries and application-specific JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the JavaScript files are organized in the
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The custom service worker logic or workflow utilizes different libraries to
    render content on the client. The two third-party libraries are `localForage`
    for `IndexedDB` interactions and `Mustache` to render markup.
  prefs: []
  type: TYPE_NORMAL
- en: '`localForage` ([https://localforage.github.io/localForage/](https://localforage.github.io/localForage/))
    is another `IndexedDB` wrapper. It provides a simple interface that mimics `localStorage`.
    The main difference is that `localForage` supports promises, making it asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: There are three `polyfils`, and these are `Object.assign`, `Promise`, and `Fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each page uses a few application-specific libraries: `api` and `push-mgr`,
    and common application modules. Each page has a page-specific script to drive
    the user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: The application module handles the common UI components, which are hamburger
    menu toggle, logout, search, and authentication validation. It also registers
    the service worker and manages the push notifications at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: Because the common user interface is simple, I combined these components in
    single script to keep things simpler to manage. Notice that there is no reference
    to jQuery or more complex frameworks to drive the UI. The entire app script is
    roughly 200 lines of nicely spaced code. Individual page scripts are much shorter,
    so there is not a lot of application-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `api.js` file is a module that contains methods to interact with the application''s
    API. Because the application is small, I placed all the methods in a single module.
    For a more complex application, you would want to refactor to separate modules
    to make the code easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method creates a global variable, `pwaTicketAPI`, which can be accessed
    by individual page controller modules to interact with the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each method wraps a fetch call to an API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the API methods make GET requests, but a few make POST requests to
    update or create new records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Each page controller uses an **Immediately Invoked Function Expression** (**IIFE**)
    to isolate the page logic from the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the pages follows a common pattern of retrieving data from the API
    and rendering markup to build the page. Most pages have a placeholder with a spinning
    disc. This is replaced when the markup is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The main app-shell has a main element with the `content-target` class. This
    class name is used as a reference to select the element and set the inner HTML
    with the dynamically rendered text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have noticed how I used `_d.qs()` to select the target element.
    This is a simple utility object that I created to eliminate the need to write
    `document.querySelector()` and the related selector methods. I don''t know about
    you, but I get tired of typing that out everywhere and it''s sort of long for
    the simplicity of jQuery''s selector syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This utility provides a simple shorthand to select elements, but without the
    overhead of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket service worker architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 2048 and Podstr apps have relied on a single script. The PWA ticket app
    uses more complex techniques like importing libraries to drive the logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service workers can load external scripts using the `importScripts` method.
    This function is available in the global scope and accepts an array of URLs. These
    are additional scripts and work much like the node.js `require` system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first two scripts are also used in the client code. `localForage` is an
    `IndexedDB` wrapper and the API script manages access to the API and authentication
    token. The `Mustache` library file is imported in the `ResponseManager` module
    and I will cover how it is used later.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining scripts are common service worker libraries to help with caching
    strategies, such as cache invalidation and push management. Each service worker
    library contains a JavaScript class with methods to manage an aspect of the cache
    strategy and life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Importing scripts is a great way to refactor your service worker logic into
    smaller units that can be reused and easier to maintain. I have reviewed several
    service workers that were over 10,000 lines of code. Any time you have a large
    code file, you tend to introduce unwanted maintenance issues.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem large code files create is navigating the code. Even with
    modern development environments and nice keyboard shortcuts, it is very easy to
    get lost in the code. If you have ever wasted time looking for functions and coordinating
    variables, you know what this is like.
  prefs: []
  type: TYPE_NORMAL
- en: Another common problem is managing team access to the code. When you have two
    or more developers with their hands in a single file, this introduces too many
    opportunities for code merges. Code merging is one of my least favorite developer
    activities, especially when someone else wrote the other version.
  prefs: []
  type: TYPE_NORMAL
- en: The last problem I see when large files are created is no code reuse. When you
    refactor your code into smaller modules, not only are they focused on a single
    responsibility, the classes, modules, and so on, can be reused in other areas
    of the application or across different applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is why I like importing scripts in service workers. The 2048 service worker
    was very simple and did not warrant this tactic. The Podstr app could use the
    `importScripts` capabilities, but I chose to save this till now. For a true production
    version of Podstr, I would have to refactor the code to import different scripts.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of importing scripts to your service worker is regarding updating
    the scripts. They are not updated when the service worker is updated. Unfortunately,
    I am still not clear on when these files will update from the server. I have read
    references saying that the imported scripts should following normal browser cache
    or cache-control invalidation, and others claimed that this is not working as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: There are some open discussions about this problem in the specification chats,
    but at this point, I think a true solution has not been adopted.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, during development, this issue can be very frustrating. You need
    to update these files frequently as you update the code. The best way I have found
    to force these files to update is to manually unregister the service worker.
  prefs: []
  type: TYPE_NORMAL
- en: After unregistering the service worker, reloading the page registers the service
    worker again and it will execute the `importScripts` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one *bug* with this technique that I am currently seeing in the Chrome
    developer tools, and this is that each unregistered service worker leaves its
    footprint in the tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.gif)'
  prefs: []
  type: TYPE_IMG
- en: You can close the tools to reset the service worker panel. If you can tolerate
    scrolling down to the current, active service worker, you can avoid this step.
    I think this is just an issue with the developer tools UI not properly refreshing
    when a service worker is unregistered manually.
  prefs: []
  type: TYPE_NORMAL
- en: '`importScripts` can also be used in any script that is imported by the service
    worker. In fact, the service worker''s global scope is available to these scripts.
    Any variable declared in the service worker''s global scope is available in the
    scripts. This also refers to any objects exported from the other imported scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: The node request system is similar to the `importScript` method. They both load
    external scripts to create methods and objects you can use in your script, which
    in this case is the service worker.
  prefs: []
  type: TYPE_NORMAL
- en: The ResponseManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ResponseManager` contains common logic that correlates to some of the
    caching strategies covered in [Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d),
    *Service Worker Caching Patterns*. The `ResponseManager` class contains a condensed
    set of cache strategies and the corresponding methods for five caching strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Cache only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache falling back to network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache falling back to network and caching response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache falling back to network, render result, and cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the `ResponseManager` class definition with method signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cacheOnly` and `networkOnly` method do exactly what their name implies,
    returning a response either from just the cache or just the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`cacheFallingBackToNetwork` checks if a response has been cached and if not,
    makes a network request to fetch the response. The response is not cached.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cacheFallingBackToNetworkCache` repeats that logic, but caches the network
    response.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two additional helper methods, which are `fetchText` and `fetchJson`.
    These two methods specifically help the render result strategy to retrieve HTML
    templates and fetch JSON from the API.
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchText` is used to retrieve HTML files. `fetchJSON` makes an API call to
    get data. The `fetchAndRenderCache` method utilizes a supplied option parameter
    to execute the API call.'
  prefs: []
  type: TYPE_NORMAL
- en: I covered the core concepts around these caching strategies in previous chapters.
    However, I do want to review the `fetchAndRenderCache` strategy because it was
    not covered in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this strategy is to dynamically render a response in the service
    worker and cache the rendered result for the next request. This works great in
    applications like the PWA ticket app, which are highly dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: While you could pre-render all the HTML pages on the server for any app, it
    may not be as efficient or cost-effective as rendering on demand. In the past,
    we have relied on run-time rendering systems such as ASP.NET, PHP, and so on,
    on the server and large single page app frameworks on the client.
  prefs: []
  type: TYPE_NORMAL
- en: It does not matter how you render the markup; the process is always the same.
    You merge data with a markup template. The engine you are using utilizes some
    sort of merge field syntax and replaces those fields with the matching values
    in the source data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer to use `Mustache` ([http://mustache.github.io/](http://mustache.github.io/))
    because the syntax is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`Mustache` gets its name from the use of two curly braces to denote the merge
    field. The render method will merge a JSON object''s properties with the matching
    field name. It can do single records or create a repeated list using the same
    template. It also supports basic `if...else` logic and a few other features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PWA ticket application uses `Mustache` templates for most pages, both for
    single records and lists. The application templates are stored in the `/templates`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaScript `Mustache` library can be used on the client or as a node module.
    I use it on both the server and client in many applications. It's great because
    you can make a single template and use it anywhere in the application and not
    worry about the rendering library being different.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following any of the mainstream JavaScript frameworks, they all have
    mature server-side rendering components. I think this is an important trend because
    these frameworks have caused a lot of performance issues and made many sites impossible
    to index in search engines.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of these server-side components should give these frameworks a longer
    lifespan and help them to produce better quality user experiences by moving their
    heavy logic to the server. This is also good since so many developers have invested
    many hours learning their proprietary syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchAndRenderResponseCache` method executes service worker level run-time
    rendering. It accepts an options parameter that contains different properties
    which are required to drive the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend pairing this method with a call to cache to see if the response
    is available. The `ResponseManager` has a `cacheOnly` method you can utilize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The method uses a JavaScript object as its only parameter. It should have the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These values are used to drive the logic and make it flexible enough to be
    reused by different pages and components in any application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first step in the sequence is to retrieve the page's HTML. This is done
    by passing the `pageURL` value to the `fetchText` method. This should resolve
    the page's core HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the template is fetched using the same method. This time, the resolved
    template HTML is injected in the `pageHTML`. It does this be replacing a custom
    token, `/<%template%>/g`, in the HTML page. Again, this is to make the page template
    more flexible. You could prerender the entire page with the template included.
  prefs: []
  type: TYPE_NORMAL
- en: I do this because I want the application to be able to fallback to using classic
    client-side rendering if service workers are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have the page''s full HTML, short of rendering with
    the data. The following step retrieves the data from the API using the supplied
    method. This method should return a promise, which means you can just return the
    fetch you use to call the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The API method should resolve the response to JSON. The data is then rendered
    with the `pageTemplate` using the `Mustache.render` method. This creates the final
    HTML we want!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for some cool magic. The logic creates a new `Response` object and clones
    it. The clone is saved to the named cache and the new response is returned so
    that it can be rendered for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This may seem like a lot of work, but it can be done pretty quickly assuming
    that the call to the API is fast. I do recommend pre-caching the page and the
    data template markup ahead of time. The pre-cache is a good place to do this.
  prefs: []
  type: TYPE_NORMAL
- en: You might also consider caching these responses in a special template cache
    so that you can apply appropriate invalidation rules to ensure that they do not
    become too stale.
  prefs: []
  type: TYPE_NORMAL
- en: Using the request method to determine the caching strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the magical aspects of HTTP is its use of different properties to trigger
    actions. The HTTP method provides a descriptive way to trigger a response. There
    are a variety of possible HTTP methods, with PUT, GET, POST, and DELETE being
    the most common methods.
  prefs: []
  type: TYPE_NORMAL
- en: Those methods correspond to **create**, **retrieve**, **update**, and **delete**
    (**CRUD**) actions. Cache is a powerful tool to make your application respond
    faster, but not all responses should be cached. The HTTP method can be a primary
    signal to trigger an appropriate caching strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The first two applications, 2048 and Podstr, use only GET requests. The PWA
    ticket application utilizes POST methods, which should not be cached. When a user
    registers, *buys* a ticket, updates their profile, or submits a contact request,
    a POST request is made to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API response is typically used to determine success or some sort of failure
    state. These responses should not be cached. If they were, your request might
    not be sent to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Matching routes with caching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing different caching strategies involves some way of triggering specific
    strategies for different response types or routes. The more complex your application
    is, the more potential routes and media types you may need to manage.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done by defining an array of rules driven by URL routes. I recommend
    using regular expressions to match routes, especially when the route has a common
    base with a large variety options. A good example would be an e-commerce site's
    product details page. This could be a URL to a pre-rendered page or might involve
    a `QueryString` value.
  prefs: []
  type: TYPE_NORMAL
- en: For the PWA tickets application, I am demonstrating how to define a dynamic
    route for event details using a regular expression and another for the QR code
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'A QR code request triggers the cache falling back to the network and then cache
    the response pattern. An event request triggers the service worker rendering strategy.
    This involves an extra property with values to drive the strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having a complex fetch event handler, you should refactor the logic
    to a separate method. Pass the event object to your handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The magic happens by testing the requested URL against the array of rules.
    This is done by testing the URL against each one of the rules `url` values. This
    testing is done using JavaScript''s regular expression `test()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns the matching rule object. If no matching rule has been
    defined, you can coalesce the rule value to an empty object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After identifying a matching rule, the strategy can be executed using a JavaScript
    switch statement. The `responseManager` has the logic for each strategy. Make
    sure you pass the `request` object and the target `cacheName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'I like to make the cache falling back to the network caching the response my
    default strategy. By stacking this strategy in the case expression, the code only
    needs to be included once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This approach relies on configuring routes and their corresponding caching strategy.
    This is similar to the WorkBox approach. I will explore Workbox, a node module
    to help you scaffold complex service workers, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cache invalidation strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like there are caching strategies, there are cache invalidation strategies
    you can employ to keep your cache from getting out of control. The PWA tickets
    application uses a maximum items strategy to control how many responses are cached,
    but there are other strategies you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Unique hash names and long time-to-live values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular technique to make updating assets easier with long time to live values
    is using hash values in the file name. This is because a hash which is generated
    based on the file's contents means that the algorithm generates a relatively unique
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The unique name creates a new URL for the asset and assigns a new Cache-Control
    value to the asset. This works well with style sheets, scripts and images, and
    other static resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'MD5 hash values are the most common way to create these unique values. Node.js
    has a built-in `crypto` module with MD5 hash capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The data parameter is the contents of the file. For a style sheet or script,
    it is the data is the text in the file. The digest is a unique value you can use
    to name the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.gif)'
  prefs: []
  type: TYPE_IMG
- en: This technique works great, but requires a somewhat complicated build process
    to update file names in all the referencing files. I don't encourage this technique
    for a local development environment, but for production, this is a very powerful
    cache busting technique. Just keep in mind that you need to update references
    in all HTML files and potentially in your service worker or other files that may
    reference these unique file names.
  prefs: []
  type: TYPE_NORMAL
- en: I think this might be a bit complex for many sites, especially without a formal
    system underlying the site that supports this technique. It's best if the hash
    technique is transparent to the developer and more or less automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is not common today. There are other techniques you can
    utilize that provide more granular control and possibly more control over how
    much data you cache. The following techniques can be used in your service worker
    to manage how long responses are cached.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum items in a cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simpler cache invalidation strategy is limiting the number of items persisted.
    I call this **Maximum Item Invalidation**.
  prefs: []
  type: TYPE_NORMAL
- en: This requires service worker logic to check how many items are saved in a specifically
    named cache. If the cache has saved the maximum number of responses, at least
    one response is removed before adding a new item.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy requires multiple named caches, which correlate to different types
    of responses. Each named cache can have a different item limit assigned to manage
    the different types of responses. You can also assign a difference cache invalidation
    strategy, which will be discussed shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The ticket application has named caches for events, which are dynamically rendered
    as they are requested. I arbitrarily chose a limit of 20 events to make it easier
    to demonstrate the strategy. It also has a QR code named cache with a limit of
    five responses, again, somewhat arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to choose an appropriate value for your application and types
    of responses. Remember, your storage quota is a combination all the different
    storage mediums and varies by device and capacities.
  prefs: []
  type: TYPE_NORMAL
- en: I typically use more liberal values for text responses and smaller values for
    binary files like images. Until you know how your site is used by your customers,
    you may need to adjust this value.
  prefs: []
  type: TYPE_NORMAL
- en: If you managed a site like Amazon.com, you would have access to data that tells
    you how many products a user visits in an average session. So, maybe you make
    sure you can cache that many product pages and associated images. I would probably
    cache most of their watch list products and everything in their shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every site and application is different, and within those sites there are unique
    page and data types that need a varied cache limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Just like there is not a magic number of total items you should cap a named
    cache capacity, not all caches should be limited by a maximum number of items.
    You should also consider limiting based on time.
  prefs: []
  type: TYPE_NORMAL
- en: Purging stale responses using time to live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next cache invalidation strategy is based on how long a response can be
    cached. If you don't have access to the Cache-Control header, it may be challenging
    to determine how long to cache the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that the Cache-Control header is not the only way to determine
    a response''s cache lifespan. When responses are added to a named cache, a `"date"`
    value is added. You can use the cached date value to apply a timeout rule to the
    cached responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When a cached response becomes stale, you can delete it. The next time the asset
    is requested, the default caching strategy triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Executing ResponseManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of writing a complex routine to fetch and cache a response directly
    in the service worker''s `fetch` event handler, you can use the `ResponseManager`.
    Because the caching strategy logic is contained within the module, you can pass
    the request and `cacheName` to have it execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the response is returned as a result of the promise chain.
    It also executes the cache's `InvalidatationManager.cacheCleanUp` method to make
    sure that the cache does not contain too many items or stale items.
  prefs: []
  type: TYPE_NORMAL
- en: The Invalidation Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Invalidation Manager is a special module that handles implementing the
    maximum items and time to live invalidation strategies. The script is imported
    to the service worker using the `importScripts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This module has a method called `cacheCleanup`, which loops over the set of
    invalidation rules that are supplied in the constructor, as shown earlier. As
    it loops through the rules, it executes each strategy against a named cache. The
    invalidation rules are defined when the class is instantiated by passing an array
    of rules.
  prefs: []
  type: TYPE_NORMAL
- en: The class can process two invalidation strategies, which are `maxItems` and
    `ttl` (time to live). Each item in the rules array is an object defining the named
    cache, the strategy to apply to the cache, and the options for the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The `ttl` `strategyOptions` is the maximum time frame a cached item can remain
    cached. In the preceding example, the `preCached` items can remain for a week
    before they will be purged. Once they are purged, a network request is made, which
    updates the asset.
  prefs: []
  type: TYPE_NORMAL
- en: The `maxItems` `strategyOptions` has a `max` property, which defines the maximum
    number of cached items a named cache can persist. In this example, I chose an
    arbitrarily low number of 10 items to help demonstrate the principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strategyOptions` property is an object, even though right now there are
    only single properties for each strategy. By using an object, it allows additional
    properties to be added later and for potential future strategies to have different
    property options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `cacheCleanUp` method can be invoked at any time. It is always executed
    when a new `InvalidationManger` is created, or when your service worker first
    wakes up.
  prefs: []
  type: TYPE_NORMAL
- en: This may not be good enough for your application. You could periodically execute
    this method based on a timer or after items are cached.
  prefs: []
  type: TYPE_NORMAL
- en: maxItems strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `maxItems` strategy limits how many items can be stored in a named cache.
    It works by opening the named cache, and then retrieving an array of requests
    using the keys method.
  prefs: []
  type: TYPE_NORMAL
- en: The routine then compares the number of stored items (`keys.length`) to the
    maximum number of items allowed in this cache. If there are more items than the
    quota, the number of items exceeding the quota is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop is then executed to delete the first item from the cache and repeats
    until the number of items to purge have been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why you could not use the Array `pop` or `slice` methods
    to remove the cache items. This is because caches do not provide an array interface,
    and thus there are no native array methods.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you must create a loop or custom routine to individually delete cached
    items.
  prefs: []
  type: TYPE_NORMAL
- en: The time-to-live invalidation strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the `maxItems` strategy, the `updateStaleEntries` strategy opens a reference
    to the named cache and gets a list of the cached requests. This time, individual
    requests must be retrieved from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requires calling the cache''s match method by passing a request object
    (key). This will return the stored response with a `date` header. This is added
    when the item is added to the cache and can be used to determine if the response
    is stale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: After retrieving the cached date, the `DateManager` can be used to test if the
    response is stale or past its expiration time. If the item has expired, it is
    deleted from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Using a real-time asset manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more complex technique I have used to manage service worker caches is the
    manifest file. This technique involves maintaining a file with a JSON object with
    caching rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To leverage this technique, you would process the dynamic requests by testing
    their URL against the supplied routes. This can be done using a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is very similar to the way the routes and caching strategies were
    defined and triggered earlier. The request URL is tested against a regular expression
    to identify the caching strategy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The manifest file is dynamically loaded when the service worker is first instantiated.
    The way I manage when the manifest is updated is by persisting a series of values
    in `indexedDB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The reason I chose to control the manifest file's time to live manually is to
    avoid potential issues with the browser cache. It is important that you set the
    manifest's cache headers to not allow the resource to be cached by the browser
    or proxy servers.
  prefs: []
  type: TYPE_NORMAL
- en: I set the default time to live to 24 hours, just like the built-in service worker's
    time to live. This keeps the service worker from loading the manifest too often,
    but not so long that it could get out of sync from the server.
  prefs: []
  type: TYPE_NORMAL
- en: The ticket app does not use this technique, but I did include an example manifest
    file and some of the additional support modules you might need. I reserve this
    technique for more complex applications, and it does require some investment to
    maintain. Specifically, you would need a utility to keep the manifest file updated
    that I feel is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How much should you cache?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned earlier that you need to determine how your application's data should
    be cached. The type of data and how it will be used should be used as guidelines
    as to how it is managed in your service worker.
  prefs: []
  type: TYPE_NORMAL
- en: I want you to also consider your user. Not everyone has access to an unlimited
    high-speed connection or a large disk. Many smartphones still come with just 8
    GB of storage, which after the operating system and all the photos and videos
    consumers record, there is not much room left.
  prefs: []
  type: TYPE_NORMAL
- en: Just because you could cache your entire application, including images and data,
    does not mean you should. Nicholas Hoizey ([https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html](https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html))
    demonstrates that that tactic could have a negative impact on your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to consider adding an experience where the user can configure
    your application to control how resources are persisted. Just like we saw with
    push notification management, you might want to add the ability for the user to
    determine how many events or tickets (in the example application) are cached and
    how long ticket QR codes are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can still use the helper modules covered in this chapter. The caching and
    invalidation strategies wont change, just the settings they use to execute the
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a very long chapter with some advanced concepts being covered.
    You learned how to trigger different caching strategies based on the request URL,
    modularizing the service worker logic, and employing cache invalidation strategies.
    Plus, you got to play with a new progressive web app!
  prefs: []
  type: TYPE_NORMAL
- en: There was a lot of valuable information and source code covered in this chapter,
    but these examples should only serve as a base reference for your applications.
    Not only should you be a good steward of the storage your application is allocated,
    but you should be mindful of your users' data plans.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to review how to use service workers and
    caching to make applications perform better. You will also see how to use available
    tools to evaluate and diagnose performance issues so that you can make a better
    application.
  prefs: []
  type: TYPE_NORMAL
