<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Your First Alexa Skill</h1>
                </header>
            
            <article>
                
<p>This chapter will introduce you to the process required to build Alexa Skills, and together we will create our first Alexa Skill. We'll learn how to build and test our skill to make sure that everything is working.</p>
<p>We'll then create a second Alexa Skill that has a more realistic conversation with the user. This skill will go through a series of questions to gather a set of information, which we'll use to decide which car is best suited to the user. This will also cover accessing data from remote storage.</p>
<p>The last thing we will cover in this chapter is deploying your skill, allowing you to publish your skills for the world to use.</p>
<p>This chapter will cover the following:</p>
<ul>
<li>Creating our first Alexa Skill</li>
<li>Using Alexa SDK in a Lambda to handle the requests from Alexa</li>
<li>Testing your Lambda</li>
<li>Creating a more complex Alexa Skill that uses data stored on S3</li>
<li>Deploying your Alexa Skill</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will be creating a Lambda function for our skill and we'll be creating and deploying it using the local development setup that we created in the previous chapter.</p>
<p>All of the code used in this chapter is available at <a href="http://bit.ly/chatbot-ch3">http://bit.ly/chatbot-ch3</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Alexa Skills Kit</h1>
                </header>
            
            <article>
                
<p>To create our first Alexa Skill, we're going to use Alexa Skills Kit. Search for <span class="packt_screen">Alexa Skills Kit</span> or go to <a href="https://developer.amazon.com/alexa-skills-kit">www.developer.amazon.com/alexa-skills-kit</a> and you should see a screen with a <span class="packt_screen">Create Skil</span><span class="packt_screen">l</span> or <span class="packt_screen">Start a Skill</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/518da09d-b61e-447e-8d57-fc02cfd92b93.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Creating your first skill</div>
<p>Start by giving your skill a name. This should be something that describes what the skill does. For this, we can call it <kbd>Hi</kbd>. Click <span class="packt_screen">Next</span> and you'll be able to select a model for your skill. We want to choose <span class="packt_screen">Custom</span> so we can create the skill exactly how we want:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a00fc3f5-ffe4-4951-8463-f069c0f08d5a.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Creating a custom skill<br/></div>
<p>Click <span class="packt_screen">Create skill</span> and once the setup has finished, you'll end up on the Alexa Skill builder page. To get started, we need to click on <span class="packt_screen">Invocation</span><span class="packt_screen"> Name</span> in the left-hand menu. This is where we set up the command that starts our skill. I'm going to use <kbd>sams demo bot</kbd> for this first skill. When you create bigger skills, it is a good idea to spend some time thinking about what you use as your invocation phrase and practice saying it out loud:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fabd8c1a-b5db-43d7-8772-59ab22838ff0.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Skill invocation</div>
<p>Now that we can start our skill, we need to create an intent so that our skill does something. Click the <span class="packt_screen">Add</span> button, next to the intents in the left-hand menu, to create a new intent. Here, you have the option to <span class="packt_screen">Create custom intent</span> or to use an existing intent from Amazon's library. Most of Amazon's intents are to do with page navigation or music control, so we're going with a custom intent.</p>
<p>Give your intent a name that describes what the intent is going to do. In our case, it is to say <kbd>Hello</kbd>, so that is what it can be called. Click <span class="packt_screen">Create custom intent</span> to start editing the intent.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now that we're in the intent window for our <kbd>Hello</kbd> intent, we need to add some utterances. As we talked about in <a href="90c77e09-3c38-4162-bd4e-6935a897df50.xhtml" target="_blank">Chapter 1</a>, <em>Understanding Chatbots</em>, these are phrases the user might say to trigger this intent. For this intent, those utterances might be <kbd>hi</kbd>, <kbd>hello</kbd>, or <kbd>hey</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4784caae-8dd3-4f92-a7fd-78ba2f89bc07.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Hello utterances</div>
<p>We have completed our first Alexa intent, so we need to save and build this model. At the top of the intents window is a <span class="packt_screen">Save Model</span> button and a <span class="packt_screen">Build Model</span> button, so save it and then build it. Building the model sometimes takes a while, so just wait for that to finish.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Lambda to handle the request</h1>
                </header>
            
            <article>
                
<p>To handle the intents inside our new Alexa Skill, we need to create a Lambda function. This will contain all of the logic we need to understand the intent and send a reply to the user.</p>
<p>To create a Lambda, we can use any of the methods described in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>, but we're going to be using our local development setup. Navigate to your base Lambda folder and create a new folder called <kbd>hello-alexa-skill</kbd>. Inside that folder, we need to create a new <kbd>index.js</kbd> file and open it to create our function.</p>
<p>To start, we need to <kbd>require</kbd> in the <kbd>alexa-sdk</kbd>, which makes creating the logic for Alexa a lot easier:</p>
<pre>const Alexa = require('alexa-sdk');</pre>
<p>Because we are requiring it, we also need to make sure that we have it installed. In the command-line interface, navigate into your <kbd>hello-alexa-skill</kbd> folder and run the <kbd>npm init</kbd> command. This process creates a package information and allows you to install other packages in the folder. You can set the values as you go through the setup or use the defaults by hitting <em>Enter</em>. Once you've finished the setup, you'll have a file called <kbd>package.json</kbd>, which contains the configuration for this folder.</p>
<p>To install a new package and add it to our <kbd>package.json</kbd> file, we can run the <kbd>npm install --save package-name</kbd> command. We want to install <kbd>ask-sdk</kbd>, so we need to run <kbd>npm install --save ask-sdk</kbd>. When this command runs, you'll see a new folder is created, called <kbd>node_modules</kbd>, which contains all of the code in the installed npm packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating handlers</h1>
                </header>
            
            <article>
                
<p>When our intents are triggered by a user saying one of our utterances, we need to handle that inside our code. To do this, we create an object containing a method for each of our intents. Currently, we only have one <kbd>hello</kbd> intent, so we only need to create one handler:</p>
<pre>const helloHandler = {<br/>    canHandle(handlerInput) {<br/>        return handlerInput.requestEnvelope.request.type === 'IntentRequest' &amp;&amp;<br/>            handlerInput.requestEnvelope.request.intent.name === 'hello';<br/>    },<br/>    handle(handlerInput) {<br/>        const speechText = `Hello from Sam's new intent!`;<br/><br/>        return handlerInput.responseBuilder<br/>            .speak(speechText)<br/>            .getResponse();<br/>    }<br/>};</pre>
<p>This <kbd>hello</kbd> handler has two parts: <kbd>canHandle</kbd> and <kbd>handle</kbd>. The <kbd>canHandle</kbd> function <span>decides</span> <span>whether this handler can deal with this request, returning true if it can and false if it can't. This is calculated using the request type and intent name. </span><span>If both match, then this is the correct handler. </span><kbd>handle</kbd><span> is telling Alexa how to respond. For this intent, all we want Alexa to do is to say <em>Hello from Sam's new intent! </em>and then get the user's next message.</span></p>
<p>Now we need to add our <kbd>helloHandler</kbd> to our skill.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can add multiple handlers by passing them as multiple parameters to the <kbd>.addRequestHandlers</kbd> method:</p>
<pre>exports.handler = Alexa.SkillBuilders.custom()<br/>    .addRequestHandlers(<br/>        helloHandler)<br/>    .lambda();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and configuring the Lambda</h1>
                </header>
            
            <article>
                
<p>Now that the function is completed, we can use the build script that we made in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>. Run the <kbd>./build.sh hello-alexa-skill</kbd> command to create our Lambda and deploy it to AWS.</p>
<p>When the build script finishes, navigate to your Lambda console in AWS and you should now see your newly created function. Click on this new <kbd>hello-alexa-skill</kbd> Lambda to open up the editor.</p>
<p>To allow this Lambda to be triggered by an Alexa Skill, we need to add <span class="packt_screen">Alexa Skills Kit</span> as a trigger. This is done by clicking on <span class="packt_screen">Alexa Skills Kit</span> in the designer under <span class="packt_screen">Add triggers</span>, creating an Alexa Skills Kit trigger appears in the main designer screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2967f443-696c-4964-a91d-dd913e5961eb.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding an Alexa Skills Kit trigger</div>
<div>
<p>This also opens the <span class="packt_screen">Alexa Skills Kit</span> configuration section. Here, we need to provide the Alexa App ID for our skill. To find this, open the Alexa Skill Kit console, go to<span> </span><span class="packt_screen">Endpoint</span><span>, </span>and choose Lambda. This will open up a few extra details and options. Our<span> <kbd>Skill ID</kbd></span><span> </span>is the first bit of information and can be copied to our clipboard and inserted into our Lambda configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d63f20f5-e6f6-432b-af7a-d6183df3e19c.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Skill endpoint configuration</div>
<p>Before exiting the Lambda editor, we should find the <span class="packt_screen">ARN</span> in the upper-right corner of the editor screen. Copy this as we'll need it for the last step in configuring the skill.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finishing skill configuration</h1>
                </header>
            
            <article>
                
<p>Now that we have the Lambda configured and the <span class="packt_screen">ARN</span> in our clipboard, we can go back to our Skill console. Under <span class="packt_screen">Endpoint</span>, we can insert our Lambda<span> </span><span class="packt_screen">ARN</span><span> </span>into the textbox next to <span class="packt_screen">Default Region</span>. This makes sure that the skill is triggering the correct Lambda. You can also create different Lambdas for different regions, allowing you to serve specific responses to different groups of people.</p>
<p>Click <strong><span class="packt_screen">Save Endpoints </span></strong>to save your skill and you have completed your first Alexa Skill. Now comes the fun part: trying out your skill!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing your skills</h1>
                </header>
            
            <article>
                
<p>Now that we've built and deployed our new Alexa Skill, we need to test it out and see whether it works. At the top of the page, there are four tabs: <span class="packt_screen">Build</span>, <span class="packt_screen">Test</span>, <span class="packt_screen">Launch</span>, and <span class="packt_screen">Measure</span>. We've finished with <span class="packt_screen">Build</span>, so we can click on <span class="packt_screen">Test</span>. Click the toggle at the top of the page to enable testing for this skill:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2fb7de44-b67b-46a0-b635-dce7630dc62e.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Test screen</div>
<p class="mce-root">To interact with your new skill, you can either type your messages or click and hold the microphone button and talk to your computer like you would with Alexa. To test your skill by talking to it, you will need a microphone on your laptop or PC, and have allowed the web page to access that microphone. As soon as you hit <em>Enter</em> or let go of the microphone button, you'll see Alexa loading and then she'll reply with your intent and add the message to the chat window. As well as the response from Alexa, you also get information in the <span class="packt_screen">Skill I/O</span> section of the screen. If the intent was successfully triggered, you'll get the full <span class="packt_screen">JSON Input</span> that is sent to your Lambda as well as the response that it has given:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/475161db-d78a-42f7-98ce-06ceaf7e6ced.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Working hello test</div>
<p class="mce-root">This is what you should get when you chat with your bot. Make sure that you are saying the correct utterances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Troubleshooting your skill</h1>
                </header>
            
            <article>
                
<p>Having a few bugs when you first make a skill or Lambda is very normal. The key is to learn how to find the bugs and fix them.</p>
<p>In the <em>Appendix</em> of this book is a helpful guide for finding the bugs in Lambdas. Follow those processes and you should have your skill working soon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a more useful skill</h1>
                </header>
            
            <article>
                
<p>Creating a skill that says <em>hello</em> when you say <em>hi</em> is great to see working but it's not very useful. The next skill that we're going to make is going to be a lot more useful.</p>
<p>We're going to create a skill that suggests a model of car to buy, and can provide the user with details about the cars that it suggests.</p>
<p>The data that we will use will contain three sizes of car, two price groups, and an extra category for small cars (number of doors) and for large cars (manual or automatic transmission).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conversational flow diagram</h1>
                </header>
            
            <article>
                
<p>To make sure that we make an effective chatbot, we need to create our conversational flow diagram. This starts with our perfect conversation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a439a5a1-0d18-463a-bad6-c7f2c5059a4f.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Car conversation</div>
<p>The user chose a large car, therefore, we had to ask them the price group as well as what type of transmission they want. This logic is going to become apparent in the conversation flow diagram. We can create similar conversations for users who choose medium or small cars, where all of the conversations would be slightly different. When there are different questions based on what the user has previously said, you can end up with hundreds of different conversations. This is where conversation flow diagrams really become useful.</p>
<p>In this conversation flow diagram, we have a very important <em>logic</em> component. It sees whether the user has chosen a small, medium, or large car, and directs the conversation based on that. This means that we can now show lots of different conversation options in one diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e7bc11a0-73ec-4798-b394-c936e0d4db01.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Car flow diagram</div>
<div>
<p>Toward the end of the flow, we also have a lookup to find the ideal car for the user. This is something completely new that we'll cover in detail later in this chapter.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Alexa Skill</h1>
                </header>
            
            <article>
                
<p>We start making this skill in the same way as before. Go into your Alexa Skills Kit developer console and choose <span class="packt_screen">Create Skill</span>. Choose a suitable name, such as <kbd>carHelper</kbd>, and select a <span class="packt_screen">Custom</span> skill.</p>
<p>Now that we're in the skill console again, we need to start at the top by setting the invocation utterance. Enter <kbd>Car Helper</kbd> or something similar that is memorable and easy to say.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Intent</h1>
                </header>
            
            <article>
                
<p>Now we can move on to the main part of the skill—adding the intent. For this, we add a new intent and we can call it <kbd>whichCar</kbd>, as we are trying to help the user choose <em>which car</em> to get.</p>
<p>The first thing this intent needs is utterances. Add in phrases that the user might say if they are wanting to find out which car to buy:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73d81841-a0bb-4439-8a0e-2e6e6d0ceb5a.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Intent utterances</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Internal Slots</h1>
                </header>
            
            <article>
                
<p>This is where we need to start making the skill more advanced than last time. We need to store information such as the size, cost, doors, and whether the user wants to have automatic or manual gears. To add a new slot, scroll down to <span class="packt_screen">Intent Slots</span> and click on <span class="packt_screen">Create a new slot</span>. In here, you can name your slot and then add that to your intent by pressing <em>Enter</em> or clicking the <span class="packt_screen">+</span> icon. Do this for <span class="packt_screen">size</span>, <span class="packt_screen">cost</span>, <span class="packt_screen">doors</span>, and <span class="packt_screen">gears</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8cd4848c-c09b-417a-9f18-b69bad7333d8.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Intent Slots</div>
<p>Before we can store any information in these slots, we need to set their <span class="packt_screen">SLOT TYPE</span>. The number of doors is simple as it is just a number, so <span class="packt_screen">AMAZON.NUMBER</span> can be chosen as its slot type. For the other three slots, it's a bit more complicated.</p>
<p>We need to create custom slot types for these three slots. To create a new slot type, click the + next to <span class="packt_screen">Slot Types</span>, which will take you to the <span class="packt_screen">Add Slot Type</span> screen. Enter the name for your new slot type and click <span class="packt_screen">Create custom slo</span><span class="packt_screen">t type</span>. We will start with a slot type called <kbd>carSize</kbd>.</p>
<p class="mce-root"/>
<p>Now you are in the slot type editing screen, and you'll see your new slot type in the menu on the left. We need to add the three values that the user can select: <kbd>large</kbd>, <kbd>medium</kbd>, and <kbd>small</kbd>. This would work as it is, but what if a user says <kbd>big</kbd> instead of <kbd>large</kbd>? We can capture these too using synonyms. We can enter as many new values as we want, and if a user says them, it will be registered as the main value:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3d32a1fc-047e-4723-bfe7-0927496aa35e.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Car size slot type</div>
<p>This process needs to be repeated to create a <kbd>carCost</kbd> slot type with values of <kbd>luxury</kbd> and <kbd>value</kbd><span class="packt_screen">,</span> and a <kbd>carGear</kbd> slot type with values of <kbd>automatic</kbd> and <kbd>manual</kbd>. You should also add synonyms for each of these values to improve the flexibility of your bot.</p>
<p>Now that we have created the three new slot types, we can add them to our slots. You should now find your new slot types in the slot type drop-down menu. Make sure each of the slots has the correct slot type, and we're almost finished with the skill editor.</p>
<p>We know that the user is always going to be asked for their choice in <kbd>size</kbd> and <kbd>cost</kbd>, so we can set these two slots to be required. Clicking on the slot name under the intent will take you to the slot config screen where we have the <span class="packt_screen">Slot Type</span>, <span class="packt_screen">Slot Filling</span>, and <span class="packt_screen">Slot Confirmation</span> sections.</p>
<p>In the <span class="packt_screen">Slot Filling</span> section, there is a toggle to change the slot to being required. When we click that toggle, it opens more settings for us to configure. The first is the <span class="packt_screen">Alexa speech prompts</span> where we can type a prompt that will get the user to fill in the slot correctly:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d9b3c20-3f91-42f8-93c4-102b02c9f3e6.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Required slot</div>
<p class="mce-root">We can also enter utterances that the user might reply with. The first one can simply be the size, so we need to type the slot name wrapped in curly braces. As well as just saying <kbd>large</kbd>, the user might say <kbd>I want a large car</kbd> or <kbd>I'm looking for a medium car</kbd>. To deal with these, we type those utterances but change large and medium for <span class="packt_screen">{size}</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48fdd45d-afa8-43dd-b228-0f64ef9b6e7d.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Slot utterances</div>
<p>Do the same process for <em>cost</em>, using utterances such as I want a <span class="packt_screen">{cost}</span> car. Add a few other utterances if you want to.</p>
<p>We don't need to do this for gears or doors as they aren't required in every conversation, but we'll be able to ask for them from our Lambda.</p>
<p>Once you have created the three custom slots and added the slot types to all of your slots, you should have intent slots that look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c154f782-24e0-445f-a3c6-d83fae5fc46f.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Slot types completed</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding the Skill ID</h1>
                </header>
            
            <article>
                
<p>The last thing to do is find and copy the Skill ID so we can use it in our Lambda. Select <span class="packt_screen">Endpoint</span> in the left-hand menu and choose <span class="packt_screen">AWS Lambda ARN</span> as the service endpoint method. This will expose the Skill ID that we need to copy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Lambda</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we have done the console setup, we can build the Lambda that will handle the logic behind the skill.</p>
<p><span>Start by creating a new folder in your <kbd>lambdas</kbd> folder, naming it something appropriate, such as</span> <kbd>carHelper</kbd>. <span>Inside, we need to create an</span> <kbd>index.js</kbd> <span>file and run</span> <span><kbd>npm init</kbd></span><span><span>.</span></span> <span>We are using <kbd>alexa-sdk</kbd> again so we need to run <kbd>npm install --save alexa-sdk</kbd>.</span></p>
<p>With the setup ready, we can start writing the Lambda. We can start with a Lambda that looks very similar to the Lambda we created in our first function:</p>
<pre>const Alexa = require('alexa-sdk');<br/> <br/>exports.handler = Alexa.SkillBuilders.custom()<br/>    .addRequestHandlers()<br/>    .lambda();</pre>
<p>The first handler we are going to create is to handle a launch request. This is when a user says something like <kbd>"Alexa start car helper"</kbd>; our skill is launched but no intent is triggered. We need to help them trigger one of our intents by telling them what to say to trigger our intent. We can then add this as our first handler in <kbd>.addRequestHandlers()</kbd>:</p>
<pre>const LaunchRequestHandler = {<br/>    canHandle(handlerInput) {<br/>        return handlerInput.requestEnvelope.request.type === 'LaunchRequest';<br/>    },<br/>    handle(handlerInput) {<br/>        const speechText = `Hi there, I'm Car Helper. You can ask me to suggest a car for you.`;<br/><br/>        return handlerInput.responseBuilder<br/>            .speak(speechText)<br/>            .reprompt(speechText)<br/>            .getResponse();<br/>    }<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the whichCar Intent</h1>
                </header>
            
            <article>
                
<p>We can start dealing with our <kbd>whichCar</kbd> intent. We start by creating the <kbd>WhichCarHandler</kbd> and adding it to the list in <kbd>addRequestHandlers()</kbd>:</p>
<pre>const WhichCarHandler = {<br/>    canHandle(handlerInput) {<br/>        return handlerInput.requestEnvelope.request.type === 'IntentRequest' &amp;&amp;<br/>            handlerInput.requestEnvelope.request.intent.name === 'whichCar';<br/>    },<br/>    async handle(handlerInput) {}<br/>}</pre>
<p>Inside this <kbd>handler</kbd> function, the first thing that we need to do is to get the slots from the event. We can use <kbd>es6</kbd> destructuring to simplify our code:</p>
<pre>const slots = handlerInput.requestEnvelope.request.intent.slots;<br/>const {size, cost, gears, doors} = slots;</pre>
<p>We now have access to all four of our slot variables. Even though we created our slot types, we need to check that we have valid values. We'll start with size and cost as we know that we always need values for those slots:</p>
<pre>if (!size.value || !(size.value === 'large' || size.value === 'medium' || size.value === 'small')) {<br/>    const slotToElicit = 'size';<br/>    const speechOutput = 'What size car do you want? Please say either small, medium or large.';<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .addElicitSlotDirective(slotToElicit)<br/>        .getResponse();<br/>}<br/> <br/>if (!cost.value || !(cost.value === 'luxury' || cost.value === 'value')){<br/>    console.log('incorrect cost')<br/>    const slotToElicit = 'cost';<br/>    const speechOutput = 'Are you looking for a luxury or value car?';<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .addElicitSlotDirective(slotToElicit)<br/>        .getResponse();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>These two blocks of code check that the slots exist and then check that they equal one of the expected responses. If the slot isn't filled or doesn't equal one of the expected values, we get Alexa to ask for the slot again using <kbd>.addElicitSlotDirective</kbd>.</p>
<p>If the request has got past these two blocks,  we know that we have a valid size and cost. In our flow diagram, this is where we had a logic step to decide which path to send them down, so that is what we need to implement now.</p>
<p>If the user chose a large car, we need to see whether they have chosen a gear yet. If they haven't, we ask them whether they want to have an automatic or manual transmission. We do the same process for small cars and the number of doors:</p>
<pre>if (size.value === 'large' &amp;&amp; ( !gears.value || !(gears.value === 'automatic' || gears.value === 'manual') )){<br/>    // missing or incorrect gears<br/>    const slotToElicit = 'gears';<br/>    const speechOutput = 'Do you want an automatic or a manual transmission?';<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .addElicitSlotDirective(slotToElicit)<br/>        .getResponse();<br/>}<br/> <br/>if (size.value === 'small' &amp;&amp; ( !doors.value || !(doors.value == 3 || doors.value == 5) )){<br/>    // missing or incorrect doors<br/>    const slotToElicit = 'doors';<br/>    const speechOutput = 'Do you want 3 or 5 doors?';<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .addElicitSlotDirective(slotToElicit)<br/>        .getResponse();<br/>}</pre>
<p>If the request has got past this point, there are three possibilities:</p>
<ul>
<li>They chose a small car and have selected the number of doors</li>
<li>They chose a medium car so didn't need to choose doors or gears</li>
<li>They chose a large car and have chosen their gears</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The next step is to find the best car based on the user choices. To choose the best car, we need to have a selection of cars to sort from. We can create an object outside of the handler to store the data we need to sort the cars:</p>
<pre>const cars = [<br/>     {name: 'fiat500', size:'small', cost: 'luxury', doors: 3, gears: 'manual'},<br/>     {name: 'fordFiesta', size:'small', cost: 'luxury', doors: 5, gears: 'manual'},<br/>     {name: 'hyundaiI10', size:'small', cost: 'value', doors: 3, gears: 'manual'},<br/>     {name: 'peugeot208', size:'small', cost: 'value', doors: 5, gears: 'manual'},<br/>     <br/>     {name: 'vauxhallAstra', size:'medium', cost: 'value', doors: 5, gears: 'manual'},<br/>     {name: 'vwGolf', size:'medium', cost: 'luxury', doors: 5, gears: 'manual'},<br/>     <br/>     {name: 'scodaOctaviaAuto', size:'large', cost: 'value', doors: 5, gears: 'automatic'},<br/>     {name: 'fordCmax', size:'large', cost: 'value', doors: 5, gears: 'manual'},<br/>     {name: 'mercedesEClass', size:'large', cost: 'luxury', doors: 5, gears: 'automatic'},<br/>     {name: 'vauxhallInsignia', size:'large', cost: 'luxury', doors: 5, gears: 'manual'}<br/> ];</pre>
<p>With this object containing all of the car options we want, we need to find the car that is best for the user. To do this, we can use the <kbd>Array.filter()</kbd> function. This function goes through each item in an array and applies a function to it. If the function returns true, the item is kept in the array, otherwise, it is removed:</p>
<pre>// find the ideal car<br/>let chosenCar = cars.filter(car =&gt; {<br/>    return (car.size === size.value &amp;&amp; car.cost === cost.value &amp;&amp; <br/>        (gears.value ? car.gears === gears.value : true) &amp;&amp; <br/>        (doors.value ? car.doors == doors.value: true));<br/>});</pre>
<p>To find the best car for the user, this filter function checks that <kbd>car.size</kbd> and <kbd>car.cost</kbd> equal what the user selected, and then uses ternary expressions to check the gears and doors. If the user has selected a gear type or a number of doors, it checks whether the car information matches the user's choice, otherwise it returns <kbd>true</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When we run this function, we get back the car that matches the user's choices. If the user has chosen a <kbd>small</kbd>, <kbd>luxury</kbd> car with <kbd>3</kbd> doors, then the <kbd>chosenCar</kbd> will equal <kbd>[{name: 'fiat500', size:'small', cost: 'luxury', doors: 3, gears: 'manual'}]</kbd>.</p>
<p>Before we get more details on the chosen car, we need to check that our function chose a car. This can be done by checking that our new <kbd>chosenCar</kbd> array has a length of <kbd>1</kbd>. If it doesn't, there has been some sort of error and we need to let the user know. Add this code after our filter method:</p>
<pre>if (chosenCar.length !== 1) {<br/>    const speechOutput = `Unfortunately I couldn't find the best car for you. You can say "suggest a car" if you want to try again.`;<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .getResponse();<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Amazon S3</h1>
                </header>
            
            <article>
                
<p>Now that we have the chosen car, we can get some more information on that car from an S3 bucket. S3 buckets allow us to store objects and access them from wherever we want.</p>
<p>To create an S3 bucket, search for S3 in the AWS console. On the S3 page, click the <span class="packt_screen">Create bucket</span> button to start the creation process. Choose a name for your bucket, noting that the name has to be unique across all buckets on S3. Adding your name or an alias onto the start or end of the bucket name can help make your bucket unique. For this example, we don't need to set up any other properties or permissions on the bucket, so we can just click on <span class="packt_screen">Next</span> until we get to the end.</p>
<p>With your new bucket created, we can start to create data that will be uploaded into it. Uploading data to an S3 bucket is really easy; click on the bucket that you want to upload into and click the <span class="packt_screen">Upload</span> button. You can then either drag and drop your files in or click <span class="packt_screen">Add files</span> to upload your files in a more traditional way. For this project, we don't need to set any of the permissions or properties for these files.</p>
<p>All of the data that we're going to upload is available at <a href="http://bit.ly/chatbot-ch3">http://bit.ly/chatbot-ch3</a> in the <kbd>car-data</kbd> folder. We'll have a look at one example file to see what data we are going to access:</p>
<pre>{<br/>    "make": "Vauxhall",<br/>    "model": "Astra",<br/>    "rrp": 16200,<br/>    "fuelEcon": "44-79 mpg",<br/>    "dimensions": "4.258 m L x 1.799 m W x 2.006 m H",<br/>    "NCAPSafetyRating": "5 star",<br/>    "cargo": 370<br/>}</pre>
<p>With this information, we can give the user a good summary of the car that our chatbot has suggested for them. This could be expanded, but providing too much data to the user may make the interaction too complicated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing our S3 data</h1>
                </header>
            
            <article>
                
<p>Now that we have all of our data in our S3 bucket and have chosen a car based on the user's choices, we need to get the relevant data. To do this, we can use <kbd>aws-sdk</kbd> to interact with <kbd>S3</kbd> from our Lambda.</p>
<p>At the top of our Lambda, we need to require in <em>AWS</em> so that we can use the <em>S3</em> method. Add these two lines to the top of this Lambda:</p>
<pre>const AWS = require('aws-sdk');<br/>var s3 = new AWS.S3();</pre>
<p>Now that we have access to the S3 methods on AWS, we can get the JSON for our chosen car. At the end of our <kbd>whichCar</kbd> handler, add the following code:</p>
<pre>var params = {<br/>    Bucket: YOUR BUCKET NAME, <br/>    Key: `${chosenCar[0].name}.json`<br/>};<br/> <br/>return new Promise((resolve, reject) =&gt; {<br/>    s3.getObject(params, function(err, data) {<br/>        if (err) { // an error occurred<br/>            console.log(err, err.stack);<br/>            reject(handleS3Error(handlerInput));<br/>        } else { // successful response<br/>            console.log(data);<br/>            resolve(handleS3Data(handlerInput, data));<br/>        }<br/>    });<br/>})</pre>
<p>The first part of this code snippet is choosing where and what data we are trying to access. Make sure that you put in your bucket name. The key is generated using a template string so that we get the file related to the car we chose for the user.</p>
<p>We then return a promise that contains the <kbd>s3.getObject()</kbd> method, passing in our <kbd>params</kbd> and a <kbd>callback</kbd> function. The callback from the <kbd>.getObject()</kbd> method passes the <kbd>err</kbd> and <kbd>data</kbd> parameters. If there is an error, we will <kbd>reject</kbd> a function called <kbd>handleS3Error</kbd>. If it succeeds, we'll <kbd>resolve</kbd> the <kbd>handleS3Data</kbd> function. We'll create these functions later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding S3 permissions</h1>
                </header>
            
            <article>
                
<p>Because we are now accessing data from S3, we also need to update the <span class="packt_screen">Execution role</span> to include S3 read-only. In your AWS console, navigate to <span class="packt_screen">IAM</span> which is where you control your users, roles, and policies.</p>
<p>In the menu on the left, select <span class="packt_screen">Roles</span> and you should see a list of your roles. If this is your first time using AWS, you'll only have one role: <em><span class="packt_screen">LambdaBasic</span></em>. When you select it, you are taken to a summary page where there is an <span class="packt_screen">Attach policy</span> button. We need to attach <em>S3</em> permissions so we can click that button.</p>
<p>This opens up a list of all of the policies that are available on your account. Amazon has made hundreds of default policies for almost every scenario. We're going to search for <kbd>S3</kbd>. We should get at least four options, which include <em>Redshift</em>, <em>FullAccess</em>, <em>ReadOnly</em>, and <em>QuickSight</em>. As we're only going to be getting data from S3, we can tick the <span class="packt_screen">AmazonS3ReadOnlyAccess</span> tickbox and then the <span class="packt_screen">Attach policy</span> button in the lower-right corner:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dcdc7ba4-2613-4457-870a-ea47988e23e2.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Adding Amazon S3 permissions</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with our data</h1>
                </header>
            
            <article>
                
<p>Having done the request to S3, we have received our data or an error. Either way, we need to deal with it and send a response to the user. We'll create two new functions that deal with either the data or an error:</p>
<pre>const handleS3Error = handlerInput =&gt; {<br/>    const speechOutput = `I've had a problem finding the perfect car for you.`<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .getResponse();<br/>};<br/> <br/>function handleS3Data(data){<br/>    let body = JSON.parse(data.Body);<br/>    console.log('body= ', body);<br/>    let { make, model, rrp, fuelEcon, dimensions, NCAPSafetyRating, cargo} = body;<br/>    let speech = `I think that a ${make} ${model} would be a good car for you. <br/>    They're available from ${rrp} pounds, get ${fuelEcon} and have a ${cargo} litre boot.`;<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .getResponse();<br/>}</pre>
<p>The error function tells the user that we couldn't find the best car for them, while the data function creates a short description of the car using the data. We need to parse the body of the data because the data comes down as a buffer. We need to convert the buffer to a format that we can use.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing our Lambda</h1>
                </header>
            
            <article>
                
<p>With the last skill, the Lambda was simple enough that we could get away with not testing it. This Lambda is more complicated, with multiple places where we could have an error, so we're going test it properly.</p>
<p>In the Lambda console, find your function and open it up. Once inside, click on the dropdown next to <span class="packt_screen">Test</span> and choose <span class="packt_screen">Configure test events</span>. Make sure that the <span class="packt_screen">Create new test event</span> option is selected and we can use a template of <span class="packt_screen">Alexa Intent - GetNewFact</span>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Most of the template can be left as default, but we need to change the slots and <kbd>intentName</kbd> (lines 20 and 21) as well as the application IDs (lines 10 and 35). Start by changing <kbd>intentName</kbd> to equal the intent that we created (<kbd>whichCar</kbd>). Next, we can add the slots that we have available. For now, we can set all of them to <em>null</em> as that is what they will be when they haven't been populated yet:</p>
<pre>"slots": {<br/>    "size": null,<br/>    "cost": null,<br/>    "gears": null,<br/>    "doors": null<br/>},<br/>"name": "whichCar"</pre>
<p>Using the ARN that you got from the Alexa Skill console <span class="packt_screen">Endpoint</span> section, change the value for <kbd>applicationId</kbd> at line 10 and 40.</p>
<p>Call this intent <kbd>whichCarEmpty</kbd> and click <span class="packt_screen">Create</span>.</p>
<p>Before we run this test, we can think about what we expect to happen. Because there are no slots filled, we expect that it will fail at the <kbd>size</kbd> check, therefore we will get a response asking us what size of car we want. It is always good to work out what you expect to happen before running a test. It helps you build your code understanding, and if you don't get that response, it raises a red flag in your mind.</p>
<p>Now we can click <span class="packt_screen">Test</span> and we should get <span class="packt_screen">Execution result: succeeded</span> and a response with an output speech of <span class="packt_screen">"What size car do you want? Please say either small, medium or large</span><span class="packt_screen">"</span>.</p>
<p>This is what we expected so that is great! If you didn't get this response, look at the error message and use that to figure out what may have gone wrong. There is a helpful section in the <em>Appendix</em> that can be used to debug common Lambda errors.</p>
<p>With this test working, we can create another test that has some filled slots. Click the testing dropdown and select <span class="packt_screen">Configure test events</span> again. Make sure that <span class="packt_screen">Create new test event</span> is selected, but this time choose <span class="packt_screen">whichCarEmpty</span> as the template. This means that we know the application IDs are correct and the only things we need to change are the slots. Change the slots to the following code:</p>
<pre>"slots": {<br/>    "size": { "value": "large"},<br/>    "cost": { "value": "luxury"},<br/>    "gears": { "value": "automatic"},<br/>    "doors": { "value": null}<br/>},</pre>
<p>Save this test as <span class="packt_screen">whichCarLargeLuxuryAuto</span><span>.</span> When you run this test, you should get a successful response of the following:</p>
<p><span class="packt_screen">"I think that a Mercedes-Benz would be a good car for you. They're available from 35,150 pounds, get 32-66 mpg and have a 425 litre boot."</span></p>
<p>You can create tests for each of the possible combinations of results, but since we know that our Lambda is responding and is accessing S3, we know that all of the code is working.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finishing the Alexa Skills Kit Configuration</h1>
                </header>
            
            <article>
                
<p>To finish the configuration of our skill, we need to get the ARN of our Lambda. Copy that from the top of the Lambda page or from the result of your build script and go to the Alexa Skills Kit console. Paste it into <span class="packt_screen">Default Region</span> and save the endpoint. That is all we need to do before we can start testing our skill.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>Now we can try out our new skill. Here you can see a conversation that I had with my car helper bot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/853d679c-ea8e-4da5-9472-0aa5143a13ad.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Testing the car helper skill</div>
<p>This skill isn't perfect <span>–</span> it doesn't respond to every utterance that you might say and there is a lot more the skill could do. The good thing is you now know everything you need to fix all of those issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching your skill</h1>
                </header>
            
            <article>
                
<p>To launch your skill to the Alexa Skill Store, we need to move to the next tab. This is where you will set up the information that will be present on the Alexa Skill Store. You need to give your skill a unique name, short and long descriptions, and example utterances. Then you get to upload an icon and select the category and keywords for your skill. The category and keywords should be carefully considered as this is probably how users are going to find your skills.</p>
<p>The last part on this page is the <em>privacy policy</em> and <em>terms of use</em> URLs. You need to have these if you are going to have a skill in the skills store. There are lots of examples out there and they shouldn't be very complicated for skills that don't store or even ask for user information. Any app that does use and store user information will need a more detailed privacy policy and it may be worth contacting a lawyer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5a8b4bd8-173c-447d-8d55-216130f0d2df.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Launch setup</div>
<p>The next page asks you a number of privacy and compliance questions about your skill. Answer these honestly and then provide some information to the person who will be testing your skill before it gets deployed.</p>
<p>Next, we have to choose the availability of our skill. We can use this to only allow certain organizations to access the skill. This can be useful if you've created a specialized skill for a company and don't want other people using it. You can also select the countries where the skill will be available. You could limit it to one or two countries or let everyone use it.</p>
<p>The last page is a review page where it tells you whether there is anything that your submission is missing. When you fix everything, you can click <span class="packt_screen">Submit</span> <span class="packt_screen">for review</span>. While the skill is in testing, you won't be able to edit the configuration of the skill. You can still edit your Lambdas, but doing so can cause your skill to be rejected.</p>
<p>Once it's been tested and approved, you'll have a live Alexa Skill!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter showed us how to do a lot of new things. We started by cr<span>eating our first Alexa Skill using Alexa Skills Kit. This involved learning about and creating i</span><span>ntents, slots, and utterances. With the configuration completed, we created a</span><span> Lambda to handle the request using Alexa-SDK. This Lambda is where we defined the response that would be sent to the user.</span><span> Finally, we b</span><span>uilt and tested our new Alexa Skill using the built-in testing tools.</span></p>
<p>Having made a basic first skill, we started to create a more useful second skill. We used a <span>custom slot type and applied it to slots in our intents. We then used Amazon's </span><span>S3 service to store the data we needed before using AWS SDK to easily get the data and use it in our Lambda.</span></p>
<p>Using the skills learned in this chapter, you can go build a huge range of powerful skills for Alexa.</p>
<p>In the next chapter we'll learn to access APIs, allowing us to create much more powerful skills.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the tool we use in Lambdas for dealing with Alexa requests?</li>
<li>What three things do we need to do to connect a Lambda to an Alexa Skill?</li>
<li>What is the method we use to get information from our S3 bucket?</li>
</ol>
<ol start="4">
<li>What do we have to do to the body response from S3 and why?</li>
<li>How do we create a Lambda test?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>If you want to try out different types of response, have a look through the Alexa SDK response builder docs: <a href="https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Building-Response.html">https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Building-Response.html</a>.</p>
<p>We have only used S3 to get data that we manually stored; there are other methods that allow more S3 functionality: <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html">https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html</a>.</p>


            </article>

            
        </section>
    </body></html>