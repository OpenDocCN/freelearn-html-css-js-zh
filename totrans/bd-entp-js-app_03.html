<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing Version History with Git</h1>
                </header>
            
            <article>
                
<p><span>In this book, starting from <a href="76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml" target="_blank">Chapter 4</a>, <em>Setting Up Development Tools</em>, we're going to be building a very simple user directory, which we've randomly named</span> <strong><span>hobnob</span></strong><span>. We need a way for us to keep a versioned history of our code, so that if we've made some mistakes along the way, we can simply revert back to the last known good version and start again from there. </span>This is known as <strong>version control</strong> (<strong>VC</strong>).</p>
<p>The simplest way to implement version control is to copy the entire codebase into date-stamped directories; however, this is tedious and may take up a lot of disk space. Instead, we can use a <strong>Version Control System</strong><span> (<strong>VCS</strong>) that'll manage these versions for us. We simply have to instruct the VCS when to create a snapshot of our code, and it will keep that version.</span></p>
<p><span>There have been many implementations of VCS, starting in 1972 with<strong> </strong></span><strong>Source Code Control System<span> </span></strong>(<strong>SCCS</strong>), which was superseded by<strong> Revision Control System<span> </span></strong>(<strong>RCS</strong>, released in <span>1982</span>),<span> </span><strong>Concurrent Versions System</strong><span> </span>(<strong>CVS</strong>, released in 1990), and<span> <strong>Apache </strong></span><strong>Subversion</strong><span> </span>(<strong>SVN</strong>, released in 2000). Nowadays, we mainly use <strong>Git</strong> (released in 2005), a type of VCS known as <strong>Distributed VCS<span> </span></strong>(<strong>DVCS</strong>).</p>
<p>Git was created by Linus Torvalds, who's also the creator of the Linux kernel. It is used to track changes in the development of the <span>Linux kernel, as well as the tens of millions of repositories currently on GitHub. </span>In this chapter, we will guide you through setting up and configuring Git, as well as explaining basic Git concepts, such as:</p>
<ul>
<li>Different states in Git</li>
<li>Basic Git operations such as <strong>staging</strong>, <strong>committing</strong>, <strong>merging</strong>/<strong>rebasing</strong>, <strong>pushing</strong>, and <strong><strong>pulling</strong></strong></li>
<li>Implementing a parallel development workflow using a branching model proposed by Vincent Driessen, commonly known as <strong><strong>Git flow</strong></strong></li>
<li>Setting up a <strong>GitHub</strong> account to host our code remotely</li>
<li>Understanding the workflow when working with others</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Git</h1>
                </header>
            
            <article>
                
<p>First, we must install Git.</p>
<div class="packt_infobox">Most installation instructions depend on your hardware architecture and operating system. It would be impractical for us to outline instructions for all of them. So, for this book, we'll assume you're running Ubuntu 16.04 / 18.04 on a 64-bit machine, using a user with <kbd>sudo</kbd> privileges.<br/>
<br/>
We will provide URL links to the documentation whenever possible, so that you can find installation instructions specific to your machine. However, due to the dynamic nature of the internet, URL addresses change and pages may get moved. If the link we provide appears to be dead, simply search for the instructions using a search engine.</div>
<p>Git is available for macOS, Windows, and Linux. You can find download instructions for Git at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>. Since we are using Ubuntu, the <kbd>git</kbd> package will be available from our distribution's package manager, <strong>Advanced Packaging Tool</strong> (<strong>APT</strong>). We should run <kbd>sudo apt update</kbd> to ensure that the list of repositories available to APT is up to date, before installing the <kbd>git</kbd> package:</p>
<pre><strong><span>$ sudo apt update<br/></span><span>$ sudo apt-get install git</span></strong></pre>
<p>Git is now available as the <kbd>git</kbd> <strong>command-line interface</strong> (<strong>CLI</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new repository</h1>
                </header>
            
            <article>
                
<p>Next, create a directory, named <kbd>hobnob</kbd>, to house our project. Then, navigate inside and run <kbd>git init</kbd>. This will allow Git to start tracking changes to our project; a project tracked by Git is also known as a <strong>repository</strong>:</p>
<pre><strong>$ mkdir -p ~/projects/hobnob</strong><br/><strong>$ cd ~/projects/hobnob/</strong><br/><strong>$ git init</strong><br/><strong>Initialised empty Git repository in ~/projects/hobnob/.git/</strong></pre>
<div class="packt_tip">As we introduce new Git commands, I encourage you to read their full documentation, which you can find at <a href="https://git-scm.com/docs" target="_blank">https://git-scm.com/docs</a>.</div>
<p><span>Running <kbd>git init</kbd> creates a </span><kbd>.git</kbd><span> directory, which holds all version-control-related information about the project. When we interact with Git using its CLI, all it's doing is </span>manipulating the content of this <kbd>.git</kbd> directory. <span>We usually don't have to care about the contents of the </span><kbd>.git</kbd><span> directory, as we can interact with Git purely through the CLI.</span></p>
<div class="packt_infobox">Because Git keeps all files under the <kbd>.git</kbd> directory, deleting the <kbd>.git</kbd> directory will delete the repository, including any history.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Git</h1>
                </header>
            
            <article>
                
<p><span>We can configure Git using the <kbd>git config</kbd> command. This command will manipulate the <kbd>.git/config</kbd> file on our behalf. </span>In fact, if we print the content of the <kbd>.git/config</kbd> file, you'll see that it is similar to the output of the <kbd>git config</kbd> command:</p>
<pre><strong>$ cd ~/projects/hobnob/</strong><br/><strong>$ cat .git/config</strong><br/><strong>[core]</strong><br/><strong>    repositoryformatversion = 0</strong><br/><strong>    filemode = true</strong><br/><strong>    bare = false</strong><br/><strong>    logallrefupdates = true</strong><br/><br/><strong>$ git config --list --local</strong><br/><strong>core.repositoryformatversion=0</strong><br/><strong>core.filemode=true</strong><br/><strong>core.bare=false</strong><br/><strong>core.logallrefupdates=true</strong></pre>
<div class="packt_tip">Feel free to examine the <kbd>.git</kbd> directory using a tool such as <kbd>tree</kbd>. First, install <kbd>tree</kbd> by running <kbd>sudo apt install tree</kbd>. Then, run <kbd>tree ~/projects/hobnob/.git</kbd>.</div>
<p class="mce-root"/>
<p>To configure Git, we must first understand that there are three scopes, or levels, of configurations, each with a corresponding configuration file stored at different locations:</p>
<ul>
<li><strong>Local</strong>: Applies only to the current repository; the configuration file is stored at <kbd>&lt;repository-root&gt;/<span>.git/config</span></kbd>.</li>
<li><strong>Global</strong>: Applies to all repositories under the user's home directory; the configuration file is stored at <span><kbd>$HOME/.config/git/config</kbd> and/or at <kbd>$HOME/.gitconfig</kbd>, with the latter being only available in newer versions of Git. <kbd>$HOME/.gitconfig</kbd> will override <kbd>$HOME/.config/git/config</kbd>.</span></li>
<li><strong>System</strong>: Applies to all repositories in your machine; the configuration file stored at <kbd><span>/etc/gitconfig</span></kbd><span>.</span></li>
</ul>
<p>The local configuration settings will override the global settings, which, in turn, override the system settings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a user</h1>
                </header>
            
            <article>
                
<p>When we ask Git to take a snapshot of our code (also called <strong>committing</strong>), Git will record several pieces of information, such as the time and author of the commit. The information about the author is saved as Git configurations, which saves us from having to re-type them each time we commit.</p>
<p>By default, adding/updating the configuration would write to the local config file. However, since you are going to be the only person using your user account on your machine, it's better to set the user settings in the global configuration file:</p>
<pre><strong>$ git config --global user.name "Daniel Li"</strong><br/><strong>$ git config --global user.email "dan@danyll.com"</strong></pre>
<p>This will cause future commits to be, by default, identified as <kbd>"Daniel Li"</kbd> whose email address is <kbd>"dan@danyll.com"</kbd>.</p>
<div class="packt_tip">If you have a GitHub account (if not, we will create one later), you should use the same email address for Git. When you push your commits, GitHub will automatically associate your commits to your account.</div>
<p class="mce-root"/>
<p><span>We have now successfully set up Git and configured our user.</span></p>
<p><span>For the remainder of this chapter, we will use dummy files to illustrate how Git works and the workflow we will follow. Everything you do for the rest of this chapter should be viewed as an educational exercise, and can be discarded afterward. At the beginning of the next chapter, we will start our project again from scratch, and you will use the things you learned in this chapter to keep your code base's history organized!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning the basics</h1>
                </header>
            
            <article>
                
<p>The primary purpose of Git is to keep a history of changes, or revisions. To illustrate this, let's create a simple file and commit it to the history of the repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Committing to history</h1>
                </header>
            
            <article>
                
<p>First, let's confirm our repository's Git history by running <kbd>git log</kbd>, which shows a history of past commits:</p>
<pre><strong>$ git log</strong><br/><strong>fatal: your current branch 'master' does not have any commits yet</strong></pre>
<p>The error correctly informs us that there are currently no commits. Now, let's create a short <kbd>README.md</kbd> file, which represents the first change we want to commit:</p>
<pre><strong>$ cd ~/projects/hobnob/</strong><br/><strong>$ echo -e "# hobnob" &gt;&gt; README.md</strong></pre>
<p>We've created our first file and thus made our first change. We can now run <kbd>git status</kbd>, which will output information about the current state of our repository. We should see our <kbd>README.md</kbd> file being picked up by Git:</p>
<pre><strong>$ git status</strong><br/><strong>On branch master</strong><br/><strong>Initial commit</strong><br/><strong>Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed)</strong><br/><strong> README.md</strong><br/><strong>nothing added to commit but untracked files present (use "git add" to track)</strong></pre>
<p>The output tells us that we<span> are on the default </span><kbd>master</kbd> <span>branch (more on branching later), and that t</span><span>his is our</span> <em>initial commit—</em><span>we have not committed anything to the repository yet. </span>It then says we have untracked files. To understand what that means, we must understand the different states that a file can be in with Git.</p>
<div class="packt_tip">So far, we have used<span> </span><kbd>git log</kbd><span> </span>and<span> </span><kbd>git status</kbd>, but there are many more CLI commands; to see a full list, run<span> </span><kbd>git help</kbd>. To get details about a particular command, run<span> </span><kbd>git help [command]</kbd>; for example,<span> </span><kbd>git help status</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding file states in Git</h1>
                </header>
            
            <article>
                
<p>In Git, every file can be in one of two generic states: <strong>tracked</strong> and <strong>untracked</strong>.</p>
<p><span>Initially, all files exists in the </span><strong>workspace</strong><span> (also known as </span><strong>working tree</strong> or <strong>working directory</strong><span>) and are in the </span><strong>untracked</strong><span> state. These untracked files are not part of the repository, and Git won't</span> <span>pick up changes made to them. When we run </span><kbd>git status</kbd><span>, Git sees that there are files in our workspace that are untracked (no</span><span>t part of the repository) and asks whether we want to add them to the repository. </span>When we commit a new file to the repository using <kbd>git add</kbd> and <kbd>git commit</kbd>, it transitions from untracked to tracked:</p>
<pre><strong>$ git add README.md</strong><br/><strong>$ git commit -m "Initial commit"</strong><br/><strong>[master (root-commit) 6883f4e] Initial commit</strong><br/><strong> 1 file changed, 1 insertion(+)</strong><br/><strong> create mode 100644 README.md</strong></pre>
<p><kbd>README.md</kbd> is now part of the repository and is in the tracked state.</p>
<div class="packt_tip">We are passing in<span> </span><kbd>"Initial commit"</kbd><span> </span>as a comment that describes the commit. Every commit should have an accompanying message that describes what changes were made. It should be informative and specific; for example,<span> </span><kbd>"Fixed rounding error bug in calculateScore"</kbd><span> </span>is a better commit message than<span> </span><kbd>"fixed bugs"</kbd>.<br/>
<br/>
However, since our commit does little other than initializing the repository, this message will suffice.</div>
<p class="mce-root"/>
<p>We can confirm this by looking at the Git commit history of the repository with the<span> </span><kbd>git log</kbd><span> </span>command:</p>
<pre class="mce-root"><strong>$ git log</strong><br/><strong>commit 9caf6edcd5c7eab2b88f23770bec1bd73552fa4a (HEAD -&gt; master)</strong><br/><strong>Author: Daniel Li &lt;dan@danyll.com&gt;</strong><br/><strong>Date: Fri Dec 8 12:29:10 2017 +0000</strong><br/><strong>    Initial commit</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The three tracked states</h1>
                </header>
            
            <article>
                
<p><span>To be more precise, the tracked state can be further subdivided into three substates: </span><strong>modified</strong><span>, </span><strong>staged</strong><span>, and </span><strong>committed</strong><span>. Our <kbd>README.md</kbd> file is in the committed state.</span></p>
<p>Git will pay attention to all the tracked files; if we modify any of them (which includes deletions and renames), they will change their state from committed to modified:</p>
<pre><strong>$ echo "A very simple user directory API with recommendation engine" &gt;&gt; README.md</strong><br/><strong>$ git status</strong><br/><strong>On branch master</strong><br/><strong>Changes not staged for commit:</strong><br/>  <strong>modified: README.md</strong></pre>
<p>Modified files, alongside any untracked files, will be listed when we run <kbd>git status</kbd>. Modified files can be committed in the same manner as untracked files:</p>
<pre><strong>$ git add README.md</strong><br/><strong>$ git commit -m "Update README.md"</strong><br/><strong>[master 85434b6] Update README.md</strong><br/><strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>You might be wondering why we had to run <kbd>git add</kbd> before we ran <kbd>git commit</kbd>. <kbd>git add</kbd> places the untracked or modified file into what is known as the <strong>staging area</strong>, which is also known as the <strong>index</strong> or <strong>cache</strong>. When a file is placed into the staging area, it is in the staged state. <span>When we commit, only changes in the staging area are added to the repository; changes that remain in the workspace are not committed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Staging our changes</h1>
                </header>
            
            <article>
                
<p>By having a staging area, <span>we can <kbd>git add</kbd> multiple related changes and <kbd>git commit</kbd> them all at the same time—as a single commit. </span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, the staging area acts as a temporary environment to collect these related changes. For example, if we add a new feature into our application, we should also document this in our <kbd>README.md</kbd>. These changes are related to each other and should be committed together:</p>
<pre><strong>$ echo "console.log('Hello World')" &gt;&gt; index.js</strong><br/><strong>$ echo -e "# Usage\nRun \`node index.js\`" &gt;&gt; README.md</strong><br/><strong>$ git add index.js README.md</strong><br/><strong>$ git commit -m "Add main script and documentation"</strong><br/><strong>[master cf3221a] Add main script and documentation</strong><br/><strong> 2 files changed, 3 insertions(+)</strong><br/><strong> create mode 100644 index.js</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Quick recap</h1>
                </header>
            
            <article>
                
<p>Let's quickly summarize what we've learned so far:</p>
<ul>
<li><strong>Workspace/working directory</strong>: All the files and directories currently in our filesystem</li>
<li><strong>Index/staging area/cache</strong>: All the modifications you want to commit</li>
<li><strong>Repository</strong> (the <kbd>.git</kbd> directory): Hosts a history of all your committed and tracked files</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/7f257635-9091-41eb-b69f-c3f88d3d1eae.jpg" style="width:24.75em;height:11.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching and merging</h1>
                </header>
            
            <article>
                
<p>So far, we have been adding changes sequentially to the repository, resulting in a history with a linear structure. But what if you, or your team, want to work on different features/multiple tasks at the same time? If we continue with our current workflow, the Git commit history is going to look disjointed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/235bffc5-cf78-426d-ab48-c4dcc59cf28f.jpg"/></p>
<p>Here, we have commits relating to bug fixes interleaved between commits relating to features. This is not ideal. Git <strong>branches</strong> were created to deal with this issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git branches</h1>
                </header>
            
            <article>
                
<p>As we've briefly mentioned, the default branch is called <kbd>master</kbd>, and we've been adding commits to this branch up to this point.</p>
<p>Now, when we develop a new feature or fix a particular bug, rather than adding those commits directory to <kbd>master</kbd>, we can instead create a branch from a certain commit from <kbd>master</kbd>. Any new commits to these bug fix and/or feature branches will be grouped together in a separate branch in the history tree, which does not affect the <kbd>master</kbd> branch. If and when the fix or feature is complete, we can merge this branch back into <kbd>master</kbd>.</p>
<p>The end result is the same, but the Git history is now much easier to read and understand. Furthermore, branches allow you to write and commit experimental code in an isolated part of the repository, so your changes, which may introduce new bugs and regressions, won't affect others until they have been tested and peer-reviewed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Branching models</h1>
                </header>
            
            <article>
                
<p>The workflow we described is an example of a <strong>branching model</strong>, which is just a term that describes how you structure your branches. As you can imagine, there are many branching models, and most are more complex than the one we've outlined.</p>
<p>For this book, we will follow a branching model put forward by Vincent Driessen in his article <em>A successful Git branching</em> <em>mode</em><em>l</em>, but you're free to explore other models and use the one that makes sense to you. The most important thing is that you and your team stick to the model consistently, so everyone on the team knows what is expected of them.</p>
<div class="packt_infobox">You may have heard Driessen's model described as <em>Git Flow</em>, but <kbd>gitflow</kbd> (<a href="https://github.com/nvie/gitflow">https://github.com/nvie/gitflow</a>) is actually a set of Git extensions that provides higher-level operations that follow Driessen's model.<br/>
<br/>
You can find the original post where Driessen proposed this model at <a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Driessen model</h1>
                </header>
            
            <article>
                
<p>Driessen provided a detailed diagram of how his model works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/132cf42f-d48c-4d5f-98bf-59f33c203c56.png" style="width:26.50em;height:36.75em;"/></p>
<p class="mce-root"/>
<p>In Driessen's model, there are two permanent branches:</p>
<ul>
<li><kbd>dev</kbd> (or <kbd>develop</kbd>, or <kbd>development</kbd>): The main branch that developers work on.</li>
<li><kbd>master</kbd>: Only production-ready code can be committed to this branch. Here, production-ready means the code has been tested and approved by the stakeholders.</li>
</ul>
<p>There are also other non-permanent branches:</p>
<ul>
<li><strong>Feature branches</strong>: Branching from the <kbd>dev</kbd> branch, feature branches are used for developing new features, or fixing non-critical bugs. Feature branches will eventually be merged back into the <kbd>dev</kbd> branch.</li>
<li><strong>Release branches</strong>: Once enough features or bug fixes havebeen implemented and merged into the <kbd>dev</kbd> branch, a release branch can be created from the <kbd>dev</kbd> branch to undergo more scrutiny before being released. For instance, the application can be deployed onto a staging server to be UI and manually tested. Any bugs uncovered during this process would then be fixed and committed directly to the release branch. Once the release branch is "free" of bugs, it can then be merged into the <kbd>master</kbd> branch and released into production. These fixes should also be merged back into the <kbd>dev</kbd> branch and any other release branches.</li>
<li><strong>Hotfix (or patch) branches</strong>: Hotfixes are issues (not always bugs) that are in production which must be fixed as soon as possible, before the next planned release. In these cases, the developer would create a branch from <kbd>master</kbd>, make the required changes, and merge directly back into <kbd>master</kbd>. These hotfix branches should also be merged back into the <kbd>dev</kbd> branch and any other release branches.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a development branch</h1>
                </header>
            
            <article>
                
<p>To implement the Driessen Model, we must first create the <kbd>dev</kbd> branch from the master branch. To check which branch we are currently on, we can run <kbd>git branch --list</kbd> or simply <kbd>git branch</kbd>:</p>
<pre><strong>$ git branch</strong><br/><strong>* master</strong></pre>
<p>This returns a list of all branches, with an asterisk (<kbd>*</kbd>) next to the currently active branch, which is currently <kbd>master</kbd>. To create<span> a new <kbd>dev</kbd> branch from the current branch, we can run </span><kbd>git branch dev</kbd><span>.</span></p>
<p><span>However, we are instead going to run </span><kbd>git checkout -b dev master</kbd><span>, which creates a new branch</span><span> </span>and<span><em> </em>makes it active at the same time:</span></p>
<pre><strong>$ git checkout -b dev master</strong><br/><strong>Switched to a new branch 'dev'</strong><br/><strong>$ git branch</strong><br/><strong>* dev</strong><br/><strong>  master</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating feature branches</h1>
                </header>
            
            <article>
                
<p><span>Any new features should be developed by branching off </span><kbd>dev</kbd><span>. Be sure to name the</span> feature branch so that it clearly indicates the feature being worked on. For example, if you're working on the social login feature, name your branch <kbd>social-login</kbd>:</p>
<pre><strong>$ git branch</strong><br/><strong>* dev</strong><br/><strong>  master</strong><br/><strong>$ git checkout -b social-login dev</strong><br/><strong>Switched to a new branch 'social-login'</strong></pre>
<p>If that feature has sub-features, you may create sub-branches from the main feature branch. For example, the <kbd>social-login</kbd> branch may include <kbd>facebook-login</kbd> and <kbd>twitter-login</kbd> sub-branches.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naming sub-branches</h1>
                </header>
            
            <article>
                
<p>There are multiple valid ways to name these sub-branches, but the most popular convention uses <span><strong>grouping tokens</strong>, with various <strong>delimiters</strong>. For example, our Facebook and Twitter login sub-branches can be grouped under the <kbd>social-login</kbd> grouping token, with a period (<kbd>.</kbd>) as a delimiter, and a <strong>sub-token</strong> such as <kbd>facebook</kbd> or <kbd>twitter</kbd>:</span></p>
<pre><strong>$ git checkout -b social-login.facebook social-login</strong><br/><strong>Switched to a new branch 'social-login.facebook'</strong><br/><strong>$ git branch<br/></strong><strong>  dev</strong><br/><strong>  master</strong></pre>
<pre><strong>  social-login</strong><br/><strong>* social-login.facebook</strong></pre>
<p>You can use almost anything as a delimiter; the comma (<kbd>,</kbd>), hash (<kbd>#</kbd>), and greater-than sign (<kbd>&gt;</kbd>) are all valid delimiters. However, there are several rules outlined under the <kbd>git-check-ref-format</kbd> part of the documentation that give valid reference names. For example, the following characters are unavailable: space, tilde (<kbd>~</kbd>), caret (<kbd>^</kbd>), colon (<kbd>:</kbd>), question mark (<kbd>?</kbd>), asterisk (<kbd>*</kbd>), and open bracket (<kbd>[</kbd>).</p>
<div class="packt_tip">See all the rules by visiting the documentation for <span><kbd>git-check-ref-format</kbd> at</span> <a href="https://git-scm.com/docs/git-check-ref-format">https://git-scm.com/docs/git-check-ref-format</a>.</div>
<p>Most conventions I have encountered use a forward slash (<kbd>/</kbd>) as the delimiter, and so we do the same here. However, this poses a problem because branches are stored as text files under <kbd>.git/refs/heads</kbd>. If we create a sub-branch called <kbd>social-login/facebook</kbd>, then it'd need to be created at <kbd>.git/refs/heads/social-login/facebook</kbd>, but this is impossible in our case because the <kbd>social-login</kbd> name is already used for the file, and thus cannot act as a directory at the same time:</p>
<pre><strong>$ git checkout -b social-login/facebook social-login</strong><br/><strong>fatal: cannot lock ref 'refs/heads/social-login/facebook': 'refs/heads/social-login' exists; cannot create 'refs/heads/social-login/facebook'</strong></pre>
<p>Therefore, when we create a new feature branch, we need to provide a <em>default</em> sub-token, such as <kbd>main</kbd>. With that in mind, let's delete our current feature branches and create them again with the <kbd>main</kbd> sub-token:</p>
<pre><strong>$ git checkout dev</strong><br/><strong>$ git branch -D social-login social-login.facebook</strong><br/><strong>$ git checkout -b social-login/main dev</strong><br/><strong>$ git branch</strong><br/><strong> dev</strong><br/><strong> master</strong><br/><strong>* social-login/main</strong></pre>
<p>We are now on the <kbd>social-login/main</kbd> feature branch, and can start developing our social login feature.</p>
<div class="packt_infobox">We won't actually be writing any code; we will simply be adding text to a file to mimic new features being added. This allows us to focus on Git and not be bogged down by implementation details.</div>
<p>First, let's create that file and commit it to the <kbd>social-login/main</kbd> branch:</p>
<pre><strong>$ touch social-login.txt</strong><br/><strong>$ git add -A &amp;&amp; git commit -m "Add a blank social-login file"</strong></pre>
<div class="packt_infobox">We are using <kbd>git add -A</kbd> here to add all changes to the staging area.</div>
<p>Now, we are going to create a sub-feature branch and develop our Facebook login feature:</p>
<pre><strong>$ git checkout -b social-login/facebook social-login/main</strong><br/><strong>$ echo "facebook" &gt;&gt; social-login.txt</strong><br/><strong>$ git add -A &amp;&amp; git commit -m "Implement Facebook login"</strong></pre>
<p>Now, do the same for the Twitter login feature, making sure to branch from the main feature branch:</p>
<pre><strong>$ git checkout -b social-login/twitter social-login/main</strong><br/><strong>$ echo "twitter" &gt;&gt; social-login.txt</strong><br/><strong>$ git add -A &amp;&amp; git commit -m "Implement Twitter login"</strong></pre>
<p>We now have two sub-feature branches, one main feature branch, one <kbd>dev</kbd> branch, and our original <kbd>master</kbd> branch:</p>
<pre><strong>$ git branch</strong><br/><strong>  dev</strong><br/><strong>  master</strong><br/><strong>  social-login/facebook</strong><br/><strong>  social-login/main</strong><br/><strong>* social-login/twitter</strong></pre>
<div class="packt_tip">Even if you're working on your own, it's useful to create branches, because it helps you organize your code and be able to switch between working on different features very quickly.<br/>
<br/>
Also note that there is no "right" way to name branches, only wrong ones. For instance, you may choose to use an additional grouping for your branches, such as <kbd>feature/social-login/facebook</kbd>. If you are using issue-tracking tools such as JIRA, you may also wish to add the issue ID into the branch, such as <kbd>fix/HB-593/wrong-status-code</kbd>. What <em>is</em> important is to choose a flexible scheme and be consistent with it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging branches</h1>
                </header>
            
            <article>
                
<p>We have developed our Facebook and Twitter login features on two separate sub-feature branches; how can we get these changes back onto the <kbd>master</kbd> branch? Following the Driessen Model, we must merge the two sub-feature branches onto the main feature branch, then merge the feature branch into the <kbd>dev</kbd> branch, and then create a release branch off <kbd>dev</kbd> and merge that release branch into <kbd>master</kbd>.</p>
<p>To get started, let's merge the <kbd>social-login/facebook</kbd> branch into the <kbd>social-login/main</kbd> branch using <kbd>git merge</kbd>:</p>
<pre><strong>$ git checkout social-login/main</strong><br/><strong>$ git merge social-login/facebook</strong><br/><strong>Updating 8d9f102..09bc8ac</strong><br/><strong>Fast-forward</strong><br/><strong> social-login.txt | 1 +</strong><br/><strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>Git will attempt to automatically merge the changes from the <kbd>social-login/facebook</kbd> branch into the <kbd>social-login/main</kbd> branch. Now, our branch structure looks like this:</p>
<pre><strong>$ git log --graph --oneline --decorate --all</strong><br/><strong>* 9204a6b (social-login/twitter) Implement Twitter login</strong><br/><strong>| * 09bc8ac (HEAD -&gt; social-login/main, social-login/facebook) Implement Facebook login</strong><br/><strong>|/ </strong><br/><strong>* 8d9f102 Add a blank social-login file</strong><br/><strong>* cf3221a (master, dev) Add main script and documentation</strong><br/><strong>* 85434b6 Update README.md</strong><br/><strong>* 6883f4e Initial commit</strong></pre>
<p>Next, we need to do the same for our Twitter login sub-feature. However, when we attempt the merge, it fails due to a <strong>merge conflict</strong>:</p>
<pre><strong>$ git checkout social-login/main</strong><br/><strong>$ git merge social-login/twitter</strong><br/><strong>Auto-merging social-login.txt</strong><br/><strong>CONFLICT (content): Merge conflict in social-login.txt</strong><br/><strong>Automatic merge failed; fix conflicts and then commit the result.</strong></pre>
<p><span>A merge conflict occurs when the changes from the two branches being merged overlap each other; Git doesn't know which version is the most appropriate version to move forward with, and so it does not automatically merge them</span><span>. Instead, it adds special Git markup into the file where the merge conflict occurs and expects you to manually resolve them:</span></p>
<pre><strong>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</strong><br/><strong>facebook</strong><br/><strong>=======</strong><br/><strong>twitter</strong><br/><strong>&gt;&gt;&gt;&gt;&gt;&gt;&gt; social-login/twitter</strong></pre>
<p>The part between <kbd>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</kbd><span> </span>and <kbd>=======</kbd><span> </span>is the version on our current branch, which is<span> </span><kbd>social-login/main</kbd>; the part between <kbd>=======</kbd><span> </span>and<span> </span><kbd>&gt;&gt;&gt;&gt;&gt;&gt;&gt; social-login/twitter</kbd><span> </span>is the version on the<span> </span><kbd>social-login/twitter</kbd><span> </span>branch.</p>
<p><span>We must </span>resolve<span> this merge conflict before the merge is complete. </span>To do that, we simply need to edit the file to the version we want, and remove the Git-specific sequences. In our example, we want to add the text for<span> </span><kbd>twitter</kbd><span> </span>after<span> </span><kbd>facebook</kbd>, so we would edit the file to become the following:</p>
<pre><strong>facebook</strong><br/><strong>twitter</strong></pre>
<p>Now the conflict is resolved, we need to complete the merge by adding <kbd>social-login.txt</kbd> to the staging area and committing it:</p>
<pre><strong>$ git status</strong><br/><strong>On branch social-login/main</strong><br/><strong>You have unmerged paths.</strong><br/><strong>Unmerged paths:</strong><br/><strong> both modified: social-login.txt</strong><br/><br/><strong>$ git add -A &amp;&amp; git commit -m "Resolve merge conflict"</strong><br/><strong>[social-login/main 8a635ca] Resolve merge conflict</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, if we look again at our Git history, we can see that we've implemented the Facebook and Twitter login features on two separate branches, and then merged them together in a separate commit (the one with the hash <kbd>37eb1b9</kbd>):</p>
<pre><strong>$ git log --graph --oneline --decorate --all</strong><br/><strong>* 37eb1b9 (HEAD -&gt; social-login/main) Resolve merge conflict</strong><br/><strong>|\ </strong><br/><strong>| * 9204a6b (social-login/twitter) Implement Twitter login</strong><br/><strong>* | 09bc8ac (social-login/facebook) Implement Facebook login</strong><br/><strong>|/ </strong><br/><strong>* 8d9f102 Add a blank social-login file</strong><br/><strong>* cf3221a (master, dev) Add main script and documentation</strong><br/><strong>* 85434b6 Update README.md</strong><br/><strong>* 6883f4e Initial commit</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examining more realistic examples</h1>
                </header>
            
            <article>
                
<p>The example we went through previously is very simple and a bit contrived. In a more realistic working environment, the <kbd>dev</kbd> branch will be very active: there will be many feature/bug fix branches that stem from <kbd>dev</kbd> and ultimately merge back into it. To illustrate how that can cause issues, and to show you how those issues can be mitigated, we're going back to the <kbd>dev</kbd> branch to create another feature branch; let's call it <kbd>user-schema/main</kbd>:</p>
<pre><strong>$ git checkout -b user-schema/main dev</strong><br/><strong>Switched to a new branch 'user-schema/main'</strong></pre>
<p>Now, let's add a file, <kbd>user-schema.js</kbd>, which represents the entirety of our user schema feature:</p>
<pre><strong>$ touch user-schema.js</strong><br/><strong>$ git add -A &amp;&amp; git commit -m "Add User Schema"</strong><br/><strong>[user-schema/main 8a31446] Add User Schema</strong><br/><strong> 1 file changed, 0 insertions(+), 0 deletions(-)</strong><br/><strong> create mode 100644 user-schema.js</strong></pre>
<p>Now, we can merge this feature branch back into <kbd>dev</kbd>:</p>
<pre><strong>$ git checkout dev</strong><br/><strong>Switched to branch 'dev'</strong><br/><strong>$ git merge user-schema/main </strong><br/><strong>Updating cf3221a..8a31446</strong><br/><strong>Fast-forward</strong><br/><strong> user-schema.js | 0</strong><br/><strong> 1 file changed, 0 insertions(+), 0 deletions(-)</strong><br/><strong> create mode 100644 user-schema.js</strong></pre>
<p>Our Git history tree now looks like this:</p>
<pre><strong>$ git log --graph --oneline --decorate --all</strong><br/><strong>* 8a31446 (HEAD -&gt; dev, user-schema/main) Add User Schema</strong><br/><strong>| * 37eb1b9 (social-login/main) Resolve merge conflict</strong><br/><strong>| |\ </strong><br/><strong>| | * 9204a6b (social-login/twitter) Implement Twitter login</strong><br/><strong>| * | 09bc8ac (social-login/facebook) Implement Facebook login</strong><br/><strong>| |/ </strong><br/><strong>| * 8d9f102 Add a blank social-login file</strong><br/><strong>|/ </strong><br/><strong>* cf3221a (master) Add main script and documentation</strong><br/><strong>* 85434b6 Update README.md</strong><br/><strong>* 6883f4e Initial commit</strong></pre>
<div class="mce-root packt_tip">If you're finding it hard to visualize the history, try using a Git client that visualizes the branches for you. For Mac and Windows, there's a free client by Atlassian called Sourcetree. If you're on Linux, you may want to try GitKraken. We will use GitKraken to illustrate the Git branch structure from here on. For example, the preceding figure looks like this on GitKraken: <br/>
<br/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b497310-12f5-46b5-a431-97d19ad1bd14.png" style="width:31.83em;height:15.33em;"/></div>
</div>
<p>Now, we could merge our <kbd>social-login/main</kbd> branch back into <kbd>dev</kbd>, which will produce the following branch structure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f47cfd37-fdf3-49da-bc5f-3d74af8af0ae.png" style="width:33.33em;height:16.75em;"/></p>
<p>However, we should not do this because:</p>
<ul>
<li><strong>Breaking changes</strong>: The implementation of the social login feature may depend on the user's schema being of a certain shape. Therefore, blindly merging the <kbd>social-login/main</kbd> branch may result in the platform breaking. The <kbd>dev</kbd> branch is the one that others will develop new features from, and so it should be kept bug-free at all times.</li>
<li><strong>Complicated Git history</strong>: The history tree is already quite hard to read, and we've only implemented two features!</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keeping the dev Branch Bug-Free</h1>
                </header>
            
            <article>
                
<p>The first issue can be tackled by merging the <kbd>dev</kbd> branch into <kbd>social-login/main</kbd>, testing that everything works as normal, and then merging it back into <kbd>dev</kbd>:</p>
<pre><strong>$ git checkout social-login/main</strong><br/><strong>$ git merge dev</strong><br/><strong>$ git checkout dev</strong><br/><strong>$ git merge social-login/main</strong></pre>
<p>This way, any bugs that arise due to the incompatibility of the branches will remain on the feature branch, and not on <kbd>dev</kbd>. This gives us a chance to fix these bugs before merging back into <kbd>dev</kbd>.</p>
<p>While this solved one issue, it exacerbated the other. Our Git history now looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3ab9b8e-5f91-4f51-9381-a2f2861264f0.png" style="width:32.08em;height:17.92em;"/></p>
<div class="packt_tip">Merging the main branch first is not as important for sub-feature branches, because feature branches are not expected to be bug-free at all times. I'd leave it up to the developer responsible for the feature branch to decide how they'd want to work on their feature branch.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keeping our history clean</h1>
                </header>
            
            <article>
                
<p>The reason our Git history looks so complicated is because <kbd>git merge</kbd> creates a separate commit for the merge. This is good because it doesn't alter the history of any of the branches; in other words, it is non-destructive:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d10e089b-1475-4693-8bbf-f6feb8675036.jpg" style="width:24.42em;height:12.50em;"/></div>
<p>To prevent the complicated history tree we have here, Git provides an alternative command, <kbd>rebase</kbd>, that allows us to merge changes, as well as keep our history clean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keeping our history clean with git rebase</h1>
                </header>
            
            <article>
                
<p>With <kbd>git rebase</kbd>, instead of creating a new commit for the merge, it will try to place the changes on the feature branch as if they were made directly after the last commit on the main branch:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d805d1e-7e97-48ab-809f-a92a84d35133.jpg" style="width:33.42em;height:18.08em;"/></div>
<p>To see how we can work with <kbd>rebase</kbd>, let's repeat everything we've done so far, but using <kbd>rebase</kbd> instead of <kbd>merge</kbd>. Create a new directory and open your Terminal, then copy and paste the following commands (which will replicate everything we've done so far):</p>
<pre><strong>git init &amp;&amp;</strong><br/><strong>echo -e "# hobnob" &gt;&gt; README.md &amp;&amp;</strong><br/><strong>git add README.md &amp;&amp; git commit -m "Initial commit" &amp;&amp;</strong><br/><strong>echo "A very simple user directory API with recommendation engine" &gt;&gt; README.md &amp;&amp;</strong><br/><strong>git add README.md &amp;&amp; git commit -m "Update README.md" &amp;&amp;</strong><br/><strong>echo "console.log('Hello World')" &gt;&gt; index.js &amp;&amp;</strong><br/><strong>echo -e "# Usage\nRun \`node index.js\`" &gt;&gt; README.md &amp;&amp;</strong><br/><strong>git add -A &amp;&amp; git commit -m "Add main script and documentation" &amp;&amp;</strong><br/><strong>git checkout -b dev master &amp;&amp;</strong><br/><strong>git checkout -b social-login/main dev &amp;&amp;</strong><br/><strong>touch social-login.txt &amp;&amp;</strong><br/><strong>git add -A &amp;&amp; git commit -m "Add a blank social-login file" &amp;&amp;</strong><br/><strong>git checkout -b social-login/facebook social-login/main &amp;&amp;</strong><br/><strong>echo "facebook" &gt;&gt; social-login.txt &amp;&amp;</strong><br/><strong>git add -A &amp;&amp; git commit -m "Implement Facebook login" &amp;&amp;</strong><br/><strong>git checkout -b social-login/twitter social-login/main &amp;&amp;</strong><br/><strong>echo "twitter" &gt;&gt; social-login.txt &amp;&amp;</strong><br/><strong>git add -A &amp;&amp; git commit -m "Implement Twitter login" &amp;&amp;</strong><br/><strong>git checkout -b user-schema/main dev &amp;&amp;</strong><br/><strong>touch user-schema.js &amp;&amp;</strong><br/><strong>git add -A &amp;&amp; git commit -m "Add User Schema" &amp;&amp;</strong><br/><strong>git checkout dev &amp;&amp;</strong><br/><strong>git merge user-schema/main</strong></pre>
<p>Our Git history tree now looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/34816a4d-4702-4f40-8887-863ad082ffdf.png" style="width:32.58em;height:13.67em;"/></p>
<p>First, we can merge <kbd>social-login/facebook</kbd> into <kbd>social-login/main</kbd>. As no changes have been made on <kbd>social-login/main</kbd> since the branching occurred, it makes no difference whether we use <kbd>git merge</kbd> or <kbd>git rebase</kbd>:</p>
<pre><strong>$ git checkout social-login/main</strong><br/><strong>$ git merge social-login/facebook</strong></pre>
<p>After our merge, there is now a change on the <kbd>social-login/main</kbd> branch since <kbd>social-login/twitter</kbd> branched out from it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/881a5e1d-00f3-474b-ad25-b14496273442.png" style="width:27.00em;height:11.25em;"/></p>
<p class="mce-root"/>
<p>Here's where <kbd>rebase</kbd> is useful:</p>
<pre><strong>$ git checkout social-login/twitter</strong><br/><strong>$ git rebase social-login/main</strong><br/><strong>...</strong><br/><strong>Auto-merging social-login.txt</strong><br/><strong>CONFLICT (content): Merge conflict in social-login.txt</strong><br/><strong>error: Failed to merge in the changes.</strong><br/><strong>Patch failed at 0001 Implement Twitter login</strong><br/><strong>The copy of the patch that failed is found in: .git/rebase-apply/patch</strong></pre>
<p>There's still going to be a merge conflict, and you should resolve it the same way as before. But this time, use <kbd>git rebase --continue</kbd> instead of <kbd>git commit</kbd>:</p>
<pre><strong># Resolve merge conflict before continuing #</strong><br/><br/><strong>$ git add -A</strong><br/><strong>$ git rebase --continue</strong><br/><strong>Applying: Implement Twitter login</strong></pre>
<p>The difference is, this time, the <kbd>git</kbd> history for the social login feature is linear, as if the changes on the <kbd>social-login/twitter</kbd> branch were made straight after those on the <kbd>social-login/main</kbd> branch:</p>
<pre><strong>$ git log --graph --oneline --decorate --all</strong><br/><strong>* da47828 (HEAD -&gt; social-login/twitter) Implement Twitter login</strong><br/><strong>* e6104cb (social-login/main, social-login/facebook) Implement Facebook login</strong><br/><strong>* c864ea4 Add a blank social-login file</strong><br/><strong>| * 8f91c9d (user-schema/main, dev) Add User Schema</strong><br/><strong>|/ </strong><br/><strong>* d128cc6 (master) Add main script and documentation</strong><br/><strong>* 7b78b0c Update README.md</strong><br/><strong>* d9056a3 Initial commit</strong></pre>
<p>Next, we need to fast-forward the <kbd>social-login/main</kbd> branch to follow the <kbd>social-login/twitter</kbd> branch:</p>
<pre><strong>$ git checkout social-login/main</strong><br/><strong>$ git merge social-login/twitter</strong></pre>
<p class="mce-root"/>
<p>This should produce a much cleaner branch structure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/499b21c5-8fe4-45f0-944f-6c5793fabf89.png" style="width:32.42em;height:14.33em;"/></p>
<p>Lastly, we can <kbd>rebase</kbd> our <kbd>social-login/main</kbd> branch onto the <kbd>dev</kbd> branch:</p>
<pre><strong>$ git checkout social-login/main</strong><br/><strong>$ git rebase dev</strong></pre>
<p>Now, we have a completely linear commit history on the <kbd>social-login/main</kbd> branch, even though they all originated from different branches:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dd8b2921-edb7-4f3b-9e4c-a2965336c125.png" style="width:32.92em;height:20.58em;"/></p>
<p>The last thing to do is to forward the <kbd>dev</kbd> branch to where the <kbd>social-login/main</kbd> branch is:</p>
<pre><strong>$ git checkout dev</strong><br/><strong>$ git merge social-login/main</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using merge and rebase together</h1>
                </header>
            
            <article>
                
<p>I might have given the impression that <kbd>git rebase</kbd> is cleaner, and thus better, than <kbd>git merge</kbd>. This is not the case; there are pros and cons for each method.</p>
<p><kbd>git rebase</kbd> rewrites, or alters, the existing history of the repository by trying to replicate changes on the sub-branch at the end of the main branch. This makes the history look cleaner and more linear, but loses the context of when and where changes are integrated together <span>–</span> we lose the information that <kbd>social-login/twitter</kbd> was originally branched off from <kbd>social-login/main</kbd>.</p>
<p>So, I'd advise using<span> </span><kbd>git rebase</kbd><span> </span>for feature/bug-fix branches. This allows you to commit small and often, making <strong>work-in-progress (WIP) commits</strong>, without having to care too much about cleanliness. After your feature is complete, you can then clean up your commit history using <kbd>git rebase</kbd>, before merging into the permanent branches.</p>
<p>On the other hand, when integrating changes from a feature branch into the <kbd>dev</kbd> branch, or from the<span> </span><kbd>dev</kbd> branch into<span> </span><kbd>master</kbd>, use<span> </span><kbd>git merge</kbd><span> </span>because it provides context as to where and when those features were added. Furthermore, we should add a <kbd>--no-ff</kbd> flag to <kbd>git merge</kbd>, which ensures the merge will <em>always</em> create a new commit, even when fast-forwarding is possible.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48001ea6-1778-4bf5-84ef-fee80690c1f6.jpg" style="width:23.75em;height:22.50em;"/></div>
<p class="mce-root"/>
<p>By combining both <kbd>git merge</kbd> and <kbd>git rebase</kbd>, it is possible to end up with a nice Git history:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/666d284e-c689-475d-a5b6-98291aaf6985.png" style="width:34.33em;height:17.00em;"/></div>
<p>We can even delete some branches to make the history even cleaner:</p>
<pre><strong>$ git branch -D social-login/facebook social-login/twitter</strong></pre>
<p>The branch structure is now much simpler to comprehend:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5862a7ab-fcf5-4dfc-a3b0-003db63b30d0.png" style="width:35.33em;height:17.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Releasing code</h1>
                </header>
            
            <article>
                
<p>We now have a sizable chunk of features that we can release. We should create a release branch from <kbd>dev</kbd>. This release branch should be named after the version of the release, prefixed by <kbd>release/</kbd>, such as <kbd>release/0.1.0</kbd>. The code to be released should then be deployed to a staging server, where automated UI testing, manual testing, and acceptance testing should be conducted (more on these later). Any bug fixes should be committed on the release branch and merged back into the <kbd>dev</kbd> branch. <span>When the release branch is ready, it can then be merged into </span><kbd>master</kbd><span>.</span></p>
<div class="packt_infobox"><span>No new features should be added to the release branch except bug fixes and hotfixes. Any new features, non-critical bug fixes, or bug fixes that are unrelated to the release should be committed to a bug-fix branch.</span></div>
<p>So, the first question is how do we name/version our releases? For this project, we'll use <strong>semantic versioning</strong>, or <strong>semver</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Semantic versioning</h1>
                </header>
            
            <article>
                
<p>In semver, everything is versioned with three digits,<span> </span><kbd>MAJOR.MINOR.PATCH</kbd>, which start at<span> </span><kbd>0.1.0</kbd><span> </span>and are incremented as follows:</p>
<ul>
<li><strong>Patch</strong>: After a backward-compatible hotfix</li>
<li><strong>Minor</strong>: After a backward-compatible set of features/bug fixes have been implemented</li>
<li><strong>Major</strong>: After a backward-incompatible change</li>
</ul>
<p>We will be following semantic versioning for our releases.</p>
<div class="packt_tip">As with naming feature branches, there are no "right" ways to name release branches. For example, you can suffix the release version with a brief description of what is included in this release, such as <kbd>release/0.1.0-social-login</kbd> or <kbd>release/0.1.0__social-login</kbd>. Again, the most important thing is to have a rule and be consistent with it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a release branch</h1>
                </header>
            
            <article>
                
<p>Now, let's create our release branch and name it <kbd>release/0.1.0</kbd>:</p>
<pre><strong>$ git checkout dev</strong><br/><strong>$ git checkout -b release/0.1.0</strong></pre>
<p>If this was a real scenario, we'd deploy the branch onto a staging server for it to be more thoroughly tested. For now, let's assume we have found a bug: the text for <kbd>facebook</kbd> and <kbd>twitter</kbd> inside <kbd>social-login.txt</kbd> should be capitalized to <kbd>Facebook</kbd> and <kbd>Twitter</kbd>. So, let's make that fix and commit it directly on the release branch:</p>
<pre><strong>$ git checkout release/0.1.0</strong><br/><strong>$ echo -e "Facebook\nTwitter" &gt; social-login.txt</strong><br/><strong>$ git add -A &amp;&amp; git commit -m "Fix typo in social-login.txt"</strong></pre>
<p>Now, we would test the revised code again, and assuming there are no more bugs, we can merge it into <kbd>master</kbd>:</p>
<pre><strong><span class="gp">$</span> git checkout master
<span class="go">Switched to branch 'master'</span>
<span class="gp">$</span> git merge --no-ff release/0.1.0</strong></pre>
<p>When we merge, it will ask us for a commit message; we can just stick with the default message, <kbd>Merge branch 'release/0.1.0'</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/125a779d-fcaf-4d62-ab10-71152381fc3c.png" style="width:38.58em;height:20.42em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Lastly, we should remember to apply the bug fixes we made on the release branch back into <kbd>dev</kbd>; if we have any other active release branches, we should apply it to those as well:</p>
<pre><strong>$ git checkout dev</strong><br/><strong>$ git merge --no-ff release/0.1.0</strong></pre>
<p>We end up with a Git branch structure similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c3309c6-df1a-4ce6-a8cf-1b899eb350ce.png" style="width:38.42em;height:24.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tagging releases</h1>
                </header>
            
            <article>
                
<p>Lastly, we should tag our release. <strong>Tags</strong>, in Git, are markers that highlight certain points in the commit history as being important. Releases are important, so the convention is to represent releases as tags on the <kbd>master</kbd> branch.</p>
<p>There are two types of tags:<span> </span><strong>lightweight</strong><span> </span>and<span> </span><strong>annotated</strong> tags. A lightweight tag is simply a pointer to a particular commit. Annotated tags are, on the other hand, full objects in the Git database, similar to a commit. Annotated tags contain information about the tagger, the date, and an optional message. We should use annotated tags to tag releases.</p>
<div class="packt_infobox">The Git Manual (accessible when you run<span> </span><kbd>git tag --help</kbd>) states <em>"</em>Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels."</div>
<p class="mce-root"/>
<p>Check out the <kbd>master</kbd> branch and add an annotated tag by running <kbd>git tag</kbd> with the <kbd>-a</kbd> flag. The name of the tag should be the semver version, and you should also add a message describing the release:</p>
<pre><strong><span class="gp">$ git checkout master<br/>$</span> git tag -a 0.1.0 -m "Implement social login. Update user schema."</strong><br/><strong>$ git show 0.1.0</strong><br/><strong>tag 0.1.0</strong><br/><strong>Tagger: Daniel Li &lt;dan@danyll.com&gt;</strong><br/><strong>Date: Fri Dec 8 21:11:20 2017 +0000</strong><br/><strong>Implement social login. Update user schema.</strong><br/><br/><strong>commit 6a415c24ea6332ea3af9c99b09ed03ee7cac36f4 (HEAD -&gt; master, tag: 0.1.0)</strong><br/><strong>Merge: b54c9de 62020b2</strong><br/><strong>Author: Daniel Li &lt;dan@danyll.com&gt;</strong><br/><strong>Date: Fri Dec 8 18:55:17 2017 +0000</strong><br/><strong>    Merge branch 'release/0.1.0'</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hotfixes</h1>
                </header>
            
            <article>
                
<p>The last thing we need to cover for our Git workflow is how to deal with bugs we discover in production (on our <kbd>master</kbd> branch). Although our code should have already been thoroughly tested before being added to <kbd>master</kbd>, subtle bugs are bound to slip through, and we must fix them quickly. This is call a <strong>hotfix</strong>.</p>
<p>Working on a hotfix branch is very similar to working on a release branch; the only difference is that we are branching off <kbd>master</kbd> instead of <kbd>dev</kbd>. Like with release branches, we'd make the changes, test it, deploy it onto a staging environment, and perform more testing, before merging it back into <kbd>master</kbd>, <kbd>dev</kbd>, and any current release branches:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5ded1335-7fee-4fa1-aa3d-459e093b9a07.jpg" style="width:18.92em;height:32.42em;"/></div>
<p>So, first we make the fix:</p>
<pre><strong>$ git checkout -b hotfix/user-schema-incompat master</strong><br/><strong>$ touch user-schema-patch.txt # Dummy hotfix</strong><br/><strong>$ git add -A</strong><br/><strong>$ git commit -m "Patch user schema incompatibility with social login"</strong></pre>
<p>Then, we merge it into <kbd>master</kbd>:</p>
<pre><strong>$ git checkout master</strong><br/><strong>$ git merge --no-ff hotfix/user-schema-incompat</strong></pre>
<p><span>As we have added something new to master, it essentially becomes a new release and therefore we need to increase the version number and tag this new commit. Since this is a bug fix and adds no new features to the platform, we should increase the patch version to</span> <kbd>0.1.1</kbd><span>:</span></p>
<pre><strong>$ git tag -a 0.1.1 -m "Patch user schema incompatibility with social login"</strong></pre>
<p>Lastly, don't forget to merge the hotfix changes back into <kbd>dev</kbd> and, if relevant, other release branches:</p>
<pre><strong>$ git checkout dev</strong><br/><strong>$ git merge --no-ff hotfix/user-schema-incompat</strong></pre>
<p>Our Git history tree now looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21e31e8d-d5a3-440c-9234-2a40ed2c4bd5.png" style="width:37.58em;height:26.67em;"/></p>
<p>You can clearly distinguish the two permanent branches, <kbd>master</kbd> and <kbd>dev</kbd>, as everything seems to revolve around them. However, it's also clear that adding a hotfix makes the Git history more complicated than before, and so hotfixes should only be made when absolutely necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with others</h1>
                </header>
            
            <article>
                
<p>So far, we've outlined how to manage our Git repository when developing by ourselves; however, more often than not, you'll work as part of a team. In those instances, your team must work in a way that allows your colleagues to get the updates you have done, as well as update others on their own changes.</p>
<p>Fortunately, Git is a <em>distributed</em> VCS, which means any local repository can act as the remote repository for someone else. This means your colleagues can <strong>pull</strong> your changes onto their machine, and you can pull their changes onto yours:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/5d48350d-651b-48e7-8701-aed7f7e1181d.png" style="width:22.33em;height:11.25em;"/> </div>
<p class="mce-root"/>
<p>However, this would mean you'd have to pull from everybody's machine regularly to get all the latest changes. Furthermore, where there are merge conflicts, one person might resolve them differently to another.</p>
<p>So while it is technically possible to follow this distributed workflow, most teams elect a single repository that they consider to be the central one.</p>
<p class="mce-root"/>
<p>By convention, this remote repository is called <kbd>origin</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/201c4432-d7b1-491e-8290-6d5df17faa1c.jpg" style="width:23.50em;height:21.17em;"/></p>
<p>When you want to update your local repository with changes made by your colleagues, you <em>pull</em> from the <kbd>origin</kbd> repository. When you have changes that you think are ready to be incorporated, you push them into <kbd>origin</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a remote repository</h1>
                </header>
            
            <article>
                
<p>There are many ways to host a remote repository. You can set up your own server, or you can use a hosted service such as Bitbucket or GitHub. We are going to use GitHub as it is the most popular, and is free for public repositories.</p>
<div class="packt_tip">If you'd like to keep your repository private, you can either pay for a personal plan from GitHub, which is currently set at $7 per month; or you can use BitBucket, which is free for both public and private repositories (although other limits apply).</div>
<ol>
<li>Go to <a href="https://github.com/" target="_blank">https://github.com/</a> and click on the <span class="packt_screen">Sign Up</span> button</li>
<li>Fill in your details to create an account</li>
<li>Once logged in, click on the <span class="packt_screen">New Repository</span> button or go to <a href="https://github.com/new" target="_blank">https://github.com/new</a></li>
</ol>
<ol start="4">
<li>Fill in the details about the repository, but do <em>not</em> check the <span class="packt_screen">Initialize this repository with a README</span> box or add a license:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/828c152c-7255-4b3e-b2ca-53f007cf6238.png" style="width:47.50em;height:39.75em;"/></div>
<ol start="5">
<li>After you press <span class="packt_screen">Create repository</span>, GitHub should show a <span class="packt_screen">Quick setup</span> tooltip. This indicates that we have now successfully created our repository:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e0038e9c-ec93-4099-a58c-30a4b9d2bcde.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pulling and pushing</h1>
                </header>
            
            <article>
                
<p>Next, we need to update our local repository so it knows the address of the remote repository:</p>
<pre class="f5 js-zeroclipboard-target"><strong><span class="user-select-contain">$ git remote add origin <span class="js-git-clone-help-text">https://github.com/d4nyll/hobnob.git<br/></span></span></strong><span class="user-select-contain"><strong>$ </strong><strong>git push -u origin master</strong><br/></span></pre>
<div class="packt_tip">Don't use <kbd>https://github.com/d4nyll/hobnob.git</kbd>; create your own remote <span>repository instead.<br/>
If you get a <kbd>fatal: Authentication failed for https://github.com/d4nyll/hobnob.git/</kbd> error, check that your GitHub username and password are entered properly. If you use two-factor authentication (2FA) on your GitHub account, you need to use an SSH key to push to the remote repository.</span></div>
<p>The <kbd>-u</kbd> tag sets the upstream repository to be <kbd>origin</kbd>. Without it, we would have to specify which remote repository we want to push to or pull from every time we run <kbd>git push</kbd> and <kbd>git pull</kbd>; using the <kbd>-u</kbd> tag here will save us a lot of time in the future. Subsequent pushes and pulls can omit the <kbd>-u</kbd> tag.</p>
<p>By default, <kbd>git push</kbd> doesn't push tags to remote repositories. So, we'd have to push tags manually. The syntax for pushing tags is similar to that of pushing branches:</p>
<pre><span><strong>$</strong> <strong>git push origin [tagname]</strong></span></pre>
<p>Alternatively, if you want to push all tags, you can run the following command instead:</p>
<pre><strong>$</strong> <strong>git push origin --tags</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloning a repository</h1>
                </header>
            
            <article>
                
<p>Our code is now publicly <span>available </span>on GitHub. Our colleagues and/or collaborators can now download the code using the <kbd>git clone</kbd> command:</p>
<pre><strong>$</strong> <strong>git clone https://github.com/d4nyll/hobnob.git</strong></pre>
<p>This will create a new directory inside the directory where the <kbd>git clone</kbd> command was run, and copy the contents of the remote repository into it.</p>
<p>Your collaborators can then work on this local copy of the repository, commit changes, and add new branches. Once they are ready to make their changes available to others, they can pull from the remote repository, resolve merge conflicts, and then push their changes back to <kbd>origin</kbd>:</p>
<pre><strong>$ git pull</strong><br/><strong># Resolves any conflicts</strong><br/><strong>$ git push</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conducting peer review through pull requests</h1>
                </header>
            
            <article>
                
<p>Most of the time, it's fine to allow anyone to push to and pull from the repository. However, for more important projects, you may wish to prevent new or junior developers from pushing to important branches such as <kbd>dev</kbd> and <kbd>master</kbd>. In those instances, the owner of the repository may restrict push rights to only a small selection of trusted developers.</p>
<p>For non-trusted developers, in order to make a change to <kbd>dev</kbd> or <kbd>master</kbd>, they must create a new branch (such as a feature or bug-fix branch), push to that branch, and create a <strong>pull request</strong> (<strong>PR</strong>). This PR is a formal request for their branch to be merged back to <kbd>dev</kbd> or <kbd>master</kbd>.</p>
<div class="packt_infobox">Pull requests are a feature of platforms such as GitHub and BitBucket, and not of Git itself.</div>
<p>After receiving a pull request, the owner or maintainer will review your work and provide feedback. On GitHub, this is done through comments. The contributor will then work with the maintainers and make changes to the code until both are happy with the changes. At this point, the maintainer will accept your pull request and merge it into the intended branch:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dccd81d3-74fb-4ba8-afea-c142101a1d61.png" style="width:38.17em;height:46.92em;"/></p>
<p>Conversely, if the maintainers do not feel the changes are in line with the goals of the project, they can reject them.</p>
<p>Implementing pull requests in your development process has several benefits:</p>
<ul>
<li>You can notify your peers that a feature/bug fix has been completed.</li>
<li>It is a formal process where all comments and discussions are logged.</li>
<li>You can invite reviewers to peer-review the changes you've made. This allows them to help spot obvious errors, as well as to provide feedback on your code. This not only ensures the code quality of the source code is high, it also helps the developer learn from other people's experience.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we outlined how to manage your project's version history using Git. We started by understanding the different states in Git and practicing some basic Git commands, and using them to commit, branch, and merge our changes. We then set up a remote repository on GitHub, which allowed us to share our code and collaborate with others.</p>
<p>The workflow and conventions used here are opinionated, and you may come across different patterns in your workplace. There is no right way to use Git, only wrong ways, and the rules we used here are not perfect. For example, in the Driessen model, o<span>nce a feature is merged into <kbd>dev</kbd>, it will be hard to extract it. Therefore, we have to be careful not to merge in features that are not meant for the current release. Therefore, t</span><span>he most important takeaway from this chapter is to establish a set of conventions with your team, and stick to it consistently.</span></p>
<p>In the next chapter, we will start writing our first lines of code, setting up our development environments and tools, and integrating with JavaScript-specific tools, such as <kbd>npm</kbd>, <kbd>yarn</kbd>, Babel, and <kbd>nodemon</kbd>. <span>For the rest of this book, as you work through the exercises and build the application, we expect you to use the workflow outlined here to keep a version history of your code.</span></p>


            </article>

            
        </section>
    </body></html>