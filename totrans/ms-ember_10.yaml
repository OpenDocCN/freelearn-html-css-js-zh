- en: Chapter 10. Testing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 测试您的应用程序
- en: 'Testing is an important activity conducted on any software project. Tests automate
    bug checks and ensure that new features not only work as expected but also don''t
    introduce undesired behavior. Ambitious Ember.js projects, therefore, need to
    be well tested in order to guarantee their stability and ensure satisfying user
    experiences. Therefore, by the end of this chapter, we should be able to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是在任何软件项目中进行的重要活动。测试自动化了错误检查，并确保新功能不仅按预期工作，而且不会引入不希望的行为。因此，雄心勃勃的Ember.js项目需要经过良好的测试，以确保其稳定性和确保满意的用户体验。因此，在本章结束时，我们应该能够：
- en: Test object-computed properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试对象计算属性
- en: Test object observers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试对象观察者
- en: Test controllers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试控制器
- en: Test views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试视图
- en: Test components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Test user journeys
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用户旅程
- en: Writing tests
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'Ember.js supports writing the following two common types of tests:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js支持编写以下两种常见的测试类型：
- en: Unit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元
- en: Integration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成
- en: 'Unit tests test a specific attribute of a class (or instance) defined in an
    application. For example, think of scenarios such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试测试应用程序中定义的类（或实例）的特定属性。例如，考虑以下场景：
- en: A created user object has a name
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建的用户对象有一个名称
- en: A user's full name is computed properly from their first and last name
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户的首名和姓氏正确计算出用户的完整姓名
- en: A book model is validated properly before being saved to the server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在保存到服务器之前，图书模型得到了正确的验证
- en: An observer reacts to changes correctly
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者正确地响应了变化
- en: 'Integration tests, on the other hand, test user journeys and important application
    workflows; for example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试另一方面，测试用户旅程和重要的应用程序工作流程；例如：
- en: Only authenticated users can access the app
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有经过身份验证的用户才能访问应用程序
- en: Submitting a form persists the form data to a store, and redirects the user
    back to a listing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交表单将表单数据持久化到存储中，并将用户重定向回列表页
- en: Clicking on a checkout button adds the product to a cart
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击结账按钮将产品添加到购物车
- en: In this chapter, we will be testing a simple implementation of a typical e-commerce
    site that you can load via the `index.html` file located in the chapter sample.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将测试一个典型的电子商务网站的简单实现，您可以通过位于章节示例中的`index.html`文件来加载它。
- en: '![Writing tests](img/00018.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![编写测试](img/00018.jpeg)'
- en: 'The site in the preceding screenshot has the following features:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前一截图中的网站具有以下功能：
- en: Users can order meals to be delivered at specified locations
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以订购要送至指定地点的餐点
- en: Admins can log in to the site to add new meals
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可以登录网站添加新餐点
- en: Admins can see orders
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可以查看订单
- en: 'To test the admin interface, log in with the username `admin` and password
    `pass`. The application has been tested with the help of the following libraries:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试管理员界面，请使用用户名`admin`和密码`pass`登录。该应用程序已通过以下库进行测试：
- en: 'Mocha.js ([http://visionmedia.github.io/mocha](http://visionmedia.github.io/mocha)):
    This is a testing library'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha.js ([http://visionmedia.github.io/mocha](http://visionmedia.github.io/mocha))：这是一个测试库
- en: 'Sinon.js ([http://sinonjs.org/](http://sinonjs.org/)): This is the spies, stubs,
    and mocks library'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sinon.js ([http://sinonjs.org/](http://sinonjs.org))：这是一个间谍、存根和模拟库
- en: 'Chai.js ([http://chaijs.com](http://chaijs.com)): This is an assertion library'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai.js ([http://chaijs.com](http://chaijs.com))：这是一个断言库
- en: The Ember mocha adapter ([https://github.com/teddyzeenny/ember-mocha-adapter](https://github.com/teddyzeenny/ember-mocha-adapter))
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember mocha适配器 ([https://github.com/teddyzeenny/ember-mocha-adapter](https://github.com/teddyzeenny/ember-mocha-adapter))
- en: 'Loading `test.html` in the browser runs the two types of tests located at `test.integration.js`
    and `test.unit.js`, as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载`test.html`将运行位于`test.integration.js`和`test.unit.js`中的两种测试类型，如下截图所示：
- en: '![Writing tests](img/00019.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![编写测试](img/00019.jpeg)'
- en: 'If we examine the test loader file content, we see that the testing framework
    required the following element to be created:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查测试加载器文件的内容，我们会看到测试框架需要创建以下元素：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the element in which the test report was rendered. We also needed to
    create our application''s root element in the same way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试报告渲染的元素。我们还需要以相同的方式创建我们应用程序的根元素：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Near the bottom of the file, the application scripts were loaded in order,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件底部附近，按照以下顺序加载了应用程序脚本：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, the testing libraries were loaded:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加载了测试库：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Ember.js comes with test utilities that help write these tests. These test
    helpers are meant to be used with any testing library of your choice. In our case,
    we used Mocha.js, a popular, easy-to-use library. The first task we needed to
    do was set up the test environment. This was done by first defining the root element
    of the Ember.js application. This ensured that the Ember.js application was only
    executed within the element and didn''t affect other parts of the testing environment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js自带了测试工具，有助于编写这些测试。这些测试助手旨在与任何你选择的测试库一起使用。在我们的例子中，我们使用了Mocha.js，这是一个流行且易于使用的库。我们首先需要完成的任务是设置测试环境。这是通过首先定义Ember.js应用程序的根元素来完成的。这确保了Ember.js应用程序只在该元素内执行，不会影响测试环境的其他部分：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then needed to run the `setupForTesting` method of the application. This
    deferred the readiness of the application for later execution during testing.
    It also prevented the tests from manipulating the window''s location:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要运行应用程序的`setupForTesting`方法。这延迟了应用程序的可用性，以便在测试期间稍后执行。它还防止了测试操作窗口的位置：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also needed to call another method, `injectTestHelpers`, which injected
    Ember.js test helpers into the test environment:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调用另一个方法，`injectTestHelpers`，它将Ember.js测试助手注入到测试环境中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We finally loaded and executed the tests included in the two files, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终加载并执行了两个文件中包含的测试，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice that, for each of the tests, we defined `beforeEach` and `afterEach`
    hooks that got called before and after the test was executed, respectively:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，对于每个测试，我们都定义了`beforeEach`和`afterEach`钩子，分别用于在测试执行前后被调用：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For example, the default pre-test run hook used the `visit` helper to transition
    the app into the `index` route, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，默认的预测试运行钩子使用了`visit`助手将应用程序过渡到`index`路由，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The post-test hook, on the other hand, resets the application state after each
    test by destroying such instances as the Ember-data store:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，测试后的钩子通过销毁如Ember-data存储这样的实例来在每个测试后重置应用程序状态：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ember.js comes with a number of test helpers that we will be using to help us
    in writing tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js自带了许多测试助手，我们将使用它们来帮助我们编写测试。
- en: Asynchronous test helpers
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步测试助手
- en: 'These helpers are used to perform asynchronous operations. This means that,
    if used, the next bunch of tests needs then to be wrapped in a run loop function.
    They include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些助手用于执行异步操作。这意味着如果使用它们，下一组测试需要被包裹在一个运行循环函数中。它们包括以下内容：
- en: '`visit(url)`: This performs an asynchronous application transition into the
    provided URL route.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visit(url)`: 这个方法执行异步应用程序转换到提供的URL路由。'
- en: '`fillIn(selector, text)`: This is used to asynchronously set the value of an
    input that matches the given selector with the given text.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillIn(selector, text)`: 这个方法用于异步设置匹配给定选择器的输入的值，并使用给定的文本。'
- en: '`click(selector)`: This is used to trigger a click event on an element that
    matches the given selector. This is good for the `triggerEvent(selector, "click")`
    helper.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click(selector)`: 这个方法用于在匹配给定选择器的元素上触发点击事件。这对于`triggerEvent(selector, "click")`助手很有用。'
- en: '`keyEvent(selector, type, keyCode)`: This is used to trigger a key event on
    the given selector.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyEvent(selector, type, keyCode)`: 这个方法用于在给定的选择器上触发一个按键事件。'
- en: '`triggerEvent(selector, type, options)`: This is used to trigger other DOM
    events on the given selector.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`triggerEvent(selector, type, options)`: 这个方法用于在给定的选择器上触发其他DOM事件。'
- en: Synchronous test helpers
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步测试助手
- en: 'These helpers are used to perform synchronous operations. They include the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些助手用于执行同步操作。它们包括以下内容：
- en: '`find(selector, context)`: This helper is used to perform an element selection
    within the given optional context'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find(selector, context)`: 这个助手用于在给定的可选上下文中执行元素选择。'
- en: '`currentPath()`: This is used to get the current application''s route path'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentPath()`: 这个方法用于获取当前应用程序的路由路径'
- en: '`currentRouteName()`: This is used to get the name of the current application
    route'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentRouteName()`: 这个方法用于获取当前应用程序路由的名称'
- en: '`currentURL()`: This is used to get the URL of the current route'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentURL()`: 这个方法用于获取当前路由的URL'
- en: Wait helpers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待助手
- en: 'There is currently only one helper of this type: `andThen`. It is used to run
    a block of test operations after the previous asynchronous operations have been
    completed.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有一种此类助手：`andThen`。它在之前的异步操作完成后运行一系列测试操作。
- en: Writing unit tests
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Unit testing involves testing object-computed properties, observers, and method
    calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试涉及测试对象计算属性、观察者和方法调用。
- en: Testing computed properties
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试计算属性
- en: 'Let''s start by looking at the first tested object-computed property in the
    chapter sample, the `total` property of `App.CartItem`, that is applied from `App.TotalMixin`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章示例中的第一个测试对象-计算属性开始，即`App.CartItem`的`total`属性，它是由`App.TotalMixin`应用而来的：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When a user clicks on the order button of a meal, we expect the cart to be
    filled by the new item. We also expect the item''s `total` property to be incremented,
    which is ascertained as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击餐点的订单按钮时，我们期望购物车被新项目填充。我们还期望项目的`total`属性会增加，这如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First, we created an order and verified that its total defaulted to zero. We
    then updated its quantity and price and ascertained that the total was computed
    properly in each case. We also did the same for the `App.Order` model, this time
    creating the order from the store:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个订单并验证其总额默认为零。然后我们更新了其数量和价格，并确认在每种情况下总额都被正确计算。我们也对`App.Order`模型做了同样的操作，这次是从商店创建订单：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note how the store instance was referenced from the main application container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何从主应用程序容器中引用存储实例。
- en: Testing method calls
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试方法调用
- en: 'The app contains a mixin `App.OnhasMixin` that defines a function `onhas` that
    invokes a given callback if the property being bound is defined or as soon as
    it gets set. This is comparable to a situation where you can either buy a new
    computer now if you have the money or wait till you get a pay check. We started
    by testing the first case:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包含一个混合`App.OnhasMixin`，它定义了一个`onhas`函数，如果正在绑定的属性已定义或一旦被设置，就会调用给定的回调。这相当于一种情况，即如果您有足够的钱，您现在可以购买一台新电脑，或者等到您收到工资支票。我们首先测试了第一种情况：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, the function fired as the object already contained the `id` property.
    We simply needed to pass the callback `done` provided by the Mocha test runner.
    The second test case asserts that the callback is called only when the bound property
    gets set as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数在对象已经包含`id`属性时被触发。我们只需要传递由Mocha测试运行器提供的回调`done`。第二个测试用例断言只有当绑定属性按如下方式设置时，回调才会被调用：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Testing observers
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试观察者
- en: 'One of the observers, `App.UserController#storeUser`, stores the username of
    the current logged-in user to the local storage:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个观察者`App.UserController#storeUser`将当前登录用户的用户名存储到本地存储中：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To test the observer, we first cleared any stored user in the local storage
    in the pre-test hook:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试观察者，我们在预测试钩子中首先清除了本地存储中存储的任何用户：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then created the user controller, set the user, and asserted that the user
    is actually stored in the browser''s local store:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了用户控制器，设置了用户，并断言用户实际上被存储在浏览器的本地存储中：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also set up a spy using **Sinon.js** to record the observer invocations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用**Sinon.js**设置了一个间谍来记录观察者的调用：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The spy, as shown in the preceding code, enabled us to verify that the observer
    subscribed properly to the property changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，间谍（spy）使我们能够验证观察者是否正确订阅了属性变化。
- en: Writing integration tests
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: 'We now already know that integration tests test the import workflows and user
    journeys in an application. The Ember.js framework is well tested; reviewing these
    tests can help a great deal in learning how to write tests for your application.
    Many features such as bindings and observers are already tested, so you will be
    writing more integration tests than unit tests. The integration tests in the chapter
    sample cover virtually all user interactions in the application. We will first
    go through all consumer-related cases, the first of which ascertains that users
    can see the available meals on the first page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道集成测试测试应用程序中的导入工作流程和用户旅程。Ember.js框架经过了良好的测试；审查这些测试对于学习如何为您的应用程序编写测试非常有帮助。许多功能，如绑定和观察者，已经过测试，因此您将编写比单元测试更多的集成测试。本章示例中的集成测试涵盖了应用程序中几乎所有的用户交互。我们将首先遍历所有与消费者相关的案例，首先是确认用户可以在第一页看到可用的餐点：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This example shows the use of the synchronous `find` helper, which returned
    the elements that listed the meals. We also checked whether the meal attributes
    were being displayed correctly to the user:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了同步`find`辅助函数的使用，它返回了列出餐点的元素。我们还检查了餐点属性是否被正确地显示给用户：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our next check verified that the cart link on the navigation bar indicated
    that the cart was empty:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的检查验证了导航栏上的购物车链接表明购物车是空的：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next to the cart link, we also ascertained that users were able to see the
    login link:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在购物车链接旁边，我们还确认用户能够看到登录链接：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we checked whether the customer was also able to see the site branding:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查了客户是否也能看到网站品牌：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next set of test cases verified that users would be able to add products
    to the cart. Before each test case, we triggered a click event on the checkout
    button of the first meal to add the meal to the cart:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试用例集验证了用户是否能够将产品添加到购物车中。在每个测试用例之前，我们在第一顿饭的结账按钮上触发一个点击事件，将饭添加到购物车：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first test checked whether the desired meal was actually added to the cart:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试检查了是否将所需的饭菜实际添加到了购物车：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We first queried this product from the store and then asserted that it was
    indeed added to the cart controller. We also asserted that the cart item contained
    the expected attributes: `product`, `price`, and `quantity`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从商店查询了这个产品，然后断言它确实被添加到了购物车控制器中。我们还断言购物车项目包含预期的属性：`product`、`price`和`quantity`。
- en: 'By then, we expected the cart link counter indicator to be incremented:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们预计购物车链接计数指示器会增加：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also expected the user to have been transitioned to the cart page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还预计用户已经过渡到购物车页面：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The proceeding tests tested the cart page to which our user has transitioned.
    First, we tested that viewing an empty cart page presents an appropriate message:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的测试测试了用户过渡到的购物车页面。首先，我们测试了查看空购物车页面会显示适当的消息：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then tested the page for when the cart was filled, by first adding two items
    to the cart in the pre-test hook:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们测试了当购物车被填满时的页面，首先在预测试钩子中向购物车添加两个项目：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We used the `controller.addItem` method to add the two products to the cart.
    Just as in the preceding test case, we asserted that the cart link indicated that
    two cart items had been added to the cart, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`controller.addItem`方法将两个产品添加到购物车。就像先前的测试用例一样，我们断言购物车链接表明已向购物车添加了两个购物车项目，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The cart page contains a table that shows the cart details. It also contains
    additional information to the left; one of these is the cart total:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车页面包含一个显示购物车详情的表格。它还包含左侧的附加信息；其中之一是购物车总金额：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `find` helper returned the label that displayed the order total. We got
    its `textContent` and asserted that it was equal to the order total. We then proceeded
    to test the cart table by first ensuring that the relevant table header cells
    were displayed in the right order:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`辅助函数返回显示订单总金额的标签。我们获取其`textContent`并断言它等于订单总金额。然后我们继续测试购物车表格，首先确保相关的表头单元格按正确的顺序显示：'
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we tested the table body:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们测试了表格体：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code tests the first row of the table by asserting that it displays
    the expected values. For the third cell, we test that the input contains the expected
    product quantity. The user is free to adjust the product amount using this input.
    We test this in the next test case. First, we update the input to a new value,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过断言它显示预期的值来测试表格的第一行。对于第三列，我们测试输入包含预期的产品数量。用户可以使用此输入自由调整产品数量。我们在下一个测试用例中测试这一点。首先，我们将输入更新为新值，如下所示：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then allow any triggered operations to finish before we assert that the
    quantity in the cart was updated:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们允许任何触发的操作完成，在我们断言购物车中的数量已更新之前：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This assertion shows how to use the `fillIn` helper to asynchronously update
    the value of an input. We also asserted that the cart total was updated as a result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言展示了如何使用`fillIn`辅助函数异步更新输入的值。我们还断言购物车总金额已更新：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the user is satisfied with the order details, they should be able to go
    to the payment page by clicking on the pay button:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户对订单详情满意，他们应该可以通过点击支付按钮转到支付页面：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the user is on the checkout page, if their cart is empty an appropriate
    message will be shown:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户进入结账页面，如果他们的购物车为空，将显示适当的消息：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the cart is not empty, the user sees a table that summarizes the order:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购物车不为空，用户会看到一个总结订单的表格：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The table body lists the order''s product name alongside its quantity:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表格体列出了订单的产品名称及其数量：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The table also displays the order total:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表格还显示了订单总金额：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The table tested sits on the left-hand side of the page. The main page contains
    a form in which the user enters their payment information before submission. We
    use the `triggerEvent` helper to invoke this event:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的表格位于页面左侧。主页包含一个表单，用户在提交前输入他们的支付信息。我们使用`triggerEvent`辅助函数来调用此事件：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A success message is displayed to the user, notifying them that the order will
    be delivered to them shortly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个成功消息给用户，通知他们订单将很快被送到他们手中：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This tests the payment action defined in the checkout controller:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试了结账控制器中定义的支付动作：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As shown, the cart items are converted to actual orders that the shop admin
    can see:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，购物车项目被转换为商店管理员可以看到的实际订单：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As a recap, you can see the preceding test cases tested the user's journey from
    the index page to the checkout page through the cart page. This is what constitutes
    integration tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回顾，你可以看到前面的测试用例测试了用户从索引页面通过购物车页面到结账页面的旅程。这就是集成测试的构成。
- en: 'The next case will test the admin''s user journey. Admins can get access to
    the admin dashboard by logging into the app on the login page with the right credentials:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个案例将测试管理员的用户旅程。管理员可以通过在登录页面使用正确的凭据登录应用程序来访问管理员仪表板：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A successful login redirects the user to the index route. We also tested the
    case when a user tries to access the admin dashboard with the wrong credentials:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录会将用户重定向到索引路由。我们还测试了当用户尝试使用错误的凭据访问管理员仪表板的情况：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We expect the user to remain in the login route on login failure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望用户在登录失败时保持在登录路由上。
- en: 'Once logged in, the admin should be able to add meals as well as edit or remove
    existing ones. These are covered in the next tests where we first log in as an
    admin into the site via the login helper defined at the bottom of the file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录，管理员应该能够添加餐点以及编辑或删除现有的餐点。这些在下一个测试中得到了覆盖，我们首先通过文件底部定义的登录助手以管理员身份登录到网站：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The application contains a hidden form whose file input prompts the user to
    select a meal image when the list-product component is clicked:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包含一个隐藏的表单，其文件输入提示用户在点击列表产品组件时选择餐点图片：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The corresponding `App.ListProductComponent` defines a click event handler
    that gets invoked when the component is clicked:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`App.ListProductComponent`定义了一个点击事件处理程序，当组件被点击时会被调用：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the user selects a file, the preceding `post` method is called with a
    `FileReader` instance argument, from which we get the URL representation of the
    selected image for storage. You would obviously upload this file to a storage
    service such as S3 or Google Cloud Storage in an actual application, instead.
    We finally create the product, which gets automatically listed in the page. Since
    it''s not possible to update the value of a file input, our next test spec partially
    confirms this by manually adding a product to the cart:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择文件，前面的`post`方法就会调用，并带有`FileReader`实例参数，我们从其中获取所选图片的URL表示形式以进行存储。显然，在实际应用中，你会将此文件上传到存储服务，如S3或Google
    Cloud Storage。我们最终创建产品，它将自动列在页面上。由于无法更新文件输入的值，我们的下一个测试规范通过手动将产品添加到购物车来部分确认这一点：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we triggered the `createProduct` action on the index controller, which
    adds a product to the cart. Note that this is the same action that is called by
    the `post` function. In the next run loop, we asserted that a new product was
    added to the listing. This product''s name and price are undefined, so the next
    test case checks whether the admin can actually edit these products:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在索引控制器上触发了`createProduct`动作，这会将产品添加到购物车中。请注意，这是由`post`函数调用的同一个动作。在下一个运行循环中，我们断言一个新的产品被添加到了列表中。由于这个产品的名称和价格尚未定义，下一个测试用例检查管理员是否真的可以编辑这些产品：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding test case showed that the admin is able to update the product's
    name and price via the provided corresponding inputs. In an actual app, you would
    probably add a `save` button that persisted the changes to the backend.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个测试用例表明管理员能够通过提供的相应输入更新产品的名称和价格。在实际应用中，你可能会添加一个`保存`按钮，以将更改持久化到后端。
- en: 'In the navigation bar, there''s an `orders` link that the user can click on
    to transition to the orders page:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航栏中，有一个用户可以点击以过渡到订单页面的`orders`链接：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The next test ascertains that clicking on the link transitions the user to
    the orders page:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试确认点击链接会将用户过渡到订单页面：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Lastly, the admin is presented with a message if no orders have been made yet.
    However, if orders have been made, the admin should be able to see a table that
    lists them:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果还没有订单，管理员会看到一个消息。然而，如果有订单，管理员应该能够看到列出它们的表格：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We just learned the various test techniques you can use to ensure the stability
    of your application. Since you will mostly be writing integration tests, the best
    approach would be to break your app into clear user journeys. Then, test any expected
    interactions as well as transitions. This would obviously be done when developing
    new features. When testing against external resources, you can use libraries such
    as Sinon to stub these services or extend the test timeout, shown as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了你可以使用的各种测试技术来确保应用程序的稳定性。由于你将主要编写集成测试，最佳方法是将你的应用程序分解为清晰的用户旅程。然后，测试任何预期的交互以及转换。这显然会在开发新功能时进行。当测试外部资源时，你可以使用如
    Sinon 这样的库来模拟这些服务或扩展测试超时，如下所示：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the next chapter, we will learn how to build Ember.js applications that are
    backed by external real-time data and service resources. We will specifically
    learn how to use the popular **socket.io** library within Ember.js applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何构建由外部实时数据和资源支持的应用程序。我们将特别学习如何在 Ember.js 应用程序中使用流行的 **socket.io**
    库。
