- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Custom Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned that a Svelte store is any object that follows
    a Svelte store contract, and encapsulating data within a Svelte store allows the
    data to be shared and used across multiple Svelte components reactively. The Svelte
    component keeps the DOM up to date with the data, even though the data is modified
    outside of the Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about two of Svelte’s built-in methods for creating a Svelte store—namely
    `readable()` and `writable()`, which create a readable and writable store. The
    two methods follow the Svelte contract and create a very basic Svelte store. However,
    besides using a Svelte store to encapsulate data, we can also encapsulate logic
    with the data, making the Svelte store modular and highly reusable.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be creating custom Svelte stores—Svelte stores that
    encapsulate custom data logic. We will go through three distinct examples; each
    example will serve as a guide, brimming with tips and tricks for creating your
    own custom Svelte stores.
  prefs: []
  type: TYPE_NORMAL
- en: First up, we’ll examine how to turn user events into store values, specifically
    turning click counts into a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’ll explore a custom store that goes beyond the basic `set` method
    to modify its value. We’ll look at an undo/redo store, which incorporates additional
    methods for reverting or redoing changes to its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we’ll turn our attention to higher-order stores. While not a custom
    store in itself, a higher-order store is a function that accepts a Svelte store
    as input and returns an enhanced version of it. This chapter includes sections
    on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Svelte store from user events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an undo/redo store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a debounced higher-order Svelte store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, without further ado, let’s dive into creating our first custom Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code in this chapter can be found on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Svelte store from user events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Svelte store stores data, but where does the data come from?
  prefs: []
  type: TYPE_NORMAL
- en: It could be from user interaction or user input, which calls an event handler
    that updates the store value by calling `store.set()`.
  prefs: []
  type: TYPE_NORMAL
- en: What if we can encapsulate the user events and event handler logic into the
    store so that we do not need to call `store.set()` manually?
  prefs: []
  type: TYPE_NORMAL
- en: For example, we are going to have a Svelte store to calculate how many times
    the user clicks on the screen. Instead of manually adding an event listener on
    the document, if there’s a way to create a Svelte store and update it every time
    there’s a new click, how would that look? In short, how about having a custom
    Svelte store that can do all of that for us?
  prefs: []
  type: TYPE_NORMAL
- en: It would be great if we could reuse this Svelte store the next time we have
    a similar need, instead of having to manually set it up again.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s try to implement this click counter custom Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first scaffold the Svelte store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we created a basic Svelte store based on the
    Svelte store contract with just a `subscribe()` method. The value of the store
    is stored in a variable called `clickCount`, and in the `subscribe()` method,
    we keep track of all the subscribers using the `subscribers` array.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we need to synchronously call `fn` in the `subscribe()` method with
    the value of the store; this lets the subscriber know the current value of the
    store.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use this store in a Svelte component right now (as shown in the following
    code snippet), you will see `0` on the screen. That is the current value of the
    store at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we import `store` into a Svelte component and
    display the `store` value using `$store`. Now, let’s listen to the `click` events
    to update the `count` value of the store. Instead of listening to the `click`
    events at the start of our program, we should start subscribing only when there’s
    a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we add the `click` event listener inside the
    `subscribe` method, and whenever the `document` is clicked, we increment the `clickCount`
    value by `1` and notify all the subscribers of the latest value of `clickCount`.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to use this Svelte store in multiple Svelte components right now,
    you will realize that every time you click, the store value increments by more
    than one.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring the event listener is only added once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why is the store value incremented more than once when it is only clicked once?
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the current implementation closely, you will realize that we
    call `document.addEventListener` on every `subscribe` method call. When you use
    the Svelte store in multiple Svelte components, each Svelte component subscribes
    to the store changes individually. If there are five components subscribed to
    the store, then five `click` event listeners will be added to `document`. As a
    result, a single click on `document` will trigger five event listeners, causing
    the `clickCount` value to increase by five each time. This means the `store` value
    will go up by more than one for every click. To fix this behavior, we can still
    call `addEventListener` within the `subscribe` method, but we need to only call
    `addEventListener` once, even though the `subscribe` method could be called more
    than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a flag to indicate if we have already called `addEventListener`,
    and make sure not to call `addEventListener` again when the flag is set to `true`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we add a variable named `called` and use it to
    prevent `document` from adding click event listeners more than once.
  prefs: []
  type: TYPE_NORMAL
- en: This works, but there’s a better way to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a new flag to indicate whether we have called `addEventListener`,
    we can use any existing variables to determine if we should call `addEventListener`.
    We know that we should call `addEventListener` once the `subscribe` method is
    being called, and it should not be called subsequently when we are adding more
    subscribers; we can use the length of the `subscribers` array to determine if
    we should call the `addEventListener` method.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no subscribers currently, then we know this is the first time the
    `subscribe` method is being called. In this case, we should call `addEventListener`.
    On the other hand, if there are existing subscribers—that is, the length of `subscribers`
    is more than zero, we know that the `subscribe` method has been called before,
    and therefore we should not call `addEventListener` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here’s the updated code to use the length of the `subscribers` array instead
    of the variable called to determine if the document should add click event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet , we replaced the `!called` condition with `subscribers.length
    ===` `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added a click event listener when a subscriber is subscribing
    to our Svelte store, we need to clean it up when all subscribers have unsubscribed
    from the Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean it up, we are going to call `removeEventListener` to remove the `click`
    event listeners from `document`. The `unsubscribe` function can be called multiple
    times, but we should only call `removeEventListener` when there are no more subscribers
    in the `subscribers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `return` function of the `subscribe` method
    is used for unsubscribing the store. In the function, we added a check to see
    if the number of `subscribers` has dropped to zero; if so, we will remove the
    `click` event listeners from `document`.
  prefs: []
  type: TYPE_NORMAL
- en: It is common that when you are creating a Svelte store, you need to keep track
    of the `subscribers` list, ensure that you only set up the event listeners once,
    and clean it up only after there are no more subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in this and the previous section, we've been through a lot of
    steps to create a Svelte store from user events, manage a `subscribers` array,
    and decide when to add or remove click event listeners from document. In the next
    section, we’ll explore a simpler way to achieve the same goal using Svelte’s built-in
    methods and using Svelte’s built-in `readable()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte provides built-in methods such as `readable()` to make our lives easier
    when creating a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Since the store value is only updated from `click` events, and not from elsewhere,
    `readable()`, out of the two most important methods—`readable()` and `writable()`—is
    good enough for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `readable()` function to create our click event store. There
    are two arguments for the `readable()` function. The first argument is for the
    initial value of the store. The second argument of the `readable()` function takes
    in a function that will be called when there’s a first subscriber and not be called
    for the subsequent subscribers. If the function returns another function, the
    returned function will be called when the last subscriber unsubscribes from the
    store. This is perfect for us to add and remove `click` event listeners on `document`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the updated code rewritten using `readable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we utilize `readable()` to handle both the creation
    and the cleanup of the `click` event listener, making our code cleaner and more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing it with our implementation in the last section, where we managed the
    `subscribers` list ourselves, you can see how using `readable()` allows us to
    declutter away from maintaining the `subscribers` array manually and focus on
    implementing the logic.
  prefs: []
  type: TYPE_NORMAL
- en: It is good to know the Svelte contract and how to implement a Svelte store from
    scratch. But in most real-world scenarios, it is easier to create a Svelte store
    out of `readable()` or `writable()` and leave the nitty-gritty detail to the built-in
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to create a Svelte store out of click events,
    let's practice with an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin our exercise, where we will implement a Svelte store in which the
    value of the store comes from the scroll position of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, a `scrollPosition` store is set up using a function called
    `createStore()`. Your task is to implement the `createStore()` function to actually
    create a `scrollPosition` store.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the solution at the following link: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to create a Svelte store where the store value comes
    from an event, let’s take a look at a different kind of Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an undo/redo store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, we change a store’s value using the `set` method. However, the next
    custom Svelte store we’ll explore provides additional custom methods to update
    its store value. The next custom Svelte store that we are going to look at is
    an undo/redo store. It is similar to a writable store where you can subscribe
    to and set a new store value. But an undo/redo store also comes with two more
    methods, `undo` and `redo`, which revert the store value backward or forward,
    based on the history of the store value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a snippet of how you would use an undo/redo store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the provided code snippet, the `createUndoRedoStore()` function generates
    an undo/redo store. Initially, we set the store’s value to `123`, followed by
    updates to `456` and then `789`. When we call the store’s `undo` method, the value
    reverts to `456` and then to `123`. Subsequently, using the `redo` method takes
    the store’s value back to `456`. Now that we understand how undo/redo store functions,
    how do we go about creating one in Svelte?
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, the undo/redo store is going to have four methods: `subscribe`, `set`,
    `undo`, and `redo`. The `subscribe` and `set` methods are based on the Svelte
    store contract and are the reason an undo/redo store is considered a Svelte store.
    The `undo` and `redo` methods, on the other hand, are two additional methods that
    we define.'
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript object can contain different methods and properties, but as long
    as it has the `subscribe` and `set` methods, with the method signature following
    the Svelte store contract, we consider the object a Svelte store. You can use
    a `$`-prefixed variable to auto-subscribe to the Svelte store and reference the
    Svelte store value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to implement this undo/redo store, we know that without the undo/redo
    feature, the store behaves just like a writable store. So, we are going to implement
    the undo/redo store based on a writable store, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we set the stage for our `createUndoRedoStore()`
    function. We start by using Svelte’s `writable()` function to create a writable
    store, which will be the base for our undo/redo store.
  prefs: []
  type: TYPE_NORMAL
- en: But as we are setting a new value into the undo/redo store, we need to keep
    track of the history of store values so that we can undo or redo them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we are going to intercept the `set` method of the writable store,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I return a new object. While the `subscribe` method is
    the same as the original writable store’s `subscribe` method, the `set` method
    is now a new function. We still call the writable store’s `set` method in the
    `set` function, so the behavior has not changed much.
  prefs: []
  type: TYPE_NORMAL
- en: But now, when we call the `set` method of the undo/redo store, we are calling
    the `set` function first, before relaying this to the `set` method of the underlying
    writable store. This allows us to add additional logic into the `set` function
    that will be run whenever we are setting a new value to the undo/redo store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get ahead of ourselves, let’s not forget that we also need to add
    two more methods, `undo` and `redo`, into the undo/redo store. Here’s how we do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we add two additional methods, `undo` and `redo`,
    to the object returned by `createUndoRedoStore()`. We will go ahead and implement
    these methods in the next steps. And now, we have the basic structure of our undo/redo
    store.
  prefs: []
  type: TYPE_NORMAL
- en: You can treat the preceding code as a template for creating custom Svelte stores.
    We use a writable store as a base and return a new object. The returned object
    is considered a Svelte store because, by having the `subscribe` and `set` methods,
    it adheres to the Svelte store contract. If we want to add logic to the `subscribe`
    or `set` method, we can build a new function based on the original `subscribe`
    and `set` methods from the writable store. In addition to that, we can also add
    more methods to the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the undo/redo logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, to implement the undo/redo logic, we are creating two arrays, `undoHistory`
    and `redoHistory`, to record the history of values that we can replay when we
    call `undo()` or `redo()`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `set` function is called, we will add the value as a new entry
    to `undoHistory` so that we can replay it later on when `undo()` is called. When
    `undo()` is called, we will push the latest entry in `undoHistory` into `redoHistory`
    so that we can redo what we’ve just undone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and implement the logic we’ve just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we’ve implemented the `undo` and `redo` function
    using two arrays: `undoHistory` and `redoHistory`. We’ve also added checks to
    see if there are any values in these arrays before performing an undo or redo
    action. This ensures that we don’t attempt to undo or redo when there’s no history
    to revert to or advance from. So, you have now learned how to create a custom
    Svelte store that extends from a writable store and adds new behavior to the original
    `set` method, as well as adding new methods to the store.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to have an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve learned how to create a custom store that provides custom methods
    to manipulate the underlying store values, let’s have an exercise to build another
    such custom store, a tweened store. A tweened store is a Svelte store that can
    contain only numeric values. When you set the value of a tweened Svelte store,
    the tweened Svelte store takes a fixed duration to update its store value to the
    set value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s suppose the tweened Svelte store is set to `0` initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you set the value of the store to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The store value is not set to `10` directly but increases from `0` to `10` over
    a configurable fixed duration—say, 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ve learned the behavior of a tweened store, let’s implement a tweened
    Svelte store. You can find the code for the tweened store on GitHub at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to create a custom store, let’s turn our attention
    to another concept, a higher-order store—a function that takes in a Svelte store
    as an input and returns a more specialized, custom store based on that input.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a debounced higher-order Svelte store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two preceding sections that we’ve seen so far each created a new Svelte
    store. In this section, we are going to look at how we can create a higher-order
    store.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a higher-order store is inspired by a higher-order function,
    where functions are treated just like any other data. This means that you can
    pass functions as arguments to other functions or return them as values.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar concept, we are going to create a function that treats stores just
    like any data, taking a Svelte store as an argument and then returning a Svelte
    store.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a higher-order Svelte store is to create a function that enhances
    an existing Svelte store. A higher-order Svelte store is a function that takes
    in a Svelte store and returns a new Svelte store, an enhanced version of the input
    Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: The example that we are going to use to illustrate this idea will create a `debounce`
    higher-order Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debounce` function that I am going to create will take in a Svelte store
    and return a new Svelte store that has its store value debounced based on the
    input Svelte store value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, in the fourth line, I demonstrated how to use
    the `debounce` function that we’re going to implement in this section. This `debounce`
    function accepts a Svelte store as an argument and returns an enhanced version
    of it, which we’ll call `debouncedStore`. To showcase the debounce functionality,
    the values of both the original `store` and `debouncedStore` arguments are displayed
    side by side.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing the `debounce` function, let’s talk about what
    debounce is.
  prefs: []
  type: TYPE_NORMAL
- en: Debouncing store value changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In engineering, debounce is the process of removing unwanted input noises from
    user input. In web development, debounce is used when there are too many user
    events, and we want to trigger an event handler or process the event only after
    the user event settles.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of debounce. When implementing an autocomplete search, we
    wouldn’t want to trigger the search for an autocomplete result on every character
    the user types; rather, we’d only start searching after the user stops typing.
    This saves resources as the autocomplete result may no longer be usable as soon
    as the user types the next character.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the concept of debounce to a Svelte store, we are going to create a
    new debounced Svelte store based on an input Svelte store. When the input Svelte
    store value updates, the debounced Svelte store only updates after the Svelte
    store updates settle.
  prefs: []
  type: TYPE_NORMAL
- en: If we are going to create a debounced Svelte store from scratch, we can build
    it up based on a writable store. I showed you how to create a custom Svelte store
    from a writable store in the last section, so I hope you know how to do that.
    Do try it out yourself; when you are done, compare it with my implementation at
    [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store).
  prefs: []
  type: TYPE_NORMAL
- en: But in this section, we are going to create a higher-order store. We already
    have a Svelte store. It could be a writable store or an undo/redo store. Our debounce
    function is going to take in the Svelte store and return a debounced version of
    the Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the basic structure of a `debounce` higher-order store.
  prefs: []
  type: TYPE_NORMAL
- en: The `debounce` function is going to return a new Svelte store. It is still much
    easier to build a new Svelte store based on a writable store than to implement
    it from scratch, create a subscribe function, and maintain an array of subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic outline of the `debounce` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the returned Svelte store is going to be based
    on the writable store, so the `subscribe` method is going to be the writable store’s
    `subscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `set` method is going to be the original store’s `set` method, instead of
    a new `set` function. We are not going to create a separate `set` function where
    it sets the original store and tries to set out a debounced store with the debounce
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not going to do like it’s done in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we intercepted the `set` method and relayed
    it to both the original store and the debounced store. We are not going to do
    that because we want to preserve the original Svelte store logic. When a value
    is passed to the `set` method, it may undergo transformations, especially if the
    store is a custom Svelte store. The `value` argument in the `set` method may not
    be the same as the final store value. So instead, we let the original store handle
    these potential transformations and subscribe to the original Svelte store to
    get the final store value. We use the final store value and update the debounced
    store as the original store value changes, as illustrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, I show how to subscribe to the original Svelte
    store rather than intercepting its `set` method. This approach allows us to keep
    the original store’s logic intact while still benefiting from its features. It
    also takes care of situations when the original Svelte store value could change
    by other methods. An example of this is the `undo()` and `redo()` methods of the
    undo/redo store. If we only intercepted the value from the `set` function, as
    in the preceding code snippet, then the debounced Svelte store would not change
    when the original undo/redo store was being undone or redone.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the debounce logic, we are going to use a timeout to update the
    debounced Svelte store. If there are new changes to the original Svelte store
    within the timeout, then we are going to cancel the previous timeout and set a
    new timeout. If not, then we assume the changes have settled, and we update the
    `debounced` store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the updated code snippet with the debounce logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the `setTimeout` function within the `subscribe`
    callback to set a timeout for 200 ms. During this time, if the original store’s
    value changes again, the existing timeout will be cleared, and a new one will
    be set. But if there’s a new value within the 200 ms time period, we will update
    the `debounced` store with the latest value from the original store.
  prefs: []
  type: TYPE_NORMAL
- en: Try out the `debounced` store and see that the store value is now debounced
    from the changes.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might notice is that we subscribed to the original Svelte store
    but haven’t unsubscribed from it. Let’s address that next.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing and unsubscribing original store on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we wrap up, there’s one small issue with the `debounced` store that we’ve
    implemented so far. We subscribed to the original Svelte store at the creation
    of the `debounced` Svelte store and we never unsubscribed from it, even though
    the `debounced` Svelte store may no longer be in use. We should only start subscribing
    to the original Svelte store when there’s already a subscriber to the `debounced`
    Svelte store and unsubscribe when there is no longer any subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could intercept the `subscribe` method and attempt to unsubscribe from the
    original Svelte store when the debounced Svelte store is being unsubscribed, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the updated code snippet, the `subscribe` method now subscribes to both the
    `debounced` store and the original Svelte store. In the `return` function, which
    is used to unsubscribe from the `debounced` store, we also make sure to unsubscribe
    from the original Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not quite right. Doing it this way means that we subscribe
    to the original store every time we subscribe to the debounced store and unsubscribe
    from the original store every time we unsubscribe from the debounced store.
  prefs: []
  type: TYPE_NORMAL
- en: We should aim to subscribe to the original store just once, regardless of how
    many subscribers there are. Similarly, we should unsubscribe from it only when
    there are no subscribers left. Does this sound familiar?
  prefs: []
  type: TYPE_NORMAL
- en: We ran into a similar conundrum in the previous section when we were trying
    to implement a click-counter Svelte store. We tried to maintain a list of subscribers
    before we found out that Svelte provides a built-in `writable()` function that
    neatly takes care of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: So, is there a built-in function that allows us to only subscribe to another
    store once a store is being subscribed, and only unsubscribe from that store once
    there are no more subscribers in a store?
  prefs: []
  type: TYPE_NORMAL
- en: Yes—this is where `derived()` comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving a new Svelte store with the derived() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`derived()` is a built-in function from Svelte that takes in one or multiple
    Svelte stores and returns a new Svelte store whose store value is based on the
    input Svelte stores.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use `derived()` to define a Svelte store whose store value
    is always double that of another Svelte store, as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, this could be a Svelte store whose store value is the sum of two Svelte
    stores, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we are using a `$`-prefixed variable in the callback function
    of the `derived()` function; for example, `$store1` and `$store2`. However, it
    does not work the same way as the `$`-prefixed variable at the top level of the
    script, where it auto-subscribes to the store and is referenced as the store value.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is merely a convention that some people use to denote that
    the variable is used to reference the value of a store. It is the same as any
    other variable name and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: When using `derived()`, Svelte only subscribes to the input Svelte stores—for
    example, `store1` and `store2`—only when the returned Svelte store—for example,
    `sum`—is being subscribed to, and will unsubscribe from the input Svelte stores
    when there are no more subscribers to the returned Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Before we rewrite our `debounce` higher-order store using `derived()`, let’s
    dive a little bit more into the `derived()` function first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `derived()` function provides two approaches to determine the store value
    of the returned Svelte store: synchronous or asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: The synchronous approach means that as soon as any of the input Svelte store’s
    values change, the store value of the returned Svelte store is determined synchronously.
    By the same token, the asynchronous approach means it is determined asynchronously,
    which means the store value can be set later after the input Svelte store’s value
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: The two examples that I showed at the beginning of this section use the synchronous
    approach, where the store value of the returned Svelte store is synchronously
    calculated and set right after the input Svelte store has changed.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous approach can be useful when the store value of the returned
    Svelte store is determined through some asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether the derived store is using the synchronous or asynchronous
    approach, the `derived()` method looks at the function signature of the callback
    function. If it takes in one parameter, then it is considered a synchronous approach.
    If it takes in two, then it is an asynchronous approach. To get a better idea,
    check out the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the callback function will be called every time any of the input
    Svelte store values change.
  prefs: []
  type: TYPE_NORMAL
- en: If the derived store uses the synchronous approach, the returned value of the
    callback function is used as the new store value of the returned Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: If the derived store uses the asynchronous approach, then the second parameter
    of the callback function is a `set` function. The `set` function can be used to
    set the value of the returned store at any time. The returned value of the callback
    function, however, will be treated as a cleanup function that will be called right
    before the callback function is called again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with the `derived()` function, let's rewrite our
    `debounce` higher-order store using `derived()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the derived method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the updated code for our `debounced` store rewritten using the `derived()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Instead of creating a new `debounced` store using `writable()`, we derived it
    from the original store using the `derived()` method. We shifted the `setTimeout`
    function into the `derived()` method callback. When there’s a new value from the
    original Svelte store, we will clear the timeout and set a new timeout.
  prefs: []
  type: TYPE_NORMAL
- en: The `derived()` function will subscribe to the original Svelte store once only
    when the `debounced` store is being subscribed to and unsubscribe from the original
    Svelte store when there are no more subscribers for the `debounced` store.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are only going to update the `debounced` store asynchronously after
    a timeout, we pass a callback function with two parameters into the `derived()`
    function. We call the `set` function to set the value of the `debounced` store
    after the timeout. If the value of the original Svelte store changes before the
    timeout, then the returned function of the callback function will be called first
    before the callback function is called again with the updated store value of the
    original Svelte store. In the returned function, we clear the timeout since we
    no longer need it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing before we conclude—sometimes, the original Svelte store may
    contain additional methods, such as the `undo()` and `redo()` methods in the case
    of an undo/redo store. These methods should also be defined in the debounced store
    returned by our higher-order function. This ensures that the enhanced store maintains
    all the same methods and behaviors as the input store while adding the debouncing
    feature. You can see an illustration of this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To return all the methods from the original Svelte store, we use the spread
    operator (`...`) to spread all the methods from the original Svelte store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we do not even need to have `set: store.set` since the `set`
    method will be spread into the returned Svelte store too!'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! In this section, you’ve learned another trick—creating a higher-order
    store, a function that takes in an existing Svelte store and returns a new Svelte
    store enhanced with new behavior. Instead of building a custom Svelte store with
    all the logic in it, we can now create smaller well-encapsulated higher-order
    stores and put them into a custom Svelte store that you need.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it’s time for an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The undo/redo store in the previous section is created as a custom Svelte store.
    Can you create an undo/redo higher-order store that turns any Svelte store into
    an undo/redo store with two additional methods, `undo()` and `redo()`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how the undo/redo higher-order store would be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows how we use the undo/redo higher-order store,
    `undoRedo`. The `undoRedo` function takes in a store, named `originalStore`, and
    returns a new store based on `originalStore` that has the undo/redo capability.
    For example, if we set a new value and then call the `undo` method, the store
    value will revert to its original state, which is `5` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the solution for this exercise on GitHub here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve explored the process of creating a `debounce` higher-order
    Svelte store using the `derived()` method. I look forward to you applying this
    knowledge in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at three different examples and learned three different
    techniques with a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how to turn any user events into a data source for a Svelte store,
    learned how to create a Svelte store from scratch, and also learned how to use
    the built-in `readable()` function to make the process much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored making a custom Svelte store with additional methods,
    building a new Svelte store based on the built-in writable store.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned to create a higher-order store, a function that takes in
    a Svelte store and returns an enhanced version of the input store. In the example,
    we see how we can turn any Svelte store into a debounced version of itself.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding these techniques, you’re now equipped to manage state in Svelte
    more effectively to craft more scalable and maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at state management in Svelte—namely, how
    to do state management with Svelte stores.
  prefs: []
  type: TYPE_NORMAL
