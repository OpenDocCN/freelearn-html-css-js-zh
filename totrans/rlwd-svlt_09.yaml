- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Implementing Custom Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义存储
- en: In the last chapter, we learned that a Svelte store is any object that follows
    a Svelte store contract, and encapsulating data within a Svelte store allows the
    data to be shared and used across multiple Svelte components reactively. The Svelte
    component keeps the DOM up to date with the data, even though the data is modified
    outside of the Svelte component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到 Svelte 存储是任何遵循 Svelte 存储合约的对象，将数据封装在 Svelte 存储中允许数据在多个 Svelte 组件之间反应性地共享和使用。Svelte
    组件会根据数据更新 DOM，即使数据是在 Svelte 组件外部被修改的。
- en: We learned about two of Svelte’s built-in methods for creating a Svelte store—namely
    `readable()` and `writable()`, which create a readable and writable store. The
    two methods follow the Svelte contract and create a very basic Svelte store. However,
    besides using a Svelte store to encapsulate data, we can also encapsulate logic
    with the data, making the Svelte store modular and highly reusable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 Svelte 创建 Svelte 存储的两种内置方法——即 `readable()` 和 `writable()`，它们创建一个可读和可写的存储。这两种方法遵循
    Svelte 合约并创建一个非常基础的 Svelte 存储。然而，除了使用 Svelte 存储封装数据外，我们还可以封装与数据相关的逻辑，使 Svelte
    存储模块化且高度可重用。
- en: In this chapter, we will be creating custom Svelte stores—Svelte stores that
    encapsulate custom data logic. We will go through three distinct examples; each
    example will serve as a guide, brimming with tips and tricks for creating your
    own custom Svelte stores.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建自定义 Svelte 存储——封装自定义数据逻辑的 Svelte 存储。我们将通过三个不同的示例进行讲解；每个示例都将作为指南，充满创建您自己的自定义
    Svelte 存储的技巧和窍门。
- en: First up, we’ll examine how to turn user events into store values, specifically
    turning click counts into a Svelte store.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨如何将用户事件转换为存储值，特别是将点击次数转换为 Svelte 存储。
- en: Second, we’ll explore a custom store that goes beyond the basic `set` method
    to modify its value. We’ll look at an undo/redo store, which incorporates additional
    methods for reverting or redoing changes to its value.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将探讨一个超出基本 `set` 方法以修改其值的自定义存储。我们将查看一个撤销/重做存储，它包含用于撤销或重做对其值更改的额外方法。
- en: 'Lastly, we’ll turn our attention to higher-order stores. While not a custom
    store in itself, a higher-order store is a function that accepts a Svelte store
    as input and returns an enhanced version of it. This chapter includes sections
    on the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将关注高级存储。虽然高级存储本身不是一个自定义存储，但它是一个接受 Svelte 存储作为输入并返回其增强版本的函数。本章包括以下主题的章节：
- en: Creating a Svelte store from user events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户事件创建 Svelte 存储
- en: Creating an undo/redo store
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个撤销/重做存储
- en: Creating a debounced higher-order Svelte store
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个防抖的高级 Svelte 存储
- en: So, without further ado, let’s dive into creating our first custom Svelte store.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需多言，让我们深入探讨创建我们的第一个自定义 Svelte 存储。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code in this chapter can be found on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09)
- en: Creating a Svelte store from user events
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户事件创建 Svelte 存储
- en: A Svelte store stores data, but where does the data come from?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 存储存储数据，但数据从何而来？
- en: It could be from user interaction or user input, which calls an event handler
    that updates the store value by calling `store.set()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能来自用户交互或用户输入，这会调用一个事件处理器，通过调用 `store.set()` 来更新存储值。
- en: What if we can encapsulate the user events and event handler logic into the
    store so that we do not need to call `store.set()` manually?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将用户事件和事件处理器逻辑封装到存储中，这样我们就不需要手动调用 `store.set()` 会怎样？
- en: For example, we are going to have a Svelte store to calculate how many times
    the user clicks on the screen. Instead of manually adding an event listener on
    the document, if there’s a way to create a Svelte store and update it every time
    there’s a new click, how would that look? In short, how about having a custom
    Svelte store that can do all of that for us?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将有一个 Svelte 存储来计算用户在屏幕上点击的次数。如果我们能够创建一个 Svelte 存储，并在每次有新的点击时更新它，而不是手动在文档上添加事件监听器，那会是什么样子？简而言之，有没有一个可以为我们做所有这些的自定义
    Svelte 存储？
- en: It would be great if we could reuse this Svelte store the next time we have
    a similar need, instead of having to manually set it up again.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在下一次有类似需求时重用这个 Svelte 存储，而不是再次手动设置它，那将是非常棒的。
- en: So, let’s try to implement this click counter custom Svelte store.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试实现这个点击计数自定义Svelte store。
- en: 'Let''s first scaffold the Svelte store:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建Svelte store：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, we created a basic Svelte store based on the
    Svelte store contract with just a `subscribe()` method. The value of the store
    is stored in a variable called `clickCount`, and in the `subscribe()` method,
    we keep track of all the subscribers using the `subscribers` array.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个基于Svelte store contract的基本Svelte store，它只有一个`subscribe()`方法。store的值存储在一个名为`clickCount`的变量中，在`subscribe()`方法中，我们使用`subscribers`数组跟踪所有订阅者。
- en: Notice that we need to synchronously call `fn` in the `subscribe()` method with
    the value of the store; this lets the subscriber know the current value of the
    store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要在`subscribe()`方法中同步调用`fn`与store的值；这样可以让订阅者知道store的当前值。
- en: 'If you use this store in a Svelte component right now (as shown in the following
    code snippet), you will see `0` on the screen. That is the current value of the
    store at this point:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在Svelte组件中使用这个store（如下面的代码片段所示），你会在屏幕上看到`0`。这就是此时store的当前值：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code snippet, we import `store` into a Svelte component and
    display the `store` value using `$store`. Now, let’s listen to the `click` events
    to update the `count` value of the store. Instead of listening to the `click`
    events at the start of our program, we should start subscribing only when there’s
    a subscriber.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将`store`导入到Svelte组件中，并使用`$store`显示store的值。现在，让我们监听`click`事件以更新store的`count`值。我们不应该在程序开始时监听`click`事件，而应该只在存在订阅者时开始订阅。
- en: 'Here’s the updated code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是更新后的代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we add the `click` event listener inside the
    `subscribe` method, and whenever the `document` is clicked, we increment the `clickCount`
    value by `1` and notify all the subscribers of the latest value of `clickCount`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`subscribe`方法内部添加了`click`事件监听器，每当点击`document`时，我们就将`clickCount`的值增加`1`，并通知所有订阅者`clickCount`的最新值。
- en: If you try to use this Svelte store in multiple Svelte components right now,
    you will realize that every time you click, the store value increments by more
    than one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试在多个Svelte组件中使用这个Svelte store，你会意识到每次点击，store的值都会增加多于一个。
- en: Ensuring the event listener is only added once
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保事件监听器只添加一次
- en: Why is the store value incremented more than once when it is only clicked once?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么点击一次时store的值会增加多于一次？
- en: If you look at the current implementation closely, you will realize that we
    call `document.addEventListener` on every `subscribe` method call. When you use
    the Svelte store in multiple Svelte components, each Svelte component subscribes
    to the store changes individually. If there are five components subscribed to
    the store, then five `click` event listeners will be added to `document`. As a
    result, a single click on `document` will trigger five event listeners, causing
    the `clickCount` value to increase by five each time. This means the `store` value
    will go up by more than one for every click. To fix this behavior, we can still
    call `addEventListener` within the `subscribe` method, but we need to only call
    `addEventListener` once, even though the `subscribe` method could be called more
    than once.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看当前实现，你会意识到我们在每次`subscribe`方法调用时都调用了`document.addEventListener`。当你使用Svelte
    store在多个Svelte组件中时，每个Svelte组件都会单独订阅store的变化。如果有五个组件订阅了store，那么五个`click`事件监听器将被添加到`document`上。结果，`document`上的单次点击将触发五个事件监听器，导致`clickCount`的值每次增加五。这意味着每次点击，`store`的值都会增加多于一个。为了修复这种行为，我们仍然可以在`subscribe`方法中调用`addEventListener`，但我们需要确保只调用一次，即使`subscribe`方法可能被多次调用。
- en: 'We can use a flag to indicate if we have already called `addEventListener`,
    and make sure not to call `addEventListener` again when the flag is set to `true`,
    as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个标志来指示是否已经调用了`addEventListener`，并确保当标志设置为`true`时不再调用`addEventListener`，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we add a variable named `called` and use it to
    prevent `document` from adding click event listeners more than once.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了一个名为`called`的变量，并使用它来防止`document`添加多于一次的点击事件监听器。
- en: This works, but there’s a better way to implement this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但还有更好的实现方式。
- en: Instead of having a new flag to indicate whether we have called `addEventListener`,
    we can use any existing variables to determine if we should call `addEventListener`.
    We know that we should call `addEventListener` once the `subscribe` method is
    being called, and it should not be called subsequently when we are adding more
    subscribers; we can use the length of the `subscribers` array to determine if
    we should call the `addEventListener` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要设置一个新的标志来指示是否已经调用过 `addEventListener`，我们可以使用任何现有的变量来确定是否应该调用 `addEventListener`。我们知道一旦调用
    `subscribe` 方法，就应该调用 `addEventListener`，而在我们添加更多订阅者时不应随后再次调用；我们可以使用 `subscribers`
    数组的长度来确定是否应该调用 `addEventListener` 方法。
- en: If there are no subscribers currently, then we know this is the first time the
    `subscribe` method is being called. In this case, we should call `addEventListener`.
    On the other hand, if there are existing subscribers—that is, the length of `subscribers`
    is more than zero, we know that the `subscribe` method has been called before,
    and therefore we should not call `addEventListener` again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目前没有订阅者，那么我们知道这是第一次调用 `subscribe` 方法。在这种情况下，我们应该调用 `addEventListener`。另一方面，如果存在现有订阅者——即
    `subscribers` 的长度大于零，我们知道 `subscribe` 方法之前已经被调用过，因此我们不应再次调用 `addEventListener`。
- en: 'So, here’s the updated code to use the length of the `subscribers` array instead
    of the variable called to determine if the document should add click event listeners:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是更新后的代码，使用 `subscribers` 数组的长度而不是变量来确定是否应该向文档添加点击事件监听器：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code snippet , we replaced the `!called` condition with `subscribers.length
    ===` `0`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `!called` 条件替换为 `subscribers.length === 0`。
- en: Now that we have added a click event listener when a subscriber is subscribing
    to our Svelte store, we need to clean it up when all subscribers have unsubscribed
    from the Svelte store.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为订阅我们的 Svelte 存储时添加了点击事件监听器，当所有订阅者从 Svelte 存储中取消订阅时，我们需要进行清理。
- en: 'To clean it up, we are going to call `removeEventListener` to remove the `click`
    event listeners from `document`. The `unsubscribe` function can be called multiple
    times, but we should only call `removeEventListener` when there are no more subscribers
    in the `subscribers` array:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行清理，我们将调用 `removeEventListener` 来从 `document` 中移除 `click` 事件监听器。`unsubscribe`
    函数可以被多次调用，但我们应该只在 `subscribers` 数组中没有更多订阅者时调用 `removeEventListener`。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, the `return` function of the `subscribe` method
    is used for unsubscribing the store. In the function, we added a check to see
    if the number of `subscribers` has dropped to zero; if so, we will remove the
    `click` event listeners from `document`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`subscribe` 方法的 `return` 函数用于取消存储的订阅。在函数中，我们添加了一个检查来查看 `subscribers`
    的数量是否下降到零；如果是这样，我们将从 `document` 中移除 `click` 事件监听器。
- en: It is common that when you are creating a Svelte store, you need to keep track
    of the `subscribers` list, ensure that you only set up the event listeners once,
    and clean it up only after there are no more subscribers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 Svelte 存储时，通常需要跟踪 `subscribers` 列表，确保你只设置一次事件监听器，并且在没有更多订阅者后进行清理。
- en: As you’ve seen in this and the previous section, we've been through a lot of
    steps to create a Svelte store from user events, manage a `subscribers` array,
    and decide when to add or remove click event listeners from document. In the next
    section, we’ll explore a simpler way to achieve the same goal using Svelte’s built-in
    methods and using Svelte’s built-in `readable()` function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节和前一节中看到的，我们已经经历了很多步骤来从用户事件创建 Svelte 存储管理 `subscribers` 数组，并决定何时向文档添加或移除点击事件监听器。在下一节中，我们将探索使用
    Svelte 的内置方法和内置 `readable()` 函数以更简单的方式实现相同目标的方法。
- en: Svelte provides built-in methods such as `readable()` to make our lives easier
    when creating a Svelte store.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 提供了内置方法，如 `readable()`，以使我们在创建 Svelte 存储时生活更加轻松。
- en: Since the store value is only updated from `click` events, and not from elsewhere,
    `readable()`, out of the two most important methods—`readable()` and `writable()`—is
    good enough for our use case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储值只由 `click` 事件更新，而不是其他地方，所以 `readable()` 在两个最重要的方法——`readable()` 和 `writable()`
    中——对于我们的用例来说已经足够好了。
- en: We will use the `readable()` function to create our click event store. There
    are two arguments for the `readable()` function. The first argument is for the
    initial value of the store. The second argument of the `readable()` function takes
    in a function that will be called when there’s a first subscriber and not be called
    for the subsequent subscribers. If the function returns another function, the
    returned function will be called when the last subscriber unsubscribes from the
    store. This is perfect for us to add and remove `click` event listeners on `document`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`readable()`函数来创建我们的点击事件存储。`readable()`函数有两个参数。第一个参数是存储的初始值。`readable()`函数的第二个参数接受一个函数，该函数在第一个订阅者订阅时会被调用，而对于后续的订阅者则不会被调用。如果该函数返回另一个函数，则当最后一个订阅者从存储中取消订阅时，返回的函数会被调用。这对于我们在`document`上添加和移除`click`事件监听器来说非常完美。
- en: 'Let’s take a look at the updated code rewritten using `readable`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`readable`重写的更新后的代码：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, we utilize `readable()` to handle both the creation
    and the cleanup of the `click` event listener, making our code cleaner and more
    efficient.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们利用`readable()`来处理`click`事件监听器的创建和清理，使我们的代码更简洁、更高效。
- en: Comparing it with our implementation in the last section, where we managed the
    `subscribers` list ourselves, you can see how using `readable()` allows us to
    declutter away from maintaining the `subscribers` array manually and focus on
    implementing the logic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中我们自行管理`subscribers`列表的实现相比，你可以看到使用`readable()`如何使我们能够从手动维护`subscribers`数组中解脱出来，并专注于实现逻辑。
- en: It is good to know the Svelte contract and how to implement a Svelte store from
    scratch. But in most real-world scenarios, it is easier to create a Svelte store
    out of `readable()` or `writable()` and leave the nitty-gritty detail to the built-in
    function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Svelte合约以及如何从头开始实现Svelte存储是很好的。但在大多数实际场景中，从`readable()`或`writable()`创建Svelte存储更容易，并将细节留给内置函数。
- en: Now that you have learned how to create a Svelte store out of click events,
    let's practice with an exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何从点击事件创建Svelte存储，让我们通过一个练习来练习一下。
- en: Exercise
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Let’s begin our exercise, where we will implement a Svelte store in which the
    value of the store comes from the scroll position of the document:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的练习，我们将实现一个Svelte存储，其值来自文档的滚动位置：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the code snippet, a `scrollPosition` store is set up using a function called
    `createStore()`. Your task is to implement the `createStore()` function to actually
    create a `scrollPosition` store.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，使用名为`createStore()`的函数设置了一个`scrollPosition`存储。你的任务是实现`createStore()`函数以实际创建一个`scrollPosition`存储。
- en: 'You can find the solution at the following link: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到解决方案：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/02-exercise-scroll-position)
- en: Now that we have seen how to create a Svelte store where the store value comes
    from an event, let’s take a look at a different kind of Svelte store.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建一个存储值来自事件的Svelte存储，让我们看看另一种类型的Svelte存储。
- en: Creating an undo/redo store
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建撤销/重做存储
- en: Typically, we change a store’s value using the `set` method. However, the next
    custom Svelte store we’ll explore provides additional custom methods to update
    its store value. The next custom Svelte store that we are going to look at is
    an undo/redo store. It is similar to a writable store where you can subscribe
    to and set a new store value. But an undo/redo store also comes with two more
    methods, `undo` and `redo`, which revert the store value backward or forward,
    based on the history of the store value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用`set`方法来更改存储的值。然而，我们接下来要探索的下一个自定义Svelte存储提供了额外的自定义方法来更新其存储值。我们将要查看的下一个自定义Svelte存储是一个撤销/重做存储。它类似于可写存储，你可以订阅并设置新的存储值。但撤销/重做存储还提供了两个额外的函数，`undo`和`redo`，它们根据存储值的历史记录将存储值向前或向后回退。
- en: 'Here’s a snippet of how you would use an undo/redo store:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何使用撤销/重做存储的示例：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the provided code snippet, the `createUndoRedoStore()` function generates
    an undo/redo store. Initially, we set the store’s value to `123`, followed by
    updates to `456` and then `789`. When we call the store’s `undo` method, the value
    reverts to `456` and then to `123`. Subsequently, using the `redo` method takes
    the store’s value back to `456`. Now that we understand how undo/redo store functions,
    how do we go about creating one in Svelte?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码片段中，`createUndoRedoStore()`函数生成一个撤销/重做存储。最初，我们将存储的值设置为`123`，然后更新为`456`，接着是`789`。当我们调用存储的`undo`方法时，值会回滚到`456`，然后是`123`。随后，使用`redo`方法将存储的值再次恢复到`456`。现在我们了解了撤销/重做存储的工作原理，那么在Svelte中如何创建一个这样的存储呢？
- en: 'Firstly, the undo/redo store is going to have four methods: `subscribe`, `set`,
    `undo`, and `redo`. The `subscribe` and `set` methods are based on the Svelte
    store contract and are the reason an undo/redo store is considered a Svelte store.
    The `undo` and `redo` methods, on the other hand, are two additional methods that
    we define.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，撤销/重做存储将拥有四个方法：`subscribe`、`set`、`undo`和`redo`。`subscribe`和`set`方法基于Svelte存储合约，这也是为什么撤销/重做存储被认为是Svelte存储的原因。另一方面，`undo`和`redo`方法是两个我们定义的额外方法。
- en: A JavaScript object can contain different methods and properties, but as long
    as it has the `subscribe` and `set` methods, with the method signature following
    the Svelte store contract, we consider the object a Svelte store. You can use
    a `$`-prefixed variable to auto-subscribe to the Svelte store and reference the
    Svelte store value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个JavaScript对象可以包含不同的方法和属性，但只要它有`subscribe`和`set`方法，并且方法签名遵循Svelte存储合约，我们就认为该对象是Svelte存储。你可以使用以`$`前缀的变量来自动订阅Svelte存储并引用Svelte存储的值。
- en: 'Now, to implement this undo/redo store, we know that without the undo/redo
    feature, the store behaves just like a writable store. So, we are going to implement
    the undo/redo store based on a writable store, as shown in the following code
    snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实现这个撤销/重做存储，我们知道如果没有撤销/重做功能，存储的行为就像一个可写存储。因此，我们将基于可写存储实现撤销/重做存储，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we set the stage for our `createUndoRedoStore()`
    function. We start by using Svelte’s `writable()` function to create a writable
    store, which will be the base for our undo/redo store.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为`createUndoRedoStore()`函数设定了场景。我们首先使用Svelte的`writable()`函数创建一个可写存储，这将是我们的撤销/重做存储的基础。
- en: But as we are setting a new value into the undo/redo store, we need to keep
    track of the history of store values so that we can undo or redo them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们正在将新值设置到撤销/重做存储中，我们需要跟踪存储值的记录，以便我们可以撤销或重做它们。
- en: 'To do that, we are going to intercept the `set` method of the writable store,
    like so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将拦截可写存储的`set`方法，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, I return a new object. While the `subscribe` method is
    the same as the original writable store’s `subscribe` method, the `set` method
    is now a new function. We still call the writable store’s `set` method in the
    `set` function, so the behavior has not changed much.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我返回了一个新的对象。虽然`subscribe`方法与原始可写存储的`subscribe`方法相同，但`set`方法现在是一个新的函数。我们仍然在`set`函数中调用可写存储的`set`方法，所以行为变化不大。
- en: But now, when we call the `set` method of the undo/redo store, we are calling
    the `set` function first, before relaying this to the `set` method of the underlying
    writable store. This allows us to add additional logic into the `set` function
    that will be run whenever we are setting a new value to the undo/redo store.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，当我们调用撤销/重做存储的`set`方法时，我们首先调用`set`函数，然后再将这个调用传递给底层可写存储的`set`方法。这允许我们在`set`函数中添加额外的逻辑，该逻辑将在我们设置撤销/重做存储的新值时运行。
- en: 'Before we get ahead of ourselves, let’s not forget that we also need to add
    two more methods, `undo` and `redo`, into the undo/redo store. Here’s how we do
    this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们急于求成之前，别忘了我们还需要在撤销/重做存储中添加两个更多的方法，即`undo`和`redo`。下面是如何实现这一点的说明：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we add two additional methods, `undo` and `redo`,
    to the object returned by `createUndoRedoStore()`. We will go ahead and implement
    these methods in the next steps. And now, we have the basic structure of our undo/redo
    store.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们向`createUndoRedoStore()`返回的对象中添加了两个额外的方法，即`undo`和`redo`。我们将继续在接下来的步骤中实现这些方法。现在，我们已经拥有了撤销/重做存储的基本结构。
- en: You can treat the preceding code as a template for creating custom Svelte stores.
    We use a writable store as a base and return a new object. The returned object
    is considered a Svelte store because, by having the `subscribe` and `set` methods,
    it adheres to the Svelte store contract. If we want to add logic to the `subscribe`
    or `set` method, we can build a new function based on the original `subscribe`
    and `set` methods from the writable store. In addition to that, we can also add
    more methods to the returned object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将前面的代码视为创建自定义 Svelte 存储的模板。我们使用可写存储作为基础并返回一个新的对象。返回的对象被视为 Svelte 存储，因为通过拥有
    `subscribe` 和 `set` 方法，它遵循 Svelte 存储契约。如果我们想向 `subscribe` 或 `set` 方法添加逻辑，我们可以基于可写存储的原始
    `subscribe` 和 `set` 方法构建一个新的函数。除此之外，我们还可以向返回的对象添加更多方法。
- en: Implementing the undo/redo logic
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现撤销/重做逻辑
- en: Now, to implement the undo/redo logic, we are creating two arrays, `undoHistory`
    and `redoHistory`, to record the history of values that we can replay when we
    call `undo()` or `redo()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实现撤销/重做逻辑，我们正在创建两个数组，`undoHistory` 和 `redoHistory`，以记录我们可以在我们调用 `undo()`
    或 `redo()` 时回放的价值历史。
- en: Whenever the `set` function is called, we will add the value as a new entry
    to `undoHistory` so that we can replay it later on when `undo()` is called. When
    `undo()` is called, we will push the latest entry in `undoHistory` into `redoHistory`
    so that we can redo what we’ve just undone.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用 `set` 函数时，我们将值作为一个新条目添加到 `undoHistory` 中，这样我们就可以在调用 `undo()` 时稍后回放它。当调用
    `undo()` 时，我们将 `undoHistory` 中的最新条目推入 `redoHistory` 中，这样我们就可以重做我们刚刚撤销的操作。
- en: 'Let’s go ahead and implement the logic we’ve just described:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现我们刚刚描述的逻辑：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code snippet, we’ve implemented the `undo` and `redo` function
    using two arrays: `undoHistory` and `redoHistory`. We’ve also added checks to
    see if there are any values in these arrays before performing an undo or redo
    action. This ensures that we don’t attempt to undo or redo when there’s no history
    to revert to or advance from. So, you have now learned how to create a custom
    Svelte store that extends from a writable store and adds new behavior to the original
    `set` method, as well as adding new methods to the store.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用两个数组：`undoHistory` 和 `redoHistory` 实现了 `undo` 和 `redo` 函数。我们在执行撤销或重做操作之前还添加了检查，以查看这些数组中是否有任何值。这确保了我们不会在没有历史记录可以回滚或前进的情况下尝试撤销或重做。因此，你现在已经学会了如何创建一个从可写存储扩展并添加新行为到原始
    `set` 方法，以及向存储添加新方法的自定义 Svelte 存储。
- en: It’s time to have an exercise.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行练习了。
- en: Exercise
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Now that we’ve learned how to create a custom store that provides custom methods
    to manipulate the underlying store values, let’s have an exercise to build another
    such custom store, a tweened store. A tweened store is a Svelte store that can
    contain only numeric values. When you set the value of a tweened Svelte store,
    the tweened Svelte store takes a fixed duration to update its store value to the
    set value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建一个提供自定义方法来操作底层存储值的自定义存储，让我们通过一个练习来构建另一个这样的自定义存储，一个缓动存储。缓动存储是一个只能包含数值的
    Svelte 存储。当你设置缓动 Svelte 存储的值时，缓动 Svelte 存储会花费一个固定的持续时间来更新其存储值到设置的值。
- en: 'For example, let’s suppose the tweened Svelte store is set to `0` initially:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设缓动 Svelte 存储最初设置为 `0`：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, you set the value of the store to `10`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将存储的值设置为 `10`：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The store value is not set to `10` directly but increases from `0` to `10` over
    a configurable fixed duration—say, 1 second.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 存储值不是直接设置为 `10`，而是在可配置的固定持续时间内从 `0` 增加到 `10`——比如说，1 秒。
- en: Now you’ve learned the behavior of a tweened store, let’s implement a tweened
    Svelte store. You can find the code for the tweened store on GitHub at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了缓动存储的行为，让我们实现一个缓动 Svelte 存储。你可以在 GitHub 上找到缓动存储的代码，链接为 [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/04-exercise-tweened-store)。
- en: Now that we’ve learned how to create a custom store, let’s turn our attention
    to another concept, a higher-order store—a function that takes in a Svelte store
    as an input and returns a more specialized, custom store based on that input.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建自定义存储，让我们将注意力转向另一个概念，一个高阶存储——一个接受 Svelte 存储作为输入并返回基于该输入的更专业、更自定义存储的函数。
- en: Creating a debounced higher-order Svelte store
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个防抖高阶 Svelte 存储
- en: The two preceding sections that we’ve seen so far each created a new Svelte
    store. In this section, we are going to look at how we can create a higher-order
    store.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的两个先前的部分各自创建了一个新的 Svelte 存储。在本节中，我们将探讨如何创建一个高阶存储。
- en: The concept of a higher-order store is inspired by a higher-order function,
    where functions are treated just like any other data. This means that you can
    pass functions as arguments to other functions or return them as values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶存储的概念灵感来源于高阶函数，其中函数被当作其他数据一样对待。这意味着你可以将函数作为参数传递给其他函数，或者将它们作为值返回。
- en: In a similar concept, we are going to create a function that treats stores just
    like any data, taking a Svelte store as an argument and then returning a Svelte
    store.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的概念下，我们将创建一个函数，将存储当作任何数据一样对待，接受一个 Svelte 存储作为参数，然后返回一个 Svelte 存储。
- en: The idea of a higher-order Svelte store is to create a function that enhances
    an existing Svelte store. A higher-order Svelte store is a function that takes
    in a Svelte store and returns a new Svelte store, an enhanced version of the input
    Svelte store.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶 Svelte 存储的想法是创建一个函数来增强现有的 Svelte 存储。高阶 Svelte 存储是一个函数，它接受一个 Svelte 存储，并返回一个新的
    Svelte 存储，这是输入 Svelte 存储的增强版本。
- en: The example that we are going to use to illustrate this idea will create a `debounce`
    higher-order Svelte store.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的示例将创建一个 `debounce` 高阶 Svelte 存储。
- en: 'The `debounce` function that I am going to create will take in a Svelte store
    and return a new Svelte store that has its store value debounced based on the
    input Svelte store value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要创建的 `debounce` 函数将接受一个 Svelte 存储，并返回一个新的 Svelte 存储，其存储值基于输入 Svelte 存储值进行防抖：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code snippet, in the fourth line, I demonstrated how to use
    the `debounce` function that we’re going to implement in this section. This `debounce`
    function accepts a Svelte store as an argument and returns an enhanced version
    of it, which we’ll call `debouncedStore`. To showcase the debounce functionality,
    the values of both the original `store` and `debouncedStore` arguments are displayed
    side by side.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，第四行展示了我们将在此部分实现 `debounce` 函数的使用方法。这个 `debounce` 函数接受一个 Svelte 存储作为参数，并返回其增强版本，我们将其称为
    `debouncedStore`。为了展示防抖功能，原始 `store` 和 `debouncedStore` 参数的值并排显示。
- en: Before we start implementing the `debounce` function, let’s talk about what
    debounce is.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现 `debounce` 函数之前，让我们谈谈什么是防抖。
- en: Debouncing store value changes
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防抖存储值变化
- en: In engineering, debounce is the process of removing unwanted input noises from
    user input. In web development, debounce is used when there are too many user
    events, and we want to trigger an event handler or process the event only after
    the user event settles.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程学中，防抖是从用户输入中移除不想要的输入噪声的过程。在 Web 开发中，当有太多用户事件时，我们会使用防抖，只在用户事件稳定后触发事件处理器或处理事件。
- en: Here’s an example of debounce. When implementing an autocomplete search, we
    wouldn’t want to trigger the search for an autocomplete result on every character
    the user types; rather, we’d only start searching after the user stops typing.
    This saves resources as the autocomplete result may no longer be usable as soon
    as the user types the next character.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个防抖的例子。在实现自动完成搜索时，我们不想在用户输入每个字符时都触发自动完成结果的搜索；相反，我们只在用户停止输入后才开始搜索。这样可以节省资源，因为当用户输入下一个字符时，自动完成结果可能就不再可用。
- en: Applying the concept of debounce to a Svelte store, we are going to create a
    new debounced Svelte store based on an input Svelte store. When the input Svelte
    store value updates, the debounced Svelte store only updates after the Svelte
    store updates settle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将防抖的概念应用于 Svelte 存储，我们将创建一个新的基于输入 Svelte 存储的防抖 Svelte 存储。当输入 Svelte 存储的值更新时，防抖
    Svelte 存储仅在 Svelte 存储更新稳定后才会更新。
- en: If we are going to create a debounced Svelte store from scratch, we can build
    it up based on a writable store. I showed you how to create a custom Svelte store
    from a writable store in the last section, so I hope you know how to do that.
    Do try it out yourself; when you are done, compare it with my implementation at
    [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从头开始创建一个延迟的 Svelte 存储，我们可以基于可写存储构建它。我在上一节中展示了如何从可写存储创建自定义 Svelte 存储，所以我希望你知道如何做。请亲自尝试一下；当你完成时，将你的实现与我提供的实现进行比较，请参阅[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/05-debounce-store)。
- en: But in this section, we are going to create a higher-order store. We already
    have a Svelte store. It could be a writable store or an undo/redo store. Our debounce
    function is going to take in the Svelte store and return a debounced version of
    the Svelte store.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但在本节中，我们将创建一个高阶存储。我们已经有了一个 Svelte 存储。它可能是一个可写存储或撤销/重做存储。我们的延迟函数将接受 Svelte 存储，并返回一个延迟版本的
    Svelte 存储。
- en: Let’s start with the basic structure of a `debounce` higher-order store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `debounce` 高阶存储的基本结构开始。
- en: The `debounce` function is going to return a new Svelte store. It is still much
    easier to build a new Svelte store based on a writable store than to implement
    it from scratch, create a subscribe function, and maintain an array of subscribers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounce` 函数将返回一个新的 Svelte 存储。基于可写存储构建一个新的 Svelte 存储比从头开始实现它、创建一个订阅函数和维护订阅者数组要容易得多。'
- en: 'Here’s the basic outline of the `debounce` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `debounce` 函数的基本框架：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code snippet, the returned Svelte store is going to be based
    on the writable store, so the `subscribe` method is going to be the writable store’s
    `subscribe` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，返回的 Svelte 存储将基于可写存储，因此 `subscribe` 方法将是可写存储的 `subscribe` 方法。
- en: The `set` method is going to be the original store’s `set` method, instead of
    a new `set` function. We are not going to create a separate `set` function where
    it sets the original store and tries to set out a debounced store with the debounce
    logic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 方法将是原始存储的 `set` 方法，而不是一个新的 `set` 函数。我们不会创建一个单独的 `set` 函数，在其中设置原始存储并尝试使用延迟逻辑设置一个延迟的存储。'
- en: 'We are not going to do like it’s done in this snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会像这个片段中那样做：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code snippet, we intercepted the `set` method and relayed
    it to both the original store and the debounced store. We are not going to do
    that because we want to preserve the original Svelte store logic. When a value
    is passed to the `set` method, it may undergo transformations, especially if the
    store is a custom Svelte store. The `value` argument in the `set` method may not
    be the same as the final store value. So instead, we let the original store handle
    these potential transformations and subscribe to the original Svelte store to
    get the final store value. We use the final store value and update the debounced
    store as the original store value changes, as illustrated in the following code
    snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们拦截了 `set` 方法并将其转发到原始存储和延迟存储。我们不会这样做，因为我们想保留原始 Svelte 存储的逻辑。当一个值传递给
    `set` 方法时，它可能会经历转换，特别是如果存储是自定义 Svelte 存储。`set` 方法中的 `value` 参数可能不等于最终的存储值。因此，我们让原始存储处理这些潜在的转换，并订阅原始
    Svelte 存储以获取最终的存储值。我们使用最终的存储值，并在原始存储值变化时更新延迟存储，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code snippet, I show how to subscribe to the original Svelte
    store rather than intercepting its `set` method. This approach allows us to keep
    the original store’s logic intact while still benefiting from its features. It
    also takes care of situations when the original Svelte store value could change
    by other methods. An example of this is the `undo()` and `redo()` methods of the
    undo/redo store. If we only intercepted the value from the `set` function, as
    in the preceding code snippet, then the debounced Svelte store would not change
    when the original undo/redo store was being undone or redone.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我展示了如何订阅原始 Svelte 存储而不是拦截其 `set` 方法。这种方法允许我们保持原始存储的逻辑完整，同时仍然受益于其功能。它还处理了原始
    Svelte 存储值可能通过其他方法更改的情况。这种情况的一个例子是撤销/重做存储的 `undo()` 和 `redo()` 方法。如果我们只拦截 `set`
    函数的值，就像前面的代码片段中那样，那么当原始撤销/重做存储正在撤销或重做时，延迟的 Svelte 存储不会改变。
- en: To implement the debounce logic, we are going to use a timeout to update the
    debounced Svelte store. If there are new changes to the original Svelte store
    within the timeout, then we are going to cancel the previous timeout and set a
    new timeout. If not, then we assume the changes have settled, and we update the
    `debounced` store.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现去抖逻辑，我们将使用一个超时来更新去抖动的Svelte存储库。如果在超时期间原始Svelte存储库有新的变化，我们将取消之前的超时并设置一个新的超时。如果没有，那么我们假设变化已经稳定，我们将更新`debounced`存储库。
- en: 'Here’s the updated code snippet with the debounce logic:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有去抖逻辑的更新代码片段：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, we use the `setTimeout` function within the `subscribe`
    callback to set a timeout for 200 ms. During this time, if the original store’s
    value changes again, the existing timeout will be cleared, and a new one will
    be set. But if there’s a new value within the 200 ms time period, we will update
    the `debounced` store with the latest value from the original store.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`subscribe`回调函数中使用`setTimeout`函数设置了一个200毫秒的超时。在这段时间内，如果原始存储库的值再次变化，现有的超时将被清除，并设置一个新的超时。但如果在200毫秒的时间段内有新值，我们将使用原始存储库的最新值更新`debounced`存储库。
- en: Try out the `debounced` store and see that the store value is now debounced
    from the changes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`debounced`存储库，并查看存储库的值现在已从变化中去抖动。
- en: One thing you might notice is that we subscribed to the original Svelte store
    but haven’t unsubscribed from it. Let’s address that next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们订阅了原始的Svelte存储库，但还没有取消订阅它。让我们接下来解决这个问题。
- en: Subscribing and unsubscribing original store on demand
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据需要订阅和取消订阅原始存储库
- en: Before we wrap up, there’s one small issue with the `debounced` store that we’ve
    implemented so far. We subscribed to the original Svelte store at the creation
    of the `debounced` Svelte store and we never unsubscribed from it, even though
    the `debounced` Svelte store may no longer be in use. We should only start subscribing
    to the original Svelte store when there’s already a subscriber to the `debounced`
    Svelte store and unsubscribe when there is no longer any subscriber.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，我们实现到目前为止的`debounced`存储库有一个小问题。我们在创建`debounced` Svelte存储库时订阅了原始的Svelte存储库，但我们从未取消订阅它，即使`debounced`
    Svelte存储库可能不再被使用。我们应该只在`debounced`存储库已经有订阅者时才开始订阅原始的Svelte存储库，并在没有订阅者时取消订阅。
- en: 'We could intercept the `subscribe` method and attempt to unsubscribe from the
    original Svelte store when the debounced Svelte store is being unsubscribed, like
    so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拦截`subscribe`方法，并在去抖动的Svelte存储库被取消订阅时尝试取消订阅原始的Svelte存储库，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the updated code snippet, the `subscribe` method now subscribes to both the
    `debounced` store and the original Svelte store. In the `return` function, which
    is used to unsubscribe from the `debounced` store, we also make sure to unsubscribe
    from the original Svelte store.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的代码片段中，`subscribe`方法现在同时订阅了`debounced`存储库和原始Svelte存储库。在用于取消订阅`debounced`存储库的`return`函数中，我们也确保取消订阅原始Svelte存储库。
- en: However, this is not quite right. Doing it this way means that we subscribe
    to the original store every time we subscribe to the debounced store and unsubscribe
    from the original store every time we unsubscribe from the debounced store.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不完全正确。这样做意味着每次我们订阅去抖动存储库时，我们都会订阅原始存储库，每次我们取消订阅去抖动存储库时，我们都会取消订阅原始存储库。
- en: We should aim to subscribe to the original store just once, regardless of how
    many subscribers there are. Similarly, we should unsubscribe from it only when
    there are no subscribers left. Does this sound familiar?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该旨在只订阅原始存储库一次，无论有多少订阅者。同样，只有当没有订阅者剩下时，我们才应该取消订阅它。这听起来熟悉吗？
- en: We ran into a similar conundrum in the previous section when we were trying
    to implement a click-counter Svelte store. We tried to maintain a list of subscribers
    before we found out that Svelte provides a built-in `writable()` function that
    neatly takes care of that for us.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当我们尝试实现一个点击计数器Svelte存储库时，我们遇到了一个类似的难题。在我们发现Svelte提供了一个内置的`writable()`函数可以很好地处理这个问题之前，我们试图维护一个订阅者列表。
- en: So, is there a built-in function that allows us to only subscribe to another
    store once a store is being subscribed, and only unsubscribe from that store once
    there are no more subscribers in a store?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有没有一个内置函数允许我们在订阅另一个存储库时只订阅一次，并且只有当存储库中没有更多订阅者时才取消订阅该存储库？
- en: Yes—this is where `derived()` comes into play.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——这正是`derived()`发挥作用的地方。
- en: Deriving a new Svelte store with the derived() function
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`derived()` is a built-in function from Svelte that takes in one or multiple
    Svelte stores and returns a new Svelte store whose store value is based on the
    input Svelte stores.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use `derived()` to define a Svelte store whose store value
    is always double that of another Svelte store, as seen in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or, this could be a Svelte store whose store value is the sum of two Svelte
    stores, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we are using a `$`-prefixed variable in the callback function
    of the `derived()` function; for example, `$store1` and `$store2`. However, it
    does not work the same way as the `$`-prefixed variable at the top level of the
    script, where it auto-subscribes to the store and is referenced as the store value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is merely a convention that some people use to denote that
    the variable is used to reference the value of a store. It is the same as any
    other variable name and nothing more.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: When using `derived()`, Svelte only subscribes to the input Svelte stores—for
    example, `store1` and `store2`—only when the returned Svelte store—for example,
    `sum`—is being subscribed to, and will unsubscribe from the input Svelte stores
    when there are no more subscribers to the returned Svelte store.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Before we rewrite our `debounce` higher-order store using `derived()`, let’s
    dive a little bit more into the `derived()` function first.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The `derived()` function provides two approaches to determine the store value
    of the returned Svelte store: synchronous or asynchronous.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The synchronous approach means that as soon as any of the input Svelte store’s
    values change, the store value of the returned Svelte store is determined synchronously.
    By the same token, the asynchronous approach means it is determined asynchronously,
    which means the store value can be set later after the input Svelte store’s value
    has changed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The two examples that I showed at the beginning of this section use the synchronous
    approach, where the store value of the returned Svelte store is synchronously
    calculated and set right after the input Svelte store has changed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous approach can be useful when the store value of the returned
    Svelte store is determined through some asynchronous operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether the derived store is using the synchronous or asynchronous
    approach, the `derived()` method looks at the function signature of the callback
    function. If it takes in one parameter, then it is considered a synchronous approach.
    If it takes in two, then it is an asynchronous approach. To get a better idea,
    check out the following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In both cases, the callback function will be called every time any of the input
    Svelte store values change.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If the derived store uses the synchronous approach, the returned value of the
    callback function is used as the new store value of the returned Svelte store.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If the derived store uses the asynchronous approach, then the second parameter
    of the callback function is a `set` function. The `set` function can be used to
    set the value of the returned store at any time. The returned value of the callback
    function, however, will be treated as a cleanup function that will be called right
    before the callback function is called again.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生存储使用异步方法，则回调函数的第二个参数是一个 `set` 函数。`set` 函数可以用来在任何时候设置返回存储的值。然而，回调函数的返回值将被视为一个清理函数，它将在再次调用回调函数之前立即被调用。
- en: Now that we are more familiar with the `derived()` function, let's rewrite our
    `debounce` higher-order store using `derived()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `derived()` 函数更熟悉了，让我们使用 `derived()` 重新编写我们的 `debounce` 高阶存储。
- en: Using the derived method
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用派生方法
- en: 'Here is the updated code for our `debounced` store rewritten using the `derived()`
    method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `derived()` 方法重写的 `debounced` 存储的更新代码：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of creating a new `debounced` store using `writable()`, we derived it
    from the original store using the `derived()` method. We shifted the `setTimeout`
    function into the `derived()` method callback. When there’s a new value from the
    original Svelte store, we will clear the timeout and set a new timeout.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用 `writable()` 创建一个新的 `debounced` 存储，而是使用 `derived()` 方法从原始存储中派生它。我们将 `setTimeout`
    函数移入 `derived()` 方法回调中。当原始 Svelte 存储有新值时，我们将清除超时并设置一个新的超时。
- en: The `derived()` function will subscribe to the original Svelte store once only
    when the `debounced` store is being subscribed to and unsubscribe from the original
    Svelte store when there are no more subscribers for the `debounced` store.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`derived()` 函数将在订阅 `debounced` 存储时仅订阅一次原始 Svelte 存储，并在没有更多订阅者时取消订阅原始 Svelte
    存储。'
- en: Since we are only going to update the `debounced` store asynchronously after
    a timeout, we pass a callback function with two parameters into the `derived()`
    function. We call the `set` function to set the value of the `debounced` store
    after the timeout. If the value of the original Svelte store changes before the
    timeout, then the returned function of the callback function will be called first
    before the callback function is called again with the updated store value of the
    original Svelte store. In the returned function, we clear the timeout since we
    no longer need it anymore.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在超时后异步更新 `debounced` 存储，我们将带有两个参数的回调函数传递给 `derived()` 函数。我们调用 `set` 函数在超时后设置
    `debounced` 存储的值。如果原始 Svelte 存储的值在超时之前发生变化，则回调函数返回的函数将在再次使用原始 Svelte 存储的更新存储值调用回调函数之前首先被调用。在返回的函数中，我们清除超时，因为我们不再需要它了。
- en: 'One last thing before we conclude—sometimes, the original Svelte store may
    contain additional methods, such as the `undo()` and `redo()` methods in the case
    of an undo/redo store. These methods should also be defined in the debounced store
    returned by our higher-order function. This ensures that the enhanced store maintains
    all the same methods and behaviors as the input store while adding the debouncing
    feature. You can see an illustration of this in the following code snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，还有最后一件事——有时，原始 Svelte 存储可能包含额外的函数，例如在撤销/重做存储中的 `undo()` 和 `redo()` 方法。这些方法也应该在我们的高阶函数返回的
    `debounced` 存储中定义。这确保了增强的存储在添加防抖功能的同时，保持了所有相同的方法和行为。你可以在下面的代码片段中看到这个示例：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To return all the methods from the original Svelte store, we use the spread
    operator (`...`) to spread all the methods from the original Svelte store:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回原始 Svelte 存储的所有方法，我们使用扩展运算符 (`...`) 来扩展原始 Svelte 存储的所有方法：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, we do not even need to have `set: store.set` since the `set`
    method will be spread into the returned Svelte store too!'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们甚至不需要 `set: store.set`，因为 `set` 方法也会扩展到返回的 Svelte 存储中！'
- en: That’s it! In this section, you’ve learned another trick—creating a higher-order
    store, a function that takes in an existing Svelte store and returns a new Svelte
    store enhanced with new behavior. Instead of building a custom Svelte store with
    all the logic in it, we can now create smaller well-encapsulated higher-order
    stores and put them into a custom Svelte store that you need.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！在本节中，你学到了另一个技巧——创建一个高阶存储，这是一个接受现有 Svelte 存储并返回一个具有新行为的新的 Svelte 存储的函数。我们不再需要构建一个包含所有逻辑的自定义
    Svelte 存储，现在我们可以创建更小、封装良好的高阶存储，并将它们放入你需要的自定义 Svelte 存储中。
- en: Exercise
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Now, it’s time for an exercise.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行练习了。
- en: The undo/redo store in the previous section is created as a custom Svelte store.
    Can you create an undo/redo higher-order store that turns any Svelte store into
    an undo/redo store with two additional methods, `undo()` and `redo()`?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的撤销/重做存储被创建为一个自定义的Svelte存储。你能创建一个撤销/重做高阶存储，将任何Svelte存储转换为具有两个额外方法`undo()`和`redo()`的撤销/重做存储吗？
- en: 'Here’s an example of how the undo/redo higher-order store would be used:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个撤销/重做高阶存储的使用示例：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code snippet shows how we use the undo/redo higher-order store,
    `undoRedo`. The `undoRedo` function takes in a store, named `originalStore`, and
    returns a new store based on `originalStore` that has the undo/redo capability.
    For example, if we set a new value and then call the `undo` method, the store
    value will revert to its original state, which is `5` in this case.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段展示了我们如何使用撤销/重做高阶存储`undoRedo`。`undoRedo`函数接收一个存储，命名为`originalStore`，并返回一个基于`originalStore`的新存储，该存储具有撤销/重做功能。例如，如果我们设置了一个新值然后调用`undo`方法，存储的值将恢复到其原始状态，在这个例子中是`5`。
- en: 'You can find the solution for this exercise on GitHub here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这个练习的解决方案：
- en: '[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store%0D)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter09/07-exercise-undo-redo-higher-order-store%0D)'
- en: In this section, we’ve explored the process of creating a `debounce` higher-order
    Svelte store using the `derived()` method. I look forward to you applying this
    knowledge in real-world scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了使用`derived()`方法创建`debounce`高阶Svelte存储的过程。我期待你在实际场景中应用这些知识。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at three different examples and learned three different
    techniques with a Svelte store.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了三个不同的示例，并学习了使用Svelte存储的三个不同技术。
- en: We explored how to turn any user events into a data source for a Svelte store,
    learned how to create a Svelte store from scratch, and also learned how to use
    the built-in `readable()` function to make the process much simpler.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何将任何用户事件转换为Svelte存储的数据源，学习了如何从头创建Svelte存储，还学习了如何使用内置的`readable()`函数使过程变得更加简单。
- en: After that, we explored making a custom Svelte store with additional methods,
    building a new Svelte store based on the built-in writable store.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们探讨了创建一个带有额外方法的自定义Svelte存储，基于内置的可写存储构建一个新的Svelte存储。
- en: Lastly, we learned to create a higher-order store, a function that takes in
    a Svelte store and returns an enhanced version of the input store. In the example,
    we see how we can turn any Svelte store into a debounced version of itself.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何创建一个高阶存储，这是一个接收Svelte存储并返回输入存储增强版本的函数。在示例中，我们看到如何将任何Svelte存储转换为自身的防抖版本。
- en: By understanding these techniques, you’re now equipped to manage state in Svelte
    more effectively to craft more scalable and maintainable applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些技术，你现在可以更有效地在Svelte中管理状态，以构建更可扩展和可维护的应用程序。
- en: In the next chapter, we will look at state management in Svelte—namely, how
    to do state management with Svelte stores.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Svelte中的状态管理——具体来说，如何使用Svelte存储进行状态管理。
