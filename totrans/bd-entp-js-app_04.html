<html><head></head><body>
        

                            
                    <h1 class="header-title">Setting Up Development Tools</h1>
                
            
            
                
<p>The first section of this book (Chapters 1-3) was written to provide sufficient background knowledge so that we can code without interruption. In this chapter, we will actually start building our user directory application, called 'hobnob', by setting up our local development environment.</p>
<p>The aim of this chapter is to help you understand how different tools and standards in the Node.js ecosystem work together. Specifically, we'll cover the following:</p>
<ul>
<li>What is <strong>Node.js</strong>?</li>
<li>Different formats/standards for JavaScript <strong>modules</strong></li>
<li>Managing modules with <kbd>npm</kbd> and <kbd>yarn</kbd></li>
<li>Transpiling code with <strong>Babel</strong></li>
<li>Watching for changes with <kbd>nodemon</kbd></li>
<li>Linting our code with <strong>ESLint</strong></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is Node.js?</h1>
                
            
            
                
<p>As you learned in <a href="47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml" target="_blank">Chapter 2</a>, <em>The State of JavaScript</em>, Node.js is "JavaScript on the server". Before we move forward, let's delve a little deeper into understanding what that means.</p>
<p>Traditionally, JavaScript is interpreted by a JavaScript engine that converts JavaScript code into more optimized, machine-executable code, which then gets executed. The engine interprets the JavaScript code at the time it is run. This is unlike <strong>compiled languages</strong> such as C#, which must first be compiled into an <strong>intermediate language</strong> (<strong>IL</strong>), where this IL is then executed by the <strong>common language runtime</strong> (<strong>CLR</strong>), software similar in function to the JavaScript engine.</p>
<p class="mce-root"/>
<p>Technically, it is inaccurate to classify a language as interpreted or compiled—how a language is processed depends on the implementation. Someone can build a compiler that converts JavaScript into machine code and run it; in that instance, JavaScript would be a compiled language.<br/>
<br/> However, since JavaScript is almost always interpreted by a JavaScript engine, you'll often hear people refer to JavaScript as an interpreted language.<br/></p>
<p>Different browsers use different JavaScript engines. Chrome uses V8, Firefox uses SpiderMonkey, WebKit browsers such as Safari use JavaScriptCore, and Microsoft Edge uses Chakra. Node.js uses V8 as its JavaScript engine and adds C++ bindings that allow it to access operating system resources, such as files and networking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Terminology</h1>
                
            
            
                
<p class="mce-root">Because JavaScript was traditionally interpreted at runtime, and because runtimes in other languages (such as C#, mentioned before) do actually execute the code, many people incorrectly call the JavaScript engine the JavaScript runtime.</p>
<p class="mce-root">But, they are different things—the engine is the software that translates the high-level JavaScript code into machine-executable code, and then executes it. The JavaScript engine then exposes all the objects obtained from parsing the code to the JavaScript runtime environment, which can then use it.</p>
<p class="mce-root">So, JavaScript in the browser and Node.js both use the same V8 engine, but run in different runtime environments. For example, the browser runtime environment provides the <kbd>window</kbd> global object, which is not available in the Node.js runtime. Conversely, the browser runtime lacks the <kbd>require</kbd> global, and cannot act on system resources such as file systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modules</h1>
                
            
            
                
<p>As mentioned in <a href="c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml" target="_blank">Chapter 1</a>, <em>The Importance of Good Code</em>, clean code should be structured in a modular way. In the next few sections, we'll introduce you to the concept of modular design, before explaining the different module formats. Then, for the rest of the chapter, we will begin composing our project by incorporating existing Node modules.</p>
<p class="mce-root"/>
<p>But first, let's remind ourselves why modular design is important. Without it, the following apply:</p>
<ul>
<li>Logic from one business domain can easily be interwoven with that of another</li>
<li>When debugging, it's hard to identify where the bug is</li>
<li>There'll likely be duplicate code</li>
</ul>
<p>Instead, writing modular code means the following:</p>
<ul>
<li>Modules are logical separations of domains—for example, for a simple social network, you might have a module for user accounts, one for user profiles, one for posts, one for comments, and so on. This ensures a clear <strong>separation of concerns</strong>.</li>
<li>Each module should have a very specific purpose—that is, it should be granular. This ensures that there is as much <strong>code reusability</strong> as possible. A side effect of code reusability is <em>consistency</em>, because changes to the code in one location will be applied everywhere.</li>
<li>Each module provides an API for other modules to interact with—for example, the comments module might provide methods that allow for creating, editing, or deleting a comment. It should also hide internal properties and methods. This turns the module into a black box, encapsulating internal logic to ensure that the API is as minimal as is practical.</li>
</ul>
<p>By writing our code in a modular way, we'll end up with many small and manageable modules, instead of one uncontrollable mess.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The dawn of modules</h1>
                
            
            
                
<p>Modules were not supported in JavaScript until ECMAScript 2015, because JavaScript was initially designed to add small bits of interactivity to web pages, not to cater for building full-fledged applications. When developers wanted to use a library or framework, they'd simply add <kbd>&lt;script&gt;</kbd> tags somewhere inside the HTML, and that library would be loaded when the page was loaded. However, this is not ideal as the scripts must be loaded in the correct order. For example, Bootstrap (a UI framework) depends on jQuery (a utility library), so we must manually check that the jQuery script is added first:</p>
<pre>&lt;!-- jQuery - this must come first --&gt;<br/>&lt;script src="img/jquery-3.2.1.min.js"&gt;&lt;/script&gt;<br/><br/>&lt;!-- Bootstrap's JavaScript --&gt;<br/>&lt;script src="img/bootstrap.min.js"&gt;&lt;/script&gt;</pre>
<p>This is fine as the dependency tree is relatively small and shallow. However, as <strong>single-page applications</strong> (<strong>SPAs</strong>) and Node.js applications become more popular, applications inevitably become more complex; having to manually arrange hundreds of modules in the correct order is impractical and error-prone:</p>
<div><img src="img/f04647ba-e067-422b-9d24-c1e37fe4bfee.png" style="width:39.75em;height:42.58em;"/></div>
<p>The dependency tree for the Cordova npm package, where each node represents a discrete module</p>
<p class="mce-root"/>
<p>Furthermore, many of these scripts add variables to the global namespace, or extend the prototypes of existing objects (for example, <kbd>Object.prototype</kbd> or <kbd>Array.prototype</kbd>). Because they are usually not namespaced, the scripts can clash/interfere with each other, or with our code.</p>
<p>Because of the increasing complexity of modern applications, developers started creating <strong>package managers</strong> to organize their modules. Moreover, standard formats began to appear so that modules could be shared with the wider community.</p>
<p>At the time of writing, there are three major package managers—<strong>npm</strong>, <strong>Bower</strong>, and <strong>y</strong><strong>arn</strong>—and four major standards in defining JavaScript modules—<strong>CommonJS</strong>, <strong>AMD</strong>, <strong>UMD</strong>, and <strong>ES6 modules</strong>. Each format also has accompanying tools to enable them to work on browsers, such as <strong>RequireJS</strong>, <strong>Browserify</strong>, <strong>Webpack</strong>, <strong>Rollup</strong>, and <strong>SystemJS</strong>.</p>
<p>In the following section, we'll give a quick overview of different types of package managers, modules, and their tools. At the end of this section, we'll look more specifically at ES6 modules, which we will use for the rest of the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The birth of Node.js modules</h1>
                
            
            
                
<p>Using modules on the client was infeasible because an application can have hundreds of dependencies and sub-dependencies; having to download them all when someone visits the page is going to increase the <strong>time-to-first-render</strong> (<strong>TTFR</strong>), drastically impacting the user experience (UX). Therefore, JavaScript modules, as we know them today, began their ascent on servers with Node.js modules.</p>
<p class="mce-root">In Node.js, a single file corresponds to a single module:</p>
<pre class="mce-root"><strong>$ tree</strong><br/><strong>.</strong><br/><strong>├── greeter.js</strong><br/><strong>└── main.js</strong><br/><strong>0 directories, 2 files</strong></pre>
<p>For instance, both of the preceding files—<kbd>greeter.js</kbd> and <kbd>main.js</kbd>—are each their own module.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adoption of the CommonJS standard</h1>
                
            
            
                
<p>In Node.js, modules are written in the CommonJS format, which provides two global objects, <kbd>require</kbd> and <kbd>exports</kbd>, that developers can use to keep their modules encapsulated. <kbd>require</kbd> is a function that allows the current module to import and use variables defined in other modules. <kbd>exports</kbd> is an object that allows a module to make certain variables publicly available to other modules that <kbd>require</kbd> it.</p>
<p>For example, we can define two functions, <kbd>helloWorld</kbd> and <kbd>internal</kbd>, in <kbd>greeter.js</kbd>:</p>
<pre>// greeter.js<br/>const helloWorld = function (name) {<br/>  process.stdout.write(`hello ${name}!\n`)<br/>};<br/>const internal = function (name) {<br/>  process.stdout.write('This is a private function')<br/>};<br/>exports.sayHello = helloWorld;</pre>
<p>By default, these two functions can only be used within the file (within the module). But, when we assign the <kbd>helloWorld</kbd> function to the <kbd>sayHello</kbd> property of <kbd>exports</kbd>, it makes the <kbd>helloWorld</kbd> function accessible to other modules that  <kbd>require</kbd> the <kbd>greeter</kbd> module.</p>
<p>To demonstrate this, we can <kbd>require</kbd> the greeter module in <kbd>main.js</kbd> and use its <kbd>sayHello</kbd> export to print a message to the console:</p>
<pre>// main.js<br/>const greeter = require('./greeter.js');<br/>greeter.sayHello("Daniel");</pre>
<p>To <kbd>require</kbd> a module, you can either specify its name or its file path.</p>
<p>Now, when we run <kbd>main.js</kbd>, we get a message printed in the Terminal:</p>
<pre class="mce-root"><strong>$ node main.js </strong><br/><strong>hello Daniel!</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Fulfilling the encapsulation requirement</h1>
                
            
            
                
<p>You can export multiple constructs from a single module by adding them as properties to the <kbd>exports</kbd> object. Constructs that are not exported are not available outside the module because Node.js wraps its modules inside a <strong>module wrapper</strong>, which is simply a function that contains the module code:</p>
<pre>(function(exports, require, module, __filename, __dirname) {<br/>  // Module code<br/>});</pre>
<p>This fulfills the encapsulation requirement of modules; in other words, the module restricts direct access to certain properties and methods of the module. Note that this is a feature of Node.js, not CommonJS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standardizing module formats</h1>
                
            
            
                
<p>Since CommonJS, multiple module formats have emerged for client-side applications, such as AMD and UMD. AMD, or <em>Asynchronous Module Definition</em>, is an early fork of the CommonJS format, and supports <strong>asynchronous module loading</strong>. This means modules that do not depend on each other can be loaded in parallel, partially alleviating the slow startup time that clients face if they use CommonJS on the browser.</p>
<p>Whenever there are multiple unofficial standards, someone will usually come up with a <em>new</em> standard that's supposed to unify them all:</p>
<div><img src="img/e0298913-b74a-4ddf-aec5-dcc9d7210b65.png" style="width:29.33em;height:16.58em;"/></div>
<p>From the XKCD comic titled "Standards" (<a href="https://xkcd.com/927/" target="_blank">h</a><a href="https://xkcd.com/927/" target="_blank">ttps://xkcd.com/927/</a>); used with permission under a Creative Commons Attribution-NonCommercial 2.5 License (<a href="http://creativecommons.org/licenses/by-nc/2.5/">http://creativecommons.org/licenses/by-nc/2.5/</a>)</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is what happened with UMD, or <em>Universal Module Definition</em>. UMD modules are compatible with both AMD and CommonJS, and this also exposes a global variable if you want to include it on your web page as a <kbd>&lt;script&gt;</kbd> tag. But, because it tries to be compatible with all formats, there's a lot of boilerplate.</p>
<p class="mce-root">Eventually, the task of unifying JavaScript module formats was taken on by the <strong>Ecma International</strong>, which standardized modules in the ECMAScript 2015 (ES6) version of JavaScript. This module format uses two keywords: <kbd>import</kbd> and <kbd>export</kbd>. The same <kbd>greeter</kbd> example would look like this with ES6 modules:</p>
<pre class="mce-root">// greeter.js<br/><br/>const helloWorld = function (name) {<br/>  process.stdout.write(`hello ${name}!\n`)<br/>};<br/>const privateHellowWorld = function (name) {<br/>  process.stdout.write('This is a private function')<br/>};<br/>export default helloWorld;<br/><br/>// main.js<br/><br/>import greeter from "./greeter.js";<br/>greeter.sayHello("Daniel");</pre>
<p>You'd still have two files—<kbd>greeter.js</kbd> and <kbd>main.js</kbd>; the only difference here is that <kbd>exports.sayHello = helloWorld;</kbd> is replaced by <kbd>export default helloWorld;</kbd>, and <kbd>const greeter = require('./greeter.js');</kbd> is replaced by <kbd>import greeter from "./greeter.js";</kbd>.</p>
<p class="mce-root">Furthermore, ES6 modules are <strong>static</strong>, meaning they cannot be changed at runtime. In other words, you cannot decide during runtime whether a module should be imported. The reason for this is to allow the modules to be analyzed and the dependency graph to be built beforehand.</p>
<p class="mce-root">Node.js and popular browsers are quickly adding support for ECMAScript 2015 features, but currently none of them fully support modules.</p>
<p>You can view the full compatibility table for ECMAScript features in the Kangax Compatibility Table at <a href="http://kangax.github.io/compat-table/es6/">kangax.github.io/compat-table/</a>.</p>
<p class="mce-root"/>
<p class="mce-root">Luckily, there are tools that can convert ECMAScript 2015 modules into the universally supported CommonJS format. The most popular are <strong>Babel</strong> and <strong>Traceur</strong>. In this book, we will use Babel because it is the <em>de facto</em> standard.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Node</h1>
                
            
            
                
<p>With that background on modules out of the way, let's begin the development of our application by installing Node.js on our local machine. Just like the saying "Many roads lead to Rome", there are many ways to install Node.js on your machine. You can do one of the following:</p>
<ul>
<li>Go to <a href="https://nodejs.org/en/download/">https://nodejs.org/</a> and download its source code (in the form of a <kbd>*.tar.gz</kbd> archive)</li>
<li>Go to <a href="https://nodejs.org/en/download/">https://nodejs.org/</a> and download an installer</li>
<li>Go to <a href="https://nodejs.org/en/download/package-manager/">https://nodejs.org/en/download/package-manager/</a> and download the Node version that's listed on your operating system's package repository</li>
</ul>
<p>But the easiest way is to use <strong>Node Version Manager</strong> (<strong>nvm</strong>), which has the added benefit of allowing you to download and switch between different versions of Node. This is especially handy if you're working on different Node projects at the same time, each using a different version.</p>
<p>There are several popular programs that manage the Node versions for you. <kbd>nvm</kbd> and <kbd>nave</kbd> manage Node versions per user/shell, which means different users on the same machine can use different versions of Node. There's also <kbd>n</kbd>, which manages the global/system-wide Node version. Lastly, <kbd>nodenv</kbd> can also be useful as it can automatically detect the correct version of Node to use for your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using nvm to install Node</h1>
                
            
            
                
<p>You can install nvm using the shell script it provides:</p>
<pre><strong>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</strong><br/><strong>$ source ~/.nvm/nvm.sh</strong></pre>
<p>Note that it is never a good idea to run a shell script directly from the internet without first examining the content. Therefore, you should first go to <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh">https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh</a> and check the commands that would be run before you actually run it.</p>
<p>This will clone the nvm repository to <kbd>~/.nvm</kbd> and adds a line to your profile (<kbd>~/.bash_profile</kbd>, <kbd>~/.zshrc</kbd>, <kbd>~/.profile</kbd>, or <kbd>~/.bashrc</kbd>) so that nvm will be loaded when your user logs in.</p>
<p>Now, we can use nvm to install Node. First, let's check the versions of Node that are available using the <kbd>nvm ls-remote</kbd> command:</p>
<pre><strong>$ nvm ls-remote</strong><br/><strong>        ...</strong><br/><strong>     v0.12.17</strong><br/><strong>     v0.12.18</strong><br/><strong>        ...</strong><br/><strong>       v8.11.3 (LTS: Carbon)</strong><br/><strong>       v8.11.4 (Latest LTS: Carbon)</strong><br/><strong>       ...</strong><br/><strong>       v10.8.0</strong><br/><strong>       v10.9.0</strong></pre>
<p>It will come back with a huge list of every Node.js version, and we can install a specific version by running <kbd>nvm install &lt;version&gt;</kbd>, where version is the version number (for example, <kbd>6.11.1</kbd>) or the name of the long-term support (LTS) version (for example, <kbd>lts/boron</kbd>):</p>
<pre><strong>$ nvm install 6.11.1</strong><br/><strong>$ nvm install lts/boron</strong></pre>
<p>We want to use the latest LTS version of Node. At the time of writing, that's <kbd>8.11.4</kbd>, so we can run <kbd>nvm install 8.11.4</kbd>. Better still, we can use the shorthand <kbd>nvm install lts/*</kbd>, which will default to the latest LTS version of Node:</p>
<pre><strong>$ nvm install lts/*</strong><br/><strong>Downloading and installing node v8.11.4...</strong><br/><strong>Downloading https://nodejs.org/dist/v8.11.4/node-v8.11.4-linux-x64.tar.xz...</strong><br/><strong>######################################################################### 100.0%</strong><br/><strong>Computing checksum with sha256sum</strong><br/><strong>Checksums matched!</strong><br/><strong>Now using node v8.11.4 (npm v5.6.0)</strong></pre>
<p>We can check that Node has been successfully installed by running <kbd>node -v</kbd>:</p>
<pre><strong>$ node -v</strong><br/><strong>v8.11.4</strong></pre>
<p>When we installed Node, we also automatically installed the npm CLI, which is the package manager for Node.js:</p>
<pre><strong>$ npm -v</strong><br/><strong>5.5.1</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Documenting Node versions</h1>
                
            
            
                
<p>We should document which version of Node we are running our API server with. To do this with nvm, we simply have to define a <kbd>.nvmrc</kbd> file in the root directory of our project. Then, any developers working on the API will be able to use the right Node version by running <kbd>nvm use</kbd>. Therefore, create a new project directory and run <kbd>git init</kbd> to create a new Git repository. Once that's done, create a new <kbd>.nvmrc</kbd> file that contains a single line that reads <kbd>8.11.4</kbd>:</p>
<pre><strong>$ mkdir hobnob &amp;&amp; cd hobnob</strong><br/><strong>$ git init</strong><br/><strong>$ echo "8.11.4" &gt; .nvmrc</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Starting projects with npm</h1>
                
            
            
                
<p>For Node.js projects, the settings and configurations are stored inside a file named <kbd>package.json</kbd>, located at the root of the repository. The npm CLI tool provides a <kbd>npm init</kbd> command, which will initiate a mini-wizard that helps you compose your <kbd>package.json</kbd> file. So, inside our project directory, run <kbd>npm init</kbd> to initiate the wizard. </p>
<p>The wizard will ask you a series of questions, but also provides sensible defaults. Let's go through each question one by one:</p>
<ol>
<li>package name: We are happy with the default name of <kbd>hobnob</kbd> (derived from the directory name), so we can just press the Return key to continue.</li>
<li>version: We're going to follow semantic versioning (semver) here and use major version 0(<kbd>0.y.z</kbd>) to indicate that our code base is under initial development, and that the API is not stable. Semver also recommends that our initial release be <kbd>0.1.0</kbd>.</li>
</ol>
<ol start="3">
<li>description: A brief description of your project; if we make our application public on <a href="http://npmjs.com">npmjs.com</a>, this description will appear in the search results.</li>
<li>entry point: This should point to the root of the module, and is what is run when other modules require your module. We have not decided on the structure of our application yet, so just leave it at <kbd>index.js</kbd>, and we may change it later.</li>
<li>test command: This will be run when we run <kbd>npm run test</kbd>. We will integrate with the Cucumber and Mocha testing frameworks later; for now, just leave it blank.</li>
<li>git repository: Use the remote repository we created earlier, for example, <kbd>git@github.com:d4nyll/hobnob.git</kbd>.</li>
<li>keywords: These are comma-separated keywords that help others search for your package on <a href="https://www.npmjs.com/">npmjs.com.</a></li>
<li>author: Put your details here in the format of <kbd>FirstName LastName &lt;e@ma.il&gt; (http://web.site/)</kbd>.</li>
<li>license: The license tells others how they can use our code. It should be one of the identifiers in the SPDX License List (<a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a>). For example, the MIT License would be <kbd>MIT</kbd>, and the GNU General Public License v3.0 would be <kbd>GPL-3.0</kbd>.</li>
</ol>
<p>There are two main types of open source licenses—<strong>permissive</strong> licenses focus on allowing others to do whatever they want with your code; while <strong>copyleft</strong> licenses promote sharing and require the sharing of derivative code under the same terms. If you're unsure which license to choose, check out <a href="https://choosealicense.com/">choosealicense.com</a>.</p>
<p>After you've completed the wizard, it'll show you a preview of the <kbd>package.json</kbd> file; press the Return key to confirm. You can also take a look at the newly-created <kbd>package.json</kbd> file to check:</p>
<pre><strong>$ cat package.json </strong><br/><strong>{</strong><br/><strong>  "name": "hobnob",</strong><br/><strong>  "version": "0.1.0",</strong><br/><strong>  "description": "Back end for a simple user directory API with <br/>   recommendation engine",</strong><br/><strong>  "main": "index.js",</strong><br/><strong>  "scripts": {</strong><br/><strong>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</strong><br/><strong>  },</strong><br/><strong>  "repository": {</strong><br/><strong>    "type": "git",</strong><br/><strong>    "url": "git+https://github.com/d4nyll/hobnob.git"</strong><br/><strong>  },</strong><br/><strong>  "author": "Daniel Li &lt;dan@danyll.com&gt;",</strong><br/><strong>  "license": "MIT",</strong><br/><strong>  "bugs": {</strong><br/><strong>    "url": "https://github.com/d4nyll/hobnob/issues"</strong><br/><strong>  },</strong><br/><strong>  "homepage": "https://github.com/d4nyll/hobnob#readme"</strong><br/><strong>}</strong></pre>
<p>The <kbd>package.json</kbd> file contains information about your project, as well as a list of packages that your project depends on. Having a <kbd>package.json</kbd> file, it allows collaborators to quickly set up the project on their local environment—all they have to do is run <kbd>npm install</kbd>, and all the project's dependencies will be installed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using yarn instead of npm</h1>
                
            
            
                
<p><kbd>npm</kbd> is the default package manager, but Facebook, in collaboration with Exponent, Google, and Tilde, has since developed a better alternative, called <kbd>yarn</kbd>, which we will use instead.</p>
<p><kbd>yarn</kbd> (<a href="https://yarnpkg.com/en/" target="_blank">https://yarnpkg.com/en/</a>) uses the same <a href="https://www.npmjs.com/" target="_blank">https://www.npmjs.com/</a> registry as the <kbd>npm</kbd> CLI. Since they both just install packages inside <kbd>node_modules</kbd> directories and write to <kbd>package.json</kbd>, you can use <kbd>npm</kbd> and <kbd>yarn</kbd> interchangeably. The differences are in their methods for resolving and downloading dependencies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Package version locking</h1>
                
            
            
                
<p>When we specify our dependencies inside our <kbd>package.json</kbd> file, we can use symbols to indicate a range of acceptable versions. For example, <kbd>&gt;version</kbd> means the installed version must be greater than a certain version, <kbd>~version</kbd> means approximately equivalent (which means it can be up to the next minor version), and <kbd>^version</kbd> means compatible (which usually means the highest version without a change in the major version). This means that given the same <kbd>package.json</kbd> file, it's likely that you'll install a different set of package versions than your colleagues.</p>
<p><kbd>yarn</kbd>, by default, creates a <strong>lock file</strong>, <kbd>yarn.lock</kbd>. The lock file ensures that the exact version of every package is recorded, so that everyone who installs using the lock file will have exactly the same version of every package.</p>
<p class="mce-root"/>
<p><kbd>npm</kbd>, on the other hand, only made its lock files as defaults in version 5.0.0 with <kbd>package-lock.json</kbd>. Prior to this, developers had to run <kbd>npm shrinkwrap</kbd> manually to generate a <kbd>npm-shrinkwrap.json</kbd> file—the predecessor to <kbd>package-lock.json</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Offline cache</h1>
                
            
            
                
<p>When you install a package with <kbd>yarn</kbd>, it will save a copy of it at <kbd>~/.yarn-cache</kbd>. So, the next time you need to install a package in one of your projects, <kbd>yarn</kbd> will check this cache and use the local copy if possible. This saves a round trip to the server each time and allows you to work offline.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Speed</h1>
                
            
            
                
<p>When you install a package and its dependencies, <kbd>npm</kbd> installs them sequentially, whereas <kbd>yarn</kbd> installs them in parallel. This means installing with <kbd>yarn</kbd> is consistently faster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing yarn</h1>
                
            
            
                
<p>There are many methods by which you can install <kbd>yarn</kbd>. The simplest one is to install it through npm (yes, this is quite ironic):</p>
<pre><strong>$ npm install --global yarn</strong></pre>
<p>However, this is not recommended because the packages are not signed, which means you cannot be sure it came from an authentic source; this poses a security risk. Therefore, it is recommended to follow the official installation instructions outlined at <a href="https://yarnpkg.com/en/docs/install#windows-stable" target="_blank">https://yarnpkg.com/en/docs/install#windows-stable</a>. For a Ubuntu machine, we should run the following:</p>
<pre><strong>curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -</strong><br/><strong>echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list</strong><br/><strong>sudo apt-get update &amp;&amp; sudo apt-get install yarn</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting familiar with the yarn CLI</h1>
                
            
            
                
<p><kbd>yarn</kbd> has most of the functionality for the <kbd>npm</kbd> CLI. The following table compares the corresponding commands:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Yarn 0.24.5</strong></td>
<td><strong>npm CLI 5.0.0</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>yarn</kbd></td>
<td><kbd>npm</kbd></td>
<td>Alias for <kbd>yarn install</kbd></td>
</tr>
<tr>
<td><kbd>yarn install</kbd></td>
<td><kbd>npm install</kbd></td>
<td>Installs dependencies specified in <kbd>yarn.lock</kbd> and <kbd>package.json</kbd></td>
</tr>
<tr>
<td><kbd>yarn add &lt;package&gt;</kbd></td>
<td><kbd>npm install &lt;package&gt;</kbd></td>
<td>Installs the package, adds it to the dependencies list, and generates lock files (prior to 5.0.0, npm CLI required a <kbd>--save</kbd> flag)</td>
</tr>
<tr>
<td><kbd>yarn remove &lt;package&gt;</kbd></td>
<td><kbd>npm uninstall &lt;package&gt;</kbd></td>
<td>Uninstalls the package</td>
</tr>
<tr>
<td><kbd>yarn global add &lt;package&gt;</kbd></td>
<td><kbd>npm install &lt;package&gt; --global</kbd></td>
<td>Installs a package globally</td>
</tr>
<tr>
<td><kbd>yarn upgrade</kbd></td>
<td><kbd>rm -rf node_modules &amp;&amp; npm install</kbd></td>
<td>Upgrades all packages to the latest version, as allowed by <kbd>package.json</kbd></td>
</tr>
<tr>
<td><kbd>yarn init</kbd></td>
<td><kbd>npm init</kbd></td>
<td>Initializes the development of a package by following a short wizard</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Apart from the basics, <kbd>yarn</kbd> also has some non-essential, but otherwise neat, features that'll help you in your workflow:</p>
<ul>
<li><kbd>yarn licenses ls</kbd>: Prints out, on the console, a list of packages, their URLs and their licenses</li>
<li><kbd>yarn licenses generate-disclaimer</kbd>: Generates a text file containing the licenses of all the dependencies</li>
<li><kbd>yarn why</kbd>: Generates a dependency graph to figure out why a package was downloaded—for example, it might be a dependency of a dependency of our application</li>
<li><kbd>yarn upgrade-interactive</kbd>: Provides an interactive wizard that allows you to selectively upgrade outdated packages</li>
</ul>
<p>You can get a full list of CLI commands at <a href="https://yarnpkg.com/en/docs/cli/" target="_blank">https://yarnpkg.com/en/docs/cli/</a>, or by running <kbd>yarn help</kbd> on your Terminal.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">npm and yarn, together</h1>
                
            
            
                
<p><kbd>yarn</kbd> is an improvement on <kbd>npm</kbd>, in terms of speed, consistency, security, and the general aesthetics of its console output. This has, in turn, made <kbd>npm</kbd> better—<kbd>npm</kbd> v5.0.0 introduced the following changes, obtained from the official announcement on the npm blog:</p>
<ul>
<li><kbd>npm</kbd> will <kbd>--save</kbd> by default now. Additionally, <kbd>package-lock.json</kbd> will be automatically created unless an instance of <kbd>npm-shrinkwrap.json</kbd> exists.</li>
<li>Package metadata, package download, and caching infrastructure have been replaced. The new cache is very fault-tolerant and supports concurrent access.</li>
<li>Running <kbd>npm</kbd> while offline will no longer insist on retrying network requests. <kbd>npm</kbd> will now immediately fall back to the cache if possible, or fail.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an HTTP server</h1>
                
            
            
                
<p>Next, we need to set up our project so that it can run ES6 code, specifically the ES6 modules feature. To demonstrate this, and also to show you how to debug your code, we're just going to create a simple HTTP server that always returns the string Hello, World!.</p>
<p>Normally, when we follow a TDD workflow, we should be writing our tests before we write our application code. However, for the purpose of demonstrating these tools, we will make a small exception here.</p>
<p>Node.js provides the HTTP module, which contains a <kbd>createServer()</kbd> method (<a href="https://nodejs.org/api/http.html#http_http_createserver_requestlistener" target="_blank">https://nodejs.org/api/http.html#http_http_createserver_requestlistener</a>)that allows you to provision HTTP servers. At the root of your project directory, create an <kbd>index.js</kbd> file and add the following:</p>
<pre>const http = require('http');<br/>const requestHandler = function (req, res) {<br/>  res.writeHead(200, {'Content-Type': 'text/plain'});<br/>  res.end('Hello, World!');<br/>}<br/>const server = http.createServer(requestHandler);<br/>server.listen(8080);</pre>
<div><p>We are able to use ES6 syntax (such as <kbd>const</kbd>) here because ES2015 support has been good since Version 6 of Node. But ES6 modules are still unsupported, even in the latest version of Node. Therefore, we are using CommonJS's <kbd>require</kbd> syntax instead.<br/>
Later in this chapter, we will demonstrate how to convert our source code to be written with the ES6 modules feature, using Babel to transpile it back to the universally supported CommonJS syntax.<br/>
To see the level of support for ES2015+ features in different versions of Node, go to <a href="http://node.green/">node.green</a>.</p>
</div>
<p>Once you've done that, open up a terminal and run <kbd>node index.js</kbd>. This should have started a server on <kbd>localhost:8080</kbd>. Now, if we send a request to <kbd>localhost:8080</kbd>, for instance by using a web browser, it'll return with the text <kbd>Hello, World!</kbd>:</p>
<div><img src="img/04a1fff3-90f6-4284-86a1-e8d24de232a5.png" style="width:14.50em;height:9.92em;"/></div>
<p class="mce-root"/>
<p>If you get an <kbd>Error: listen EADDRINUSE :::8080</kbd> error, it means something else is using port <kbd>8080</kbd>; in that case, either terminate the process bound to port <kbd>8080</kbd>, or choose a different port instead by changing the number passed into <kbd>server.listen()</kbd>.</p>
<p>The <kbd>node</kbd> process is currently running in the <strong>foreground</strong> and will continue to listen for further requests. To stop the <kbd>node</kbd> process (and thus our server), press Ctrl + C.</p>
<p>Pressing Ctrl + C sends an <strong>interrupt signal</strong> (<kbd>SIGINT</kbd>) to the Node program, which handles it and terminates the server.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Our HTTP server in detail</h1>
                
            
            
                
<p>Let's break down our HTTP server code to see what's really going on. First, we <kbd>require</kbd> the <kbd>http</kbd> package so we can access the HTTP module's methods:</p>
<pre>const http = require('http');</pre>
<p>Next, we use the <kbd>createServer</kbd> method to create a server instance that listens to incoming requests. Inside it, we pass in a <strong>request handler</strong> function that takes a <kbd>req</kbd> and <kbd>res</kbd> parameters.</p>
<p>Most developers use <kbd>req</kbd> and <kbd>res</kbd> as shorthands for "request" and "response" parameter names, but you can use any variable names you like.</p>
<p>The <kbd>req</kbd> parameter is an object containing information about the request, such as its origin IP, URL, protocol, body payload (if any), and so on. The <kbd>res</kbd> object provides methods that help you prepare the response message to send back to the client; for example, you can set the header, add a response body, specify the content type of the body, and so on.</p>
<p>When we run <kbd>res.end()</kbd>, it finishes the preparation of the response and sends it back to the client. Here, we disregard what the request was, and it simply returns with <kbd>Hello, World!</kbd>:</p>
<pre>const requestHandler = function (req, res) {<br/>  res.writeHead(200, {'Content-Type': 'text/plain'});<br/>  res.end('Hello, World!');<br/>}<br/>const server = http.createServer(requestHandler);</pre>
<p>Now that we have created a server instance and configured its response, the last step is to give it a port and instruct it to listen for requests on that port.</p>
<pre>server.listen(8080);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Transpiling ES6 with Babel</h1>
                
            
            
                
<p>We've been using the CommonJS <kbd>require</kbd> syntax for modules; let's change it to use the ES6 module syntax (using <kbd>import</kbd>).</p>
<p>In your code, update the first line to use <kbd>import</kbd>:</p>
<pre>const http = require('http'); // CommonJS syntax<br/>import http from 'http'; // ES6 syntax</pre>
<p>When we try to run our server by executing <kbd>node index.js</kbd>, it will throw a <kbd>SyntaxError: Unexpected token import</kbd> error. This is because Node.js support for modules is still experimental, and not likely to be supported without the <kbd>--experimental-modules</kbd> flag until late 2018.</p>
<p>This means that for us to write our source code using ES6 modules, we need to add an extra step that will transpile the unsupported syntax into supported syntax. There are a few compilers/transpilers available for us to choose from:</p>
<ul>
<li><strong>Babel</strong>: The most popular and de facto standard for JavaScript compilers/transpilers.</li>
<li><strong>Traceur</strong>: Another compiler by Google.</li>
<li><strong>The TypeScript compiler</strong>: TypeScript is a superset of JavaScript that provides static typing. Since valid JavaScript is also valid TypeScript, the TypeScript compiler can also act as an ES6 to ES5 transpiler.</li>
<li><strong>The Closure compiler</strong>: A compiler that optimizes your JavaScript by parsing and analyzing it, removing dead code, refactoring existing code, and minimizing the final results. It also warns the user of common mistakes. The Closure compiler supports the ES6 syntax, but transpiles everything down to ES5.</li>
</ul>
<p>Whilst the TypeScript and Closure compilers are able to transpile ES6 to ES5, it is not their primary function; thus naturally, these features are of limited use here. Babel and Traceur are tools whose sole purpose is to transform the ES6/7/8/9 and <strong>ESNext</strong> syntax to JavaScript that is supported by the environment, and so would be more suitable for our use. Of the two, Babel is, by far, the most popular and active, and will be the one we use in this project.</p>
<p>ESNext is a collective term for features that have been submitted by members of the community, but have not gone through Ecma's review process (the T39 Process), and thus have not been incorporated into the ECMAScript standard.<br/>
<br/>
There are 5 stages to the T39 Process: Strawman (Stage 0), Proposal (Stage 1), Draft (Stage 2), Candidate (Stage 3), and Finished (Stage 4). You can get a more detailed description of each stage by going to <a href="https://tc39.github.io/process-document/" target="_blank">https://tc39.github.io/process-document/</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Babel is a transpiler...and more!</h1>
                
            
            
                
<p>Babel can transpile ES6/7/8/9 and ESNext syntax into syntax that works in the targeted environment. For example, let's say we have a module that uses arrow functions:</p>
<pre>double = a =&gt; a * 2</pre>
<p>If we want this to be available on the browser, Babel can transpile it to ES5:</p>
<pre>double = function double(a) {<br/>  return a * 2;<br/>};</pre>
<p>However, if we are running Node v8.11.4, which natively supports arrow functions, it will leave the function unmodified.</p>
<p>Apart from supporting new ECMAScript versions, it also supports commonly used syntax such as JSX (used by React) and Flow static type annotations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Different faces of Babel</h1>
                
            
            
                
<p>Babel is a suite of tools—it is both a command-line tool, and a polyfill, and the packages are split up into many parts, such as <kbd>@babel/cli</kbd>, <kbd>@babel/register</kbd>, <kbd>@babel/node</kbd>, and <kbd>@babel/core</kbd>, all of which allow you to run ESNext code.</p>
<p>So first, let's understand what the different parts of Babel actually are, and how we can use Babel in our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">@babel/cli</h1>
                
            
            
                
<p>The Babel CLI is the most common (and easiest) way to run Babel. It gives you an executable (<kbd>babel</kbd>) which you can use on the terminal to transpile files and directories. It is available on <a href="http://npmjs.com">npmjs.com</a>, and so we can install it using yarn:</p>
<pre># Install @babel/cli as a development dependency<br/><strong>$ yarn add @babel/cli --dev</strong><br/><br/># transpile a single file
<strong>$ babel example.js -o compiled.js</strong><br/><br/># transpile an entire directory<br/><strong>$ babel src -d build</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">@babel/register</h1>
                
            
            
                
<p>The <kbd>@babel/cli</kbd> package allows you to transpile source code ahead of time; on the other hand, <kbd>@babel/register</kbd> transpiles it at runtime.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using @babel/register for tests</h1>
                
            
            
                
<p><kbd>@babel/register</kbd> is useful during testing, as it allows you to write ESNext inside your tests, as they will be transpiled down before the tests are run.</p>
<p>The alternative is to transpile manually using the <kbd>babel</kbd> CLI, and perform the tests on the transpiled code. This is acceptable; however, the line numbers on the transpiled code will not match the ones in the source code, making it harder to identify the failing test(s). Furthermore, since there is likely to be more boilerplate code in the transpiled code, the test coverage statistics might not be accurate.</p>
<p>Therefore, using <kbd>@babel/register</kbd> is recommended for running tests written in ES6.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">@babel/node</h1>
                
            
            
                
<p>While the <kbd>@babel/register</kbd> hook can integrate with other tools such as <kbd>mocha</kbd> and <kbd>nyc</kbd> and acts as a middle step, <kbd>@babel/node</kbd> is a stand-in replacement for <kbd>node</kbd> and supports ESNext syntax:</p>
<pre># install @babel/node<br/><strong>$ yarn add @babel/node --dev</strong><br/><br/># instead of this<br/><strong>$ node main.js</strong><br/><br/># you'd run<br/><strong>$ babel-node main.js</strong></pre>
<p>It is provided for convenience, to help you get started. It's not meant to be used in production since, like <kbd>@babel/register</kbd>, it transpiles the source code at runtime, which is highly inefficient.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">@babel/core</h1>
                
            
            
                
<p><kbd>@babel/cli</kbd>, <kbd>@babel/register</kbd>, <kbd>@babel/node</kbd>, and several other packages all depend on <kbd>@babel/core</kbd>, which as its name implies contains the core logic behind Babel. In addition, the <kbd>@babel/core</kbd> package exposes API methods that you can use inside your code:</p>
<pre>import * as babel from '@babel/core';<br/>var result = babel.transform("code();", options);<br/>result.code;<br/>result.map;<br/>result.ast;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">@babel/polyfill</h1>
                
            
            
                
<p>Newer versions of ECMAScript provide new and cleaner syntax, and Babel transpiles the new syntax down to older versions of ECMAScript. However, this is more difficult (if not impossible) to do in the same way if you're using newer JavaScript <em>APIs</em>.</p>
<p>For example, if you're using the new <kbd>fetch</kbd> API instead of <kbd>XMLHttpRequest</kbd>, Babel won't be able to transpile this down. For APIs, we must use a polyfill; luckily, Babel provides the <kbd>@babel/polyfill</kbd> package.</p>
<p>A polyfill is code that checks whether a feature is supported in the environment, and if not, provides methods that mimic the native implementation.</p>
<p>To use the polyfill, you must first install it as a dependency (not a development dependency):</p>
<pre><strong>$ yarn add @babel/polyfill</strong></pre>
<p>Then, import the <kbd>@babel/polyfill</kbd> package at the top of your code and it'll mutate existing global variables to polyfill methods that are not yet supported:</p>
<pre>require("@babel/polyfill"); # ES5<br/>import "@babel/polyfill"; # ES6</pre>
<div><kbd>@babel/polyfill</kbd> uses <kbd>core-js</kbd> as its underlying polyfill.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Babel CLI and polyfill</h1>
                
            
            
                
<p>We'll be using the Babel CLI to transpile our code, while also adding the Babel polyfill in order to make use of newer JavaScript APIs. Therefore, while still inside your project directory, run the following two commands:</p>
<pre><strong>$ yarn add @babel/core @babel/cli --dev</strong><br/><strong>$ yarn add @babel/polyfill</strong></pre>
<p>We used the <kbd>--dev</kbd> flag when we ran <kbd>yarn add @babel/core @babel/cli</kbd>, and this is because we want to include them as <strong>development dependencies</strong>. Development dependencies may include build tools, test runners, documentation generators, linters, and anything else that are used during development, but not used by the application itself.</p>
<p>This is done so that if someone wants to use our package in their project, they can just <kbd>npm install</kbd> our package and its dependencies, without also downloading the development dependencies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Babel CLI to transpile our code</h1>
                
            
            
                
<p>Now, let's use the Babel CLI to transpile our code:</p>
<pre><strong>$ npx babel index.js -o compiled.js</strong></pre>
<p>The preceding command uses <kbd>npx</kbd>, a tool that was introduced with <kbd>npm</kbd> v5.2.0. <kbd>npx</kbd> allows you to run binaries install locally (within your project's <kbd>node_modules</kbd> directory, as opposed to globally) using a very tidy syntax. Instead of typing <kbd>./node_modules/.bin/babel index.js -o compile.js</kbd>, you can shorten it to <kbd>npx babel index.js -o compile.js</kbd>.</p>
<p>Here, we are using npx to run the local <kbd>babel</kbd> executable, which will transpile our <kbd>index.js</kbd> file and output it as <kbd>compiled.js</kbd>.</p>
<p class="mce-root"/>
<p>If you compare the two files, you'll see that apart from formatting changes (such as whitespace), the two files should be identical. This is because the Babel CLI, by default, will simply copy files from one place to another. To give it functionality, we must add plugins and specify them in a configuration file. So next, let's create that configuration file. At the root of the project directory, create a new file named <kbd>.babelrc</kbd> and add the following lines:</p>
<pre>{<br/> "presets": [],<br/> "plugins": []<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Plugins and presets</h1>
                
            
            
                
<p><strong>Plugins</strong> tell Babel how to transform your code, and <strong>presets</strong> are predefined groups of plugins. For example, you have the <kbd>es2017</kbd> preset, which includes the plugins <kbd>syntax-trailing-function-commas</kbd> and <kbd>transform-async-to-generator</kbd>, which are required to support ECMAScript 2017 syntax. There's also the <kbd>react</kbd> preset, which includes the <kbd>transform-react-jsx</kbd> plugin (among others) to allow Babel to understand JSX.</p>
<p>To use a plugin or preset, you can install it as a development dependency, and specify it in the <kbd>.babelrc</kbd>. For example, if I want to support ECMAScript 2017 syntax, but also the <kbd>rest</kbd> and <kbd>spread</kbd> operators for objects (a ES2018 feature), I could run the following:</p>
<pre><strong>$ yarn add @babel/preset-es2017 @babel/plugin-syntax-object-rest-spread --dev</strong></pre>
<p>And, add the setting into <kbd>.babelrc</kbd>:</p>
<pre>{<br/>  "presets": ["@babel/es2017"],<br/>  "plugins": ["@babel/syntax-object-rest-spread"]<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The env preset</h1>
                
            
            
                
<p>However, in the previous approach, you have to manually keep track of which ECMAScript features you've used, and determine whether they are compatible with the version of Node.js you have installed on your machine. Babel provides a better alternative, the <kbd>env</kbd> preset, which is available as the <kbd>@babel/preset-env</kbd> package. This preset will use the kangax ECMAScript compatibility tables (<a href="http://kangax.github.io/compat-table/">kangax.github.io/compat-table/</a>) to determine which features are unsupported by your environment, and download the appropriate Babel plugins.</p>
<p>This is great for our use case, because we don't want to transpile everything into ES5, only the <kbd>import</kbd>/<kbd>export</kbd> module syntax. Using the <kbd>env</kbd> preset will ensure that only the minimum number of transformations are made to our code.</p>
<p>In fact, if you go to the <kbd>npmjs.com</kbd> page for <kbd>@babel/preset-es2017</kbd> or similar packages, you'll see that they have been deprecated in favor of the <kbd>@babel/preset-env</kbd> package. Therefore, we should remove the previous plugins and presets, and use the <kbd>env</kbd> preset instead:</p>
<pre><strong>$ yarn remove @babel/preset-es2017 @babel/plugin-syntax-object-rest-spread</strong><br/><strong>$ yarn add @babel/preset-env --dev</strong></pre>
<p>Next, replace the content of our <kbd>.babelrc</kbd> with the following:</p>
<pre>{<br/>  "presets": ["@babel/env"]<br/>}</pre>
<p>If you do not specify a targeted environment, the <kbd>env</kbd> preset will default to using the latest official version of ECMAScript, not including stage-x proposals.</p>
<p>The API we are writing is intended to be run only on the server, using Node, so we should specify that in the configuration. We can specify the exact version of Node we want to support, but even better, we can ask Babel to detect it for us using the target option <kbd>"node": "current"</kbd>.</p>
<p>So, replace <kbd>.babelrc</kbd> with the following:</p>
<pre>{<br/>  "presets": [<br/>    ["@babel/env", {<br/>      "targets": {<br/>        "node": "current"<br/>      }<br/>    }]<br/>  ]<br/>}</pre>
<p>Great! Now we can continue writing in ES6. When we want to run our program, we can simply transpile it using Babel, and run the compiled script:</p>
<pre><strong>$ npx babel index.js -o compiled.js</strong><br/><strong>$ node compiled.js</strong></pre>
<p>You should, once again, receive the <kbd>'Hello World!'</kbd> text as the response when you send a <kbd>GET</kbd> request to <kbd>localhost:8080</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Separating source and distribution code</h1>
                
            
            
                
<p>Usually, the source code consists of many files, nested inside multiple directories. We can transpile each file and place them next to the corresponding source file, but this is not ideal as it is hard to separate the distribution code from the source. Therefore, it's preferable to separate the source and distribution code into two different directories.</p>
<p>Therefore, let's remove the existing <kbd>compiled.js</kbd>, and create two new directories called <kbd>src</kbd> and <kbd>dist</kbd>. Also, move the <kbd>index.js</kbd> file into the <kbd>src</kbd> directory:</p>
<pre><strong>$ rm compiled.js</strong><br/><strong>$ mkdir src dist</strong><br/><strong>$ mv index.js src/</strong></pre>
<p>Now, we should build our project again, but this time supplying the <kbd>-d</kbd> flag to the Babel CLI, which will compile files in our <kbd>src</kbd> directory into an output directory. We should also remove our existing <kbd>dist</kbd> directory before we build to ensure no artifacts are left behind from the previous build:</p>
<pre><strong>$ rm -rf dist/ &amp;&amp; npx babel src -d dist</strong><br/><strong>$ node dist/index.js</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing the Babel polyfill</h1>
                
            
            
                
<p>Lastly, inside the <kbd>src/index.js</kbd> file, import the polyfill at the top of the file:</p>
<pre class="mce-root">import "@babel/polyfill";<br/>...</pre>
<p class="mce-root"/>
<p>This will allow us to use new JavaScript APIs, such as <kbd>fetch</kbd>. Again, transpile the modified source code by executing <kbd>rm -rf dist/ &amp;&amp; npx babel src -d dist</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consolidating commands with npm scripts</h1>
                
            
            
                
<p>It's troublesome to have to type <kbd>rm -rf dist/ &amp;&amp; npx babel src -d dist</kbd> each time you want to build your project. Instead, we should use <strong>npm scripts</strong> to consolidate this command into a simpler one.</p>
<p>In your <kbd>package.json</kbd> file, add a new <kbd>build</kbd> sub-property to the <kbd>scripts</kbd> property, and set it to a string representing the command we want to run:</p>
<pre>"scripts": {<br/> "build": "rm -rf dist/ &amp;&amp; babel src -d dist",<br/> "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>}</pre>
<p>Now, instead of typing  <kbd>rm -rf dist/ &amp;&amp; npx babel src -d dist</kbd>, you can just type <kbd>yarn run build</kbd>, or <kbd>npm run build</kbd>—much less cumbersome! By adding this script into <kbd>package.json</kbd>, it allows you to share this with other developers, so everyone can benefit from this convenience.</p>
<p>We can also create a <kbd>serve</kbd> script, which will build our application and then run it:</p>
<pre>"scripts": {<br/>  "build": "rm -rf dist/ &amp;&amp; babel src -d dist",<br/>  "serve": "yarn run build &amp;&amp; node dist/index.js",<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>}</pre>
<p>When we integrate with testing frameworks and documentation tools in subsequent chapters, we will add even more scripts here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ensuring cross-platform compatibility</h1>
                
            
            
                
<p>Before we move on, we should try to ensure our npm scripts work across multiple platforms. So, if we have a developer working on a Mac, and another on a Linux machine, the script would work for both of them.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For example, if you want to remove the <kbd>dist</kbd> directory using <kbd>cmd</kbd> in Windows, you'd have to run <kbd>rd /s /q dist</kbd>; while using Ubuntu's default shell (Bash), you'll run <kbd>rm -rf dist</kbd>. To ensure our npm script will work everywhere, we can use a Node package called <kbd>rimraf</kbd> (<a href="https://www.npmjs.com/package/rimraf" target="_blank">https://www.npmjs.com/package/rimraf</a><a href="https://www.npmjs.com/package/rimraf" target="_blank">). First, install it:</a></p>
<pre><strong>$ yarn add rimraf --dev</strong></pre>
<p>And now update our <kbd>build</kbd> script to use <kbd>rimraf</kbd>:</p>
<pre>"build": "rimraf dist &amp;&amp; babel src -d dist",</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Automating development using nodemon</h1>
                
            
            
                
<p>At the moment, to see the final product, we have to run the <kbd>build</kbd> script after each time we modify our source code. While this is fine, it can be annoying and a time-waster. <kbd>nodemon</kbd> is a tool that monitors for changes in our code and automatically restarts the <kbd>node</kbd> process when a change is detected. This can speed up development and testing, as we no longer need to run the <kbd>build</kbd> and <kbd>serve</kbd> scripts manually. Furthermore, the API served from our machine will always be the most up-to-date version.</p>
<p>First, let's install <kbd>nodemon</kbd>:</p>
<pre><strong>$ yarn add nodemon --dev</strong></pre>
<p>Next, add a <kbd>watch</kbd> script that uses <kbd>nodemon</kbd> instead of <kbd>node</kbd>:</p>
<pre>"scripts": {<br/>  "build": "rimraf dist &amp;&amp; babel src -d dist",<br/>  "serve": "yarn run build &amp;&amp; node dist/index.js",<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>  "watch": "nodemon -w src --exec yarn run serve"<br/>},</pre>
<p>This command instructs nodemon to watch for file changes in the <kbd>src</kbd> directory and, whenever one is detected, to execute <kbd>yarn run serve</kbd> and restart our server.</p>
<p>Now, run <kbd>yarn run watch</kbd>, and make a small file change in <kbd>src/index.js</kbd> (for example, change the text returned in the response). Pay attention to the console and you'll see nodemon detecting changes and restarting our server:</p>
<pre><strong>[nodemon] restarting due to changes...</strong><br/><strong>[nodemon] starting `yarn run serve`</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Linting with ESLint</h1>
                
            
            
                
<p>Finally, we should take care to maintain a consistent code style throughout our project. Code styles are subjective, stylistic choices that do not alter the function of the program, for example, whether to use spaces or tabs, or whether to use <kbd>camelCase</kbd> or <kbd>underscore_case</kbd> when naming variables.</p>
<p>Having a consistent code style is important for the following reasons:</p>
<ul>
<li>It makes the code more readable.</li>
<li>When working with others, contributors may override each other's style changes. For instance, contributor A may change all string literals to using single-quotes, and contributor B may change it back to double-quotes in a subsequent commit. This is a problem because:<br/>
<ul>
<li>Time and effort are wasted</li>
<li>It can lead to ill-feelings because no one likes their work being overwriten</li>
<li>Changes become hard to review, and the pertinent changes may be submerged under the stylistic changes.</li>
</ul>
</li>
</ul>
<p>Once a set of code style rules is defined, a <strong>linter</strong> can be used to enforce those rules. A linter is a static analysis tool that scans your code and identifies code styles that do not adhere to those rules, as well as identifying potential bugs that arise due to syntax errors.</p>
<p><em>ESLint</em> is an open source linter for JavaScript. To use it, you would first document your rules inside a configuration file named <kbd>.eslintrc</kbd>. It is designed to be pluggable, which means developers can override the default rules and compose their own set of code style rules. Any violations can also be given a severity level of warning or error. It also provides useful features such as the <kbd>--init</kbd> flag, which initiates a wizard to help you compose your configuration file, as well as the <kbd>--fix</kbd> flag, which automatically fixes any violations that do not require human intervention.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing ESLint</h1>
                
            
            
                
<p>Let's install ESLint and run its initiation wizard:</p>
<pre><strong>$ yarn add eslint --dev</strong><br/><strong>$ npx eslint --init</strong><br/><strong>? How would you like to configure ESLint?</strong><br/><strong> <img src="img/2c64d4ea-912b-4a87-9a27-d23df9333633.png"/>Use a popular style guide</strong><br/><strong>  Answer questions about your style</strong><br/><strong>  Inspect your JavaScript file(s)</strong></pre>
<p>For this project, we are going to be using Airbnb's JavaScript style guide, which you can find at <a href="https://github.com/airbnb/javascript" target="_blank">https://github.com/airbnb/javascript</a>. Therefore, use your arrow keys to select the Use a popular style guide option, and press the Return key. On the next question, select the Airbnb option:</p>
<pre><strong>? Which style guide do you want to follow? (Use arrow keys)</strong><br/><strong><img src="img/2c64d4ea-912b-4a87-9a27-d23df9333633.png"/> Airbnb (https://github.com/airbnb/javascript)</strong><br/><strong>  Standard (https://github.com/standard/standard)</strong><br/><strong>  Google (https://github.com/google/eslint-config-google)</strong></pre>
<p>Next, it'll ask questions about React and the configuration format; select the No and JSON options, respectively:</p>
<pre><strong>? Do you use React? No</strong><br/><strong>? What format do you want your config file to be in? JSON</strong></pre>
<p>Lastly, it will check whether we have the required dependencies installed, and if not, prompt us to install them. Select the Yes option here:</p>
<pre><strong>Checking peerDependencies of eslint-config-airbnb-base@latest</strong><br/><strong>The config that you've selected requires the following dependencies:</strong><br/><br/><strong>eslint-config-airbnb-base@latest eslint@^4.19.1 || ^5.3.0 eslint-plugin-import@^2.14.0</strong><br/><strong>? Would you like to install them now with npm? Yes</strong></pre>
<p>This completes the wizard, and you should now see an <kbd>.eslintrc.json</kbd> file at the root of your repository, which simply reads as follows:</p>
<pre>{<br/>    "extends": "airbnb-base"<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Linting our code</h1>
                
            
            
                
<p>Now, let's run <kbd>eslint</kbd> on our <kbd>src/index.js</kbd> to discover problems with our code:</p>
<pre><strong>$ npx eslint src/index.js</strong><br/><br/><strong>/home/dli/.d4nyll/.beja/final/code/6/src/index.js</strong><br/><strong>  1:8 error Strings must use singlequote quotes</strong><br/><strong>  2:1 error Expected 1 empty line after import statement not followed by another import import/newline-after-import</strong><br/><strong>  3:24 warning Unexpected unnamed function func-names</strong><br/><strong>  4:22 error A space is required after '{' object-curly-spacing</strong><br/><strong>  4:51 error A space is required before '}' object-curly-spacing</strong><br/><strong>  6:2 error Missing semicolon semi</strong><br/><strong>  8:21 error Newline required at end of file but not found eol-last</strong><br/><br/><strong><img src="img/b1bdf0f6-02f3-4bb8-83c0-45b6f4ef931f.png" style="width:1.33em;height:1.33em;"/> 8 problems (7 errors, 1 warning)</strong><br/><strong>  6 errors and 0 warnings potentially fixable with the `--fix` option.</strong></pre>
<p>Follow the instructions and fix those issues, or pass the <kbd>--fix</kbd> flag to have ESLint fix the issues for you automatically. At the end, you should end up with a file that looks like this:</p>
<pre>import '@babel/polyfill';<br/>import http from 'http';<br/><br/>function requestHandler(req, res) {<br/>  res.writeHead(200, { 'Content-Type': 'text/plain' });<br/>  res.end('Hello, World!');<br/>}<br/>const server = http.createServer(requestHandler);<br/>server.listen(8080); // Note that there is a newline below this line</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding lint script to package.json</h1>
                
            
            
                
<p>Just as we did with the <kbd>build</kbd>, <kbd>serve</kbd>, and <kbd>watch</kbd> npm scripts, we can add a <kbd>fix</kbd> and <kbd>lint</kbd> script into our <kbd>package.json</kbd>:</p>
<pre>"scripts": {<br/>    ...<br/>    "fix": "eslint src --fix",<br/>    "lint": "eslint src",<br/>    ...</pre>
<p>Now, we can run <kbd>yarn run lint</kbd> to lint our entire project.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing the ESLint extension</h1>
                
            
            
                
<p>While we can run ESLint manually, it would be even better for developer experience if these errors were pointed out as we are developing. To do that, we can install an ESLint extension for your code editor or IDE. For example, the Visual Studio Code ESLint Extension will add red and yellow squiggly lines below any violations:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f61e6395-1eaf-463d-ab3f-c3300fa10f2e.jpg"/></p>
<p>There are a lot more integrations available for editors and build tools; you can find a comprehensive list at <a href="https://eslint.org/docs/user-guide/integrations" target="_blank">https://eslint.org/docs/user-guide/integrations</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding pre-commit hooks</h1>
                
            
            
                
<p>However, we're not quite finished yet. Many developers are careless and forgetful. Even with <kbd>eslint</kbd> installed and the extension configured, they may still forget to run the lint command before committing badly styled code. To help them, we can implement <strong>Git hooks</strong>, which are programs that are triggerred to run at defined points in Git's execution.</p>
<p>By default, Git hooks are stored inside the <kbd>.git/hooks</kbd> directory. If you look inside the directory, you'll find many sample hooks with the <kbd>.sample</kbd> file extension. The one we are interested in is the <kbd>pre-commit</kbd> hook, which is executed after the <kbd>git commit</kbd> command is issued, but before the actual commit is made.</p>
<p class="mce-root"/>
<p>Hooks are written as a shell script. For the <kbd>pre-commit</kbd> hook, we can abort the commit by returning a non-zero exit code. Conveniently, when ESLint detects code style violations, it will exit with a status code of <kbd>1</kbd>; therefore, in our script, we can simply return the exit code returned by <kbd>eslint</kbd>. When writing a hook manually, you should take care to only use syntax that abides by the POSIX standard, because other developers may use a different type of shell from you.</p>
<p>However, if writing shell scripts manually sounds like too much work for you, there's a tool called <strong>Husky</strong>, which hugely simplifies the process for us. Let's install it:</p>
<pre><strong>$ yarn add husky --dev</strong></pre>
<p>Husky will insert its own Git hooks into our project. In these hooks, it will check our <kbd>package.json</kbd> for scripts with special names and run them. For instance, our <kbd>pre-commit</kbd> hook will check for a script named <kbd>precommit</kbd>. Therefore, to run our lint command with Husky, all we have to do is add a new npm script called <kbd>precommit</kbd>:</p>
<pre>"scripts": {<br/>    ...<br/>    "precommit": "yarn run lint",<br/>    ...</pre>
<p>Now, if we try to commit any badly formatted code, it will throw an error and abort:</p>
<pre>...<br/>error Command failed with exit code 1.<br/>husky &gt; pre-commit hook failed (add --no-verify to bypass)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Committing our code into Git</h1>
                
            
            
                
<p>We have finished bootstrapping our project by setting up an HTTP server and enabling ourselves to write in ES6. So, let's actually commit this block of code into Git.</p>
<p>Note that we could have created a new commit each time we added a new script, or integrated with a new tool, but because the bootstrapping of a project can be considered as one logical unit, we're committing all of that into one commit.<br/>
<br/>
Also, note that we are not going to be creating a <kbd>dev</kbd> branch just yet, as bootstrapping a project is not considered to be a "feature." Remember that branches are here to help us separate our commits by business domains; if branching provides no benefit for us, then it's better to be pragmatic, rather than dogmatic.</p>
<p class="mce-root"/>
<p>Let's run <kbd>git status</kbd> to see which files we can track in our Git repository:</p>
<pre><strong>$ git status</strong><br/><strong>Untracked files:</strong><br/><strong>  .babelrc</strong><br/><strong>  .eslintrc.json</strong><br/><strong>  .nvmrc</strong><br/><strong>  dist/</strong><br/><strong>  node_modules/</strong><br/><strong>  package.json</strong><br/><strong>  src/</strong><br/><strong>  yarn.lock</strong></pre>
<p>The list of files listed by the <kbd>git status</kbd> command includes the <kbd>node_modules/</kbd> and <kbd>dist/</kbd> directories, both of which do not constitute the core logic of our application. Furthermore, they can be regenerated from our source code—<kbd>node_modules/</kbd> from the <kbd>package.json</kbd> and <kbd>yarn.lock</kbd> files, and <kbd>dist/</kbd> from the <kbd>src/</kbd> directory. Moreover, the <kbd>node_modules/</kbd> directory can be very large, as it includes a copy of all third-party libraries we are depending on in our application. Therefore, let's make sure the <kbd>node_modules/</kbd> and <kbd>dist/</kbd> directories are not tracked in our Git repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using .gitignore to ignore files</h1>
                
            
            
                
<p>Git allows for a special <kbd>.gitignore</kbd> file that allows us to specify which files Git should ignore. So, create a <kbd>.gitignore</kbd> file at the project root directory, and add the following lines:</p>
<pre>node_modules/<br/>dist/</pre>
<p>Now, when we run <kbd>git status</kbd> again, <kbd>node_modules/</kbd> and <kbd>dist/</kbd> are gone from our list, and <kbd>.gitignore</kbd> is added:</p>
<pre><strong>$ git status</strong><br/><strong>Untracked files:</strong><br/><strong>  .babelrc</strong><br/><strong>  .eslintrc.json</strong><br/><strong>  .gitignore</strong><br/><strong>  .nvmrc</strong><br/><strong>  package.json</strong><br/><strong>  src/</strong><br/><strong>  yarn.lock</strong></pre>
<p class="mce-root"/>
<p>Apart from the <kbd>node_modules/</kbd> and <kbd>dist/</kbd> directories, there will be many other files we'll eventually want Git to ignore; for example, a <kbd>yarn-error.log</kbd> is generated whenever <kbd>yarn</kbd> encounters an error. It is for our information only and should not be tracked on Git. While we can keep adding more and more lines to the <kbd>.gitignore</kbd> file as is required, many others working with Node.js have already worked together to compile a list of common files and directories that most projects should ignore; we can use that as a basis and modify it as needed.</p>
<p>Go to <a href="https://github.com/github/gitignore/blob/master/Node.gitignore">github.com/github/gitignore/blob/master/Node.gitignore</a> and replace our <kbd>.gitignore</kbd> file with the content of the <kbd>Node.gitignore</kbd> file; but remember to add the <kbd>dist/</kbd> entry back at the end.</p>
<p>Now, let's add everything to the staging area and commit them:</p>
<pre><strong>$ git status</strong><br/><strong>Untracked files:</strong><br/><strong> .babelrc</strong><br/><strong> .eslintrc.json</strong><br/><strong> .gitignore</strong><br/><strong> .nvmrc</strong><br/><strong> package.json</strong><br/><strong> src/</strong><br/><strong> yarn.lock</strong><br/><strong>$ git add -A</strong><br/><strong>$ git commit -m "Initial project setup"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>At the start of this chapter, we looked at the difference between CommonJS and ES6 modules, and settled on using the new ES6 module syntax, which uses the <kbd>import</kbd> and <kbd>export</kbd> keywords.</p>
<p>Next, we installed Node on our machine using nvm, and got acquainted with the <kbd>npm</kbd> and <kbd>yarn</kbd> package managers. We then set up a simple HTTP server using the native <kbd>http</kbd> Node module. After that, we used Babel to transpile our ESNext code into a syntax supported by our local environment. We also set up <kbd>nodemon</kbd> to watch for changes in our code and restart the server whenever a change is detected. Lastly, we incorporated ESLint to spot problems in our code, and use a <kbd>pre-commit</kbd> Git hook to run the linter automatically before each commit.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the next chapter, we will be following a <strong>test-driven development</strong> (<strong>TDD</strong>) approach to develop our API server, to provide functionalities for clients to <strong>create, read, update, and delete</strong> (<strong>CRUD</strong>) user objects on our database, using <strong>ElasticSearch</strong> as our data storage solution.</p>
<p>In general, each subsequent chapter will incorporate a new set of tools to the application. The book will focus first on the backend, server-side code, later moving on to frontend, client-side code, before rounding off the book by looking at implementing an automated deployment process.</p>


            

            
        
    </body></html>