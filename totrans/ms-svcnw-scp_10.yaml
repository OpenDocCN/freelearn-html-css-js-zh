- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at best practices when scripting in ServiceNow.
    Best practices are important when scripting to make the most use of resources
    and present the best user experience. We will explore best practices in general
    scripting, server-side and client-side code, and debugging. We will also delve
    into best practices involving logs, queues, and system performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be looked at in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Coding best practices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rule best practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client script best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs and queues best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System performance best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding best practices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When scripting, there are many ways to achieve the same goal, but keeping code
    efficient can make it much easier to maintain and work on in the future. Using
    a few system resources is usually encouraged too, as this decreases loading times
    and the load on the data center in the cloud.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: You will often find that older instances suffer from poor performance because
    best practices were not adhered to during development. I have been part of minor
    projects simply to make code more efficient before, and because these are often
    associated with slow loading times, it can be a great improvement for the user
    base.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at how to make sure your script adhers to best
    practices and how to avoid common mistakes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'First, one type of scripting that is quite common is nested `if` statements.
    This is an `if` statement after an `if` statement and is often used to catch several
    potential values for the same variable. We can see a server-side example of what
    this looks like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also see what this looks like in a script field in *Figure 10.1*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b0da519-1776-4e5e-932e-333a32ed5b1e.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Nested if statement script example'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using these nested if statements, it is better to use a `switch`
    statement. We can see how the previous script can be a more efficient `switch`
    statement instead:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `switch` statement is easier to read as well for developers who may need
    to maintain the ServiceNow instance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `switch` statement inside a script field in *Figure 10.2*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ac4131c-bdb6-4b33-8530-32cdc872631f.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Switch statement script example'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you use a break at the end of each case to ensure that the `switch`
    statement works correctly, as sometimes this can be omitted by mistake.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Business rule best practices
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business rule best practices are, to a large extent, about running business
    rules at the correct time. As we have already discovered, a business rule can
    be run at different times based on when the form is saved or the action is taken
    to the record.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: This means that it is important to make sure that a business rule that is created
    is running in the most efficient way. Using business rules correctly, we can avoid
    problems such as updating the same record twice and running script when it is
    not required.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with looking at the check boxes on a business rule, as shown in *Figure
    10.3*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fdd372f-ae82-46c1-be9d-400360e4aaf9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Business rule check boxes'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Insert and Update are the most frequently used, and they are often used together.
    However, it is a best practice to ensure that you make your business rule only
    run when necessary. Do not tick both boxes just to cover all possibilities; if
    your business rule is not needed when a record is inserted or updated then leave
    that tick box unchecked.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Usually, Delete and Query are selected individually, as these operations do
    not tend to align themselves with any other operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As business rules run on the server side, a good practice in business rule script
    also applies to other areas of ServiceNow where server-side scripting is used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The When field is the next field we will look at. This is an important field
    to get right, and avoid bad practices by doing so. There are four options here;
    let's have a look at each.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Before
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a business rule before a record is saved is a great way to change values
    before the save action takes place. The before option should be selected when
    making changes to the record being saved. This means that if you are changing
    values using current, then before is most likely the best option.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when running a script in a before business rule, the record has
    not been saved yet. This means that you only need to set the values in the current
    record as the record will be saved afterward. This also means that you need to
    ensure that you avoid using `current.update()` as this will end up saving the
    record twice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: After
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the business rule is run with the after option selected, the script runs
    immediately after the record is saved. We should use the after option if we are
    updating values not on the current record we are saving, but want the script to
    be run immediately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This option is useful to update records associated with the record being saved,
    for example, to change tasks when updating a change. This is also a good option
    if we are scripting any sort of approval changes for the record being saved, as
    these will be displayed on the record after it is reloaded, after being saved.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: If we are looking to update the current record, then it is better to use the
    before option. If you are thinking of using `current.update()` in your script,
    then think about using the before option instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Async
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The async option will send the script to the system scheduler, and it will be
    run shortly after the record is saved. This option is good for when the script
    you have written does not need to be run immediately after the record is saved.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Good uses for the async option are for sending messages between integrations
    and sending tasks to the ECC queue. Remember that the async option can have a
    more significant delay if the ServiceNow instance-scheduled job queue is long,
    so be mindful of the average wait time for your instance when setting an async
    business rule. If you would like a more instant running of your script, consider
    the after option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Display
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A display business rule runs when a record is loaded before any client-side
    scripts are run. This type of business rule is useful for providing values to
    the client side so that there is no need to call the server from a client script.
    We can avoid AJAX calls using this type of business rule.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Display business rules were not always available in ServiceNow, so you may find
    instances where using them in old instances can reduce server calls in client
    scripts and therefore reduce record-loading times.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: If you are considering using an AJAX call in an onLoad client script, then you
    should instead, where possible, use a display business rule to fetch the server-side
    values you require and set them in a scratchpad for client-side scripts to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Client script best practices
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, client scripts run on the client side and so only have access
    to data that has been sent to the client from the server. The main goal we have
    when writing client-side scripts is to minimize the amount of script we write
    and the calls to the server we make.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The reason we keep client scripting to a minimum is that these scripts run in
    front of the user and therefore directly effect loading times. We want to keep
    loading times to a minimum and, therefore, client scripting to a minimum also.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: When writing a new client script, it is worth considering whether the script
    could be run on the server side instead, and if so, then this is usually considered
    a best practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at one of the most common bad practices in client scripting.
    Take the following script, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script is calling the server side to get the details about the current
    caller for an incident, and whether that caller is active now in the system. This
    is a bad practice as we can already tell whether this user is active before we
    load the record, rather than loading it, then going back to the database again,
    increasing load times.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what this code would look like in the following client script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84110aec-6a8c-4713-beb8-416985f4c191.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Client script showing bad practise by making an unnecessary server
    call'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: To keep this functionality, but improve the code, we can use a display business
    rule. By doing this, we bring the data we want from the server before we get to
    the client using a scratchpad.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the display business rule with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code sets the active field value to the `caller_active` scratchpad so that
    it can be used by the client code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what this looks like as a display business rule:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33caf409-5655-4b44-96f7-e387f1389de3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Display business rule setting a scratchpad variable'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In our business rule, we would set the When field on the When to run tab to
    be displayed so that this rule runs as the form is loaded. For our example, we
    have set the incident form as the table to run this business rule on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the display business rule set up, so we just need to amend our
    client script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the earlier code, we set the field message text using the scratchpad value
    we set in the display business rule. This now means that we are not making a round
    trip to the server for this detail anymore as it is sent initially.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what this will look like in a defined client script:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b113e83-e523-48c3-9e8c-066bbff49ac5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Client script setting a field message based on a scratchpad value'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are using the script when the incident form loads. This will
    show the active state of the caller currently selected on the incident form. We
    would also want to bear in mind changing this value if the caller changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, we can display any of the other caller attributes as well,
    including helpful fields like phone number or email address to contact a caller
    about progress on an incident. We could also display the line manager and use
    dot walking to display some of the manager's information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see what the output would look like for our example for a caller
    on the incident form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e88c6d9c-bd36-49a4-8928-ada8e91557ce.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Incident form showing a custom field message for the Caller field'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: We have opened one of the baseline incidents that is present in ServiceNow,
    and we can see that the current caller is active in ServiceNow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to review the client scripts in your ServiceNow instance
    to ensure that no unnecessary server calls are made by them. Remember to use display
    business rules where possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools best practices
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discovered in previous chapters, there are many ways to debug in
    ServiceNow. Each developer will have their own favorite methods, and also, there
    are better ways to debug different scenarios.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my favorite ways of debugging is using logging techniques such as `gs.log`.
    In earlier chapters, we saw that these logs can be added to a script, and when
    the script runs, we see these logs in the system log for the ServiceNow instance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: However, we must ensure that this debugging is never seen in a production instance.
    It is a good practice to check each script that you write to ensure that no debugging
    is left in the final version. It can be a good idea to check the system log before
    your newly created script is executed and then again once you have finished. If
    there are any logging messages that are sent, then these should be removed before
    the new functionality is sent to a production instance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to make sure that you make your logging messages relevant
    to the functionality you are trying to achieve. This is especially important if
    you aim to leave in some logging functionality for your new code. Building some
    logging functionality can be helpful in a larger application or customization.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the following code and logging:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example will create a log when the value of the caller has been successfully
    put into the caller variable, but it does not offer much information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the log this creates here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1af01dba-3064-4ceb-ab33-82a1126d309a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Sample basic log'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our log, let''s look at another example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This second example is better because we now have some information about what
    is happening at this point in the code, and where the code was successful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this log looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf92da7-bd2e-4149-ad80-cdd63246976d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Sample improved log'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We can still improve this further though by adding more information at this
    point.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a further example on logging in this way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looking at the example, we now have added code in our logging to log the value
    of the caller field, as well as the details of what has occurred in the script.
    This will log the `sys_id` of the user in the system log, so we can check the
    value of the caller variable is correct at this point in the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this improved log in the following figure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b5b4b7c-9459-4dfc-ab5d-d5c3a9ff4498.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Sample log with data added'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will look at one final example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this final example, we are now logging the display value to the log, so
    we can see the actual name of the user rather than just the `sys_id` of the user.
    This makes the result clearer for a developer reading through the log statements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how the final example looks in the system log:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8dba677-3bae-4ccc-ba7b-c43c818ecc20.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11:  Sample log with useful data included
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how it is easy to add logging to ServiceNow script, but it is best
    practice to ensure that the logs you create would be helpful to developers other
    than yourself.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Session debug
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session debug can be a powerful tool, but it can also create an overload of
    logs making debugging a long and arduous process. When using session debugging,
    it is important to think about the type of logs you need to debug the situation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: While it can seem easiest to simply enable all session debugging, it is best
    to enable the areas you are interested in only. This ensures there are less logs
    to go through and means you can access the information that you are interested
    in faster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In general, I do not find session debug to be used by many developers except
    for scopes and security rules. This is because other methods are preferred for
    the other debugging options session debugging provides.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Logs and queues best practices
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logs and queues are an important part of a ServiceNow instance. Logs are used
    throughout ServiceNow to record events occurring in an instance. These are used
    in debugging, as we have seen, and these logs should be well-defined when included.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Queues are seen in ServiceNow in a number of areas, from the ECC queue to the
    system scheduler. These queues build up jobs or actions to be performed when the
    time is right.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When using logs and queues, it is important to make logs clear and only create
    jobs or event in queues where necessary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logs need to be created with clear information given for each log, and to be
    sent to the right logging location to ensure that the information can be easily
    read. We covered some logging techniques in the debugging section or how to write
    good logs, but we also need to make sure that we send logs to the correct log
    itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: When using `gs.log`, we can specify a source to send the logs to. If no source
    is specified, then *** Script will be the default source used. This will show
    the log in the Script Log Statements module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see a sample log with the *** Script source displayed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/118bac73-6537-4fab-af5b-bc38a969c51b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Sample script log'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a larger piece of functionality or a custom application,
    it is advised that you create your own logging source. By adding your own source,
    you can keep all of your logging separate and easy to maintain. It is also often
    the case that a developer will create a module as part of their new application
    to be directed to logs with the custom source of the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many queues in ServiceNow that you can send jobs and events to. Queuing
    up a task or event allows them to be combined together and processed in a batch
    rather than individually.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Each queue will be processed after a given time, and the timing that each queue
    is processed is often set in the system properties. Changing the frequency that
    a queue is processed will mean that tasks or events are dealt with quicker, but
    it will have a draining effect on system resources. It is always important to
    carefully consider this when setting queue processing times at a different value
    to the defaults that are provided in the baseline system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at some of the most important queues in a ServiceNow
    instance and the best practice for each queue type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Event queue
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event queue triggers events that are then picked up by notifications and
    script actions. Triggering an event does not use many system resources, so volume
    is not usually a problem. There are many events that are provided and triggered
    in the baseline system, so this queue will always contain activity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The more important aspect of setting up scripts to send events to the event
    queue is making sure that the event is well-defined and only fires when it is
    supposed to.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Well-explained events are much easier to use for other developers, so try to
    demonstrate what the event is triggered by in the name of the event itself, and
    certainly in the definition.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a sample event log here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27c3e01e-f7b1-42b5-95a5-c7a97ad60ffb.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Event log sample'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In an event log, we can see when events were processed, and the processing duration
    of events. It is worth considering the impact of events taking a long time to
    process and, if necessary, investigate why this is the case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we can see some regular events in the log including a successful
    login and established session, as well as a heartbeat event and text indexing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: When creating an event, ensure that you test edge-case scenarios so that the
    definition of the event truly reflects when it will fire.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: When sending an event to the event queue for the more distant future, be careful
    that the event will not be lost as part of table rotation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: System scheduler
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common ways that you can add a job to the system scheduler is
    to use an async business rule. Once an async business rule is triggered, it sends
    a job to the scheduler queue to run the script contained within it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to add your own jobs to the system scheduler. It is best
    to only do this where necessary, as too many jobs in the scheduler can be a detriment
    to instance performance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: ECC queue
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ECC queue is where input and output messages from MID servers are held.
    This is usually for integrations between instances and other systems. Here, we
    can send jobs using scripts for the MID servers to perform. There is normally
    not a lot of scripted messages to the ECC queue as it normally triggers an integration
    in one line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECC Queue is accessed from the application navigator by navigating to ECC
    | Queue. We can see this module here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fecccce-53ba-4615-a4da-1d56a8f7e2b3.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14:  ECC queue module
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The queue will often contain heartbeat probes sent out to MID servers to check
    that they are responding. This is done every 5 minutes, and if a response is received,
    the MID server is marked as up, and if no response is received, the MID server
    is marked as down.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When sending jobs to the ECC queue, just make sure that each job is relevant
    and do not send more jobs than are necessary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: System performance best practices
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of attributes that make up the perceived performance of an
    instance. These can be greatly effected by badly coded scripts or a large number
    of them that are not required.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common ways scripting can cause perceived performance delays
    is when an excess of client scripts are used when a form opens. This causes a
    big delay in browser rendering and parsing, which is very apparent to the user.
    As we have mentioned before, a best practice in this scenario is to limit the
    amount of client scripts created only to those essential, and to ensure that server
    calls are kept to a minimum.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If information is needed for an `onLoad` client script, then consider a display
    business rule instead of calling the server from a client script.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要`onLoad`客户端脚本的信息，那么考虑使用显示业务规则而不是从客户端脚本调用服务器。
- en: Using this method, we can obtain the information we need from the server from
    the display business rule before displaying a form. Then, we run client-side code
    in a client script that will be able to use the information we provided from the
    display business rule.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以在显示表单之前从显示业务规则中获取所需的服务器信息。然后，我们在客户端脚本中运行客户端代码，该代码将能够使用我们从显示业务规则中提供的信息。
- en: It is possible to clear the cache of an instance by navigating to your instance
    name and suffixing it with `/cache.do`. This clears the cache for you and can
    help when you want to ensure that your new script is being run, and cached data
    is not being used.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到您的实例名称并在其后附加`/cache.do`，可以清除实例的缓存。这会为您清除缓存，并在您想要确保新脚本正在运行且缓存数据未被使用时有所帮助。
- en: We can see the screen a user is shown when navigating to the page that clears
    the cache, here in *Figure 10.15*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到用户在导航到清除缓存页面时看到的屏幕，如图10.15所示。
- en: '![](img/61ee7e84-2e2a-410b-879b-9aa670c02095.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61ee7e84-2e2a-410b-879b-9aa670c02095.png)'
- en: 'Figure 10.15: Information provided on cache clearance'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：缓存清除提供的信息
- en: Clearing the cache for an instance, however, can cause performance degradation,
    so it is important to know when to do this. On non-production instances, this
    should not be a problem, as the performance decrease should not dramatically affect
    other developers. For a production instance though, this should be avoided during
    business hours where possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，清除实例的缓存可能会导致性能下降，因此了解何时进行此操作很重要。在非生产实例上，这通常不会成为问题，因为性能下降不应显著影响其他开发者。但对于生产实例，在可能的情况下应避免在办公时间内进行。
- en: When considering system performance, it is also worth checking the performance
    of the instance being used. This can be done using the ServiceNow performance
    home page that ServiceNow provides.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑系统性能时，还值得检查正在使用的实例的性能。这可以通过ServiceNow提供的性能主页来完成。
- en: 'Let''s have a look at some of the graphs that this home page provides:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个主页提供的某些图表：
- en: '![](img/e95682fd-8e0e-4e32-a6f7-0a8ec2702828.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e95682fd-8e0e-4e32-a6f7-0a8ec2702828.png)'
- en: 'Figure 10.16: System overview graphs sample'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：系统概述图表示例
- en: In the previously shown graphs, we can see an overview, transaction, response
    time, and active session graph. These can be helpful in finding out the current
    load on the instance and whether the response times are providing a good level
    of service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前展示的图表中，我们可以看到概述、交易、响应时间和活跃会话图表。这些图表有助于了解实例当前的负载情况以及响应时间是否提供了良好的服务水平。
- en: The ServiceNow performance home page also displays many other graphs than the
    ones shown, which you can use. I tend to find the response times the most useful
    of the ones provided, but each graph can have its uses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow性能主页还显示了比展示的更多的图表，您可以使用它们。我倾向于认为提供的响应时间是最有用的，但每个图表都有其用途。
- en: By keeping an eye on instance performance, you can be proactive in resolving
    potential system performance issues.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注实例性能，您可以主动解决潜在的系统性能问题。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at best practices in ServiceNow. We looked at some
    of the best ways to use scripting in ServiceNow, and some bad practices to avoid.
    Our best practices included the areas of coding, business rules, and client scripts,
    as well as debugging, logs, queues, and system performance. We saw how these best
    practices work together to build a streamlined ServiceNow instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了ServiceNow的最佳实践。我们探讨了在ServiceNow中使用脚本的一些最佳方法，以及一些应避免的坏习惯。我们的最佳实践包括编码、业务规则和客户端脚本领域，以及调试、日志、队列和系统性能。我们看到了这些最佳实践是如何协同工作以构建一个精简的ServiceNow实例的。
- en: In the next chapter, we will look at using update sets. Update sets are a big
    part of moving functionality between instances of ServiceNow, and are widely used.
    We will look at when and how to use update sets and how they work in relation
    to scope. We discover how to move update sets between instances and the pitfalls
    to avoid when doing so. Finally, we take a look at best practices with update
    sets, so you can make the most of the ServiceNow application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用更新集。更新集是ServiceNow实例之间移动功能的重要组成部分，并且被广泛使用。我们将讨论何时以及如何使用更新集，以及它们与范围的关系。我们将发现如何在不同实例之间移动更新集，以及在此过程中应避免的陷阱。最后，我们将探讨使用更新集的最佳实践，以便您能够最大限度地利用ServiceNow应用程序。
