- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at best practices when scripting in ServiceNow.
    Best practices are important when scripting to make the most use of resources
    and present the best user experience. We will explore best practices in general
    scripting, server-side and client-side code, and debugging. We will also delve
    into best practices involving logs, queues, and system performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be looked at in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rule best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client script best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs and queues best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System performance best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When scripting, there are many ways to achieve the same goal, but keeping code
    efficient can make it much easier to maintain and work on in the future. Using
    a few system resources is usually encouraged too, as this decreases loading times
    and the load on the data center in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: You will often find that older instances suffer from poor performance because
    best practices were not adhered to during development. I have been part of minor
    projects simply to make code more efficient before, and because these are often
    associated with slow loading times, it can be a great improvement for the user
    base.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at how to make sure your script adhers to best
    practices and how to avoid common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, one type of scripting that is quite common is nested `if` statements.
    This is an `if` statement after an `if` statement and is often used to catch several
    potential values for the same variable. We can see a server-side example of what
    this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see what this looks like in a script field in *Figure 10.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b0da519-1776-4e5e-932e-333a32ed5b1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Nested if statement script example'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using these nested if statements, it is better to use a `switch`
    statement. We can see how the previous script can be a more efficient `switch`
    statement instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` statement is easier to read as well for developers who may need
    to maintain the ServiceNow instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `switch` statement inside a script field in *Figure 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ac4131c-bdb6-4b33-8530-32cdc872631f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Switch statement script example'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you use a break at the end of each case to ensure that the `switch`
    statement works correctly, as sometimes this can be omitted by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Business rule best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business rule best practices are, to a large extent, about running business
    rules at the correct time. As we have already discovered, a business rule can
    be run at different times based on when the form is saved or the action is taken
    to the record.
  prefs: []
  type: TYPE_NORMAL
- en: This means that it is important to make sure that a business rule that is created
    is running in the most efficient way. Using business rules correctly, we can avoid
    problems such as updating the same record twice and running script when it is
    not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with looking at the check boxes on a business rule, as shown in *Figure
    10.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fdd372f-ae82-46c1-be9d-400360e4aaf9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Business rule check boxes'
  prefs: []
  type: TYPE_NORMAL
- en: Insert and Update are the most frequently used, and they are often used together.
    However, it is a best practice to ensure that you make your business rule only
    run when necessary. Do not tick both boxes just to cover all possibilities; if
    your business rule is not needed when a record is inserted or updated then leave
    that tick box unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, Delete and Query are selected individually, as these operations do
    not tend to align themselves with any other operations.
  prefs: []
  type: TYPE_NORMAL
- en: As business rules run on the server side, a good practice in business rule script
    also applies to other areas of ServiceNow where server-side scripting is used.
  prefs: []
  type: TYPE_NORMAL
- en: The When field is the next field we will look at. This is an important field
    to get right, and avoid bad practices by doing so. There are four options here;
    let's have a look at each.
  prefs: []
  type: TYPE_NORMAL
- en: Before
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a business rule before a record is saved is a great way to change values
    before the save action takes place. The before option should be selected when
    making changes to the record being saved. This means that if you are changing
    values using current, then before is most likely the best option.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when running a script in a before business rule, the record has
    not been saved yet. This means that you only need to set the values in the current
    record as the record will be saved afterward. This also means that you need to
    ensure that you avoid using `current.update()` as this will end up saving the
    record twice.
  prefs: []
  type: TYPE_NORMAL
- en: After
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the business rule is run with the after option selected, the script runs
    immediately after the record is saved. We should use the after option if we are
    updating values not on the current record we are saving, but want the script to
    be run immediately.
  prefs: []
  type: TYPE_NORMAL
- en: This option is useful to update records associated with the record being saved,
    for example, to change tasks when updating a change. This is also a good option
    if we are scripting any sort of approval changes for the record being saved, as
    these will be displayed on the record after it is reloaded, after being saved.
  prefs: []
  type: TYPE_NORMAL
- en: If we are looking to update the current record, then it is better to use the
    before option. If you are thinking of using `current.update()` in your script,
    then think about using the before option instead.
  prefs: []
  type: TYPE_NORMAL
- en: Async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The async option will send the script to the system scheduler, and it will be
    run shortly after the record is saved. This option is good for when the script
    you have written does not need to be run immediately after the record is saved.
  prefs: []
  type: TYPE_NORMAL
- en: Good uses for the async option are for sending messages between integrations
    and sending tasks to the ECC queue. Remember that the async option can have a
    more significant delay if the ServiceNow instance-scheduled job queue is long,
    so be mindful of the average wait time for your instance when setting an async
    business rule. If you would like a more instant running of your script, consider
    the after option.
  prefs: []
  type: TYPE_NORMAL
- en: Display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A display business rule runs when a record is loaded before any client-side
    scripts are run. This type of business rule is useful for providing values to
    the client side so that there is no need to call the server from a client script.
    We can avoid AJAX calls using this type of business rule.
  prefs: []
  type: TYPE_NORMAL
- en: Display business rules were not always available in ServiceNow, so you may find
    instances where using them in old instances can reduce server calls in client
    scripts and therefore reduce record-loading times.
  prefs: []
  type: TYPE_NORMAL
- en: If you are considering using an AJAX call in an onLoad client script, then you
    should instead, where possible, use a display business rule to fetch the server-side
    values you require and set them in a scratchpad for client-side scripts to use.
  prefs: []
  type: TYPE_NORMAL
- en: Client script best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, client scripts run on the client side and so only have access
    to data that has been sent to the client from the server. The main goal we have
    when writing client-side scripts is to minimize the amount of script we write
    and the calls to the server we make.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we keep client scripting to a minimum is that these scripts run in
    front of the user and therefore directly effect loading times. We want to keep
    loading times to a minimum and, therefore, client scripting to a minimum also.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a new client script, it is worth considering whether the script
    could be run on the server side instead, and if so, then this is usually considered
    a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at one of the most common bad practices in client scripting.
    Take the following script, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This script is calling the server side to get the details about the current
    caller for an incident, and whether that caller is active now in the system. This
    is a bad practice as we can already tell whether this user is active before we
    load the record, rather than loading it, then going back to the database again,
    increasing load times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what this code would look like in the following client script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84110aec-6a8c-4713-beb8-416985f4c191.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Client script showing bad practise by making an unnecessary server
    call'
  prefs: []
  type: TYPE_NORMAL
- en: To keep this functionality, but improve the code, we can use a display business
    rule. By doing this, we bring the data we want from the server before we get to
    the client using a scratchpad.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the display business rule with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code sets the active field value to the `caller_active` scratchpad so that
    it can be used by the client code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what this looks like as a display business rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33caf409-5655-4b44-96f7-e387f1389de3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Display business rule setting a scratchpad variable'
  prefs: []
  type: TYPE_NORMAL
- en: In our business rule, we would set the When field on the When to run tab to
    be displayed so that this rule runs as the form is loaded. For our example, we
    have set the incident form as the table to run this business rule on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the display business rule set up, so we just need to amend our
    client script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the earlier code, we set the field message text using the scratchpad value
    we set in the display business rule. This now means that we are not making a round
    trip to the server for this detail anymore as it is sent initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what this will look like in a defined client script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b113e83-e523-48c3-9e8c-066bbff49ac5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Client script setting a field message based on a scratchpad value'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are using the script when the incident form loads. This will
    show the active state of the caller currently selected on the incident form. We
    would also want to bear in mind changing this value if the caller changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, we can display any of the other caller attributes as well,
    including helpful fields like phone number or email address to contact a caller
    about progress on an incident. We could also display the line manager and use
    dot walking to display some of the manager's information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see what the output would look like for our example for a caller
    on the incident form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e88c6d9c-bd36-49a4-8928-ada8e91557ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Incident form showing a custom field message for the Caller field'
  prefs: []
  type: TYPE_NORMAL
- en: We have opened one of the baseline incidents that is present in ServiceNow,
    and we can see that the current caller is active in ServiceNow.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to review the client scripts in your ServiceNow instance
    to ensure that no unnecessary server calls are made by them. Remember to use display
    business rules where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discovered in previous chapters, there are many ways to debug in
    ServiceNow. Each developer will have their own favorite methods, and also, there
    are better ways to debug different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my favorite ways of debugging is using logging techniques such as `gs.log`.
    In earlier chapters, we saw that these logs can be added to a script, and when
    the script runs, we see these logs in the system log for the ServiceNow instance.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must ensure that this debugging is never seen in a production instance.
    It is a good practice to check each script that you write to ensure that no debugging
    is left in the final version. It can be a good idea to check the system log before
    your newly created script is executed and then again once you have finished. If
    there are any logging messages that are sent, then these should be removed before
    the new functionality is sent to a production instance.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to make sure that you make your logging messages relevant
    to the functionality you are trying to achieve. This is especially important if
    you aim to leave in some logging functionality for your new code. Building some
    logging functionality can be helpful in a larger application or customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the following code and logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example will create a log when the value of the caller has been successfully
    put into the caller variable, but it does not offer much information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the log this creates here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1af01dba-3064-4ceb-ab33-82a1126d309a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Sample basic log'
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our log, let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This second example is better because we now have some information about what
    is happening at this point in the code, and where the code was successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this log looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf92da7-bd2e-4149-ad80-cdd63246976d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Sample improved log'
  prefs: []
  type: TYPE_NORMAL
- en: We can still improve this further though by adding more information at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a further example on logging in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the example, we now have added code in our logging to log the value
    of the caller field, as well as the details of what has occurred in the script.
    This will log the `sys_id` of the user in the system log, so we can check the
    value of the caller variable is correct at this point in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this improved log in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b5b4b7c-9459-4dfc-ab5d-d5c3a9ff4498.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Sample log with data added'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will look at one final example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this final example, we are now logging the display value to the log, so
    we can see the actual name of the user rather than just the `sys_id` of the user.
    This makes the result clearer for a developer reading through the log statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how the final example looks in the system log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8dba677-3bae-4ccc-ba7b-c43c818ecc20.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11:  Sample log with useful data included
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how it is easy to add logging to ServiceNow script, but it is best
    practice to ensure that the logs you create would be helpful to developers other
    than yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Session debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session debug can be a powerful tool, but it can also create an overload of
    logs making debugging a long and arduous process. When using session debugging,
    it is important to think about the type of logs you need to debug the situation.
  prefs: []
  type: TYPE_NORMAL
- en: While it can seem easiest to simply enable all session debugging, it is best
    to enable the areas you are interested in only. This ensures there are less logs
    to go through and means you can access the information that you are interested
    in faster.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I do not find session debug to be used by many developers except
    for scopes and security rules. This is because other methods are preferred for
    the other debugging options session debugging provides.
  prefs: []
  type: TYPE_NORMAL
- en: Logs and queues best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logs and queues are an important part of a ServiceNow instance. Logs are used
    throughout ServiceNow to record events occurring in an instance. These are used
    in debugging, as we have seen, and these logs should be well-defined when included.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are seen in ServiceNow in a number of areas, from the ECC queue to the
    system scheduler. These queues build up jobs or actions to be performed when the
    time is right.
  prefs: []
  type: TYPE_NORMAL
- en: When using logs and queues, it is important to make logs clear and only create
    jobs or event in queues where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logs need to be created with clear information given for each log, and to be
    sent to the right logging location to ensure that the information can be easily
    read. We covered some logging techniques in the debugging section or how to write
    good logs, but we also need to make sure that we send logs to the correct log
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: When using `gs.log`, we can specify a source to send the logs to. If no source
    is specified, then *** Script will be the default source used. This will show
    the log in the Script Log Statements module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see a sample log with the *** Script source displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/118bac73-6537-4fab-af5b-bc38a969c51b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Sample script log'
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a larger piece of functionality or a custom application,
    it is advised that you create your own logging source. By adding your own source,
    you can keep all of your logging separate and easy to maintain. It is also often
    the case that a developer will create a module as part of their new application
    to be directed to logs with the custom source of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many queues in ServiceNow that you can send jobs and events to. Queuing
    up a task or event allows them to be combined together and processed in a batch
    rather than individually.
  prefs: []
  type: TYPE_NORMAL
- en: Each queue will be processed after a given time, and the timing that each queue
    is processed is often set in the system properties. Changing the frequency that
    a queue is processed will mean that tasks or events are dealt with quicker, but
    it will have a draining effect on system resources. It is always important to
    carefully consider this when setting queue processing times at a different value
    to the defaults that are provided in the baseline system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at some of the most important queues in a ServiceNow
    instance and the best practice for each queue type.
  prefs: []
  type: TYPE_NORMAL
- en: Event queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event queue triggers events that are then picked up by notifications and
    script actions. Triggering an event does not use many system resources, so volume
    is not usually a problem. There are many events that are provided and triggered
    in the baseline system, so this queue will always contain activity.
  prefs: []
  type: TYPE_NORMAL
- en: The more important aspect of setting up scripts to send events to the event
    queue is making sure that the event is well-defined and only fires when it is
    supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: Well-explained events are much easier to use for other developers, so try to
    demonstrate what the event is triggered by in the name of the event itself, and
    certainly in the definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a sample event log here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27c3e01e-f7b1-42b5-95a5-c7a97ad60ffb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Event log sample'
  prefs: []
  type: TYPE_NORMAL
- en: In an event log, we can see when events were processed, and the processing duration
    of events. It is worth considering the impact of events taking a long time to
    process and, if necessary, investigate why this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we can see some regular events in the log including a successful
    login and established session, as well as a heartbeat event and text indexing.
  prefs: []
  type: TYPE_NORMAL
- en: When creating an event, ensure that you test edge-case scenarios so that the
    definition of the event truly reflects when it will fire.
  prefs: []
  type: TYPE_NORMAL
- en: When sending an event to the event queue for the more distant future, be careful
    that the event will not be lost as part of table rotation.
  prefs: []
  type: TYPE_NORMAL
- en: System scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common ways that you can add a job to the system scheduler is
    to use an async business rule. Once an async business rule is triggered, it sends
    a job to the scheduler queue to run the script contained within it.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to add your own jobs to the system scheduler. It is best
    to only do this where necessary, as too many jobs in the scheduler can be a detriment
    to instance performance.
  prefs: []
  type: TYPE_NORMAL
- en: ECC queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ECC queue is where input and output messages from MID servers are held.
    This is usually for integrations between instances and other systems. Here, we
    can send jobs using scripts for the MID servers to perform. There is normally
    not a lot of scripted messages to the ECC queue as it normally triggers an integration
    in one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECC Queue is accessed from the application navigator by navigating to ECC
    | Queue. We can see this module here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fecccce-53ba-4615-a4da-1d56a8f7e2b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14:  ECC queue module
  prefs: []
  type: TYPE_NORMAL
- en: The queue will often contain heartbeat probes sent out to MID servers to check
    that they are responding. This is done every 5 minutes, and if a response is received,
    the MID server is marked as up, and if no response is received, the MID server
    is marked as down.
  prefs: []
  type: TYPE_NORMAL
- en: When sending jobs to the ECC queue, just make sure that each job is relevant
    and do not send more jobs than are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: System performance best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of attributes that make up the perceived performance of an
    instance. These can be greatly effected by badly coded scripts or a large number
    of them that are not required.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common ways scripting can cause perceived performance delays
    is when an excess of client scripts are used when a form opens. This causes a
    big delay in browser rendering and parsing, which is very apparent to the user.
    As we have mentioned before, a best practice in this scenario is to limit the
    amount of client scripts created only to those essential, and to ensure that server
    calls are kept to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: If information is needed for an `onLoad` client script, then consider a display
    business rule instead of calling the server from a client script.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, we can obtain the information we need from the server from
    the display business rule before displaying a form. Then, we run client-side code
    in a client script that will be able to use the information we provided from the
    display business rule.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to clear the cache of an instance by navigating to your instance
    name and suffixing it with `/cache.do`. This clears the cache for you and can
    help when you want to ensure that your new script is being run, and cached data
    is not being used.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the screen a user is shown when navigating to the page that clears
    the cache, here in *Figure 10.15*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61ee7e84-2e2a-410b-879b-9aa670c02095.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Information provided on cache clearance'
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the cache for an instance, however, can cause performance degradation,
    so it is important to know when to do this. On non-production instances, this
    should not be a problem, as the performance decrease should not dramatically affect
    other developers. For a production instance though, this should be avoided during
    business hours where possible.
  prefs: []
  type: TYPE_NORMAL
- en: When considering system performance, it is also worth checking the performance
    of the instance being used. This can be done using the ServiceNow performance
    home page that ServiceNow provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at some of the graphs that this home page provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e95682fd-8e0e-4e32-a6f7-0a8ec2702828.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: System overview graphs sample'
  prefs: []
  type: TYPE_NORMAL
- en: In the previously shown graphs, we can see an overview, transaction, response
    time, and active session graph. These can be helpful in finding out the current
    load on the instance and whether the response times are providing a good level
    of service.
  prefs: []
  type: TYPE_NORMAL
- en: The ServiceNow performance home page also displays many other graphs than the
    ones shown, which you can use. I tend to find the response times the most useful
    of the ones provided, but each graph can have its uses.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping an eye on instance performance, you can be proactive in resolving
    potential system performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at best practices in ServiceNow. We looked at some
    of the best ways to use scripting in ServiceNow, and some bad practices to avoid.
    Our best practices included the areas of coding, business rules, and client scripts,
    as well as debugging, logs, queues, and system performance. We saw how these best
    practices work together to build a streamlined ServiceNow instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at using update sets. Update sets are a big
    part of moving functionality between instances of ServiceNow, and are widely used.
    We will look at when and how to use update sets and how they work in relation
    to scope. We discover how to move update sets between instances and the pitfalls
    to avoid when doing so. Finally, we take a look at best practices with update
    sets, so you can make the most of the ServiceNow application.
  prefs: []
  type: TYPE_NORMAL
