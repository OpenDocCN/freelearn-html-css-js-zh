<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor051"/>3</h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Managing Props and State</h1>
<p>In the world of web development, managing data effectively is crucial. Whether it’s the information that flows between components or the internal state of a component, proper data management is the backbone of a functional and responsive web application.</p>
<p>In this chapter, we will delve into the core concepts of managing props and state within a Svelte application. First, we’ll clarify what props and states in Svelte are, laying the groundwork for understanding more advanced topics. We then explore the concept of bindings, a feature in Svelte for keeping state and element values or component props in sync.</p>
<p>We’ll then explore data flow within components, highlighting the differences between one-way data flow and two-way data flow and why they matter. Moving on, we’ll discuss how to derive state from props using Svelte’s reactive declarations. To conclude, we’ll offer tips for managing complex derived states and explain how to update props based on those derived states.</p>
<p>By the end of the chapter, you’ll have a solid understanding of how to manage data within a Svelte component, being equipped with practical tips and strategies to tackle common challenges effectively.</p>
<p>In this chapter, you will learn the following:</p>
<ul>
<li>Defining props and state</li>
<li>Understanding bindings</li>
<li>One-way versus two-way data flow</li>
<li>Deriving states from props with a reactive declaration</li>
<li>Managing complex derived states</li>
<li>Updating props using derived states</li>
</ul>
<p>Before we start to talk about props and state, let’s first define what props and state are in Svelte.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Technical requirements</h1>
<p>You can find all the code samples used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03</a></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Defining props and state</h1>
<p>In Svelte, both props and state are used to manage data within components. Props are a way to pass data from a parent component to a child component. This makes the child component flexible and reusable, as it can get different data from the parent as needed.</p>
<p>On the other hand, state is data that is initialized and managed internally within a component, unlike props, which are received from an external source. State allows a component to be self-contained and modular.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Defining props</h2>
<p>Let’s start with props. Props<a id="_idIndexMarker080"/> in Svelte are defined using the <code>export</code> keyword. When you export a variable in a Svelte component, it becomes a prop that you can pass data to from a parent component.</p>
<p>Here is a simple example:</p>
<pre class="source-code">
&lt;!-- file: Child.svelte --&gt;
&lt;script&gt;
  export let message;
&lt;/script&gt;
&lt;h1&gt;{message}&lt;/h1&gt;</pre> <p>In the preceding code snippet, we defined a Svelte component in a file named <code>Child.svelte</code>. In the Svelte component, <code>message</code> is a prop. You can pass data to <code>message</code> from a parent component like so:</p>
<pre class="source-code">
&lt;!-- file: Parent.svelte --&gt;
&lt;script&gt;
  import Child from './Child.svelte';
&lt;/script&gt;
&lt;Child message="Hello, World!" /&gt;</pre> <p>In the preceding code snippet, we define another Svelte component in a file named <code>Parent.svelte</code>. In the component, we import and use the <code>Child</code> component from <code>Child.svelte</code>. As the <code>Parent</code> component includes the <code>Child</code> component, the <code>Parent</code> component is considered the parent component of the imported <code>Child</code> component.</p>
<p>In the parent <a id="_idIndexMarker081"/>component, you can set the <code>message</code> props of the child component to the value <code>"Hello, World!"</code> by passing <code>"Hello, World!"</code> through the <code>message</code> attribute of the <code>&lt;Child /&gt;</code> component, as shown in the preceding code snippet.</p>
<p>In summary, props are defined using the <code>export</code> keyword, and their values are passed from the parent component to the child component.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Defining state</h2>
<p>Next, let’s look at <a id="_idIndexMarker082"/>the state. State is any data that is used and managed within a component. It is not passed in from a parent component like props. Instead, it is defined within the component itself.</p>
<p>Here’s an example that illustrates state:</p>
<pre class="source-code">
&lt;!-- file: Counter.svelte --&gt;
&lt;script&gt;
  let count = 0;
  function increment() {
    count += 1;
  }
&lt;/script&gt;
&lt;button on:click={increment}&gt;Click me&lt;/button&gt;
&lt;p&gt;{count}&lt;/p&gt;</pre> <p>In this example, <code>count</code> is a state variable. It’s not passed in as a prop but is defined and managed within the <code>Counter</code> component. When you click the button, the <code>increment</code> function is called, which <a id="_idIndexMarker083"/>modifies the <code>count</code> state.</p>
<p>In summary, props are variables that are passed into a component from a parent component, whereas the state is data that is managed within a component itself.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Props versus state</h2>
<p>If you <a id="_idIndexMarker084"/>look closely, both props and state represent data. The difference <a id="_idIndexMarker085"/>between them depends on the context of the component you are considering.</p>
<p>For example, let’s consider two components, component <code>A</code> and component <code>B</code>.</p>
<p>Let’s begin with component <code>A</code>:</p>
<pre class="source-code">
&lt;!-- A.svelte --&gt;
&lt;script&gt;
  export let height;
&lt;/script&gt;</pre> <p>In component <code>A</code>, we define a props called <code>height</code>.</p>
<p>Now take a look at component <code>B</code>:</p>
<pre class="source-code">
&lt;!-- B.svelte --&gt;
&lt;script&gt;
  import A from './A.svelte';
  let height = 0;
&lt;/script&gt;
&lt;A height={height} /&gt;</pre> <p>In component <code>B</code>, we define a state called <code>height</code> and pass its value as a prop to component <code>A</code>.</p>
<p>From the perspective of component <code>B</code>, <code>height</code> is considered a state, but from the viewpoint of component <code>A</code>, it’s considered a prop. Whether a variable is a prop or a state depends on the context of the component in which it is being viewed. At their core, they are essentially the same thing.</p>
<p>In this <a id="_idIndexMarker086"/>example, due to the way JavaScript passes primitive variables by value, it may not be immediately obvious that the <code>height</code> variable in both component <code>A</code> and component <code>B</code> refers to the same thing.</p>
<p>However, if we define an object as state and pass it to another component through props, it becomes clear that both the state in one component and the props in the other component refer to the same object reference.</p>
<p>Let’s modify our example to illustrate this point:</p>
<pre class="source-code">
&lt;!-- A.svelte --&gt;
&lt;script&gt;
  export let height;
  <strong class="bold">setInterval(() =&gt; console.log('A:', height), 1000);</strong>
&lt;/script&gt;
&lt;!-- B.svelte --&gt;
&lt;script&gt;
  import A from './A.svelte';
  <strong class="bold">let height = { value: 100 };</strong>
  <strong class="bold">setInterval(() =&gt; console.log('B:', height), 1000);</strong>
&lt;/script&gt;
&lt;A height={height} /&gt;</pre> <p>In this code <a id="_idIndexMarker087"/>snippet, I’ve added a <code>setInterval</code> function to print out the value of the <code>height</code> variable every second in both components. In component <code>B</code>, I’ve modified the state <code>height</code> to be an object. Because objects in JavaScript are passed by reference, the state <code>height</code> in component <code>B</code> that is passed as a prop to component <code>A</code> is passed by reference as well. This means the <code>height</code> prop in component <code>A</code> is referencing the same object as the state <code>height</code> in component <code>B</code>.</p>
<p>If we add a <code>&lt;button&gt;</code> element in component <code>B</code> to mutate the <code>height</code> object, as shown here, you’ll be able to see that both component <code>A</code> and component <code>B</code> print out the same updated value of the <code>height</code> variable in the console. This is because they are printing out the value of the same object reference:</p>
<pre class="source-code">
&lt;button on:click={() =&gt; { height.value += 10; }} /&gt;</pre> <p>Clicking on <a id="_idIndexMarker088"/>the button from the preceding code snippet will result in the <a id="_idIndexMarker089"/>console printing out <code>A: { value: 110 }</code> and <code>B: { value: 110 }</code>. This demonstrates that the <code>height</code> variable in both components <code>A</code> and <code>B</code> refer to the same object reference. When <code>height.value</code> is changed to <code>110</code> in component <code>B</code>, the change is also reflected in the <code>height</code> variable in component <code>A</code>.</p>
<p>Now that we understand what props and state are in Svelte, let’s talk about bindings next.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Understanding bindings</h1>
<p>Bindings in Svelte allow <a id="_idIndexMarker090"/>you to keep the value of a component’s state in sync with the value of an <code>&lt;input /&gt;</code> element. If the state changes, the input updates; conversely, if the input changes, the state updates as well.</p>
<p>The following code snippet is an example of creating a binding in Svelte:</p>
<pre class="source-code">
&lt;script&gt;
  let name = "John";
&lt;/script&gt;
&lt;input bind:value={name} /&gt;</pre> <p>Bindings are created through the <code>bind:</code> directive. In the preceding code snippet, the input element’s value is bound to the <code>name</code> variable. When you type in the input, the <code>name</code> variable will update automatically. Conversely, when you change the value of the <code>name</code> variable, the input element’s value will also automatically update.</p>
<p>As demonstrated, bindings create a two-way data flow, enabling data changes to propagate from the element to the component state, and from the component state into the element.</p>
<p>The previous example demonstrates binding on elements, but bindings can also work on components. You <a id="_idIndexMarker091"/>can use the <code>bind:</code> directive to link the props of a component with your component’s state, as shown in the following code:</p>
<pre class="source-code">
&lt;script&gt;
  import Profile from './Profile.svelte';
  let name = "John";
&lt;/script&gt;
&lt;Profile bind:username={name} /&gt;</pre> <p>In the preceding code snippet, we bind the <code>username</code> props of the <code>&lt;Profile&gt;</code> component to the <code>name</code> state variable. When you update the <code>name</code> state variable, the value of the <code>username</code> prop will automatically reflect the new value; conversely, if you update the value of the <code>username</code> prop from within the <code>&lt;Profile&gt;</code> component, the value of the <code>name</code> state variable will automatically update to match.</p>
<p>To further demonstrate this behavior, let’s make a slight modification to the code. Here’s the updated version of the component:</p>
<pre class="source-code">
&lt;script&gt;
  import Profile from './Profile.svelte';
  let name = "John";
&lt;/script&gt;
<strong class="bold">&lt;p&gt;Name from App: {name}&lt;/p&gt;</strong>
&lt;Profile bind:username={name} /&gt;
<code>&lt;p&gt;</code> element and a <code>&lt;button&gt;</code> element. The <code>&lt;p&gt;</code> element shows the value of the <code>name</code> state variable, and the <code>&lt;button&gt;</code> element, when clicked, updates the value of the <code>name</code> state variable to <code>Svelte</code>. Due to the binding, when the button is clicked, it will also update the <code>username</code> props in the <code>&lt;</code><code>Profile&gt;</code> component.</p>
<p>Here’s the updated version of the <code>&lt;</code><code>Profile&gt;</code> component:</p>
<pre class="source-code">
&lt;script&gt;
  export let username;
&lt;/script&gt;
&lt;p&gt;Name in Profile: {username}&lt;/p&gt;
&lt;button on:click={() =&gt; username = "World"}&gt;Update from Profile&lt;/button&gt;</pre> <p>In this code snippet, we <a id="_idIndexMarker092"/>are looking at the <code>&lt;Profile&gt;</code> component. This component receives a prop called <code>username</code>, whose value is displayed inside a <code>&lt;p&gt;</code> element. We’ve also added a button, and when clicked, it will update the value of the <code>username</code> prop to <code>"World"</code>.</p>
<p>Because of the binding we established in the parent component, any change to the <code>username</code> prop in this <code>&lt;Profile&gt;</code> component will also update the <code>name</code> state variable in the parent component.</p>
<p>Indeed, if you click on the button in the parent component, both the <code>name</code> state variable in the parent component and the <code>username</code> prop in the <code>&lt;Profile&gt;</code> component will update to <code>"Svelte"</code>. On the other hand, if you click on the button in the <code>&lt;Profile&gt;</code> component, both the <code>name</code> state variable in the parent component and the <code>username</code> prop in the <code>&lt;Profile&gt;</code> component will change to <code>"World"</code>. This is the power of two-way binding in Svelte, allowing you to easily synchronize data between parent and child components.</p>
<p>When we talk about binding in Svelte, we often refer to <em class="italic">two-way data binding</em>. But what exactly does <em class="italic">two-way</em> mean? And is there such a thing as <em class="italic">one-way</em> data binding? Let’s delve deeper into the concept of data flow to clarify these terms.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>One-way versus two-way data flow</h1>
<p>When you <a id="_idIndexMarker093"/>pass data from one component to <a id="_idIndexMarker094"/>another component either through props or binding, data flows from one component to another component. The term data flow refers to how data is passed or transmitted between components or elements within a web application.</p>
<p>Understanding data flow is important when designing an application’s architecture, as it helps to establish clear lines of communication between components and determine how information is shared and updated throughout the system.</p>
<p>Data flow <a id="_idIndexMarker095"/>can be unidirectional (one-way) or bidirectional (two-way), depending on how data is transferred between components.</p>
<p>In <a id="_idIndexMarker096"/>one-way data flow, data <a id="_idIndexMarker097"/>moves in a single direction, from a parent to a child component, or from a component to a DOM element. This unidirectional flow is achieved through component props or DOM element attributes.</p>
<p>For example, consider the following code snippets featuring two components, component <code>A</code> and component <code>B</code>.</p>
<p>In component <code>B</code>, we define a prop named <code>value</code>:</p>
<pre class="source-code">
&lt;!-- filename: B.svelte --&gt;
&lt;script&gt;
  export let value;
&lt;/script&gt;</pre> <p>In component <code>A</code>, we import component <code>B</code> and pass the value of a variable named <code>data</code> to the prop of component <code>B</code>:</p>
<pre class="source-code">
&lt;!-- filename: A.svelte --&gt;
&lt;script&gt;
  import B from './B.svelte';
  let data;
&lt;/script&gt;
&lt;B value={data} /&gt;</pre> <p>Here, the value of <code>data</code> in component <code>A</code> is passed to the <code>value</code> prop in component <code>B</code>, illustrating the data flow from component <code>A</code> to component <code>B</code>.</p>
<p>If you draw up the data flow in a diagram, this is what a one-way data flow looks like:</p>
<div><div><img alt="" height="181" role="presentation" src="img/B18887_03_1.jpg" width="334"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: One-way data flow</p>
<p>The <a id="_idIndexMarker098"/>boxes show the data state and value prop, and <a id="_idIndexMarker099"/>the arrow shows how changing one value will affect another.</p>
<p>In one-way data flow, changes to data in the parent component automatically propagate to the child component, but the reverse is not true.</p>
<p>Building on<a id="_idIndexMarker100"/> the example with component <code>A</code> and component <code>B</code>, if the value of the <code>data</code> variable in component <code>A</code> changes, this change would automatically update the <code>value</code> props in component <code>B</code>. However, any changes made directly to the <code>value</code> props in component <code>B</code> would not affect the <code>data</code> variable in component <code>A</code>. Data changes only flow from component <code>A</code> to component <code>B</code>, but not in the reverse direction.</p>
<p>Having a one-way data flow makes the application easier to reason about and debug, as data changes follow a predictable path. For example, when the <code>data</code> variable in component <code>A</code> changes unexpectedly, isolating the issue becomes more straightforward. Because of the one-way data flow, we know that any changes to the <code>data</code> variable in component <code>A</code> will only originate from component <code>A</code>, not from component <code>B</code>.</p>
<p>On the other hand, two-way data flow <a id="_idIndexMarker101"/>allows data to flow in both directions, enabling automatic updates between the parent and child components, or between a component and DOM elements. Two-way data flow in Svelte is achieved through component or DOM element bindings.</p>
<p>For example, consider the following code snippets featuring two components, component <code>C</code> and component <code>D</code>.</p>
<p>In component <code>D</code>, we define a prop named <code>value</code>:</p>
<pre class="source-code">
&lt;!-- filename: D.svelte --&gt;
&lt;script&gt;
  export let value;
&lt;/script&gt;</pre> <p>In <a id="_idIndexMarker102"/>component <code>C</code>, we import component <code>D</code> and <a id="_idIndexMarker103"/>bind the value of a variable named <code>data</code> to the prop of component <code>D</code>:</p>
<pre class="source-code">
&lt;!-- filename: C.svelte --&gt;
&lt;script&gt;
  import D from './D.svelte';
  let data;
&lt;/script&gt;
&lt;D bind:value={data} /&gt;</pre> <p>Here, the<a id="_idIndexMarker104"/> value of <code>data</code> in component <code>C</code> is bound to the <code>value</code> prop in component <code>D</code>, illustrating the two-way data flow between component <code>C</code> to component <code>D</code>.</p>
<p>Here is a diagram showing how the data flows in a two-way data flow:</p>
<div><div><img alt="" height="181" role="presentation" src="img/B18887_03_2.jpg" width="334"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Two-way data flow</p>
<p>In a two-way data flow, when you change the data in the parent component, the child component is automatically updated; conversely, changing the data in the child component automatically updates the parent.</p>
<p>Building <a id="_idIndexMarker105"/>on the example with component <code>C</code> and component <code>D</code>, if the value of the <code>data</code> variable in component <code>C</code> changes, this change would automatically update the <code>value</code> props in component <code>D</code>. Conversely, unlike one-way data flow, any changes made directly to the <code>value</code> props in component <code>D</code> would update the <code>data</code> variable in component <code>C</code>. Data changes flow from component <code>C</code> to component <code>D</code> as well as from component <code>D</code> to component <code>C</code>.</p>
<p>While<a id="_idIndexMarker106"/> this bidirectional flow of data can make it <a id="_idIndexMarker107"/>easier to keep data in different components synchronized, it can also introduce complexity and make the application harder to debug, since data changes can originate from multiple sources.</p>
<p>For example, when the <code>data</code> variable in component <code>C</code> changes unexpectedly, isolating the issue becomes more complex. Because of two-way data flow, any changes to the <code>data</code> variable in component <code>C</code> could originate from component <code>C</code>, as well as from component <code>D</code>. This complexity can escalate further if the <code>value</code> prop of component <code>D</code> is also bound to the prop of another component.</p>
<p>In summary, one-way data flow offers predictability and easier debugging, while two-way data flow makes it much easier to synchronize data across multiple components but at the cost of added complexity.</p>
<p>Now that we’ve delved into both one-way and two-way data flows via props, let’s explore how to create state variables that derive their values from props.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Deriving states from props with a reactive declaration</h1>
<p>It’s <a id="_idIndexMarker108"/>common in Svelte to create new<a id="_idIndexMarker109"/> state variables based on the values of props.</p>
<p>For<a id="_idIndexMarker110"/> instance, a <code>&lt;DateLabel /&gt;</code> component might accept a <code>date</code> value as a prop and display a formatted date inside a <code>&lt;label&gt;</code> element. To use the <code>&lt;DateLabel&gt;</code> component, you might write the following:</p>
<pre class="source-code">
&lt;DateLabel date={new Date(2023,5,5)} /&gt;</pre> <p>To display<a id="_idIndexMarker111"/> the date as formatted text, you could first define a variable named <code>label</code>, deriving its value from the <code>date</code> prop:</p>
<pre class="source-code">
&lt;!-- filename: DateLabel.svelte --&gt;
&lt;script&gt;
  export let date;
  // Deriving the 'label' variable from the 'date' prop
  let label = date.toLocaleDateString();
&lt;/script&gt;
&lt;label&gt;{label}&lt;/label&gt;</pre> <p>In this<a id="_idIndexMarker112"/> code snippet, we defined a variable called <code>label</code> and derived its value from the <code>date</code> prop using the <code>toLocaleDateString()</code> method. This variable is then used inside a <code>&lt;label&gt;</code> element to display the formatted date.</p>
<p>In the preceding <a id="_idIndexMarker113"/>code snippet, the <code>label</code> variable is initialized when the <code>&lt;DateLabel&gt;</code> component is first created. However, if the <code>date</code> prop changes after the component has been initialized, the <code>label</code> variable won’t update to reflect the new value. This is not the intended behavior, as the <code>&lt;DateLabel&gt;</code> component should always display the most up-to-date formatted date based on the latest <code>date</code> prop.</p>
<p>To solve this issue, you can use Svelte’s reactive declarations to keep the <code>label</code> variable updated whenever the <code>date</code> prop changes.</p>
<p>Svelte’s reactive declarations utilize a special <code>$:</code> syntax to mark a statement as reactive. This means that whenever the variables used in that statement change, the statement itself will be re-run.</p>
<p>Let’s modify our component code to use Svelte’s reactive declaration:</p>
<pre class="source-code">
&lt;!-- filename: DateLabel.svelte --&gt;
&lt;script&gt;
  export let date;
  // Deriving the 'label' variable from the 'date' prop
  <strong class="bold">$: label = date.toLocaleDateString();</strong>
&lt;/script&gt;</pre> <p>In this <a id="_idIndexMarker114"/>code snippet, by modifying the declaration of <code>label</code> to a reactive declaration, the component will automatically re-compute the <code>label</code> variable whenever the <code>date</code> prop is modified, ensuring that the <code>&lt;DateLabel&gt;</code> component is always displaying the most current formatted date.</p>
<p>So, how does Svelte know when a reactive declaration statement should be re-run?</p>
<p>Svelte <a id="_idIndexMarker115"/>re-runs a reactive declaration <a id="_idIndexMarker116"/>statement whenever any of its dependent variables change. The Svelte compiler identifies these dependencies by analyzing the statement.</p>
<p>For example, in the reactive declaration <code>$: label = date.toLocaleDateString();</code>, Svelte recognizes that the dependency for this statement is the <code>date</code> variable. Therefore, whenever the <code>date</code> changes, the statement will re-run and update the value of the <code>label</code> variable.</p>
<p>A good rule of thumb for identifying dependencies in a reactive declaration is to look for any variable on the right side of the equal sign (<code>=</code>). These variables are considered dependencies of the reactive declaration.</p>
<p>You can include multiple dependencies within a single reactive declaration. For instance, let’s say we want to add a new <code>locale</code> prop to the <code>&lt;DateLabel&gt;</code> component. To use this new prop, you might write something like this:</p>
<pre class="source-code">
&lt;DateLabel date={new Date(2023, 5, 5)} locale="de-DE" /&gt;</pre> <p>In this code snippet, we pass in a new <code>locale</code> prop with the value <code>de-DE</code> to format the date in German. To accommodate this new <code>locale</code> prop, we’ll need to modify our <code>&lt;DateLabel&gt;</code> component as follows:</p>
<pre class="source-code">
&lt;script&gt;
  export let date;
  <strong class="bold">export let locale;</strong>
  <strong class="bold">// Reactive declaration with multiple dependencies</strong>
  <strong class="bold">$: label = date.toLocaleDateString(locale);</strong>
&lt;/script&gt;
&lt;label&gt;{label}&lt;/label&gt;</pre> <p>In this <a id="_idIndexMarker117"/>updated code, the reactive declaration <code>$: label = date.toLocaleDateString(locale);</code> now has two dependencies: <code>date</code> and <code>locale</code>. Svelte <a id="_idIndexMarker118"/>will automatically re-run this statement whenever either of these variables changes, ensuring <a id="_idIndexMarker119"/>that the <code>label</code> value stays up to date with the latest <code>date</code> and <code>locale</code> props.</p>
<p>Now that we’ve covered the basics of props, bindings, states, and derived states, it’s crucial to note that as components become more complex, managing these elements can quickly become overwhelming. In the next section, we’ll explore some tips for effectively managing complex derived states to keep them manageable.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Managing complex derived states</h1>
<p>As your <a id="_idIndexMarker120"/>Svelte application grows more complex, it will likely involve a greater number of interconnected components with multiple props and derived states. When dealing with this complexity, tracking updates and changes can become a complex task. Each prop or state change can affect other parts of your component, making it challenging to manage and predict how your component will behave.</p>
<p>To make this easier, here are some guidelines to consider:</p>
<ul>
<li><em class="italic">Maintain one-way data flow for </em><em class="italic">derived states</em><p class="list-inset">While it’s possible to derive state from props and other states, it’s crucial to maintain a one-way data flow to simplify both debugging and understanding. Consider the following Svelte example:</p><pre class="source-code">
&lt;script&gt;
  export let valueA;
  export let valueB;
  $: valueC = valueA + 5;
  $: valueD = valueB + valueC;
  $: valueC = Math.min(valueC, valueD / 2);
&lt;/script&gt;
Upon observing the data flow, we can see that <code>valueC</code> depends on <code>valueA</code>, <code>valueD</code> depends on both <code>valueB</code> and <code>valueC</code>, and then <code>valueC</code> in turn depends on <code>valueD</code>. Consequently, it’s unclear how <code>valueC</code> is actually calculated, it could be either <code>valueA + 5</code> or the minimum of <code>valueC</code> and <code>valueD / 2</code>. Such complexity makes the code hard to understand and increases the likelihood of bugs.</pre></li> <li><em class="italic">Group similar </em><em class="italic">logic together</em><p class="list-inset">Consider this tip a stylistic suggestion. When dealing with multiple reactive declarations, it’s beneficial to group those that are related together. Utilize blank lines to create a visual separation between unrelated reactive declarations. This not only improves readability but also aids in code maintenance.</p><p class="list-inset">It is worth noting that the Svelte compiler takes care of execution order based on dependencies regardless of how you arrange your declarations. For example, the following two code snippets will behave identically due to Svelte’s handling of dependencies:</p><pre class="source-code">
&lt;script&gt;
  export let a;
  $: b = a * 2;
  $: c = b * 2;
&lt;/script&gt;
b</strong> is declared reactively before <code>c</code>. However, it behaves identically to the following snippet, where <code>c</code> is declared before <code>b</code>. Let’s look at the next one:</pre><pre class="source-code">&lt;script&gt;
  export let a;
  $: c = b * 2;
  $: b = a * 2;
&lt;/script&gt;</pre><p class="list-inset">The Svelte compiler analyzes the dependencies of each declaration and executes them in the correct order. In this case, it evaluates <code>b = a * 2</code> before <code>c = b * 2</code> since the latter depends on the value of <code>b</code>, established by the former declaration.</p></li> <li><em class="italic">Avoid reassigning </em><em class="italic">props directly</em><p class="list-inset">It might be tempting to modify the value of a prop directly, especially when you want to transform its value or provide a default fallback. For example, you might consider writing something like this to set a default value for an undefined prop:</p><pre class="source-code">
&lt;script&gt;
  export let data;
  $: data = data ?? 100;
&lt;/script&gt;
Instead, it’s better to declare a new state variable to manage this behavior:</pre><pre class="source-code">&lt;script&gt;
  export let data;
  $: dataWithDefault = data ?? 100;
&lt;/script&gt;</pre><p class="list-inset">In this<a id="_idIndexMarker123"/> improved example, we introduce a new variable, <code>dataWithDefault</code>, which takes on either the value of the <code>data</code> prop or a default value of <code>100</code> if <code>data</code> is undefined. This approach makes the component’s behavior more transparent and easier to debug.</p></li> <li><em class="italic">Be cautious when updating </em><em class="italic">derived states</em><p class="list-inset">Modifying a derived state directly can introduce inconsistencies, particularly when that state is based on props or other state variables.</p><p class="list-inset">Consider the following example:</p><pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
&lt;/script&gt;
&lt;input bind:value={double} type="number" /&gt;
&lt;input bind:value={triple} type="number" /&gt;</pre><p class="list-inset">In this example, we have a single prop named <code>value</code> and two derived states, <code>double</code> and <code>triple</code>, which are two and three times the value of the <code>value</code> prop respectively. The component features two input boxes, each bound to <code>double</code> and <code>triple</code> using two-way binding.</p><p class="list-inset">Here, <code>triple</code> can be modified in two ways: either by updating the <code>value</code> prop, which will keep <code>triple</code> at three times the value of <code>value</code>, or by directly changing the value in the input box, thereby directly altering <code>triple</code>.</p><p class="list-inset">If you type<a id="_idIndexMarker124"/> into the input box bound to <code>triple</code>, you’ll find that its value diverges from being strictly three times the <code>value</code> prop. This inconsistency arises because <code>triple</code> is now subject to changes from multiple sources, causing it to go <em class="italic">out of sync</em> with the original <code>value</code>.</p><p class="list-inset">If you were to map out a diagram illustrating the data flow between <code>value</code> <code>double</code> and <code>triple</code>, you’d get the following diagram:</p></li> </ul>
<div><div><img alt="" height="466" role="presentation" src="img/B18887_03_3.jpg" width="705"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Data flows between props, states, and the input elements</p>
<p class="list-inset">Notice that both <code>double</code> and <code>triple</code> have two incoming arrows, suggesting multiple pathways for changing their values. Conversely, <code>value</code> has no incoming arrows, indicating that modifying <code>triple</code> alone would cause <code>value</code> and <code>double</code> to go out of sync.</p>
<p class="list-inset">Therefore, it is recommended to refrain from manually updating derived states, as this complicates debugging and makes the component’s behavior harder to reason about.</p>
<p class="list-inset">If you <a id="_idIndexMarker125"/>wish to modify the input while maintaining the synchrony between <code>value</code>, <code>double</code>, and <code>triple</code>, a solution will be discussed in the following section.</p>
<p>By keeping these tips in mind, you can better manage complex derived states and make your components more maintainable and easier to understand.</p>
<p>In our last tip, we highlighted that updating the derived states can lead to inconsistencies between states and props and noted that there’s a solution to modify the input while keeping everything in sync. That solution is what we will explore next.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Updating props using derived states</h1>
<p>In an attempt <a id="_idIndexMarker126"/>to synchronize the <code>value</code> prop <a id="_idIndexMarker127"/>with changes to the input bound to <code>triple</code>, one might be tempted to add another reactive declaration. This declaration would update the <code>value</code> prop to be one-third of <code>triple</code> whenever <code>triple</code> changes. Here is the proposed modification:</p>
<pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
<strong class="bold">  $: value = double / 2;</strong>
<strong class="bold">  $: value = triple / 3;</strong>
&lt;/script&gt;
&lt;input bind:value={double} type="number" /&gt;
&lt;input bind:value={triple} type="number" /&gt;</pre> <p>As we discussed earlier, it’s best practice to maintain a one-way data flow for derived states to simplify debugging and data management. Indeed, the Svelte compiler flags the preceding code snippet for cyclical dependencies. This is because <code>double</code> is derived from <code>value</code>, and <code>value</code> is in turn dependent on <code>double</code>.</p>
<p>However, Svelte’s compiler determines dependency relationships based solely on the reactive <a id="_idIndexMarker128"/>declarations. By refactoring the code to make <a id="_idIndexMarker129"/>these relationships less obvious, you can bypass the compiler’s cyclical dependency check. Here’s a refactored version of the code that does just that:</p>
<pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
<strong class="bold">  $: updateValueFromDouble(double);</strong>
<strong class="bold">  $: updateValueFromTriple(triple);</strong>
<strong class="bold">  function updateValueFromDouble(double) {</strong>
<strong class="bold">    value = double / 2;</strong>
<strong class="bold">  }</strong>
<strong class="bold">  function updateValueFromTriple(triple) {</strong>
<strong class="bold">    value = triple / 3;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
&lt;input bind:value={double} type="number" /&gt;
&lt;input bind:value={triple} type="number" /&gt;</pre> <p>In the provided code snippet, we’ve shifted the equations <code>value = double / 2</code> and <code>value = triple / 3</code> into separate functions named <code>updateValueFromDouble</code> and <code>updateValueFromTriple</code>. This change lets us evade Svelte’s compiler warning about cyclical dependencies.</p>
<p>However, there’s a catch. If you try altering the <code>triple</code> input, it updates <code>value</code> but doesn’t refresh <code>double</code>. This happens because Svelte avoids infinite update loops. Changing <code>triple</code> would set off a chain reaction—updating <code>value</code>, then <code>double</code>, then back to <code>value</code>, and so on.</p>
<p>This is <a id="_idIndexMarker130"/>how <a id="_idIndexMarker131"/>the data flow looks right now:</p>
<div><div><img alt="" height="466" role="presentation" src="img/B18887_03_4.jpg" width="705"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Data flows between props, states, and the input elements</p>
<p>As you can see in the diagram, we update the value of <code>value</code>, <code>double</code>, and <code>triple</code> through reactive declarations, creating a loop in the data flow, indicated by the bold arrows.</p>
<p>Therefore, using derived states to update their original properties via reactive declarations isn’t advisable.</p>
<p>A better approach to keep <code>value</code>, <code>double</code>, and <code>triple</code> in sync is to establish value as the single source of truth. Since both <code>double</code> and <code>triple</code> are derived from <code>value</code>, any changes to the input should first update <code>value</code>. This, in turn, triggers the reactive declarations to automatically recalculate <code>double</code> and <code>triple</code>.</p>
<p>Here’s the updated code:</p>
<pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
  function updateValueFromDouble(double) {
    value = double / 2;
  }
  function updateValueFromTriple(triple) {
    value = triple / 3;
  }
&lt;/script&gt;
&lt;input <strong class="bold">value={double}</strong> type="number" <strong class="bold">on:change={e =&gt; updateValueFromDouble(e.target.value)}</strong> /&gt;
&lt;input <code>value</code> as the sole source of truth. Instead of binding the input elements directly to <code>double</code> and <code>triple</code>, we’ve added event listeners that update <code>value</code> based on user input. This change automatically updates <code>double</code> and <code>triple</code> through reactive declarations, which then refresh the displayed values in the input fields.</p>
<p>With the updated code, the data flow is now streamlined, as shown in the following diagram:</p>
<div><div><img alt="" height="466" role="presentation" src="img/B18887_03_5.jpg" width="693"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Data flows between props, states, and the input elements</p>
<p>The <a id="_idIndexMarker134"/>values for <code>double</code> and <code>triple</code> are directly derived from <code>value</code>, which then populates <a id="_idIndexMarker135"/>the input fields. When you modify the input, it alters <code>value</code> directly, which in turn automatically updates both <code>double</code> and <code>triple</code>, as well as the input fields themselves.</p>
<p>So, this is how you maintain synchronized states for <code>value</code>, <code>double</code>, and <code>triple</code>, by focusing on the data flow and keeping a single source of truth.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Summary</h1>
<p>Understanding how to handle props and state effectively is crucial for creating robust Svelte apps. This chapter has shown you how Svelte uses props, bindings, and reactive declarations to facilitate data passing and state changes across components.</p>
<p>It’s crucial to keep an eye on data flow within a component. Having a unified and organized data flow makes the code easier to follow and debug. Good data management paves the way for building more intricate and dynamic apps with ease.</p>
<p>In the next chapter, we’ll explore how to compose Svelte components to construct more complex applications.</p>
</div>
</div></body></html>