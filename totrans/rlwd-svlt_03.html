<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor051"/>3</h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Managing Props and State</h1>
<p>In the world of web development, managing data effectively is crucial. Whether it’s the information that flows between components or the internal state of a component, proper data management is the backbone of a functional and responsive <span class="No-Break">web application.</span></p>
<p>In this chapter, we will delve into the core concepts of managing props and state within a Svelte application. First, we’ll clarify what props and states in Svelte are, laying the groundwork for understanding more advanced topics. We then explore the concept of bindings, a feature in Svelte for keeping state and element values or component props <span class="No-Break">in sync.</span></p>
<p>We’ll then explore data flow within components, highlighting the differences between one-way data flow and two-way data flow and why they matter. Moving on, we’ll discuss how to derive state from props using Svelte’s reactive declarations. To conclude, we’ll offer tips for managing complex derived states and explain how to update props based on those <span class="No-Break">derived states.</span></p>
<p>By the end of the chapter, you’ll have a solid understanding of how to manage data within a Svelte component, being equipped with practical tips and strategies to tackle common <span class="No-Break">challenges effectively.</span></p>
<p>In this chapter, you will learn <span class="No-Break">the following:</span></p>
<ul>
<li>Defining props <span class="No-Break">and state</span></li>
<li><span class="No-Break">Understanding bindings</span></li>
<li>One-way versus two-way <span class="No-Break">data flow</span></li>
<li>Deriving states from props with a <span class="No-Break">reactive declaration</span></li>
<li>Managing complex <span class="No-Break">derived states</span></li>
<li>Updating props using <span class="No-Break">derived states</span></li>
</ul>
<p>Before we start to talk about props and state, let’s first define what props and state are <span class="No-Break">in Svelte.</span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Technical requirements</h1>
<p>You can find all the code samples used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03</span></a></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Defining props and state</h1>
<p>In Svelte, both props and state are used to manage data within components. Props are a way to pass data from a parent component to a child component. This makes the child component flexible and reusable, as it can get different data from the parent <span class="No-Break">as needed.</span></p>
<p>On the other hand, state is data that is initialized and managed internally within a component, unlike props, which are received from an external source. State allows a component to be self-contained <span class="No-Break">and modular.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Defining props</h2>
<p>Let’s start with props. Props<a id="_idIndexMarker080"/> in Svelte are defined using the <strong class="source-inline">export</strong> keyword. When you export a variable in a Svelte component, it becomes a prop that you can pass data to from a <span class="No-Break">parent component.</span></p>
<p>Here is a <span class="No-Break">simple example:</span></p>
<pre class="source-code">
&lt;!-- file: Child.svelte --&gt;
&lt;script&gt;
  export let message;
&lt;/script&gt;
&lt;h1&gt;{message}&lt;/h1&gt;</pre> <p>In the preceding code snippet, we defined a Svelte component in a file named <strong class="source-inline">Child.svelte</strong>. In the Svelte component, <strong class="source-inline">message</strong> is a prop. You can pass data to <strong class="source-inline">message</strong> from a parent component <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;!-- file: Parent.svelte --&gt;
&lt;script&gt;
  import Child from './Child.svelte';
&lt;/script&gt;
&lt;Child message="Hello, World!" /&gt;</pre> <p>In the preceding code snippet, we define another Svelte component in a file named <strong class="source-inline">Parent.svelte</strong>. In the component, we import and use the <strong class="source-inline">Child</strong> component from <strong class="source-inline">Child.svelte</strong>. As the <strong class="source-inline">Parent</strong> component includes the <strong class="source-inline">Child</strong> component, the <strong class="source-inline">Parent</strong> component is considered the parent component of the imported <span class="No-Break"><strong class="source-inline">Child</strong></span><span class="No-Break"> component.</span></p>
<p>In the parent <a id="_idIndexMarker081"/>component, you can set the <strong class="source-inline">message</strong> props of the child component to the value <strong class="source-inline">"Hello, World!"</strong> by passing <strong class="source-inline">"Hello, World!"</strong> through the <strong class="source-inline">message</strong> attribute of the <strong class="source-inline">&lt;Child /&gt;</strong> component, as shown in the preceding <span class="No-Break">code snippet.</span></p>
<p>In summary, props are defined using the <strong class="source-inline">export</strong> keyword, and their values are passed from the parent component to the <span class="No-Break">child component.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Defining state</h2>
<p>Next, let’s look at <a id="_idIndexMarker082"/>the state. State is any data that is used and managed within a component. It is not passed in from a parent component like props. Instead, it is defined within the <span class="No-Break">component itself.</span></p>
<p>Here’s an example that <span class="No-Break">illustrates state:</span></p>
<pre class="source-code">
&lt;!-- file: Counter.svelte --&gt;
&lt;script&gt;
  let count = 0;
  function increment() {
    count += 1;
  }
&lt;/script&gt;
&lt;button on:click={increment}&gt;Click me&lt;/button&gt;
&lt;p&gt;{count}&lt;/p&gt;</pre> <p>In this example, <strong class="source-inline">count</strong> is a state variable. It’s not passed in as a prop but is defined and managed within the <strong class="source-inline">Counter</strong> component. When you click the button, the <strong class="source-inline">increment</strong> function is called, which <a id="_idIndexMarker083"/>modifies the <span class="No-Break"><strong class="source-inline">count</strong></span><span class="No-Break"> state.</span></p>
<p>In summary, props are variables that are passed into a component from a parent component, whereas the state is data that is managed within a <span class="No-Break">component itself.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Props versus state</h2>
<p>If you <a id="_idIndexMarker084"/>look closely, both props and state represent data. The difference <a id="_idIndexMarker085"/>between them depends on the context of the component you <span class="No-Break">are considering.</span></p>
<p>For example, let’s consider two components, component <strong class="source-inline">A</strong> and <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">.</span></p>
<p>Let’s begin with <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;!-- A.svelte --&gt;
&lt;script&gt;
  export let height;
&lt;/script&gt;</pre> <p>In component <strong class="source-inline">A</strong>, we define a props <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">height</strong></span><span class="No-Break">.</span></p>
<p>Now take a look at <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;!-- B.svelte --&gt;
&lt;script&gt;
  import A from './A.svelte';
  let height = 0;
&lt;/script&gt;
&lt;A height={height} /&gt;</pre> <p>In component <strong class="source-inline">B</strong>, we define a state called <strong class="source-inline">height</strong> and pass its value as a prop to <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">.</span></p>
<p>From the perspective of component <strong class="source-inline">B</strong>, <strong class="source-inline">height</strong> is considered a state, but from the viewpoint of component <strong class="source-inline">A</strong>, it’s considered a prop. Whether a variable is a prop or a state depends on the context of the component in which it is being viewed. At their core, they are essentially the <span class="No-Break">same thing.</span></p>
<p>In this <a id="_idIndexMarker086"/>example, due to the way JavaScript passes primitive variables by value, it may not be immediately obvious that the <strong class="source-inline">height</strong> variable in both component <strong class="source-inline">A</strong> and component <strong class="source-inline">B</strong> refers to the <span class="No-Break">same thing.</span></p>
<p>However, if we define an object as state and pass it to another component through props, it becomes clear that both the state in one component and the props in the other component refer to the same <span class="No-Break">object reference.</span></p>
<p>Let’s modify our example to illustrate <span class="No-Break">this point:</span></p>
<pre class="source-code">
&lt;!-- A.svelte --&gt;
&lt;script&gt;
  export let height;
  <strong class="bold">setInterval(() =&gt; console.log('A:', height), 1000);</strong>
&lt;/script&gt;
&lt;!-- B.svelte --&gt;
&lt;script&gt;
  import A from './A.svelte';
  <strong class="bold">let height = { value: 100 };</strong>
  <strong class="bold">setInterval(() =&gt; console.log('B:', height), 1000);</strong>
&lt;/script&gt;
&lt;A height={height} /&gt;</pre> <p>In this code <a id="_idIndexMarker087"/>snippet, I’ve added a <strong class="source-inline">setInterval</strong> function to print out the value of the <strong class="source-inline">height</strong> variable every second in both components. In component <strong class="source-inline">B</strong>, I’ve modified the state <strong class="source-inline">height</strong> to be an object. Because objects in JavaScript are passed by reference, the state <strong class="source-inline">height</strong> in component <strong class="source-inline">B</strong> that is passed as a prop to component <strong class="source-inline">A</strong> is passed by reference as well. This means the <strong class="source-inline">height</strong> prop in component <strong class="source-inline">A</strong> is referencing the same object as the state <strong class="source-inline">height</strong> in <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">.</span></p>
<p>If we add a <strong class="source-inline">&lt;button&gt;</strong> element in component <strong class="source-inline">B</strong> to mutate the <strong class="source-inline">height</strong> object, as shown here, you’ll be able to see that both component <strong class="source-inline">A</strong> and component <strong class="source-inline">B</strong> print out the same updated value of the <strong class="source-inline">height</strong> variable in the console. This is because they are printing out the value of the same <span class="No-Break">object reference:</span></p>
<pre class="source-code">
&lt;button on:click={() =&gt; { height.value += 10; }} /&gt;</pre> <p>Clicking on <a id="_idIndexMarker088"/>the button from the preceding code snippet will result in the <a id="_idIndexMarker089"/>console printing out <strong class="source-inline">A: { value: 110 }</strong> and <strong class="source-inline">B: { value: 110 }</strong>. This demonstrates that the <strong class="source-inline">height</strong> variable in both components <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> refer to the same object reference. When <strong class="source-inline">height.value</strong> is changed to <strong class="source-inline">110</strong> in component <strong class="source-inline">B</strong>, the change is also reflected in the <strong class="source-inline">height</strong> variable in <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">.</span></p>
<p>Now that we understand what props and state are in Svelte, let’s talk about <span class="No-Break">bindings next.</span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Understanding bindings</h1>
<p>Bindings in Svelte allow <a id="_idIndexMarker090"/>you to keep the value of a component’s state in sync with the value of an <strong class="source-inline">&lt;input /&gt;</strong> element. If the state changes, the input updates; conversely, if the input changes, the state updates <span class="No-Break">as well.</span></p>
<p>The following code snippet is an example of creating a binding <span class="No-Break">in Svelte:</span></p>
<pre class="source-code">
&lt;script&gt;
  let name = "John";
&lt;/script&gt;
&lt;input bind:value={name} /&gt;</pre> <p>Bindings are created through the <strong class="source-inline">bind:</strong> directive. In the preceding code snippet, the input element’s value is bound to the <strong class="source-inline">name</strong> variable. When you type in the input, the <strong class="source-inline">name</strong> variable will update automatically. Conversely, when you change the value of the <strong class="source-inline">name</strong> variable, the input element’s value will also <span class="No-Break">automatically update.</span></p>
<p>As demonstrated, bindings create a two-way data flow, enabling data changes to propagate from the element to the component state, and from the component state into <span class="No-Break">the element.</span></p>
<p>The previous example demonstrates binding on elements, but bindings can also work on components. You <a id="_idIndexMarker091"/>can use the <strong class="source-inline">bind:</strong> directive to link the props of a component with your component’s state, as shown in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Profile from './Profile.svelte';
  let name = "John";
&lt;/script&gt;
&lt;Profile bind:username={name} /&gt;</pre> <p>In the preceding code snippet, we bind the <strong class="source-inline">username</strong> props of the <strong class="source-inline">&lt;Profile&gt;</strong> component to the <strong class="source-inline">name</strong> state variable. When you update the <strong class="source-inline">name</strong> state variable, the value of the <strong class="source-inline">username</strong> prop will automatically reflect the new value; conversely, if you update the value of the <strong class="source-inline">username</strong> prop from within the <strong class="source-inline">&lt;Profile&gt;</strong> component, the value of the <strong class="source-inline">name</strong> state variable will automatically update <span class="No-Break">to match.</span></p>
<p>To further demonstrate this behavior, let’s make a slight modification to the code. Here’s the updated version of <span class="No-Break">the component:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Profile from './Profile.svelte';
  let name = "John";
&lt;/script&gt;
<strong class="bold">&lt;p&gt;Name from App: {name}&lt;/p&gt;</strong>
&lt;Profile bind:username={name} /&gt;
<strong class="bold">&lt;button on:click={() =&gt; name = "Svelte"}&gt;Update from App&lt;/button&gt;</strong></pre> <p>In this code snippet, we’ve added a <strong class="source-inline">&lt;p&gt;</strong> element and a <strong class="source-inline">&lt;button&gt;</strong> element. The <strong class="source-inline">&lt;p&gt;</strong> element shows the value of the <strong class="source-inline">name</strong> state variable, and the <strong class="source-inline">&lt;button&gt;</strong> element, when clicked, updates the value of the <strong class="source-inline">name</strong> state variable to <strong class="source-inline">Svelte</strong>. Due to the binding, when the button is clicked, it will also update the <strong class="source-inline">username</strong> props in the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Profile&gt;</strong></span><span class="No-Break"> component.</span></p>
<p>Here’s the updated version of the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Profile&gt;</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let username;
&lt;/script&gt;
&lt;p&gt;Name in Profile: {username}&lt;/p&gt;
&lt;button on:click={() =&gt; username = "World"}&gt;Update from Profile&lt;/button&gt;</pre> <p>In this code snippet, we <a id="_idIndexMarker092"/>are looking at the <strong class="source-inline">&lt;Profile&gt;</strong> component. This component receives a prop called <strong class="source-inline">username</strong>, whose value is displayed inside a <strong class="source-inline">&lt;p&gt;</strong> element. We’ve also added a button, and when clicked, it will update the value of the <strong class="source-inline">username</strong> prop <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"World"</strong></span><span class="No-Break">.</span></p>
<p>Because of the binding we established in the parent component, any change to the <strong class="source-inline">username</strong> prop in this <strong class="source-inline">&lt;Profile&gt;</strong> component will also update the <strong class="source-inline">name</strong> state variable in the <span class="No-Break">parent component.</span></p>
<p>Indeed, if you click on the button in the parent component, both the <strong class="source-inline">name</strong> state variable in the parent component and the <strong class="source-inline">username</strong> prop in the <strong class="source-inline">&lt;Profile&gt;</strong> component will update to <strong class="source-inline">"Svelte"</strong>. On the other hand, if you click on the button in the <strong class="source-inline">&lt;Profile&gt;</strong> component, both the <strong class="source-inline">name</strong> state variable in the parent component and the <strong class="source-inline">username</strong> prop in the <strong class="source-inline">&lt;Profile&gt;</strong> component will change to <strong class="source-inline">"World"</strong>. This is the power of two-way binding in Svelte, allowing you to easily synchronize data between parent and <span class="No-Break">child components.</span></p>
<p>When we talk about binding in Svelte, we often refer to <em class="italic">two-way data binding</em>. But what exactly does <em class="italic">two-way</em> mean? And is there such a thing as <em class="italic">one-way</em> data binding? Let’s delve deeper into the concept of data flow to clarify <span class="No-Break">these terms.</span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>One-way versus two-way data flow</h1>
<p>When you <a id="_idIndexMarker093"/>pass data from one component to <a id="_idIndexMarker094"/>another component either through props or binding, data flows from one component to another component. The term data flow refers to how data is passed or transmitted between components or elements within a <span class="No-Break">web application.</span></p>
<p>Understanding data flow is important when designing an application’s architecture, as it helps to establish clear lines of communication between components and determine how information is shared and updated throughout <span class="No-Break">the system.</span></p>
<p>Data flow <a id="_idIndexMarker095"/>can be unidirectional (one-way) or bidirectional (two-way), depending on how data is transferred <span class="No-Break">between components.</span></p>
<p>In <a id="_idIndexMarker096"/>one-way data flow, data <a id="_idIndexMarker097"/>moves in a single direction, from a parent to a child component, or from a component to a DOM element. This unidirectional flow is achieved through component props or DOM <span class="No-Break">element attributes.</span></p>
<p>For example, consider the following code snippets featuring two components, component <strong class="source-inline">A</strong> and <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">.</span></p>
<p>In component <strong class="source-inline">B</strong>, we define a prop <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;!-- filename: B.svelte --&gt;
&lt;script&gt;
  export let value;
&lt;/script&gt;</pre> <p>In component <strong class="source-inline">A</strong>, we import component <strong class="source-inline">B</strong> and pass the value of a variable named <strong class="source-inline">data</strong> to the prop of <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;!-- filename: A.svelte --&gt;
&lt;script&gt;
  import B from './B.svelte';
  let data;
&lt;/script&gt;
&lt;B value={data} /&gt;</pre> <p>Here, the value of <strong class="source-inline">data</strong> in component <strong class="source-inline">A</strong> is passed to the <strong class="source-inline">value</strong> prop in component <strong class="source-inline">B</strong>, illustrating the data flow from component <strong class="source-inline">A</strong> to <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">.</span></p>
<p>If you draw up the data flow in a diagram, this is what a one-way data flow <span class="No-Break">looks like:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="" height="181" role="presentation" src="image/B18887_03_1.jpg" width="334"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: One-way data flow</p>
<p>The <a id="_idIndexMarker098"/>boxes show the data state and value prop, and <a id="_idIndexMarker099"/>the arrow shows how changing one value will <span class="No-Break">affect another.</span></p>
<p>In one-way data flow, changes to data in the parent component automatically propagate to the child component, but the reverse is <span class="No-Break">not true.</span></p>
<p>Building on<a id="_idIndexMarker100"/> the example with component <strong class="source-inline">A</strong> and component <strong class="source-inline">B</strong>, if the value of the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">A</strong> changes, this change would automatically update the <strong class="source-inline">value</strong> props in component <strong class="source-inline">B</strong>. However, any changes made directly to the <strong class="source-inline">value</strong> props in component <strong class="source-inline">B</strong> would not affect the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">A</strong>. Data changes only flow from component <strong class="source-inline">A</strong> to component <strong class="source-inline">B</strong>, but not in the <span class="No-Break">reverse direction.</span></p>
<p>Having a one-way data flow makes the application easier to reason about and debug, as data changes follow a predictable path. For example, when the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">A</strong> changes unexpectedly, isolating the issue becomes more straightforward. Because of the one-way data flow, we know that any changes to the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">A</strong> will only originate from component <strong class="source-inline">A</strong>, not from <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">.</span></p>
<p>On the other hand, two-way data flow <a id="_idIndexMarker101"/>allows data to flow in both directions, enabling automatic updates between the parent and child components, or between a component and DOM elements. Two-way data flow in Svelte is achieved through component or DOM <span class="No-Break">element bindings.</span></p>
<p>For example, consider the following code snippets featuring two components, component <strong class="source-inline">C</strong> and <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">D</strong></span><span class="No-Break">.</span></p>
<p>In component <strong class="source-inline">D</strong>, we define a prop <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;!-- filename: D.svelte --&gt;
&lt;script&gt;
  export let value;
&lt;/script&gt;</pre> <p>In <a id="_idIndexMarker102"/>component <strong class="source-inline">C</strong>, we import component <strong class="source-inline">D</strong> and <a id="_idIndexMarker103"/>bind the value of a variable named <strong class="source-inline">data</strong> to the prop of <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">D</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;!-- filename: C.svelte --&gt;
&lt;script&gt;
  import D from './D.svelte';
  let data;
&lt;/script&gt;
&lt;D bind:value={data} /&gt;</pre> <p>Here, the<a id="_idIndexMarker104"/> value of <strong class="source-inline">data</strong> in component <strong class="source-inline">C</strong> is bound to the <strong class="source-inline">value</strong> prop in component <strong class="source-inline">D</strong>, illustrating the two-way data flow between component <strong class="source-inline">C</strong> to <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">D</strong></span><span class="No-Break">.</span></p>
<p>Here is a diagram showing how the data flows in a two-way <span class="No-Break">data flow:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="" height="181" role="presentation" src="image/B18887_03_2.jpg" width="334"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Two-way data flow</p>
<p>In a two-way data flow, when you change the data in the parent component, the child component is automatically updated; conversely, changing the data in the child component automatically updates <span class="No-Break">the parent.</span></p>
<p>Building <a id="_idIndexMarker105"/>on the example with component <strong class="source-inline">C</strong> and component <strong class="source-inline">D</strong>, if the value of the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">C</strong> changes, this change would automatically update the <strong class="source-inline">value</strong> props in component <strong class="source-inline">D</strong>. Conversely, unlike one-way data flow, any changes made directly to the <strong class="source-inline">value</strong> props in component <strong class="source-inline">D</strong> would update the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">C</strong>. Data changes flow from component <strong class="source-inline">C</strong> to component <strong class="source-inline">D</strong> as well as from component <strong class="source-inline">D</strong> to <span class="No-Break">component </span><span class="No-Break"><strong class="source-inline">C</strong></span><span class="No-Break">.</span></p>
<p>While<a id="_idIndexMarker106"/> this bidirectional flow of data can make it <a id="_idIndexMarker107"/>easier to keep data in different components synchronized, it can also introduce complexity and make the application harder to debug, since data changes can originate from <span class="No-Break">multiple sources.</span></p>
<p>For example, when the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">C</strong> changes unexpectedly, isolating the issue becomes more complex. Because of two-way data flow, any changes to the <strong class="source-inline">data</strong> variable in component <strong class="source-inline">C</strong> could originate from component <strong class="source-inline">C</strong>, as well as from component <strong class="source-inline">D</strong>. This complexity can escalate further if the <strong class="source-inline">value</strong> prop of component <strong class="source-inline">D</strong> is also bound to the prop of <span class="No-Break">another component.</span></p>
<p>In summary, one-way data flow offers predictability and easier debugging, while two-way data flow makes it much easier to synchronize data across multiple components but at the cost of <span class="No-Break">added complexity.</span></p>
<p>Now that we’ve delved into both one-way and two-way data flows via props, let’s explore how to create state variables that derive their values <span class="No-Break">from props.</span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Deriving states from props with a reactive declaration</h1>
<p>It’s <a id="_idIndexMarker108"/>common in Svelte to create new<a id="_idIndexMarker109"/> state variables based on the values <span class="No-Break">of props.</span></p>
<p>For<a id="_idIndexMarker110"/> instance, a <strong class="source-inline">&lt;DateLabel /&gt;</strong> component might accept a <strong class="source-inline">date</strong> value as a prop and display a formatted date inside a <strong class="source-inline">&lt;label&gt;</strong> element. To use the <strong class="source-inline">&lt;DateLabel&gt;</strong> component, you might write <span class="No-Break">the following:</span></p>
<pre class="source-code">
&lt;DateLabel date={new Date(2023,5,5)} /&gt;</pre> <p>To display<a id="_idIndexMarker111"/> the date as formatted text, you could first define a variable named <strong class="source-inline">label</strong>, deriving its value from the <span class="No-Break"><strong class="source-inline">date</strong></span><span class="No-Break"> prop:</span></p>
<pre class="source-code">
&lt;!-- filename: DateLabel.svelte --&gt;
&lt;script&gt;
  export let date;
  // Deriving the 'label' variable from the 'date' prop
  let label = date.toLocaleDateString();
&lt;/script&gt;
&lt;label&gt;{label}&lt;/label&gt;</pre> <p>In this<a id="_idIndexMarker112"/> code snippet, we defined a variable called <strong class="source-inline">label</strong> and derived its value from the <strong class="source-inline">date</strong> prop using the <strong class="source-inline">toLocaleDateString()</strong> method. This variable is then used inside a <strong class="source-inline">&lt;label&gt;</strong> element to display the <span class="No-Break">formatted date.</span></p>
<p>In the preceding <a id="_idIndexMarker113"/>code snippet, the <strong class="source-inline">label</strong> variable is initialized when the <strong class="source-inline">&lt;DateLabel&gt;</strong> component is first created. However, if the <strong class="source-inline">date</strong> prop changes after the component has been initialized, the <strong class="source-inline">label</strong> variable won’t update to reflect the new value. This is not the intended behavior, as the <strong class="source-inline">&lt;DateLabel&gt;</strong> component should always display the most up-to-date formatted date based on the latest <span class="No-Break"><strong class="source-inline">date</strong></span><span class="No-Break"> prop.</span></p>
<p>To solve this issue, you can use Svelte’s reactive declarations to keep the <strong class="source-inline">label</strong> variable updated whenever the <strong class="source-inline">date</strong> <span class="No-Break">prop changes.</span></p>
<p>Svelte’s reactive declarations utilize a special <strong class="source-inline">$:</strong> syntax to mark a statement as reactive. This means that whenever the variables used in that statement change, the statement itself will <span class="No-Break">be re-run.</span></p>
<p>Let’s modify our component code to use Svelte’s <span class="No-Break">reactive declaration:</span></p>
<pre class="source-code">
&lt;!-- filename: DateLabel.svelte --&gt;
&lt;script&gt;
  export let date;
  // Deriving the 'label' variable from the 'date' prop
  <strong class="bold">$: label = date.toLocaleDateString();</strong>
&lt;/script&gt;</pre> <p>In this <a id="_idIndexMarker114"/>code snippet, by modifying the declaration of <strong class="source-inline">label</strong> to a reactive declaration, the component will automatically re-compute the <strong class="source-inline">label</strong> variable whenever the <strong class="source-inline">date</strong> prop is modified, ensuring that the <strong class="source-inline">&lt;DateLabel&gt;</strong> component is always displaying the most current <span class="No-Break">formatted date.</span></p>
<p>So, how does Svelte know when a reactive declaration statement should <span class="No-Break">be re-run?</span></p>
<p>Svelte <a id="_idIndexMarker115"/>re-runs a reactive declaration <a id="_idIndexMarker116"/>statement whenever any of its dependent variables change. The Svelte compiler identifies these dependencies by analyzing <span class="No-Break">the statement.</span></p>
<p>For example, in the reactive declaration <strong class="source-inline">$: label = date.toLocaleDateString();</strong>, Svelte recognizes that the dependency for this statement is the <strong class="source-inline">date</strong> variable. Therefore, whenever the <strong class="source-inline">date</strong> changes, the statement will re-run and update the value of the <span class="No-Break"><strong class="source-inline">label</strong></span><span class="No-Break"> variable.</span></p>
<p>A good rule of thumb for identifying dependencies in a reactive declaration is to look for any variable on the right side of the equal sign (<strong class="source-inline">=</strong>). These variables are considered dependencies of the <span class="No-Break">reactive declaration.</span></p>
<p>You can include multiple dependencies within a single reactive declaration. For instance, let’s say we want to add a new <strong class="source-inline">locale</strong> prop to the <strong class="source-inline">&lt;DateLabel&gt;</strong> component. To use this new prop, you might write something <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;DateLabel date={new Date(2023, 5, 5)} locale="de-DE" /&gt;</pre> <p>In this code snippet, we pass in a new <strong class="source-inline">locale</strong> prop with the value <strong class="source-inline">de-DE</strong> to format the date in German. To accommodate this new <strong class="source-inline">locale</strong> prop, we’ll need to modify our <strong class="source-inline">&lt;DateLabel&gt;</strong> component <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let date;
  <strong class="bold">export let locale;</strong>
  <strong class="bold">// Reactive declaration with multiple dependencies</strong>
  <strong class="bold">$: label = date.toLocaleDateString(locale);</strong>
&lt;/script&gt;
&lt;label&gt;{label}&lt;/label&gt;</pre> <p>In this <a id="_idIndexMarker117"/>updated code, the reactive declaration <strong class="source-inline">$: label = date.toLocaleDateString(locale);</strong> now has two dependencies: <strong class="source-inline">date</strong> and <strong class="source-inline">locale</strong>. Svelte <a id="_idIndexMarker118"/>will automatically re-run this statement whenever either of these variables changes, ensuring <a id="_idIndexMarker119"/>that the <strong class="source-inline">label</strong> value stays up to date with the latest <strong class="source-inline">date</strong> and <span class="No-Break"><strong class="source-inline">locale</strong></span><span class="No-Break"> props.</span></p>
<p>Now that we’ve covered the basics of props, bindings, states, and derived states, it’s crucial to note that as components become more complex, managing these elements can quickly become overwhelming. In the next section, we’ll explore some tips for effectively managing complex derived states to keep <span class="No-Break">them manageable.</span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Managing complex derived states</h1>
<p>As your <a id="_idIndexMarker120"/>Svelte application grows more complex, it will likely involve a greater number of interconnected components with multiple props and derived states. When dealing with this complexity, tracking updates and changes can become a complex task. Each prop or state change can affect other parts of your component, making it challenging to manage and predict how your component <span class="No-Break">will behave.</span></p>
<p>To make this easier, here are some guidelines <span class="No-Break">to consider:</span></p>
<ul>
<li><em class="italic">Maintain one-way data flow for </em><span class="No-Break"><em class="italic">derived states</em></span><p class="list-inset">While it’s possible to derive state from props and other states, it’s crucial to maintain a one-way data flow to simplify both debugging and understanding. Consider the following <span class="No-Break">Svelte example:</span></p><pre class="source-code">
&lt;script&gt;
  export let valueA;
  export let valueB;
  $: valueC = valueA + 5;
  $: valueD = valueB + valueC;
  $: valueC = Math.min(valueC, valueD / 2);
&lt;/script&gt;</pre><p class="list-inset">This <a id="_idIndexMarker121"/>code snippet won’t compile in Svelte due to a cyclical dependency detected by the compiler. Though workarounds may exist to circumvent this compile error, the code is purposely flawed to highlight <span class="No-Break">the issue.</span></p><p class="list-inset">Upon observing the data flow, we can see that <strong class="source-inline">valueC</strong> depends on <strong class="source-inline">valueA</strong>, <strong class="source-inline">valueD</strong> depends on both <strong class="source-inline">valueB</strong> and <strong class="source-inline">valueC</strong>, and then <strong class="source-inline">valueC</strong> in turn depends on <strong class="source-inline">valueD</strong>. Consequently, it’s unclear how <strong class="source-inline">valueC</strong> is actually calculated, it could be either <strong class="source-inline">valueA + 5</strong> or the minimum of <strong class="source-inline">valueC</strong> and <strong class="source-inline">valueD / 2</strong>. Such complexity makes the code hard to understand and increases the likelihood <span class="No-Break">of bugs.</span></p></li> <li><em class="italic">Group similar </em><span class="No-Break"><em class="italic">logic together</em></span><p class="list-inset">Consider this tip a stylistic suggestion. When dealing with multiple reactive declarations, it’s beneficial to group those that are related together. Utilize blank lines to create a visual separation between unrelated reactive declarations. This not only improves readability but also aids in <span class="No-Break">code maintenance.</span></p><p class="list-inset">It is worth noting that the Svelte compiler takes care of execution order based on dependencies regardless of how you arrange your declarations. For example, the following two code snippets will behave identically due to Svelte’s handling <span class="No-Break">of dependencies:</span></p><pre class="source-code">
&lt;script&gt;
  export let a;
  $: b = a * 2;
  $: c = b * 2;
&lt;/script&gt;</pre><p class="list-inset">In the <a id="_idIndexMarker122"/>preceding snippet, <strong class="source-inline">b</strong> is declared reactively before <strong class="source-inline">c</strong>. However, it behaves identically to the following snippet, where <strong class="source-inline">c</strong> is declared before <strong class="source-inline">b</strong>. Let’s look at the <span class="No-Break">next one:</span></p><pre class="source-code">&lt;script&gt;
  export let a;
  $: c = b * 2;
  $: b = a * 2;
&lt;/script&gt;</pre><p class="list-inset">The Svelte compiler analyzes the dependencies of each declaration and executes them in the correct order. In this case, it evaluates <strong class="source-inline">b = a * 2</strong> before <strong class="source-inline">c = b * 2</strong> since the latter depends on the value of <strong class="source-inline">b</strong>, established by the <span class="No-Break">former declaration.</span></p></li> <li><em class="italic">Avoid reassigning </em><span class="No-Break"><em class="italic">props directly</em></span><p class="list-inset">It might be tempting to modify the value of a prop directly, especially when you want to transform its value or provide a default fallback. For example, you might consider writing something like this to set a default value for an <span class="No-Break">undefined prop:</span></p><pre class="source-code">
&lt;script&gt;
  export let data;
  $: data = data ?? 100;
&lt;/script&gt;</pre><p class="list-inset">While this code snippet may seem to work as intended, directly reassigning prop values within a component can introduce confusion and make data flow unpredictable. This practice can muddy the waters when you’re trying to trace the origin of data changes, making it unclear whether the alteration occurred within the component itself or came from the <span class="No-Break">parent component.</span></p><p class="list-inset">Instead, it’s better to declare a new state variable to manage <span class="No-Break">this behavior:</span></p><pre class="source-code">&lt;script&gt;
  export let data;
  $: dataWithDefault = data ?? 100;
&lt;/script&gt;</pre><p class="list-inset">In this<a id="_idIndexMarker123"/> improved example, we introduce a new variable, <strong class="source-inline">dataWithDefault</strong>, which takes on either the value of the <strong class="source-inline">data</strong> prop or a default value of <strong class="source-inline">100</strong> if <strong class="source-inline">data</strong> is undefined. This approach makes the component’s behavior more transparent and easier <span class="No-Break">to debug.</span></p></li> <li><em class="italic">Be cautious when updating </em><span class="No-Break"><em class="italic">derived states</em></span><p class="list-inset">Modifying a derived state directly can introduce inconsistencies, particularly when that state is based on props or other <span class="No-Break">state variables.</span></p><p class="list-inset">Consider the <span class="No-Break">following example:</span></p><pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
&lt;/script&gt;
&lt;input bind:value={double} type="number" /&gt;
&lt;input bind:value={triple} type="number" /&gt;</pre><p class="list-inset">In this example, we have a single prop named <strong class="source-inline">value</strong> and two derived states, <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong>, which are two and three times the value of the <strong class="source-inline">value</strong> prop respectively. The component features two input boxes, each bound to <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong> using <span class="No-Break">two-way binding.</span></p><p class="list-inset">Here, <strong class="source-inline">triple</strong> can be modified in two ways: either by updating the <strong class="source-inline">value</strong> prop, which will keep <strong class="source-inline">triple</strong> at three times the value of <strong class="source-inline">value</strong>, or by directly changing the value in the input box, thereby directly <span class="No-Break">altering </span><span class="No-Break"><strong class="source-inline">triple</strong></span><span class="No-Break">.</span></p><p class="list-inset">If you type<a id="_idIndexMarker124"/> into the input box bound to <strong class="source-inline">triple</strong>, you’ll find that its value diverges from being strictly three times the <strong class="source-inline">value</strong> prop. This inconsistency arises because <strong class="source-inline">triple</strong> is now subject to changes from multiple sources, causing it to go <em class="italic">out of sync</em> with the <span class="No-Break">original </span><span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break">.</span></p><p class="list-inset">If you were to map out a diagram illustrating the data flow between <strong class="source-inline">value</strong> <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong>, you’d get the <span class="No-Break">following diagram:</span></p></li> </ul>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="" height="466" role="presentation" src="image/B18887_03_3.jpg" width="705"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Data flows between props, states, and the input elements</p>
<p class="list-inset">Notice that both <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong> have two incoming arrows, suggesting multiple pathways for changing their values. Conversely, <strong class="source-inline">value</strong> has no incoming arrows, indicating that modifying <strong class="source-inline">triple</strong> alone would cause <strong class="source-inline">value</strong> and <strong class="source-inline">double</strong> to go out <span class="No-Break">of sync.</span></p>
<p class="list-inset">Therefore, it is recommended to refrain from manually updating derived states, as this complicates debugging and makes the component’s behavior harder to <span class="No-Break">reason about.</span></p>
<p class="list-inset">If you <a id="_idIndexMarker125"/>wish to modify the input while maintaining the synchrony between <strong class="source-inline">value</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">triple</strong>, a solution will be discussed in the <span class="No-Break">following section.</span></p>
<p>By keeping these tips in mind, you can better manage complex derived states and make your components more maintainable and easier <span class="No-Break">to understand.</span></p>
<p>In our last tip, we highlighted that updating the derived states can lead to inconsistencies between states and props and noted that there’s a solution to modify the input while keeping everything in sync. That solution is what we will <span class="No-Break">explore next.</span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Updating props using derived states</h1>
<p>In an attempt <a id="_idIndexMarker126"/>to synchronize the <strong class="source-inline">value</strong> prop <a id="_idIndexMarker127"/>with changes to the input bound to <strong class="source-inline">triple</strong>, one might be tempted to add another reactive declaration. This declaration would update the <strong class="source-inline">value</strong> prop to be one-third of <strong class="source-inline">triple</strong> whenever <strong class="source-inline">triple</strong> changes. Here is the <span class="No-Break">proposed modification:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
<strong class="bold">  $: value = double / 2;</strong>
<strong class="bold">  $: value = triple / 3;</strong>
&lt;/script&gt;
&lt;input bind:value={double} type="number" /&gt;
&lt;input bind:value={triple} type="number" /&gt;</pre> <p>As we discussed earlier, it’s best practice to maintain a one-way data flow for derived states to simplify debugging and data management. Indeed, the Svelte compiler flags the preceding code snippet for cyclical dependencies. This is because <strong class="source-inline">double</strong> is derived from <strong class="source-inline">value</strong>, and <strong class="source-inline">value</strong> is in turn dependent <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
<p>However, Svelte’s compiler determines dependency relationships based solely on the reactive <a id="_idIndexMarker128"/>declarations. By refactoring the code to make <a id="_idIndexMarker129"/>these relationships less obvious, you can bypass the compiler’s cyclical dependency check. Here’s a refactored version of the code that does <span class="No-Break">just that:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
<strong class="bold">  $: updateValueFromDouble(double);</strong>
<strong class="bold">  $: updateValueFromTriple(triple);</strong>
<strong class="bold">  function updateValueFromDouble(double) {</strong>
<strong class="bold">    value = double / 2;</strong>
<strong class="bold">  }</strong>
<strong class="bold">  function updateValueFromTriple(triple) {</strong>
<strong class="bold">    value = triple / 3;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
&lt;input bind:value={double} type="number" /&gt;
&lt;input bind:value={triple} type="number" /&gt;</pre> <p>In the provided code snippet, we’ve shifted the equations <strong class="source-inline">value = double / 2</strong> and <strong class="source-inline">value = triple / 3</strong> into separate functions named <strong class="source-inline">updateValueFromDouble</strong> and <strong class="source-inline">updateValueFromTriple</strong>. This change lets us evade Svelte’s compiler warning about <span class="No-Break">cyclical dependencies.</span></p>
<p>However, there’s a catch. If you try altering the <strong class="source-inline">triple</strong> input, it updates <strong class="source-inline">value</strong> but doesn’t refresh <strong class="source-inline">double</strong>. This happens because Svelte avoids infinite update loops. Changing <strong class="source-inline">triple</strong> would set off a chain reaction—updating <strong class="source-inline">value</strong>, then <strong class="source-inline">double</strong>, then back to <strong class="source-inline">value</strong>, and <span class="No-Break">so on.</span></p>
<p>This is <a id="_idIndexMarker130"/>how <a id="_idIndexMarker131"/>the data flow looks <span class="No-Break">right now:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="" height="466" role="presentation" src="image/B18887_03_4.jpg" width="705"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Data flows between props, states, and the input elements</p>
<p>As you can see in the diagram, we update the value of <strong class="source-inline">value</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">triple</strong> through reactive declarations, creating a loop in the data flow, indicated by the <span class="No-Break">bold arrows.</span></p>
<p>Therefore, using derived states to update their original properties via reactive declarations <span class="No-Break">isn’t advisable.</span></p>
<p>A better approach to keep <strong class="source-inline">value</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">triple</strong> in sync is to establish value as the single source of truth. Since both <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong> are derived from <strong class="source-inline">value</strong>, any changes to the input should first update <strong class="source-inline">value</strong>. This, in turn, triggers the reactive declarations to automatically recalculate <strong class="source-inline">double</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">triple</strong></span><span class="No-Break">.</span></p>
<p>Here’s the <span class="No-Break">updated code:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let value;
  $: double = value * 2;
  $: triple = value * 3;
  function updateValueFromDouble(double) {
    value = double / 2;
  }
  function updateValueFromTriple(triple) {
    value = triple / 3;
  }
&lt;/script&gt;
&lt;input <strong class="bold">value={double}</strong> type="number" <strong class="bold">on:change={e =&gt; updateValueFromDouble(e.target.value)}</strong> /&gt;
&lt;input <strong class="bold">value={triple}</strong> type="number" <strong class="bold">on:change={e =&gt; updateValueFromTriple(e.target.value)}</strong> /&gt;</pre> <p>In the <a id="_idIndexMarker132"/>preceding code snippet, we’ve shifted our <a id="_idIndexMarker133"/>approach to focus on <strong class="source-inline">value</strong> as the sole source of truth. Instead of binding the input elements directly to <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong>, we’ve added event listeners that update <strong class="source-inline">value</strong> based on user input. This change automatically updates <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong> through reactive declarations, which then refresh the displayed values in the <span class="No-Break">input fields.</span></p>
<p>With the updated code, the data flow is now streamlined, as shown in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="" height="466" role="presentation" src="image/B18887_03_5.jpg" width="693"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Data flows between props, states, and the input elements</p>
<p>The <a id="_idIndexMarker134"/>values for <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong> are directly derived from <strong class="source-inline">value</strong>, which then populates <a id="_idIndexMarker135"/>the input fields. When you modify the input, it alters <strong class="source-inline">value</strong> directly, which in turn automatically updates both <strong class="source-inline">double</strong> and <strong class="source-inline">triple</strong>, as well as the input <span class="No-Break">fields themselves.</span></p>
<p>So, this is how you maintain synchronized states for <strong class="source-inline">value</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">triple</strong>, by focusing on the data flow and keeping a single source <span class="No-Break">of truth.</span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Summary</h1>
<p>Understanding how to handle props and state effectively is crucial for creating robust Svelte apps. This chapter has shown you how Svelte uses props, bindings, and reactive declarations to facilitate data passing and state changes <span class="No-Break">across components.</span></p>
<p>It’s crucial to keep an eye on data flow within a component. Having a unified and organized data flow makes the code easier to follow and debug. Good data management paves the way for building more intricate and dynamic apps <span class="No-Break">with ease.</span></p>
<p>In the next chapter, we’ll explore how to compose Svelte components to construct more <span class="No-Break">complex applications.</span></p>
</div>
</div></body></html>