- en: 7 Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Before you begin: Join our book community on Discord**'
  prefs: []
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on your knowledge of sequential data structures, this chapter introduces
    you to the unique world of **sets**, a collection that stores only distinct values.
    We will cover the fundamentals of creating sets, adding or removing elements,
    and efficiently checking for membership. We will then discover how to leverage
    the power of sets with mathematical operations like union, intersection, and difference.
    To make things even easier, we will explore JavaScript''s built-in `Set` class,
    providing you with a convenient tool for working with sets directly. So, in this
    chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Set class from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing mathematical operations with a set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript native Set class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **set** is a fundamental concept in mathematics and computer science. It is
    an unordered collection of distinct items (elements). Think of it as a bag where
    you can put things in, but the order you put them in does not matter, and you
    cannot have duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are a fundamental concept in mathematics and computer science, with numerous
    real-world applications across various fields.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the mathematical concept of sets before we dive into the
    computer science implementation of it. In mathematics, a set is a collection of
    distinct objects. For example, we have a set of natural numbers, which consists
    of integer numbers greater than or equal to 0 - that is, N = {0, 1, 2, 3, 4, 5,
    6, ...}. The list of the objects within the set is surrounded by {} (curly braces).
  prefs: []
  type: TYPE_NORMAL
- en: There is also the null set concept. A set with no element is called a **null
    set** or an **empty set**. An example would be a set of prime numbers between
    24 and 29\. Since there is no prime number (a natural number greater than 1 that
    has no positive divisors other than 1 and itself) between 24 and 29, the set will
    be empty. We will represent an empty set with { }.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, a set also has some basic operations such as union, intersection,
    and difference. We will also cover these operations in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science for example, sets are used to model relationships between
    data and to perform operations like filtering, sorting, and searching. Sets are
    also extremely useful to remove duplicate elements from other collections such
    as lists.
  prefs: []
  type: TYPE_NORMAL
- en: You can also imagine a set as an array with no repeated elements and no concept
    of order.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MySet class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 2015 (ES6) introduced the native Set class to JavaScript, providing
    a built-in and efficient way to work with sets. However, understanding the underlying
    implementation of a set is crucial for grasping data structures and algorithms.
    We will delve into creating our own custom `MySet` class that mirrors the functionality
    of the native Set, but with additional features like union, intersection, and
    difference operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation will reside in the `src/07-set/set.js` file. We will start
    by defining the `MySet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We chose the name `MySet` to avoid conflicts with the native `Set` class. We
    utilize an object (`{}`) instead of an array to store elements within the `#items`
    private property. The keys of this object represent the set's unique values, while
    the corresponding values can be anything (we will use true as a simple placeholder).
    This choice leverages the fact that JavaScript objects cannot have duplicate keys,
    naturally enforcing the uniqueness of set elements. Arrays could also be used,
    but they require additional logic to prevent duplicates and might have slightly
    slower lookups in some cases. In other languages, this data structure (using a
    hash table-like approach) is often referred to as a **hash set**. We will also
    keep track of the number of elements in the set with the property `size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to declare the methods available for a set:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MySet` class will provide the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(value)`: adds a unique value to the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete(value)`: removes the value from the set if it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has(value)`: returns true if the element exists in the set and false otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: removes all the values from the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()`: returns how many values the set contains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: returns an array of all the values of the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`union(otherSet)`: combines two sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intersection(otherSet)`: finds common elements between the two sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference(otherSet)`: finds elements unique to one set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement each of these methods in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a value in the set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first method we implement in our custom `MySet` class is `has(value)`.
    This method plays a crucial role as a building block for other operations like
    adding and removing elements. It allows us to efficiently determine if a given
    value already exists within the set. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The method directly utilizes JavaScript's built-in `hasOwnProperty` function
    on the internal `#items` object. This is a highly optimized way to check if a
    specific key (representing the value) exists in the object.
  prefs: []
  type: TYPE_NORMAL
- en: The `hasOwnProperty` method provides constant time complexity (*O(1)*) on average,
    making it an extremely fast way to check for existence within the set. This efficiency
    is a key reason we often prefer using objects over arrays for set implementations
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: And now that we have this method, we can proceed with the implementation of
    the methods for adding and removing values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding values to the set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement the add method in our custom `MySet` class. This method
    is responsible for inserting a new element into the set, but only if it''s not
    already present (maintaining the set''s uniqueness property) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We start by efficiently checking if the value already exists within the set
    using the `has(value)` method we implemented earlier. If the value is not already
    present, we insert it into the `#items` object. We use the `value` itself as the
    key and assign a value of `true` to it. This serves as a simple flag indicating
    that the value is part of the set. After a successful insertion, we increment
    the `#size` property to accurately reflect the new number of elements in the set.
  prefs: []
  type: TYPE_NORMAL
- en: We return `true` to signal that the value was successfully added (it was not
    already in the set). Otherwise, we return `false` to indicate that the value was
    not added because it was a duplicate.
  prefs: []
  type: TYPE_NORMAL
- en: Removing and clearing all values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement the `delete` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if the specified value exists within the set using the
    previously implemented `has(value)` method. This ensures we only try to delete
    elements that are present. If the value is found, we use the `delete` operator
    to remove the corresponding key-value pair from the `#items` object. This directly
    eliminates the element from the set's internal storage. After a successful deletion,
    we decrease the `#size` property to maintain an accurate count of elements in
    the set.
  prefs: []
  type: TYPE_NORMAL
- en: We return `true` to signal that the value was successfully deleted from the
    set, and `false` to indicate that the value was not found in the set and therefore
    could not be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we want to remove all the elements from the set, we can use the `clear`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We achieve a complete clearing of the set by directly reassigning the `#items`
    object to a new, empty object `{}`. This effectively discards all previous key-value
    pairs (representing the set's elements) and creates a fresh, empty container for
    future additions. And we also reset the `#size` property back to 0 to accurately
    reflect that the set now contains no elements.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is extremely efficient, as reassigning the `#items` object
    is a constant time operation (*O(1)*). The alternative of iterating and deleting
    each element individually would be much slower, especially for large sets. This
    is generally not recommended unless we have a specific reason to track which elements
    are being removed during the clear operation.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the size and checking if it is empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next method we will implement is the size method (technically a getter
    method) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method simply returns the size property we are using to keep count.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we weren''t tracking the `#size` property, we could determine the size of
    the set by:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over the keys (elements) of the `#items` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incrementing a counter for each key encountered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for this alternative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code uses a `for...in` loop to iterate over the keys (which are the values
    of the set) in the `#items` object. Inside the loop, `hasOwnProperty` is used
    to ensure we are only counting properties that belong directly to the object (not
    inherited properties from the prototype chain).
  prefs: []
  type: TYPE_NORMAL
- en: This approach would be less efficient, especially for large sets, as it would
    involve iterating over all elements, resulting in a time complexity of *O(n)*,
    where *n* is the number of elements in the set
  prefs: []
  type: TYPE_NORMAL
- en: 'And to determine if the `MySet` is empty, we implement the `isEmpty()` method,
    following a pattern consistent with other data structures we have covered in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method directly compares the private `#size` property to 0\. The property
    `#size` is meticulously maintained to always reflect the number of elements in
    the set.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving all the values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve an array containing all the elements (values) within our `MySet`,
    we can implement the `values` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can leverage the built-in `Object.keys()` method for a concise implementation.
    This built-in JavaScript method takes an object (in our case, `this.#items`) and
    returns an array containing all its enumerable property keys as strings. Remember,
    in our `MySet` implementation, we use the keys of the `#items` object to store
    the actual values that are added to the set.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed the implementation of our custom `MySet` data structure,
    let's explore how to put it into action!
  prefs: []
  type: TYPE_NORMAL
- en: Using the MySet class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will dive into practical examples that showcase the utility and flexibility
    of `MySet`, demonstrating how it can be used to efficiently manage collections
    of unique elements. Imagine we are building a blog or content management system
    where users can add tags (keywords) to their articles or posts. We want to ensure
    that each post has a list of unique tags, with no duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this example can be found in the file src/07-set/01-using-myset-class.js.
    Let''s start by defining the article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some tags to our article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the first and last tags are duplicates. We can confirm if we have
    three tags in the set, meaning there are no duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `has` method to double check which tags are part of the
    article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the values method to retrieve all the tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we want to remove the tag programming and add the tag JavaScript
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, now we have a remarkably similar implementation of the Set class, as in
    ECMAScript 2015\. But we can also enhance our implementation by adding some basic
    operations such as union, intersection, and difference.
  prefs: []
  type: TYPE_NORMAL
- en: Performing mathematical operations with a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are a fundamental concept in mathematics with far-reaching applications
    in computer science, particularly within the realm of **databases**. Databases
    serve as the backbone of countless applications, and sets play a crucial role
    in their design and operation.
  prefs: []
  type: TYPE_NORMAL
- en: When we construct a query to retrieve data from a relational database (such
    as Oracle, Microsoft SQL Server, MySQL, etc.), we are essentially using set notation
    to define the desired result. The database, in turn, returns a set of data that
    matches our criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL queries allow us to specify the scope of the data we want to retrieve.
    We can select all records from a table, or we can narrow down the search to a
    specific subset based on certain conditions. Furthermore, SQL leverages set operations
    to perform various types of data manipulation. The concept of *joins* in SQL is
    fundamentally based on set operations. Here are some common examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Union**: combining data from two or more tables to create a new set containing
    all unique rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersection**: identifying rows that are common to multiple tables, resulting
    in a set containing only the shared data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difference** (Except/Minus): finding rows that exist in one table but not
    in another, creating a set of unique rows from the first table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And beyond the operations used in SQL, there are other essential set operations
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subset**: determining if one set is entirely contained within another set.
    This helps establish relationships between sets and can be useful for various
    logical and analytical tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding sets and their operations is essential for working with databases
    and other data-intensive applications. The ability to manipulate sets effectively
    allows us to efficiently extract, filter, and analyze information from complex
    datasets. Let's see how we can simulate these operations using our `MySet` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Union: combining two sets'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The union of two sets, A and B, is a new set that contains all the unique elements
    from both sets. It is like combining the contents of two bags into one larger
    bag, making sure not to put in any duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider we have two sets: A and B as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set A = {1, 2, 3}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set B = {3, 4, 5}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ∪ B = {1, 2, 3, 4, 5}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the value 3 appears in both sets, but it is only included once
    in the resulting union set because sets cannot contain duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The union of sets A and B is denoted by the symbol ∪. So, the union of A and
    B is written as A ∪ B in the mathematical notation. The following diagram exemplifies
    the union operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The union operation of two sets, highlighting all the area of both sets](img/file54.png)'
  prefs: []
  type: TYPE_IMG
- en: The union operation of two sets, highlighting all the area of both sets
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the union method in our `MySet` class with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We need three steps to perform the union of two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new empty set: this will be the set to hold the results of the union.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the first set: add each element from the first set to the new
    set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the second set: add each element from the second set to the new
    set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When performing the add operation, it will evaluate if the value is duplicate
    or not, resulting in a new set containing all the unique elements from the original
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the union, intersection, and difference methods
    we are implementing in this chapter do not modify the current instance of the
    `MySet` class nor the `otherSet` that is being passed as a parameter. Methods
    or functions that do not have collateral effects are called **pure functions**.
    A pure function does not modify the current instance nor the parameters; it only
    produces a new result.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s see this in action. Suppose an online advertising platform wants to
    target users based on their interests, which are collected from various sources
    (for example: websites visited and social media activity). To be able to launch
    a campaign, we need:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect sets of keywords representing interests from different sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the union of these sets to get a comprehensive list of user interests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this combined set to match users with relevant advertisements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following would be the code that would represent this logic. Let''s first
    collect the interest from websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s collect the interested from social media:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With both sources, we can calculate the union to have a list of all interests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we can try to launch a successful campaign!
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate our examples, we can also create a new method what will take
    an array of values as the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This method will add each element individually so we can save some time during
    the next examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intersection: identifying common values in two sets'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The intersection of two sets, A and B, is a new set that contains only the elements
    that are common to both sets. Think of it as finding the overlap between the contents
    of two bags.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider we have two sets: A and B as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set A = {1, 2, 3, 4}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set B = {3, 4, 5, 6}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ∩ B = {3, 4}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the values 3 and 4 are present in both sets, so they are included
    in the resulting intersection set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intersection of sets A and B is denoted by the symbol ∩. So, the intersection
    of A and B is written as A ∩ B. The following diagram exemplifies the intersection
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The intersection operation of two sets, highlighting only the middle, which
    is the shared area of both sets](img/file55.png)'
  prefs: []
  type: TYPE_IMG
- en: The intersection operation of two sets, highlighting only the middle, which
    is the shared area of both sets
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the intersection method in our `MySet` class with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We need three steps to perform the intersection of two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new empty set: this will be the set to hold the results of the intersection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the first set: for each element in the first set, check if it
    also exists in the second set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Conditional addition: If the element is found in both sets, add it to the new
    set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see this in action. Suppose a job platform wants to match candidates
    with job postings based on their skills. For this implementation we would need
    the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Represent a candidate's skills and a job's required skills as sets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the intersection of these sets to determine the skills that the candidate
    possesses, and the job requires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rank job postings based on the size of the intersection to show the most relevant
    jobs to the candidate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following would be the code that would represent this logic. First, we
    will define the job postings available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `jobPostings` variable is an array of job objects, each with a `title` and
    a `MySet` named skills containing the required skills for that job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the candidate with the name and their skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `candidate` is an object representing a job seeker with a name and a `MySet`
    named skills containing their skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can create a function that will calculate the best potential matches
    between the candidate and the job postings available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation of the `matchCandidateWithJobs` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the `candidate` and the `jobPostings` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes an empty array `matches` to store the matching jobs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterates through each job in the `jobPostings` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each job, it calculates the intersection of the candidate's skills and the
    job's required skills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the intersection set is not empty (meaning there are matching skills), the
    job title and the matching skills (as an array) are added to the `matches` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we return the matches array containing the job titles and their matching
    skills with the candidate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Putting all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We get the output that the best job posting for this candidate would be the
    Software Engineer job because the candidate also has JavaScript and Angular skills.
  prefs: []
  type: TYPE_NORMAL
- en: The intersection logic we created works perfectly, however, there is an improvement
    we can make.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the intersection logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set A contains values: {1, 2, 3, 4, 5, 6, 7}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set B contains values: {4, 6}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our initial intersection method, we would iterate through all seven elements
    of Set A and check for their presence in Set B. However, a more efficient approach
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can optimize the intersection method by iterating over the *smaller* of
    the two sets. This significantly reduces the number of iterations and comparisons
    needed when one set is considerably smaller than the other. The optimized code
    is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a concise ternary expression to determine which set has fewer elements:
    `this.size <= otherSet.size ? [this, otherSet] : [otherSet, this]`. This assigns
    the smaller set to `smallerSet` and the larger set to `largerSet`. Then, we iterate
    over the `values()` of the `smallerSet`. This immediately reduces the number of
    loop iterations to the size of the smaller set.'
  prefs: []
  type: TYPE_NORMAL
- en: In cases where one set is much smaller than the other, this optimization significantly
    reduces the number of iterations and comparisons, leading to faster execution
    time. And the overall performance of the intersection operation is enhanced, especially
    for scenarios with large set size disparities.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between two sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between two sets, A and B (denoted as A - B or A \ B), is a new
    set that contains all the elements of A that are not present in B. In other words,
    it is the set of elements that are unique to set A.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider we have two sets: A and B as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set A = {1, 2, 3, 4}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set B = {3, 4, 5, 6}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A - B = {1, 2}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B - A = {5, 6}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, A - B results in the set {1, 2} because these elements are
    in A but not in B. Similarly, B - A results in {5, 6}.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference of sets A and B is written as:'
  prefs: []
  type: TYPE_NORMAL
- en: A - B (sometimes read as *A minus B*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A \ B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram exemplifies the difference operation of A - B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The difference operation of two sets A - B, highlighting only the area of
    A not common to B](img/file56.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference operation of two sets A - B, highlighting only the area of A
    not common to B
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the difference method in our `MySet` class with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We need three steps to perform the difference of two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new empty set: this will hold the result of the difference.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the first set: for each element in the first set, check if it
    exists in the second set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Conditional addition: if the element is *not* found in the second set, add
    it to the new set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see this in action. Suppose we are running an online store with a list
    of subscribers who receive promotional emails. We have segmented the subscribers
    based on their interests (books, fashion, technology). We want to send a targeted
    email campaign about books, but we want to exclude subscribers who have already
    shown interest in these books.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start by declaring all the sets we need for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allSubscribers`: a set of all email subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`booksInterested`: a set of subscribers who have expressed interest in the
    books.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alreadyPurchasedBooks`: a set of subscribers who have already purchased books.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will find the subscribers interested in books, but have not purchased
    yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use `booksInterested.difference(alreadyPurchasedBooks)` to find the subscribers
    who are interested in books but have not yet made a purchase in that category.
    This gives us the `targetSubscribers` set.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we will send the email to the target subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output we will get is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We only have one last operation to cover: subsets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subset: checking if a set contains all the values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A set A is a subset of another set B if every element of A is also an element
    of B. In simpler terms, A is completely contained within B.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider we have two sets: A and B as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set A = {1, 2}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set B = {1, 2, 3, 4}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ⊆ B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, A is a subset of B because every element in A is also in B.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subset relationship is denoted by the symbol ⊆. So, if A is a subset of
    B, we write: A ⊆ B. The following diagram exemplifies the subset relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A is a subset of B because element in A is also in B](img/file57.png)'
  prefs: []
  type: TYPE_IMG
- en: A is a subset of B because element in A is also in B
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `isSubsetOf` method in our `MySet` class with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if the size of the current set (`this.size`) is greater
    than the size of the `otherSet`. If it is, we know immediately that the current
    set cannot be a subset of `otherSet` because a subset cannot have more elements
    than the set it is a part of. In this case, the method returns `false` early,
    saving unnecessary further checks.
  prefs: []
  type: TYPE_NORMAL
- en: If the size check passes, we call `this.values()` to get an array of all the
    values in the current set. Then, we use the `every()` method on this array to
    check if the other set has the value from the current set. If every value in the
    current set is also found in `otherSet`, then the `every()` method returns `true`
    (meaning the current set is a subset). If even a single value in the current set
    is not found in `otherSet`, `every()` returns `false` (meaning it's not a subset).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see this in action. Imagine we are developing a recipe app with a large
    database of recipes. Each recipe has a set of ingredients. Users can filter the
    recipes based on the ingredients they have available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by declaring the sets that store the ingredients of our recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will declare the recipes along with the ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `recipes` variable is an array of recipe objects, each with a name and a
    `MySet` named ingredients representing the ingredients required for that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we also need a set with the list of ingredients we have available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step would be the logic to check if we have a recipe that matches
    our ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation of the `filterRecipes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the `recipes` and `userIngredients` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes an empty array `filteredRecipes` to store the matching recipe names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterates over each recipe in the recipes array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each recipe, it checks if `recipe.ingredients.isSubsetOf(userIngredients)`.
    If `true` (meaning all the recipe's ingredients are present in the user's ingredients),
    the recipe's name is added to `filteredRecipes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the `filteredRecipes` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, putting all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can also implement the isSupersetOf method, which would check if the current
    set A is a superset of another set B if every element of B is also an element
    of A. In simpler terms, B is completely contained within A. Try it, and you can
    find the source code within the `MySet` class when you download the source code
    of this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have added some additional logic to the `MySet` class, let's check
    how the native JavaScript Set class works.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Set class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's dive into the native Set class introduced in ECMAScript 2015 (ES6) and
    explore how to use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Set class provides a built-in, efficient way to work with sets in JavaScript.
    It offers all the fundamental set operations and is optimized for performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the methods and features available in the native Set class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two constructors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Set()`: creates an empty Set.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Set(iterable)`: creates a Set from an iterable object (for example, an
    array).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add(value)`: adds a value to the set (if it is not already present). Returns
    the Set object itself for chaining.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete(value)`: removes the specified value from the set. Returns `true` if
    the value was present and removed, otherwise `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: removes all elements from the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has(value)`: returns `true` if the value exists in the set, otherwise `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Different methods for iterating the set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach(callbackFn)`: executes the provided `callbackFn` for each value in
    the set.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: returns an iterator over the values of the set.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keys()`: alias for `values()`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entries()`: Returns an iterator over `[value, value]` pairs (since keys and
    values are the same in a Set).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: property that returns the number of elements in the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we would like to rewrite our example of the article and its tags, can we
    simply replace `MySet` with `Set` and the code would still work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the Set class also has a constructor that accepts an array, we could
    simplify the previous code and pass the tags directly to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The other methods, such as delete, check the size, has and values would also
    work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Building our custom `MySet` class served as a valuable learning exercise, providing
    insights into the internal workings and mechanics of set data structures. While
    in everyday JavaScript development, we would likely use the efficient and convenient
    built-in Set class, the knowledge gained from implementing our own set empowers
    us to understand the underlying principles, make informed choices between built-in
    and custom solutions, and troubleshoot set-related issues more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the efficiency of sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review the efficiency of each method by reviewing the Big O notation
    in terms of time of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **MySet** | **Set** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `add(value)` | *O(1)* | *O(1)* | Constant time insertion into the object
    or underlying data structure. |'
  prefs: []
  type: TYPE_TB
- en: '| `addAll(values)` | *O(n)* | *O(n)* | Calls `add(value)` for each value in
    the input array, where *n* is the size of the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete(value)` | *O(1)* | *O(1)* | Constant time deletion from the object
    or underlying data structure. |'
  prefs: []
  type: TYPE_TB
- en: '| `has(value)` | *O(1)* | *O(1)* | Object lookup in both cases has constant
    time |'
  prefs: []
  type: TYPE_TB
- en: '| `values()` | *O(n)* | *O(n)* | In `MySet` , it iterates over the object''s
    keys. In `Set` , it creates an iterator that yields each value in linear time.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size (getter)` | *O(1)* | *O(1)* | Returns the value of the `#size` property
    or equivalent in the native Set. |'
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty()` | *O(1)* | *O(1)* | Checks if `#size` is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `values()` | *O(n)* | *O(n)* | In `MySet` , it iterates over the object''s
    keys. In `Set` , it creates an iterator that yields each value in linear time.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | *O(1)* | *O(1)* | Reassigns the `#items` object to an empty object
    and resets `#size` . |'
  prefs: []
  type: TYPE_TB
- en: The overall space complexity of sets is considered O(n), where n is the number
    of unique elements stored in the set. This means that the memory used by a set
    data structure increases linearly with the number of elements it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reviewing the time complexity, adding, removing values, and checking if a value
    exists in a set have constant time. One might ask why not always use sets instead
    of arrays or lists? While sets excel at specific tasks, there are a few reasons
    why we would not always choose them over arrays or lists:'
  prefs: []
  type: TYPE_NORMAL
- en: If the order of the elements is crucial, arrays are the way to go. Sets do not
    guarantee any specific order of elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we frequently need to access elements by their position (for example, getting
    the third item in a list), arrays are much faster due to their direct indexing.
    Sets require iteration to find a specific element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data naturally contains duplicates, and those duplicates are meaningful,
    then an array is the more appropriate choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's put our knowledge into practice with some exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will resolve one exercise from **LeetCode** using the set data structure
    to remove duplicate values from an array.
  prefs: []
  type: TYPE_NORMAL
- en: Remove duplicates from sorted array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exercise we will resolve the is the *26\. Remove Duplicates from Sorted
    Array* problem available at [https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function removeDuplicates(nums: number[]):
    number`, which receives an array of numbers and expects the number of unique elements
    within the array as a return. For our solution to be accepted, we also have to
    remove the duplicates from the `nums` array in-place, meaning we cannot simply
    assign a new reference to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `removeDuplicates` function using a set data structure to
    easily remove the duplicates from the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation of the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new JavaScript Set object, initializing it with the values
    from the input array `nums`. Sets automatically store only unique values, so any
    duplicates in `nums` are eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we convert the set back into a regular array `arr`. This new array contains
    only the unique elements from the original `nums` array, in sorted order. This
    step is required because we cannot access each set value directly, like an `array[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop iterates through the `arr` (unique elements) array and copies each
    element back into the original `nums` array, overwriting any duplicate values
    that were present. Since `arr` is guaranteed to be shorter or equal in length
    to `nums`, we only need to iterate up to the length of arr. This step is a requirement
    as the problem judge will also check if the `nums` array was modified in-place.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method returns arr.length, which is the number of unique elements
    in the original array. This is the expected output for the LeetCode problem.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of this function is *O(n)*, where *n* is the number of values
    we have in the array `nums`. We are creating the set, adding all the elements
    (*O(n)*), we convert the set into an array (*O(n)*), and we also have a loop to
    overwrite the original array (*O(k)*, where *k* is the number of unique elements).
    Therefore, the overall time complexity is *O(n)*, as it is dominated by the linear-time
    operations of creating the set and converting it to an array.
  prefs: []
  type: TYPE_NORMAL
- en: The space complexity is *O(k)* because we are creating a set to store the unique
    elements. In the worst-case scenario where all elements are unique, it will store
    all *n* elements. However, in most cases, *k* (the number of unique elements)
    will be smaller than *n*. We also have the array `arr`, which stores only the
    unique elements, so its size is *k*. Therefore, the overall space complexity is
    *O(k)*, where *k* is the number of unique elements in the input array.
  prefs: []
  type: TYPE_NORMAL
- en: While the algorithm is correct and solves the problem, it is not the most *space-efficient*
    solution. We will resolve this same problem later in this book using a different
    technique. In the meantime, give it a try and try to solve this problem using
    *O(1)* space complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we delved into the inner workings of set data structures by
    implementing a custom `MySet` class. This hands-on approach mirrors the core functionality
    of the Set class introduced in ECMAScript 2015, giving you a deeper understanding
    of how sets operate under the hood. We also extended our exploration beyond the
    standard JavaScript Set by implementing additional methods like union, intersection,
    difference, and subset, enriching your toolkit for working with sets.
  prefs: []
  type: TYPE_NORMAL
- en: To put our newfound knowledge into practice, we tackled a real-world LeetCode
    problem, demonstrating the power of sets in solving algorithmic challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our focus to non-sequential data structures,
    specifically hashes and dictionaries. Get ready to discover how these versatile
    structures enable efficient data storage and retrieval based on key-value pairs!
  prefs: []
  type: TYPE_NORMAL
