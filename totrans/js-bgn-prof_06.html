<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer036">&#13;
    <h1 class="chapterNumber">6</h1>&#13;
    <h1 id="_idParaDest-159" class="chapterTitle">Functions</h1>&#13;
    <p class="normal">You have seen quite a lot of JavaScript already, and now you are ready for functions. Soon you will see that you have been using functions already, but now it is time to learn how to start writing your own. Functions are a great building block that will reduce the amount of code you will need in your app. You can call a function whenever you need it, and you can write it as a kind of template with variables. So, depending on how you've written it, you can reuse it in many situations.</p>&#13;
    <p class="normal">They do require you to think differently about the structure of your code and this can be hard, especially in the beginning. Once you have got the hang of this way of thinking, functions will really help you to write nicely structured, reusable, and low-maintenance code. Let's dive into this new abstraction layer!</p>&#13;
    <p class="normal">Along the way, we will cover the following topics:</p>&#13;
    <ul>&#13;
      <li class="bullet">Basic functions</li>&#13;
      <li class="bullet">Function arguments</li>&#13;
      <li class="bullet">Return</li>&#13;
      <li class="bullet">Variable scope in functions</li>&#13;
      <li class="bullet">Recursive functions</li>&#13;
      <li class="bullet">Nested functions</li>&#13;
      <li class="bullet">Anonymous functions</li>&#13;
      <li class="bullet">Function callbacks<div class="note">&#13;
          <p class="Information-Box--PACKT-">Note: exercise, project and self-check quiz answers can be found in the <em class="chapterRef">Appendix</em>.</p>&#13;
        </div>&#13;
      </li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-160" class="title">Basic functions</h1>&#13;
    <p class="normal">We have been calling functions<a id="_idIndexMarker266"/> for a while already. Remember <code class="Code-In-Text--PACKT-">prompt()</code>, <code class="Code-In-Text--PACKT-">console.log()</code>, <code class="Code-In-Text--PACKT-">push()</code>, and <code class="Code-In-Text--PACKT-">sort()</code> for arrays? These are all functions. Functions are a group of statements, variable declarations, loops, and so on that are bundled together. Calling a function means an entire group of statements will get executed.</p>&#13;
    <p class="normal">First, we are going to have a look at how we can invoke functions, and then we will see how to write functions of our own.</p>&#13;
    <h2 id="_idParaDest-161" class="title">Invoking functions</h2>&#13;
    <p class="normal">We can recognize functions by the parentheses at the end. We can<a id="_idIndexMarker267"/> invoke functions like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">nameOfTheFunction();&#13;
functionThatTakesInput(<span class="hljs-string">"the input"</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">true</span>);&#13;
</code></pre>&#13;
    <p class="normal">This is invoking a function called <code class="Code-In-Text--PACKT-">nameOfTheFunction</code> with no arguments, and a function called <code class="Code-In-Text--PACKT-">functionThatTakesInput</code> with three required arguments. Let's have a look at what functions can look like when we start writing them.</p>&#13;
    <h2 id="_idParaDest-162" class="title">Writing functions</h2>&#13;
    <p class="normal">Writing <a id="_idIndexMarker268"/>a function can be done using the <code class="Code-In-Text--PACKT-">function</code> keyword. Here is the template syntax to do so:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">nameOfTheFunction</span><span class="hljs-function">() </span>{&#13;
    <span class="hljs-comment">//content of the function</span>&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The above function can be called like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">nameOfTheFunction();&#13;
</code></pre>&#13;
    <p class="normal">Let's write a function that asks for your name and then greets you:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHello</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">let</span> you = prompt(<span class="hljs-string">"What's your name? "</span>);&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello"</span>, you + <span class="hljs-string">"!"</span>);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">We add a space after the question mark to ensure the user starts typing their answer one space away from the question mark, rather than directly afterward. We call this function like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">sayHello();&#13;
</code></pre>&#13;
    <p class="normal">It will prompt:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">What's your name? &gt;&#13;
</code></pre>&#13;
    <p class="normal">Let's go ahead and enter our name. The output will be:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hello Maaike!&#13;
</code></pre>&#13;
    <p class="normal">Take a moment to consider the relationship between functions and variables. As you have seen, functions can contain variables, which shape how they operate. The opposite is also true: variables can contain functions. Still with me? Here you can see an example<a id="_idIndexMarker269"/> of a variable containing a function (<code class="Code-In-Text--PACKT-">varContainingFunction</code>) and a variable inside a function (<code class="Code-In-Text--PACKT-">varInFunction</code>):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> varContainingFunction = <span class="hljs-keyword">function</span><span class="hljs-function">() </span>{&#13;
<span class="hljs-keyword">    let</span> varInFunction = <span class="hljs-string">"I'm in a function."</span>;&#13;
<span class="hljs-built_in">    console</span>.log(<span class="hljs-string">"hi there!"</span>, varInFunction);&#13;
};&#13;
varContainingFunction();&#13;
</code></pre>&#13;
    <p class="normal">Variables contain a certain value and <em class="italic">are</em> something; they do not <em class="italic">do</em> anything. Functions are actions. They are a bundle of statements that can be executed when they get called. JavaScript will not run the statements when the functions do not get invoked. We will return to the idea of storing functions in variables, and consider some of the benefits, in the <em class="italic">Anonymous functions</em> section, but for now let's move on to look at the best way to name your functions.</p>&#13;
    <h2 id="_idParaDest-163" class="title">Naming functions</h2>&#13;
    <p class="normal">Giving your <a id="_idIndexMarker270"/>function a name might seem like a trivial task, but there are some best practices to keep in mind here. To keep it short:</p>&#13;
    <ul>&#13;
      <li class="bullet">Use camelCase for your functions: this means that the first word starts with a lowercase letter and new words start with a capital. That makes it a lot easier to read and keeps your code consistent.</li>&#13;
      <li class="bullet">Make sure that the name describes what the function is doing: it's better to call a number addition function <code class="Code-In-Text--PACKT-">addNumbers</code> than <code class="Code-In-Text--PACKT-">myFunc</code>.</li>&#13;
      <li class="bullet">Use a verb to describe what the function is doing: make it an action. So instead of <code class="Code-In-Text--PACKT-">hiThere</code>, call it <code class="Code-In-Text--PACKT-">sayHi</code>.</li>&#13;
    </ul>&#13;
    <h2 id="_idParaDest-164" class="title">Practice exercise 6.1</h2>&#13;
    <p class="normal">See if you can write a function for yourself. We want to write a function that adds two numbers.</p>&#13;
    <ol>&#13;
      <li class="numbered">Create a function that takes two parameters, adds the parameters together, and returns the result.</li>&#13;
      <li class="numbered">Set up two different variables with two different values.</li>&#13;
      <li class="numbered">Use your function on the two variables, and output the result using <code class="Code-In-Text--PACKT-">console.log</code>.</li>&#13;
      <li class="numbered">Create a second call to the function using two more numbers as arguments sent to the function.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-165" class="title">Practice exercise 6.2</h2>&#13;
    <p class="normal">We are going to create a program that will randomly describe an inputted name.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create an array of descriptive words.</li>&#13;
      <li class="numbered">Create a function that contains a prompt asking the user for a name.</li>&#13;
      <li class="numbered">Select a random value from the array using <code class="Code-In-Text--PACKT-">Math.random</code>.</li>&#13;
      <li class="numbered">Output into the console the prompt value and the randomly selected array value.</li>&#13;
      <li class="numbered">Invoke the function.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-166" class="title">Parameters and arguments</h1>&#13;
    <p class="normal">You may have noticed that we are talking about parameters and arguments. Both terms are commonly used to <a id="_idIndexMarker271"/>mean the information that is passed into a function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">tester</span><span class="hljs-function">(</span><span class="hljs-params">para1, para2</span><span class="hljs-function">)</span>{&#13;
<span class="hljs-keyword">    return</span> para1 + <span class="hljs-string">" "</span> + para2;&#13;
}&#13;
<span class="hljs-keyword">const</span> arg1 = <span class="hljs-string">"argument 1"</span>;&#13;
<span class="hljs-keyword">const</span> arg2 = <span class="hljs-string">"argument 2"</span>;&#13;
tester(arg1, arg2);&#13;
</code></pre>&#13;
    <p class="normal">A parameter is defined as the <a id="_idIndexMarker272"/>variable listed inside the parentheses of the function definition, which defines the scope of the function. They are declared like so:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">myFunc</span><span class="hljs-function">(</span><span class="hljs-params">param1, param2</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-comment">// code of the function;</span>&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">A practical example could be the following, which takes <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> as parameters:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addTwoNumbers</span><span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(x + y);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">When called, this function will simply add the parameters and log the result. However, to do this, we can <a id="_idIndexMarker273"/>call the function with arguments:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">myFunc(<span class="hljs-string">"arg1"</span>, <span class="hljs-string">"arg2"</span>);&#13;
</code></pre>&#13;
    <p class="normal">We have seen various examples of arguments; for example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is an argument"</span>);&#13;
prompt(<span class="hljs-string">"argument here too"</span>);&#13;
<span class="hljs-keyword">let</span> arr = [];&#13;
arr.push(<span class="hljs-string">"argument"</span>);&#13;
</code></pre>&#13;
    <p class="normal">Depending on the arguments you are calling with the function, the outcome of the function can change, which makes the <a id="_idIndexMarker274"/>function a very powerful and flexible building block. A practical example using our <code class="Code-In-Text--PACKT-">addTwoNumbers()</code> function looks like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addTwoNumbers(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);&#13;
addTwoNumbers(<span class="hljs-number">12</span>,-<span class="hljs-number">90</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">7&#13;
-78&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the function has a different outcome for both calls. This is because we call it with different arguments, which take the place of <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code>, that are sent to the function to be used within the function scope.</p>&#13;
    <h2 id="_idParaDest-167" class="title">Practice exercise 6.3</h2>&#13;
    <p class="normal">Create a basic calculator that takes two numbers and one string value indicating an operation. If the operation equals add, the two numbers should be added. If the operation equals subtract, the two numbers should be subtracted from one another. If there is no option specified, the value of the option should be <code class="Code-In-Text--PACKT-">add</code>.</p>&#13;
    <p class="normal">The result of this function needs to be logged. Test your function by invoking it with different operators and no operator specified.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Set up two variables containing number values.</li>&#13;
      <li class="numbered">Set up a variable to hold an operator, either + or -.</li>&#13;
      <li class="numbered">Create a function that retrieves the two values and the operator string value within its parameters. Use those values with a condition to check if the operator is + or -, and add or subtract the values accordingly (remember if not presented with a valid operator, the function should default to addition).</li>&#13;
      <li class="numbered">Within <code class="Code-In-Text--PACKT-">console.log()</code>, call the function using your variables and output the response to the console.</li>&#13;
      <li class="numbered">Update the operator value to be the other operator type—either plus or minus—and call to the function again with the new updated arguments.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-168" class="title">Default or unsuitable parameters</h2>&#13;
    <p class="normal">What happens if we call our <code class="Code-In-Text--PACKT-">addTwoNumbers()</code> function without any arguments? Take a moment and decide what you think this should do:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addTwoNumbers();&#13;
</code></pre>&#13;
    <p class="normal">Some languages <a id="_idIndexMarker275"/>might crash and cry, but not JavaScript. JavaScript just gives the <a id="_idIndexMarker276"/>variables a default type, which is undefined. And <code class="Code-In-Text--PACKT-">undefined</code> + <code class="Code-In-Text--PACKT-">undefined</code> equals:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-literal">NaN</span> &#13;
</code></pre>&#13;
    <p class="normal">Instead, we could tell JavaScript to take different default parameters. And that can be done like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addTwoNumbers</span><span class="hljs-function">(</span><span class="hljs-params">x = </span><span class="hljs-number">2</span><span class="hljs-params">, y = </span><span class="hljs-number">3</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(x + y);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">If you call the function with no arguments now, it will automatically assign <code class="Code-In-Text--PACKT-">2</code> to <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">3</code> to <code class="Code-In-Text--PACKT-">y</code>, unless you override them by calling the function with arguments. The values that are used for invoking are prioritized over hardcoded arguments. So, given the above function, what will the output of these function calls be?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addTwoNumbers();&#13;
addTwoNumbers(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>);&#13;
addTwoNumbers(<span class="hljs-number">10</span>);&#13;
</code></pre>&#13;
    <p class="normal">The output will be:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">5&#13;
12&#13;
13&#13;
</code></pre>&#13;
    <p class="normal">The first one has the default values, so <code class="Code-In-Text--PACKT-">x</code> is <code class="Code-In-Text--PACKT-">2</code> and <code class="Code-In-Text--PACKT-">y</code> is <code class="Code-In-Text--PACKT-">3</code>. The second one assigns <code class="Code-In-Text--PACKT-">6</code> to both <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code>. The last one <a id="_idIndexMarker277"/>is a bit less obvious. We are only giving one argument, so which one will be given this value? Well, JavaScript does not like to overcomplicate things. It simply <a id="_idIndexMarker278"/>assigns the value to the first parameter, <code class="Code-In-Text--PACKT-">x</code>. Therefore, <code class="Code-In-Text--PACKT-">x</code> becomes <code class="Code-In-Text--PACKT-">10</code> and <code class="Code-In-Text--PACKT-">y</code> gets its default value <code class="Code-In-Text--PACKT-">3</code>, and together that makes <code class="Code-In-Text--PACKT-">13</code>.</p>&#13;
    <p class="normal">If you call a function with more arguments than parameters, nothing will happen. JavaScript will just execute the function using the first arguments that can be mapped to parameters. Like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addTwoNumbers(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">3&#13;
</code></pre>&#13;
    <p class="normal">It is just adding 1 and 2 and ignoring the last two arguments (<code class="Code-In-Text--PACKT-">3</code> and <code class="Code-In-Text--PACKT-">4</code>).</p>&#13;
    <h1 id="_idParaDest-169" class="title">Special functions and operators</h1>&#13;
    <p class="normal">There are a few special ways of writing functions, as well as some special operators that will come in handy. We are talking about arrow functions and the spread and rest operators here. Arrow functions are great for sending functions around as parameters and using shorter notations. The spread and rest operators make our lives easier and are more flexible when sending arguments and working with arrays.</p>&#13;
    <h2 id="_idParaDest-170" class="title">Arrow functions</h2>&#13;
    <p class="normal">Arrow functions are <a id="_idIndexMarker279"/>a special way of writing functions that can be confusing at first. Their use looks like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">(param1, param2) =&gt; body <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>;&#13;
</code></pre>&#13;
    <p class="normal">Or for no parameters:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">() =&gt; body <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>;&#13;
</code></pre>&#13;
    <p class="normal">Or for one parameter (no parentheses are needed here):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">param =&gt; body <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>;&#13;
</code></pre>&#13;
    <p class="normal">Or for a multiline function with two parameters:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">(param1, param2) =&gt; {&#13;
  <span class="hljs-comment">// line 1;</span>&#13;
  <span class="hljs-comment">// any number of lines;</span>&#13;
};&#13;
</code></pre>&#13;
    <p class="normal">Arrow functions are useful whenever you want to write an implementation on the spot, such as inside <a id="_idIndexMarker280"/>another function as an argument. This is because they are a shorthand notation for writing functions. They are most often used for functions that consist of only one statement. Let's start with a simple function that we will rewrite to an arrow function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(x);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">To rewrite this as an arrow function, you will have to store it in a variable or send it in as an argument if you want to be able to use it. We use the name of the variable to execute the arrow function. In this case we only have one parameter, so it's optional to surround it with parentheses. We can write it like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> doingArrowStuff = <span class="hljs-params">x</span><span class="hljs-function"> =&gt;</span> <span class="hljs-built_in">console</span>.log(x);&#13;
</code></pre>&#13;
    <p class="normal">And invoke it like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">doingArrowStuff(<span class="hljs-string">"Great!"</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will log <code class="Code-In-Text--PACKT-">Great!</code> to the console. If there is more than one argument, we will have to use parentheses, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> addTwoNumbers = <span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) =&gt;</span> <span class="hljs-built_in">console</span>.log(x + y);&#13;
</code></pre>&#13;
    <p class="normal">We can call it like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addTwoNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);&#13;
</code></pre>&#13;
    <p class="normal">And then it will log <code class="Code-In-Text--PACKT-">8</code> to the console. If there are no arguments, you must use the parentheses, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hi"</span>);&#13;
</code></pre>&#13;
    <p class="normal">If we call <code class="Code-In-Text--PACKT-">sayHi()</code>, it will log <code class="Code-In-Text--PACKT-">hi</code> to the console.</p>&#13;
    <p class="normal">As a final example, we can <a id="_idIndexMarker281"/>combine the arrow function with certain built-in methods. For example, we can use the <code class="Code-In-Text--PACKT-">foreach()</code> method on an array. This method executes a certain function for every element in the array. Have a look at this example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"squirrel"</span>, <span class="hljs-string">"alpaca"</span>, <span class="hljs-string">"buddy"</span>];&#13;
arr.forEach(<span class="hljs-params">e</span><span class="hljs-function"> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));&#13;
</code></pre>&#13;
    <p class="normal">It outputs:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">squirrel&#13;
alpaca&#13;
buddy&#13;
</code></pre>&#13;
    <p class="normal">For every element in the array, it takes the element as input and executing the arrow function for it. In this case, the function is to log the element. So the output is every single element in the array.</p>&#13;
    <p class="normal">Using arrow functions combined with built-in functions is very powerful. We can do something for every element in the array, without counting or writing a complicated loop. We'll see more examples of great use cases for arrow functions later on.</p>&#13;
    <h2 id="_idParaDest-171" class="title">Spread operator</h2>&#13;
    <p class="normal">The spread operator is a special operator. It consists of three dots used before a referenced expression <a id="_idIndexMarker282"/>or string, and it spreads out the arguments or elements of an array. </p>&#13;
    <p class="normal">This might sound very complicated, so let's look at a simple example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> spread = [<span class="hljs-string">"so"</span>, <span class="hljs-string">"much"</span>, <span class="hljs-string">"fun"</span>];&#13;
<span class="hljs-keyword">let</span> message = [<span class="hljs-string">"JavaScript"</span>, <span class="hljs-string">"is"</span>, ...spread, <span class="hljs-string">"and"</span>, <span class="hljs-string">"very"</span>,<span class="hljs-string">"powerful"</span>];&#13;
</code></pre>&#13;
    <p class="normal">The value of this array becomes:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">['JavaScript', 'is', 'so', 'much', 'fun', 'and', 'very', 'powerful']&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the elements of the spread operator become individual elements in the array. The spread operator spreads the array to individual elements in the new array. It can also be used to send <a id="_idIndexMarker283"/>multiple arguments to a function, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addTwoNumbers</span><span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(x + y); &#13;
} &#13;
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>];&#13;
addTwoNumbers(...arr);&#13;
</code></pre>&#13;
    <p class="normal">This will log <code class="Code-In-Text--PACKT-">14</code> to the console, since it is the same as calling the function with:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addTwoNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>);&#13;
</code></pre>&#13;
    <p class="normal">This operator avoids having to copy a long array or string into a function, which saves time and reduces code complexity. You can call a function with multiple spread operators. It will use all the elements of the arrays as input. Here's an example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addFourNumbers</span><span class="hljs-function">(</span><span class="hljs-params">x, y, z, a</span><span class="hljs-function">) </span>{ &#13;
  <span class="hljs-built_in">console</span>.log(x + y + z + a); &#13;
} &#13;
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>];&#13;
<span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>];&#13;
addFourNumbers(...arr, ...arr2);&#13;
</code></pre>&#13;
    <p class="normal">This will output <code class="Code-In-Text--PACKT-">27</code> to the console, calling the function like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">addFourNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-172" class="title">Rest parameter</h2>&#13;
    <p class="normal">Similar to the spread operator, we have the rest parameter. It has the same symbol as the spread operator, but it is <a id="_idIndexMarker284"/>used inside the function parameter list. Remember what would happen if we were to send an argument too many times, as here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">someFunction</span><span class="hljs-function">(</span><span class="hljs-params">param1, param2</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(param1, param2);&#13;
}&#13;
someFunction(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"there!"</span>, <span class="hljs-string">"How are you?"</span>);&#13;
</code></pre>&#13;
    <p class="normal">That's right. Nothing really: it would just pretend we only sent in two arguments and log <code class="Code-In-Text--PACKT-">hi there!</code>. If we use the rest parameter, it allows us to send in any number of arguments <a id="_idIndexMarker285"/>and translate them into a parameter array. Here is an example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">someFunction</span><span class="hljs-function">(</span><span class="hljs-params">param1, ...param2</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(param1, param2);&#13;
}&#13;
someFunction(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"there!"</span>, <span class="hljs-string">"How are you?"</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will log:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">hi [ 'there!', 'How are you?' ]&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the second parameter has changed into an array, containing our second and third arguments. This can be useful whenever you are not sure what number of arguments you will get. Using the rest parameter allows you to process this variable number of arguments, for example, using a loop.</p>&#13;
    <h1 id="_idParaDest-173" class="title">Returning function values</h1>&#13;
    <p class="normal">We are still missing a<a id="_idIndexMarker286"/> very important piece to make functions as useful as they are: the return value. Functions can give back a result when we specify a return value. The return value can be stored in a variable. We have done this already – remember <code class="Code-In-Text--PACKT-">prompt()</code>?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> favoriteSubject = prompt(<span class="hljs-string">"What is your favorite subject?"</span>);&#13;
</code></pre>&#13;
    <p class="normal">We are storing the result of our <code class="Code-In-Text--PACKT-">prompt()</code> function in the variable <code class="Code-In-Text--PACKT-">favoriteSubject</code>, which in this case would be whatever the user specifies. Let's see what happens if we store the result of our <code class="Code-In-Text--PACKT-">addTwoNumbers()</code> function and log that variable:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> result = addTwoNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);&#13;
<span class="hljs-built_in">console</span>.log(result);&#13;
</code></pre>&#13;
    <p class="normal">You may or may not have guessed it—this logs the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">9&#13;
undefined&#13;
</code></pre>&#13;
    <p class="normal">The value <code class="Code-In-Text--PACKT-">9</code> is written to the console because <code class="Code-In-Text--PACKT-">addTwoNumbers()</code> contains a <code class="Code-In-Text--PACKT-">console.log()</code> statement. The <code class="Code-In-Text--PACKT-">console.log(result)</code> line outputs <code class="Code-In-Text--PACKT-">undefined</code>, because nothing is inserted into the function to store the result, meaning our function <code class="Code-In-Text--PACKT-">addTwoNumbers()</code> does not send anything back. Since JavaScript does not like to cause trouble and crash, it will assign <code class="Code-In-Text--PACKT-">undefined</code>. To counter this, we can rewrite our <code class="Code-In-Text--PACKT-">addTwoNumbers()</code> function to actually return the value instead of logging it. This is much more powerful because <a id="_idIndexMarker287"/>we can store the result and continue working with the result of this function in the rest of our code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addTwoNumbers</span><span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-keyword">return</span> x + y;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">return</code> ends the function and sends back whatever value comes after <code class="Code-In-Text--PACKT-">return</code>. If it is an expression, like the one above, it will evaluate the expression to one result and then return that to where it was called (the <code class="Code-In-Text--PACKT-">result</code> variable, in this instance):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> result = addTwoNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);&#13;
<span class="hljs-built_in">console</span>.log(result);&#13;
</code></pre>&#13;
    <p class="normal">With these adjustments made, the code snippet logs <code class="Code-In-Text--PACKT-">9</code> to the terminal.</p>&#13;
    <p class="normal">What do you think this code does?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> resultsArr = [];&#13;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++){&#13;
  <span class="hljs-keyword">let</span> result = addTwoNumbers(i, <span class="hljs-number">2</span>*i);&#13;
  resultsArr.push(result);&#13;
}&#13;
<span class="hljs-built_in">console</span>.log(resultsArr);&#13;
</code></pre>&#13;
    <p class="normal">It logs an array of all the results to the screen. The function is being called in a loop. The first iteration, <code class="Code-In-Text--PACKT-">i</code>, equals <code class="Code-In-Text--PACKT-">0</code>. Therefore, the result is <code class="Code-In-Text--PACKT-">0</code>. The last iteration, <code class="Code-In-Text--PACKT-">i</code>, equals <code class="Code-In-Text--PACKT-">9</code>, and therefore the last value of the array equals <code class="Code-In-Text--PACKT-">27</code>. Here are the results:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">[&#13;
   0,  3,  6,  9, 12,&#13;
  15, 18, 21, 24, 27&#13;
]&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-174" class="title">Practice exercise 6.4</h2>&#13;
    <p class="normal">Modify the calculator that you made in <em class="italic">Practice exercise 6.2</em> to return added values instead of printing them. Then, call the function 10 or more times in a loop, and store the results in an array. Once the loop finishes, output the final array into the console.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Set up an empty array to store the values that will be calculated within the loop.</li>&#13;
      <li class="numbered">Create a loop that runs 10 times, incrementing by 1 each time, creating two values each iteration. For the first value, multiply the value of the loop count by 5. For the second value, multiply the value of the loop counter by itself.</li>&#13;
      <li class="numbered">Create a function that returns the value of the two parameters passed into the function when it is called. Add the values together, returning the result.</li>&#13;
      <li class="numbered">Within the loop, call the calculation function, passing in the two values as arguments into the function and storing the returned result in a response variable.</li>&#13;
      <li class="numbered">Still within the loop, push the result values into the array as it iterates through the loop.</li>&#13;
      <li class="numbered">After the loop is complete, output the value of the array into the console.</li>&#13;
      <li class="numbered">You should see the values <code class="Code-In-Text--PACKT-">[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]</code> for the array in the console.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-175" class="title">Returning with arrow functions</h2>&#13;
    <p class="normal">If we have a one-line arrow function, we can return without using the keyword <code class="Code-In-Text--PACKT-">return</code>. So if we want to <a id="_idIndexMarker288"/>rewrite the function, we can write it like this to make an arrow function out of it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> addTwoNumbers = <span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) =&gt;</span> x + y;&#13;
</code></pre>&#13;
    <p class="normal">And we can call it and store the result like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> result = addTwoNumbers(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>);&#13;
<span class="hljs-built_in">console</span>.log(result);&#13;
</code></pre>&#13;
    <p class="normal">This will then log <code class="Code-In-Text--PACKT-">27</code> to the console. If it's a multiline function, you will have to use the keyword <code class="Code-In-Text--PACKT-">return</code> as demonstrated in the previous section. So, for example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> addTwoNumbers = <span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) =&gt;</span> {&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Adding..."</span>);&#13;
  <span class="hljs-keyword">return</span> x + y;&#13;
}&#13;
</code></pre>&#13;
    <h1 id="_idParaDest-176" class="title">Variable scope in functions</h1>&#13;
    <p class="normal">In this section, we will discuss a topic that is often considered challenging. We will talk about scope. Scope defines where you can access a certain variable. When a variable is <em class="italic">in scope</em>, you can access it. When a variable is <em class="italic">out of scope</em>, you cannot access the variable. We will discuss this for both local and global variables.</p>&#13;
    <h2 id="_idParaDest-177" class="title">Local variables in functions</h2>&#13;
    <p class="normal">Local variables are only in scope within the function they are defined. This is true for <code class="Code-In-Text--PACKT-">let</code> variables and <code class="Code-In-Text--PACKT-">var</code> variables. There is a difference between them, which we will touch upon here as well. The<a id="_idIndexMarker289"/> function <a id="_idIndexMarker290"/>parameters (they do not use <code class="Code-In-Text--PACKT-">let</code> or <code class="Code-In-Text--PACKT-">var</code>) are also local variables. This might sound very vague, but the next code snippet will demonstrate what this means:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">testAvailability</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Available here:"</span>, x);&#13;
}&#13;
testAvailability(<span class="hljs-string">"Hi!"</span>);&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not available here:"</span>, x);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Available here: Hi!&#13;
ReferenceError: x is not defined&#13;
</code></pre>&#13;
    <p class="normal">When called inside the function, <code class="Code-In-Text--PACKT-">x</code> will be logged. The statement outside of the function fails, because <code class="Code-In-Text--PACKT-">x</code> is a local variable to the function <code class="Code-In-Text--PACKT-">testAvailability()</code>. This is showing that the function parameters are not accessible outside of the function. </p>&#13;
    <p class="normal">They are out of scope outside the function and in scope inside the function. Let's have a look at a variable defined inside a function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">testAvailability</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">let</span> y = <span class="hljs-string">"Local variable!"</span>;&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Available here:"</span>, y);&#13;
}&#13;
testAvailability();&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not available here:"</span>, y);&#13;
</code></pre>&#13;
    <p class="normal">This shows the following on the console:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Available here: Local variable!&#13;
ReferenceError: y is not defined&#13;
</code></pre>&#13;
    <p class="normal">Variables defined inside the function are not available outside the function either.</p>&#13;
    <p class="normal">For beginners, it can be confusing to combine local variables and <code class="Code-In-Text--PACKT-">return</code>. Right now, we're telling you the local variables declared inside a function are not available outside of the function, but <a id="_idIndexMarker291"/>with <code class="Code-In-Text--PACKT-">return</code> you can make their values available outside the function. So if you need their values outside a function, you can return the values. The key word here is <em class="italic">values</em>! You cannot return the variable itself. Instead, a value can be caught<a id="_idIndexMarker292"/> and stored in a different variable, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">testAvailability</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">let</span> y = <span class="hljs-string">"I'll return"</span>;&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Available here:"</span>, y);&#13;
  <span class="hljs-keyword">return</span> y;&#13;
}&#13;
<span class="hljs-keyword">let</span> z = testAvailability();&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Outside the function:"</span>, z);&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not available here:"</span>, y);&#13;
</code></pre>&#13;
    <p class="normal">So, the returned value <code class="Code-In-Text--PACKT-">I'll return</code> that was assigned to local variable <code class="Code-In-Text--PACKT-">y</code> gets returned and stored in variable <code class="Code-In-Text--PACKT-">z</code>.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">This variable <code class="Code-In-Text--PACKT-">z</code> could actually also have been called <code class="Code-In-Text--PACKT-">y</code>, but that would have been confusing since it still would have been a different variable.</p>&#13;
    </div>&#13;
    <p class="normal">The output of this code snippet is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Available here: I'll return&#13;
Outside the function: I'll return&#13;
ReferenceError: y is not defined&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-178" class="title">let versus var variables</h3>&#13;
    <p class="normal">The difference between <code class="Code-In-Text--PACKT-">let</code> and <code class="Code-In-Text--PACKT-">var</code> is that <code class="Code-In-Text--PACKT-">var</code> is function-scoped, which is the concept we described above. <code class="Code-In-Text--PACKT-">let</code> is <a id="_idIndexMarker293"/>actually not function-scoped <a id="_idIndexMarker294"/>but block-scoped. A block is defined by two curly braces <code class="Code-In-Text--PACKT-">{ }</code>. The code within those braces is where <code class="Code-In-Text--PACKT-">let</code> is still available.</p>&#13;
    <p class="normal">Let's see this distinction in action:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {&#13;
    <span class="hljs-keyword">var</span> x = <span class="hljs-string">"local"</span>;&#13;
  }&#13;
  <span class="hljs-built_in">console</span>.log(x);&#13;
}&#13;
doingStuff();&#13;
</code></pre>&#13;
    <p class="normal">The output of this snippet will be:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">local&#13;
</code></pre>&#13;
    <p class="normal">If we use <code class="Code-In-Text--PACKT-">var</code>, the <a id="_idIndexMarker295"/>variable becomes function-scoped and is <a id="_idIndexMarker296"/>available anywhere in the function block (even before defining with the value undefined). Thus, after the <code class="Code-In-Text--PACKT-">if</code> block has ended, <code class="Code-In-Text--PACKT-">x</code> can still be accessed.</p>&#13;
    <p class="normal">Here is what happens with <code class="Code-In-Text--PACKT-">let</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {&#13;
    <span class="hljs-keyword">let</span> x = <span class="hljs-string">"local"</span>;&#13;
  }&#13;
  <span class="hljs-built_in">console</span>.log(x);&#13;
}&#13;
doingStuff();&#13;
</code></pre>&#13;
    <p class="normal">This will produce the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">ReferenceError: x is not defined&#13;
</code></pre>&#13;
    <p class="normal">Here we get the error that <code class="Code-In-Text--PACKT-">x is not defined</code>. Since <code class="Code-In-Text--PACKT-">let</code> is only block-scoped, <code class="Code-In-Text--PACKT-">x</code> goes out of scope when the <code class="Code-In-Text--PACKT-">if</code> block ends and can no longer be accessed after that. </p>&#13;
    <p class="normal">A final difference between <code class="Code-In-Text--PACKT-">let</code> and <code class="Code-In-Text--PACKT-">var</code> relates to the order of declaration in a script. Try using the value of <code class="Code-In-Text--PACKT-">x</code> before having defined it with <code class="Code-In-Text--PACKT-">let</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">() </span>{ &#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) { &#13;
    <span class="hljs-built_in">console</span>.log(x);&#13;
    <span class="hljs-keyword">let</span> x = <span class="hljs-string">"local"</span>; &#13;
  } &#13;
}&#13;
doingStuff();&#13;
</code></pre>&#13;
    <p class="normal">This will give a <code class="Code-In-Text--PACKT-">ReferenceError</code> that <code class="Code-In-Text--PACKT-">x</code> is not initialized. This is because variables declared <a id="_idIndexMarker297"/>with <code class="Code-In-Text--PACKT-">let</code> cannot be accessed before being defined, even <a id="_idIndexMarker298"/>within the same block. What do you think will happen for a <code class="Code-In-Text--PACKT-">var</code> declaration like this?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">() </span>{ &#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) { &#13;
    <span class="hljs-built_in">console</span>.log(x);&#13;
    <span class="hljs-keyword">var</span> x = <span class="hljs-string">"local"</span>;&#13;
  }&#13;
}&#13;
doingStuff();&#13;
</code></pre>&#13;
    <p class="normal">This time, we won't get an error. When we use a <code class="Code-In-Text--PACKT-">var</code> variable before the <code class="Code-In-Text--PACKT-">define</code> statement, we simply get <code class="Code-In-Text--PACKT-">undefined</code>. This is due to a phenomenon called hoisting, which means using a <code class="Code-In-Text--PACKT-">var</code> variable before it's been declared results in the variable being <code class="Code-In-Text--PACKT-">undefined</code> rather than giving a <code class="Code-In-Text--PACKT-">ReferenceError</code>.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Hoisting, and how to negate its effects if needed, are more complex topics that we will cover in <em class="chapterRef">Chapter 12</em>, <em class="italic">Intermediate JavaScript</em>. </p>&#13;
    </div>&#13;
    <h3 id="_idParaDest-179" class="title">const scope</h3>&#13;
    <p class="normal">Constants are block-scoped, just like <code class="Code-In-Text--PACKT-">let</code>. This is why the scope rules here are similar to those for <code class="Code-In-Text--PACKT-">let</code>. Here <a id="_idIndexMarker299"/>is an example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {&#13;
    <span class="hljs-keyword">const</span> X = <span class="hljs-string">"local"</span>;&#13;
  }&#13;
  <span class="hljs-built_in">console</span>.log(X);&#13;
}&#13;
doingStuff();&#13;
</code></pre>&#13;
    <p class="normal">This will produce the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">ReferenceError: X is not defined&#13;
</code></pre>&#13;
    <p class="normal">Using a <code class="Code-In-Text--PACKT-">const</code> variable before <a id="_idIndexMarker300"/>having defined it will also give a <code class="Code-In-Text--PACKT-">ReferenceError</code>, just as it does for a <code class="Code-In-Text--PACKT-">let</code> variable.</p>&#13;
    <h2 id="_idParaDest-180" class="title">Global variables</h2>&#13;
    <p class="normal">As you might have guessed, global variables are variables declared outside a function and not in some other <a id="_idIndexMarker301"/>code block. Variables are accessible in the scope (either function or block) where they're defined, plus any "lower" scopes. So, a variable defined outside of a function is available within the function as well as inside any functions or other code blocks inside that function. A variable defined at the top level of your program is therefore available everywhere in your program. This concept is called a global variable. You can see an example here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> globalVar = <span class="hljs-string">"Accessible everywhere!"</span>;&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Outside function:"</span>, globalVar);&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">creatingNewScope</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Access to global vars inside function."</span> , globalVar);&#13;
}&#13;
creatingNewScope(<span class="hljs-string">"some parameter"</span>);&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Still available:"</span>, globalVar);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Outside function: Accessible everywhere!&#13;
Access to global vars inside function. Accessible everywhere!&#13;
Still available: Accessible everywhere!&#13;
</code></pre>&#13;
    <p class="normal">As you can see, global variables are accessible from everywhere because they are not declared in a block. They are <em class="italic">always</em> in scope after they have been defined—it doesn't matter where you use them. However, you can hide their accessibility inside a function by specifying a new variable with the same name inside that scope; this can be done for <code class="Code-In-Text--PACKT-">let</code>, <code class="Code-In-Text--PACKT-">var</code>, and <code class="Code-In-Text--PACKT-">const</code>. (This is not changing the value of the <code class="Code-In-Text--PACKT-">const</code> variable; you are creating a new <code class="Code-In-Text--PACKT-">const</code> variable that is going to override the first one in the inner scope.) In the same scope, you cannot specify two <code class="Code-In-Text--PACKT-">let</code> or two <code class="Code-In-Text--PACKT-">const</code> variables with the same name. You can do so for <code class="Code-In-Text--PACKT-">var</code>, but you shouldn't do so, in order to avoid confusion.</p>&#13;
    <p class="normal">If you create a variable with the same name inside a function, that variable's value will be used whenever you refer to that variable name within the scope of that particular function. Here you can see an example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> x = <span class="hljs-string">"global"</span>;&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">let</span> x = <span class="hljs-string">"local"</span>;&#13;
  <span class="hljs-built_in">console</span>.log(x);&#13;
}&#13;
doingStuff();&#13;
<span class="hljs-built_in">console</span>.log(x);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">local&#13;
global&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the value of <code class="Code-In-Text--PACKT-">x</code> inside the <code class="Code-In-Text--PACKT-">doingStuff()</code> function is <code class="Code-In-Text--PACKT-">local</code>. However, outside the function <a id="_idIndexMarker302"/>the value is still <code class="Code-In-Text--PACKT-">global</code>. This means that you'll have to be extra careful about mixing up names in local and global scopes. It is usually better to avoid this.</p>&#13;
    <p class="normal">The same is also true for parameter names. If you have the same parameter name as a global variable, the value of the parameter will be used:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> x = <span class="hljs-string">"global"</span>;&#13;
 &#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuff</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(x); &#13;
} &#13;
 &#13;
doingStuff(<span class="hljs-string">"param"</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will log <code class="Code-In-Text--PACKT-">param</code>.</p>&#13;
    <p class="normal">There is a danger in relying on global variables too much. This is something you will come across soon when your applications grow. As we just saw, local variables override the value of global variables. It is best to work with local variables in functions; this way, you have more control over what you are working with. This might be a bit vague for now, but it will become clear when coding in the wild as things get bigger and more lines and files of code get involved.</p>&#13;
    <p class="normal">There is only one more very important point to be made about scopes for now. Let's start with an example and see if you can figure out what this should log:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">confuseReader</span><span class="hljs-function">() </span>{&#13;
  x = <span class="hljs-string">"Guess my scope..."</span>;&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inside the function:"</span>, x);&#13;
}&#13;
confuseReader();&#13;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Outside of function:"</span>, x);&#13;
</code></pre>&#13;
    <p class="normal">Answer ready? Here is the output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Inside the function: Guess my scope...&#13;
Outside of function: Guess my scope...&#13;
</code></pre>&#13;
    <p class="normal">Do not close the book—we'll explain what is going on. If you look carefully, the <code class="Code-In-Text--PACKT-">x</code> in the function gets defined without the keyword <code class="Code-In-Text--PACKT-">let</code> or <code class="Code-In-Text--PACKT-">var</code>. There is no declaration of <code class="Code-In-Text--PACKT-">x</code> above the code; this is <a id="_idIndexMarker303"/>all the code of the program. JavaScript does not see <code class="Code-In-Text--PACKT-">let</code> or <code class="Code-In-Text--PACKT-">var</code> and then decides, "this must be a global variable." Even though it gets defined inside the function, the declaration of <code class="Code-In-Text--PACKT-">x</code> within the function gets global scope and can still be accessed outside of the function.</p>&#13;
    <p class="normal">We really want to emphasize that this is a terrible practice. If you need a global variable, declare it at the top of your file.</p>&#13;
    <h2 id="_idParaDest-181" class="title">Immediately invoked function expression</h2>&#13;
    <p class="normal">The <strong class="keyword">immediately invoked function expression</strong> (<strong class="keyword">IIFE</strong>) is a way of expressing a function so that it gets <a id="_idIndexMarker304"/>invoked immediately. It is anonymous, it doesn't have a name, and it is self-executing.</p>&#13;
    <p class="normal">This can be useful when you want to initialize something using this function. It is also used in many design patterns, for example, to create private and public variables and functions. </p>&#13;
    <p class="normal">This has to do with where functions and variables are accessible from. If you have an IIFE in the top-level scope, whatever is in there is not accessible from outside even though it is top level.</p>&#13;
    <p class="normal">Here is how to define it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">(<span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"IIFE!"</span>);&#13;
})();&#13;
</code></pre>&#13;
    <p class="normal">The function itself is surrounded by parentheses, which makes it create a function instance. Without these parentheses around it, it would throw an error because our function does not have a name (this is worked around by assigning the function to a variable, though, where the output can be returned to the variable).</p>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">();</code> executes the unnamed function—this must be done immediately following a function declaration. If your function were to require a parameter, you would pass it in within these final brackets.</p>&#13;
    <p class="normal">You could also combine IIFE with other function patterns. For example, you could use an arrow function here <a id="_idIndexMarker305"/>to make the function even more concise:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">(<span class="hljs-function">()=&gt;</span>{&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"run right away"</span>);&#13;
})();&#13;
</code></pre>&#13;
    <p class="normal">Again, we use <code class="Code-In-Text--PACKT-">();</code> to invoke the function that you created.</p>&#13;
    <h3 id="_idParaDest-182" class="title">Practice exercise 6.5</h3>&#13;
    <p class="normal">Use IIFE to create a few immediately invoked functions and observe how the scope is affected.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a variable value with <code class="Code-In-Text--PACKT-">let</code> and assign a string value of 1000 to it.</li>&#13;
      <li class="numbered">Create an IIFE function and within this function scope assign a new value to a variable of the same name. Within the function, print the local value to the console.</li>&#13;
      <li class="numbered">Create an IIFE expression, assigning it to a new <code class="Code-In-Text--PACKT-">result</code> variable, and assign a new value to a variable of the same name within this scope. Return this local value to the <code class="Code-In-Text--PACKT-">result</code> variable and invoke the function. Print the <code class="Code-In-Text--PACKT-">result</code> variable, along with the variable name you've been using: what value does it contain now?</li>&#13;
      <li class="numbered">Lastly, create an anonymous function that has a parameter. Add logic that will assign a passed-in value to the same variable name as the other steps, and print it as part of a string sentence. Invoke the function and pass in your desired value within the rounded brackets.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-183" class="title">Recursive functions</h1>&#13;
    <p class="normal">In some cases, you want to call the same function from inside the function. It can be a beautiful solution to <a id="_idIndexMarker306"/>rather complex problems. There are some things to keep in mind though. What do you think this will do?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">getRecursive</span><span class="hljs-function">(</span><span class="hljs-params">nr</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(nr);&#13;
  getRecursive(--nr);&#13;
}&#13;
getRecursive(<span class="hljs-number">3</span>);&#13;
</code></pre>&#13;
    <p class="normal">It prints <code class="Code-In-Text--PACKT-">3</code> and then counts down and never stops. Why is it not stopping? Well, we are not saying when <a id="_idIndexMarker307"/>it should stop. Look at our improved version:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">getRecursive</span><span class="hljs-function">(</span><span class="hljs-params">nr</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(nr);&#13;
  <span class="hljs-keyword">if</span> (nr &gt; <span class="hljs-number">0</span>) {&#13;
    getRecursive(--nr);&#13;
  }&#13;
}&#13;
getRecursive(<span class="hljs-number">3</span>);&#13;
</code></pre>&#13;
    <p class="normal">This function is going to call itself until the value of the parameter is no longer bigger than <code class="Code-In-Text--PACKT-">0</code>. And then it stops.</p>&#13;
    <p class="normal">What happens when we call a function recursively is that it goes one function deeper every time. The first function call is done last. For this function it goes like this:</p>&#13;
    <ul>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">getRecursive(3)</code>&#13;
        <ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">getRecursive(2)</code>&#13;
          <ul>&#13;
			<li class="bullet-l2"><code class="Code-In-Text--PACKT-">getRecursive(1)</code>&#13;
			<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">getRecursive(0)</code></li>&#13;
          <li class="bullet-l2">done with <code class="Code-In-Text--PACKT-">getRecursive(0)</code> execution</li>&#13;
			</ul></li>&#13;
          <li class="bullet-l2">done with <code class="Code-In-Text--PACKT-">getRecursive(1)</code> execution</li>&#13;
			</ul></li>&#13;
          <li class="bullet-l2">done with <code class="Code-In-Text--PACKT-">getRecursive(2)</code> execution</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bullet">done with <code class="Code-In-Text--PACKT-">getRecursive(3)</code> execution</li>&#13;
    </ul>&#13;
    <p class="normal">The next recursive function will demonstrate that:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">logRecursive</span><span class="hljs-function">(</span><span class="hljs-params">nr</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Started function:"</span>, nr);&#13;
  <span class="hljs-keyword">if</span> (nr &gt; <span class="hljs-number">0</span>) {&#13;
    logRecursive(nr - <span class="hljs-number">1</span>);&#13;
  } <span class="hljs-keyword">else</span> {&#13;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"done with recursion"</span>);&#13;
  }&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ended function:"</span>, nr);&#13;
}&#13;
logRecursive(<span class="hljs-number">3</span>);&#13;
</code></pre>&#13;
    <p class="normal">It will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Started function: 3&#13;
Started function: 2&#13;
Started function: 1&#13;
Started function: 0&#13;
done with recursion&#13;
Ended function: 0&#13;
Ended function: 1&#13;
Ended function: 2&#13;
Ended function: 3&#13;
</code></pre>&#13;
    <p class="normal">Recursive functions can be great in some contexts. When you feel the need to call the same function over and over again in a loop, you should probably consider recursion. An example could also <a id="_idIndexMarker308"/>be searching for something. Instead of looping over everything inside the same function, you can split up inside the function and call the function repeatedly from the inside.</p>&#13;
    <p class="normal">However, it must be kept in mind that in general, the performance of recursion is slightly worse than the performance of regular iteration using a loop. So if this causes a bottleneck situation that would really slow down your application, then you might want to consider another approach.</p>&#13;
    <p class="normal">Have a look at calculating the factorial using recursive functions in the following exercise.</p>&#13;
    <h2 id="_idParaDest-184" class="title">Practice exercise 6.6</h2>&#13;
    <p class="normal">A common problem that we can solve with recursion is calculating the factorial.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Quick mathematics refresher about factorials:</p>&#13;
      <p class="Information-Box--PACKT-">The factorial of a number is the product of all positive integers bigger than 0, up to the number itself. So for example, the factorial of seven is 7 * 6 * 5 * 4 * 3 * 2 * 1. You can write this as 7!.</p>&#13;
    </div>&#13;
    <p class="normal">How are recursive functions going to help us calculate the factorial? We are going to call the function with a lower number until we reach 0. In this exercise, we will use recursion to calculate the factorial result of a numeric value set as the argument of a function.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a function that contains a condition within it checking if the argument value is <code class="Code-In-Text--PACKT-">0</code>.</li>&#13;
      <li class="numbered">If the parameter is equal to <code class="Code-In-Text--PACKT-">0</code>, it should return the value of <code class="Code-In-Text--PACKT-">1</code>. Otherwise, it should return the value of the argument multiplied by the value returned from the function itself, subtracting one from the value of the argument that is provided. This will result in running the block of code until the value reaches <code class="Code-In-Text--PACKT-">0</code>.</li>&#13;
      <li class="numbered">Invoke the function, providing an argument of whatever number you want to find the factorial of. The code should run whatever number is passed initially into the function, decreasing all the way to <code class="Code-In-Text--PACKT-">0</code> and outputting the results of the calculation to the console. It could also contain a <code class="Code-In-Text--PACKT-">console.log()</code> call to print the current value of the argument in the function as it gets invoked.</li>&#13;
      <li class="numbered">Change and update the number to see how it affects the results.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-185" class="title">Nested functions</h1>&#13;
    <p class="normal">Just as with loops, <code class="Code-In-Text--PACKT-">if</code> statements, and actually all other building blocks, we can have functions <a id="_idIndexMarker309"/>inside functions. This phenomenon is called nested functions:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doOuterFunctionStuff</span><span class="hljs-function">(</span><span class="hljs-params">nr</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Outer function"</span>);&#13;
  doInnerFunctionStuff(nr);&#13;
  <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doInnerFunctionStuff</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-built_in">console</span>.log(x + <span class="hljs-number">7</span>);&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I can access outer variables:"</span>, nr);&#13;
  }&#13;
}&#13;
doOuterFunctionStuff(<span class="hljs-number">2</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Outer function&#13;
9&#13;
I can access outer variables: 2&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the outer function is calling its nested function. This nested function has access to the variables of the parent. The other way around, this is not the case. Variables defined inside the inner function have function scope. This means they are accessible inside <a id="_idIndexMarker310"/>the function where they are defined, which is in this case the inner function. Thus, this will throw a <code class="Code-In-Text--PACKT-">ReferenceError</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doOuterFunctionStuff</span><span class="hljs-function">(</span><span class="hljs-params">nr</span><span class="hljs-function">) </span>{&#13;
  doInnerFunctionStuff(nr);&#13;
  <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doInnerFunctionStuff</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">let</span> z = <span class="hljs-number">10</span>;&#13;
  }&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not accessible:"</span>, z);&#13;
}&#13;
doOuterFunctionStuff(<span class="hljs-number">2</span>);&#13;
</code></pre>&#13;
    <p class="normal">What do you think this will do?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doOuterFunctionStuff</span><span class="hljs-function">(</span><span class="hljs-params">nr</span><span class="hljs-function">) </span>{&#13;
  doInnerFunctionStuff(nr);&#13;
  <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doInnerFunctionStuff</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">let</span> z = <span class="hljs-number">10</span>;&#13;
  }&#13;
}&#13;
doInnerFunctionStuff(<span class="hljs-number">3</span>);&#13;
</code></pre>&#13;
    <p class="normal">This will also throw a <code class="Code-In-Text--PACKT-">ReferenceError</code>. Now, <code class="Code-In-Text--PACKT-">doInnerFunctionStuff()</code> is defined inside the outer function, which means that it is only in scope inside <code class="Code-In-Text--PACKT-">doOuterFunctionStuff()</code>. Outside this function, it is out of scope.</p>&#13;
    <h2 id="_idParaDest-186" class="title">Practice exercise 6.7</h2>&#13;
    <p class="normal">Create a countdown loop starting at a dynamic value of <code class="Code-In-Text--PACKT-">10</code>.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Set the <code class="Code-In-Text--PACKT-">start</code> variable at a value of <code class="Code-In-Text--PACKT-">10</code>, which will be used as the starting value for the loop.</li>&#13;
      <li class="numbered">Create a function that takes one argument, which is the countdown value.</li>&#13;
      <li class="numbered">Within the function, output the current value of the countdown into the console.</li>&#13;
      <li class="numbered">Add a condition to check if the value is less than 1; if it is, then return the function.</li>&#13;
      <li class="numbered">Add a condition to check if the value of the countdown is not less than 1, then continue to loop by calling the function within itself.</li>&#13;
      <li class="numbered">Make sure you add a decrement operator on the countdown so the preceding condition eventually will be true to end the loop. Every time it loops, the value will decrease until it reaches 0.</li>&#13;
      <li class="numbered">Update and create a second countdown using a condition if the value is greater than 0. If it is, decrease the value of the countdown by 1.</li>&#13;
      <li class="numbered">Use <code class="Code-In-Text--PACKT-">return</code> to return the function, which then invokes it again and again until the condition is no longer true.</li>&#13;
      <li class="numbered">Make sure, when you send the new countdown value as an argument into the function, that there is a way out of the loop by using the <code class="Code-In-Text--PACKT-">return</code> keyword and a condition that continues the loop if met.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-187" class="title">Anonymous functions</h1>&#13;
    <p class="normal">So far, we have been naming our functions. We can also create functions without names if we store <a id="_idIndexMarker311"/>them inside variables. We call these functions anonymous. Here is a non-anonymous function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doingStuffAnonymously</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not so secret though."</span>);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Here is how to turn the previous function into an anonymous function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not so secret though."</span>);&#13;
};&#13;
</code></pre>&#13;
    <p class="normal">As you can see, our function has no name. It is anonymous. So you may wonder how you can invoke this function. Well actually, you can't like this!</p>&#13;
    <p class="normal">We will have to store it in a variable in order to call the anonymous function; we can store it like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> functionVariable = <span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not so secret though."</span>);&#13;
};&#13;
</code></pre>&#13;
    <p class="normal">An anonymous function can be called using the variable name, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">functionVariable();&#13;
</code></pre>&#13;
    <p class="normal">It will simply output <code class="Code-In-Text--PACKT-">Not so secret though.</code>.</p>&#13;
    <p class="normal">This might seem <a id="_idIndexMarker312"/>a bit useless, but it is a very powerful JavaScript construct. Storing functions inside variables enables us to do very cool things, like passing in functions as parameters. This concept adds another abstract layer to coding. This concept is called callbacks, and we will discuss it in the next section.</p>&#13;
    <h2 id="_idParaDest-188" class="title">Practice exercise 6.8</h2>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Set a variable name and assign a function to it. Create a function expression with one parameter that outputs a provided argument to the console.</li>&#13;
      <li class="numbered">Pass an argument into the function.</li>&#13;
      <li class="numbered">Create the same function as a normal function declaration.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-189" class="title">Function callbacks</h2>&#13;
    <p class="normal">Here is an example of passing a function as an argument to another function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doFlexibleStuff</span><span class="hljs-function">(</span><span class="hljs-params">executeStuff</span><span class="hljs-function">) </span>{&#13;
  executeStuff();&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inside doFlexibleStuffFunction."</span>);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">If we call this new <a id="_idIndexMarker313"/>function with our previously made anonymous function, <code class="Code-In-Text--PACKT-">functionVariable</code>, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">doFlexibleStuff(functionVariable);&#13;
</code></pre>&#13;
    <p class="normal">It will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Not so secret though.&#13;
Inside doFlexibleStuffFunction.&#13;
</code></pre>&#13;
    <p class="normal">But we can also call it with another function, and then our <code class="Code-In-Text--PACKT-">doFlexibleStuff</code> function will execute this other function. How cool is that?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> anotherFunctionVariable = <span class="hljs-keyword">function</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Another anonymous function implementation."</span>);&#13;
}&#13;
doFlexibleStuff(anotherFunctionVariable);&#13;
</code></pre>&#13;
    <p class="normal">This will produce the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Another anonymous function implementation.&#13;
Inside doFlexibleStuffFunction.&#13;
</code></pre>&#13;
    <p class="normal">So what happened? We created a function and stored it in the <code class="Code-In-Text--PACKT-">anotherFunctionVariable</code> variable. We then sent that in as a function parameter to our <code class="Code-In-Text--PACKT-">doFlexibleStuff()</code> function. And this function is simply executing whatever function gets sent in.</p>&#13;
    <p class="normal">At this point you may wonder why the writers are so excited about this callback concept. It probably <a id="_idIndexMarker314"/>looks rather lame in the examples you have seen so far. Once we get to asynchronous functions later on, this concept is going to be of great help. To still satisfy your need for a more concrete example, we will give you one.</p>&#13;
    <p class="normal">In JavaScript, there are many built-in functions, as you may know by now. One of them is the <code class="Code-In-Text--PACKT-">setTimeout()</code> function. It is a very special function that is executing a certain function after a specified amount of time that it will wait first. It is also seemingly responsible for quite a few terribly performing web pages, but that is definitely not the fault of this poor misunderstood and misused function.</p>&#13;
    <p class="normal">This code is really something you should try to understand:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> youGotThis = <span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You're doing really well, keep coding!"</span>);&#13;
};&#13;
<span class="hljs-built_in">setTimeout</span>(youGotThis, <span class="hljs-number">1000</span>);&#13;
</code></pre>&#13;
    <p class="normal">It is going to wait for <code class="Code-In-Text--PACKT-">1000</code>ms (one second) and then print:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">You're doing really well, keep coding!&#13;
</code></pre>&#13;
    <p class="normal">If you need more encouragement, you can use the <code class="Code-In-Text--PACKT-">setInterval()</code> function instead. It works very similarly, but instead of executing the specified function once, it will keep on executing it with the specified interval:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">setInterval</span>(youGotThis, <span class="hljs-number">1000</span>);&#13;
</code></pre>&#13;
    <p class="normal">In this case, it will print our encouraging message every second until you kill the program.</p>&#13;
    <p class="normal">This concept of the function executing the function after having been called itself is very useful for managing asynchronous program execution.</p>&#13;
    <h1 id="_idParaDest-190" class="title">Chapter projects</h1>&#13;
    <h2 id="_idParaDest-191" class="title">Create a recursive function</h2>&#13;
    <p class="normal">Create a recursive function that counts up to 10. Invoke the function with different start numbers as the arguments <a id="_idIndexMarker315"/>that are passed into the function. The function should run until the value is greater than 10.</p>&#13;
    <h2 id="_idParaDest-192" class="title">Set timeout order</h2>&#13;
    <p class="normal">Use the arrow format to create functions that output the values <code class="Code-In-Text--PACKT-">one</code> and <code class="Code-In-Text--PACKT-">two</code> to the console. Create a third function that outputs the value <code class="Code-In-Text--PACKT-">three</code> to the console, and then invokes the first two functions.</p>&#13;
    <p class="normal">Create a fourth function that <a id="_idIndexMarker316"/>outputs the word <code class="Code-In-Text--PACKT-">four</code> to the console and also use <code class="Code-In-Text--PACKT-">setTimeout()</code> to invoke the first function immediately and then the third function.</p>&#13;
    <p class="normal">What does your output look like in the console? Try to get the console to output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Four&#13;
Three&#13;
One&#13;
Two&#13;
One&#13;
</code></pre>&#13;
    <h1 id="_idParaDest-193" class="title">Self-check quiz</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">What value is output into the console?&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> val = <span class="hljs-number">10</span>;&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">tester</span><span class="hljs-function">(</span><span class="hljs-params">val</span><span class="hljs-function">)</span>{&#13;
    val += <span class="hljs-number">10</span>;&#13;
    <span class="hljs-keyword">if</span>(val &lt; <span class="hljs-number">100</span>){&#13;
        <span class="hljs-keyword">return</span> tester(val);&#13;
    }&#13;
    <span class="hljs-keyword">return</span> val;&#13;
}&#13;
tester(val);&#13;
<span class="hljs-built_in">console</span>.log(val);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What will be output into the console by the below code?&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> testFunction = <span class="hljs-keyword">function</span><span class="hljs-function">()</span>{&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello"</span>);&#13;
}();&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What will be output to the console?&#13;
        <pre class="programlisting code"><code class="hljs-code">(<span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Welcome"</span>);&#13;
})();&#13;
(<span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
    <span class="hljs-keyword">let</span> firstName = <span class="hljs-string">"Laurence"</span>;&#13;
})();&#13;
<span class="hljs-keyword">let</span> result = (<span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{&#13;
    <span class="hljs-keyword">let</span> firstName = <span class="hljs-string">"Laurence"</span>;&#13;
    <span class="hljs-keyword">return</span> firstName;&#13;
})();&#13;
<span class="hljs-built_in">console</span>.log(result);&#13;
(<span class="hljs-keyword">function</span><span class="hljs-function"> (</span><span class="hljs-params">firstName</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"My Name is "</span> + firstName);&#13;
})(<span class="hljs-string">"Laurence"</span>);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What will be output to the console?&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> test2 = <span class="hljs-function">(</span><span class="hljs-params">num</span><span class="hljs-function">) =&gt;</span> num + <span class="hljs-number">5</span>;&#13;
<span class="hljs-built_in">console</span>.log(test2(<span class="hljs-number">14</span>));&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What will be output to the console?&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> addFive1 = <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addFive1</span><span class="hljs-function">(</span><span class="hljs-params">num</span><span class="hljs-function">) </span>{&#13;
<span class="hljs-keyword">return</span> num + <span class="hljs-number">2</span>;&#13;
};&#13;
<span class="hljs-keyword">let</span> addFive2 = <span class="hljs-function">(</span><span class="hljs-params">num</span><span class="hljs-function">) =&gt;</span> num + <span class="hljs-number">2</span>;&#13;
<span class="hljs-built_in">console</span>.log(addFive1(<span class="hljs-number">14</span>));&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-194" class="title">Summary</h1>&#13;
    <p class="normal">In this chapter, we have covered functions. Functions are a great JavaScript building block that we can use to reuse lines of code. We can give our functions parameters, so that we can change the code depending on the arguments a function gets invoked with. Functions can return a result; we do so using the <code class="Code-In-Text--PACKT-">return</code> keyword. And we can use <code class="Code-In-Text--PACKT-">return</code> at the place where we call a function. We can store the result in a variable or use it in another function, for example.</p>&#13;
    <p class="normal">We then met with variable scopes. The scope entails the places from where variables are accessible. Default <code class="Code-In-Text--PACKT-">let</code> and <code class="Code-In-Text--PACKT-">const</code> variables can be accessed inside the block where they're defined (and the inner blocks of that block) and <code class="Code-In-Text--PACKT-">var</code> is just accessible from the line where it was defined.</p>&#13;
    <p class="normal">We can also use recursive functions to elegantly solve problems that can be solved recursively by nature, such as calculating the factorial. Nested functions were the next topic we studied. They are not a big deal, just functions inside functions. Basic functions inside functions are not considered very pretty, but anonymous functions and arrow functions are not uncommon to see. Anonymous functions are functions without a name and arrow functions are a special case of anonymous functions, where we use an arrow to separate the parameters and the body.</p>&#13;
    <p class="normal">In the next chapter, we'll consider classes, another powerful programming construct!</p>&#13;
  </div>&#13;
</div></body></html>