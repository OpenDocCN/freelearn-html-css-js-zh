- en: Mapping with Canvas and D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to leave our house and tree. I know it''s sad, but we''ll move on
    to potentially more exciting things to build. You covered a lot of ground in the
    previous chapter. You learned how to draw with Canvas, how to animate with Canvas,
    and a pattern to combine the D3 life cycle with Canvas. As D3 is usually in cahoots
    with SVG, you also learned about a few key differences between SVG and Canvas.
    Understanding the advantages and limitations of either approach is key to making
    informed decisions about which mode of rendering to use. Here''s what we will
    go through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start off with a summary of the key reasons for using either SVG or Canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then move on to review steps to build a flight path visualization with
    SVG, before building one with Canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we will focus on measuring the performance to get a good understanding
    of how far we can go with either approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will further contrast and compare the two approaches conceptually and technically.
    It will also allow us to demonstrate the main reason for choosing Canvas over
    SVG – animation of a great many points.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Canvas or SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already seen some benefits and some challenges to overcome when working
    with either of the two rendering methods. This section is supposed to summarize
    the most important differences. As such, it should give you a good understanding
    of what to use in which circumstance. Note, that I am juxtaposing SVG and Canvas
    rather than HTML and SVG with Canvas. It seems appropriate to focus on SVG as
    it is D3's main building block due to its visualization advantages. However, the
    same logic applies to the equally retained HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons to choose SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first look at the SVG benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: SVG is a vector-based graphics system. It allows resolution independent drawings
    you can scale without affecting quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily access elements in the DOM to move, change, or add interactivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can style with CSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3 works closely with the DOM, allowing for concise operations such as element
    selection and styling in a single pass and declarative animations with SVG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG is accessible to screen-readers and SEO bots out of the box. Canvas requires
    fallback text or a sub-DOM to provide some level of accessibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasons to choose Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While SVG might be easier to handle, Canvas has advantages when it comes to showing
    and animating more elements:'
  prefs: []
  type: TYPE_NORMAL
- en: SVG allows you to draw roughly 10,000 elements and animate 1,000 or so elements.
    With Canvas you can animate around 10,000 points. Why? First of all, Canvas is
    lower level and has fewer abstraction layers to keep and manage in memory. Secondly,
    browsers (like most monitors) mostly support a frame rate of 60 frames per second,
    meaning the screen is updated 60 times per second. This leaves *1000 / 60 = 16.67* milliseconds
    to finish all necessary rendering and housekeeping activities. As human brains
    are fooled into perceiving fluid animation at a mere 16 frames per second, the
    maximum time for rendering a frame is *1000 / 16 = 62.5* milliseconds — but you
    should strive for a shorter time. For SVG these activities include DOM parsing,
    render tree production, layout and screen painting, to name the most important.
    The path between Canvas changes and image is shorter. The browser turns the context
    instructions into an array of pixel values before painting it to the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need more elements to render or animate, accessing the alternative WebGL
    context is as easy as defining `canvas.getContext(‘webgl')`. WebGL allows you
    to animate 100k elements and more. While WebGL code is close to GPU programming
    and hence not for the faint-hearted, abstraction libraries like `Three.js`, `Pixi.js`, or `regl` make
    it more accessible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out Peter Beshai's excellent tutorial on animating 100,000 points with
    WebGl and regl at [https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html](https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Canvas is a **rasterized** graphics system. This just means the image consists
    of a *raster* (we could also say a *matrix*) of pixels. As a result, scaling can
    lead to blur, but in turn it''s simple to download your canvas as an image. A
    further problem are high **Dots Per Inch** (**DPI**) or retina screens, that can
    make Canvas blur. You can use the following setup to support retina displays on
    Canvas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Considering this, it seems a wise choice to stick to SVG for as long as possible
    and pull Canvas out of the hat when many elements need to be drawn or moved around.
    You might want to keep things simple until they can't be. One not-so-simple case
    could be the animation of a great many points. Let's look at an example that demonstrates
    the performance benefits Canvas has by building an element-heavy, animated application
    first with SVG and then with Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing flight paths with Canvas and D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data can come with a great many number of individual data points. Maps especially
    can be the playground for large datasets. While it might be tempting to visualize
    features of a dataset as individual elements, in explanatory data visualization
    especially it often makes sense to aggregate data to bring across a single point
    well. While Canvas allows you to show and animate many points, it is power you
    might want to use responsibly.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, it can often be mesmerizing to watch dynamic data unfold as
    well as bringing across a specific point. Combining user engagement with concise
    learnings is of course a great plus you should leverage if possible. Considering
    map data, there are a great many examples of dynamic visualizations with numerous
    animated elements, such as natural elements like winds or ocean currents, cultural
    elements like spreading ideas or inventions, as well technical elements like cars,
    ships, or airplanes. In this section, we will jump on the latter and visualize
    flight paths.
  prefs: []
  type: TYPE_NORMAL
- en: Our aim will be two-fold. Firstly, we want to build a map visualization with
    many animated elements – not just for the sake of showing many elements, but the
    detail we show should facilitate the understanding of the visual. Secondly, we
    want to compare the performance between SVG and Canvas. We have described it theoretically
    in a previous section, but let's get practical now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15f41f3a-8672-433a-88c4-8a0c805a3659.png)'
  prefs: []
  type: TYPE_IMG
- en: 1,000 flight paths visualized. Each red dot is an animated plane (promise!)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main element categories we will draw: *the world, airports*
    (the white dots, consciously kept in the background as they are of only supporting
    importance), and the *planes* (the red dots). Representing real planes, our red
    dots are animated along their very own flight path flying from their origin to
    their destination. Here''s an image showing the paths our planes follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6df407f2-f612-4734-adc7-16dc5c59dc86.png)'
  prefs: []
  type: TYPE_IMG
- en: 100 flights showing the route paths and their respective planes
  prefs: []
  type: TYPE_NORMAL
- en: The source data for this visual includes over 65,000 worldwide routes flying
    to and from just over 7,000 airports. We won't be able to animate all these routes,
    not even with Canvas. The aim of our visualization will rather be to show as many
    as we can to convey an immediate visual understanding of active versus less active
    flight regions as well as oft-used versus lesser-used routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the visual we will show a row of buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c602cbc1-4402-4fb7-a5b0-0d0e0bf040af.png)'
  prefs: []
  type: TYPE_IMG
- en: Buttons to kick off the animation
  prefs: []
  type: TYPE_NORMAL
- en: These buttons will allow the user to set the number of flights to be displayed
    at once. Importantly, this will not be real time or replayed time. We won't bring
    in any flight schedules, showing flights at the time of day/date they depart or
    arrive, we will show all flights at the same time! Firstly, this supports the
    visualization aims described previously and secondly, it will help test performance
    because as many elements as possible are being animated at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test browser performance, we shall add a small information box from `stats.js`
    at the top left of our app. Once dropped into your code, this nifty info tool
    displays page performance measures on your page, of which we will be mainly interested
    in **frames per second** (**FPS**). You will see it soon in action, but this is
    how it looks magnified indicating 60 frames per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e03b7b04-6e56-407e-b2cd-8536647e006d.png)'
  prefs: []
  type: TYPE_IMG
- en: The data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the three element categories we want to represent, we need three
    data sources to build the visual. The map data, data about airport locations,
    as well as flight data, showing origins and destinations for each flight. We will
    call this the **route data**. Both datasets come from [openflights.org](https://openflights.org/)
    which offers a tool you can use to map flights as well as databases for flights
    worldwide including routes and airport location data. This is exactly what we're
    after.
  prefs: []
  type: TYPE_NORMAL
- en: 'After light cleaning and minor modifications, the first 10 entries of the route
    data and the airport location data with 100 flights look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09edba9a-51fb-4a11-a87f-a4a9421e33a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The route and the airport data
  prefs: []
  type: TYPE_NORMAL
- en: All variable names are self-explanatory. Note that the first variable in the
    airport data, *i**ata**,* represents the official three-letter airport code from
    the **International Air Transport Association** (**IATA**). Also note that we
    had to remove some flights per dataset as not every airport location was available,
    which in fact leads to a lower number (less than 2-3%) of flights than the buttons
    suggest.
  prefs: []
  type: TYPE_NORMAL
- en: Building the flight path map in SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our focus in this chapter will be on mapping with Canvas as well as on a benchmark
    of Canvas against SVG animation. In order to spend our time and effort wisely,
    I have pre-built an SVG map we can use as a benchmark, leaving us the rest of
    the chapter to focus on how to build the Canvas flight path app. The chapter is
    called *Mapping with **Canvas** and D3* after all...
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, let''s have a quick look at the steps we would take to build this
    app with SVG. There are roughly eight logical steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: You set up the map with a container SVG, as well as the projection and the path
    generator for the map
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You load the map data and draw the map
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You listen to button events and load in the appropriate dataset depending on
    the button pressed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You draw the airports
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You calculate each plane’s origin and destination position as well as compute
    a path from origin to destination
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You sample points along each plane’s path and store them in an array (we’ll
    call them *way points*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using D3, you transition each plane along its path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once each plane has reached its destination, you let the transition start again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have conjured up our SVG flight path visual, let's see how many
    planes we can set off without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So here it is – let''s make some planes fly. We should start modestly and try
    with 100 routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a6bcd3b-ff61-4ea7-9fde-77ffc0c51fab.png)'
  prefs: []
  type: TYPE_IMG
- en: SVG visualization of 100 flight paths at 60 FPS
  prefs: []
  type: TYPE_NORMAL
- en: 'See the frame rate in the top-left corner? It''s a bit small but we''re still
    very happy with it! Displaying 60 frames per second is perfect. 1,000 flights
    will give us up to 40 frames per seconds. This is a drop, but the animation remains
    smooth. However, even at 1,000 flights we can’t really see any major clusters
    of flight activity. So, let’s try 5,000 flights at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2e784cf-5c22-4ced-b89e-9770c8f440fc.png)'
  prefs: []
  type: TYPE_IMG
- en: SVG visualization of 5,000 flight paths at 6 FPS
  prefs: []
  type: TYPE_NORMAL
- en: Our performance crashed to 6 FPS. While this static image brings us closer to
    our visualization aim of identifying regions of high flight traffic, it's no fun
    to view the janking animation. Canvas to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at: [https://larsvers.github.io/learning-d3-mapping-9-1](https://larsvers.github.io/learning-d3-mapping-9-1). Code
    example [09_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_01.html).
    I recommend to use a recent version of Chrome to view and work on the examples
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: At the conclusion of each step you will find two links in an info box close
    to the the relevant image. The first link brings you to a working implementation
    of this step that you can view in the browser. The second *code example* link
    brings you to the full code. If you're reading the print version, you can find
    all code examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping) in
    their relevant chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the flight path map in Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with an overview of our Canvas application before we take it apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s best to quickly get the HTML out of the way as it couldn''t be much simpler.
    We have a `div` for the canvas at hand as well as our buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that each button gets the same class selector as well as a `data-flights`
    attribute to pass on the number of flights each button represents. You will use
    this in a moment to load the right dataset!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the steps we take in the JavaScript to build this app in
    Canvas and see what changes to the flow we described previously for the SVG app.
    I have **highlighted** the parts we change for the Canvas flow and have removed
    the SVG parts (in brackets):'
  prefs: []
  type: TYPE_NORMAL
- en: You set up the **Canvas and the context** (instead of a container SVG), as well
    as the projection and the path generator for the map
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You load the map data and draw the map
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You listen to button events and load in the appropriate dataset depending on
    the button pressed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You draw the airports **and the world**, as they are on the same Canvas and
    a redraw is cheap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You calculate each plane’s origin and destination position as well as compute
    a path from origin to destination
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You sample *way points* along each plane’s path and store them in an array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**You set off the game loop **(instead of using D3 transitions)**:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: clear the Canvas
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: update the position
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: draw the planes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the SVG example we restart a transition, once each plane has reached its
    destination. In our Canvas app this is part of the **update step in the game loop**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we set up a few global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`width` and `height` speak for themselves. Countries will hold the GeoJSON
    data to draw the globe, which needs to be reached from various function scopes.
    Hence, it''s easier to define it as a global variable in this small app. `airportMap`
    will allow us to join the airport with the routes data by the three-letter IATA
    code. `requestID` will be filled by our loop function `requestAnimationFrom()`
    and used to cancel the current loop. We shall get to this in no time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set up the two contexts: a context for the world and a context for
    the planes. This little extra work at the beginning makes our life much easier
    later. If we drew the world and the planes on the same context, we would have
    to update both the world and the planes every time a plane flies a short distance.
    Keeping the world on a separate canvas means we only have to draw the world once
    and can leave that image/context untouched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use absolute CSS positioning for the canvases to stack them perfectly on
    top of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the `projection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please note that instead of playing with `.scale()` and `.translate()` to center
    and fit your projection, you can use the D3 convenience methods  `.fitExtent()` or `.fitSize()`.
    You pass them your viz dimensions and the GeoJSON object you want to project and
    it calculates the best scale and translation for you.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we don't use the omnipresent *Mercator* projection but the *Robinson* projection
    for our world map. It has the advantage of drawing the world in a slightly more
    realistic way in terms of country size proportions. The *Robinson *and many more
    non-standard projections can be found in the additional *d3-geo-projection module*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a path generator. In fact, you will need to build two path generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`pathSVG` will be used to generate the flight path in memory. We want to do
    that in SVG as it comes with handy methods to calculate its length and sample
    points from it. `pathCanvas` will be used to draw our `geo` data to the screen.
    Note that we add `d3.geoPath()`''s `.context()` method and pass it our `contextWorld`.
    If we pass a Canvas context to this `.context()` method, the path generator will
    return a Canvas path for the passed context. If it''s not specified it will return
    an SVG path string. You can think of it as a switch button to tell D3 which renderer
    to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the map and listening for user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the SVG process, we start by loading the data in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then do a bit of housekeeping and move the buttons in the `div#controls`
    below the canvases. You recode the TopoJSON to GeoJSON features and save the data
    as a global variable before you draw the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to D3's versatile path generator, this is all it needs to draw the world.
    Easy!
  prefs: []
  type: TYPE_NORMAL
- en: Back in our asynchronous `d3.json()` data load function, you'll handle the button
    events next. Remember, nothing has happened yet, but as soon as the user hits
    a button, the animation should kick off.
  prefs: []
  type: TYPE_NORMAL
- en: 'You attach a mouse-down listener to all buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed with writing the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The button colors are handled in the first two lines. The next line will stop
    the current loop. We haven't even got a loop yet, so let's get back to this as
    soon as we have.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we retrieve the number of flights the button represents and load the
    respective route and airport location data from the server. That's it for the
    `d3.json()` callback, as the `ready()` function will take over as soon as the
    data is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing and drawing with Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Canvas, we want to achieve three things in the `ready()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the background scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we draw the airports, we manipulate the airport locations data. We create
    an array holding one GeoJSON point `geometry` object per airport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then we fill the global `airportMap` variable with a map we produce with `d3.map()`.
    `d3.map()` is a utility function that takes an array of objects to produce key-value
    pairs we can access with its own `map.get()` method. We won't use the map immediately
    but will get to it in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we call the `ready()` function, that is every time the user presses
    a new button, we will redraw airports and the world. Both are drawn on the same
    canvas. If we want to change one thing on a canvas, we need to change everything
    on a canvas. There are ways to only update regions with clip-paths but with complex
    animations of multiple elements, this can become a mess real quick. So we erase
    and rebuild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, we''re on the first canvas we''ve drawn – accessible via `contextWorld.`
    We''ve seen `drawMap()` a few paragraphs ago, `drawAirports()` is even simpler
    and speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's it. This background scene will be drawn with every button press updating
    the airports shown.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the planes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we build the fundament for our animation. Essentially, we want an array
    of points on each plane''s route. We will call them **way points** and here''s
    how they will look for the flight path **Frankfurt to Atlanta** as an array and
    as points on the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4039708-d1d0-461c-848b-dfc51e19590f.png)'
  prefs: []
  type: TYPE_IMG
- en: Way points in an array (showing the first 10 of 733) and on the map (an illustration,
    not exact)
  prefs: []
  type: TYPE_NORMAL
- en: 'The **way points** are the core ingredient, the fuel for our animation. When
    we animate the first frame, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear the plane's own canvas `contextPlane`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull out the very first way point for each plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw that plane in this position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we draw the second frame we do the same, but in *step 2* pull out the second
    way point. For the third frame, we shall pull out the third way point, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to hold up the browser with complex calculations in between each
    frame, so we shall calculate all positions for all planes before we animate. Note,
    this is not always possible, positions might be dependent on user input or arbitrary
    charges in your force-directed graph or the like. However, whatever you can pre-calculate,
    you should.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the plane's positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we get to the `wayPoints` array? Conceptually, we''ve said it all already.
    We now express it in code. First, you need to create an array for all planes,
    depending on the route data the respective button press has loaded in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple array of elements representing the three-letter origin and
    the destination IATA airport codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you iterate through this array of start and end points to calculate the
    `wayPoints`. You will create an object called `planes` holding the data as well
    as two helper functions to calculate the data. But before this, have a look at
    the simple algorithm to produce the planes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Conceptually, you produce a plane for each route. Then you get this plane's
    route path and store it within the plane. Next, you sample the path for a number
    of *x*, *y* coordinates – our `wayPoints` – and also store it in the `plane`.
    Lastly, you add the `plane` with all the information you need in the `planes.items`
    array. That's all the calculation magic in an overview. As soon as that's done,
    you can animate the points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a brief look at the `planes` object. Note the plural! This
    is different to the `plane` object we build for each route. It is the home of
    all our `plane` objects. `planes.items` will keep all `plane` objects, `planes.getPlane()`
    will produce them, `planes.getPath()` will create the route''s path, and `planes.getWayPoints()`
    will sample our way points from the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what each `planes` function does. There are three simple steps:
    first, we build the plane, then we draw each plane''s path, and finally we sample
    points from that path we can iterate through to make the plane move:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manufacturing a plane**:the `getPlane()` function takes the `planeRoute`
    – the three-letter airport codes for origin and destination – and uses it to initialize
    the plane''s position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It returns an object holding the `startX` and `startY` positions it retrieves
    from the `airportMap` lookup you created earlier. It also has `x` and `y` coordinates
    representing the current position of the plane. For the first frame this is the
    same as `startX` and `startY.` It also holds an as yet empty object for the `route`
    path and the `wayPoints` we calculate next. Lastly, it has a `currentIndex` keeping
    track of the way point the plane is at when we change its position (this will
    become clearer very soon).
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing each plane''s path**:plane initialized. Now, let''s get the path.
    Remember that we created two path generators during setup? One was a Canvas path
    to draw worlds, the airport, and plane circles. The other one – `pathSVG` – was
    for creating the route as an SVG path. Why would you want to do that? Because
    SVG paths have the great `.getTotalLength()` and `.getPointAtLength()` methods
    that make it easy to sample points from that path. Here''s how to use D3 to create
    the path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You won't create the path in the DOM, but only in memory and save it in the
    `pathElement` variable. As it's an SVG and not an HTML element, you need to specify
    the SVG namespace which you can do with D3's `.namespaces.svg` utility function.
    Then you create the path before returning the raw element rather than the D3 selection
    as `route.node()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieving the way points**:all set to calculate the way points. `getWayPoints()`
    takes the plane which by now has its path stored in the `plane.route` property.
    We use the path sampling functions we just praised on its path and return an array
    holding all way points for this specific plane''s route path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, you create an empty array called `arr` which will hold all your way points.
    Then, you produce an integer saved in the `points` variable. This integer will
    represent the number of points we want to sample from the path. You get the total
    length of the path, which is represented by the number of pixels the path will
    take up. This, you multiply by `2.5`. This very factor is important and controls
    how many points will be sampled and hence how fast or slow the animation will
    be. The higher the number, the more points it will sample and the slower the animation
    will appear. If you choose a low number or even a fraction such as *0.1*, few
    points will be sampled and the animation will appear faster.
  prefs: []
  type: TYPE_NORMAL
- en: You use `d3.range(points).forEach()` to retrieve the coordinates returned as
    so-called `DOMPoints` by `.getPointAtLength()` at each point of the path. Then
    you push each of them into the array and voila, you have your way points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations. You have just built a plane. In fact, you have built a plane
    and its route and all the points you need to make it jump to so that a viewer
    would think it flies. This is how it looks inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca50163d-84e0-461b-babd-943c3e5fe0f0.png)'
  prefs: []
  type: TYPE_IMG
- en: The plane flying from Frankfurt to Atlanta
  prefs: []
  type: TYPE_NORMAL
- en: Animating the plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rest is simple. You just need to apply the game loop to the canvas. We''ve
    already encountered this a few times; you create a function called `animate()`
    and let it run in a continuous loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note, that we added the used functions to the planes object as well, to keep
    all plane-related function code together.
  prefs: []
  type: TYPE_NORMAL
- en: First, we clear the canvas. `planes.clearPlanes()` literally just clears the
    context we pass to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we iterate through the `planes.items` array holding all planes and update
    each plane with `planes.updatePlane()`. We pass it the respective plane and it
    either moves the `x` and `y` coordinates to the start if the plane has reached
    its destination or it moves them to the next way point coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The use of `currentIndex` should become clearer here. It keeps track of where
    each plane is on its path as well as moving the plane forward by one way point
    on each update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we draw the plane (this is where we realize we haven''t built an actual
    plane but a `tomato` colored circle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you kick it off with `requestAnimationFrame()`. You can use `setInterval()`
    but you should use `requestAnimationFrame()` instead. It will allow the browser
    to choose the best time to trigger its callback before the next repaint. This
    is much more economical compared to the brute force `setInterval()`. It also has
    the additional benefit of interrupting the loop when the browser tab the app runs
    on is not in focus. Note also, that we save the `requestID` of each loop. You
    might remember that we use this unique ID to cancel the current loop with `cancelAnimationFrame(requestID)`
    when the user presses a button to set off a new loop.
  prefs: []
  type: TYPE_NORMAL
- en: Done. Well done.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far so good. But does it work? And if it works, does it work better than
    the SVG example? Let''s recall that the SVG flight path visual gave us a whopping
    60 FPS for 100 animated circles and a meager 6 FPS for some 5,000 animated circles.
    Let''s start with 100 circles and focus on the `stats.js` measure in the top-left
    corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1367c00-7bfd-4a2b-b49f-a90f3d1a74d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Canvas visualization of 100 flight paths at 60 FPS
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at: [https://larsvers.github.io/learning-d3-mapping-9-2a](https://larsvers.github.io/learning-d3-mapping-9-2a).
    Code example [09_02a.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02a.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We expected 60 FPS. Let''s go to 1,000 flights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e04a0e3-eac8-4a50-a4ec-62b7ea6f2203.png)'
  prefs: []
  type: TYPE_IMG
- en: Canvas visualization of 1,000 flight paths at 60 FPS
  prefs: []
  type: TYPE_NORMAL
- en: Again, 60 FPS! 5,000 planes?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a914d46d-9c9a-4d7c-9062-1c4b4f0f8c22.png)'
  prefs: []
  type: TYPE_IMG
- en: Canvas visualization of 5,000 flight paths at 45 FPS
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s going down, but still at 45 FPS keeping the animation fluid. Let''s look
    at 10,000 flights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fccd0c7-df9c-4e14-a37b-810eaae2305d.png)'
  prefs: []
  type: TYPE_IMG
- en: Canvas visualization of 10,000 flight paths at 23 FPS
  prefs: []
  type: TYPE_NORMAL
- en: We still see a frame rate similar to what you see when watching a movie with
    23 FPS. However, let's try and squeeze out a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that we've used two canvases for this visual, one canvas to draw the
    static background scene with the map and the airports and one canvas for the dynamic
    flight animation. We did this because it kept drawing concerns separate.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for using an additional canvas is increased performance. We can
    use one canvas as an **in-memory buffer** to pre-render elements and just copy
    its contents onto the main visible canvas. This saves render costs as drawing
    on a visible canvas is less performant than drawing on a non-visible canvas to
    then copy over the image to the main canvas. Performance further rejoices as the
    context's `drawImage()` method we will use to copy over the image from the buffer
    to the display canvas, is hardware accelerated (meaning it uses the parallel processing
    powers of the GPU) by default.
  prefs: []
  type: TYPE_NORMAL
- en: For our little app, the animated elements are the plane circles. Instead of
    drawing them with the `drawPlane()` function for each update, we can first create
    a single image of a circle on a small buffer canvas and then use `drawImage()`
    to port it over to the `canvasPlane.`
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a single plane image in global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We create our buffer canvas called `planeImg` in thin air, set its `width` and
    `height` to `2` (double the plane's desired radius of `1`), and retrieve its context.
    We'll draw a `tomato` colored circle on it before we return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this function once when initializing the `planes` object and store
    it as an image in the `planes` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just have to remove our `drawPlane()` function we used to draw
    the circle on every update. Instead, we add a new function called `drawPlaneImage()`
    to the `planes` object that uses `drawImage()` to add our plane icon (the circle)
    to the context we determine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we don''t call `drawImage()` in the `animate()` function, but `drawPlaneImage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with measuring performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s check the frame rate for animating 10,000 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aff3f428-0751-4728-842b-44d1d7b9bc84.png)'
  prefs: []
  type: TYPE_IMG
- en: Canvas visualization of 10,000 flight paths at 36 instead of 23 FPS
  prefs: []
  type: TYPE_NORMAL
- en: 'View complete app at: [https://larsvers.github.io/learning-d3-mapping-9-2b](https://larsvers.github.io/learning-d3-mapping-9-2b).
    Code example: [09_02b.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02b.html).'
  prefs: []
  type: TYPE_NORMAL
- en: That's great, boosting performance by about +57% compared to not using the powers
    of `drawImage()`. It's not shown here, but 5,000 points were animated at 60 FPS
    instead of 45 FPS. Yay.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, 15,000 flights fly with 24 FPS and 20,000 with up to 18 FPS. This
    is still just beyond the 16 FPS generally considered the lowest possible frame
    rate for fooling the brain into believing a fluid animation. Even 25,000 planes
    still move with around 14 frames per second conveying a mild jank, while 30,000
    flights stutter still only modestly at 12 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e1e2049-a745-45f5-a39b-dc83b29464cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Canvas visualization of 30,000 flight paths at 12 FPS
  prefs: []
  type: TYPE_NORMAL
- en: While performance can vary with different browsers, CPU’s and GPU’s the jump
    from SVG to Canvas is significant!
  prefs: []
  type: TYPE_NORMAL
- en: With Canvas we have achieved our narrative mission to visualize regions of heavy
    flight activity. All of Europe seems to be in the air, as well as the east and
    west of the US and the east of China. Other continents show a line of increased
    air-activity along their costs. You might be surprised by the band of planes moving
    down through Thailand and Indonesia, although this is a densely-populated area.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned how to build a flight path visualization
    in SVG and in Canvas, bringing together much of what you have learned before.
    You have seen how it requires a different mental model to program animations with
    Canvas, probably best summarized by the game loop: process your data, clear the
    drawing, re-draw the animation. You have used D3 to set up the visualizations,
    but you have also seen that due to the different coding concept, Canvas might
    require you to step away a little from D3 core functionality like transitions.
    However, all that paid off by witnessing the power of Canvas when it comes to
    animation. Instead of being able to fluidly animate 1,000 points we managed to
    animate 15,000 points safely and 20,000 points still gracefully with optimized
    Canvas techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After having seen the benefits of Canvas, let''s now find a workaround for
    one of its caveats: interactivity!'
  prefs: []
  type: TYPE_NORMAL
