<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Application Building Blocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Application Building Blocks</h1></div></div></div><p>The previous chapter addressed a key capability of Lo-Dash—wrapping values and executing chained function calls. One benefit of this style of coding is the ability to construct larger units of functionality that are generic and portable. We saw glimpses of both generality and portability when working with wrapper instances in the last chapter. The goal of this chapter is to implement these ideas. Writing an application is more than throwing together filters and maps that give you the data you need. Your code would grow messy in no time if you kept writing the same thing over and over again.</p><p>In this chapter, we'll learn how to write generic functions that internally utilize the Lo-Dash API. We'll also take chained function calls a step further by exploring the various ways they fit together, like puzzle pieces, and ultimately result in a robust foundation for your application. There comes a point when the functions you write for your application belong in the Lo-Dash infrastructure. That is, you need to mix your own generic code with the Lo-Dash API. We'll tackle that too.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generic functions</li><li class="listitem" style="list-style-type: disc">Generic wrappers and chains</li><li class="listitem" style="list-style-type: disc">Composing functions</li><li class="listitem" style="list-style-type: disc">Creating mixins</li></ul></div><div class="section" title="Generic functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Generic functions</h1></div></div></div><p>Creating <a id="id406" class="indexterm"/>generic functions can make all the difference in the size and comprehensibility of our code. A generic function is useful in more than one context. It is loosely coupled to the application. That's what higher-level building blocks are all about; whether we're using a functional programming model, a more object-oriented approach, or a hybrid of the two, the key lies in generic components. As with most other aspects of programming, Lo-Dash provides many avenues to construct generic components. We'll address many of them throughout the course of this chapter. Let's start off by looking at functions that aren't so generic and how they compare with their more fluid cousins.</p><div class="section" title="Specific functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Specific functions</h2></div></div></div><p>Whether a function is<a id="id407" class="indexterm"/> fit for one <a id="id408" class="indexterm"/>purpose or not, and whether it is fit for only one purpose, isn't always clear-cut. Depending on your perspective, there are degrees of specificity. Consider the following functions:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Ronnie', age: 43 },
    { name: 'Ben', age: 19 },
    { name: 'Sharon', age: 25 },
    { name: 'Melissa', age: 29 }
];

function collectionNames() {
    return _.map(collection, 'name');
}

function indirectionNames(coll, prop) {
    return _.map(coll, prop);
}

function genericCollNames(coll) {
    return _.map(coll, 'name');
}

function genericPropNames(prop) {
    return _.map(collection, prop);
}

collectionNames();
indirectionNames(collection, 'name');
genericCollNames(collection);

genericPropNames('name');
// → [ "Ronnie", "Ben", "Sharon", "Melissa" ]</pre></div><p>Each of these four functions yields the same result, yet their implementations have their own unique consequences in our application. We can evaluate two generic properties of each function. First, we look at the collection that's being transformed—the main operand. Also, there are the secondary arguments passed in that affect the outcome.</p><p>The <code class="literal">collectionNames()</code> function<a id="id409" class="indexterm"/> is fairly specific, in that it expects a <code class="literal">collection</code> variable in its scope and hardcodes the <code class="literal">name</code> argument that is passed to <code class="literal">map()</code>. The <code class="literal">indirectionNames()</code> function<a id="id410" class="indexterm"/> is the opposite—it's completely generic because it accepts collection and property arguments, but it's also completely pointless since it's just a proxy and we might as well call <code class="literal">map()</code> directly. The <code class="literal">genericCollNames()</code> function<a id="id411" class="indexterm"/> is interesting; the collection we're mapping with this function is generic since it is passed as an argument, while the <code class="literal">name</code> argument is hardcoded. Lastly, the <code class="literal">genericPropNames()</code> function<a id="id412" class="indexterm"/> uses a <a id="id413" class="indexterm"/>generic argument <a id="id414" class="indexterm"/>when hardcoding the collection.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Remember to consider each extreme—from indirection to fully hardcoding—when defining your functions. Either of these extremes is hardly worthwhile and the middle ground is somewhere to aim for. As for what you hardcode and what you keep generic, each has trade-offs that are unique to what you're building. You'll often find yourself changing these around as your application evolves.</p></div></div></div><div class="section" title="Generic function arguments"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Generic function arguments</h2></div></div></div><p>JavaScript gives us some <a id="id415" class="indexterm"/>freedom in defining our functions. Not all arguments need to be statically declared ahead of time, as is the case in other languages. The <code class="literal">arguments</code> object is available to help us out, especially when we're trying to keep something generic. For example, certain callers may not pass all arguments. That's fine, our functions can cope and we can utilize this capability to define functions that are better equipped to generically interact with the Lo-Dash API, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">function insert(coll, callback) {
    var toInsert;

    if (_.isFunction(callback)) {
        toInsert = _.slice(arguments, 2);
    } else {
        toInsert = _.slice(arguments, 1);
        callback = _.identity;
    }

    _.each(toInsert, function(item) {
        coll.splice(_.sortedIndex(coll, item, callback), 0, item);
    });

    return coll;

}

var collection = _.range(1, 11);

insert(collection, 8.4);
// → [ 1, 2, 3, 4, 5, 6, 7, 8, 8.4, 9, 10 ]

insert(collection, 1.1, 6.9);
// → [ 1, 1.1, 2, 3, 4, 5, 6, 6.9, 7, 8, 8.4, 9, 10 ]

insert(collection, 4, 100);
// → [ 1, 1.1, 2, 3, 4, 4, 5, 6, 6.9, 7, 8, 8.4, 9, 10, 100 ]</pre></div><p>The <code class="literal">insert()</code> function <a id="id416" class="indexterm"/>accepts a <code class="literal">coll</code> and a <code class="literal">callback</code> argument. The <a id="id417" class="indexterm"/>collection is always required but the callback is optional. If no callback is provided, it defaults to the <code class="literal">identity()</code> function.</p><p>There's some additional trickery involved here as well, since any other arguments supplied to the function are the targets to be inserted into the collection. We use the <code class="literal">slice()</code> function<a id="id418" class="indexterm"/> to stick these in the <code class="literal">toInsert</code> variable and we slice them differently depending on whether or not a callback function was supplied. Then it's just a matter of iterating through each argument value to insert and passing our callback to <code class="literal">sortedIndex()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>Setting the callback <a id="id419" class="indexterm"/>value to <code class="literal">identity()</code> isn't strictly necessary here. That's the default behavior of most Lo-Dash functions that take callbacks. Being explicit doesn't hurt either, especially if we don't want the same default function.</p></div></div></div><div class="section" title="Using partials"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Using partials</h2></div></div></div><p>A handy pattern to<a id="id420" class="indexterm"/> solve the generic argument issues that arise is to use <a id="id421" class="indexterm"/>partials, that is, partially apply function arguments using the<a id="id422" class="indexterm"/> <code class="literal">partial()</code> function. This lets us build functions at runtime that can be used repeatedly, without having to always apply the same arguments. Sometimes it's not even feasible to provide function arguments. The following is an example of using partials:</p><div class="informalexample"><pre class="programlisting">var flattenProp = _.compose(_.flatten, _.prop),
    skills = _.partialRight(flattenProp, 'skills'),
    names = _.partialRight(flattenProp, 'name');

var collection = [
    { name: 'Danielle', skills: [ 'CSS', 'HTML', 'HTTP' ] },
    { name: 'Candice', skills: [ 'Lo-Dash', 'jQuery' ] },
    { name: 'Larry', skills: [ 'KineticJS', 'Jasmine' ] },
    { name: 'Norman', skills: [ 'Grunt', 'Require' ] }
];

_.contains(skills(collection), 'Lo-Dash');
// → true
_.contains(names(collection), 'Candice');
// → true</pre></div><p>Our <code class="literal">flattenProp()</code> function<a id="id423" class="indexterm"/> is a composition of <code class="literal">flatten()</code> and <code class="literal">prop()</code>. The result that is returned is a flattened array. So, if any of these property values were themselves arrays, they just get added to the single array.</p><p>There's no need to<a id="id424" class="indexterm"/> always supply the name of the property we need flattened, especially<a id="id425" class="indexterm"/> when the data model used in our application shares many properties between entities. This is the perfect case for the use of partial functions. Remember, partials aren't entirely static—they do return functions after all. Our code defines two partial functions with the <code class="literal">prop</code> argument preapplied. Later on, we can use this function with specific collections.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>Creating partial functions out of generic functions is a form of function composition and a critical tool in building high-level application components.</p></div></div></div><div class="section" title="Generic callbacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Generic callbacks</h2></div></div></div><p>It's one thing to design a function that's <a id="id426" class="indexterm"/>called manually in your code or in someone else's code. However, callbacks are essential to Lo-Dash. So it's always worthwhile to consider the fact that our functions are likely to be used as callbacks, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var YEAR_MILLISECONDS = 31560000000;

function validItem(item) {       
    return item.age &gt; 21 &amp;&amp;
        _.isString(item.first) &amp;&amp;
        _.isString(item.last);
}

function computed(item) {
    return _.extend({
        name: _.result(item, 'first', '') + ' ' +
            _.result(item, 'last', ''),
        yob: new Date(new Date() - (YEAR_MILLISECONDS * item.age))
            .getFullYear()
    }, item);
}

var invalidItem = _.negate(validItem);

    { first: 'Roderick', last: 'Campbell', age: 56 },
    { first: 'Monica', last: 'Salazar', age: 38 },
    { first: 'Ross', last: 'Andrews', age: 45 },
    { first: 'Martha', age: 51 }
];
                
_.every(collection, validItem);
// → false

_.filter(collection, validItem);
// →
// [
//   { first: "Roderick", last: "Campbell", age: 56 },
//   { first: "Monica", last: "Salazar", age: 38 },
//   { first: "Ross", last: "Andrews", age: 45 }
// ]

_.find(collection, invalidItem);
// → { first: "Martha", age: 51 }

_.map(collection, computed);
// →
// [
//   {
//     name: "Roderick Campbell",
//     yob: 1958,
//     first: "Roderick",
//     last: "Campbell",
//     age: 56
//   }, {
//     name: "Monica Salazar",
//     yob: 1976,
//     first: "Monica",
//     last: "Salazar",
//     age: 38
//   }, {
//     name: "Ross Andrews",
//     yob: 1969,
//     first: "Ross",
//     last: "Andrews",
//     age: 45
//   }, {
//     name: "Martha ",
//     yob: 1963,
//     first: "Martha",
//     age: 51 }]</pre></div><p>Our first callback defined in this<a id="id427" class="indexterm"/> code is <code class="literal">validItem()</code>, and this is an incredibly useful function because there are bound to be lots of scenarios where you might be interested only in valid items. This function takes a generic <code class="literal">item</code> argument and returns <code class="literal">true</code> if that argument meets a certain criteria. This is the ideal format for callbacks that are iteratively applied to collections. The second callback is <code class="literal">computed()</code>, and this too takes a generic <code class="literal">item</code> argument. This callback is useful in mapping scenarios since it returns an extended version of the item, with computed properties. There's a third callback here too—<code class="literal">invalidItem()</code>. This is the inverse of the <code class="literal">validItem()</code> function<a id="id428" class="indexterm"/> and we're able to create it using <code class="literal">negate()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>You may have noticed that a lot of our callback functions use <code class="literal">item</code> as the first named argument. This is good practice as it gives the readers of your code a good indication that a given function is likely used as a callback somewhere.</p></div></div></div></div></div>
<div class="section" title="Generic wrappers and chains"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Generic wrappers and chains</h1></div></div></div><p>With generic <a id="id429" class="indexterm"/>functions under our belts, it's time to turn our attention to Lo-Dash wrapper instances and create generic function call chains. Chains <a id="id430" class="indexterm"/>are useful when you're stuck and you need a quick way out of a tricky programming situation, but they're also useful in the generic sense. That is, you can compose chains of functionality that are general enough to apply in a variety of contexts.</p><div class="section" title="Generic filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Generic filters</h2></div></div></div><p>Let's start by taking a look at <a id="id431" class="indexterm"/>generic filters and how they can be utilized in our functions. Filters are especially suitable for chained function calls since they can be stitched together by applying a filter after a preceding filter. There are often some kinds of sorting or other constraints that take place at the end of a filter, such as limiting the number of results returned, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">function byName(coll, name, take) {
    return _(coll)
        .filter({ name: name })
        .take(_.isUndefined(take) ? 100 : take)
        .value();
}

var collection = [
    { name: 'Theodore', enabled: true },
    { name: 'Leslie', enabled: true },
    { name: 'Justin', enabled: false },
    { name: 'Leslie', enabled: false }
];

byName(collection, 'Leslie');
// →
// [
//   { name: "Leslie", enabled: true },
//   { name: "Leslie", enabled: false }
// ]

byName(_.filter(collection, 'enabled'), 'Leslie');
// →
// [ { name: "Leslie", enabled: true } ]

byName(_(collection).filter('enabled'), 'Leslie');
// →
// [ { name: "Leslie", enabled": true } ]</pre></div><p>Our <code class="literal">byName()</code> function<a id="id432" class="indexterm"/> wraps the passed-in collection and applies a <code class="literal">filter()</code> and a <code class="literal">take()</code> operation. It also accepts a couple of arguments. The <code class="literal">name</code> argument is the name we're filtering the collection on. The <code class="literal">take</code> argument is optional, and if supplied, specifies the number of items to return. If the <code class="literal">take</code> argument is missing, we default to <code class="literal">100</code>.</p><p>There are three different invocations of <code class="literal">byName()</code> demonstrated in the preceding code. The first invocation is the most straightforward. We're simply passing the name, <code class="literal">Leslie</code>, since this is the name we want to filter the collection by. The next invocation performs a <code class="literal">filter()</code> operation on the collection, then passes its result to <code class="literal">byName()</code>. The last invocation gets the same result as the second. However, you'll notice that we've already wrapped the collection, and since <a id="id433" class="indexterm"/>the <code class="literal">filter()</code> function is <a id="id434" class="indexterm"/>
<span class="strong"><strong>chainable</strong></span>, the wrapper instance gets passed as the <code class="literal">coll</code> argument.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Rewrapping a Lo-Dash wrapper is safe. The constructor recognizes this and knows how to handle it.</p></div></div><p>This function constructs a somewhat generic chain. We can pass in the collection at runtime along with the name value we would like to filter by. We can even pass the number of results we'd like to take, and the function doesn't care if it gets a wrapped value. This latter point is especially useful since it allows us to use other functions we've developed that perform chained function calls, return these chains, and use them. The limiting factor of <code class="literal">byName()</code> is that it calls <code class="literal">value()</code>, and returns the unwrapped collection.</p></div><div class="section" title="Returning chains"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Returning chains</h2></div></div></div><p>It's almost always a <a id="id435" class="indexterm"/>good idea to have our functions that construct wrappers return those same wrapper instances. In the previous section, our function unwrapped the value after the call chain had completed and returned it. The problem with this approach is that the caller may have more operations to apply on the chain. To do this, the value would need to be wrapped again. Lo-Dash wrapper instances should have the freedom to move about your code and be passed around from function to function, as if it were a plain array, as in the following example:</p><div class="informalexample"><pre class="programlisting">function sort(coll, prop, desc) {
    var wrapper = _(coll).sortBy(prop);
    return desc ? wrapper.reverse() : wrapper;
}

var collection = [
    { first: 'Bobby', last: 'Pope' },
    { first: 'Debbie', last: 'Reid' },
    { first: 'Julian', last: 'Garcia' },
    { first: 'Jody', last: 'Greer' }
];

sort(collection, 'first').value(),
// →
// [
//   { first: "Bobby", last: "Pope" },
//   { first: "Debbie", last: "Reid" },
//   { first: "Jody", last: "Greer" },
//   { first: "Julian", last: "Garcia" }
// ]

sort(collection, 'first', true).value(),
// →
// [
//   { first: "Julian", last: "Garcia" },
//   { first: "Jody", last: "Greer" },
//   { first: "Debbie", last: "Reid" },
//   { first: "Bobby", last: "Pope" }
// ]

sort(collection, 'last')
    .takeRight(2)
    .pluck('last')
    .value();
// → [ "Pope", "Reid" ]</pre></div><p>The <code class="literal">sort()</code> function<a id="id436" class="indexterm"/> is quite straightforward and doesn't seem to do all that much. On the face of it, it just takes in a collection, sorts it, and returns it. Yes, that's the goal at a high level. First, you'll notice that the <code class="literal">coll</code> argument is wrapped in the Lo-Dash constructor function—the argument value can be either a wrapper instance or an unwrapped value. The function also accepts a property name or a function callback to sort the collection by. The <code class="literal">desc</code> argument is optional and it reverses the sort order if <code class="literal">true</code>.</p><p>The major difference<a id="id437" class="indexterm"/> between this function and the <code class="literal">byName()</code> function we implemented earlier is that <code class="literal">sort()</code> will always return a wrapper instance. This means that we don't have to rewrap the returned value, should the caller need to add more function calls to the chain. You can see this in action with the last invocation of <code class="literal">sort()</code> in the preceding code. Here we're adding a <code class="literal">takeRight()</code> and a <code class="literal">pluck()</code> call to the chain. Designing functions in this way gives us great flexibility in how we're able to use wrappers throughout our code. The general rule would be to let your functions be wrapper friendly, both in what they accept as arguments and in what they return.</p><p>The trade-off, it would appear, is that the caller needs to call not only your function, but also the <code class="literal">value()</code> function. Sometimes, this can be a pain if all you want is the actual value so that you can start working with it, but remember that the chain itself isn't executed until the <code class="literal">value()</code> function is called. This has implications for lazy evaluation, which simply means that the return values aren't computed until <code class="literal">value()</code> is called. So this could actually be a desired trait—the ability to build chains without executing them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>You should always document in one form or another that your function does indeed return a Lo-Dash wrapper and that the caller needs to call <code class="literal">value()</code>.</p></div></div></div></div>
<div class="section" title="Composing functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Composing functions</h1></div></div></div><p>Whether our functions are <a id="id438" class="indexterm"/>called manually, used as a callback by another function, or used in some other context that involves chains, function composition helps construct larger pieces of functionality. For example, we may have two smaller functions that serve niche purposes on their own. When we're in scenarios where these functions may come in handy, we can use the functional tools in Lo-Dash to compose a new function that utilizes them, rather than roll out our own.</p><div class="section" title="Composing generic functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Composing generic functions</h2></div></div></div><p>Earlier in the chapter, we <a id="id439" class="indexterm"/>emphasized the idea that functions need to be generic if they're to be of any service in more than one context. The same idea holds true when composing larger components of smaller functions. The smaller functions need to be generic if we're going to use them to compose anything larger. Likewise, the composite should also be as generic as possible so that we can use it as an ingredient in a larger piece of the application. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">function enabledIndex(obj) {
    return _.transform(obj, function(result, value, key) {
        result[key] = _.result(value, 'enabled', false);
    });
}

var collection = [
    { name: 'Claire', enabled: true },
    { name: 'Patricia', enabled: false },
    { name: 'Mario', enabled: true },
    { name: 'Jerome', enabled: false }
];

var indexByName = _.partialRight(_.indexBy, 'name'),
    enabled = _.partial(_.flow(indexByName, enabledIndex),
    collection);
        
enabled();
// →
// {
//   Claire: true,
//   Patricia: false,
//   Mario: true,
//   Jerome: false
// }

collection.push({ name: 'Gloria', enabled: true });
enabled();
// →
// {
//   Claire: true,
//   Patricia: false,
//   Mario: true,
//   Jerome: false,
//   Gloria: true
// }</pre></div><p>This code has two generic utility functions. The <code class="literal">indexByName()</code> function<a id="id440" class="indexterm"/> takes a collection and returns an object where the keys are the <code class="literal">name</code> property for every item in the collection. The <code class="literal">enabledIndex()</code> function<a id="id441" class="indexterm"/> takes an object and converts each property value to a Boolean value, based on its <code class="literal">enabled</code> property. Perhaps, each of these functions is used on its own elsewhere in your application, but now, while developing a new component, we've come up with a use case that warrants using them together.</p><p>Rather than having to call <a id="id442" class="indexterm"/>each function independently and feed the output of the first function to the second, we decide to compose <a id="id443" class="indexterm"/>an <code class="literal">enabled()</code> function. This way, we can use a simple invocation any time we need the object structure that maps the name to the <code class="literal">enabled</code> Boolean value. This is done by partially applying the collection argument to the function we're creating, using <code class="literal">flow()</code>. The <code class="literal">flow()</code> function<a id="id444" class="indexterm"/> passes the first argument to the first function, and the next, and so on, returning the result.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>This code makes the assumption that the <code class="literal">name</code> property is unique for each object. Otherwise, it wouldn't be worth indexing like this.</p></div></div></div><div class="section" title="Composing callbacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Composing callbacks</h2></div></div></div><p>The <code class="literal">enabled()</code> function<a id="id445" class="indexterm"/> we just <a id="id446" class="indexterm"/>composed in the preceding section was intended to be directly called by our code somewhere. Callbacks, on the other hand, are generally passed to a Lo-Dash function. Passing inline anonymous functions works fine, except when you find yourself writing the same callback functions over and over again, or at least, similar functions with little variance. There's no reason that our application can't compose generic callbacks and make them available throughout the application to encourage reuse over duplication. Let's take a look at this example:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { first: 'Andrea', last: 'Stewart', age: 28 },
    { first: 'Clarence', last: 'Johnston', age: 31 },
    { first: 'Derek', last: 'Lynch', age: 37 },
    { first: 'Susan', last: 'Rodgers', age: 41 }
];

var minimal = _.flow(_.identity,
    _.partialRight(_.pick, [ 'last', 'age' ]));

_.map(collection, minimal);
// →
// [
//   { last: "Stewart", age: 28 },
//   { last: "Johnston", age: 31 },
//   { last: "Lynch", age: 37 },
//   { last: "Rodgers", age: 41 }
// ]</pre></div><p>A common problem faced by callback functions is that they have no control over how they're invoked. One function may invoke each of its callbacks using a single argument, while the next uses three arguments. This prevents us from doing certain things we'd otherwise like to, such as composing callbacks using Lo-Dash functions that are already built and ready to go.</p><p>The <code class="literal">minimal()</code> function<a id="id447" class="indexterm"/> defined in this code is used to pick only the essential object properties from the passed-in argument. Let's say we want to pass this callback to <code class="literal">map()</code>. Well, <code class="literal">map()</code> invokes its callbacks with three arguments, the first one being the actual item we're interested in. This means that it's nearly impossible for us to use Lo-Dash functions with partially applied arguments as callbacks.</p><p>The workaround<a id="id448" class="indexterm"/> we've employed with the <code class="literal">minimal()</code> callback is to use <code class="literal">flow()</code> to compose the callback. You'll notice that the first function is <code class="literal">identity()</code>. This does nothing more than returning whatever value is passed to it. So in other words, it returns the first argument. Next in the flow is our partial function that uses <code class="literal">pick()</code>. And guess what? It'll only get one argument passed to it, as we need, even if used in a <code class="literal">map()</code> callback, which is called with three arguments.</p></div><div class="section" title="Composing chains"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Composing chains</h2></div></div></div><p>Now we'll look at composing <a id="id449" class="indexterm"/>functions that work with chains. As we've seen throughout this chapter, it's beneficial for you and anyone else who uses your functions to be flexible in what your functions accept as arguments, and what they return. For example, a function that accepts a wrapper and returns a wrapper means that it can be passed just about anything and that the caller is free to extend the call chain. Just as we can compose plain functions and callback functions, we can also compose functions whose main focus is working with chains. Take a look at the following example:</p><div class="informalexample"><pre class="programlisting">function sorted(wrapper) {
    return _(wrapper).sortBy();
}

function rejectOdd(wrapper) {
    return _(wrapper).reject(function(item) {
        return item % 2
    });
}

var sortedEvens = _.flow(sorted, rejectOdd),
    evensSorted = _.flow(rejectOdd, sorted,
        _.partialRight(_.result, 'value')),
    collection = _.shuffle(_.range(1, 11));

sortedEvens(collection)
    .reverse()
    .value();
// → [ 10, 8, 6, 4, 2 ]

evensSorted(collection);
// → [ 2, 4, 6, 8, 10 ]</pre></div><p>The <code class="literal">rejectOdd()</code> function<a id="id450" class="indexterm"/> here takes either a collection or a wrapper instance as <a id="id451" class="indexterm"/>the first argument and filters out the odd numbers. Notice that it returns a wrapper instead of the unwrapped value. We use this wrapper-friendly function to compose two new functions. The first is <code class="literal">sortedEvens()</code>, which uses our <code class="literal">sorted()</code> function to sort the collection. This returns a wrapper instance, which is then fed to the <code class="literal">rejectOdd()</code> function. The <code class="literal">evensSorted()</code> function<a id="id452" class="indexterm"/> does something similar but in a different order. It rejects the odd numbers before sorting them, and then it uses <code class="literal">partialRight()</code> to unwrap the value using <code class="literal">result()</code>.</p><p>You can see that when we call the <code class="literal">sortedEvens()</code> function, it returns a wrapper instance because we're extending the function call chain with <code class="literal">reverse()</code>, and then we get the value. However, we don't perform this extension with our composed <code class="literal">evensSorted()</code> function because it unwraps the value for us.</p></div><div class="section" title="Method composition"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Method composition</h2></div></div></div><p>Sometimes, it makes sense to attach <a id="id453" class="indexterm"/>functions to a specific object scope or implement methods. If the function requires instance-specific values in order to operate, then it's probably a good idea to implement the function as a property of the prototype so that it is always available to instances. So we can use the techniques we've looked at so far in this chapter to assist us with building object methods, which are yet another building block in our application's structure. Take a look at the following example of object methods:</p><div class="informalexample"><pre class="programlisting">function validThru(next, value) {
    return value &amp;&amp; next;
}

function User(first, last, age) {
    this.first = first;
    this.last = last;
    this.age = age;
}

User.prototype.valid = function() {
    return _.chain(this.first)
        .isString()
        .thru(_.partial(validThru, this.last))
        .isString()
        .thru(_.partial(validThru, this.age))
        .isFinite()
        .value();
}

new User('Orlando', 'Olson', 25).valid();
// → true

new User('Timothy', 'Davis').valid();
// → false

new User('Colleen').valid();
// → false</pre></div><p>Our <code class="literal">User</code> constructor accepts three arguments, and all of these are set as instance values. We've also implemented a <code class="literal">valid()</code> method. We're utilizing a function call chain here to validate each of the instance attributes. Note that we've enabled explicit chaining here. This means the functions in the chain that would normally return unwrapped values, won't. We're doing this because we need to pass primitive values through the chain.</p><p>The <code class="literal">first</code> property is wrapped, and we validate that it is a string using the <code class="literal">isString()</code> function. Next, we use <code class="literal">thru()</code>. We're using our <code class="literal">validThru()</code> function here as a callback to <code class="literal">thru()</code>. Basically, if the value returned by <code class="literal">isString()</code>, the previous call, is <code class="literal">true</code>, then return the next value. In this case, it's partially applied as the <code class="literal">last</code> property. The same steps are performed with the <code class="literal">age</code> property.</p><p>What's nice about this <a id="id454" class="indexterm"/>approach is that the chain requires access to several properties and all enclosed within the method. We can then construct a readable chain that validates all of these properties and doesn't require several control flow statements, which can be more difficult to maintain than two lines in a chain.</p></div></div>
<div class="section" title="Creating mixins"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Creating mixins</h1></div></div></div><p>The last major building block<a id="id455" class="indexterm"/> we'll visit in this chapter is the mixin. Lo-Dash has a <code class="literal">mixin()</code> function that lets us extend the API by providing our own functions. There are two reasons you'd want to do such a thing. The first is that by placing your generic toolset in the Lo-Dash object, you can have access to them wherever the <code class="literal">_</code> symbol is accessible. The second reason is that once you've mixed in your own function, it can be used as a piece in a function call chain.</p><div class="section" title="Creating an average() function"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Creating an average() function</h2></div></div></div><p>There's only so many utilities a <a id="id456" class="indexterm"/>library such as Lo-Dash can feasibly ship. The ones that are <a id="id457" class="indexterm"/>viewed as most applicable to common users are the ones we get out of the box. This doesn't mean that the application you're working on doesn't have a high-value use case you wish Lo-Dash implemented. For example, assume your application computes averages all over the place. While the library doesn't ship with an <code class="literal">average</code> function, that doesn't mean we can't add this function to the code:</p><div class="informalexample"><pre class="programlisting">_.mixin({average: function(coll, callback) {
    return _(coll)
        .map(callback)
        .reduce(function(result, item) {
            return result + item;
        }) / _.size(coll);
}});

var collection = [
    { name: 'Frederick', age: 41, enabled: true },
    { name: 'Jasmine', age: 29, enabled: true },
    { name: 'Virgil', age: 47, enabled: true },
    { name: 'Lila', age: 22, enabled: false }
];

_.average(collection, 'age');
// → 34.75

_.average(collection, function(item) {
    return _.size(item.name);
});
// → 6.5

_(collection)
    .filter('enabled')
    .average('age');
// → 39</pre></div><p>The computation that takes<a id="id458" class="indexterm"/> place in our <code class="literal">average()</code> mixin is really straightforward—division of the items by the length of the collection. It's the mapping of these items we need to consider. If you look at the arguments accepted by the <code class="literal">average()</code> mixin, you'll notice that it takes a collection, which is always required, and a callback. The callback is optional and can be anything that's accepted as a <code class="literal">map()</code> callback. Our chain then reduces <a id="id459" class="indexterm"/>these items to a sum before they're divided by the collection size.</p><p>You can see that the <code class="literal">average()</code> function is now part of the Lo-Dash object and that we're able to pass a string argument or a function callback. You can also see that the function is chainable, as demonstrated in the last invocation.</p></div><div class="section" title="Creating a distance() function"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Creating a distance() function</h2></div></div></div><p>Let's create a <a id="id460" class="indexterm"/>more involved mixin function called <code class="literal">distance</code>. It'll use the Levenshtein <a id="id461" class="indexterm"/>distance algorithm to measure the edit distance between two strings. We'll create another mixin that uses <code class="literal">distance()</code>. This function will sort collections by the shortest distance from the target string:</p><div class="informalexample"><pre class="programlisting">_.mixin({distance: function(source, target) {
    var sourceSize = _.size(source),
        targetSize = _.size(target),
        matrix;

    if (sourceSize === 0) {
        return targetSize;
    }
    if (targetSize === 0) {
        return sourceSize;
    }

    matrix = _.map(_.range(targetSize + 1), function(item) {
        return [ item ];
    });

     _.each(_.range(sourceSize + 1), function(item) {
        matrix[0][item] = item;
    });

    _.each(target, function(targetItem, targetIndex) {
        _.each(source, function(sourceItem, sourceIndex) {
            if (targetItem === sourceItem) {
                matrix[targetIndex + 1][sourceIndex + 1] =
                    matrix[targetIndex][sourceIndex];
            } else {
                matrix[targetIndex + 1][sourceIndex + 1] = Math.min(
                    matrix[targetIndex][sourceIndex] + 1,
                    Math.min(matrix[targetIndex + 1][sourceIndex] + 1,
                        matrix[targetIndex][sourceIndex + 1] + 1));
            }
        });
    });
        
    return matrix[targetSize][sourceSize]

}});

_.mixin({closest: function(coll, value, callback) {
    return _.sortBy(coll, _.flow(_.callback(callback), function(item) {
        return _.distance(value, item);
    }));
}});

var collection = [
    'console',
    'compete',
    'competition',
    'compose',
    'composition'
];

_.distance('good', 'food');
// → 1

_.closest(collection, 'composite');
// →
// [
//   "compose",
//   "compete",
//   "composition",
//   "console",
//   "competition"
// ]

_(collection)
    .closest('consulate')
    .first();
// → "console"</pre></div><p>We won't fixate on the<a id="id462" class="indexterm"/> details of the Levenshtein distance algorithm; there are plenty of online resources available for that. The <code class="literal">distance()</code> mixin we just implemented accepts a <code class="literal">source</code> string and a <code class="literal">target</code> string with which to compare it. The<a id="id463" class="indexterm"/> return value represents the number of edits needed to make the target match the source. For example, the call to <code class="literal">distance()</code>in the preceding code yields <code class="literal">1</code>.</p><p>The <code class="literal">closest()</code> mixin function uses <code class="literal">distance()</code> as a <code class="literal">sortBy()</code> callback. This is a useful function because it's often a collection of the target strings we're comparing the source string to. Further, since it's a mixin function, we're able to use it in a chain. The last call to <code class="literal">closest()</code> does this and then uses <code class="literal">first()</code> to grab the closest value.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, we learned some useful approaches to building higher-level application components. Functions are the fundamental unit of Lo-Dash programming, so it's important that we properly utilize all that they have to offer. We addressed some common issues faced when thinking about how to design reusable functions. For example, the specificity of a function and the arguments it accepts can impact where and how the function can be used in your Lo-Dash code.</p><p>Generic wrappers and the chained function calls they implement are powerful tools, and there are many implementation options that come with them. We walked through several examples of how different aspects of chains work, and how these wrappers interact with the various functions in our application.</p><p>Function composition is an essential part of functional programming and we learned how to exploit the functional tools Lo-Dash provides to compose larger pieces of our application code. These include the generic functions we call manually, and callback functions. This chapter closed with a look at the mixin functions that are used to extend the Lo-Dash API. The next chapter will show you how to take these application-level Lo-Dash components, and make sure they play nicely alongside other libraries.</p></div></body></html>