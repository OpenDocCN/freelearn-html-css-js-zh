["```js\n/* src/Ch06/Ch06_GenericInference.re */\nlet *triple*(*x*) = (*x*, *x*, *x*); /* (1) */\nlet *wrap*(*x*) = `*wrap*(*x*); /* (2) */\nlet *makeObj*(*x*) = {as _; pub *x* = *x*}; /* (3) */\nlet *greet*(*x*) = *print_endline*({j|Hello, $*x*!|j}); /* (4) */\n```", "```js\n/* src/Ch06/Ch06_List.re */\ntype list('a) = *Cons*('a, list('a)) | *Empty*; /* (1) */\n\n/* (2) */\nlet *people* = *Ch04_RecordLiterals*.(*Cons*(*bob*, *Cons*(*jim*, *Cons*(*tom*, *Empty*))));\n\n/* (3) */\nlet *greetOne*({*Ch04_RecordLiterals.id*, *name*}) = *print_endline*(\n {j|Hello, $*name* with ID $*id*!|j});\n\nlet rec *greetAll*(*people*) = switch (*people*) {\n| *Cons*(*person*, *people*) => { /* (4) */\n *greetOne*(*person*);\n *greetAll*(*people*)\n }\n| *Empty* => () /* (5) */\n};\n```", "```js\n/* src/Ch06/Ch06_ReasonList.re */\nlet *people* = *Ch04_RecordLiterals*.[*bob*, *jim*, *tom*]; /* (1) */\n\nlet rec *greetAll*(*people*) = switch (*people*) {\n| [*person*, ...*people*] => { /* (2) */\n    *Ch06_List.greetOne*(*person*); /* (3) */\n    *greetAll*(*people*)\n  }\n| [] => () /* (4) */\n};\n```", "```js\ntype option('a) = *Some*('a) | *None*;\n```", "```js\n/* src/Ch06/Ch06_Option.re */\nlet rec *tryFind*(*needle*, *haystack*) = switch (*haystack*) { /* (1) */\n| [*item*, ...*_items*] when *needle*(*item*) => *Some*(*item*) /* (2) */\n| [*_item*, ...*items*] => *tryFind*(*needle*, *items*) /* (3) */\n| [] => *None* /* (4) */\n};\n\nlet *optionallyGreet*(*person*) = switch (*person*) { /* (5) */\n| *Some*(*person*) => *Ch06_List.greetOne*(*person*)\n| *None* => *print_endline*(\"No such person!\")\n};\n\nlet *idEq1*({*Ch04_RecordLiterals.id*}) = *id* == 1; /* (6) */\nlet *idEq4*({*Ch04_RecordLiterals.id*}) = *id* == 4;\n\n*optionallyGreet*(*tryFind*(*idEq1*, *Ch06_ReasonList.people*)); /* (7) */\n*optionallyGreet*(*tryFind*(*idEq4*, *Ch06_ReasonList.people*));\n```", "```js\n$ node src/Ch06/Ch06_Option.bs.js \nHello, Bob with ID 1!\nNo such person!\n```", "```js\ntype ref('a) = {mutable *contents*: 'a}; /* (1) */\nlet *ref*: 'a => ref('a); /* (2) */\nlet (:=): (ref('a), 'a) => unit; /* (3) */\nlet (^): ref('a) => 'a; /* (4) */\nlet *incr*: ref(int) => unit; /* (5) */\nlet *decr*: ref(int) => unit;\n```", "```js\n/* src/Ch06/Ch06_Ref.re */\nlet *tryFind*(*needle*, *haystack*) = {\n  let *currHaystack* = *ref*(*haystack*);\n  let *stop* = *ref*(*false*);\n  let *currItem* = *ref*(*None*);\n\n  while (!(*stop*^)) { /* (1) */\n    switch (*currHaystack*^) { /* (2) */\n    | [*item*, ...*_items*] when *needle*(*item*) => { /* (3) */\n        *stop* := *true*;\n        *currItem* := *Some*(*item*)\n      }\n    | [*_item*, ...*items*] => *currHaystack* := *items* /* (4) */\n    | [] => *stop* := *true* /* (5) */\n    };\n  };\n\n  *currItem*^ /* (6) */\n};\n```", "```js\ntype array('a);\n```", "```js\n/* src/Ch06/Ch06_Array.re */\nlet *empty* = [||]; /* (1) */\nlet *singleton* = [|1|];\nlet *multi* = [|*false*, *true*, *true*|];\n\n*multi*[1] = *false*; /* (2) */\nJs.log(*multi*[1]); /* (3) */\n```", "```js\n/* src/Ch06/Ch06_TicTacToe.re */\n\n/* Each slot on the board can be taken by X or O, or it can be empty. */\ntype slot = *X* | *O* | *Empty*;\n\nlet *newBoard*() = *Array.make*(9, *Empty*); /* (1) */\n\n/* Coords are as follows on the board:\n   1 2 3\n   4 5 6\n   7 8 9 */\nlet *play*(*player*, *coord*, *board*) = *board*[*coord* - 1] = *player*; /* (2) */\n\nlet *xWon*(*board*) = switch (*board*) {\n| [|*X*, *X*, *X*, /* (3) */\n    _, _, _,\n    _, _, _|]\n| [|_, _, _, /* (4) */\n    *X*, *X*, *X*,\n    _, _, _|]\n| [|_, _, _,\n    _, _, _,\n    *X*, *X*, *X*|]\n| [|*X*, _, _,\n    *X*, _, _,\n    *X*, _, _|]\n| [|_, *X*, _,\n    _, *X*, _,\n    _, *X*, _|]\n| [|_, _, *X*,\n    _, _, *X*,\n    _, _, *X*|]\n| [|*X*, _, _,\n    _, *X*, _,\n    _, _, *X*|]\n| [|_, _, *X*,\n    _, *X*, _,\n    *X*, _, _|] => *true* /* (5) */\n| _ => *false* /* (6) */\n};\n```", "```js\n(Output from bsb -w)\n  We've found a bug for you!\n  src/Ch06/Ch06_ValueRestrictionError.re 2:17-24\n\n  1 │ /* src/Ch06/Ch06_ValueRestrictionError.re */\n  2 │ let optionArr = [|None|];\n  3 │ let optionRef = ref(None);\n\n  This expression's type contains type variables that can't be generalized:\n  array(option('_a))\n\n  This happens when the type system senses there's a mutation/side-effect, in combination with a polymorphic value.\n  Using or annotating that value usually solves it. More info:\n  https://realworldocaml.org/v1/en/html/imperative-programming-1.html#side-effects-and-weak-polymorphism\n```", "```js\n/* src/Ch06/Ch06_ValueRestrictionErrorFixed.re */\nlet optionArr: array(option(string)) = [|None|];\nlet optionRef: ref(option(string)) = ref(None);\n```", "```js\n(Output from bsb -w)\nWe've found a bug for you!\n  src/Ch06/Ch06_ValueRestrictionOtherError.re 5:15-28\n\n  1 │ /* src/Ch06/Ch06_ValueRestrictionOtherError.re */\n  2 │ let pair(x) = (x, x);\n  3 │ let pairAll = List.map(pair);\n\n  This expression's type contains type variables that can't be generalized:\n  list('_a) => list(('_a, '_a))\n\n  This happens when the type system senses there's a mutation/side-effect, in combination with a polymorphic value.\n  Using or annotating that value usually solves it. More info:\n  https://realworldocaml.org/v1/en/html/imperative-programming-1.html#side-effects-and-weak-polymorphism\n```", "```js\nlet *pairAll*(*list*) = *List.map*(*pair*, *list*);\n```", "```js\n/* src/Ch06/Ch06_PhantomTypes.re */\n\nmodule *Sql*: {\n  type column = string; /* (1) */\n  type table = string;\n  type t('a); /* (2) */\n\n  let *select*: list(column) => t([`*select*]); /* (3) */\n  let *from*: (table, t([`*select*])) => t([`*ok*]);\n  let *print*: t([`*ok*]) => string;\n} = {\n  type column = string;\n  type table = string;\n  type t('a) = string;\n\n  let *select*(*columns*) = { /* (4) */\n    let *commalist* = *String.concat*(\", \", *columns*);\n    {j|select $*commalist*|j}\n  };\n\n  let *from*(*table*, *t*) = {j|$*t* from $*table*|j};\n  let *print*(*t*) = *t*; /* (5) */\n};\n\nlet *sql* = *Sql*.(*select*([\"name\"]) |> *from*(\"employees\") |> *print*); /* (6) */\nJs.log(*sql*);\n```", "```js\n(Output from bsb -w)\nWe've found a bug for you!\n  src/Ch06/Ch06_PhantomTypes.re 25:36-40\n\n  23 │ };\n  24 │ \n  25 │ let sql = Sql.(select([\"name\"]) |> print); /* (6) */\n  26 │ Js.log(sql);\n\n  This has type:\n    Sql.t([ `ok ]) => string\n  But somewhere wanted:\n    Sql.t([ `select ]) => 'a\n  These two variant types have no intersection\n```"]