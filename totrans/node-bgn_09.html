<html><head></head><body>
		<div><h1 id="_idParaDest-237" class="chapter-number"><a id="_idTextAnchor244"/>9</h1>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor245"/>Handling HTTP and REST APIs</h1>
			<p>In this chapter, we will learn about the internet from both a historical point of view and a practical understanding of the infrastructure behind the internet that we know and use every day.</p>
			<p>We will deep dive into the protocols and architectures that make it possible to create web projects and will explore the RFCs that are the backbone of the current web browsing experience.</p>
			<p>We will master all the components and theoretical concepts around HTTP, URLs, and REST APIs.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>The history of the internet and how the internet infrastructure works</li>
				<li>What <strong class="bold">Requests for Comments</strong> (<strong class="bold">RFCs</strong>) are and how to use them</li>
				<li>HTTP communications between the server and clients (<strong class="bold">Single-Page Applications </strong>(<strong class="bold">SPAs</strong>) versus server-side rendering)</li>
				<li>Mastering HTTP (headers, status codes, payloads, verbs, and more)</li>
				<li>Using tools to debug HTTP requests</li>
				<li>How REST APIs are structured</li>
				<li>How the JSON spec works</li>
				<li>How the modern web works under the hood</li>
			</ul>
			<p>By the end of this chapter, you will have a clear idea of all the pieces in place that constitute the current internet and how you should build your web projects by applying this knowledge learned in this chapter.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor246"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/GleRpaaR2PQ">https://youtu.be/GleRpaaR2PQ</a></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor247"/>How the internet works under the hood</h1>
			<p>We use the internet every day, but do we know how it works? Wikipedia defines the internet<a id="_idIndexMarker470"/> as follows:</p>
			<p class="author-quote">“The Internet (or internet) is the global system of interconnected computer networks that uses the Internet protocol suite (TCP/IP) to communicate between networks and devices. It is a network of networks that consists of private, public, academic, business, and government networks of local to global scope, linked by a broad array of electronic, wireless, and optical networking technologies. The Internet carries a vast range of information resources and services, such as the interlinked hypertext documents and applications of the World Wide Web (WWW), electronic mail, telephony, and file sharing.”</p>
			<p>Basically, the internet is a global system that connects computers together through networks and employs certain protocols and techniques to enable that communication in a resilient way. The internet is used by all kinds of entities and people to share information resources and services using tools such as electronic mail, file sharing, and so on.</p>
			<p>But to be honest, this definition is just scratching the surface. To understand how the internet works, we need to go back in time and understand how it started.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor248"/>History of the internet</h2>
			<p>The internet as we know it today<a id="_idIndexMarker471"/> was not created by a single person or specific group of people. The internet is the product of the work of many people who contributed to the creation of different technologies and ideas that, over time, became what we know today as the modern internet.</p>
			<p>There are two main concepts that we need to keep in mind when we try to understand how the internet works from the engineering perspective. These concepts are the following:</p>
			<ul>
				<li><strong class="bold">Access to information</strong>: While the computer world was stuck<a id="_idIndexMarker472"/> in the mainframe era, user terminals had to be connected to a mainframe. The idea of remote access started to grow. Over time, humanity discovered that if we connect computers together, we can share information and resources between them. Basically, we can segment and distribute information and computer resources. We can connect with other people and share information<a id="_idIndexMarker473"/> with them faster than ever before in the history of humanity.</li>
				<li><strong class="bold">Resilience</strong>: In the 1960s, the US government<a id="_idIndexMarker474"/> was concerned about the possibility of a nuclear attack that could destroy the communication infrastructure. This concern was the seed of the idea of a distributed network without a single point of failure that could survive a nuclear attack, and that is the reason <a id="_idIndexMarker475"/>why the internet is very often referred to as a network of networks.</li>
			</ul>
			<p>Many more things needed<a id="_idIndexMarker476"/> to happen since the 20th century to make the internet a reality, but these two concepts remain strong in the architecture of the internet today.</p>
			<p class="callout-heading">Important info</p>
			<p class="callout">There is a great video that explains the history of the internet in a very simple way. You can watch it here: <a href="https://www.youtube.com/watch?v=9hIQjrMHTv4">https://www.youtube.com/watch?v=9hIQjrMHTv4</a>.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor249"/>Internet Infrastructure</h2>
			<p>Just to give you an idea of the dependency<a id="_idIndexMarker477"/> that we all have on the internet, there are hundreds of optic fiber cables connecting the world across the oceans and seas to make internet connectivity possible. Here is a map of the submarine cables that connect the world:</p>
			<div><div><img src="img/B21678_09_01.jpg" alt="Figure 9.1 – Our world is connected by dozens of fiber optic cables across the oceans. Screenshot from (https://www.submarinecablemap.com/) CC BY-SA 4.0."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Our world is connected by dozens of fiber optic cables across the oceans. Screenshot from (<a href="https://www.submarinecablemap.com/">https://www.submarinecablemap.com/</a>) CC BY-SA 4.0.</p>
			<p>Optic fiber cables are not<a id="_idIndexMarker478"/> the only way to connect to the internet. Other ways include satellites and radio waves. Over the years, the speed of the internet has increased and the cost of a connection has decreased thanks to endless research and innovation in the field of telecommunications.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor250"/>Request for Comments (RFC)</h2>
			<p>In this chapter, we will focus a lot<a id="_idIndexMarker479"/> on the specifications, protocols, and standards that we need to get familiar with in order to make our applications work.</p>
			<p>If this is the first time that you’re exploring such exotic topics, you may feel overwhelmed by the amount of information that you need to digest. But don’t worry, we will explore all these topics in a very simple and functional way.</p>
			<p>The Internet Engineering Task Force (IETF) defines<a id="_idIndexMarker480"/> an Request for Comments (RFC) as follows (<a href="https://www.ietf.org/standards/rfcs/">https://www.ietf.org/standards/rfcs/</a>):</p>
			<p class="author-quote">“ RFC documents contain technical specifications and organizational notes for the Internet.”</p>
			<p>Basically, RFC is a document<a id="_idIndexMarker481"/> that describes some kind of specification/protocol/standard to be designed as part of the internet architecture. Any person can submit an RFC to the IETF and if the RFC is approved, it becomes a standard while this sounds simple, this process can take a long time as the refinement and review process is exhaustive.</p>
			<p>Here is a simple extract<a id="_idIndexMarker482"/> from RFC 2616 (<a href="https://www.rfc-editor.org/rfc/rfc2616.txt">https://www.rfc-editor.org/rfc/rfc2616.txt</a>) that describes the <strong class="bold">Hypertext Transfer Protocol – HTTP/1.1</strong> in 175 pages:</p>
			<pre class="console">
Network Working Group                       R. Fielding
Request for Comments: 2616
  UC Irvine
Obsoletes: 2068
  J. Gettys
Category: Standards Track                    Compaq/W3C                                                  J. Mogul
                                                 Compaq
                                             H. Frystyk
                                                W3C/MIT
                                            L. Masinter
                                                  Xerox
                                               P. Leach
                                              Microsoft
                                         T. Berners-Lee
                                                W3C/MIT
                                              June 1999
                Hypertext Transfer Protocol -- HTTP/1.1
Status of this Memo
   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.
Copyright Notice
   Copyright (C) The Internet Society (1999).  All Rights Reserved.
Abstract
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [47]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 [33].</pre>			<p>Yeah, I know… this is not an easy read. I don’t expect you to read the whole RFC but we will explore some parts of it in this chapter in a practical way.</p>
			<p>The best aspect of RFCs is that they are free and you can read them online. You can find lots of quality information that can help you understand specific parts of the internet architecture when you<a id="_idIndexMarker483"/> need it.</p>
			<h3><strong class="bold">Other RFCs</strong></h3>
			<p>Just to get rid of that overwhelming feeling, I would like to share with you other RFCs that are more fun to read:</p>
			<ul>
				<li><strong class="bold">RFC 2324</strong> (<a href="https://tools.ietf.org/html/rfc2324">https://tools.ietf.org/html/rfc2324</a>): Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</li>
				<li><strong class="bold">RFC 1149 </strong>(<a href="https://tools.ietf.org/html/rfc1149">https://tools.ietf.org/html/rfc1149</a>): A Standard for the Transmission of IP Datagrams on Avian Carriers</li>
			</ul>
			<p>And my favorite one:</p>
			<ul>
				<li><strong class="bold"> RFC 2549</strong> (<a href="https://datatracker.ietf.org/doc/html/rfc2549">https://datatracker.ietf.org/doc/html/rfc2549</a>): IP over Avian Carriers with Quality of Service; an iteration of RFC 1149</li>
			</ul>
			<p>These funny RFCs can give you familiarity and an idea of the power of the RFC discussion format. Basically, if you want to create a new protocol, you can submit an RFC to the IETF and if the RFC is approved, it becomes a standard. You can read more about the RFC process here: <a href="https://www.rfc-editor.org/about/independent/">https://www.rfc-editor.org/about/independent/</a>.</p>
			<p>One of the most important<a id="_idIndexMarker484"/> protocols that you will need to know as a web developer is HTTP. In the next section, we will explore this protocol in detail and will learn the different architectures and components it involves and that are in use today as the backbone of the internet as we know it.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor251"/>HTTP – server and client relationship</h1>
			<p>While web development <a id="_idIndexMarker485"/>can be a very complex topic, we can simplify it by understanding the relationship between the server and the client in the typical web applications.</p>
			<p>We have two main actors, the server and the client:</p>
			<ul>
				<li><strong class="bold">Server</strong>: The server is the computer that<a id="_idIndexMarker486"/> is running the application, dealing with the database<a id="_idIndexMarker487"/> queries, and many other things. This server is often called the backend.</li>
				<li><strong class="bold">Client</strong>: The client is the piece of software<a id="_idIndexMarker488"/> that the end user executes on the local machine in the case of web applications. The user employs a web browser to execute<a id="_idIndexMarker489"/> the software (HTML, CSS, JS, etc.). The client is often called the frontend.</li>
			</ul>
			<p>The communication between the server and the client is done through HTTP. The client sends a request to the server and the server <a id="_idIndexMarker490"/>replies with a response. This is the typical request/response cycle</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor252"/>Request and response</h2>
			<p>The request and response<a id="_idIndexMarker491"/> are the two main parts of HTTP. The request is sent by the client to the server and the server returns a response. The request and response are composed of different parts that we will explore in the following sections.</p>
			<div><div><img src="img/B21678_09_02.jpg" alt="Figure 9.2 – The relationship between the server, internet, and multiple clients"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The relationship between the server, internet, and multiple clients</p>
			<p>As we can see in the preceding diagram, one server can handle multiple clients at the same time. This is the typical architecture of a web application. The server handles the requests from clients and responds with the corresponding response.</p>
			<p>But very often, one client will send multiple requests to a single server or multiple servers. Let’s take a look at the following HTML snippet:</p>
			<pre class="source-code">
&lt;head&gt;
&lt;link rel="stylesheet" type="text/css" href="https://server1.com/style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src="img/image.png"&gt;
&lt;script type="text/javascript" src="img/script.js"&gt;&lt;/script&gt;
&lt;/body&gt;</pre>			<p>As we can see, the client sends three requests to three different servers (<code>server1.com</code>, <code>server2.com</code>, and <code>server3.com</code>) asking for specific resources. Each server will eventually respond with the requested resource.</p>
			<p>As a simple example, let’s go to <a href="https://packtpub.com">https://packtpub.com</a> and open the developer<a id="_idIndexMarker492"/> tools in our browser. In the <strong class="bold">Network</strong> tab, we can see all the requests that the browser is sending to the server and the responses from the server:</p>
			<div><div><img src="img/B21678_09_03.jpg" alt="Figure 9.3 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Web browser screenshot</p>
			<p>If you pay attention to the bottom part of <em class="italic">Figure 9</em><em class="italic">.3</em>, you can easily see that this page is sending more than 60 requests targeting different servers to render the page. This is a very common scenario in web applications: the client sends multiple requests to the server(s) to get key resources including favicons, CSS files, JS files, images, videos, and raw data. If we look at the table, we can see each item that is loaded, and can debug and explore each request that was made. This can be intimidating at the beginning, but once you know how the filter works<a id="_idIndexMarker493"/> and you spend some hours working with it you will feel more comfortable.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor253"/>Server-side rendering</h2>
			<p>In the beginning, web applications<a id="_idIndexMarker494"/> were very simple, and JavaScript was very limited in its usage. Web applications were rendered on the server and the client just received<a id="_idIndexMarker495"/> the HTML, CSS, and JS files. This is called server-side rendering, and it is still used in many applications.</p>
			<p>While this model is still used today, there are some clear disadvantages. Any time the user wants to interact with the application, the server needs to render the page again and send it to the client. This generates a lot of traffic and the user experience is not the best, as there are moments where the website appears blank between refreshes.</p>
			<div><div><img src="img/B21678_09_04.jpg" alt="Figure 9.4 – The relationship between the server and client in the server-side rendering approach"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The relationship between the server and client in the server-side rendering approach</p>
			<p>This pattern was especially bad in the early days of smartphones, when mobile devices were not powerful enough to render the pages and the connection was not very good. The user experience was very bad. The solution was to move<a id="_idIndexMarker496"/> the rendering to the client side, this is called client-side rendering.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor254"/>Single-Page Applications (SPAs)</h2>
			<p>In client-side rendering, the server<a id="_idIndexMarker497"/> sends the initial HTML, CSS, and JS files to the client. Then, JavaScript takes control of the application and renders the views on the client side. Thus, the server only sends the data to the client<a id="_idIndexMarker498"/> and the client renders the page. This is called a <strong class="bold">Single-Page Application</strong> (<strong class="bold">SPA</strong>) and it is the most common pattern today.</p>
			<div><div><img src="img/B21678_09_05.jpg" alt="Figure 9.5 – The relationship between the server in the AJAX approach"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The relationship between the server in the AJAX approach</p>
			<p>At first, this pattern was very complicated to implement, but with the evolution of JavaScript frameworks, this pattern has become very popular. Today, we have a lot of frameworks that can help us to build SPAs easily. Some of the most popular frameworks are Angular, React, and Vue.js. The SPA pattern<a id="_idIndexMarker499"/> uses the same HTTP but in a different way via <strong class="bold">Asynchronous JavaScript and XML</strong> (<strong class="bold">AJAX</strong>) requests.</p>
			<p>This new technique introduced <a id="_idIndexMarker500"/>a lot of changes and innovations in the way we build the backend applications. Backend applications became more like an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) that responds with data to the client, and not only to the typical web clients, but now even servers can also use this API to exchange information with each other.</p>
			<p>Now that we have a clear idea of the components and possible web architectures, it is time to deep dive into HTTP so we can build solid projects using standardized communication between the server and the clients.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor255"/>Mastering HTTP</h1>
			<p>Now that we have a better understanding <a id="_idIndexMarker501"/>of the HTTP concept, let’s take a look at the different parts of HTTP that we need to understand in order to build a web application.</p>
			<p>We have already seen the request and response, but let’s take a deeper look at the different parts that compose the request and the response (headers, payloads, versions, and methods).</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor256"/>HTTP headers</h2>
			<p>Each request and response<a id="_idIndexMarker502"/> has a set of headers. These are key-value pairs and provide additional information about the request or the response.</p>
			<p>While both the request and response headers may look similar, they are not the same, although they do share common key-value pairs.</p>
			<h3>Request headers</h3>
			<p>We will start by analyzing<a id="_idIndexMarker503"/> in <em class="italic">Figure 9</em><em class="italic">.6</em> what is included in the request header:</p>
			<div><div><img src="img/B21678_09_06.jpg" alt="Figure 9.6 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5</p>
			<p>Let’s group the different header properties:</p>
			<ul>
				<li>Representation headers: <code>content-type</code> and <code>content-length</code></li>
				<li>General headers: <code>keep-alive</code> and <code>upgrade-insecure-requests</code></li>
				<li>Request headers: <code>accept</code>, <code>accept-encoding</code>, <code>accept-language</code>, <code>host</code>, and <code>user-agent</code></li>
			</ul>
			<p>Just by looking at the headers, we can understand many things about a request, such as the type of content the client is expecting, the language, and the browser used. The server can use this information <a id="_idIndexMarker504"/>to provide a better response to the client.</p>
			<p class="callout-heading">Important info</p>
			<p class="callout">This is just a small list of the possible headers. There are many more headers that we can use to provide more information about the request or response. We can even create our own key-value<a id="_idIndexMarker505"/> pairs. You can find the list of the HTTP headers here: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</a>.</p>
			<h3>Response headers</h3>
			<p>We will finish by analyzing<a id="_idIndexMarker506"/> in the <em class="italic">Figure 9</em><em class="italic">.7</em> what is included in the response header</p>
			<div><div><img src="img/B21678_09_07.jpg" alt="Figure 9.7 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5</p>
			<p>The response headers are very similar to the request headers, but they are not the same. They can be grouped as follows:</p>
			<ul>
				<li>Representation headers: <code>content-type</code>, <code>content-encoding</code>, and <code>last-modified</code></li>
				<li>General headers: <code>connection</code>, <code>date</code>, <code>keep-alive</code>, and <code>transfer-encoding</code></li>
				<li>Response headers: <code>access-control-allow-origin</code>, <code>etag</code>, <code>server</code>, <code>set-cookie</code>, <code>vary</code>, and <code>x-frame-options</code></li>
			</ul>
			<p>With the response headers, we can also provide additional information that will help the browsers and the web applications to digest and render the information properly.</p>
			<p>The response headers are very important for the security of the application, as there are many headers that can prevent certain attacks in the web browser environment. For example, we can use <code>x-frame-options</code> to prevent the application from being loaded in an <code>iframe</code>, or use <code>feature-policy</code> to prevent the application from using features such as the camera <a id="_idIndexMarker507"/>or microphone. We will explore this in <a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor257"/>Status codes</h2>
			<p>Overall, one of the most important<a id="_idIndexMarker508"/> pieces of information that we can find in the response is the status code.</p>
			<p>The status code allows us to understand whether the request was successful or not and can even provide more granular feedback. We can classify status codes into the following groups:</p>
			<ul>
				<li>1xx: Informational</li>
				<li>2xx: Success</li>
				<li>3xx: Redirection</li>
				<li>4xx: Client Error</li>
				<li>5xx: Server Error</li>
			</ul>
			<p>The most common status codes are <code>200 OK</code>, <code>201 Created</code>, <code>301 Moved Permanently</code>, <code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>403 Forbidden</code>, <code>404 Not Found</code>, <code>429 Too Many Requests</code>, <code>500 Internal Server Error</code>, and <code>503 Service Unavailable</code>. You can find<a id="_idIndexMarker509"/> the complete list of the status codes here: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a>.</p>
			<p>As you can see, if you know the given status code, you can understand what happened with your request. For example, a <code>429</code> error code occurs when the client has sent too many requests in a given amount of time (“rate limiting”), but if you receive a <code>401</code> then the error is related to your authentication. Finally, if in the same scenario you receive <code>403</code>, you are correctly authenticated but you don’t have enough permission to perform the given operation, such as deleting another user account.</p>
			<p>We all have experienced<a id="_idIndexMarker510"/> the <code>404</code> error code, which is very common when we try to access a resource that doesn’t exist. For example, if we try to access the following URL, <code>https://www.google.com/invented-resource</code>, we will receive a <code>404</code> error code.</p>
			<p class="callout-heading">418 I’m a teapot</p>
			<p class="callout">There is a strong culture on the internet to build fancy 404 pages. You can find a lot of examples online, but not many people know that there is a special error code <code>418</code> that RFC 2324 (<a href="https://tools.ietf.org/html/rfc2324">https://tools.ietf.org/html/rfc2324</a>) describes as follows:</p>
			<p class="callout">“Any attempt to brew coffee with a teapot should result in the error code “418 I’m a teapot”. The resulting entity body MAY be short and stout.”</p>
			<p class="callout">While this might seem just like a running joke, it is actually supported by many entities including Node (<a href="https://github.com/nodejs/node/issues/14644">https://github.com/nodejs/node/issues/14644</a>) and Google.</p>
			<div><div><img src="img/B21678_09_08.jpg" alt="Figure 9.8 – Web browser screenshot of google.com/teapot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Web browser screenshot of google.com/teapot</p>
			<p>As Shane Brunswick said on the Save 418 Movement website (<a href="https://save418.com/">https://save418.com/</a>):</p>
			<p class="author-quote">“It’s a reminder that the underlying processes of computers are still made by humans. It’d be a real shame to see 418 go.”</p>
			<p>And I do agree with him: behind these complex systems<a id="_idIndexMarker511"/> there are humans, and we should not forget that, in the same way that we should not forget that the internet could not exist without the open source movement and the hacker culture.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor258"/>Request methods</h2>
			<p>Just as status codes are very important<a id="_idIndexMarker512"/> to understand responses, the request methods are essential to understand requests.</p>
			<p>There are many request methods, but the most common are the following: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>. You can find<a id="_idIndexMarker513"/> the complete list of the request methods here: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a>.</p>
			<p>The way that we backend developers use them can differ a bit, but the most common way is the following:</p>
			<ul>
				<li><code>GET</code>: Retrieve a resource</li>
				<li><code>POST</code>: Create a resource</li>
				<li><code>PUT</code>: Update a resource</li>
				<li><code>PATCH</code>: Partially update a resource</li>
				<li><code>DELETE</code>: Delete a resource</li>
			</ul>
			<p>We will explore them in detail in <a href="B21678_11.xhtml#_idTextAnchor300"><em class="italic">Chapter 11</em></a><em class="italic">, </em>when we create an actual REST API with all the endpoints.</p>
			<p>In the early days of the internet, we used<a id="_idIndexMarker514"/> forms to send data to the server and specified the given method in the form. See the following, for example:</p>
			<pre class="source-code">
&lt;form action="/user" method="POST"&gt;
  &lt;input type="text" name="username" /&gt;
  &lt;input type="password" name="password" /&gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;</pre>			<p>The preceding code was a common way to send data to a server in order to create a new user, but nowadays we use JavaScript to send data to the server. For example, we can use the <code>fetch</code> API to send data to the server as follows:</p>
			<pre class="source-code">
fetch('/user', {
  method: 'POST',
  headers: {
   'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    username: 'john',
    password: '1234'
  })
})</pre>			<p>And then we would use the response to inform the user whether the request was successful or not. While using JavaScript to send data to the server is more complex, it gives us more flexibility and control<a id="_idIndexMarker515"/> over the request.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When you enter a URL in the browser, the browser sends a <code>GET</code> request to the server. This is the default method that the browser uses. You have been using HTTP methods for a long time without knowing it.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor259"/>HTTP payloads</h2>
			<p>HTTP messages can carry<a id="_idIndexMarker516"/> a payload, which means that we can send data to the server, and servers likewise can send data to their clients. This is often done with <code>POST</code> requests.</p>
			<p>Payloads can be in many formats, but the most common are the following:</p>
			<ul>
				<li><code>application/json</code>: Used when sharing JSON data</li>
				<li><code>application/x-www-form-urlencoded</code>: Used when sending simple texts in ASCII, sending data in the URL</li>
				<li><code>multipart/form-data</code>: Used when sending binary data (such as files) or non-ASCII texts</li>
				<li><code>text/plain</code>: Used when sending plain text, such as a log file</li>
				<li>You can find the complete list of the content types here: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a>.</li>
			</ul>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor260"/>HTTP versions</h2>
			<p>HTTP has evolved over<a id="_idIndexMarker517"/> the years, and we have different versions of the protocol:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Version</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Year</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Status</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>HTTP/0.9</code></p>
						</td>
						<td class="No-Table-Style">
							<p>1991</p>
						</td>
						<td class="No-Table-Style">
							<p>Obsolete</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>HTTP/1.0</code></p>
						</td>
						<td class="No-Table-Style">
							<p>1996</p>
						</td>
						<td class="No-Table-Style">
							<p>Obsolete</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>HTTP/1.1</code></p>
						</td>
						<td class="No-Table-Style">
							<p>1997</p>
						</td>
						<td class="No-Table-Style">
							<p>Standard</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>HTTP/2</code></p>
						</td>
						<td class="No-Table-Style">
							<p>2015</p>
						</td>
						<td class="No-Table-Style">
							<p>Standard</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>HTTP/3</code></p>
						</td>
						<td class="No-Table-Style">
							<p>2022</p>
						</td>
						<td class="No-Table-Style">
							<p>Standard</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Currently, the most used version of the protocol is the <code>HTTP/1.1</code> version, but the <code>HTTP/2</code> version is gaining popularity. The <code>HTTP/3</code> version is quite new and not widely supported yet.</p>
			<p>Nowadays, Node supports the <code>HTTP/1.1</code> and <code>HTTP/2</code> versions, but it doesn’t support the <code>HTTP/3</code> version yet. There is an ongoing strategic initiative to support it: <a href="https://github.com/nodejs/node/issues/38478">https://github.com/nodejs/node/issues/38478</a>.</p>
			<p>In the next section, we will learn how important <strong class="bold">Uniform Resource Locators</strong> (<strong class="bold">URLs</strong>) are and how we can use<a id="_idIndexMarker518"/> them to structure access to resources in our web applications.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor261"/>Using URLs in web applications</h1>
			<p>Let’s take a look<a id="_idIndexMarker519"/> at the following<a id="_idIndexMarker520"/> table, made by Node.js, that describes the different parts of a URL:</p>
			<div><div><img src="img/B21678_09_09.jpg" alt="Figure 9.9 – URL structure from the Node.js Official Documentation. Attributions and copyright licensing by Node.js Contributors is licensed under MIT"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – URL structure from the Node.js Official Documentation. Attributions and copyright licensing by Node.js Contributors is licensed under MIT</p>
			<p>In the following chapters, we will use the URL parts a lot, so keep this table handy. There are many ways to parse a URL, but the most common way is to use the <code>URL</code> class:</p>
			<pre class="source-code">
import { URL } from 'node:url';
const myUrl = new URL('https: //user:pass @sub.example. com:8080 /p/a/t/h?query=string#hash');
console.log(myUrl.hash); // #hash
console.log(myUrl.host); // sub.example.com:8080
console.log(myUrl.hostname); // sub.example.com</pre>			<p>This class is available in Node.js and in the browser.</p>
			<p class="callout-heading">Important info</p>
			<p class="callout">Node.js 20 introduced one of the most performant<a id="_idIndexMarker521"/> URL parsers available, called Ada 2.0: <a href="https://www.yagiz.co/announcing-ada-url-parser-v2-0">https://www.yagiz.co/announcing-ada-url-parser-v2-0</a>.</p>
			<p>Now that we know how flexible<a id="_idIndexMarker522"/> URLs are, let’s explore in the next section<a id="_idIndexMarker523"/> how we can build a standard layer on top of our web services. This layer is the foundation of many online services and SaaS products. We will learn the basics of creating web application interfaces (APIs).</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor262"/>REST APIs in a nutshell</h1>
			<p><strong class="bold">REST</strong> stands for <strong class="bold">Representational State Transfer</strong>, and is an architectural style for building<a id="_idIndexMarker524"/> APIs. It was introduced<a id="_idIndexMarker525"/> by Roy Fielding in his PhD dissertation (<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>) in 2000.</p>
			<p>In practical terms, the idea is to define a set of resources that can be accessed by the client using HTTP, as we explored in the previous section.</p>
			<p>Each resource is identified by a unique URL, and the client can perform operations on it using the HTTP methods. The server will respond with a status code and a payload when necessary.</p>
			<p>For example, let’s say that we have a REST API to manage a database of movies. We can define the following resources:</p>
			<ul>
				<li><code>/movies</code>: This resource represents the collection of movies</li>
				<li><code>/movies/:id</code>: This resource represents a single movie</li>
			</ul>
			<p class="callout-heading">Important tip</p>
			<p class="callout">The <code>:id</code> part of the URL is a placeholder<a id="_idIndexMarker526"/> for the user ID. This is called a URL parameter, and takes the form of <code>/movies/1</code> or <code>/movies/12345</code>, and so on.</p>
			<p>The client can perform the following operations on these resources using the aforementioned HTTP methods:</p>
			<ul>
				<li><code>GET /movies:</code> Get all the movies</li>
				<li><code>GET /movies/:id</code>: Get a single movie</li>
				<li><code>POST /movies</code>: Create a new movie</li>
				<li><code>PUT /movies/:id</code>: Update a movie</li>
				<li><code>DELETE /movies/:id</code>: Delete a movie</li>
			</ul>
			<p>Most of the time, the server<a id="_idIndexMarker527"/> will respond with a JSON payload, but it can also respond with other formats such as XML or HTML.</p>
			<p>Let’s see an example of a REST API in action. We will use simple-api (<a href="https://www.npmjs.com/package/@ulisesgascon/simple-api">https://www.npmjs.com/package/@ulisesgascon/simple-api</a>), which is a very simple HTTP API to build fast prototypes. This API includes Swagger documentation that can be used to explore the API.</p>
			<div><div><img src="img/B21678_09_10.jpg" alt="Figure 9.10 – Web browser screenshot of the API documentation generated with Swagger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Web browser screenshot of the API documentation generated with Swagger</p>
			<p>As you can see, the API is quite<a id="_idIndexMarker528"/> intuitive and easy to use because it follows the REST principles. So, you intuitively know how to use it. We can use Swagger to explore more details of the payload expected by the API when we create a new todo:</p>
			<div><div><img src="img/B21678_09_11.jpg" alt="Figure 9.11 – Web browser screenshot of the API documentation generated with Swagger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Web browser screenshot of the API documentation generated with Swagger</p>
			<p>It is also possible to explore the potential responses that the API can return for any specific endpoint that is available:</p>
			<div><div><img src="img/B21678_09_12.jpg" alt="Figure 9.12 – Web browser screenshot of the API documentation generated with Swagger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Web browser screenshot of the API documentation generated with Swagger</p>
			<p>If you understand how RESTful APIs work, you will be able to use any API based on HTTP. For example, the GitHub API <a href="https://docs.github.com/en/rest">https://docs.github.com/en/rest</a> is a REST API that uses HTTP to expose its services.</p>
			<p>There is a world full of APIs out there, waiting for you to use them to build amazing projects. Here is a great list<a id="_idIndexMarker529"/> of public APIs: <a href="https://apilist.fun/">https://apilist.fun/</a></p>
			<p>Throughout the previous<a id="_idIndexMarker530"/> chapters, we have mentioned JSON, but we haven’t explained it in detail, so in the next section we will deep dive into it, as it is the most common format to exchange data in modern APIs.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor263"/>Exploring the JSON specification</h1>
			<p><strong class="bold">JSON</strong> stands for <strong class="bold">JavaScript Object Notation</strong>, and is a lightweight<a id="_idIndexMarker531"/> data-interchange format. It is easy for humans to read and write, and it is easy for machines to parse and generate.</p>
			<p>We can easily convert a JavaScript object to a JSON string using the <code>JSON.stringify()</code> method:</p>
			<pre class="source-code">
const user = {
  name: 'John',
  age: 30
};
const json = JSON.stringify(user);</pre>			<p>And we can convert a JSON string to a JavaScript object using the <code>JSON.parse()</code> method:</p>
			<pre class="source-code">
const json = '{"name":"John","age":30}';
const user = JSON.parse(json);</pre>			<p>While the JSON name includes the world JavaScript, it is a language-independent data format. Many programming languages have libraries to parse and generate JSON.</p>
			<p>JSON is the most common<a id="_idIndexMarker532"/> format used to exchange data between clients and servers, such as when we use or build a REST API.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The JSON specification is quite simple, and I strongly suggest you read it. You can find it at <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf">https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf</a></p>
			<p>In the next section, we will explore how to debug HTTP requests so that we can build complex projects easily.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor264"/>Debugging HTTP requests</h1>
			<p>There are many ways<a id="_idIndexMarker533"/> to debug HTTP requests. The most common way is to use the developer tools, as these are easily accessible in most web browsers. It is also quite helpful when you are developing a website to keep these tools open and navigate between the tabs to debug UI components and network requests.</p>
			<p>But there are also other tools<a id="_idIndexMarker534"/> that you can <a id="_idIndexMarker535"/>use, such as Postman (<a href="https://www.postman.com/">https://www.postman.com/</a>) or Insomnia (<a href="https://insomnia.rest/">https://insomnia.rest/</a>), which were designed specifically for this purpose and offer many features out of the box (collections, authentication, etc.). These tools are the best option if you don’t have a website and you are just testing API endpoints directly.</p>
			<p>In the next chapters, we will use the developer tools of the browser to debug our HTTP transactions and will use Jest to test and debug our HTTP requests.</p>
			<p>Other developers use<a id="_idIndexMarker536"/> more advanced tools such as Charles (<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a>) or Wireshark (<a href="https://www.wireshark.org/">https://www.wireshark.org/</a>), but they are not necessary<a id="_idIndexMarker537"/> for the scope of this book.</p>
			<p>If you are not familiar with the developer<a id="_idIndexMarker538"/> tools of your browser, you can read more about it in <a href="B21678_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor265"/>Summary</h1>
			<p>In this chapter, we have learned a lot about the technologies that we will use to build our applications and that constitute the foundation of the modern internet.</p>
			<p>Additionally, we have learned how RFC documents are used to define the standards of the internet and how we can use them to learn more about the technologies that we use.</p>
			<p>Later on, we learned how the server-client architecture works and how HTTP is used to exchange data between the client and the server in detail, including HTTP methods and status codes.</p>
			<p>Finally, we explored the URL parts and learned how to use them to build RESTful APIs. We also learned about the JSON specification in more detail and how to debug HTTP requests.</p>
			<p>In the next chapter, we will explore how we can use databases to store data and how we can interact with them. This is the last piece of the puzzle before we can start building our final web application.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor266"/>Further reading</h1>
			<ul>
				<li><em class="italic">Wikipedia</em> | <em class="italic">IP over Avian </em><em class="italic">Carriers</em>: <a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers">https://en.wikipedia.org/wiki/IP_over_Avian_Carriers</a></li>
				<li><em class="italic">Wikipedia</em> | <em class="italic">HTTP</em>: <a href="https://en.wikipedia.org/wiki/HTTP">https://en.wikipedia.org/wiki/HTTP</a></li>
				<li><em class="italic">History of the </em><em class="italic">Internet</em>: <a href="https://www.youtube.com/watch?v=9hIQjrMHTv4">https://www.youtube.com/watch?v=9hIQjrMHTv4</a></li>
				<li><em class="italic">How the Internet Works in 5 </em><em class="italic">Minutes</em>: <a href="https://www.youtube.com/watch?v=7_LPdttKXPc">https://www.youtube.com/watch?v=7_LPdttKXPc</a></li>
				<li>An overview of HTTP: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview</a></li>
				<li><em class="italic">Project Code Rush - The Beginnings of Netscape / Mozilla </em><em class="italic">Documentary</em>: <a href="https://www.youtube.com/watch?v=4Q7FTjhvZ7Y">https://www.youtube.com/watch?v=4Q7FTjhvZ7Y</a></li>
				<li><em class="italic">How The Internet Travels Across </em><em class="italic">Oceans</em>: <a href="https://www.youtube.com/watch?v=yd1JhZzoS6A">https://www.youtube.com/watch?v=yd1JhZzoS6A</a></li>
				<li><em class="italic">There is a Reason Why Underwater Power Cables are So </em><em class="italic">Expensive</em>: <a href="https://www.youtube.com/watch?v=bkgvqC3M1Tw">https://www.youtube.com/watch?v=bkgvqC3M1Tw</a></li>
				<li><em class="italic">Jeff Geerling</em> | <em class="italic">Testing one of the oldest internet </em><em class="italic">myths</em>: <a href="https://www.youtube.com/watch?v=4pz2kMxCu8I">https://www.youtube.com/watch?v=4pz2kMxCu8I</a></li>
			</ul>
		</div>
	</body></html>