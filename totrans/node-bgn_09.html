<html><head></head><body>
		<div id="_idContainer059">
			<h1 id="_idParaDest-237" class="chapter-number"><a id="_idTextAnchor244"/>9</h1>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor245"/>Handling HTTP and REST APIs</h1>
			<p>In this chapter, we will learn about the internet from both a historical point of view and a practical understanding of the infrastructure behind the internet that we know and use <span class="No-Break">every day.</span></p>
			<p>We will deep dive into the protocols and architectures that make it possible to create web projects and will explore the RFCs that are the backbone of the current web <span class="No-Break">browsing experience.</span></p>
			<p>We will master all the components and theoretical concepts around HTTP, URLs, and <span class="No-Break">REST APIs.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>The history of the internet and how the internet <span class="No-Break">infrastructure works</span></li>
				<li>What <strong class="bold">Requests for Comments</strong> (<strong class="bold">RFCs</strong>) are and how to <span class="No-Break">use them</span></li>
				<li>HTTP communications between the server and clients (<strong class="bold">Single-Page Applications </strong>(<strong class="bold">SPAs</strong>) versus <span class="No-Break">server-side rendering)</span></li>
				<li>Mastering HTTP (headers, status codes, payloads, verbs, <span class="No-Break">and more)</span></li>
				<li>Using tools to debug <span class="No-Break">HTTP requests</span></li>
				<li>How REST APIs <span class="No-Break">are structured</span></li>
				<li>How the JSON <span class="No-Break">spec works</span></li>
				<li>How the modern web works under <span class="No-Break">the hood</span></li>
			</ul>
			<p>By the end of this chapter, you will have a clear idea of all the pieces in place that constitute the current internet and how you should build your web projects by applying this knowledge learned in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor246"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/GleRpaaR2PQ"><span class="No-Break">https://youtu.be/GleRpaaR2PQ</span></a></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor247"/>How the internet works under the hood</h1>
			<p>We use the internet every day, but do we know how it works? Wikipedia defines the internet<a id="_idIndexMarker470"/> <span class="No-Break">as follows:</span></p>
			<p class="author-quote">“The Internet (or internet) is the global system of interconnected computer networks that uses the Internet protocol suite (TCP/IP) to communicate between networks and devices. It is a network of networks that consists of private, public, academic, business, and government networks of local to global scope, linked by a broad array of electronic, wireless, and optical networking technologies. The Internet carries a vast range of information resources and services, such as the interlinked hypertext documents and applications of the World Wide Web (WWW), electronic mail, telephony, and file sharing.”</p>
			<p>Basically, the internet is a global system that connects computers together through networks and employs certain protocols and techniques to enable that communication in a resilient way. The internet is used by all kinds of entities and people to share information resources and services using tools such as electronic mail, file sharing, and <span class="No-Break">so on.</span></p>
			<p>But to be honest, this definition is just scratching the surface. To understand how the internet works, we need to go back in time and understand how <span class="No-Break">it started.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor248"/>History of the internet</h2>
			<p>The internet as we know it today<a id="_idIndexMarker471"/> was not created by a single person or specific group of people. The internet is the product of the work of many people who contributed to the creation of different technologies and ideas that, over time, became what we know today as the <span class="No-Break">modern internet.</span></p>
			<p>There are two main concepts that we need to keep in mind when we try to understand how the internet works from the engineering perspective. These concepts are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Access to information</strong>: While the computer world was stuck<a id="_idIndexMarker472"/> in the mainframe era, user terminals had to be connected to a mainframe. The idea of remote access started to grow. Over time, humanity discovered that if we connect computers together, we can share information and resources between them. Basically, we can segment and distribute information and computer resources. We can connect with other people and share information<a id="_idIndexMarker473"/> with them faster than ever before in the history <span class="No-Break">of humanity.</span></li>
				<li><strong class="bold">Resilience</strong>: In the 1960s, the US government<a id="_idIndexMarker474"/> was concerned about the possibility of a nuclear attack that could destroy the communication infrastructure. This concern was the seed of the idea of a distributed network without a single point of failure that could survive a nuclear attack, and that is the reason <a id="_idIndexMarker475"/>why the internet is very often referred to as a network <span class="No-Break">of networks.</span></li>
			</ul>
			<p>Many more things needed<a id="_idIndexMarker476"/> to happen since the 20th century to make the internet a reality, but these two concepts remain strong in the architecture of the <span class="No-Break">internet today.</span></p>
			<p class="callout-heading">Important info</p>
			<p class="callout">There is a great video that explains the history of the internet in a very simple way. You can watch it <span class="No-Break">here: </span><a href="https://www.youtube.com/watch?v=9hIQjrMHTv4"><span class="No-Break">https://www.youtube.com/watch?v=9hIQjrMHTv4</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor249"/>Internet Infrastructure</h2>
			<p>Just to give you an idea of the dependency<a id="_idIndexMarker477"/> that we all have on the internet, there are hundreds of optic fiber cables connecting the world across the oceans and seas to make internet connectivity possible. Here is a map of the submarine cables that connect <span class="No-Break">the world:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B21678_09_01.jpg" alt="Figure 9.1 – Our world is connected by dozens of fiber optic cables across the oceans. Screenshot from (https://www.submarinecablemap.com/) CC BY-SA 4.0."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Our world is connected by dozens of fiber optic cables across the oceans. Screenshot from (<a href="https://www.submarinecablemap.com/">https://www.submarinecablemap.com/</a>) CC BY-SA 4.0.</p>
			<p>Optic fiber cables are not<a id="_idIndexMarker478"/> the only way to connect to the internet. Other ways include satellites and radio waves. Over the years, the speed of the internet has increased and the cost of a connection has decreased thanks to endless research and innovation in the field <span class="No-Break">of telecommunications.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor250"/>Request for Comments (RFC)</h2>
			<p>In this chapter, we will focus a lot<a id="_idIndexMarker479"/> on the specifications, protocols, and standards that we need to get familiar with in order to make our <span class="No-Break">applications work.</span></p>
			<p>If this is the first time that you’re exploring such exotic topics, you may feel overwhelmed by the amount of information that you need to digest. But don’t worry, we will explore all these topics in a very simple and <span class="No-Break">functional way.</span></p>
			<p>The Internet Engineering Task Force (IETF) defines<a id="_idIndexMarker480"/> an Request for Comments (RFC) as <span class="No-Break">follows (</span><a href="https://www.ietf.org/standards/rfcs/"><span class="No-Break">https://www.ietf.org/standards/rfcs/</span></a><span class="No-Break">):</span></p>
			<p class="author-quote">“ RFC documents contain technical specifications and organizational notes for the Internet.”</p>
			<p>Basically, RFC is a document<a id="_idIndexMarker481"/> that describes some kind of specification/protocol/standard to be designed as part of the internet architecture. Any person can submit an RFC to the IETF and if the RFC is approved, it becomes a standard while this sounds simple, this process can take a long time as the refinement and review process <span class="No-Break">is exhaustive.</span></p>
			<p>Here is a simple extract<a id="_idIndexMarker482"/> from RFC 2616 (<a href="https://www.rfc-editor.org/rfc/rfc2616.txt">https://www.rfc-editor.org/rfc/rfc2616.txt</a>) that describes the <strong class="bold">Hypertext Transfer Protocol – HTTP/1.1</strong> in <span class="No-Break">175 pages:</span></p>
			<pre class="console">
Network Working Group                       R. Fielding
Request for Comments: 2616
  UC Irvine
Obsoletes: 2068
  J. Gettys
Category: Standards Track                    Compaq/W3C                                                  J. Mogul
                                                 Compaq
                                             H. Frystyk
                                                W3C/MIT
                                            L. Masinter
                                                  Xerox
                                               P. Leach
                                              Microsoft
                                         T. Berners-Lee
                                                W3C/MIT
                                              June 1999
                Hypertext Transfer Protocol -- HTTP/1.1
Status of this Memo
   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.
Copyright Notice
   Copyright (C) The Internet Society (1999).  All Rights Reserved.
Abstract
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [47]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 [33].</pre>			<p>Yeah, I know… this is not an easy read. I don’t expect you to read the whole RFC but we will explore some parts of it in this chapter in a <span class="No-Break">practical way.</span></p>
			<p>The best aspect of RFCs is that they are free and you can read them online. You can find lots of quality information that can help you understand specific parts of the internet architecture when you<a id="_idIndexMarker483"/> <span class="No-Break">need it.</span></p>
			<h3><strong class="bold">Other RFCs</strong></h3>
			<p>Just to get rid of that overwhelming feeling, I would like to share with you other RFCs that are more fun <span class="No-Break">to read:</span></p>
			<ul>
				<li><strong class="bold">RFC 2324</strong> (<a href="https://tools.ietf.org/html/rfc2324">https://tools.ietf.org/html/rfc2324</a>): Hyper Text Coffee Pot Control <span class="No-Break">Protocol (HTCPCP/1.0)</span></li>
				<li><strong class="bold">RFC 1149 </strong>(<a href="https://tools.ietf.org/html/rfc1149">https://tools.ietf.org/html/rfc1149</a>): A Standard for the Transmission of IP Datagrams on <span class="No-Break">Avian Carriers</span></li>
			</ul>
			<p>And my <span class="No-Break">favorite one:</span></p>
			<ul>
				<li><strong class="bold"> RFC 2549</strong> (<a href="https://datatracker.ietf.org/doc/html/rfc2549">https://datatracker.ietf.org/doc/html/rfc2549</a>): IP over Avian Carriers with Quality of Service; an iteration of <span class="No-Break">RFC 1149</span></li>
			</ul>
			<p>These funny RFCs can give you familiarity and an idea of the power of the RFC discussion format. Basically, if you want to create a new protocol, you can submit an RFC to the IETF and if the RFC is approved, it becomes a standard. You can read more about the RFC process <span class="No-Break">here: </span><a href="https://www.rfc-editor.org/about/independent/"><span class="No-Break">https://www.rfc-editor.org/about/independent/</span></a><span class="No-Break">.</span></p>
			<p>One of the most important<a id="_idIndexMarker484"/> protocols that you will need to know as a web developer is HTTP. In the next section, we will explore this protocol in detail and will learn the different architectures and components it involves and that are in use today as the backbone of the internet as we <span class="No-Break">know it.</span></p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor251"/>HTTP – server and client relationship</h1>
			<p>While web development <a id="_idIndexMarker485"/>can be a very complex topic, we can simplify it by understanding the relationship between the server and the client in the typical <span class="No-Break">web applications.</span></p>
			<p>We have two main actors, the server and <span class="No-Break">the client:</span></p>
			<ul>
				<li><strong class="bold">Server</strong>: The server is the computer that<a id="_idIndexMarker486"/> is running the application, dealing with the database<a id="_idIndexMarker487"/> queries, and many other things. This server is often called <span class="No-Break">the backend.</span></li>
				<li><strong class="bold">Client</strong>: The client is the piece of software<a id="_idIndexMarker488"/> that the end user executes on the local machine in the case of web applications. The user employs a web browser to execute<a id="_idIndexMarker489"/> the software (HTML, CSS, JS, etc.). The client is often called <span class="No-Break">the frontend.</span></li>
			</ul>
			<p>The communication between the server and the client is done through HTTP. The client sends a request to the server and the server <a id="_idIndexMarker490"/>replies with a response. This is the typical <span class="No-Break">request/response cycle</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor252"/>Request and response</h2>
			<p>The request and response<a id="_idIndexMarker491"/> are the two main parts of HTTP. The request is sent by the client to the server and the server returns a response. The request and response are composed of different parts that we will explore in the <span class="No-Break">following sections.</span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B21678_09_02.jpg" alt="Figure 9.2 – The relationship between the server, internet, and multiple clients"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The relationship between the server, internet, and multiple clients</p>
			<p>As we can see in the preceding diagram, one server can handle multiple clients at the same time. This is the typical architecture of a web application. The server handles the requests from clients and responds with the <span class="No-Break">corresponding response.</span></p>
			<p>But very often, one client will send multiple requests to a single server or multiple servers. Let’s take a look at the following <span class="No-Break">HTML snippet:</span></p>
			<pre class="source-code">
&lt;head&gt;
&lt;link rel="stylesheet" type="text/css" href="https://server1.com/style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src="https://server3.com/image.png"&gt;
&lt;script type="text/javascript" src="https://server2.com/script.js"&gt;&lt;/script&gt;
&lt;/body&gt;</pre>			<p>As we can see, the client sends three requests to three different servers (<strong class="source-inline">server1.com</strong>, <strong class="source-inline">server2.com</strong>, and <strong class="source-inline">server3.com</strong>) asking for specific resources. Each server will eventually respond with the <span class="No-Break">requested resource.</span></p>
			<p>As a simple example, let’s go to <a href="https://packtpub.com">https://packtpub.com</a> and open the developer<a id="_idIndexMarker492"/> tools in our browser. In the <strong class="bold">Network</strong> tab, we can see all the requests that the browser is sending to the server and the responses from <span class="No-Break">the server:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B21678_09_03.jpg" alt="Figure 9.3 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Web browser screenshot</p>
			<p>If you pay attention to the bottom part of <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em>, you can easily see that this page is sending more than 60 requests targeting different servers to render the page. This is a very common scenario in web applications: the client sends multiple requests to the server(s) to get key resources including favicons, CSS files, JS files, images, videos, and raw data. If we look at the table, we can see each item that is loaded, and can debug and explore each request that was made. This can be intimidating at the beginning, but once you know how the filter works<a id="_idIndexMarker493"/> and you spend some hours working with it you will feel <span class="No-Break">more comfortable.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor253"/>Server-side rendering</h2>
			<p>In the beginning, web applications<a id="_idIndexMarker494"/> were very simple, and JavaScript was very limited in its usage. Web applications were rendered on the server and the client just received<a id="_idIndexMarker495"/> the HTML, CSS, and JS files. This is called server-side rendering, and it is still used in <span class="No-Break">many applications.</span></p>
			<p>While this model is still used today, there are some clear disadvantages. Any time the user wants to interact with the application, the server needs to render the page again and send it to the client. This generates a lot of traffic and the user experience is not the best, as there are moments where the website appears blank <span class="No-Break">between refreshes.</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B21678_09_04.jpg" alt="Figure 9.4 – The relationship between the server and client in the server-side rendering approach"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The relationship between the server and client in the server-side rendering approach</p>
			<p>This pattern was especially bad in the early days of smartphones, when mobile devices were not powerful enough to render the pages and the connection was not very good. The user experience was very bad. The solution was to move<a id="_idIndexMarker496"/> the rendering to the client side, this is called <span class="No-Break">client-side rendering.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor254"/>Single-Page Applications (SPAs)</h2>
			<p>In client-side rendering, the server<a id="_idIndexMarker497"/> sends the initial HTML, CSS, and JS files to the client. Then, JavaScript takes control of the application and renders the views on the client side. Thus, the server only sends the data to the client<a id="_idIndexMarker498"/> and the client renders the page. This is called a <strong class="bold">Single-Page Application</strong> (<strong class="bold">SPA</strong>) and it is the most common <span class="No-Break">pattern today.</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B21678_09_05.jpg" alt="Figure 9.5 – The relationship between the server in the AJAX approach"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The relationship between the server in the AJAX approach</p>
			<p>At first, this pattern was very complicated to implement, but with the evolution of JavaScript frameworks, this pattern has become very popular. Today, we have a lot of frameworks that can help us to build SPAs easily. Some of the most popular frameworks are Angular, React, and Vue.js. The SPA pattern<a id="_idIndexMarker499"/> uses the same HTTP but in a different way via <strong class="bold">Asynchronous JavaScript and XML</strong> (<span class="No-Break"><strong class="bold">AJAX</strong></span><span class="No-Break">) requests.</span></p>
			<p>This new technique introduced <a id="_idIndexMarker500"/>a lot of changes and innovations in the way we build the backend applications. Backend applications became more like an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) that responds with data to the client, and not only to the typical web clients, but now even servers can also use this API to exchange information with <span class="No-Break">each other.</span></p>
			<p>Now that we have a clear idea of the components and possible web architectures, it is time to deep dive into HTTP so we can build solid projects using standardized communication between the server and <span class="No-Break">the clients.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor255"/>Mastering HTTP</h1>
			<p>Now that we have a better understanding <a id="_idIndexMarker501"/>of the HTTP concept, let’s take a look at the different parts of HTTP that we need to understand in order to build a <span class="No-Break">web application.</span></p>
			<p>We have already seen the request and response, but let’s take a deeper look at the different parts that compose the request and the response (headers, payloads, versions, <span class="No-Break">and methods).</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor256"/>HTTP headers</h2>
			<p>Each request and response<a id="_idIndexMarker502"/> has a set of headers. These are key-value pairs and provide additional information about the request or <span class="No-Break">the response.</span></p>
			<p>While both the request and response headers may look similar, they are not the same, although they do share common <span class="No-Break">key-value pairs.</span></p>
			<h3>Request headers</h3>
			<p>We will start by analyzing<a id="_idIndexMarker503"/> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.6</em> what is included in the <span class="No-Break">request header:</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B21678_09_06.jpg" alt="Figure 9.6 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5</p>
			<p>Let’s group the different <span class="No-Break">header properties:</span></p>
			<ul>
				<li>Representation headers: <strong class="source-inline">content-type</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">content-length</strong></span></li>
				<li>General headers: <strong class="source-inline">keep-alive</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">upgrade-insecure-requests</strong></span></li>
				<li>Request headers: <strong class="source-inline">accept</strong>, <strong class="source-inline">accept-encoding</strong>, <strong class="source-inline">accept-language</strong>, <strong class="source-inline">host</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">user-agent</strong></span></li>
			</ul>
			<p>Just by looking at the headers, we can understand many things about a request, such as the type of content the client is expecting, the language, and the browser used. The server can use this information <a id="_idIndexMarker504"/>to provide a better response to <span class="No-Break">the client.</span></p>
			<p class="callout-heading">Important info</p>
			<p class="callout">This is just a small list of the possible headers. There are many more headers that we can use to provide more information about the request or response. We can even create our own key-value<a id="_idIndexMarker505"/> pairs. You can find the list of the HTTP headers <span class="No-Break">here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</span></a><span class="No-Break">.</span></p>
			<h3>Response headers</h3>
			<p>We will finish by analyzing<a id="_idIndexMarker506"/> in the <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em> what is included in the <span class="No-Break">response header</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B21678_09_07.jpg" alt="Figure 9.7 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5</p>
			<p>The response headers are very similar to the request headers, but they are not the same. They can be grouped <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Representation headers: <strong class="source-inline">content-type</strong>, <strong class="source-inline">content-encoding</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">last-modified</strong></span></li>
				<li>General headers: <strong class="source-inline">connection</strong>, <strong class="source-inline">date</strong>, <strong class="source-inline">keep-alive</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">transfer-encoding</strong></span></li>
				<li>Response headers: <strong class="source-inline">access-control-allow-origin</strong>, <strong class="source-inline">etag</strong>, <strong class="source-inline">server</strong>, <strong class="source-inline">set-cookie</strong>, <strong class="source-inline">vary</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">x-frame-options</strong></span></li>
			</ul>
			<p>With the response headers, we can also provide additional information that will help the browsers and the web applications to digest and render the <span class="No-Break">information properly.</span></p>
			<p>The response headers are very important for the security of the application, as there are many headers that can prevent certain attacks in the web browser environment. For example, we can use <strong class="source-inline">x-frame-options</strong> to prevent the application from being loaded in an <strong class="source-inline">iframe</strong>, or use <strong class="source-inline">feature-policy</strong> to prevent the application from using features such as the camera <a id="_idIndexMarker507"/>or microphone. We will explore this in <a href="B21678_15.xhtml#_idTextAnchor394"><span class="No-Break"><em class="italic">Chapter 15</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor257"/>Status codes</h2>
			<p>Overall, one of the most important<a id="_idIndexMarker508"/> pieces of information that we can find in the response is the <span class="No-Break">status code.</span></p>
			<p>The status code allows us to understand whether the request was successful or not and can even provide more granular feedback. We can classify status codes into the <span class="No-Break">following groups:</span></p>
			<ul>
				<li><span class="No-Break">1xx: Informational</span></li>
				<li><span class="No-Break">2xx: Success</span></li>
				<li><span class="No-Break">3xx: Redirection</span></li>
				<li>4xx: <span class="No-Break">Client Error</span></li>
				<li>5xx: <span class="No-Break">Server Error</span></li>
			</ul>
			<p>The most common status codes are <strong class="source-inline">200 OK</strong>, <strong class="source-inline">201 Created</strong>, <strong class="source-inline">301 Moved Permanently</strong>, <strong class="source-inline">400 Bad Request</strong>, <strong class="source-inline">401 Unauthorized</strong>, <strong class="source-inline">403 Forbidden</strong>, <strong class="source-inline">404 Not Found</strong>, <strong class="source-inline">429 Too Many Requests</strong>, <strong class="source-inline">500 Internal Server Error</strong>, and <strong class="source-inline">503 Service Unavailable</strong>. You can find<a id="_idIndexMarker509"/> the complete list of the status codes <span class="No-Break">here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</span></a><span class="No-Break">.</span></p>
			<p>As you can see, if you know the given status code, you can understand what happened with your request. For example, a <strong class="source-inline">429</strong> error code occurs when the client has sent too many requests in a given amount of time (“rate limiting”), but if you receive a <strong class="source-inline">401</strong> then the error is related to your authentication. Finally, if in the same scenario you receive <strong class="source-inline">403</strong>, you are correctly authenticated but you don’t have enough permission to perform the given operation, such as deleting another <span class="No-Break">user account.</span></p>
			<p>We all have experienced<a id="_idIndexMarker510"/> the <strong class="source-inline">404</strong> error code, which is very common when we try to access a resource that doesn’t exist. For example, if we try to access the following URL, <strong class="source-inline">https://www.google.com/invented-resource</strong>, we will receive a <strong class="source-inline">404</strong> <span class="No-Break">error code.</span></p>
			<p class="callout-heading">418 I’m a teapot</p>
			<p class="callout">There is a strong culture on the internet to build fancy 404 pages. You can find a lot of examples online, but not many people know that there is a special error code <strong class="source-inline">418</strong> that RFC 2324 (<a href="https://tools.ietf.org/html/rfc2324">https://tools.ietf.org/html/rfc2324</a>) describes <span class="No-Break">as follows:</span></p>
			<p class="callout">“Any attempt to brew coffee with a teapot should result in the error code “418 I’m a teapot”. The resulting entity body MAY be short <span class="No-Break">and stout.”</span></p>
			<p class="callout">While this might seem just like a running joke, it is actually supported by many entities including Node (<a href="https://github.com/nodejs/node/issues/14644">https://github.com/nodejs/node/issues/14644</a>) <span class="No-Break">and Google.</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B21678_09_08.jpg" alt="Figure 9.8 – Web browser screenshot of google.com/teapot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Web browser screenshot of google.com/teapot</p>
			<p>As Shane Brunswick said on the Save 418 Movement <span class="No-Break">website (</span><a href="https://save418.com/"><span class="No-Break">https://save418.com/</span></a><span class="No-Break">):</span></p>
			<p class="author-quote">“It’s a reminder that the underlying processes of computers are still made by humans. It’d be a real shame to see 418 go.”</p>
			<p>And I do agree with him: behind these complex systems<a id="_idIndexMarker511"/> there are humans, and we should not forget that, in the same way that we should not forget that the internet could not exist without the open source movement and the <span class="No-Break">hacker culture.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor258"/>Request methods</h2>
			<p>Just as status codes are very important<a id="_idIndexMarker512"/> to understand responses, the request methods are essential to <span class="No-Break">understand requests.</span></p>
			<p>There are many request methods, but the most common are the following: <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">DELETE</strong>. You can find<a id="_idIndexMarker513"/> the complete list of the request methods <span class="No-Break">here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</span></a><span class="No-Break">.</span></p>
			<p>The way that we backend developers use them can differ a bit, but the most common way is <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">GET</strong>: Retrieve <span class="No-Break">a resource</span></li>
				<li><strong class="source-inline">POST</strong>: Create <span class="No-Break">a resource</span></li>
				<li><strong class="source-inline">PUT</strong>: Update <span class="No-Break">a resource</span></li>
				<li><strong class="source-inline">PATCH</strong>: Partially update <span class="No-Break">a resource</span></li>
				<li><strong class="source-inline">DELETE</strong>: Delete <span class="No-Break">a resource</span></li>
			</ul>
			<p>We will explore them in detail in <a href="B21678_11.xhtml#_idTextAnchor300"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><em class="italic">, </em>when we create an actual REST API with all <span class="No-Break">the endpoints.</span></p>
			<p>In the early days of the internet, we used<a id="_idIndexMarker514"/> forms to send data to the server and specified the given method in the form. See the following, <span class="No-Break">for example:</span></p>
			<pre class="source-code">
&lt;form action="/user" method="POST"&gt;
  &lt;input type="text" name="username" /&gt;
  &lt;input type="password" name="password" /&gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;</pre>			<p>The preceding code was a common way to send data to a server in order to create a new user, but nowadays we use JavaScript to send data to the server. For example, we can use the <strong class="source-inline">fetch</strong> API to send data to the server <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
fetch('/user', {
  method: 'POST',
  headers: {
   'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    username: 'john',
    password: '1234'
  })
})</pre>			<p>And then we would use the response to inform the user whether the request was successful or not. While using JavaScript to send data to the server is more complex, it gives us more flexibility and control<a id="_idIndexMarker515"/> over <span class="No-Break">the request.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When you enter a URL in the browser, the browser sends a <strong class="source-inline">GET</strong> request to the server. This is the default method that the browser uses. You have been using HTTP methods for a long time without <span class="No-Break">knowing it.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor259"/>HTTP payloads</h2>
			<p>HTTP messages can carry<a id="_idIndexMarker516"/> a payload, which means that we can send data to the server, and servers likewise can send data to their clients. This is often done with <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> requests.</span></p>
			<p>Payloads can be in many formats, but the most common are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">application/json</strong>: Used when sharing <span class="No-Break">JSON data</span></li>
				<li><strong class="source-inline">application/x-www-form-urlencoded</strong>: Used when sending simple texts in ASCII, sending data in <span class="No-Break">the URL</span></li>
				<li><strong class="source-inline">multipart/form-data</strong>: Used when sending binary data (such as files) or <span class="No-Break">non-ASCII texts</span></li>
				<li><strong class="source-inline">text/plain</strong>: Used when sending plain text, such as a <span class="No-Break">log file</span></li>
				<li>You can find the complete list of the content types <span class="No-Break">here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types</span></a><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor260"/>HTTP versions</h2>
			<p>HTTP has evolved over<a id="_idIndexMarker517"/> the years, and we have different versions of <span class="No-Break">the protocol:</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Version</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Year</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Status</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HTTP/0.9</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">1991</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Obsolete</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HTTP/1.0</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">1996</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Obsolete</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HTTP/1.1</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">1997</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Standard</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HTTP/2</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">2015</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Standard</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HTTP/3</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">2022</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Standard</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Currently, the most used version of the protocol is the <strong class="source-inline">HTTP/1.1</strong> version, but the <strong class="source-inline">HTTP/2</strong> version is gaining popularity. The <strong class="source-inline">HTTP/3</strong> version is quite new and not widely <span class="No-Break">supported yet.</span></p>
			<p>Nowadays, Node supports the <strong class="source-inline">HTTP/1.1</strong> and <strong class="source-inline">HTTP/2</strong> versions, but it doesn’t support the <strong class="source-inline">HTTP/3</strong> version yet. There is an ongoing strategic initiative to support <span class="No-Break">it:</span><span class="No-Break"> </span><a href="https://github.com/nodejs/node/issues/38478"><span class="No-Break">https://github.com/nodejs/node/issues/38478</span></a><span class="No-Break">.</span></p>
			<p>In the next section, we will learn how important <strong class="bold">Uniform Resource Locators</strong> (<strong class="bold">URLs</strong>) are and how we can use<a id="_idIndexMarker518"/> them to structure access to resources in our <span class="No-Break">web applications.</span></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor261"/>Using URLs in web applications</h1>
			<p>Let’s take a look<a id="_idIndexMarker519"/> at the following<a id="_idIndexMarker520"/> table, made by Node.js, that describes the different parts of <span class="No-Break">a URL:</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B21678_09_09.jpg" alt="Figure 9.9 – URL structure from the Node.js Official Documentation. Attributions and copyright licensing by Node.js Contributors is licensed under MIT"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – URL structure from the Node.js Official Documentation. Attributions and copyright licensing by Node.js Contributors is licensed under MIT</p>
			<p>In the following chapters, we will use the URL parts a lot, so keep this table handy. There are many ways to parse a URL, but the most common way is to use the <span class="No-Break"><strong class="source-inline">URL</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
import { URL } from 'node:url';
const myUrl = new URL('https: //user:pass @sub.example. com:8080 /p/a/t/h?query=string#hash');
console.log(myUrl.hash); // #hash
console.log(myUrl.host); // sub.example.com:8080
console.log(myUrl.hostname); // sub.example.com</pre>			<p>This class is available in Node.js and in <span class="No-Break">the browser.</span></p>
			<p class="callout-heading">Important info</p>
			<p class="callout">Node.js 20 introduced one of the most performant<a id="_idIndexMarker521"/> URL parsers available, called Ada <span class="No-Break">2.0: </span><a href="https://www.yagiz.co/announcing-ada-url-parser-v2-0"><span class="No-Break">https://www.yagiz.co/announcing-ada-url-parser-v2-0</span></a><span class="No-Break">.</span></p>
			<p>Now that we know how flexible<a id="_idIndexMarker522"/> URLs are, let’s explore in the next section<a id="_idIndexMarker523"/> how we can build a standard layer on top of our web services. This layer is the foundation of many online services and SaaS products. We will learn the basics of creating web application <span class="No-Break">interfaces (APIs).</span></p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor262"/>REST APIs in a nutshell</h1>
			<p><strong class="bold">REST</strong> stands for <strong class="bold">Representational State Transfer</strong>, and is an architectural style for building<a id="_idIndexMarker524"/> APIs. It was introduced<a id="_idIndexMarker525"/> by Roy Fielding in his PhD dissertation (<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>) <span class="No-Break">in 2000.</span></p>
			<p>In practical terms, the idea is to define a set of resources that can be accessed by the client using HTTP, as we explored in the <span class="No-Break">previous section.</span></p>
			<p>Each resource is identified by a unique URL, and the client can perform operations on it using the HTTP methods. The server will respond with a status code and a payload <span class="No-Break">when necessary.</span></p>
			<p>For example, let’s say that we have a REST API to manage a database of movies. We can define the <span class="No-Break">following resources:</span></p>
			<ul>
				<li><strong class="source-inline">/movies</strong>: This resource represents the collection <span class="No-Break">of movies</span></li>
				<li><strong class="source-inline">/movies/:id</strong>: This resource represents a <span class="No-Break">single movie</span></li>
			</ul>
			<p class="callout-heading">Important tip</p>
			<p class="callout">The <strong class="source-inline">:id</strong> part of the URL is a placeholder<a id="_idIndexMarker526"/> for the user ID. This is called a URL parameter, and takes the form of <strong class="source-inline">/movies/1</strong> or <strong class="source-inline">/movies/12345</strong>, and <span class="No-Break">so on.</span></p>
			<p>The client can perform the following operations on these resources using the aforementioned <span class="No-Break">HTTP methods:</span></p>
			<ul>
				<li><strong class="source-inline">GET /movies:</strong> Get all <span class="No-Break">the movies</span></li>
				<li><strong class="source-inline">GET /movies/:id</strong>: Get a <span class="No-Break">single movie</span></li>
				<li><strong class="source-inline">POST /movies</strong>: Create a <span class="No-Break">new movie</span></li>
				<li><strong class="source-inline">PUT /movies/:id</strong>: Update <span class="No-Break">a movie</span></li>
				<li><strong class="source-inline">DELETE /movies/:id</strong>: Delete <span class="No-Break">a movie</span></li>
			</ul>
			<p>Most of the time, the server<a id="_idIndexMarker527"/> will respond with a JSON payload, but it can also respond with other formats such as XML <span class="No-Break">or HTML.</span></p>
			<p>Let’s see an example of a REST API in action. We will use simple-api (<a href="https://www.npmjs.com/package/@ulisesgascon/simple-api">https://www.npmjs.com/package/@ulisesgascon/simple-api</a>), which is a very simple HTTP API to build fast prototypes. This API includes Swagger documentation that can be used to explore <span class="No-Break">the API.</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B21678_09_10.jpg" alt="Figure 9.10 – Web browser screenshot of the API documentation generated with Swagger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Web browser screenshot of the API documentation generated with Swagger</p>
			<p>As you can see, the API is quite<a id="_idIndexMarker528"/> intuitive and easy to use because it follows the REST principles. So, you intuitively know how to use it. We can use Swagger to explore more details of the payload expected by the API when we create a <span class="No-Break">new todo:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B21678_09_11.jpg" alt="Figure 9.11 – Web browser screenshot of the API documentation generated with Swagger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Web browser screenshot of the API documentation generated with Swagger</p>
			<p>It is also possible to explore the potential responses that the API can return for any specific endpoint that <span class="No-Break">is available:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B21678_09_12.jpg" alt="Figure 9.12 – Web browser screenshot of the API documentation generated with Swagger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Web browser screenshot of the API documentation generated with Swagger</p>
			<p>If you understand how RESTful APIs work, you will be able to use any API based on HTTP. For example, the GitHub API <a href="https://docs.github.com/en/rest">https://docs.github.com/en/rest</a> is a REST API that uses HTTP to expose <span class="No-Break">its services.</span></p>
			<p>There is a world full of APIs out there, waiting for you to use them to build amazing projects. Here is a great list<a id="_idIndexMarker529"/> of public <span class="No-Break">APIs: </span><a href="https://apilist.fun/"><span class="No-Break">https://apilist.fun/</span></a></p>
			<p>Throughout the previous<a id="_idIndexMarker530"/> chapters, we have mentioned JSON, but we haven’t explained it in detail, so in the next section we will deep dive into it, as it is the most common format to exchange data in <span class="No-Break">modern APIs.</span></p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor263"/>Exploring the JSON specification</h1>
			<p><strong class="bold">JSON</strong> stands for <strong class="bold">JavaScript Object Notation</strong>, and is a lightweight<a id="_idIndexMarker531"/> data-interchange format. It is easy for humans to read and write, and it is easy for machines to parse <span class="No-Break">and generate.</span></p>
			<p>We can easily convert a JavaScript object to a JSON string using the <span class="No-Break"><strong class="source-inline">JSON.stringify()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
const user = {
  name: 'John',
  age: 30
};
const json = JSON.stringify(user);</pre>			<p>And we can convert a JSON string to a JavaScript object using the <span class="No-Break"><strong class="source-inline">JSON.parse()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
const json = '{"name":"John","age":30}';
const user = JSON.parse(json);</pre>			<p>While the JSON name includes the world JavaScript, it is a language-independent data format. Many programming languages have libraries to parse and <span class="No-Break">generate JSON.</span></p>
			<p>JSON is the most common<a id="_idIndexMarker532"/> format used to exchange data between clients and servers, such as when we use or build a <span class="No-Break">REST API.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The JSON specification is quite simple, and I strongly suggest you read it. You can find it <span class="No-Break">at </span><a href="https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf"><span class="No-Break">https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf</span></a></p>
			<p>In the next section, we will explore how to debug HTTP requests so that we can build complex <span class="No-Break">projects easily.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor264"/>Debugging HTTP requests</h1>
			<p>There are many ways<a id="_idIndexMarker533"/> to debug HTTP requests. The most common way is to use the developer tools, as these are easily accessible in most web browsers. It is also quite helpful when you are developing a website to keep these tools open and navigate between the tabs to debug UI components and <span class="No-Break">network requests.</span></p>
			<p>But there are also other tools<a id="_idIndexMarker534"/> that you can <a id="_idIndexMarker535"/>use, such as Postman (<a href="https://www.postman.com/">https://www.postman.com/</a>) or Insomnia (<a href="https://insomnia.rest/">https://insomnia.rest/</a>), which were designed specifically for this purpose and offer many features out of the box (collections, authentication, etc.). These tools are the best option if you don’t have a website and you are just testing API <span class="No-Break">endpoints directly.</span></p>
			<p>In the next chapters, we will use the developer tools of the browser to debug our HTTP transactions and will use Jest to test and debug our <span class="No-Break">HTTP requests.</span></p>
			<p>Other developers use<a id="_idIndexMarker536"/> more advanced tools such as Charles (<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a>) or Wireshark (<a href="https://www.wireshark.org/">https://www.wireshark.org/</a>), but they are not necessary<a id="_idIndexMarker537"/> for the scope of <span class="No-Break">this book.</span></p>
			<p>If you are not familiar with the developer<a id="_idIndexMarker538"/> tools of your browser, you can read more about it in <a href="B21678_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor265"/>Summary</h1>
			<p>In this chapter, we have learned a lot about the technologies that we will use to build our applications and that constitute the foundation of the <span class="No-Break">modern internet.</span></p>
			<p>Additionally, we have learned how RFC documents are used to define the standards of the internet and how we can use them to learn more about the technologies that <span class="No-Break">we use.</span></p>
			<p>Later on, we learned how the server-client architecture works and how HTTP is used to exchange data between the client and the server in detail, including HTTP methods and <span class="No-Break">status codes.</span></p>
			<p>Finally, we explored the URL parts and learned how to use them to build RESTful APIs. We also learned about the JSON specification in more detail and how to debug <span class="No-Break">HTTP requests.</span></p>
			<p>In the next chapter, we will explore how we can use databases to store data and how we can interact with them. This is the last piece of the puzzle before we can start building our final <span class="No-Break">web application.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor266"/>Further reading</h1>
			<ul>
				<li><em class="italic">Wikipedia</em> | <em class="italic">IP over Avian </em><span class="No-Break"><em class="italic">Carriers</em></span><span class="No-Break">: </span><a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers"><span class="No-Break">https://en.wikipedia.org/wiki/IP_over_Avian_Carriers</span></a></li>
				<li><em class="italic">Wikipedia</em> | <span class="No-Break"><em class="italic">HTTP</em></span><span class="No-Break">: </span><a href="https://en.wikipedia.org/wiki/HTTP"><span class="No-Break">https://en.wikipedia.org/wiki/HTTP</span></a></li>
				<li><em class="italic">History of the </em><span class="No-Break"><em class="italic">Internet</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=9hIQjrMHTv4"><span class="No-Break">https://www.youtube.com/watch?v=9hIQjrMHTv4</span></a></li>
				<li><em class="italic">How the Internet Works in 5 </em><span class="No-Break"><em class="italic">Minutes</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=7_LPdttKXPc"><span class="No-Break">https://www.youtube.com/watch?v=7_LPdttKXPc</span></a></li>
				<li>An overview of <span class="No-Break">HTTP: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview</span></a></li>
				<li><em class="italic">Project Code Rush - The Beginnings of Netscape / Mozilla </em><span class="No-Break"><em class="italic">Documentary</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=4Q7FTjhvZ7Y"><span class="No-Break">https://www.youtube.com/watch?v=4Q7FTjhvZ7Y</span></a></li>
				<li><em class="italic">How The Internet Travels Across </em><span class="No-Break"><em class="italic">Oceans</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=yd1JhZzoS6A"><span class="No-Break">https://www.youtube.com/watch?v=yd1JhZzoS6A</span></a></li>
				<li><em class="italic">There is a Reason Why Underwater Power Cables are So </em><span class="No-Break"><em class="italic">Expensive</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=bkgvqC3M1Tw"><span class="No-Break">https://www.youtube.com/watch?v=bkgvqC3M1Tw</span></a></li>
				<li><em class="italic">Jeff Geerling</em> | <em class="italic">Testing one of the oldest internet </em><span class="No-Break"><em class="italic">myths</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=4pz2kMxCu8I"><span class="No-Break">https://www.youtube.com/watch?v=4pz2kMxCu8I</span></a></li>
			</ul>
		</div>
	</body></html>