- en: Your First Express Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个Express应用程序
- en: Now that we've got our feet wet building an Express application for Node.js,
    let's work on an application that performs a useful function. The application
    we'll build will keep a list of notes, and it will let us explore some aspects
    of a real application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试构建了Node.js的Express应用程序，让我们来构建一个执行有用功能的应用程序。我们将构建的应用程序将保存笔记列表，并让我们探索真实应用程序的一些方面。
- en: In this chapter, we'll only build the basic infrastructure of the application,
    and in the later chapters, we'll extend the application considerably.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只构建应用程序的基本基础设施，而在后面的章节中，我们将大大扩展应用程序。
- en: The topics covered in this chapter includes
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括
- en: Using Promises and async functions in Express router functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express路由函数中使用承诺（Promises）和异步函数
- en: Applying the MVC paradigm to Express applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MVC范式应用于Express应用程序
- en: Building an Express application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Express应用程序
- en: JavaScript Class definitions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript类定义
- en: Implementing the CRUD paradigm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CRUD范式
- en: Handlebars templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Handlebars模板
- en: Promises, async functions, and Express router functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺（Promises）、异步函数和Express路由函数
- en: 'Before we get into developing our application, we must take a deeper look at
    a pair of new ES-2015/2016/2017 features that collectively revolutionize JavaScript
    programming:  The `Promise` class and `async` functions. Both are used for deferred
    and asynchronous computation and can make intensely nested callback a thing of
    the past:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发我们的应用程序之前，我们必须更深入地了解一对新的ES-2015/2016/2017特性，这些特性共同彻底改变了JavaScript编程：`Promise`类和`async`函数。两者都用于延迟和异步计算，可以使深层嵌套的回调成为过去式：
- en: A `Promise` represents an operation that hasn't completed yet but is expected
    to be completed in the future. We've seen Promises in use. The `.then` or `.catch`
    functions are invoked when the promised result (or error) is available.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise`表示一个尚未完成但预期将在未来完成的操作。我们已经看到了Promise的使用。当承诺的结果（或错误）可用时，会调用`.then`或`.catch`函数。'
- en: '*Generator* functions are a new kind of function that can be paused and resumed,
    and can return results from the middle of the function.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成器*函数是一种新的函数类型，它可以暂停和恢复，并可以从函数的中间返回结果。'
- en: Those two features were mixed with another, the iteration protocol, along with
    some new syntax, to create `async` functions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个特性与另一个特性混合，即迭代协议，以及一些新的语法，以创建`async`函数。
- en: The magic of `async` functions is that we can write asynchronous code as if
    it's synchronous code. It's still asynchronous code, meaning long-running request
    handlers won't block the event loop. The code looks like the synchronous code
    we'd write in other languages. One statement follows another, the errors are thrown
    as exceptions, and the results land on the next line of code. Promise and `async`
    functions are so much of an improvement that it's extremely compelling for the
    Node.js community to switch paradigms, meaning rewriting legacy callback-oriented
    APIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数的魔力在于我们可以像编写同步代码一样编写异步代码。它仍然是异步代码，这意味着长时间运行的请求处理器不会阻塞事件循环。代码看起来就像我们在其他语言中编写的同步代码。一条语句跟在另一条语句后面，错误以异常的形式抛出，结果落在下一行代码上。承诺（Promise）和`async`函数的改进如此之大，以至于Node.js社区切换范式（即重写面向回调的遗留API）极具吸引力。'
- en: 'Over the years, several other approaches have been used to manage asynchronous
    code, and you may come across code using these other techniques. Before the `Promise`
    object was standardized, at least two implementations were available: Bluebird
    ([http://bluebirdjs.com/](http://bluebirdjs.com/)) and Q ([https://www.npmjs.com/package/q](https://www.npmjs.com/package/q)). Use
    of a non-standard Promise library should be carefully considered, since there
    is value in maintaining compatibility with the standard Promise object.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，已经使用了几种其他方法来管理异步代码，你可能会遇到使用这些其他技术的代码。在`Promise`对象标准化之前，至少有两种实现可用：Bluebird
    ([http://bluebirdjs.com/](http://bluebirdjs.com/)) 和 Q ([https://www.npmjs.com/package/q](https://www.npmjs.com/package/q))。使用非标准的Promise库应谨慎考虑，因为与标准Promise对象保持兼容性是有价值的。
- en: 'The **Pyramid of Doom** is named after the shape the code takes after a few
    layers of nesting. Any multistage process can quickly escalate to code nested
    15 levels deep. Consider the following example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**死亡金字塔**这个名字来源于代码在几层嵌套后的形状。任何多阶段过程都可以迅速升级到15层深的嵌套代码。考虑以下示例：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Rewriting this as an `async` function will make this much clearer. To get there,
    we need to examine the following ideas:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重写为`async`函数将使这更加清晰。要做到这一点，我们需要检查以下想法：
- en: Using Promises to manage asynchronous results
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Promise管理异步结果
- en: Generator functions and Promises
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数和Promise
- en: '`async` functions'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`函数'
- en: 'We generate a Promise this way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是这样生成一个Promise的：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that `asyncFunction` is an asynchronous function, but it does not take
    a callback. Instead, it returns a `Promise` object, and the asynchronous code
    is executed within a callback passed to the `Promise` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`asyncFunction`是一个异步函数，但它不接收回调。相反，它返回一个`Promise`对象，异步代码在传递给`Promise`类的回调中执行。
- en: 'Your code must indicate the status of the asynchronous operation via the `resolve`
    and `reject` functions. As implied by the function names, `reject` indicates an
    error occurred and `resolve` indicates a success result. Your caller then uses
    the function as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码必须通过`resolve`和`reject`函数来指示异步操作的状态。正如函数名所暗示的，`reject`表示发生了错误，而`resolve`表示成功的结果。您的调用者随后可以使用该函数如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The system is fluid enough that the function passed in a `.then` can return
    something, such as another Promise, and you can chain the `.then` calls together.
    The value returned in a `.then` handler (if any) becomes a new Promise object,
    and in this way you can construct a chain of `.then` and `.catch` calls to manage
    a sequence of asynchronous operations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 系统足够灵活，传递给`.then`的函数可以返回某些内容，例如另一个Promise，并且您可以一起链式调用`.then`。在`.then`处理程序中返回的值（如果有）将成为一个新的Promise对象，通过这种方式，您可以构建一个`.then`和`.catch`调用的链，以管理一系列异步操作。
- en: A sequence of asynchronous operations would be implemented as a chain of `.then`
    functions, as we will see in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列异步操作将被实现为`.then`函数的链，正如我们将在下一节中看到的。
- en: Promises and error handling
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise和错误处理
- en: 'Promise objects can be in one of three states:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Promise对象可以处于三种状态之一：
- en: '**Pending**: This is the initial state, neither fulfilled nor rejected'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pending**：这是初始状态，既未满足也未拒绝'
- en: '**Fulfilled**: This is the final state where it executed successfully and'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fulfilled**：这是执行成功时的最终状态'
- en: produced a result
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 产生了一个结果
- en: '**Rejected**: This is the final state where execution failed'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rejected**：这是执行失败时的最终状态'
- en: 'Consider this code segment similar to the one we''ll use later in this chapter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段代码片段类似于我们在本章后面将要使用的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are several places where errors can occur in this little bit of code.
    The `notes.read` function has several possible failure modes: the `filterNote`
    function might want to raise an alarm if it detects a cross-site scripting attack.
    The Swedish chef could be on strike. There could be a failure in `res.render`
    or the template being used. But we have only one way to catch and report errors.
    Are we missing something?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段小代码中，有几个地方可能会发生错误。`notes.read`函数有几个可能的失败模式：`filterNote`函数可能会在检测到跨站脚本攻击时发出警报。瑞典厨师可能会罢工。`res.render`或使用的模板可能会失败。但我们只有一种方法来捕获和报告错误。我们遗漏了什么吗？
- en: The `Promise` class automatically captures errors, sending them down the chain
    of operations attached to the `Promise`. If the `Promise` class has an error on
    its hands, it skips over the `.then` functions and will instead invoke the first
    `.catch` function it finds. In other words, using instances of Promise provides
    a higher assurance of capturing and reporting errors. With the older convention,
    error reporting was trickier, and it was easy to forget to add correct error handling.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`类会自动捕获错误，将它们发送到与`Promise`关联的操作链中。如果`Promise`类本身有错误，它会跳过`.then`函数，并调用它找到的第一个`.catch`函数。换句话说，使用Promise的实例提供了更高的确保捕获和报告错误的可能性。在旧的传统中，错误报告更复杂，很容易忘记添加正确的错误处理。'
- en: Flattening our asynchronous code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑我们的异步代码
- en: 'The problem being addressed is that asynchronous coding in JavaScript results
    in the Pyramid of Doom. To explain, let''s reiterate the example Ryan Dahl gave
    as the primary Node.js idiom:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的问题是在JavaScript中异步编码会导致“死亡金字塔”。为了解释，让我们重述Ryan Dahl给出的作为Node.js主要语法的例子：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The goal was to avoid blocking the event loop with a long operation. Deferring
    the processing of results or errors using callback functions was an excellent
    solution and is the founding idiom of Node.js. The implementation of callback
    functions led to this pyramid-shaped problem.  Namely, that results and errors
    land in the callback. Rather than delivering them to the next line of code, the
    errors and results are buried.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是避免使用长时间操作阻塞事件循环。使用回调函数延迟处理结果或错误是一个出色的解决方案，并且是 Node.js 的基础习语。回调函数的实现导致了这种金字塔形问题。也就是说，结果和错误落在回调中。而不是将它们传递到下一行代码，错误和结果被埋藏。
- en: Promises help flatten the code so that it no longer takes a pyramidal shape.
    They also capture errors, ensuring delivery to a useful location. But those errors
    and results are still buried inside an anonymous function and do not get delivered
    to the next line of code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 帮助简化代码，使其不再呈现金字塔形状。它们还捕获错误，确保将结果传递到有用的位置。但那些错误和结果仍然隐藏在匿名函数内部，并没有传递到下一行代码。
- en: Further, using Promises results in a little bit of boilerplate code that obscures
    the programmers intent. It's less boilerplate than with regular callback functions,
    but the boilerplate is still there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 Promise 会导致一些样板代码，这会掩盖程序员的意图。它比常规回调函数的样板代码少，但样板代码仍然存在。
- en: Fortunately, the ECMAScript committee kept working on the problem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ECMAScript 委员会一直在努力解决这个问题。
- en: Promises and generators birthed async functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise 和生成器催生了异步函数
- en: Generators and the associated Iteration Protocol are a large topic, which we
    will briefly cover.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器和相关的迭代协议是一个大主题，我们将简要介绍。
- en: The Iteration Protocol is what's behind the new `for..of` loop, and some other
    new looping constructs. These constructs can be used with anything producing an
    iterator. For more about both, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代协议是新的 `for..of` 循环和其他一些新循环结构背后的原理。这些结构可以与任何产生迭代器的对象一起使用。有关更多信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
- en: A generator is a kind of function which can be stopped and started using the
    `yield` keyword. Generators produce an iterator whose values are whatever is given
    to the yield statement. For more on this, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一种可以使用 `yield` 关键字停止和启动的函数。生成器产生一个迭代器，其值是传递给 `yield` 语句的任何内容。有关更多信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
- en: 'Consider this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `yield` statement causes a generator function to pause and to provide the
    value given to the next call on its `next` function. The `next` function isn''t
    explicitly seen here, but is what controls the loop, and is part of the iteration
    protocol. Instead of the loop, try calling `gen().next()` several times:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 语句使生成器函数暂停，并在其 `next` 函数的下一个调用上提供值。`next` 函数在这里没有明确显示，但它控制循环，是迭代协议的一部分。而不是循环，尝试多次调用
    `gen().next()`：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''ll see this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Iteration protocol says the iterator is finished when `done` is `true`.
    In this case, we didn't call it enough to trigger the end state of the iterator.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代协议指出，当 `done` 为 `true` 时，迭代器完成。在这种情况下，我们没有调用它足够多次以触发迭代器的结束状态。
- en: Where generators became interesting is when used with functions that return
    a Promise. The Promise is what's made available through the iterator. The code
    consuming the iterator can wait on the Promise to get its value. A series of asynchronous
    operations could be inside the generator and invoked in an iterable fashion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器变得有趣的地方在于与返回 Promise 的函数一起使用。Promise 是通过迭代器提供的。消耗迭代器的代码可以等待 Promise 获取其值。一系列异步操作可以放在生成器中，并以可迭代的方式调用。
- en: 'With the help of an extra function, a generator function along with Promise-returning
    asynchronous functions can be a very nice way to write asynchronous code. We saw
    an example of this in Chapter 2,* Setting up Node.js,* while exploring Babel.
    Babel has a plugin to rewrite `async` functions into a generator along with a
    helper function, and we took a look at the transpiled code and the helper function.
    The `co` library ([https://www.npmjs.com/package/co](https://www.npmjs.com/package/co))
    is a popular helper function for implementing asynchronous coding in generators.
    Create a file named `2files.js`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个额外的函数，一个生成器函数以及返回 Promise 的异步函数可以是一种编写异步代码的好方法。我们在第二章，“设置 Node.js”，探索 Babel
    时看到了这个例子。Babel 有一个插件可以将 `async` 函数重写为生成器以及一个辅助函数，我们查看了解译后的代码和辅助函数。`co` 库（[https://www.npmjs.com/package/co](https://www.npmjs.com/package/co)）是实现生成器异步编码的流行辅助函数。创建一个名为
    `2files.js` 的文件：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then run it like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式运行它：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Normally, `fs.readFile` sends its result to a callback function, and we'd build
    a little pyramid-shaped piece of code to perform this task. The `fs-extra` module
    contains implementations of all functions from the built-in `fs` module but changed
    to return a Promise instead of a callback function. Therefore, each `fs.readFile`
    shown here is returning a Promise that's resolved when the file content is fully
    read into memory. What `co` does is it manages the dance of waiting for the Promise
    to be resolved (or rejected), and returns the value of the Promise. Therefore,
    with two suitable text files we have the result shown from executing `2files.js`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`fs.readFile` 将其结果发送到回调函数，我们会构建一个金字塔形状的小段代码来完成这个任务。`fs-extra` 模块包含了内置 `fs`
    模块中所有函数的实现，但改为返回 Promise 而不是回调函数。因此，这里显示的每个 `fs.readFile` 都返回一个在文件内容完全读入内存时解决的
    Promise。`co` 所做的是管理等待 Promise 解决（或拒绝）的舞蹈，并返回 Promise 的值。因此，使用两个合适的文本文件，我们得到了执行
    `2files.js` 的结果。
- en: The important thing is that the code is very clean and readable. We aren't caught
    up in boilerplate code required to manage asynchronous operations. The intent
    of the programmer is pretty clear.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是代码非常清晰和易于阅读。我们不会陷入管理异步操作所需的样板代码。程序员的意图非常明确。
- en: '`async` functions take that same combination of generators and Promises and
    define a standardized syntax in the JavaScript language. Create a file named `2files-async.js`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 函数结合了生成器和 Promise，并在 JavaScript 语言中定义了一种标准化的语法。创建一个名为 `2files-async.js`
    的文件：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then run it like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式运行它：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Clean. Readable. The intent of the programmer is clear. No dependency on an
    add-on library, with syntax built-in to the JavaScript language. Most importantly,
    everything is handled in a natural way. Errors are indicated naturally by throwing
    exceptions. The results of an asynchronous operation naturally appear as the result
    of the operation, with the `await` keyword facilitating the delivery of that result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰。易于阅读。程序员的意图非常明确。无需依赖任何附加库，语法内置在 JavaScript 语言中。最重要的是，所有操作都以自然的方式处理。错误通过抛出异常自然地指示。异步操作的结果自然地作为操作的结果出现，`await`
    关键字有助于结果的传递。
- en: 'To see the real advantage, let''s return to the Pyramid of Doom example from
    earlier:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到真正的优势，让我们回到之前提到的“灾难金字塔”示例：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Other than the `try/catch`, this example became very clean compared to its form
    as a callback pyramid. All the asynchronous callback boilerplate is erased, and
    the intent of the programmer shines clearly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `try/catch` 之外，与作为回调金字塔的形式相比，这个例子变得非常简洁。所有异步回调的样板代码都被删除了，程序员的意图清晰可见。
- en: Why was the `try/catch` needed? Normally, an `async` function catches thrown
    errors, automatically reporting them correctly. But since this example is within
    an Express router function, we're limited by its capabilities. Express doesn't
    know how to recognize an `async` function, and therefore it does not know to look
    for the thrown errors. Instead, we're required to `catch` them and call `next(err)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要 `try/catch`？通常，`async` 函数会捕获抛出的错误，并自动正确地报告它们。但因为这个例子是在 Express 路由函数中，所以我们受限于其功能。Express
    无法识别 `async` 函数，因此它不知道要寻找抛出的错误。相反，我们必须 `catch` 它们并调用 `next(err)`。
- en: This improvement is only for code executing inside an `async` function. Code
    outside an `async` function still requires callbacks or Promises for asynchronous
    coding. Further, the return value of an `async` function is a Promise.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此改进仅适用于在 `async` 函数内部执行的代码。`async` 函数外部的代码仍然需要回调或 Promises 来进行异步编程。此外，`async`
    函数的返回值是一个 Promise。
- en: Refer to the official specification of `async` functions at [https://tc39.github.io/ecmascript-asyncawait/](https://tc39.github.io/ecmascript-asyncawait/)
    for details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `async` 函数的详细信息，请参阅官方规范 [https://tc39.github.io/ecmascript-asyncawait/](https://tc39.github.io/ecmascript-asyncawait/)。
- en: Express and the MVC paradigm
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express 和 MVC 范式
- en: 'Express doesn''t enforce an opinion on how you should structure the Model,
    View, and Controller modules of your application, or whether you should follow
    any kind of MVC paradigm at all. As we learned in the previous chapter, the blank
    application created by the Express Generator provides two aspects of the MVC model:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Express 不强制要求您如何构建应用程序的模型、视图和控制器模块，或者是否应该遵循任何类型的 MVC 范式。正如我们在上一章中学到的，Express
    生成器创建的空白应用程序提供了 MVC 模型的两个方面：
- en: The `views` directory contains template files, controlling the display portion,
    corresponding to the View.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views` 目录包含模板文件，控制显示部分，对应于视图。'
- en: The `routes` directory contains code implementing the URLs recognized by the
    application and coordinating the response to each URL. This corresponds to the
    controller.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes` 目录包含实现应用程序识别的 URL 的代码，并协调对每个 URL 的响应。这对应于控制器。'
- en: This leaves you wondering where to put code corresponding to the model. Models
    hold the application data, changing it as instructed by the controller and supplying
    data requested by View code. At a minimum, the Model code should be in separate
    modules from the Controller code. This is to ensure a clean separation of concerns,
    for example, to ease the unit testing of each.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你想知道模型对应的代码应该放在哪里。模型持有应用程序数据，根据控制器的指令进行更改，并为视图代码提供所需的数据。至少，模型代码应该与控制器代码分开在不同的模块中。这是为了确保职责的清晰分离，例如，便于对每个模块进行单元测试。
- en: The approach we'll use is to create a `models` directory as a sibling of the
    `views` and `routes` directories. The `models` directory will hold modules for
    storing the notes and related data. The API of the modules in the `models` directory
    will provide functions to create, read, update, or delete data items **C****reate**, **R****ead**, **Update**,
    and **D****elete** or **Destroy **(**CRUD** model) and other functions necessary
    for the View code to do its thing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用的方法是在 `views` 和 `routes` 目录的兄弟目录中创建一个 `models` 目录。`models` 目录将包含存储笔记和相关数据的模块。`models`
    目录中模块的 API 将提供创建、读取、更新或删除数据项的函数 **C****reate**、**R****ead**、**U****pdate** 和 **D****elete**
    或 **D****estroy**（**CRUD** 模型）以及其他视图代码执行其功能所需的函数。
- en: The CRUD model (create, read, update, destroy) is the four basic operations
    of persistent data storage. The `Notes` application is structured as a CRUD application
    to demonstrate implementing each of these operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 模型（创建、读取、更新、删除）是持久数据存储的四个基本操作。`Notes` 应用程序被构建为一个 CRUD 应用程序，以展示实现这些操作。
- en: We'll use functions named `create`, `read`, `update`, and `destroy` to implement
    each of the basic operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为 `create`、`read`、`update` 和 `destroy` 的函数来实现每个基本操作。
- en: We're using the verb `destroy` rather than `delete`, because `delete` is a reserved
    word in JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用动词 `destroy` 而不是 `delete`，因为 `delete` 是 JavaScript 中的一个保留字。
- en: Creating the Notes application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建笔记应用程序
- en: 'Let''s start creating the *Notes* application as before, by using the Express
    generator to give us a starting point:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像以前一样开始创建 *Notes* 应用程序，使用 Express 生成器为我们提供一个起点：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you wish, you can run `npm start` and view the blank application in your
    browser. Instead, let's move on to setting up the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以运行 `npm start` 并在浏览器中查看空白应用程序。相反，让我们继续设置代码。
- en: Your first Notes model
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个笔记模型
- en: Create a directory named `models`, as a sibling of the `views` and `routes`
    directories.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `models` 的目录，作为 `views` 和 `routes` 目录的兄弟目录。
- en: 'Then, create a file named `Note.js` in that directory, and put this code in
    it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在那个目录中创建一个名为 `Note.js` 的文件，并将此代码放入其中：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This defines a new class, `Note`, for use within our `Notes` application. The
    intent is to hold data related to notes being exchanged between users of our application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个新的类，`Note`，用于在我们的 `Notes` 应用程序中使用。目的是存储与应用程序用户之间交换的笔记相关数据。
- en: Understanding ES-2015 class definitions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ES-2015 类定义
- en: This sort of object class definition is new to JavaScript with ES-2015\. It
    simplifies defining classes over previous methods and brings JavaScript class
    definitions closer to the syntax in other languages. Under the hood, JavaScript
    classes still use prototype-based inheritance, but with a simpler syntax, and
    the coder doesn't even have to think about the object prototype.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reliably determine whether an object is a note with the `instanceof`
    operator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This shows us the clearest method to identify an object is with the `instanceof`
    operator. The `typeof` operator informs us `Note` is a function (because of the
    prototype-based inheritance behind the scenes), and that an instance of the `Note`
    class is an object. With instance of, we can easily determine whether an object
    is an instance of a given class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: With the Note class, we have used `Symbol` instances to provide a small measure
    of data hiding. JavaScript classes don't provide a data-hiding mechanism—you can't
    label a field `private` as you can in Java, for example. It's useful to know how
    to hide implementation details. This is an important attribute of object-oriented
    programming, because it's useful to have the freedom to change the implementation
    at will. And there's the issue of controlling which code can manipulate the object's
    fields.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: First, we declared getter and setter functions to provide access to the values.
    We went over normal getter/setter usage in [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml), *HTTP
    Servers and Clients*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Access to a getter-based field is by using the name of the property, and not
    by calling a function - `aNote.title` and not `aNote.title()`. It looks like you're
    accessing an object property by assigning a value or accessing the value. In actuality,
    the function defined in the class is executed on every access. You can define
    a read-only property by only implementing a getter, and no setter, as we did with
    the `key` field.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'There are significant differences between the preceding and simply defining
    anonymous objects:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We write code like that in JavaScript all the time. It's easy, it's quick, and
    it's a very fluid way to share data between functions. But there's no measure
    of hiding implementation details, and no clear identification of object type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Note` class, we could have used this `constructor` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's effectively the same as the anonymous object, in that no details have
    been hidden and no control is implemented in terms of which code can do what to
    object instances. The only advantage over an anonymous object is using the `instanceof` operator
    to identify object instances.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we chose uses the Symbol class, which is also new with ES-2015\.
    A Symbol is an opaque object with two main use cases:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Generating unique keys to use as property fields—as in the previous `Note` class
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolic identifiers that you can use for concepts like COLOR_RED
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You define a Symbol through a factory method that generates `Symbol` instances:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each time you invoke the Symbol factory method, a new and unique instance is
    created. For example, `Symbol('foo') === Symbol('foo')` is `false`, as is `symfoo
    === Symbol('foo')`, because a new instance is created on each side of the equality
    operator. However, `symfoo === symfoo` is true, because they are the same instance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用符号工厂方法时，都会创建一个新的唯一实例。例如，`Symbol('foo') === Symbol('foo')` 是 `false`，同样 `symfoo
    === Symbol('foo')` 也是 `false`，因为等号两边的每个实例都是新创建的。然而，`symfoo === symfoo` 是 `true`，因为它们是同一个实例。
- en: 'What this means in practice is that if we try a direct approach to access a
    field, it fails:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这意味着，如果我们尝试直接访问一个字段，将会失败：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that each time we use the Symbol factory method we get a new instance.
    The new instance of `Symbol('title')` is not the same instance used within the
    `Note.js` module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次我们使用符号工厂方法时，我们都会得到一个新的实例。`Symbol('title')` 的新实例与 `Note.js` 模块内部使用的实例不是同一个实例。
- en: The bottom line is that using `Symbol` objects for the fields provides a small
    measure of implementation hiding.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，使用 `Symbol` 对象为字段提供了一定程度的功能隐藏。
- en: Filling out the in-memory Notes model
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充内存笔记模型
- en: 'Create a file named `notes-memory.js` in the `models` directory, with this
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models` 目录中创建一个名为 `notes-memory.js` 的文件，包含以下代码：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a simple in-memory data store that's fairly self-explanatory. The `key`
    for each Note instance is used as the index to an array, which in turn holds the
    Note instance. Simple, fast, and easy to implement. It does not support any long-term
    data persistence. Any data stored in this model will disappear when the server
    is killed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直观的简单内存数据存储。每个笔记实例的 `key` 被用作数组的索引，该数组反过来又包含笔记实例。简单、快速且易于实现。它不支持任何长期数据持久性。存储在这个模型中的任何数据，当服务器被关闭时都会消失。
- en: We have used `async` functions because in the future we'll be storing data in
    the file system or in databases. Therefore, we need an asynchronous API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `async` 函数，因为将来我们将在文件系统或数据库中存储数据。因此，我们需要一个异步 API。
- en: The `create` and `update` functions are being handled by the same function.
    At this stage of the Notes application, the code for both these functions can
    be exactly the same because they perform the exact same operation. Later, when
    we add database support to Notes, the `create` and `update` functions will need
    to be different. For example, in a SQL data model, `create` would be implemented
    with an `INSERT INTO` command, while `update` would be implemented with an `UPDATE`
    command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 和 `update` 函数由同一个函数处理。在笔记应用的这个阶段，这两个函数的代码可以完全相同，因为它们执行的是完全相同的操作。稍后，当我们为笔记添加数据库支持时，`create`
    和 `update` 函数将需要不同。例如，在 SQL 数据模型中，`create` 将通过 `INSERT INTO` 命令实现，而 `update` 将通过
    `UPDATE` 命令实现。'
- en: The Notes home page
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 笔记主页
- en: We're going to modify the starter application to support creating, editing,
    updating, viewing, and deleting notes. Let's start by fixing up the home page.
    It should show a list of notes, and the top navigation bar should link to an ADD
    Note page so that we can always add a new note.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改启动应用程序以支持创建、编辑、更新、查看和删除笔记。让我们先修复主页。它应该显示笔记列表，并且顶部的导航栏应该链接到一个“添加笔记”页面，这样我们就可以始终添加新的笔记。
- en: 'While we will be modifying the generated `app.js`, it needs no modification
    to support the home page. These lines of code are related to the home page:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将修改生成的 `app.js`，但为了支持主页，它不需要任何修改。这些代码行与主页相关：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Additionally, to support Handlebars templates `app.js` requires these changes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了支持 Handlebars 模板，`app.js` 需要以下更改：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll put Handlebars `partials` in a directory, `partials`, which is a sibling
    to the `views` directory. Change `routes/index.js` to this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 Handlebars 的 `partials` 放在一个名为 `partials` 的目录中，该目录是 `views` 目录的兄弟目录。将 `routes/index.js`
    修改为以下内容：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This gathers data about the notes that we'll be displaying on the home page.
    By default, we'll show a simple table of note titles. We do need to talk about
    the technique.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这收集了将在主页上显示的笔记的相关数据。默认情况下，我们将显示一个简单的笔记标题表格。我们确实需要讨论一下这项技术。
- en: The `Promise.all` function executes an array of Promises. The Promises are evaluated
    in parallel, allowing our code to potentially make parallel requests to a service.
    This should execute more quickly than making the requests one at a time sequentially.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all` 函数执行一个 Promise 数组。Promise 是并行评估的，允许我们的代码可能对服务进行并行请求。这应该比逐个顺序请求执行得更快。'
- en: 'We could have written a simple `for` loop like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的 `for` 循环，如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While simpler to read, the notes are retrieved one at a time with no opportunity
    to overlap `read` operations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然阅读起来更简单，但笔记是一次性检索的，没有机会重叠`read`操作。
- en: The Promise array is constructed using the `map` function. With `map`, one iterates
    over an array to produce a new array. In this case, the new array contains the
    Promises generated by the `notes.read` function calls.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Promise数组是用`map`函数构建的。使用`map`，我们可以遍历一个数组以生成一个新的数组。在这种情况下，新数组包含由`notes.read`函数调用生成的Promise。
- en: Because we wrote `await Promise.all`, the `notelist` array will be completely
    filled with the correct data once all the Promises succeed. If any Promise fails—is
    rejected, in other words—an exception will be thrown instead. What we've done
    is enqueue a list of asynchronous operations and neatly waited for them all to
    finish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在代码中写了`await Promise.all`，所以一旦所有Promise都成功，`notelist`数组将完全填充正确的数据。如果任何Promise失败——换句话说，被拒绝——将抛出异常。我们所做的是排一个异步操作列表，并优雅地等待它们全部完成。
- en: The `notelist` array is then passed into the `view` templates we're about to
    write.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`notelist`数组被传递到我们即将编写的`view`模板中。
- en: 'Start with `views/layout.hbs`, containing:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从`views/layout.hbs`开始，包含以下内容：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the generated file, with the addition of a partial for the page header.
    We already declared `partials` to live in the `partials` directory. Create `partials/header.hbs`,
    containing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的文件，增加了页面标题的部分。我们已经在`partials`目录中声明了`partials`。创建`partials/header.hbs`，包含以下内容：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Change `views/index.hbs` to this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`views/index.hbs`更改为以下内容：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This simply steps through the array of note data and formats a simple listing.
    Each item links to the `/notes/view` URL with a `key` parameter. We have yet to
    look at that code, but this URL will obviously display the note. Another thing
    of note is that no HTML for the list is generated if the `notelist` is empty.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是遍历笔记数据数组并格式化一个简单的列表。每个条目都链接到带有`key`参数的`/notes/view` URL。我们还没有查看那段代码，但这个URL显然会显示笔记。另一个值得注意的是，如果`notelist`为空，则不会生成列表的HTML。
- en: There's of course a whole lot more that could be put into this. For example,
    it's easy to add jQuery support to every page just by adding the appropriate `script`
    tags here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多可以添加到这个里面。例如，只需在这里添加适当的`script`标签，就可以很容易地为每个页面添加jQuery支持。
- en: 'We now have enough written to run the application; let''s view the home page:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经写足够的内容来运行应用程序；让我们查看主页：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we visit `http://localhost:3000`, we will see the following page:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问`http://localhost:3000`，我们将看到以下页面：
- en: '![](img/34f574a7-e8fe-46b3-a1cf-f806fe04b73c.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34f574a7-e8fe-46b3-a1cf-f806fe04b73c.png)'
- en: Because there aren't any notes (yet), there's nothing to show. Clicking on the
    Home link just refreshes the page. Clicking on the ADD Note link throws an error
    because we haven't (yet) implemented that code. This shows that the provided error
    handler in `app.js` is performing as expected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为还没有任何笔记，所以没有东西可以显示。点击主页链接只是刷新页面。点击添加笔记链接会抛出错误，因为我们还没有（目前）实现那段代码。这表明`app.js`中提供的错误处理器正在按预期执行。
- en: Adding a new note – create
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个新笔记 – 创建
- en: Now, let's look at creating notes. Because the application doesn't have a route
    configured for the `/notes/add` URL, we must add one. To do that, we need a controller
    for the notes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建笔记。因为应用程序没有为`/notes/add` URL配置路由，我们必须添加一个。为此，我们需要一个笔记控制器。
- en: In `app.js`, make the following changes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，进行以下更改。
- en: 'Comment out these lines:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉这些行：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At this stage, the `Notes` application does not support users, and these routes
    are not required. That will change in a future chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`笔记`应用不支持用户，这些路由也不需要。这将在未来的章节中改变。
- en: 'What we really need to do is add code for the `notes` controller:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要做的是添加`notes`控制器的代码：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we''ll add a Controller module containing the `notes` router. Create a
    file named `routes/notes.js`, with this content:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个包含`notes`路由器的控制器模块。创建一个名为`routes/notes.js`的文件，包含以下内容：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The resulting `/notes/add` URL corresponds to the link in `partials/header.hbs`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`/notes/add` URL对应于`partials/header.hbs`中的链接。
- en: 'In the `views` directory, add a template named `noteedit.hbs`, containing the
    following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views`目录中，添加一个名为`noteedit.hbs`的模板，包含以下内容：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We'll be reusing this template to support both editing notes and creating new
    ones.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用这个模板来支持编辑笔记和创建新笔记。
- en: Notice that the `note` and `notekey` objects passed to the template are empty
    in this case. The template detects this condition and ensures the input areas
    are empty. Additionally, a flag, `docreate`, is passed in so that the form records
    whether it is being used to create or update a note. At this point, we're adding
    a new note, so no note object exists. The template code is being written defensively
    to not throw errors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下传递给模板的`note`和`notekey`对象是空的。模板检测到这种条件并确保输入区域为空。此外，还传递了一个名为`docreate`的标志，以便表单记录它是否用于创建或更新笔记。目前，我们正在添加一个新的笔记，因此不存在笔记对象。模板代码正在被编写为防御性，以避免抛出错误。
- en: This template is a form that will `POST` its data to the `/notes/save` URL.
    If you were to run the application at this time, it would give you an error message
    because no route is configured for that URL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板是一个将数据`POST`到`/notes/save` URL的表单。如果你现在运行应用程序，它将显示错误消息，因为没有为该URL配置任何路由。
- en: 'To support the `/notes/save` URL, add this to `routes/notes.js`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持`/notes/save` URL，请将以下内容添加到`routes/notes.js`：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because this URL will also be used for both creating and updating notes, it
    needs to detect the `docreate` flag and call the appropriate model operation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个URL也将用于创建和更新笔记，所以它需要检测`docreate`标志并调用适当的模型操作。
- en: The model returns a Promise for both `notes.create` and `notes.update`. Of course,
    we must call the corresponding Model function based on the `docreate` flag.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模型为`notes.create`和`notes.update`都返回一个Promise。当然，我们必须根据`docreate`标志调用相应的模型函数。
- en: This is a `POST` operation handler. Because of the `bodyParser` middleware,
    the form data is added to the `req.body` object. The fields attached to `req.body`
    correspond directly to elements in the HTML form.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`POST`操作处理程序。由于`bodyParser`中间件，表单数据被添加到`req.body`对象中。附加到`req.body`的字段直接对应于HTML表单中的元素。
- en: 'Now, we can run the application again and use the Add a Note form:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行应用程序并使用添加笔记表单：
- en: '![](img/c832fe20-73d7-4e07-a496-a71faa1fa83e.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c832fe20-73d7-4e07-a496-a71faa1fa83e.png)'
- en: But upon clicking on the Submit button, we get an error message. There isn't
    anything, yet, implementing the `/notes/view` URL.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但在点击提交按钮后，我们得到了一个错误消息。目前还没有实现`/notes/view` URL。
- en: 'You can modify the URL in the location box to revisit `http://localhost:3000`, and
    you''ll see something like the following screenshot on the home page:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改位置框中的URL以重新访问`http://localhost:3000`，您将在主页上看到如下截图：
- en: '![](img/994a5099-4517-4f21-a455-897076962d74.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/994a5099-4517-4f21-a455-897076962d74.png)'
- en: The note is actually there; we just need to implement `/notes/view`. Let's get
    on with that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记实际上就在那里；我们只需要实现`/notes/view`。让我们继续。
- en: Viewing notes – read
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看笔记 – 阅读
- en: Now that we've looked at how to create notes, we need to move on to reading
    them. This means implementing controller logic and view templates for the `/notes/view`
    URL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建笔记，我们需要继续阅读它们。这意味着实现`/notes/view` URL的控制器逻辑和视图模板。
- en: 'To `routes/notes.js`, add this router function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下路由函数添加到`routes/notes.js`：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because this route is mounted on a router handling `/notes`, this route handles `/notes/view`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个路由挂载在处理`/notes`的路由器上，所以这个路由处理`/notes/view`。
- en: If `notes.read` successfully reads the note, it is rendered with the `noteview`
    template. If something goes wrong, we'll instead display an error to the user
    through Express.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`notes.read`成功读取笔记，它将使用`noteview`模板进行渲染。如果出现问题，我们将通过Express向用户显示错误。
- en: 'To the `views` directory, add the `noteview.hbs` template, referenced by this
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将`noteview.hbs`模板添加到`views`目录中，如下代码所示：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is straightforward: taking data out of the note object and displaying
    using HTML. At the bottom are two links, one to `/notes/destroy` to delete the
    note and the other to `/notes/edit` to edit it.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：从笔记对象中提取数据并使用HTML显示。底部有两个链接，一个链接到`/notes/destroy`以删除笔记，另一个链接到`/notes/edit`以编辑它。
- en: 'The code for neither of these exists at the moment. But that won''t stop us
    from going ahead and executing the application:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这两个代码都不存在。但这不会阻止我们继续执行应用程序：
- en: '![](img/e6658cdd-3c46-427e-b5b8-e3f7a8ad7673.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6658cdd-3c46-427e-b5b8-e3f7a8ad7673.png)'
- en: As expected, with this code, the application correctly redirects to `/notes/view`,
    and we can see our handiwork. Also, as expected, clicking on either the Delete
    or Edit links will give you an error, because the code hasn't been implemented.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，使用这段代码，应用程序正确地重定向到`/notes/view`，我们可以看到我们的成果。同样，如预期的那样，点击删除或编辑链接将给出错误，因为代码尚未实现。
- en: Editing an existing note – update
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑现有笔记 – 更新
- en: Now that we've looked at the `create` and `read` operations, let's look at how
    to update or edit a note.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了 `create` 和 `read` 操作，让我们看看如何更新或编辑一个笔记。
- en: 'To `routes/notes.js`, add this router function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/notes.js` 中添加此路由函数：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We're reusing the `noteedit.ejs` template, because it can be used for both `create`
    and `update`/`edit` operations. Notice that we pass `false` for `docreate`, informing
    the template that it is to be used for editing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重用 `noteedit.ejs` 模板，因为它可以用于 `create` 和 `update`/`edit` 操作。注意，我们为 `docreate`
    传递 `false`，通知模板它将被用于编辑。
- en: 'In this case, we first retrieve the note object and then pass it through to
    the template. This way, the template is set up for editing rather than note creation.
    When the user clicks on the Submit button, we''ll end up in the same `/notes/save`
    route handler shown in the preceding screenshot. It already does the right thing:
    calling the `notes.update` method in the model rather than `notes.create`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先检索笔记对象，然后将其传递给模板。这样，模板就为编辑而不是笔记创建设置了。当用户点击提交按钮时，我们将最终进入前面截图所示的相同
    `/notes/save` 路由处理器。它已经做了正确的事情：在模型中调用 `notes.update` 方法而不是 `notes.create`。
- en: 'Because that''s all we need do, we can go ahead and rerun the application:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为那是我们需要做的全部，我们可以继续重新运行应用程序：
- en: '![](img/b3950a09-e038-448e-b3d0-96998fa21d8a.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3950a09-e038-448e-b3d0-96998fa21d8a.png)'
- en: 'Click on the Submit button here, and you will be redirected to the `/notes/view`
    screen and will then be able to read the newly edited note. Back to the `/notes/view`
    screen: we''ve just taken care of the Edit link, but the Delete link still produces
    an error.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里点击提交按钮，你将被重定向到 `/notes/view` 屏幕，然后可以阅读新编辑的笔记。回到 `/notes/view` 屏幕：我们刚刚处理了编辑链接，但删除链接仍然产生错误。
- en: Deleting notes – destroy
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除笔记 – 销毁
- en: Now, let's look at how to implement the `/notes/destroy` URL to delete notes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何实现 `/notes/destroy` URL 来删除笔记。
- en: 'To `routes/notes.js`, add the following router function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/notes.js` 中添加以下路由函数：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Destroying a note is a significant step if only because there's no trash can
    to retrieve it from if we make a mistake. Therefore, we want to ask the user whether
    they're sure they want to delete that note. In this case, we retrieve the note
    and then render the following page, displaying a question to ensure they do want
    to delete the note.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 删除笔记是一个重要的步骤，仅仅是因为如果我们出错，没有回收站可以从中恢复。因此，我们想要询问用户他们是否确定要删除那个笔记。在这种情况下，我们检索笔记，然后渲染以下页面，显示一个问题以确保他们确实想要删除笔记。
- en: 'To the `views` directory, add a `notedestroy.hbs` template:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `views` 目录下，添加一个 `notedestroy.hbs` 模板：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a simple form, asking the user to confirm by clicking on the button.
    The Cancel link just sends them back to the `/notes/view` page. Clicking on the
    Submit button generates a `POST` request on the `/notes/destroy/confirm` URL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的表单，要求用户通过点击按钮来确认。取消链接只是将他们送回到 `/notes/view` 页面。点击提交按钮会在 `/notes/destroy/confirm`
    URL 上生成一个 `POST` 请求。
- en: 'That URL needs a request handler. Add this code to `routes/notes.js`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 URL 需要一个请求处理器。将以下代码添加到 `routes/notes.js`：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This calls the `notes.destroy` function in the model. If it succeeds, the browser
    is redirected to the home page. If not, an error message is shown to the user.
    Rerunning the application, we can now view it in action:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用模型中的 `notes.destroy` 函数。如果成功，浏览器将被重定向到主页。如果不成功，将向用户显示错误消息。重新运行应用程序，我们现在可以查看其效果：
- en: '![](img/30ef8b2e-91a4-4eb1-b3c4-01a06e827bf0.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30ef8b2e-91a4-4eb1-b3c4-01a06e827bf0.png)'
- en: Now that everything is working in the application, you can click on any button
    or link and keep all the notes you want.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序中的所有功能都正常工作，你可以点击任何按钮或链接，保留你想要的全部笔记。
- en: Theming your Express application
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题化 Express 应用程序
- en: The Express team has done a decent job of making sure Express applications look
    okay out of the gate. Our Notes application won't win any design awards, but at
    least it isn't ugly. There's a lot of ways to improve it, now that the basic application
    is running. Let's take a quick look at theming an Express application. In Chapter
    6, *Implementing the Mobile-First Paradigm*, we'll take a deeper dive, focusing
    on that all-important goal of addressing the mobile market.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Express 团队已经做了相当不错的工作，确保 Express 应用程序一开始看起来就很好。我们的笔记应用不会赢得任何设计奖项，但至少它不丑陋。现在基本应用已经运行，我们可以从许多方面来改进它。让我们快速看一下如何为主题化
    Express 应用程序。在第 6 章 *实现移动优先范式* 中，我们将更深入地探讨，重点关注那个至关重要的目标——满足移动市场的需求。
- en: 'If you''re running the *Notes* application using the recommended method, `npm
    start`, a nice log of activity is being printed in your console window. One of
    those is the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用推荐的方法 `npm start` 运行 *Notes* 应用程序，你会在控制台窗口中看到一些活动日志。其中之一如下：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is due to this line of code that we put in `layout.hbs`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在 `layout.hbs` 中添加的这一行代码：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This file was autogenerated for us by the Express Generator at the outset and
    dropped inside the `public` directory. The `public` directory is managed by the
    Express static file server, using this line in `app.js`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件最初是由Express Generator自动生成的，并放置在 `public` 目录中。`public` 目录由Express静态文件服务器管理，使用
    `app.js` 中的这一行：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s open `public/stylesheets/style.css` and take a look:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `public/stylesheets/style.css` 并查看一下：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Something that leaps out is that the application content has a lot of white
    space at the top and left-hand sides of the screen. The reason is that `body` tags
    have the `padding: 50px` style. Changing it is quick business.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '一个突出的问题是应用程序内容在屏幕的顶部和左侧有大量的空白空间。原因是 `body` 标签有 `padding: 50px` 样式。更改它非常简单。'
- en: Since there is no caching in the Express static file server, we can simply edit
    the CSS file and reload the page, and the CSS will be reloaded as well. It's possible
    to turn on cache-control headers and ETags generation, as you would do for a production
    website. Look in the online Express documentation for details.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Express静态文件服务器中没有缓存，我们可以简单地编辑CSS文件并重新加载页面，CSS也会被重新加载。你可以像为生产网站那样开启缓存控制头和ETags生成。有关详细信息，请查看在线Express文档。
- en: 'It involves a little bit of work:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一点工作：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As a result, we''ll have this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到以下内容：
- en: '![](img/8e6139be-9c2b-4c6c-b279-b2b1635eaba2.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e6139be-9c2b-4c6c-b279-b2b1635eaba2.png)'
- en: We're not going to win any design awards with this either, but there's the beginning
    of some branding and theming possibilities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种方法也不会赢得任何设计奖项，但这是品牌和主题化可能性的开始。
- en: Generally speaking, the way we've structured the page templates, applying a site-wide
    theme is just a matter of adding appropriate code to `layout.hbs` along with appropriate
    stylesheets and other assets. Many of the modern theming frameworks, such as Twitter's
    Bootstrap, serve up CSS and JavaScript files out of a CDN server, making it incredibly
    easy to incorporate into a site design.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我们构建页面模板的方式，应用全局主题只需在 `layout.hbs` 中添加适当的代码，以及相应的样式表和其他资源。许多现代主题框架，如Twitter的Bootstrap，通过CDN服务器提供CSS和JavaScript文件，使得将其集成到网站设计中变得极其简单。
- en: For jQuery, refer to [http://jquery.com/download/](http://jquery.com/download/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于jQuery，请参阅[http://jquery.com/download/](http://jquery.com/download/)。
- en: Google's Hosted Libraries service provides a long list of libraries, hosted
    on Google's CDN infrastructure. Refer to [https://developers.google.com/speed/libraries/](https://developers.google.com/speed/libraries/).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Google的托管库服务提供了一系列托管在Google CDN基础设施上的库。请参阅[https://developers.google.com/speed/libraries/](https://developers.google.com/speed/libraries/)。
- en: While it's straightforward to use third-party CDNs to host these assets, it's
    safer to host them yourself. Not only do you take responsibility for bandwidth
    consumption of your application, but you're certain of not being affected by any
    outages of third-party services. As reliable as Google might be, their service
    can go down, and if that means jQuery and Bootstrap doesn't load, your customer
    will think your site is broken. But if those files are loaded from the same server
    as your application, the reliability of delivering those files will exactly equal
    the reliability of your application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用第三方CDN托管这些资源很简单，但自己托管它们更安全。这不仅意味着你负责应用程序的带宽消耗，而且可以确保不会受到第三方服务中断的影响。尽管Google可能很可靠，但他们的服务可能会中断，如果这意味着jQuery和Bootstrap无法加载，你的客户可能会认为你的网站出了问题。但如果这些文件是从与你的应用程序相同的服务器加载的，那么这些文件交付的可靠性将正好等于你应用程序的可靠性。
- en: In Chapter 6, *Implementing the Mobile-First Paradigm*, we will look at a simple
    method to add those front-end libraries to your application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章，*实现移动优先范式*中，我们将探讨一种简单的方法将那些前端库添加到你的应用程序中。
- en: Scaling up – running multiple Notes instances
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展规模 - 运行多个Notes实例
- en: Now that we've got ourselves a running application, you'll have played around
    a bit and created, read, updated, and deleted many notes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个运行中的应用程序，你可能已经玩了一段时间，并创建了、读取了、更新了和删除了许多笔记。
- en: Suppose for a moment this isn't a toy application, but one that is interesting
    enough to draw a million users a day. Serving a high load typically means adding
    servers, load balancers, and many other things. A core part is to have multiple
    instances of the application running at the same time to spread the load.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一下，这不是一个玩具应用，而是一个每天能吸引一百万用户的有趣应用。处理高负载通常意味着添加服务器、负载均衡器以及许多其他东西。核心部分是同时运行多个应用实例以分散负载。
- en: Let's see what happens when you run multiple instances of the Notes application
    at the same time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看同时运行多个 Notes 应用实例会发生什么。
- en: The first thing is to make sure the instances are on different ports. In `bin/www`,
    you'll see that setting the `PORT` environment variable controls the port being
    used. If the `PORT` variable is not set, it defaults to `http://localhost:3000`,
    or what we've been using all along.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是确保实例在不同的端口上。在 `bin/www` 中，你会看到设置 `PORT` 环境变量控制着正在使用的端口。如果 `PORT` 变量未设置，它默认为
    `http://localhost:3000`，或者我们一直在使用的那个。
- en: 'Let''s open up `package.json` and add these lines to the `scripts` section:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `package.json` 并将这些行添加到 `scripts` 部分：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `server1` script runs on `PORT 3001`, while the `server2` script runs on
    `PORT 3002`. Isn't it nice to have all this documented in one place?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`server1` 脚本在 `PORT 3001` 上运行，而 `server2` 脚本在 `PORT 3002` 上运行。不是很好吗，所有这些都在一个地方有文档记录？'
- en: 'Then, in one command window, run this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在一个命令窗口中运行以下命令：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In another command window, run this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个命令窗口中运行以下命令：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This gives us two instances of the Notes application. Use two browser windows
    to visit `http://localhost:3001` and `http://localhost:3002`. Enter a couple of
    notes, and you might see something like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了 Notes 应用的两个实例。使用两个浏览器窗口访问 `http://localhost:3001` 和 `http://localhost:3002`。输入一些笔记，你可能会看到类似这样的内容：
- en: '![](img/3f9f45a6-7222-4702-af1f-c4f52d180d07.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f9f45a6-7222-4702-af1f-c4f52d180d07.png)'
- en: After editing and adding some notes, your two browser windows could look like
    the preceding screenshot. The two instances do not share the same data pool. Each
    is instead running in its own process and memory space. You add a note in one,
    and it does not show in the other screen.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑并添加一些注释后，你的两个浏览器窗口可能看起来像前面的截图。这两个实例不共享相同的数据池。每个实例都在自己的进程和内存空间中运行。你在其中一个中添加注释，它不会显示在另一个屏幕上。
- en: Additionally, because the model code does not persist data anywhere, the notes
    are not saved. You might have written the greatest Node.js programming book of
    all time, but as soon as the application server restarts, it's gone.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为模型代码没有在任何地方持久化数据，所以笔记不会被保存。你可能已经写下了有史以来最伟大的 Node.js 编程书籍，但一旦应用服务器重启，它就消失了。
- en: Typically, you run multiple instances of an application to scale performance.
    That's the old *throw more servers at it* trick. For this to work, the data of
    course must be shared, and each instance must access the same data source. Typically,
    this involves a database. And when it comes to user identity information, it might
    even entail armed guards.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你运行多个应用实例以扩展性能。这就是“给服务器加把劲”的老方法。为了使其工作，数据当然必须共享，并且每个实例必须访问相同的数据源。通常，这涉及到数据库。当涉及到用户身份信息时，甚至可能需要武装警卫。
- en: Hold on—we'll get to database implementation shortly. Before that, we'll cover
    mobile-first development.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等——我们很快就会讨论数据库实现。在那之前，我们将介绍移动优先开发。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've come a long way in this chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经走了很长的路。
- en: We started with the Pyramid of Doom and how the `Promise` object and `async`
    functions can help us a tame asynchronous code. We'll be using these techniques
    all through this book.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从“末日金字塔”开始，讨论 `Promise` 对象和 `async` 函数如何帮助我们驯服异步代码。我们将在整本书中使用这些技术。
- en: We quickly moved on to writing the foundation of a real application with Express.
    At the moment, it keeps its data in memory, but it has the basic functionality
    of what will become a note-taking application supporting real-time collaborative
    commenting on the notes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迅速转向使用 Express 编写真实应用的框架。目前，它将数据保存在内存中，但它具有将成为支持实时协作注释的笔记应用的基本功能。
- en: In the next chapter, we'll dip our toes in the water of responsive, mobile-friendly
    web design. Due to the growing popularity of mobile computing devices, it's become
    necessary to address mobile devices first before desktop computer users. In order
    to reach those millions of users a day, the Notes application users need a good
    user experience when using their smartphone.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将浅尝辄止地涉足响应式、移动友好的网页设计领域。鉴于移动计算设备的日益普及，在考虑桌面电脑用户之前，首先解决移动设备的问题变得必要。为了触及每天数百万的用户，笔记应用的用户在使用智能手机时需要良好的用户体验。
- en: In following chapters, we'll keep growing the capabilities of the Notes application,
    starting with database storage models.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续扩展笔记应用的功能，从数据库存储模型开始。
