- en: Your First Express Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got our feet wet building an Express application for Node.js,
    let's work on an application that performs a useful function. The application
    we'll build will keep a list of notes, and it will let us explore some aspects
    of a real application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll only build the basic infrastructure of the application,
    and in the later chapters, we'll extend the application considerably.
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered in this chapter includes
  prefs: []
  type: TYPE_NORMAL
- en: Using Promises and async functions in Express router functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the MVC paradigm to Express applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript Class definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the CRUD paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlebars templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises, async functions, and Express router functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into developing our application, we must take a deeper look at
    a pair of new ES-2015/2016/2017 features that collectively revolutionize JavaScript
    programming:  The `Promise` class and `async` functions. Both are used for deferred
    and asynchronous computation and can make intensely nested callback a thing of
    the past:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Promise` represents an operation that hasn't completed yet but is expected
    to be completed in the future. We've seen Promises in use. The `.then` or `.catch`
    functions are invoked when the promised result (or error) is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generator* functions are a new kind of function that can be paused and resumed,
    and can return results from the middle of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those two features were mixed with another, the iteration protocol, along with
    some new syntax, to create `async` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magic of `async` functions is that we can write asynchronous code as if
    it's synchronous code. It's still asynchronous code, meaning long-running request
    handlers won't block the event loop. The code looks like the synchronous code
    we'd write in other languages. One statement follows another, the errors are thrown
    as exceptions, and the results land on the next line of code. Promise and `async`
    functions are so much of an improvement that it's extremely compelling for the
    Node.js community to switch paradigms, meaning rewriting legacy callback-oriented
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the years, several other approaches have been used to manage asynchronous
    code, and you may come across code using these other techniques. Before the `Promise`
    object was standardized, at least two implementations were available: Bluebird
    ([http://bluebirdjs.com/](http://bluebirdjs.com/)) and Q ([https://www.npmjs.com/package/q](https://www.npmjs.com/package/q)). Use
    of a non-standard Promise library should be carefully considered, since there
    is value in maintaining compatibility with the standard Promise object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Pyramid of Doom** is named after the shape the code takes after a few
    layers of nesting. Any multistage process can quickly escalate to code nested
    15 levels deep. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Rewriting this as an `async` function will make this much clearer. To get there,
    we need to examine the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Promises to manage asynchronous results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions and Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async` functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We generate a Promise this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that `asyncFunction` is an asynchronous function, but it does not take
    a callback. Instead, it returns a `Promise` object, and the asynchronous code
    is executed within a callback passed to the `Promise` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code must indicate the status of the asynchronous operation via the `resolve`
    and `reject` functions. As implied by the function names, `reject` indicates an
    error occurred and `resolve` indicates a success result. Your caller then uses
    the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The system is fluid enough that the function passed in a `.then` can return
    something, such as another Promise, and you can chain the `.then` calls together.
    The value returned in a `.then` handler (if any) becomes a new Promise object,
    and in this way you can construct a chain of `.then` and `.catch` calls to manage
    a sequence of asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of asynchronous operations would be implemented as a chain of `.then`
    functions, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Promises and error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Promise objects can be in one of three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: This is the initial state, neither fulfilled nor rejected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fulfilled**: This is the final state where it executed successfully and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: produced a result
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rejected**: This is the final state where execution failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this code segment similar to the one we''ll use later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several places where errors can occur in this little bit of code.
    The `notes.read` function has several possible failure modes: the `filterNote`
    function might want to raise an alarm if it detects a cross-site scripting attack.
    The Swedish chef could be on strike. There could be a failure in `res.render`
    or the template being used. But we have only one way to catch and report errors.
    Are we missing something?'
  prefs: []
  type: TYPE_NORMAL
- en: The `Promise` class automatically captures errors, sending them down the chain
    of operations attached to the `Promise`. If the `Promise` class has an error on
    its hands, it skips over the `.then` functions and will instead invoke the first
    `.catch` function it finds. In other words, using instances of Promise provides
    a higher assurance of capturing and reporting errors. With the older convention,
    error reporting was trickier, and it was easy to forget to add correct error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Flattening our asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem being addressed is that asynchronous coding in JavaScript results
    in the Pyramid of Doom. To explain, let''s reiterate the example Ryan Dahl gave
    as the primary Node.js idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The goal was to avoid blocking the event loop with a long operation. Deferring
    the processing of results or errors using callback functions was an excellent
    solution and is the founding idiom of Node.js. The implementation of callback
    functions led to this pyramid-shaped problem.  Namely, that results and errors
    land in the callback. Rather than delivering them to the next line of code, the
    errors and results are buried.
  prefs: []
  type: TYPE_NORMAL
- en: Promises help flatten the code so that it no longer takes a pyramidal shape.
    They also capture errors, ensuring delivery to a useful location. But those errors
    and results are still buried inside an anonymous function and do not get delivered
    to the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Further, using Promises results in a little bit of boilerplate code that obscures
    the programmers intent. It's less boilerplate than with regular callback functions,
    but the boilerplate is still there.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the ECMAScript committee kept working on the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Promises and generators birthed async functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generators and the associated Iteration Protocol are a large topic, which we
    will briefly cover.
  prefs: []
  type: TYPE_NORMAL
- en: The Iteration Protocol is what's behind the new `for..of` loop, and some other
    new looping constructs. These constructs can be used with anything producing an
    iterator. For more about both, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  prefs: []
  type: TYPE_NORMAL
- en: A generator is a kind of function which can be stopped and started using the
    `yield` keyword. Generators produce an iterator whose values are whatever is given
    to the yield statement. For more on this, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `yield` statement causes a generator function to pause and to provide the
    value given to the next call on its `next` function. The `next` function isn''t
    explicitly seen here, but is what controls the loop, and is part of the iteration
    protocol. Instead of the loop, try calling `gen().next()` several times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Iteration protocol says the iterator is finished when `done` is `true`.
    In this case, we didn't call it enough to trigger the end state of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Where generators became interesting is when used with functions that return
    a Promise. The Promise is what's made available through the iterator. The code
    consuming the iterator can wait on the Promise to get its value. A series of asynchronous
    operations could be inside the generator and invoked in an iterable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of an extra function, a generator function along with Promise-returning
    asynchronous functions can be a very nice way to write asynchronous code. We saw
    an example of this in Chapter 2,* Setting up Node.js,* while exploring Babel.
    Babel has a plugin to rewrite `async` functions into a generator along with a
    helper function, and we took a look at the transpiled code and the helper function.
    The `co` library ([https://www.npmjs.com/package/co](https://www.npmjs.com/package/co))
    is a popular helper function for implementing asynchronous coding in generators.
    Create a file named `2files.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Normally, `fs.readFile` sends its result to a callback function, and we'd build
    a little pyramid-shaped piece of code to perform this task. The `fs-extra` module
    contains implementations of all functions from the built-in `fs` module but changed
    to return a Promise instead of a callback function. Therefore, each `fs.readFile`
    shown here is returning a Promise that's resolved when the file content is fully
    read into memory. What `co` does is it manages the dance of waiting for the Promise
    to be resolved (or rejected), and returns the value of the Promise. Therefore,
    with two suitable text files we have the result shown from executing `2files.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is that the code is very clean and readable. We aren't caught
    up in boilerplate code required to manage asynchronous operations. The intent
    of the programmer is pretty clear.
  prefs: []
  type: TYPE_NORMAL
- en: '`async` functions take that same combination of generators and Promises and
    define a standardized syntax in the JavaScript language. Create a file named `2files-async.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Clean. Readable. The intent of the programmer is clear. No dependency on an
    add-on library, with syntax built-in to the JavaScript language. Most importantly,
    everything is handled in a natural way. Errors are indicated naturally by throwing
    exceptions. The results of an asynchronous operation naturally appear as the result
    of the operation, with the `await` keyword facilitating the delivery of that result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the real advantage, let''s return to the Pyramid of Doom example from
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Other than the `try/catch`, this example became very clean compared to its form
    as a callback pyramid. All the asynchronous callback boilerplate is erased, and
    the intent of the programmer shines clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Why was the `try/catch` needed? Normally, an `async` function catches thrown
    errors, automatically reporting them correctly. But since this example is within
    an Express router function, we're limited by its capabilities. Express doesn't
    know how to recognize an `async` function, and therefore it does not know to look
    for the thrown errors. Instead, we're required to `catch` them and call `next(err)`.
  prefs: []
  type: TYPE_NORMAL
- en: This improvement is only for code executing inside an `async` function. Code
    outside an `async` function still requires callbacks or Promises for asynchronous
    coding. Further, the return value of an `async` function is a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official specification of `async` functions at [https://tc39.github.io/ecmascript-asyncawait/](https://tc39.github.io/ecmascript-asyncawait/)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Express and the MVC paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express doesn''t enforce an opinion on how you should structure the Model,
    View, and Controller modules of your application, or whether you should follow
    any kind of MVC paradigm at all. As we learned in the previous chapter, the blank
    application created by the Express Generator provides two aspects of the MVC model:'
  prefs: []
  type: TYPE_NORMAL
- en: The `views` directory contains template files, controlling the display portion,
    corresponding to the View.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` directory contains code implementing the URLs recognized by the
    application and coordinating the response to each URL. This corresponds to the
    controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This leaves you wondering where to put code corresponding to the model. Models
    hold the application data, changing it as instructed by the controller and supplying
    data requested by View code. At a minimum, the Model code should be in separate
    modules from the Controller code. This is to ensure a clean separation of concerns,
    for example, to ease the unit testing of each.
  prefs: []
  type: TYPE_NORMAL
- en: The approach we'll use is to create a `models` directory as a sibling of the
    `views` and `routes` directories. The `models` directory will hold modules for
    storing the notes and related data. The API of the modules in the `models` directory
    will provide functions to create, read, update, or delete data items **C****reate**, **R****ead**, **Update**,
    and **D****elete** or **Destroy **(**CRUD** model) and other functions necessary
    for the View code to do its thing.
  prefs: []
  type: TYPE_NORMAL
- en: The CRUD model (create, read, update, destroy) is the four basic operations
    of persistent data storage. The `Notes` application is structured as a CRUD application
    to demonstrate implementing each of these operations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use functions named `create`, `read`, `update`, and `destroy` to implement
    each of the basic operations.
  prefs: []
  type: TYPE_NORMAL
- en: We're using the verb `destroy` rather than `delete`, because `delete` is a reserved
    word in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start creating the *Notes* application as before, by using the Express
    generator to give us a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you wish, you can run `npm start` and view the blank application in your
    browser. Instead, let's move on to setting up the code.
  prefs: []
  type: TYPE_NORMAL
- en: Your first Notes model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a directory named `models`, as a sibling of the `views` and `routes`
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a file named `Note.js` in that directory, and put this code in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This defines a new class, `Note`, for use within our `Notes` application. The
    intent is to hold data related to notes being exchanged between users of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ES-2015 class definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This sort of object class definition is new to JavaScript with ES-2015\. It
    simplifies defining classes over previous methods and brings JavaScript class
    definitions closer to the syntax in other languages. Under the hood, JavaScript
    classes still use prototype-based inheritance, but with a simpler syntax, and
    the coder doesn't even have to think about the object prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reliably determine whether an object is a note with the `instanceof`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This shows us the clearest method to identify an object is with the `instanceof`
    operator. The `typeof` operator informs us `Note` is a function (because of the
    prototype-based inheritance behind the scenes), and that an instance of the `Note`
    class is an object. With instance of, we can easily determine whether an object
    is an instance of a given class.
  prefs: []
  type: TYPE_NORMAL
- en: With the Note class, we have used `Symbol` instances to provide a small measure
    of data hiding. JavaScript classes don't provide a data-hiding mechanism—you can't
    label a field `private` as you can in Java, for example. It's useful to know how
    to hide implementation details. This is an important attribute of object-oriented
    programming, because it's useful to have the freedom to change the implementation
    at will. And there's the issue of controlling which code can manipulate the object's
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: First, we declared getter and setter functions to provide access to the values.
    We went over normal getter/setter usage in [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml), *HTTP
    Servers and Clients*.
  prefs: []
  type: TYPE_NORMAL
- en: Access to a getter-based field is by using the name of the property, and not
    by calling a function - `aNote.title` and not `aNote.title()`. It looks like you're
    accessing an object property by assigning a value or accessing the value. In actuality,
    the function defined in the class is executed on every access. You can define
    a read-only property by only implementing a getter, and no setter, as we did with
    the `key` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are significant differences between the preceding and simply defining
    anonymous objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We write code like that in JavaScript all the time. It's easy, it's quick, and
    it's a very fluid way to share data between functions. But there's no measure
    of hiding implementation details, and no clear identification of object type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Note` class, we could have used this `constructor` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That's effectively the same as the anonymous object, in that no details have
    been hidden and no control is implemented in terms of which code can do what to
    object instances. The only advantage over an anonymous object is using the `instanceof` operator
    to identify object instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we chose uses the Symbol class, which is also new with ES-2015\.
    A Symbol is an opaque object with two main use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating unique keys to use as property fields—as in the previous `Note` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolic identifiers that you can use for concepts like COLOR_RED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You define a Symbol through a factory method that generates `Symbol` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each time you invoke the Symbol factory method, a new and unique instance is
    created. For example, `Symbol('foo') === Symbol('foo')` is `false`, as is `symfoo
    === Symbol('foo')`, because a new instance is created on each side of the equality
    operator. However, `symfoo === symfoo` is true, because they are the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means in practice is that if we try a direct approach to access a
    field, it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember that each time we use the Symbol factory method we get a new instance.
    The new instance of `Symbol('title')` is not the same instance used within the
    `Note.js` module.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that using `Symbol` objects for the fields provides a small
    measure of implementation hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Filling out the in-memory Notes model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `notes-memory.js` in the `models` directory, with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple in-memory data store that's fairly self-explanatory. The `key`
    for each Note instance is used as the index to an array, which in turn holds the
    Note instance. Simple, fast, and easy to implement. It does not support any long-term
    data persistence. Any data stored in this model will disappear when the server
    is killed.
  prefs: []
  type: TYPE_NORMAL
- en: We have used `async` functions because in the future we'll be storing data in
    the file system or in databases. Therefore, we need an asynchronous API.
  prefs: []
  type: TYPE_NORMAL
- en: The `create` and `update` functions are being handled by the same function.
    At this stage of the Notes application, the code for both these functions can
    be exactly the same because they perform the exact same operation. Later, when
    we add database support to Notes, the `create` and `update` functions will need
    to be different. For example, in a SQL data model, `create` would be implemented
    with an `INSERT INTO` command, while `update` would be implemented with an `UPDATE`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to modify the starter application to support creating, editing,
    updating, viewing, and deleting notes. Let's start by fixing up the home page.
    It should show a list of notes, and the top navigation bar should link to an ADD
    Note page so that we can always add a new note.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we will be modifying the generated `app.js`, it needs no modification
    to support the home page. These lines of code are related to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, to support Handlebars templates `app.js` requires these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll put Handlebars `partials` in a directory, `partials`, which is a sibling
    to the `views` directory. Change `routes/index.js` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This gathers data about the notes that we'll be displaying on the home page.
    By default, we'll show a simple table of note titles. We do need to talk about
    the technique.
  prefs: []
  type: TYPE_NORMAL
- en: The `Promise.all` function executes an array of Promises. The Promises are evaluated
    in parallel, allowing our code to potentially make parallel requests to a service.
    This should execute more quickly than making the requests one at a time sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have written a simple `for` loop like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While simpler to read, the notes are retrieved one at a time with no opportunity
    to overlap `read` operations.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise array is constructed using the `map` function. With `map`, one iterates
    over an array to produce a new array. In this case, the new array contains the
    Promises generated by the `notes.read` function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Because we wrote `await Promise.all`, the `notelist` array will be completely
    filled with the correct data once all the Promises succeed. If any Promise fails—is
    rejected, in other words—an exception will be thrown instead. What we've done
    is enqueue a list of asynchronous operations and neatly waited for them all to
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: The `notelist` array is then passed into the `view` templates we're about to
    write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with `views/layout.hbs`, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the generated file, with the addition of a partial for the page header.
    We already declared `partials` to live in the `partials` directory. Create `partials/header.hbs`,
    containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `views/index.hbs` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This simply steps through the array of note data and formats a simple listing.
    Each item links to the `/notes/view` URL with a `key` parameter. We have yet to
    look at that code, but this URL will obviously display the note. Another thing
    of note is that no HTML for the list is generated if the `notelist` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: There's of course a whole lot more that could be put into this. For example,
    it's easy to add jQuery support to every page just by adding the appropriate `script`
    tags here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have enough written to run the application; let''s view the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we visit `http://localhost:3000`, we will see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34f574a7-e8fe-46b3-a1cf-f806fe04b73c.png)'
  prefs: []
  type: TYPE_IMG
- en: Because there aren't any notes (yet), there's nothing to show. Clicking on the
    Home link just refreshes the page. Clicking on the ADD Note link throws an error
    because we haven't (yet) implemented that code. This shows that the provided error
    handler in `app.js` is performing as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new note – create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's look at creating notes. Because the application doesn't have a route
    configured for the `/notes/add` URL, we must add one. To do that, we need a controller
    for the notes.
  prefs: []
  type: TYPE_NORMAL
- en: In `app.js`, make the following changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, the `Notes` application does not support users, and these routes
    are not required. That will change in a future chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really need to do is add code for the `notes` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll add a Controller module containing the `notes` router. Create a
    file named `routes/notes.js`, with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The resulting `/notes/add` URL corresponds to the link in `partials/header.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `views` directory, add a template named `noteedit.hbs`, containing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We'll be reusing this template to support both editing notes and creating new
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `note` and `notekey` objects passed to the template are empty
    in this case. The template detects this condition and ensures the input areas
    are empty. Additionally, a flag, `docreate`, is passed in so that the form records
    whether it is being used to create or update a note. At this point, we're adding
    a new note, so no note object exists. The template code is being written defensively
    to not throw errors.
  prefs: []
  type: TYPE_NORMAL
- en: This template is a form that will `POST` its data to the `/notes/save` URL.
    If you were to run the application at this time, it would give you an error message
    because no route is configured for that URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support the `/notes/save` URL, add this to `routes/notes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because this URL will also be used for both creating and updating notes, it
    needs to detect the `docreate` flag and call the appropriate model operation.
  prefs: []
  type: TYPE_NORMAL
- en: The model returns a Promise for both `notes.create` and `notes.update`. Of course,
    we must call the corresponding Model function based on the `docreate` flag.
  prefs: []
  type: TYPE_NORMAL
- en: This is a `POST` operation handler. Because of the `bodyParser` middleware,
    the form data is added to the `req.body` object. The fields attached to `req.body`
    correspond directly to elements in the HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application again and use the Add a Note form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c832fe20-73d7-4e07-a496-a71faa1fa83e.png)'
  prefs: []
  type: TYPE_IMG
- en: But upon clicking on the Submit button, we get an error message. There isn't
    anything, yet, implementing the `/notes/view` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify the URL in the location box to revisit `http://localhost:3000`, and
    you''ll see something like the following screenshot on the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/994a5099-4517-4f21-a455-897076962d74.png)'
  prefs: []
  type: TYPE_IMG
- en: The note is actually there; we just need to implement `/notes/view`. Let's get
    on with that.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing notes – read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at how to create notes, we need to move on to reading
    them. This means implementing controller logic and view templates for the `/notes/view`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `routes/notes.js`, add this router function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because this route is mounted on a router handling `/notes`, this route handles `/notes/view`.
  prefs: []
  type: TYPE_NORMAL
- en: If `notes.read` successfully reads the note, it is rendered with the `noteview`
    template. If something goes wrong, we'll instead display an error to the user
    through Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the `views` directory, add the `noteview.hbs` template, referenced by this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is straightforward: taking data out of the note object and displaying
    using HTML. At the bottom are two links, one to `/notes/destroy` to delete the
    note and the other to `/notes/edit` to edit it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for neither of these exists at the moment. But that won''t stop us
    from going ahead and executing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6658cdd-3c46-427e-b5b8-e3f7a8ad7673.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, with this code, the application correctly redirects to `/notes/view`,
    and we can see our handiwork. Also, as expected, clicking on either the Delete
    or Edit links will give you an error, because the code hasn't been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Editing an existing note – update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at the `create` and `read` operations, let's look at how
    to update or edit a note.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `routes/notes.js`, add this router function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We're reusing the `noteedit.ejs` template, because it can be used for both `create`
    and `update`/`edit` operations. Notice that we pass `false` for `docreate`, informing
    the template that it is to be used for editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we first retrieve the note object and then pass it through to
    the template. This way, the template is set up for editing rather than note creation.
    When the user clicks on the Submit button, we''ll end up in the same `/notes/save`
    route handler shown in the preceding screenshot. It already does the right thing:
    calling the `notes.update` method in the model rather than `notes.create`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because that''s all we need do, we can go ahead and rerun the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3950a09-e038-448e-b3d0-96998fa21d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Submit button here, and you will be redirected to the `/notes/view`
    screen and will then be able to read the newly edited note. Back to the `/notes/view`
    screen: we''ve just taken care of the Edit link, but the Delete link still produces
    an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting notes – destroy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's look at how to implement the `/notes/destroy` URL to delete notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `routes/notes.js`, add the following router function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Destroying a note is a significant step if only because there's no trash can
    to retrieve it from if we make a mistake. Therefore, we want to ask the user whether
    they're sure they want to delete that note. In this case, we retrieve the note
    and then render the following page, displaying a question to ensure they do want
    to delete the note.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the `views` directory, add a `notedestroy.hbs` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple form, asking the user to confirm by clicking on the button.
    The Cancel link just sends them back to the `/notes/view` page. Clicking on the
    Submit button generates a `POST` request on the `/notes/destroy/confirm` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'That URL needs a request handler. Add this code to `routes/notes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This calls the `notes.destroy` function in the model. If it succeeds, the browser
    is redirected to the home page. If not, an error message is shown to the user.
    Rerunning the application, we can now view it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30ef8b2e-91a4-4eb1-b3c4-01a06e827bf0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that everything is working in the application, you can click on any button
    or link and keep all the notes you want.
  prefs: []
  type: TYPE_NORMAL
- en: Theming your Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Express team has done a decent job of making sure Express applications look
    okay out of the gate. Our Notes application won't win any design awards, but at
    least it isn't ugly. There's a lot of ways to improve it, now that the basic application
    is running. Let's take a quick look at theming an Express application. In Chapter
    6, *Implementing the Mobile-First Paradigm*, we'll take a deeper dive, focusing
    on that all-important goal of addressing the mobile market.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re running the *Notes* application using the recommended method, `npm
    start`, a nice log of activity is being printed in your console window. One of
    those is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is due to this line of code that we put in `layout.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This file was autogenerated for us by the Express Generator at the outset and
    dropped inside the `public` directory. The `public` directory is managed by the
    Express static file server, using this line in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open `public/stylesheets/style.css` and take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Something that leaps out is that the application content has a lot of white
    space at the top and left-hand sides of the screen. The reason is that `body` tags
    have the `padding: 50px` style. Changing it is quick business.'
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no caching in the Express static file server, we can simply edit
    the CSS file and reload the page, and the CSS will be reloaded as well. It's possible
    to turn on cache-control headers and ETags generation, as you would do for a production
    website. Look in the online Express documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'It involves a little bit of work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we''ll have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e6139be-9c2b-4c6c-b279-b2b1635eaba2.png)'
  prefs: []
  type: TYPE_IMG
- en: We're not going to win any design awards with this either, but there's the beginning
    of some branding and theming possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the way we've structured the page templates, applying a site-wide
    theme is just a matter of adding appropriate code to `layout.hbs` along with appropriate
    stylesheets and other assets. Many of the modern theming frameworks, such as Twitter's
    Bootstrap, serve up CSS and JavaScript files out of a CDN server, making it incredibly
    easy to incorporate into a site design.
  prefs: []
  type: TYPE_NORMAL
- en: For jQuery, refer to [http://jquery.com/download/](http://jquery.com/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Google's Hosted Libraries service provides a long list of libraries, hosted
    on Google's CDN infrastructure. Refer to [https://developers.google.com/speed/libraries/](https://developers.google.com/speed/libraries/).
  prefs: []
  type: TYPE_NORMAL
- en: While it's straightforward to use third-party CDNs to host these assets, it's
    safer to host them yourself. Not only do you take responsibility for bandwidth
    consumption of your application, but you're certain of not being affected by any
    outages of third-party services. As reliable as Google might be, their service
    can go down, and if that means jQuery and Bootstrap doesn't load, your customer
    will think your site is broken. But if those files are loaded from the same server
    as your application, the reliability of delivering those files will exactly equal
    the reliability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 6, *Implementing the Mobile-First Paradigm*, we will look at a simple
    method to add those front-end libraries to your application.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up – running multiple Notes instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got ourselves a running application, you'll have played around
    a bit and created, read, updated, and deleted many notes.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose for a moment this isn't a toy application, but one that is interesting
    enough to draw a million users a day. Serving a high load typically means adding
    servers, load balancers, and many other things. A core part is to have multiple
    instances of the application running at the same time to spread the load.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what happens when you run multiple instances of the Notes application
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is to make sure the instances are on different ports. In `bin/www`,
    you'll see that setting the `PORT` environment variable controls the port being
    used. If the `PORT` variable is not set, it defaults to `http://localhost:3000`,
    or what we've been using all along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `package.json` and add these lines to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `server1` script runs on `PORT 3001`, while the `server2` script runs on
    `PORT 3002`. Isn't it nice to have all this documented in one place?
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in one command window, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In another command window, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us two instances of the Notes application. Use two browser windows
    to visit `http://localhost:3001` and `http://localhost:3002`. Enter a couple of
    notes, and you might see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f9f45a6-7222-4702-af1f-c4f52d180d07.png)'
  prefs: []
  type: TYPE_IMG
- en: After editing and adding some notes, your two browser windows could look like
    the preceding screenshot. The two instances do not share the same data pool. Each
    is instead running in its own process and memory space. You add a note in one,
    and it does not show in the other screen.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, because the model code does not persist data anywhere, the notes
    are not saved. You might have written the greatest Node.js programming book of
    all time, but as soon as the application server restarts, it's gone.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you run multiple instances of an application to scale performance.
    That's the old *throw more servers at it* trick. For this to work, the data of
    course must be shared, and each instance must access the same data source. Typically,
    this involves a database. And when it comes to user identity information, it might
    even entail armed guards.
  prefs: []
  type: TYPE_NORMAL
- en: Hold on—we'll get to database implementation shortly. Before that, we'll cover
    mobile-first development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come a long way in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We started with the Pyramid of Doom and how the `Promise` object and `async`
    functions can help us a tame asynchronous code. We'll be using these techniques
    all through this book.
  prefs: []
  type: TYPE_NORMAL
- en: We quickly moved on to writing the foundation of a real application with Express.
    At the moment, it keeps its data in memory, but it has the basic functionality
    of what will become a note-taking application supporting real-time collaborative
    commenting on the notes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dip our toes in the water of responsive, mobile-friendly
    web design. Due to the growing popularity of mobile computing devices, it's become
    necessary to address mobile devices first before desktop computer users. In order
    to reach those millions of users a day, the Notes application users need a good
    user experience when using their smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: In following chapters, we'll keep growing the capabilities of the Notes application,
    starting with database storage models.
  prefs: []
  type: TYPE_NORMAL
