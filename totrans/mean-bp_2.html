<html><head></head><body>
<div class="book" title="Chapter&#xA0;2.&#xA0;Expense Tracker" id="MSDG1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Expense Tracker</h1></div></div></div><p class="calibre8">In this chapter, we will see how to build an expense tracker application. It will store all of our expenses for a given category. We will be able to see an aggregated balance of our expenses, or expenses by category. Each user will have a separate account to manage their expenses.</p><p class="calibre8">Some of the interesting <a id="id110" class="calibre1"/>topics that we will cover are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating a multiuser system</li><li class="listitem">Working with monetary data</li><li class="listitem">Using the MongoDB aggregation framework</li><li class="listitem">Different authentication strategies, such as HTTP Basic and token-based authentication</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Expense Tracker" id="MSDG1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Setting up the base application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec17" class="calibre1"/>Setting up the base application</h1></div></div></div><p class="calibre8">Let's set <a id="id111" class="calibre1"/>up the base structure and files of our <a id="id112" class="calibre1"/>application. The whole source code for the project will be available as a bundle at <a class="calibre1" href="https://www.packtpub.com/">https://www.packtpub.com/</a>. Therefore, we are only going to detail the most important part of setting up the base application.</p></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Expense Tracker" id="MSDG1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Setting up the base application">
<div class="book" title="Installing the dependencies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec31" class="calibre1"/>Installing the dependencies</h2></div></div></div><p class="calibre8">Let's start by <a id="id113" class="calibre1"/>creating our <code class="email">package.json</code> file in the root of the project and adding the following code:</p><div class="informalexample"><pre class="programlisting">{
  "name": "mean-blueprints-expensetracker",
  "version": "0.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/robert52/mean-blueprints-expensetracker.git"
  },
  "engines": {
    "node": "&gt;=0.12.0"
  },
  "scripts": {
    "start": "node app.js",
    "unit": "mocha tests/unit/ --ui bdd --recursive --reporter spec --timeout 10000 --slow 900",
    "integration": "mocha tests/integration/ --ui bdd --recursive --reporter spec --timeout 10000 --slow 900"
  },
  "dependencies": {
    "async": "^0.9.0",
    "body-parser": "^1.12.3",
    "express": "^4.12.4",
    "express-session": "^1.11.2",
    "lodash": "^3.7.0",
    "method-override": "^2.3.2",
    "mongoose": "^4.0.2",
    "passport": "^0.2.1",
    "passport-local": "^1.0.0",
    "serve-static": "^1.9.2"
  },
  "devDependencies": {
    "chai": "^2.3.0",
    "chai-things": "^0.2.0",
    "mocha": "^2.2.4",
    "request": "^2.55.0"
  }
}</pre></div><p class="calibre8">The next step <a id="id114" class="calibre1"/>after defining the <code class="email">package.json</code> file is to install the necessary dependencies. Run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">npm install</strong></span>
</pre></div><p class="calibre8">After <code class="email">npm</code> has pulled all the necessary files, you should be returned to the command prompt.</p></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Expense Tracker" id="MSDG1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Setting up the base application">
<div class="book" title="Creating the base configuration files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec32" class="calibre1"/>Creating the base configuration files</h2></div></div></div><p class="calibre8">We <a id="id115" class="calibre1"/>are going to reuse a lot of code from the previous contact manager project. We created a file to load the necessary environment config file based on the current environment node is running. Add a new config file.</p><p class="calibre8">Create a <a id="id116" class="calibre1"/>file called <code class="email">config/environments/development.js</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = {
  port: 3000,
  hostname: 'localhost',
  baseUrl: 'http://localhost:3000',
  mongodb: {
    uri: 'mongodb://localhost/expense_dev_db'
  },
  app: {
    name: 'Expense tracker'
  },
  serveStatic: true,
  session: {
    session: {
      type: 'mongo',
      secret: 'someVeRyN1c3S#cr3tHer34U',
      resave: false,
      saveUninitialized: true
    }
  }
};</pre></div><p class="calibre8">Next, we are going to create the configuration file for Express and add the following lines of code to <code class="email">config/express.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const path = require('path');
const bodyParser = require('body-parser');
const methodOverride = require('method-override');
const serveStatic = require('serve-static');
const session = require('express-session');
const MongoStore = require('connect-mongo')(session);
const passport = require('passport');
const config = require('./index');

module.exports.init = initExpress

function initExpress(app) {
  const env = app.get('env');
  const root = app.get('root');
  const sessionOpts = {
    secret: config.session.secret,
    key: 'skey.sid',
    resave: config.session.resave,
    saveUninitialized: config.session.saveUninitialized
  };

  app.use(bodyParser.urlencoded({ extended: true }));
  app.use(bodyParser.json());
  app.use(methodOverride());
  app.disable('x-powered-by');

  if (config.session.type === 'mongo') {
    sessionOpts.store = new MongoStore({
      url: config.mongodb.uri
    });
  }

  app.use(session(sessionOpts));
  app.use(passport.initialize());
  app.use(passport.session());

  if (config.serveStatic) {
    app.use(serveStatic(path.join(root, 'public')));
  }
}</pre></div><p class="calibre8">Finally, we <a id="id117" class="calibre1"/>are going to add a file called <code class="email">config/mongoose.js</code> to connect to MongoDB, with the following content:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const config = require('./index');

module.exports.init = initMongoose;

function initMongoose(app) {
  mongoose.connect(config.mongodb.uri);

  // If the Node process ends, cleanup existing connections
  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('SIGHUP', cleanup);

  if (app) {
    app.set('mongoose', mongoose);
  }

  return mongoose;
}

function cleanup() {
  mongoose.connection.close(function () {
    console.log('Closing DB connections and stopping the app. Bye bye.');
    process.exit(0);
  });
}</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Expense Tracker" id="MSDG1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Setting up the base application">
<div class="book" title="Creating the main server.js file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec33" class="calibre1"/>Creating the main server.js file</h2></div></div></div><p class="calibre8">The <a id="id118" class="calibre1"/>main entry point for our application is the <code class="email">server.js</code> file. Create it in the root of the project. This file starts the web server and bootstraps all of the logic. Add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

// Get process environment or set default environment to development
const ENV = process.env.NODE_ENV || 'development';
const DEFAULT_PORT = 3000;
const DEFAULT_HOSTNAME = 'localhost';

const http = require('http');
const express = require('express');
const config = require('./config');
const app = express();
let server;

/**
 * Set express (app) variables
 */
app.set('config', config);
app.set('root', __dirname);
app.set('env', ENV);

require('./config/mongoose').init(app);
require('./config/models').init(app);
require('./config/passport').init(app);
require('./config/express').init(app);
require('./config/routes').init(app);

app.use((err, req, res, next) =&gt; {
  res.status(500).json(err);
});

/**
 * Start the app if not loaded by another module
 */
 if (!module.parent) {
   server = http.createServer(app);
   server.listen(
     config.port || DEFAULT_PORT,
     config.hostname || DEFAULT_HOSTNAME,
     () =&gt; {
       console.log(`${config.app.name} is running`);
       console.log(`   listening on port: ${config.port}`);
       console.log(`   environment: ${ENV.toLowerCase()}`);
     }
   );
 }

module.exports = app;</pre></div></div></div></div>

<div class="book" title="Setting up the user section"><div class="book" id="NQU22-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Setting up the user section</h1></div></div></div><p class="calibre8">In the previous <a id="id119" class="calibre1"/>chapter, we also had a user section for the application. In this chapter, we are going to extend those functionalities by <a id="id120" class="calibre1"/>adding the register and change password functionalities. We are going to reuse the existing code base and add the new features.</p></div>

<div class="book" title="Setting up the user section">
<div class="book" title="Describing the user model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec34" class="calibre1"/>Describing the user model</h2></div></div></div><p class="calibre8">We will create a <a id="id121" class="calibre1"/>test file specifically for the user model. This will come in handy for testing all its functionalities without booting up the entire application. Create a file called <code class="email">test/integration/user.model.test.js</code> and add the following content:</p><div class="informalexample"><pre class="programlisting">'use strict';

/**
 * Important! Set the environment to test
 */
process.env.NODE_ENV = 'test';

const chai = require('chai');
const should = chai.should();
consst config = require('../../config/environments/test');

describe('User model', function() {
  const mongoose;
  const User;
  const _user;
  const newUserData = {
    email: 'jane.doe@test.com',
    password: 'user_password',
    name: 'Jane Doe'
  };

  before(function(done) {
    mongoose = require('../../config/mongoose').init();
    User = require('../../app/models/user');
    done();
  });

  after(function(done) {
    User.remove({}).exec(function(err) {
      if (err) throw err;

      mongoose.connection.close(function() {
        setTimeout(function() { done(); }, 1000);
      });
    });
  });
});</pre></div><p class="calibre8">We have defined the <a id="id122" class="calibre1"/>base for our test file. Now we are going to add each test case one by one, before the last closing bracket:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">A user should be able to register with our system. We can test this with the following lines of code:<div class="informalexample"><pre class="programlisting">  it('should register a user', function(done) {
    User.register(newUserData, function(err, user) {
      if (err) throw err;

      should.exist(user);
      user.email.should.equal(newUserData.email);
      should.not.exist(user.password);
      should.not.exist(user.passwordSalt);
      should.exist(user.createdAt);
      user.active.should.equal(true);

      _user = user;
      done();
    });
  });</pre></div></li><li class="listitem" value="2">The same user cannot register twice with the same e-mail:<div class="informalexample"><pre class="programlisting">  it('should not register a user if already exists', function(done) {
    User.register(newUserData, function(err, user) {
      should.exist(err);
      err.code.should.equal(11000); // duplicate key error
      should.not.exist(user);
      done();
    });
  });</pre></div></li><li class="listitem" value="3">After successful registration, a user should be able to authenticate into our system:<div class="informalexample"><pre class="programlisting">  it('should authenticate a user with valid credentials', function(done) {
    User.authenticate(newUserData.email, 'user_password', function(err, user) {
      if (err) throw err;

      should.exist(user);
      should.not.exist(user.password);
      should.not.exist(user.passwordSalt);
      user.email.should.equal(newUserData.email);
      done();
    });
  });</pre></div></li><li class="listitem" value="4">If a user <a id="id123" class="calibre1"/>provides invalid credentials, it should not be authenticated successfully:<div class="informalexample"><pre class="programlisting">  it('should not authenticate user with invalid credentials', function(done) {
    User.authenticate(newUserData.email, 'notuserpassowrd', function(err, user) {
      if (err) throw err;

      should.not.exist(user);
      done();
    });
  });</pre></div></li><li class="listitem" value="5">A user should be able to change the current password:<div class="informalexample"><pre class="programlisting">  it('should change the password of a user', function(done) {
    _user.changePassword('user_password', 'new_user_password', function(err, result) {
      if (err) throw err;

      should.exist(result);
      result.success.should.equal(true);
      result.message.should.equal('Password changed successfully.');
      result.type.should.equal('password_change_success');

      // run a check credential with the new password
      User.authenticate(_user.email, 'new_user_password', function(err, user) {
        if (err) throw err;

        should.exist(user);
        user.email.should.equal(_user.email);
        done();
      });
    });
  });</pre></div></li><li class="listitem" value="6">An old <a id="id124" class="calibre1"/>password challenge must be passed in order to set a new password:<div class="informalexample"><pre class="programlisting">  it('should not change password if old password does not match', function(done) {
    _user.changePassword('not_good', 'new_user_password', function(err, result) {
      should.not.exist(result);
      should.exist(err);
      err.type.should.equal('old_password_does_not_match');

      // run a check credential with the old password
      User.authenticate(_user.email, 'new_user_password', function(err, user) {
        if (err) throw err;

        should.exist(user);
        user.email.should.equal(_user.email);
        done();
      });
    });
  });</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">With the <a id="id125" class="calibre1"/>preceding test suit, we have described and will test the functionality of our implemented methods.</p></div></div>

<div class="book" title="Setting up the user section">
<div class="book" title="Implementing the user model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec35" class="calibre1"/>Implementing the user model</h2></div></div></div><p class="calibre8">The <code class="email">user</code> <a id="id126" class="calibre1"/>model is going to use the same password helper principle as in <a class="calibre1" title="Chapter 1. Contact Manager" href="part0016_split_000.html#F8902-5c78d361d97340239270192b72d53e7b">Chapter 1</a>, <span class="strong"><em class="calibre11">Contact Manager</em></span>. Let's create a file called <code class="email">app/helpers/password.js</code>. The file should contain the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const LEN = 256;
const SALT_LEN = 64;
const ITERATIONS = 10000;
const DIGEST = 'sha256';
const crypto = require('crypto');

module.exports.hash = hashPassword;
module.exports.verify = verify;</pre></div><p class="calibre8">Now add the <code class="email">hashPassword()</code> function:</p><div class="informalexample"><pre class="programlisting">function hashPassword(password, salt, callback) {
  let len = LEN / 2;

  if (3 === arguments.length) {
    generateDerivedKey(password, salt, ITERATIONS, len, DIGEST, callback);
  } else {
    callback = salt;
    crypto.randomBytes(SALT_LEN / 2, (err, salt) =&gt; {
      if (err) {
        return callback(err);
      }

      salt = salt.toString('hex');
      generateDerivedKey(password, salt, ITERATIONS, len, DIGEST, callback);
    });
  }
}</pre></div><p class="calibre8">We have added an extra function, called <code class="email">generateDerivedKey()</code>, in order not to repeat code blocks:</p><div class="informalexample"><pre class="programlisting">function generateDerivedKey(password, salt, iterations, len, digest, callback) {
  crypto.pbkdf2(password, salt, ITERATIONS, len, DIGEST, (err, derivedKey) =&gt; {
    if (err) {
      return callback(err);
    }

    return callback(null, derivedKey.toString('hex'), salt);
  });
}</pre></div><p class="calibre8">Finally, add <a id="id127" class="calibre1"/>the <code class="email">verify()</code> function:</p><div class="informalexample"><pre class="programlisting">function verify(password, hash, salt, callback) {
  hashPassword(password, salt, (err, hashedPassword) =&gt; {
    if (err) {
      return callback(err);
    }

    if (hashedPassword === hash) {
      callback(null, true);
    } else {
      callback(null, false);
    }
  });
}</pre></div><p class="calibre8">Next, let's create a user schema in the model file. Create a new file, called <code class="email">app/models/user.js</code>, and add the following:</p><div class="informalexample"><pre class="programlisting">'use strict';

const _ = require('lodash');
const mongoose = require('mongoose');
const passwordHelper = require('../helpers/password');
const Schema = mongoose.Schema;

const UserSchema = new Schema({
  email:  {
    type: String,
    required: true,
    unique: true
  },
  name: {
    type: String
  },
  password: {
    type: String,
    required: true,
    select: false
  },
  passwordSalt: {
    type: String,
    required: true,
    select: false
  },
  phoneNumber: {
    type: String
  },
  active: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

UserSchema.statics.register = registerUser;
UserSchema.statics.authenticate = authenticateUser;
UserSchema.methods.changePassword = changeUserPassword;</pre></div><p class="calibre8">Now, one by <a id="id128" class="calibre1"/>one, let's add the required methods from the test. We will start with the <code class="email">register()</code> method. Append these lines of code to the user model file:</p><div class="informalexample"><pre class="programlisting">function registerUser(opts, callback) {
  let data = _.cloneDeep(opts);

  //hash the password
  passwordHelper.hash(opts.password, (err, hashedPassword, salt) =&gt; {
    if (err) {
      return callback(err);
    }

    data.password = hashedPassword;
    data.passwordSalt = salt;

    //create the user
    this.model('User').create(data, (err, user) =&gt; {
      if (err) {
        return callback(err, null);
      }

      // remove password and salt from the result
      user.password = undefined;
      user.passwordSalt = undefined;
      // return user if everything is ok
      callback(err, user);
    });
  });
}</pre></div><p class="calibre8">This is a simple function that will save a user in MongoDB. Before saving the user, we want to build a <a id="id129" class="calibre1"/>hash from the given password and save that hash with a salt in the database, instead of a plain password string. Mongoose will also validate the user data before saving it, based on the User schema.</p><p class="calibre8">For the <code class="email">authenticate()</code> method, we will append the following lines of code:</p><div class="informalexample"><pre class="programlisting">function authenticateUser(email, password, callback) {
  this
  .findOne({ email: email })
  .select('+password +passwordSalt')
  .exec((err, user) =&gt; {
    if (err) {
      return callback(err, null);
    }

    // no user found just return the empty user
    if (!user) {
      return callback(err, user);
    }

    // verify the password with the existing hash from the user
    passwordHelper.verify(
      password,
      user.password,
      user.passwordSalt,
      (err, result) =&gt; {
        if (err) {
          return callback(err, null);
        }

        // if password does not match don't return user
        if (result === false) {
          return callback(err, null);
        }

        // remove password and salt from the result
        user.password = undefined;
        user.passwordSalt = undefined;
        // return user if everything is ok
        callback(err, user);
      }
    );
  });
}</pre></div><p class="calibre8">The authentication method will find a user by e-mail. The <code class="email">password</code> and <code class="email">passwordSalt</code> fields are explicitly set to be read from the database only for this query. A password verification function will be called to match the existing password hash with the password sent to the authentication method.</p><p class="calibre8">Finally we will <a id="id130" class="calibre1"/>add a <code class="email">changePassword()</code> method. This method will be available on user instances only. Mongoose gives us the ability to use the <code class="email">methods</code> property on a schema to attach new functions. Append the following code:</p><div class="informalexample"><pre class="programlisting">function changeUserPassword(oldPassword, newPassword, callback) {
  this
  .model('User')
  .findById(this.id)
  .select('+password +passwordSalt')
  .exec((err, user) =&gt; {
    if (err) {
      return callback(err, null);
    }

    // no user found just return the empty user
    if (!user) {
      return callback(err, user);
    }

    passwordHelper.verify(
      oldPassword,
      user.password,
      user.passwordSalt,
      (err, result) =&gt; {
        if (err) {
          return callback(err, null);
        }

        // if password does not match don't return user
        if (result === false) {
          let PassNoMatchError = new Error('Old password does not match.');
          PassNoMatchError.type = 'old_password_does_not_match';
          return callback(PassNoMatchError, null);
        }

        // generate the new password and save the user
        passwordHelper.hash(newPassword, (err, hashedPassword, salt) =&gt; {
          this.password = hashedPassword;
          this.passwordSalt = salt;

          this.save((err, saved) =&gt; {
            if (err) {
              return callback(err, null);
            }

            if (callback) {
              return callback(null, {
                success: true,
                message: 'Password changed successfully.',
                type: 'password_change_success'
              });
            }
          });
        });
      }
    );
  });
}</pre></div><p class="calibre8">The change <a id="id131" class="calibre1"/>password functionality is built using three small steps. The first step is to get the user's password and salt from the database. The returned data is used to verify the existing password hash and salt with the old password entered by the user. If everything goes well, the new password is hashed using a generated salt and the user instance is saved into MongoDB.</p><p class="calibre8">Don't forget to move the following line of code to the end of the file, in order to compile the user model:</p><div class="informalexample"><pre class="programlisting">module.exports = mongoose.model('User', UserSchema);</pre></div><p class="calibre8">Suppose we run our user model test with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mocha tests/integration/user.mode.test.js</strong></span>
</pre></div><p class="calibre8">We should <a id="id132" class="calibre1"/>see all of our tests passing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">  User Model Integration</strong></span>
<span class="strong"><strong class="calibre2">    #register()</strong></span>
<span class="strong"><strong class="calibre2">      √ should create a new user (124ms)</strong></span>
<span class="strong"><strong class="calibre2">      √ should not create a new user if email already exists (100ms)</strong></span>
<span class="strong"><strong class="calibre2">    #authenticate()</strong></span>
<span class="strong"><strong class="calibre2">      √ should return the user if the credentials are valid (63ms)</strong></span>
<span class="strong"><strong class="calibre2">      √ should return nothing if the credential of the user are invalid (62ms)</strong></span>
<span class="strong"><strong class="calibre2">    #changePassword()</strong></span>
<span class="strong"><strong class="calibre2">      √ should change the password of a user (223ms)</strong></span>
<span class="strong"><strong class="calibre2">      √ should not change password if old password does not match (146ms)</strong></span>


<span class="strong"><strong class="calibre2">  6 passing (1s)</strong></span>
</pre></div></div></div>

<div class="book" title="Authenticating users"><div class="book" id="OPEK2-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Authenticating users</h1></div></div></div><p class="calibre8">In the previous <a id="id133" class="calibre1"/>chapter, we used session-based authentication. For this chapter, we are going to explore a different solution—using access tokens to authenticate our users.</p><p class="calibre8">Access tokens are <a id="id134" class="calibre1"/>widely used for RESTful APIs. Because we are building our application with the premise that it could be used not only by our Angular app but also by many other client applications, we need to rely on something that can be used to identify users with something that they have.</p><p class="calibre8">An access token is a string that identifies a user, or even an app, and it can be used to make API calls to our system. Tokens can be issued via a number of methods. For example, tokens can be issued easily using OAuth 2.0. </p><p class="calibre8">For this chapter, we are going to build a custom module that is responsible for creating tokens. This will give us the ability to easily switch to any other available solution.</p><p class="calibre8">We are going to implement two strategies to authenticate our users. One of them will be an HTTP Basic authentication strategy, which will use a simple username (e-mail in our case) and password combo to authenticate a user and generate a token that will be used for further API calls. The second strategy is an HTTP Bearer authentication, which will use the access token issued by the Basic authentication to grant the user access to resources.</p></div>

<div class="book" title="Authenticating users">
<div class="book" title="Describing the authentication strategies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec36" class="calibre1"/>Describing the authentication strategies</h2></div></div></div><p class="calibre8">Before <a id="id135" class="calibre1"/>implementing any code, we should create a test that will describe the desired behavior regarding user authentication. Create a file called <code class="email">tests/integration/authentication.test.js</code> and describe the main test cases:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The first test case should consider a positive scenario, that is, when a user tries to authenticate with valid credentials. This would look like the following:<div class="informalexample"><pre class="programlisting">    it('should authenticate a user and return a new token', function(done) {
      request({
        method: 'POST',
        url: baseUrl + '/auth/basic',
        auth: {
          username: userFixture.email,
          password: 'P@ssw0rd!'
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(200);
        body.email.should.equal(userFixture.email);
        should.not.exist(body.password);
        should.not.exist(body.passwordSalt);
        should.exist(body.token);
        should.exist(body.token.hash);
        should.exist(body.token.expiresAt);
        done();
      });
    });</pre></div></li><li class="listitem" value="2">If a user tries to authenticate with invalid credentials, the system should return a bad request message:<div class="informalexample"><pre class="programlisting">    it('should not authenticate a user with invalid credentials', function(done) {
      request({
        method: 'POST',
        url: baseUrl + '/auth/basic',
        auth: {
          username: userFixture.email,
          password: 'incorrectpassword'
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(400);
        body.message.should.equal('Invalid email or password.');
        done();
      });
    });</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">We described the basic strategy. We considered the fact that a user must send an e-mail as username <a id="id136" class="calibre1"/>and password via a POST call to the <code class="email">/api/auth</code> endpoint and get back the user details and a valid token.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">The <code class="email">request</code> library has a special property called <code class="email">auth</code> that will encode the username-and-password tuple using base64 and set the appropriate headers for HTTP Basic authentication.</p></div><p class="calibre8">As you can see, our presumption is that a valid token will be generated when a user successfully authenticates into our system. For this reason, we are going to implement the token generation functionality before continuing further.</p></div></div>

<div class="book" title="Authenticating users">
<div class="book" title="Implementing the token generation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec37" class="calibre1"/>Implementing the token generation</h2></div></div></div><p class="calibre8">Tokens can be <a id="id137" class="calibre1"/>generated in many ways. For this chapter, we are going to use the built-in crypto library from Node.js. We can use the <code class="email">randomBytes()</code> method to generate a random string of a given length. One thing to note is that <code class="email">randomBytes()</code> will throw an error if there is not enough accumulated entropy. This means that if there is not enough information in the entropy source to generate a random number, it will throw an error.</p><p class="calibre8">Let's create a new file called <code class="email">app/helpers/token.js</code> and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const LEN = 16;
const crypto = require('crypto');

module.exports.generate = generateToken;

function generateToken(size, callback) {
  if (typeof size === 'function') {
    callback = size;
    size = LEN;
  }

  // we will return the token in `hex`
  size = size / 2;

  crypto.randomBytes(size, (err, buf) =&gt; {
    if (err) {
      return callback(err);
    }

    const token = buf.toString('hex');

    callback(null, token);
  });
} </pre></div><p class="calibre8">We created a <a id="id138" class="calibre1"/>helper function that will generate a random token for us. The function takes two arguments: the number of random bytes, which is optional, and a callback function.</p></div></div>

<div class="book" title="Authenticating users">
<div class="book" title="Persisting tokens in MongoDB"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec38" class="calibre1"/>Persisting tokens in MongoDB</h2></div></div></div><p class="calibre8">In order to <a id="id139" class="calibre1"/>check an access token sent by the user—that is, whether it's valid or not—we should store it somewhere. For this, we are going to use MongoDB as our storage engine for the tokens.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">Note that you should treat your tokens with the same responsibility as user passwords, because tokens will give access to the system's functionality. One option to consider for further security improvements is to store tokens encrypted in the database or even store them in a separate token storage.</p></div><p class="calibre8">Before anything, let's create a test for the token model. Create a file called <code class="email">tests/integration/token.model.js</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">process.env.NODE_ENV = 'test';

const chai = require('chai');
const should = chai.should();
const mongoose = require('../../config/mongoose').init();
const Token = require('../../app/models/token');

describe('Token Model Integration', function() {
  after(function(done) {
    mongoose.connection.db.dropDatabase(function(err) {
      if (err) throw err;

      setTimeout(done, 200);
    });
  });

  describe('#generate() - Token class method', function() {
    var _userId = new mongoose.Types.ObjectId();

    it('should generate a new token for a user', function(done) {
      Token.generate({
        user: _userId
      }, function(err, token) {
        if (err) throw err;

        should.exist(token);
        should.exist(token.id);
        token.hash.length.should.equal(32);
        token.user.toString().should.equal(_userId.toString());
        done();
      });
    });
  });

});</pre></div><p class="calibre8">We are going to add a <code class="email">generate()</code> method to the <code class="email">Token</code> model, which will return a cryptographically strong token.</p><p class="calibre8">Create a file <a id="id140" class="calibre1"/>called <code class="email">app/models/token.js</code>. It will hold the <code class="email">Token</code> Mongoose schema and the preceding method:</p><div class="informalexample"><pre class="programlisting">'use strict';

const EXPIRATION = 30; // in days
const LEN = 32;

const mongoose = require('mongoose');
const tokenHelper = require('../helpers/token');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

const TokenSchema = new Schema({
  user: {
    type: ObjectId,
    ref: 'User',
    required: true
  },
  hash: {
    type: String,
  },
  expiresAt: {
    type: Date,
    default: function() {
      var now = new Date();
      now.setDate(now.getDate() + EXPIRATION);

      return now;
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});


TokenSchema.statics.generate = generateToken

function generateToken(opts, callback) {
  tokenHelper.generate(opts.tokenLength || LEN, (err, tokenString) =&gt; {
    if (err) {
      return callback(err);
    }

    opts.hash = tokenString;

    this.model('Token').create(opts, callback);
  });
};

// compile Token model
module.exports = mongoose.model('Token', TokenSchema); </pre></div><p class="calibre8">As you can see, we added an expiration date for our tokens. This could be used to automatically <a id="id141" class="calibre1"/>invalidate tokens after a given time. Usually, in an application, you don't want to have tokens without an expiration date. If there is a need for such tokens, another layer of authorization <a id="id142" class="calibre1"/>through API keys should be added to authorize the usage of the system for third-party clients.</p></div></div>

<div class="book" title="Authenticating users">
<div class="book" title="Authentication using HTTP Basic"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec39" class="calibre1"/>Authentication using HTTP Basic</h2></div></div></div><p class="calibre8">Before <a id="id143" class="calibre1"/>generating a token, we need to authenticate our users. One simple solution could be to use a simple username-and-password authentication and generate a token if the entered information is valid. </p><p class="calibre8">We can expose a route that will handle HTTP Basic authentication. This is the simplest technique for enforcing access control for a resource. In our case, the resource will be a token and it does not require cookies or identifying sessions. HTTP Basic authentication uses standard fields in the HTTP request header.</p><p class="calibre8">This method does not add any encryption or hashing in any way; just a simple base64 encoding is needed. For this reason, it is typically used over HTTPS. If the client wants to send the server the necessary credentials for authentication, it can use the <code class="email">Authorization</code> header field.</p><p class="calibre8">We are going to use the <code class="email">passport-http</code> module for the Basic authentication strategy. Let's create a file called <code class="email">app/config/strategies/basic.js</code> and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const passport = require('passport');
const BasicStrategy = require('passport-http').BasicStrategy;
const mongoose = require('mongoose');
const User = mongoose.model('User');

module.exports.init = initBasicStrategy;

function initBasicStrategy() {
  passport.use('basic', new BasicStrategy((username, password, done) =&gt; {
    User.authenticate(username, password, (err, user) =&gt; {
      if (err) {
        return done(err);
      }

      if (!user) {
        return done(null, false);
      }

      return done(null, user);
    });
  }));
} </pre></div><p class="calibre8">The strategy uses the <code class="email">authenticate()</code> method to check whether the credentials are valid. As you can see, we are not adding any extra logic here.</p><p class="calibre8">Next, we <a id="id144" class="calibre1"/>are going to create a controller that will handle the basic authentication. Create a file called <code class="email">app/controllers/authentication.js</code> and add the following content:</p><div class="informalexample"><pre class="programlisting">'use strict';

const _ = require('lodash');
const passport = require('passport');
const mongoose = require('mongoose');
const Token = mongoose.model('Token');

module.exports.basic = basicAuthentication;

function basicAuthentication(req, res, next) {
  passport.authenticate('basic', (err, user, info) =&gt; {
    if (err || !user) {
      return res.status(400).send({ message: 'Invalid email or password.' });
    }

    Token.generate({
      user: user.id
    }, (err, token) =&gt; {
      if (err || !token) {
        return res.status(400).send({ message: 'Invalid email or password.' });
      }

      var result = user.toJSON();
      result.token = _.pick(token, ['hash', 'expiresAt']);

      res.json(result);
    });

  })(req, res, next);
} </pre></div><p class="calibre8">Passport has an <code class="email">authenticate()</code> method that enables us to call a given strategy. We are using a custom callback in order to generate and persist a token in MongoDB. When returning <a id="id145" class="calibre1"/>the token to the client, we only need a few things from the stored data, such as the value and expiration date.</p></div></div>

<div class="book" title="Authenticating users">
<div class="book" title="Adding authentication routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec40" class="calibre1"/>Adding authentication routes</h2></div></div></div><p class="calibre8">Create a file <a id="id146" class="calibre1"/>called <code class="email">app/routes/authentication.js</code> and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const authCtrl = require('../controllers/authentication');

router.post('/basic, authCtrl.basic);

module.exports = router;</pre></div><p class="calibre8">The <code class="email">auth</code> route will allow users to make a post call and authenticate using the basic strategy. In order to create reusable routes, we do not mount the routes directly to the Express app instance. Instead, we use the <code class="email">Router</code> class to instantiate a new router.</p><p class="calibre8">In order to be able to configure what routes we are mounting on our Express application, we can create a file called <code class="email">config/routes.js</code> with the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports.init = function(app) {
  var routesPath = app.get('root') + '/app/routes';

  app.use('/auth, require(routesPath + '/auth));
};</pre></div><p class="calibre8">The preceding lines of code should be straightforward. We are defining the routes' base path and mounting them onto our application. One thing to note is that we are adding a prefix to the authentication routes.</p><p class="calibre8">Add the following highlighted code to the main <code class="email">server.js</code> file in order to initialize the routes configuration file:</p><div class="informalexample"><pre class="programlisting">require('./config/express').init(app);
<span class="strong"><strong class="calibre2">require('./config/routes').init(app);</strong></span>
</pre></div><p class="calibre8">Run our authentication test with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mocha tests/integration/authentication.test.js</strong></span>
</pre></div><p class="calibre8">This should have a similarly positive output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">  Authentication</strong></span>
<span class="strong"><strong class="calibre2">    Basic authentication</strong></span>
<span class="strong"><strong class="calibre2">      √ should authenticate a user and return a new token</strong></span>
<span class="strong"><strong class="calibre2">      √ should not authenticate a user with invalid credentials</strong></span>
<span class="strong"><strong class="calibre2">  2 passing</strong></span>
</pre></div></div></div>

<div class="book" title="Authenticating users">
<div class="book" title="Verifying users using bearer authentication"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec41" class="calibre1"/>Verifying users using bearer authentication</h2></div></div></div><p class="calibre8">For each <a id="id147" class="calibre1"/>request, tokens should be used to determine whether the requester has access to the system or not. We only used the basic strategy to issue a token if the user sent valid credentials. Passport has a <code class="email">passport-http-bearer</code> module. Normally this is used to protect API endpoints, as in our case. The tokens are often issued using OAuth 2.0, but, in our case, we built a custom solution to issue tokens.</p><p class="calibre8">Also in our case, a token is a string representing an access authorization key issued to the client by the system. The client application, the Angular app, will use the access token to retrieve protected resources from the RESTful API.</p><p class="calibre8">Let's describe a simple use case to retrieve information using an access token. Append the following lines of code to <code class="email">tests/integration/authentication.test.js</code>, after the basic authentication test suite:</p><div class="informalexample"><pre class="programlisting">  describe('Bearer authentication', function() {
    var _token;

    before(function() {
      Token.generate({
        user: _user.id
      }, function(err, token) {
        if (err) throw err;

        _token = token;
        done();
      });
    });

    it('should authenticate a user using an access token', function(done) {
      request({
        method: 'GET',
        url: baseUrl + '/auth/info',
        auth: {
          bearer: _token.value
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(200);
        body.email.should.equal(userFixture.email);
        should.not.exist(body.password);
        should.not.exist(body.passwordSalt);
        done();
      });
    });

    it('should not authenticate a user with an invalid access token', function(done) {
      request({
        method: 'GET',
        url: baseUrl + '/auth/info',
        auth: {
          bearer: _token.value + 'a1e'
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(401);
        body.should.equal('Unauthorized');
        done();
      });
    });
  });</pre></div><p class="calibre8">We assume <a id="id148" class="calibre1"/>the existence of an <code class="email">/auth/info</code> route on which, if a GET call is made, it will return the token's owner credential. If the token is invalid, an unauthorized message is sent back, with the appropriate 401 HTTP status code.</p><div class="book" title="Bearer strategy"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec17" class="calibre1"/>Bearer strategy</h3></div></div></div><p class="calibre8">Let's create a <a id="id149" class="calibre1"/>file called <code class="email">config/strategies/bearer.js</code>. Add the following piece of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const passport = require('passport');
const BearerStrategy = require('passport-http-bearer').Strategy;
const mongoose = require('mongoose');
const Token = mongoose.model('Token');

module.exports.init = initBearerStrategy;

function initBearerStrategy() {
  passport.use('bearer', new BearerStrategy((token, done) =&gt; {
    Token
    .findOne({ hash: token })
    .populate('user')
    .exec((err, result) =&gt; {
      if (err) {
        return done(err);
      }

      if (!result) {
        return done(null, false, { message: 'Unauthorized.' });
      }

      if (!result.user) {
        return done(null, false, { message: 'Unauthorized.' });
      }

      done(null, result.user);
    });
  }));
} </pre></div><p class="calibre8">The preceding code searches in the database for the given token. In order to retrieve the token owner, we <a id="id150" class="calibre1"/>can use the <code class="email">populate()</code> method from Mongoose in combination with a normal query method, such as <code class="email">findOne()</code>. This can be done because we explicitly added a reference to the User model in the Token model.</p></div><div class="book" title="Protecting resources using tokens"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec18" class="calibre1"/>Protecting resources using tokens</h3></div></div></div><p class="calibre8">In order to <a id="id151" class="calibre1"/>protect our resources, we need to add a layer that checks the presence of the access token. We did the first part of the Bearer strategy. Now we only need to use it; for this, we can create middleware that will validate the token.</p><p class="calibre8">Create a new file called <code class="email">app/middlewares/authentication.js</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const passport = require('passport');

module.exports.bearer = function bearerAuthentication(req, res, next) {
  return passport.authenticate('bearer', { session: false });
};</pre></div><p class="calibre8">The preceding code is fairly simple. We just use passport's built-in <code class="email">authenticate()</code> method to call the bearer strategy. We don't want to save any session on the server. This piece of middleware can be used on each route in combination with any other application logic.</p><p class="calibre8">Append the <a id="id152" class="calibre1"/>following lines of code to <code class="email">app/controllers/authentication.js</code>. It will only check whether the user is present on the request object and return a JSON with the data:</p><div class="informalexample"><pre class="programlisting">module.exports.getAuthUser = getAuthUser;

function getAuthUser(req, res, next) {
  if (!req.user) {
    res.status(401).json({ message: 'Unauthorized.' });
  }

  res.json(req.user);
} </pre></div><p class="calibre8">Now let's get back to our authentication route, <code class="email">app/routes/authentication.js</code>, and add the following highlighted lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

var express = require('express');
var router = express.Router();
var authCtrl = require('../controllers/authentication');
<span class="strong"><strong class="calibre2">var auth = require('../middlewares/authentication');</strong></span>

router.post('/basic', authCtrl.basic);
<span class="strong"><strong class="calibre2">router.get('/info', auth.bearer(), authCtrl.getAuthUser);</strong></span>

module.exports = router;</pre></div><p class="calibre8">We added the authentication middleware before the execution of the logic from the controller in order to validate and retrieve the token's owner. Our bearer strategy will handle this and set the user on the request object; more precisely, it can be found on <code class="email">req.user</code>.</p><p class="calibre8">If we run our authentication test:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mocha tests/integration/authentication.test.js</strong></span>
</pre></div><p class="calibre8">The following output should be printed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">  Authentication</strong></span>
<span class="strong"><strong class="calibre2">    Basic authentication</strong></span>
<span class="strong"><strong class="calibre2">      √ should authenticate a user and return a new token</strong></span>
<span class="strong"><strong class="calibre2">      √ should not authenticate a user with invalid credentials </strong></span>
<span class="strong"><strong class="calibre2">    Bearer authentication</strong></span>
<span class="strong"><strong class="calibre2">      √ should authenticate a user using an access token</strong></span>
<span class="strong"><strong class="calibre2">      √ should not authenticate a user with an invalid access token</strong></span>


<span class="strong"><strong class="calibre2">  4 passing</strong></span>
</pre></div><p class="calibre8">With this, we've <a id="id153" class="calibre1"/>finally added all the necessary authentication methods to grant users access to our system.</p></div></div></div>

<div class="book" title="Tracking expenses"><div class="book" id="PNV62-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Tracking expenses</h1></div></div></div><p class="calibre8">The main feature <a id="id154" class="calibre1"/>of our application is to track the user's expenses. A user should be able to insert expenses, be persisted in the system, and see the exact balance for his/her account.</p><p class="calibre8">There should always <a id="id155" class="calibre1"/>be a clear view of what is desired to be achieved. Let's take a high-level view of what we want to achieve:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A user should be able to persist an expense in the system</li><li class="listitem">A user should be able to get all their expenses</li><li class="listitem">A user should be able to get the balance of their expenses</li><li class="listitem">A user should be able to define a category in which to save expenses, for example, groceries</li></ul></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="Monetary values"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec42" class="calibre1"/>Monetary values</h2></div></div></div><p class="calibre8">In our case, an <a id="id156" class="calibre1"/>expense will store the exact value of money spent. In some cases, working with monetary data can get tricky. Often, applications that handle monetary data are required to work with fractional units of the currency. </p><p class="calibre8">We could store data in floating-point numbers. However, in JavaScript, floating-point arithmetic often does not conform to monetary arithmetic. In other words, values like one-third and one-tenth do not have an exact representation in binary floating-point numbers.</p><p class="calibre8">MongoDB, for example, stores numeric data as either IEEE 754 standard 64-bit floating-point numbers, 32-bit, or 64-bit signed integers. JavaScript treats numbers according to specs as double-precision 64-bit format IEEE 754 values. Because of this, we need to pay attention to such operations:</p><div class="informalexample"><pre class="programlisting">+ 0.2 = 0.30000000000000004</pre></div><p class="calibre8">We won't be able to <a id="id157" class="calibre1"/>store values such as 9.99 USD, representing cents in decimal. Don't get me wrong; we can store them, but we are not going to get correct results if we use the built-in MongoDB aggregation framework or do server-side arithmetic (the same thing applies for the client side too in JavaScript).</p><p class="calibre8">Do not worry; there are a few solutions that we can use. There are two common approaches to storing monetary values in MongoDB:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Exact precision is an approach that is used to multiply the monetary value by a power of 10.</li><li class="listitem">Arbitrary precision, on the other hand, uses two fields to represent the monetary value. One field stores the exact value as a non-numeric format, such as a string, and another field stores the floating-point approximation of the value.</li></ul></div><p class="calibre8">For our implementation, we are going to use the exact precision model. We will discuss all the details as we progress with the code.</p></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="The category model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec43" class="calibre1"/>The category model</h2></div></div></div><p class="calibre8">As we discussed <a id="id158" class="calibre1"/>earlier, we want to be able to add an expense to a specific category. A user should also be able to invite another user to add expenses to a category. We are not going to detail the test cases for this feature, but you should consider writing tests to make sure that everything works as expected.</p><p class="calibre8">Let's create a file called <code class="email">app/models/category.js</code> and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

const CategorySchema = new Schema({
  name: {
    type: String,
    required: true
  },
  description: {
    type: String
  },
  owner: {
    type: ObjectId,
    ref: 'User',
    required: true
  },
  collaborators: {
    type: [
      {
        type: ObjectId,
        ref: 'User'
      }
    ]
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// compile Category model
module.exports = mongoose.model('Category', CategorySchema);</pre></div><p class="calibre8">Two important things to note here: we define the owner of the category, which will always be the authenticated user that creates the category, and the collaborators field, which holds users that can insert expenses into the category.</p><p class="calibre8">Also, don't forget to <a id="id159" class="calibre1"/>change the model configuration file, <code class="email">config/models.js</code>, by adding the following highlighted code:</p><div class="informalexample"><pre class="programlisting">['user', 'token', '<span class="strong"><strong class="calibre2">category</strong></span>', 'expense'].forEach(function(model) {
    require(modelsPath + model);
});</pre></div></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="Categories routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec44" class="calibre1"/>Categories routes</h2></div></div></div><p class="calibre8">To expose a simple <a id="id160" class="calibre1"/>CRUD on the category collection, we have to define routes for those actions. For this, we are going to create a router file, called <code class="email">app/routes/categories.js</code>, and add these lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const categoryCtrl = require('../controllers/category');
const auth = require('../middlewares/authentication');

router.param('categoryId', expenseCtrl.findById);

router.get('/categories', auth.bearer(), categoryCtrl.getAll);
router.get('/categories/:categoryId', auth.bearer(), categoryCtrl.getOne);
router.post('/categories', auth.bearer(), categoryCtrl.create);
router.put('/categories/:categoryId', auth.bearer(), categoryCtrl.update);
router.delete('/categories/:categoryId', auth.bearer(), categoryCtrl.delete);

module.exports = router;</pre></div><p class="calibre8">Keep in mind <a id="id161" class="calibre1"/>that we actually have no implementation of the category controller at the moment. Let's create a category controller with the following name: <code class="email">app/controllers/category.js</code>.</p><div class="book" title="Getting the category by ID"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec19" class="calibre1"/>Getting the category by ID</h3></div></div></div><p class="calibre8">Add the <a id="id162" class="calibre1"/>following lines of code to <code class="email">app/controllers/category.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const _ = require('lodash');
const mongoose = require('mongoose');
const Category = mongoose.model('Category');
const ObjectId = mongoose.Types.ObjectId;

module.exports.findById = findCategoryById;
module.exports.create = createCategory;
module.exports.getOne = getOneCategory;
module.exports.getAll = getAllCategories;
module.exports.update = updateCategory;
module.exports.delete = deleteCategory;

function findCategoryById(req, res, next, id) {
  if (!ObjectId.isValid(id)) {
    return res.status(404).json({ message: 'Not found.'});
  }

  Category.findById(id, (err, category) =&gt; {
    if (err) {
      return next(err);
    }

    if (!category) {
      return res.status(404).json({ message: 'Not found.'});
    }

    req.category = category;
    next();
  });
} </pre></div><p class="calibre8">The preceding <a id="id163" class="calibre1"/>code will come in handy when the <code class="email">categoryId</code> route <code class="email">param</code> is present. It will automatically get a category, as we defined it in the route file.</p></div><div class="book" title="Creating a category"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec20" class="calibre1"/>Creating a category</h3></div></div></div><p class="calibre8">To create a <a id="id164" class="calibre1"/>category, append the following lines of code to the controller file:</p><div class="informalexample"><pre class="programlisting">function createCategory(req, res, next) {
  const data = req.body;
  data.owner = req.user.id;

  Category.create(data, (err, category) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(201).json(category);
  });
} </pre></div><p class="calibre8">Before creating a category, we add the owner's ID, which is the current user's ID.</p></div><div class="book" title="Getting one and all categories"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec21" class="calibre1"/>Getting one and all categories</h3></div></div></div><p class="calibre8">We also <a id="id165" class="calibre1"/>want to get a single category and all categories. To get one category, we are going to use the results from getting a category by ID. To retrieve multiple categories, we are going to use the <code class="email">find()</code> query method from Mongoose. We could easily add pagination or set limits, but we are going to presume that a user will not have so many categories. This could be a small improvement for our application later on.</p><p class="calibre8">Append the following lines of code to the controller:</p><div class="informalexample"><pre class="programlisting">function getOneCategory(req, res, next) {
  res.json(req.category);
}

function getAllCategories(req, res, next) {
  Category.find((err, categories) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(categories);
  });
} </pre></div></div><div class="book" title="Updating and deleting a category"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec22" class="calibre1"/>Updating and deleting a category</h3></div></div></div><p class="calibre8">When we get <a id="id166" class="calibre1"/>a category by ID, we set the <a id="id167" class="calibre1"/>returned instance from Mongoose to the request object. Due to this, we can use that instance to change its properties and save it back to Mongo. Append this code:</p><div class="informalexample"><pre class="programlisting">function updateCategory(req, res, next) {
  const category = req.category;
  const data = _.pick(req.body, ['description', 'name']);
  _.assign(category, data);

  category.save((err, updatedCategory) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(updatedCategory);
  });
}</pre></div><p class="calibre8">The same thing can be used when deleting a category; also append the following lines of code:</p><div class="informalexample"><pre class="programlisting">function deleteCategory(req, res, next) {
  req.category.remove((err) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(204).json();
  });
} </pre></div><p class="calibre8">With the preceding lines of code, we have finished CRUD operations on categories.</p></div></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="Defining the expense model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec45" class="calibre1"/>Defining the expense model</h2></div></div></div><p class="calibre8">Earlier, we <a id="id168" class="calibre1"/>discussed the fact that we cannot simply store monetary data as floating-point numbers in the database or use it for server-side arithmetic. The accepted solution for our scenario was to use exact precision to store monetary data. In other words, money values will be stored by multiplying the initial value with a number that is a power of 10.</p><p class="calibre8">We are going to assume that the required maximum precision will be a tenth of a cent. Going with this assumption, we will multiply the initial value by 1000. For example, if we have an initial value of 9.99 USD, the stored value in the database will be 9990.</p><p class="calibre8">For the current implementation of the application, we are going to use USD as our currency for monetary values. The scale factor will be 1000 to preserve precision up to one-tenth of a cent. Using the exact precision model, the scale factor needs to be consistent for the currency across the application and anytime given it should be determined from the currency.</p><p class="calibre8">Let's create our expense model, <code class="email">app/models/expense.js</code>, and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const CURRENCY = 'USD';
const SCALE_FACTOR = 1000;

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

const ExpenseSchema = new Schema({
  name: {
    type: String
  },
  amount: {
    type: Number,
    default: 0
  },
  currency: {
    type: String,
    default: CURRENCY
  },
  scaleFactor: {
    type: Number,
    default: SCALE_FACTOR
  },
  user: {
    type: ObjectId,
    ref: 'User',
    required: true
  },
  category: {
    type: ObjectId,
    ref: 'Category',
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
}, {
  toObject: {
    virtuals: true
  },
  toJSON: {
    virtuals: true
  }
});

module.exports = mongoose.model('Expense', ExpenseSchema); </pre></div><p class="calibre8">The following <a id="id169" class="calibre1"/>table will give a short description of the fields in the schema:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Field</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">name</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Name of the expense</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">amount</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The scaled amount of money</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">currency</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">What currency is used to represent the money</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">scaleFactor</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The scale factor used to obtain the amount</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">user</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">To whom the expense belongs</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">category</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">A category group that the expense belongs to</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">createdAt</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The date when the expense object was created</p>
</td></tr></tbody></table></div><p class="calibre8">Mongoose has an interesting feature, called <code class="email">virtual attributes</code>. Such attributes are not persisted in the database but are really helpful in many scenarios. We are going to use a virtual <a id="id170" class="calibre1"/>attribute called <code class="email">value</code>, which is going to represent the monetary value of the <code class="email">amount</code> attribute.</p><p class="calibre8">Append the following lines of code before the model compilation:</p><div class="informalexample"><pre class="programlisting">ExpenseSchema.virtual('value')
.set(function(value) {
  if (value) {
    this.set('amount', value * this.scaleFactor);
  }
})
.get(function() {
  return this.amount / this.scaleFactor;
});</pre></div><p class="calibre8">Like all attributes, virtual attributes can have <code class="email">getters</code> and <code class="email">setters</code>. We are going to piggyback the setter and add our own logic, which will scale the value with a give factor and obtain the desired amount. Also, when getting the virtual <code class="email">value</code> attribute, we are going to return the correct monetary representation, dividing the stored amount by the corresponding scale factor.</p><p class="calibre8">By default, when doing a query, Mongoose will not return <code class="email">virtual attributes</code>, but we have overwritten the default options for the schema to return all <code class="email">virtual attributes</code> when using the <code class="email">.toJSON()</code> and <code class="email">.toObject()</code> methods.</p></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="Describing the expense module functionality"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec46" class="calibre1"/>Describing the expense module functionality</h2></div></div></div><p class="calibre8">Next, we <a id="id171" class="calibre1"/>are going to write some tests for the expense module in order to define the required behavior of the module.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">In order to go faster, we are only going to define a few test cases. The rest of the CRUD test cases are the same as in earlier implementations for different modules. For reference, you can check out the full code base for the test suite at the following link: <a class="calibre1" href="https://www.packtpub.com/">https://www.packtpub.com/</a>.</p></div><p class="calibre8">Let's create a file called <code class="email">tests/integration/expense.test.js</code>. We are going to define the most important test cases:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">When creating an expense, a value and a category must be present. The value should be a number that accepts decimal values too:<div class="informalexample"><pre class="programlisting">    it('should save an expense', function(done) {
      request({
        method: 'POST',
        url: baseUrl + '/expenses',
        auth: {
          bearer: _token.value
        },
        form: {
          value: 14.99,
          category: _category.toString()
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(201);
        body.amount.should.equal(14990);
        body.scaleFactor.should.equal(1000);
        body.value.should.equal(14.99);
        body.category.should.equal(_category.toString());
        done();
      });
    });</pre></div></li><li class="listitem" value="2">We <a id="id172" class="calibre1"/>should be able to get all of the user's expenses from the database:<div class="informalexample"><pre class="programlisting">    it('should get balance for all expenses', function(done) {
      request({
        method: 'GET',
        url: baseUrl + '/expenses/balance',
        auth: {
          bearer: _token.value
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(200);
        should.exist(body);
        body.balance.should.equal(33.33);
        body.count.should.equal(3);
        done();
      });
    });</pre></div></li><li class="listitem" value="3">If necessary, we should get only the expenses for a given category. This will come in <a id="id173" class="calibre1"/>handy when we want to display expenses for a certain category:<div class="informalexample"><pre class="programlisting">    it('should get expenses balance only for a category', function(done) {
      request({
        method: 'GET',
        url: baseUrl + '/expenses/balance?category=' + _categoryOne.toString(),
        auth: {
          bearer: _token.value
        },
        json:true
      }, function(err, res, body) {
        if (err) throw err;

        res.statusCode.should.equal(200);
        should.exist(body);
        body.balance.should.equal(21.21);
        body.count.should.equal(2);
        done();
      });
    });</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">The preceding code tests the creation of an expense and that the virtual value attribute works correctly. It also checks whether an invalid token is sent and that the application will treat it accordingly. Now the fun part starts with the <code class="email">balance</code> functionality, which should return an aggregated value of the expenses for different scenarios.</p></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="CRUD operations for expenses"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec47" class="calibre1"/>CRUD operations for expenses</h2></div></div></div><p class="calibre8">Next, we are <a id="id174" class="calibre1"/>going to implement the CRUD operations for expenses one by one. Before going any further, we are going to create a new routes file called <code class="email">app/routes/expenses.js</code> and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const expenseCtrl = require('../controllers/expense');
const auth = require('../middlewares/authentication');

router.param('expenseId', expenseCtrl.findById);

router.get('/expenses', auth.bearer(), expenseCtrl.getAll);
router.get('/expenses/:expenseId', auth.bearer(), expenseCtrl.getOne);
router.post('/expenses', auth.bearer(), expenseCtrl.create);
router.put('/expenses/:expenseId', auth.bearer(), expenseCtrl.update);
router.delete('/expenses/:expenseId', auth.bearer(), expenseCtrl.delete);

module.exports = router;</pre></div><p class="calibre8">We added a bearer <a id="id175" class="calibre1"/>authentication for each route. You could have created a single route to catch all the resources that need authentication, but, in this way, you will have fine-grained control for each route.</p><div class="book" title="Create expense"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec23" class="calibre1"/>Create expense</h3></div></div></div><p class="calibre8">Let's create the <a id="id176" class="calibre1"/>controller that the routes file needs—<code class="email">app/controllers/expense.js</code>—and add the create expense logic:</p><div class="informalexample"><pre class="programlisting">'use strict';

const _ = require('lodash');
const mongoose = require('mongoose');
const Expense = mongoose.model('Expense');
const ObjectId = mongoose.Types.ObjectId;

module.exports.create = createExpense;
module.exports.findById = findExpenseById
module.exports.getOne = getOneExpense;
module.exports.getAll = getAllExpenses;
module.exports.update = updateExpense;
module.exports.delete = deleteExpense;
module.exports.getBalance = getExpensesBalance;

function createExpense(req, res, next) {
  const data = _.pick(req.body, ['name', 'value', 'category', 'createdAt']);
  data.user = req.user.id;

  if (data.createdAt === null) {
    delete data.createdAt;
  }

  Expense.create(data, (err, expense) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(201).json(expense);
  });
} </pre></div><p class="calibre8">The expense that we want to create should be for the token owner. Hence, we explicitly set the user property <a id="id177" class="calibre1"/>to the authenticated user's ID.</p></div><div class="book" title="Get expense by ID"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec24" class="calibre1"/>Get expense by ID</h3></div></div></div><p class="calibre8">The get one and <a id="id178" class="calibre1"/>update expense logic uses an expense instance to display or update it. Due to this, we are only going to add a single logic that retrieves an expense by ID. Append the following lines of code to the controller file:</p><div class="informalexample"><pre class="programlisting">function findExpenseById(req, res, next, id) {
  if (!ObjectId.isValid(id)) {
    return res.status(404).json({ message: 'Not found.'});
  }

  Expense.findById(id, (err, expense) =&gt; {
    if (err) {
      return next(err);
    }

    if (!expense) {
      return res.status(404).json({ message: 'Not found.'});
    }

    req.expense = expense;
    next();
  });
} </pre></div><p class="calibre8">Because we are not going to do a final operation here, we only set the expense to be present on the request object and call the next handler in the route pipeline.</p></div><div class="book" title="Get one expense"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec25" class="calibre1"/>Get one expense</h3></div></div></div><p class="calibre8">We are going to <a id="id179" class="calibre1"/>extend "get expense by ID" and just respond with a JSON representation of the resource. Getting an expense logic should be a few lines of code appended to the controller file:</p><div class="informalexample"><pre class="programlisting">function getOneExpense(req, res, next) {
  if (!req.expense) {
    return res.status(404).json({ message: 'Not found.'});
  }

  res.json(req.expense);
}</pre></div></div><div class="book" title="Get all expenses"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec26" class="calibre1"/>Get all expenses</h3></div></div></div><p class="calibre8">When getting all <a id="id180" class="calibre1"/>expenses, we need to take a different approach—one that enables us to filter them by a specific query. Expenses should also be returned for a specific category. We don't need to implement different search logics for all these scenarios. Instead, we can create one that will wrap around our needs:</p><div class="informalexample"><pre class="programlisting">function getAllExpenses(req, res, next) {
  const limit = +req.query.limit || 30;
  const skip = +req.query.skip || 0;
  const query = {};

  if (req.category) {
    query.category = req.category.id;
  } else {
    query.user = req.user.id;
  }

  if (req.query.startDate) {
    query.createdAt = query.createdAt || {};
    query.createdAt.$gte = new Date(req.query.startDate);
  }

  if (req.query.endDate) {
    query.createdAt = query.createdAt || {};
    query.createdAt.$lte = new Date(req.query.endDate);
  }

  if (req.query.category) {
    query.category = req.query.category;
  }

  Expense
  .find(query)
  .limit(limit)
  .skip(skip)
  .sort({ createdAt: 'desc' })
  .populate('category')
  .exec((err, expenses) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(expenses);
  });
}  </pre></div><p class="calibre8">Before querying the database using Mongoose to retrieve the necessary data, we construct a query variable that will hold all our criteria. One nice thing to note here is that once again we used <a id="id181" class="calibre1"/>the query builder object provided by Mongoose. Expenses are going to be stored in a greater number in MongoDB. Hence, we add a <code class="email">limit</code> and a <code class="email">skip</code> to retrieve only a limited set of data.</p><p class="calibre8">Expenses can be queried using a date range. Due to this reason, the <code class="email">createdAt</code> property will be progressively extended to match only a set of expenses in a period. Expenses should also be returned in a chronological order; newly added expenses should be returned first.</p><p class="calibre8">To have all the necessary information about each expense, we are going to populate the category property of an expense with the appropriate category object from the database.</p></div><div class="book" title="Update expense"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec27" class="calibre1"/>Update expense</h3></div></div></div><p class="calibre8">Append the <a id="id182" class="calibre1"/>following code for the update logic to the controller file:</p><div class="informalexample"><pre class="programlisting">function updateExpense(req, res, next) {
  const data = _.pick(req.body, ['name', 'value', 'category', 'createdAt']);
  const expense = req.expense;

  if (data.createdAt === null) {
    delete data.createdAt;
  }

  _.assign(expense, data);

  expense.save((err, updatedExpense) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(updatedExpense);
  });
} </pre></div><p class="calibre8">The update logic uses the expense instance set on the request object by the callback trigger for the <a id="id183" class="calibre1"/>expense ID parameter.</p></div><div class="book" title="Delete expense"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec28" class="calibre1"/>Delete expense</h3></div></div></div><p class="calibre8">In order to delete <a id="id184" class="calibre1"/>an expense, we just remove the expense instance from the database, using the following code:</p><div class="informalexample"><pre class="programlisting">function deleteExpense(req, res, next) {
  req.expense.remove((err) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(204).json();
  });
}</pre></div></div></div></div>

<div class="book" title="Tracking expenses">
<div class="book" title="Getting the expense balance"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch02lvl2sec48" class="calibre1"/>Getting the expense balance</h2></div></div></div><p class="calibre8">Let's get back to <a id="id185" class="calibre1"/>the expense model and extend it with balance calculation. In order to get the balance in different scenarios, we are going to use the Aggregation framework from MongoDB. Aggregated data means computed results from operations on data from collections. </p><p class="calibre8">Mongo provides a complex set of operations to perform on datasets. Because we are using Mongoose, we have access to <code class="email">Model.aggregate()</code>, which will help us create the aggregation pipelines. </p><p class="calibre8">Keep in mind that the data returned from aggregation is in the form of plain JavaScript objects, not Mongoose documents. This is due to the fact that any shape of document can be returned when using aggregations.</p><p class="calibre8">Append the following code before the expense model compilation:</p><div class="informalexample"><pre class="programlisting">ExpenseSchema.statics.getBalance = getExpensesBalance;

function getExpensesBalance(opts, callback) {
  const query = {};

  // set the current user
  query.user = opts.user;

  if (opts.category || opts.category === null) {
    query.category = new mongoose.Types.ObjectId(opts.category);
  }

  if (opts.startDate &amp;&amp; opts.endDate) {
    query.createdAt = {
      $gte: new Date(opts.startDate),
      $lte: new Date(opts.endDate)
    };
  }

  this.model('Expense').aggregate([
    { $match: query },
    { $group: { _id: null, balance: { $sum: '$amount' }, count: { $sum: 1 } } }
  ], (err, result) =&gt; {

    // result is an array with a single item, we can just return that
    const final = result[0];
    final.balance = final.balance / SCALE_FACTOR;

    callback(err, final);
  });
}</pre></div><p class="calibre8">The preceding static <code class="email">.getBalance()</code> method will calculate the current balance in different scenarios, as described in the test case. The <code class="email">.aggregate()</code> method goes through multiple stages. The first one is a match stage that will select all the documents for our defined query. The result from the match is sent to the group stage, where the documents are grouped by a specified identifier.</p><p class="calibre8">In addition, pipeline stages can use operators to perform different tasks, for example, calculating the <a id="id186" class="calibre1"/>balance in our scenario. We are using an accumulator operator called <code class="email">$sum</code> that returns a numerical value for each group. </p><p class="calibre8">In the group stage, the <code class="email">_id</code> field is mandatory, but you can specify a null value for it to calculate all the values for the input documents of the pipeline. The group operator has a limit of 100 megabytes of RAM, but you can set it to use the disk to write temporary files. To set this option, use Mongoose and take a look at the <code class="email">.allowDiskUse()</code> method.</p><p class="calibre8">Add the missing controller function, <code class="email">app/controller/expense</code>:</p><div class="informalexample"><pre class="programlisting">function getExpensesBalance(req, res, next) {
  Expense.getBalance({
    user: req.user._id,
    category: req.query.category,
    startDate: req.query.start,
    endDate: req.query.end
  }, (err, result) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(result);
  });
}</pre></div></div></div>

<div class="book" title="Implementing the Angular client application" id="QMFO1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Implementing the Angular client application</h1></div></div></div><p class="calibre8">We have reached <a id="id187" class="calibre1"/>the point in <a id="id188" class="calibre1"/>our project at which we will start integrating the AngularJS application. This chapter will take a different approach at building the desired application. An ideal application should be structured in a modular way, each module addressing a specific functionality.</p><p class="calibre8">You are probably already familiar with the component-based approach when building Angular apps. What this means is that we will create small modules that encapsulate specific functionalities. This enables us to add functionality incrementally; imagine adding vertical blocks onto the application.</p><p class="calibre8">For this to work, we need to create a main block that glues everything together, pulling all features and modules together. Keep your main app module thin and move the rest of the logic to application modules.</p><p class="calibre8">One rule that I like to follow is to keep my folder structure as flat as possible. I always try to reduce the level of the folders so that I can locate code and functionality quickly. If your module grows too big, you can either split it up or add subfolders.</p></div>

<div class="book" title="Implementing the Angular client application" id="QMFO1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Bootstrapping the project"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec49" class="calibre1"/>Bootstrapping the project</h2></div></div></div><p class="calibre8">Let's get <a id="id189" class="calibre1"/>started and create a <code class="email">public/package.json</code> file. We are going to use <code class="email">npm</code> to install our dependencies for the frontend part of the project. The <code class="email">package.json</code> file will have the following content:</p><div class="informalexample"><pre class="programlisting">{
  "private": true,
  "name": "mean-blueprints-expensetracker-client",
  "dependencies": {
    "systemjs": "^0.19.25",
    "es6-shim": "^0.35.0",
    "es6-promise": "^3.0.2",
    "rxjs": "^5.0.0-beta.2",
    "reflect-metadata": "^0.1.2",
    "zone.js": "^0.6.6",
    "angular2": "^2.0.0-beta.14"
  },
  "devDependencies": {
    "typings": "^0.7.12",
    "typescript": "^1.8.9"
  }
} </pre></div><p class="calibre8">Run this command to install all the dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">npm install</strong></span>
</pre></div><p class="calibre8">After a <a id="id190" class="calibre1"/>successful installation, create a folder called <code class="email">public/src</code>. This folder will hold the main Angular application. Inside this folder, we will create our modules folder and application files.</p><p class="calibre8">Create your main app component file, called <code class="email">public/src/app.component.ts</code>, and follow these steps to create the final version of the file:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the necessary dependencies:<div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { RouteConfig, RouterOutlet, RouterLink } from 'angular2/router';
import { Router } from 'angular2/router';
import { AuthHttp, AuthService, SigninComponent, RegisterComponent } from './auth/index';
import { ExpensesComponent } from './expense/index';
import { CategoriesComponent } from './expense/index';</pre></div></li><li class="listitem" value="2">Configure your routes:<div class="informalexample"><pre class="programlisting">@RouteConfig([
  { path: '/', redirectTo: ['/Expenses'], useAsDefault: true },
  { path: '/expenses', as: 'Expenses', component: ExpensesComponent },
  { path: '/categories', as: 'Categories', component: CategoriesComponent },
  { path: '/signin', as: 'Signin', component: SigninComponent },
  { path: '/register', as: 'Register', component: RegisterComponent }
])</pre></div><p class="calibre22">We defined a default path that will redirect to the <code class="email">expenses</code> view, displaying all the entries to the user. There is also a <code class="email">Signin</code> and <code class="email">register</code> route available.</p></li><li class="listitem" value="3">Add the component annotation:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'expense-tracker',
    directives: [
      RouterOutlet,
      RouterLink
    ],
    template: `
      &lt;div class="app-wrapper card whiteframe-z2"&gt;
        &lt;div class="row"&gt;
          &lt;div class="col"&gt;
            &lt;a href="#"&gt;Expense tracker&lt;/a&gt;
            &lt;a href="#" [routerLink]="['Expenses']"&gt;Expenses&lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="row"&gt;
          &lt;router-outlet&gt;&lt;/router-outlet&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="4">Define <a id="id191" class="calibre1"/>the component's class:<div class="informalexample"><pre class="programlisting">export class AppComponent implements OnInit {
  public currentUser: any;
  private _authHttp: AuthHttp;
  private _authSerivce: AuthService;
  private _router: Router;

  constructor(authHttp: AuthHttp, authSerice: AuthService, router: Router) {
    this._router = router;
    this._authSerivce = authSerice;
    this._authHttp = authHttp;
  }

  ngOnInit() {
    this.currentUser = {};
    this._authHttp.unauthorized.subscribe((res) =&gt; {
      if (res) {
        this._router.navigate(['./Signin']);
      }
    });
    this._authSerivce.currentUser.subscribe((user) =&gt; {
      this.currentUser = user;
    });
  }
}</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">If an unauthorized call is made, we redirect the user to the <code class="email">Signin</code> route in order to authenticate <a id="id192" class="calibre1"/>itself with valid credentials.</p></div></div>

<div class="book" title="Registering users" id="RL0A1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Registering users</h1></div></div></div><p class="calibre8">Our application <a id="id193" class="calibre1"/>should support user registration. We <a id="id194" class="calibre1"/>already have the backend logic for this functionality. Now, all we have to do is tie it up with our Angular application. To do this, we are going to create a generic module called <code class="email">auth</code>, which will be used for both registering and authenticating users.</p></div>

<div class="book" title="Registering users" id="RL0A1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="The auth service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec50" class="calibre1"/>The auth service</h2></div></div></div><p class="calibre8">We will <a id="id195" class="calibre1"/>continue with the <code class="email">auth</code> service, which will hold all the communication logic with the Node.js backend application. Create a file called <code class="email">public/src/auth/services/auth.service.ts</code> and implement the entire logic of the service by following these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Import the dependencies:<div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';
import { contentHeaders } from '../../common/index';</pre></div></li><li class="listitem" value="2">Define the service class:<div class="informalexample"><pre class="programlisting">@Injectable()
export class AuthService {
  public currentUser: Subject&lt;any&gt;;
  private _http: Http;

  constructor(http: Http) {
    this._http = http;
    this._initSession();
  }
}</pre></div></li><li class="listitem" value="3">Add the <code class="email">signin()</code> method:<div class="informalexample"><pre class="programlisting">  public signin(user: any) {
    let body = this._serialize(user);
    let basic = btoa(`${user.email}:${user.password}`);
    let headers = new Headers(contentHeaders);
    headers.append('Authorization', `Basic ${basic}`)

    return this._http
    .post('/auth/basic', '', { headers: headers })
    .map((res: Response) =&gt; res.json());
  }
Append the register() method:
  public register(user: any) {
    let body = this._serialize(user);

    return this._http
    .post('/api/users', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json());
  }</pre></div></li><li class="listitem" value="4">Set the <a id="id196" class="calibre1"/>current user:<div class="informalexample"><pre class="programlisting">  public setCurrentUser(user: any) {
    this.currentUser.next(user);
  }</pre></div><p class="calibre22">We want to expose a simple function to set the next value of the <code class="email">currentUser</code> Observable.</p></li><li class="listitem" value="5">Initialize the session:<div class="informalexample"><pre class="programlisting">  private _initSession() {
    let user = this._deserialize(localStorage.getItem('currentUser'));
    this.currentUser = new BehaviorSubject&lt;Response&gt;(user);
    // persist the user to the local storage
    this.currentUser.subscribe((user) =&gt; {
      localStorage.setItem('currentUser', this._serialize(user));
      localStorage.setItem('token', user.token.hash || '');
    });
  }</pre></div><p class="calibre22">When the application reloads, we want to retrieve the current user from the local storage in order to restore the session. One improvement you can add is to check whether the token has expired.</p></li><li class="listitem" value="6">Append the helper methods:<div class="informalexample"><pre class="programlisting">  private _serialize(data) {
    return JSON.stringify(data);
  }

  private _deserialize(str) {
    try {
      return JSON.parse(str);
    } catch(err) {
      console.error(err);
      return null;
    }
  }</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">The preceding <a id="id197" class="calibre1"/>functions are simple abstractions for the <code class="email">stringify</code> and <code class="email">parse</code> JSON methods.</p></div></div>

<div class="book" title="Registering users" id="RL0A1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Register component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec51" class="calibre1"/>Register component</h2></div></div></div><p class="calibre8">Create the <a id="id198" class="calibre1"/>appropriate component file, <code class="email">public/src/auth/components/register.component.ts</code>, with the following lines of code in it:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { AuthService } from '../services/auth.service';

export class RegisterComponent {
  private _authService: AuthService;
  private _router: Router;

  constructor(authService: AuthService, router: Router) {
    this._router = router;
    this._authService = authService;
  }

  register(event, name, email, password) {
    event.preventDefault();

    let data = { name, email, password };

    this._authService
    .register(data)
    .subscribe((user) =&gt; {
      this._router.navigateByUrl('/');
    }, err =&gt; console.error(err));
  }
}</pre></div><p class="calibre8">When the <code class="email">register</code> method is called, we simply try to register our user using the <code class="email">AuthService</code>. Error handling is not added in the preceding code. Only a simple log will be printed on the <a id="id199" class="calibre1"/>browser's console. Let's add the template:</p><div class="informalexample"><pre class="programlisting">@Component({
    selector: 'register',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="login jumbotron center-block"&gt;
        &lt;h1&gt;Register&lt;/h1&gt;
        &lt;form role="form" (submit)="register($event, name.value, email.value, password.value)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="name"&gt;Full name&lt;/label&gt;
            &lt;input type="text" #name class="form-control" id="email" placeholder="please enter your name"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="email"&gt;E-mail&lt;/label&gt;
            &lt;input type="text" #email class="form-control" id="email" placeholder="enter valid e-mail"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="password"&gt;Password&lt;/label&gt;
            &lt;input type="password" #password class="form-control" id="password" placeholder="now your password"&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre8">The register component is pretty straightforward. We are defining a simple register function that will use the auth service's <code class="email">register</code> method. All the necessary fields also can be found in the <code class="email">template</code> property.</p></div></div>
<div class="book" title="Sign-in-user component" id="SJGS1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Sign-in-user component</h1></div></div></div><p class="calibre8">In order to <a id="id200" class="calibre1"/>authenticate users, we have added some extra functionality to the auth service to enable us to sign in a user. Because we are not persisting the state of a user on the backend—in other words, our backend is stateless—we have to store the current state of the user on the frontend.</p><p class="calibre8">Remember that we created an endpoint that will issue us a token for a valid username-and-password tuple. We are going to use that endpoint to retrieve a token that will grant us access to the rest of the API endpoints.</p><p class="calibre8">Our sign-in component is fairly simple and it's really reused from the previous chapter, but let's refresh our memory and take a look at it. <code class="email">SigninComponent</code> is found under <code class="email">public/src/auth/components/signin.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { AuthService } from '../services/auth.service';

@Component({
    selector: 'signin',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="login jumbotron center-block"&gt;
        &lt;h1&gt;Login&lt;/h1&gt;
        &lt;form role="form" (submit)="signin($event, email.value, password.value)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="email"&gt;E-mail&lt;/label&gt;
            &lt;input type="text" #email class="form-control" id="email" placeholder="enter your e-mail"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="password"&gt;Password&lt;/label&gt;
            &lt;input type="password" #password class="form-control" id="password" placeholder="now your password"&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})
export class SigninComponent {
  private _authService: AuthService;
  private _router: Router;

  constructor(authService: AuthService, router: Router) {
    this._authService = authService;
    this._router = router;
  }

  signin(event, email, password) {
    event.preventDefault();

    let data = { email, password };

    this._authService
    .signin(data)
    .subscribe((user) =&gt; {
      this._authService.setCurrentUser(user);
      this._router.navigateByUrl('/');
    }, err =&gt; console.error(err));
  }
}</pre></div><p class="calibre8">Just as in <code class="email">RegisterComponent</code>, we are using local variables for our fields. Using <code class="email">AuthService</code>, we <a id="id201" class="calibre1"/>try to authenticate our user. We are not really focusing on handling errors, but, if the user successfully authenticates, we want to navigate to the <code class="email">root</code> path and set the current user.</p></div>

<div class="book" title="Common functionalities" id="TI1E1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec24" class="calibre1"/>Common functionalities</h1></div></div></div><p class="calibre8">There are a few functionalities <a id="id202" class="calibre1"/>that we used earlier and some extra functionality to consider before jumping further into development. For example, we used a common headers definition, found under <code class="email">public/src/common/headers.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Headers } from 'angular2/http';

const HEADERS = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
};

export const contentHeaders = new Headers(HEADERS);</pre></div><p class="calibre8">This is simply a way to define constants and use them across the application without repeating yourself. So, basically, we imported <code class="email">Headers</code> from Angular 2 and created a new instance. You can easily add extra fields to this header instance using the <code class="email">append()</code> method, like this for example:</p><div class="informalexample"><pre class="programlisting">contentHeaders.append('Authorization', 'Bearer &lt;token_value&gt;');</pre></div><p class="calibre8">Now there a few other things to consider:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When asking <a id="id203" class="calibre1"/>the server for resources through the API, we should send the required Bearer token</li><li class="listitem">If a user makes a call and the server responds with a status code that equals 401—unauthorized—we should redirect the user to the sign-in page</li></ul></div><p class="calibre8">Let's see what we can do about the preceding list.</p></div>

<div class="book" title="Common functionalities" id="TI1E1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Custom HTTP service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec52" class="calibre1"/>Custom HTTP service</h2></div></div></div><p class="calibre8">We did something <a id="id204" class="calibre1"/>similar in the previous chapter when we created a custom HTTP service to make calls to the Express backend application. But we need a few extra things, such as attaching the token to each call that is made through this service in order to identify the user.</p><p class="calibre8">Remember that we stored our user's token inside the browser's <code class="email">LocalStorage</code>. This should be fairly simple to retrieve and I think we can even add it inside the service. Let's get started and create a new file called <code class="email">public/src/auth/services/auth-http.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers, BaseRequestOptions, Request, RequestOptions, RequestOptionsArgs, RequestMethod } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';

@Injectable()
export class AuthHttp {
  public unauthorized: Subject&lt;Response&gt;;
  private _http: Http;

  constructor(http: Http) {
    this._http = http;
    this.unauthorized = new BehaviorSubject&lt;Response&gt;(null);
  }

  public get(url: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Get}, opts);
  }

  public post(url: string, body?: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Post, body: body}, opts);
  }

  public put(url: string, body?: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Put, body: body}, opts);
  }

  public delete(url: string, body?: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Delete, body: body}, opts);
  }

  // rest of the HTTP methods ...
}</pre></div><p class="calibre8">So this is our <a id="id205" class="calibre1"/>custom <code class="email">HttpAuth</code> service, which exposes a few public methods, the same as in the previous chapter. Now the changes occur in the private <code class="email">request()</code> method:</p><div class="informalexample"><pre class="programlisting">  private request(requestArgs: RequestOptionsArgs, additionalArgs?: RequestOptionsArgs) {
    let opts = new RequestOptions(requestArgs);

    if (additionalArgs) {
      opts = opts.merge(additionalArgs);
    }

    let req:Request = new Request(opts);

    if (!req.headers) {
      req.headers = new Headers();
    }

    if (!req.headers.has('Authorization')) {
      req.headers.append('Authorization', `Bearer ${this.getToken()}`);
    }

    return this._http.request(req).catch((err: any) =&gt; {
      if (err.status === 401) {
        this.unauthorized.next(err);
      }

      return Observable.throw(err);
    });
  }</pre></div><p class="calibre8">Before we make a call, we attach the necessary token to the <code class="email">Authorization</code> header. The token is stored in the browser's storage, so we use the <code class="email">getToken()</code> method to retrieve it. If the request is unauthorized, we push it through our unauthorized data stream, which holds requests that <a id="id206" class="calibre1"/>failed authentication.</p><p class="calibre8">The <code class="email">getToken()</code> method has a very simple implementation:</p><div class="informalexample"><pre class="programlisting">  private getToken() {
    return localStorage.getItem('token');
  }</pre></div></div></div>

<div class="book" title="Common functionalities" id="TI1E1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Using a single export file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec53" class="calibre1"/>Using a single export file</h2></div></div></div><p class="calibre8">We can add an <a id="id207" class="calibre1"/><code class="email">index.ts</code> file in the root of each module folder in order to export all public members. In the <code class="email">auth</code> module, we can have a file called <code class="email">public/src/auth/index.ts</code> with the following content:</p><div class="informalexample"><pre class="programlisting">export * from './components/register.component';
export * from './components/signin.component';
export * from './services/auth.service';
export * from './services/auth-http';</pre></div><p class="calibre8">This technique will be used for each module and it's not going to be covered any further.</p></div></div>

<div class="book" title="The categories module"><div class="book" id="UGI02-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec25" class="calibre1"/>The categories module</h1></div></div></div><p class="calibre8">The category <a id="id208" class="calibre1"/>module will hold all of the logic that is necessary to <a id="id209" class="calibre1"/>perform CRUD operations on categories and communicate with the backend through an Angular service.</p></div>

<div class="book" title="The categories module">
<div class="book" title="Category service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec54" class="calibre1"/>Category service</h2></div></div></div><p class="calibre8">The category <a id="id210" class="calibre1"/>service is going to be fairly simple, it's only going to manage the CRUD operations on categories. The following steps will describe the process to achieve this:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a file called <code class="email">public/app/categories/category.service.js</code>.</li><li class="listitem" value="2">Add the necessary business logic:<div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';
import { AuthHttp } from '../auth/index';
import { contentHeaders } from '../common/index';
import { Category } from './category.model';

@Injectable()
export class CategoryService {
  public category: Subject&lt;Category&gt;;
  public categories: Observable&lt;Array&lt;Category&gt;&gt;;

  private _authHttp: AuthHttp;
  private _categoriesObserver: any;

  constructor(authHttp: AuthHttp) {
    this._authHttp = authHttp;
    this.categories = new Observable(
      observer =&gt; {
        this._categoriesObserver = observer
      }
    ).share();
    this.category = new BehaviorSubject&lt;Category&gt;(null);
  }

  getAll() {
    return this._authHttp
    .get('/api/categories', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map((data) =&gt; {
      let categories = data.map((category) =&gt; {
        return new Category(
          category._id,
          category.name,
          category.description,
          category.owner,
          category.collaborators
        );
      });

      this._categoriesObserver.next(categories);

      return categories;
    });
  }

  findById(id) {
    return this._authHttp
    .get(`/api/categories/${id}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }

  create(category) {
    let body = JSON.stringify(category);

    return this._authHttp
    .post('/api/categories', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }

  update(category) {
    let body = JSON.stringify(category);

    return this._authHttp
    .put(`/api/categories/${category._id}`, body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }

  delete(category) {
    return this._authHttp
    .put(`/api/categories/${category._id}`, '', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }
} </pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">As you can see, the service will expose all the methods needed for the CRUD operations. Each method will return an observable, which will emit a single response. We are also using our own <code class="email">AuthHttp</code> in order to check whether a request is unauthorized and the user needs to sign in.</p><p class="calibre8">Note that, besides the returned observable, the <code class="email">getAll()</code> method also updates the <code class="email">categories</code> data <a id="id211" class="calibre1"/>stream in order to push the new values to each subscriber. This will come in handy when multiple subscribers use the same data source to display data in their own way.</p></div></div>

<div class="book" title="The categories module">
<div class="book" title="The categories component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec55" class="calibre1"/>The categories component</h2></div></div></div><p class="calibre8">We are going <a id="id212" class="calibre1"/>to create a component that is used when we navigate to the <code class="email">/categories</code> path, which we configured at the beginning of the chapter. The final version of <code class="email">AppComponent</code> was used earlier in the chapter.</p><p class="calibre8">
<code class="email">CategoriesComponent</code> will use two other components to create a new category and list all the available entries from the system. Let's create a new file, <code class="email">public/src/category/categories.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { CategoryListComponent } from './category-list.component';
import { CategoryCreateComponent } from './category-create.component';

@Component({
    selector: 'categories',
    directives: [
      CategoryCreateComponent,
      CategoryListComponent
    ],
    template: `
      &lt;category-create&gt;&lt;/category-create&gt;
      &lt;category-list&gt;&lt;/category-list&gt;
    `
})
export class CategoryComponent {
  constructor() {}
}</pre></div><p class="calibre8">The previous component does not have much going on; we have no moving parts. We just import the two necessary components and include them in the template. Let's continue by <a id="id213" class="calibre1"/>implementing the other two components from this context.</p></div></div>

<div class="book" title="The categories module">
<div class="book" title="Create a new category"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec56" class="calibre1"/>Create a new category</h2></div></div></div><p class="calibre8">A user must be <a id="id214" class="calibre1"/>able to interact with our application and add new categories, so we are going to create a separate component for this. Let's break it down into these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, create the view file, called <code class="email">public/src/category/components/category-create.component.ts</code>.</li><li class="listitem" value="2">Import the necessary dependencies:<div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { CategoryService } from '../category.service';
import { Category } from '../category.model';</pre></div></li><li class="listitem" value="3">Define the component annotation, which includes the template:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'category-create',
    template: `
      &lt;div&gt;
        &lt;form role="form" (submit)="onSubmit($event)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="name"&gt;Name&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="category.name" class="form-control" id="name"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="description"&gt;Description&lt;/label&gt;
            &lt;textarea class="form-control" id="description"
              name="description" [(ngModel)]="category.description"&gt;
            &lt;/textarea&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Add&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="4">Add the <a id="id215" class="calibre1"/>component's class:<div class="informalexample"><pre class="programlisting">export class CategoryCreateComponent implements OnInit {
  public category: Category;
  public categories: Array&lt;Category&gt;;
  private _categoryService: CategoryService;

  constructor(categoryService: CategoryService) {
    this._categoryService = categoryService;
  }

  ngOnInit() {
    this.category = new Category();
  }

  onSubmit(event) {
    event.preventDefault();

    this._categoryService
    .create(this.category)
    .subscribe((category) =&gt; {
      this._categoryService.category.next(category);
      this.category = new Category();
    }, err =&gt; console.error(err));
  }
}</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">Each time <a id="id216" class="calibre1"/>we add a new category, we want to broadcast the new item to all subscribers. For example, the categories list should have the new entry displayed. After we have successfully created the category, the form should be reset to its initial value.</p></div></div>

<div class="book" title="The categories module">
<div class="book" title="List all categories"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec57" class="calibre1"/>List all categories</h2></div></div></div><p class="calibre8">Now that we can <a id="id217" class="calibre1"/>create categories, we should be able to list them for the user. In order to list the categories, we are going to use two components, one component to iterate over the data from the server and another to display information about a category. </p><p class="calibre8">The latter component will also have encapsulated the update functionality. So anytime the user can change information about a category and persist the changes on the backend.</p><p class="calibre8">Let's create a new component file for the categories listing, called <code class="email">public/src/category/components/category-list.component.ts</code>, and follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Import the necessary modules:<div class="informalexample"><pre class="programlisting">import { Component, OnInit, OnDestroy } from 'angular2/core';
import { CategoryService } from '../category.service';
import { CategoryComponent } from './category.component';
import { Category } from '../category.model';</pre></div><p class="calibre22">We imported a <code class="email">CategoryComponent</code>, which doesn't exist at the moment, but we should already have an idea of how we are going to use our component.</p></li><li class="listitem" value="2">Define the template and component annotation:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'category-list',
    directives: [CategoryComponent],
    template: `
      &lt;div class="jumbotron center-block"&gt;
        &lt;h2&gt;List of all your categories&lt;/h2&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;category *ngFor="#category of categories" [category]="category"&gt;&lt;/category&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre22">We are using the <code class="email">ngFor</code> directive to render the <code class="email">category</code> template for each item from the list.</p></li><li class="listitem" value="3">Declare <a id="id218" class="calibre1"/>the component's class:<div class="informalexample"><pre class="programlisting">export class CategoryListComponent implements OnInit, OnDestroy {
  public categories: Array&lt;Category&gt;;
  private _categoryService: CategoryService;
  private _categorySubscription: any;

  constructor(categoryService: CategoryService) {
    this._categoryService = categoryService;
  }

  ngOnInit() {
    this._categorySubscription = this._categoryService.category
    .subscribe((category) =&gt; {
      if (category) {
        this.categories.push(category);
      }
    });
    this._categoryService.getAll()
    .subscribe((categories) =&gt; {
      this.categories = categories;
    });
  }

  ngOnDestroy() {
    this._categorySubscription.unsubscribe();
  }
}</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">When the component is initialized, we are going to retrieve all the available categories from the backend using our <code class="email">CategoryService</code>. Besides fetching all the necessary data, we also subscribe when a new category is created. Basically, we subscribe to a category data stream.</p><p class="calibre8">Each time a new category is added, it is going to be pushed to the <code class="email">categories</code> list and displayed to the user. In order to render the information for the user, we are going to have a component for a single category. </p><p class="calibre8">When the component is destroyed, we want to unsubscribe from the data stream; otherwise, notifications will be pushed down the data stream.</p></div></div>

<div class="book" title="The categories module">
<div class="book" title="The category component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec58" class="calibre1"/>The category component</h2></div></div></div><p class="calibre8">To display <a id="id219" class="calibre1"/>information for a single category from our list, we are going to create a new component, called <code class="email">public/src/category/components/category.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { CategoryService } from '../category.service';
import { Category } from '../category.model';

@Component({
    inputs: ['category'],
    selector: 'category',
    template: `
    &lt;div&gt;
      &lt;form role="form" (submit)="onSubmit($event)"&gt;
        &lt;div class="form-group"&gt;
          &lt;label for="name"&gt;Name&lt;/label&gt;
          &lt;input type="text" [(ngModel)]="category.name" class="form-control" id="name"&gt;
        &lt;/div&gt;
        &lt;div class="form-group"&gt;
          &lt;label for="description"&gt;Description&lt;/label&gt;
          &lt;textarea class="form-control" id="description"
            name="description" [(ngModel)]="category.description"&gt;
          &lt;/textarea&gt;
        &lt;/div&gt;
        &lt;button type="submit" class="button"&gt;save&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
    `
})
export class CategoryComponent {
  public category: Category;
  private _categoryService: CategoryService;

  constructor(categoryService: CategoryService) {
    this._categoryService = categoryService;
  }

  onSubmit(event) {
    event.preventDefault();
    this._categoryService.update(this.category)
    .subscribe((category) =&gt; {
      this.category = category;
    }, err =&gt; console.error(err));
  }
}</pre></div><p class="calibre8">This category gets input data to display information about a category. It also triggers an event when the <span class="strong"><strong class="calibre2">Save</strong></span> button is clicked on and the form is submitted. We use our service to <a id="id220" class="calibre1"/>communicate with the server and persist the changes in MongoDB.</p></div></div>

<div class="book" title="The expenses module"><div class="book" id="VF2I2-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec26" class="calibre1"/>The expenses module</h1></div></div></div><p class="calibre8">In this module, we <a id="id221" class="calibre1"/>are going to treat functionality <a id="id222" class="calibre1"/>related to expenses. This is going to be the main module used by our users in the frontend application, because here they will add new expenses and store them in MongoDB through our backend API.</p></div>

<div class="book" title="The expenses module">
<div class="book" title="Expense service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec59" class="calibre1"/>Expense service</h2></div></div></div><p class="calibre8">The <a id="id223" class="calibre1"/>expense service will implement CRUD operations on expenses and one other important feature of it is getting the balance of expenses. In order to create the expense service, we will follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a file called <code class="email">public/src/expense/expense.service.js</code>.</li><li class="listitem" value="2">Define the main logic of the service:<div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';
import { AuthHttp } from '../auth/index';
import { contentHeaders, serializeQuery } from '../common/index';
import { Expense } from './expense.model';

@Injectable()
export class ExpenseService {
  public expense: Subject&lt;Expense&gt;;
  public expenses: Observable&lt;Array&lt;Expense&gt;&gt;;
  public filter: Subject&lt;any&gt;;
  private _authHttp: AuthHttp;
  private _expensesObserver: any;

  constructor(authHttp: AuthHttp) {
    this._authHttp = authHttp;
    this.expenses = new Observable(
      observer =&gt; {
        this._expensesObserver = observer
      }
    );
    this.filter = new BehaviorSubject&lt;any&gt;(null);
    this.expense = new BehaviorSubject&lt;Expense&gt;(null);
  }
  create(expense) {
  }
  findById(id) {
  }
  getAll() { 
  }
  update(expense) {
  }
  delete(expense) {
  }
}</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">We just defined a list of exposed methods. We also exposed a few public properties, for the filter that can be updated externally, like the expense, and an Observable expenses data stream.</p><p class="calibre8">Now let's <a id="id224" class="calibre1"/>follow the methods one by one and append their actual implementation:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Creating an expense:<div class="informalexample"><pre class="programlisting">  create(expense) {
    let body = JSON.stringify(expense);

    return this._authHttp
    .post('/api/expenses', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map((expense) =&gt; {
      return new Expense(
        expense._id,
        expense.name,
        expense.currency,
        expense.amoun,
        expense.scaleFactor,
        expense.value,
        expense.user,
        expense.category,
        expense.createdAt
      );
    });
  }
Getting one expense by ID:
  findById(id) {
    return this._authHttp
    .get(`/api/expenses/${id}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map((expense) =&gt; {
      return new Expense(
        expense._id,
        expense.name,
        expense.currency,
        expense.amoun,
        expense.scaleFactor,
        expense.value,
        expense.user,
        expense.category,
        expense.createdAt
      );
    });
  }</pre></div></li><li class="listitem" value="2">Getting <a id="id225" class="calibre1"/>all expenses matching a given query criteria:<div class="informalexample"><pre class="programlisting">  getAll(criteria?: any) {
    let query = '';

    if (criteria) {
      query = `?${serializeQuery(criteria)}`
    }

    this._authHttp
    .get(`/api/expenses${query}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map((data) =&gt; {
      return data.map((expense) =&gt; {
        return new Expense(
          expense._id,
          expense.name,
          expense.currency,
          expense.amoun,
          expense.scaleFactor,
          expense.value,
          expense.user,
          expense.category,
          expense.createdAt
        );
      });
    }).subscribe((expenses: Array&lt;Expense&gt;) =&gt; {
      this._expensesObserver.next(expenses);
    }, err =&gt; console.error(err));
  }</pre></div><p class="calibre22">The preceding method uses a <code class="email">serializeQuery()</code> method, which will transform our criteria into <code class="email">query string</code> parameters. We are doing this to filter our expenses by a given criteria. Also, rather than returning an Observable from the HTTP call, we update our <code class="email">expenses</code> data stream to notify all subscribers of the newly available data.</p></li><li class="listitem" value="3">Getting the <a id="id226" class="calibre1"/>balance of the expenses matching a query criteria:<div class="informalexample"><pre class="programlisting">  getExpensesBalance(criteria?: any) {
    let query = '';

    if (criteria) {
      query = `?${serializeQuery(criteria)}`
    }

    return this._authHttp
    .get(`/api/expenses/balance${query}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div><p class="calibre22">We use the same <code class="email">serializeQuery()</code> function to transform our criteria into a <code class="email">query string</code>.</p></li><li class="listitem" value="4">Updating an expense by ID with new data:<div class="informalexample"><pre class="programlisting">  update(expense) {
    let body = JSON.stringify(expense);

    return this._authHttp
    .put(`/api/expenses/${expense._id}`, body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }
Removing an existing expense by ID:
  delete(expense) {
    return this._authHttp
    .put(`/api/expenses/${expense._id}`, '', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div></li></ol><div class="calibre12"/></div></div></div>

<div class="book" title="The expenses module">
<div class="book" title="Filter expenses"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec60" class="calibre1"/>Filter expenses</h2></div></div></div><p class="calibre8">As a start, we <a id="id227" class="calibre1"/>are going to implement expenses filtering. We just want to have all the necessary blocks in order to list the expenses properly. Basically, this component will be a simple form with three inputs: start date, end date, and category.</p><p class="calibre8">Using these simple criteria, we are going to filter our expenses on the backend. Remember, we need these in the <code class="email">query</code> params so that the correct data is retrieved from the <code class="email">expenses</code> collection.</p><p class="calibre8">This component will rely on the <code class="email">CategoryService</code> and subscribe to the categories data stream. It will also push new values down the filter stream to notify each subscriber to filter the expenses.</p><p class="calibre8">Let's follow these steps to implement our component:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Import the modules:<div class="informalexample"><pre class="programlisting">import { Component, OnInit, OnDestroy } from 'angular2/core';
import { CategoryService, Category } from '../../category/index';
import { ExpenseService } from '../expense.service';
import { Expense } from '../expense.model';</pre></div></li><li class="listitem" value="2">Define our component's template:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'expense-filter',
    template: `
      &lt;div&gt;
        &lt;form role="form"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="startDate"&gt;Start&lt;/label&gt;
            &lt;input type="date" [(ngModel)]="filter.startDate" class="form-control" id="startDate"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="endDate"&gt;End&lt;/label&gt;
            &lt;input type="date" [(ngModel)]="filter.endDate" class="form-control" id="endDate"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="category"&gt;Category&lt;/label&gt;
            &lt;select name="category" [(ngModel)]="filter.category"&gt;
              &lt;option *ngFor="#category of categories" [value]="category._id"&gt;
                {{ category.name }}
              &lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button" (click)="onFilter($event)"&gt;Filter&lt;/button&gt;
          &lt;button type="button" class="button" (click)="onReset($event)"&gt;Reset&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="3">Append <a id="id228" class="calibre1"/>the <code class="email">ExpenseFilterComponent</code> class:<div class="informalexample"><pre class="programlisting">export class ExpenseFilterComponent implements OnInit, OnDestroy {
  public filter: any;
  public categories: Array&lt;Category&gt;;
  private _expenseService: ExpenseService;
  private _categoryService: CategoryService;

  constructor(
    expenseService: ExpenseService,
    categoryService: CategoryService
  ) {
    this._expenseService = expenseService;
    this._categoryService = categoryService;
  }
}</pre></div></li><li class="listitem" value="4">What will happen on initialization:<div class="informalexample"><pre class="programlisting">  ngOnInit() {
    this.filter = {};
    this.categories = [];
    this._subscriptions = [];
    this._subscriptions.push(
      this._categoryService
      .categories
      .subscribe((categories) =&gt; {
        this.categories = categories;
      })
    );
  }</pre></div></li><li class="listitem" value="5">When the <a id="id229" class="calibre1"/>component is destroyed:<div class="informalexample"><pre class="programlisting">  ngOnDestroy() {
    this._subscriptions.forEach((subscription) =&gt; {
      subscription.unsubscribe();
    })
  }</pre></div><p class="calibre22">We have to unsubscribe from the data stream. We used a subscriptions list in order to hold all of them in one place and later on iterate over the subscriptions and dispose of them.</p></li><li class="listitem" value="6">How we update the filter stream:<div class="informalexample"><pre class="programlisting">  onFilter(event) {
    event.preventDefault();
    this._expenseService.filter.next(this.filter);
  }</pre></div></li><li class="listitem" value="7">Resetting the filter:<div class="informalexample"><pre class="programlisting">  onReset(event) {
    event.preventDefault();
    this.filter = {};
    this._expenseService.filter.next(this.filter);
  }</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">When the component initializes, we subscribe to the <code class="email">categories</code> data stream. If the user clicks on the <code class="email">filter</code> button, we'll update the <code class="email">filter</code> so that each subscriber can get the new filter criteria.</p><p class="calibre8">In order to reset everything, we can use the <code class="email">reset</code> button and get back to the initial state. We can then notify all subscribers that we can retrieve all expenses once again.</p></div></div>

<div class="book" title="The expenses module">
<div class="book" title="Add a new expense"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec61" class="calibre1"/>Add a new expense</h2></div></div></div><p class="calibre8">Because adding <a id="id230" class="calibre1"/>expenses will be a fairly well used feature, we are going to add the necessary logic into the same view and controller used to list expenses.</p><p class="calibre8">Remember that, in order to add a new expense, it must be included in a category. So we need a list of categories loaded into the component. This should be similar to what we did earlier in <code class="email">ExpenseFilterComponent</code>.</p><p class="calibre8">Let's go through <a id="id231" class="calibre1"/>the following steps to implement the add expense functionality:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new file, called <code class="email">public/src/expense/components/expense-create.component.ts</code>.</li><li class="listitem" value="2">Import the necessary modules:<div class="informalexample"><pre class="programlisting">import { Component, OnInit, OnDestroy } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { CategoryService, Category } from '../../category/index';
import { ExpenseService } from '../expense.service';
import { Expense } from '../expense.model';</pre></div></li><li class="listitem" value="3">Append the annotation with the template:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'expense-create',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div&gt;
        &lt;form role="form" (submit)="onSubmit($event)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="name"&gt;Name&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="expense.name" class="form-control" id="name"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="category"&gt;Category&lt;/label&gt;
            &lt;select name="category" [(ngModel)]="expense.category"&gt;
              &lt;option *ngFor="#category of categories" [value]="category._id"&gt;
                {{ category.name }}
              &lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="value"&gt;Amount&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="expense.value" class="form-control" id="value"&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Add&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="4">Add the <a id="id232" class="calibre1"/>class:<div class="informalexample"><pre class="programlisting">export class ExpenseCreateComponent implements OnInit, OnDestroy {
  public expense: Expense;
  public categories: Array&lt;Category&gt;;
  private _expenseService: ExpenseService;
  private _categoryService: CategoryService;
  private _subscriptions: Array&lt;any&gt;;

  constructor(
    expenseService: ExpenseService,
    categoryService: CategoryService
  ) {
    this._expenseService = expenseService;
    this._categoryService = categoryService;
  }</pre></div></li><li class="listitem" value="5">On initialization, we subscribe to the categories data stream and store the subscription so that we can dispose of it later on:<div class="informalexample"><pre class="programlisting">  ngOnInit() {
    this.expense = new Expense();
    this.categories = [];
    this._subscriptions = [];
    this._subscriptions.push(
      this._categoryService
      .categories
      .subscribe((categories) =&gt; {
        this.categories = categories;
      })
    );
  }</pre></div></li><li class="listitem" value="6">Unsubscribe when the component is destroyed:<div class="informalexample"><pre class="programlisting">  ngOnDestroy() {
    this._subscriptions.forEach((subscription) =&gt; {
      subscription.unsubscribe();
    })
  }
Create a new expense event:
  onSubmit(event) {
    event.preventDefault();

    this._expenseService
    .create(this.expense)
    .subscribe((expense) =&gt; {
      this._expenseService.expense.next(expense);
    }, err =&gt; console.error(err));
  }</pre></div></li></ol><div class="calibre12"/></div></div></div>

<div class="book" title="The expenses module">
<div class="book" title="List expenses"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec62" class="calibre1"/>List expenses</h2></div></div></div><p class="calibre8">To display a list of <a id="id233" class="calibre1"/>expenses, we are going to query the server for the necessary information and create a table with the retrieved information. For this, we are going to go through the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create the expenses controller file, called <code class="email">public/src/expense/components/expense-list.component.ts</code>.</li><li class="listitem" value="2">Import the service and other dependencies:<div class="informalexample"><pre class="programlisting">import { Component, OnInit, OnDestroy } from 'angular2/core';
import { ExpenseService } from '../expense.service';
import { Expense } from '../expense.model'; </pre></div></li><li class="listitem" value="3">Define the <code class="email">expense</code> table in the template:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'expense-list',
    directives: [],
    template: `
      &lt;div class="jumbotron center-block"&gt;
        &lt;h2&gt;List of all your expenses&lt;/h2&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Name&lt;/th&gt;
              &lt;th&gt;Category&lt;/th&gt;
              &lt;th&gt;Amount&lt;/th&gt;
              &lt;th&gt;Date&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr *ngFor="#expense of expenses"&gt;
              &lt;td&gt;{{ expense.name }}&lt;/td&gt;
              &lt;td&gt;{{ expense.category.name }}&lt;/td&gt;
              &lt;td&gt;{{ expense.value }}&lt;/td&gt;
              &lt;td&gt;{{ expense.createdAt | date }}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="4">Declare <a id="id234" class="calibre1"/>the <code class="email">ExpenseListComponent</code> class:<div class="informalexample"><pre class="programlisting">export class ExpenseListComponent implements OnInit, OnDestroy {
  public expenses: Array&lt;Expense&gt;;
  private _expenseService: ExpenseService;
  private _subscriptions: Array&lt;any&gt;;

  constructor(expenseService: ExpenseService) {
    this._expenseService = expenseService;
  }
}</pre></div></li><li class="listitem" value="5">Subscribe to all data streams on initialization:<div class="informalexample"><pre class="programlisting">  ngOnInit() {
    this.expenses = [];
    this._subscriptions = [];

    this._subscriptions.push(
      this._expenseService
      .expenses
      .subscribe((expenses) =&gt; {
        this.expenses = expenses;
      })
    );
    this._subscriptions.push(
      this._expenseService
      .expense
      .subscribe((expense) =&gt; {
        if (expense) {
          this.expenses.push(expense);
        }
      })
    );
    this._subscriptions.push(
      this._expenseService
      .filter
      .subscribe((filter) =&gt; {
        if (filter) {
          this._expenseService.getAll(filter);
        }
      })
    );
  }</pre></div></li><li class="listitem" value="6">Dispose of <a id="id235" class="calibre1"/>subscriptions when the component is destroyed:<div class="informalexample"><pre class="programlisting">  ngOnDestroy() {
    this._subscriptions.forEach(subscription =&gt; {
      subscription.unsubscribe();
    });
  }</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">We mostly use streams of data to display information to the user. When a new expense is created, we just get notified and update the list of expenses. If a new set of expenses is loaded, the list is updated with the new values. We also subscribe to the change of filter so that we can fetch data from the backend using that filter.</p></div></div>

<div class="book" title="The expenses module">
<div class="book" title="Display balance"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec63" class="calibre1"/>Display balance</h2></div></div></div><p class="calibre8">We want to display <a id="id236" class="calibre1"/>an accumulated value from the expenses amount. When we filter the expenses, the same filter should apply to the query for the balance. For example, we might want to display expenses from a specific category; in such a case, the balance should be displayed for expenses from that category.</p><p class="calibre8">Because we do all the heavy lifting on the backend and the result that we get through the API is nicely formatted, we only have to implement a few things to display the balance properly:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new file for the component, called <code class="email">public/src/expense/components/expense-balance.component.ts</code>. </li><li class="listitem" value="2">Implement the base class:<div class="informalexample"><pre class="programlisting">import { Component, OnInit, OnDestroy } from 'angular2/core';
import { ExpenseService } from '../expense.service';

@Component({
    selector: 'expense-balance',
    directives: [],
    template: `
      &lt;h2&gt;
        Total balance: {{ info.balance }}
        &lt;span&gt;from {{ info.count }}&lt;/span&gt;
      &lt;/h2&gt;
    `
})
export class ExpenseBalanceComponent implements OnInit, OnDestroy {
  public info: any;
  private _expenseService: ExpenseService;
  private _subscriptions: Array&lt;any&gt;;

  constructor(expenseService: ExpenseService) {
    this._expenseService = expenseService;
  }

  ngOnInit() {

  }

  ngOnDestroy() {

  }

}
Subscribe to the change of filter on init:
  ngOnInit() {
    this.info = {};
    this._subscriptions = [];

    this._subscriptions.push(
      this._expenseService
      .filter
      .subscribe((filter) =&gt; {
        if (filter) {
          this._getBalance(filter);
        }
      })
    );
  }</pre></div></li><li class="listitem" value="3">Retrieve <a id="id237" class="calibre1"/>the balance from the backend based on a criteria:<div class="informalexample"><pre class="programlisting">  ngOnDestroy() {
    this._subscriptions.forEach((subscription) =&gt; {
      subscription.unsubscribe();
    })
  }</pre></div></li><li class="listitem" value="4">Dispose of <a id="id238" class="calibre1"/>the subscriptions:<div class="informalexample"><pre class="programlisting">  ngOnDestroy() {
    this._subscriptions.forEach((subscription) =&gt; {
      subscription.unsubscribe();
    })
  }</pre></div></li></ol><div class="calibre12"/></div></div></div>

<div class="book" title="The expenses module">
<div class="book" title="Expenses component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec64" class="calibre1"/>Expenses component</h2></div></div></div><p class="calibre8">Now that we <a id="id239" class="calibre1"/>have all the necessary components, we can implement our main expenses component, which will use all the previously implemented child components. We should create a new file, called <code class="email">public/src/expense/components/expenses.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { ExpenseService } from '../expense.service';
import { CategoryService } from '../../category/index';
import { ExpenseCreateComponent } from './expense-create.component';
import { ExpenseListComponent } from './expense-list.component';
import { ExpenseBalanceComponent } from './expense-balance.component';
import { ExpenseFilterComponent } from './expense-filter.component';
@Component({
    selector: 'expenses',
    directives: [
      ExpenseCreateComponent,
      ExpenseListComponent,
      ExpenseBalanceComponent,
      ExpenseFilterComponent
    ],
    template: `
      &lt;expense-balance&gt;&lt;/expense-balance&gt;
      &lt;expense-filter&gt;&lt;/expense-filter&gt;
      &lt;expense-create&gt;&lt;/expense-create&gt;
      &lt;expense-list&gt;&lt;/expense-list&gt;
    `
})
export class ExpensesComponent implements OnInit {
  private _expenseService: ExpenseService;
  private _categoryService: CategoryService;

  constructor(
    expenseService: ExpenseService,
    categoryService: CategoryService
  ) {
    this._expenseService = expenseService;
    this._categoryService = categoryService;
  }

  ngOnInit() {
    this._categoryService.getAll().subscribe();
    this._expenseService.filter.next({});
  }
}</pre></div><p class="calibre8">The component is fairly simple, but an interesting thing happens in the <code class="email">ngOnInit()</code> method when we just get all the categories and set the filter to be an empty object. When this happens, all the rest of the components react to our actions and update accordingly.</p><p class="calibre8">With this, we have <a id="id240" class="calibre1"/>implemented the expenses module, which allows users to add expenses and see a list of all expenses. We left out some functionality, such as error handling, pagination, and other minor features, but you may improve this code as you desire.</p></div></div>
<div class="book" title="Summary" id="10DJ41-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec27" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This brings us to the end of a rather long chapter.</p><p class="calibre8">We learned to manipulate monetary data with JavaScript and Node.js and how to store it in MongoDB. We implemented a multiuser system in which users can easily register and sign in at any time. </p><p class="calibre8">We exposed most of our backend functionality through an API. We used a stateless authentication mechanism, granting access only by presenting a valid token.</p><p class="calibre8">In the next chapter, we are going to build a web page that is more public oriented, with different account types.</p></div></body></html>