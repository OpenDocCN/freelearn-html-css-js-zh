- en: Chapter 4. Sencha Cmd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Application Structure"), *Application Structure*,
    we described the nature of an Ext JS application as, essentially, a collection
    of HTML, JavaScript, and CSS. Just a web page. However, taking this point of view
    not only oversimplifies the issue, but it also means that your application won't
    reach its full potential; you'll be ignoring things like dependency management,
    code optimization, and many other matters that a high-quality application should
    incorporate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that application architecture, just like building architecture, isn't
    just about piecing together parts of a whole. It's about brick-and-mortar, the
    materials used in construction, and the methodology used to construct the final
    product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sencha Cmd can be an important part of architecting your project. It gives
    you a strong foundation, a smooth workflow, and a polished final product. In this
    chapter, we''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: What Sencha Cmd actually is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Sencha Cmd is important in your development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way in which it helps you build an initial application template and then
    assists with adding new pieces of functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it provides useful tools for the ongoing development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment process—producing optimized builds for various platforms and
    customizing the build process for more specific requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, you will understand how and why an application built
    with Sencha Cmd is significantly easier to develop and deploy. You'll have a strong
    understanding of the various parts of Sencha Cmd and how to configure and augment
    it to fit your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What is Sencha Cmd?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In short, Sencha Cmd is an executable that provides a series of further commands
    to assist with your Sencha application development. Under the hood, it comprises
    a number of third-party utilities and scripts that combine to provide this functionality.
    Here are a few of the things it bundles in its installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PhantomJS**: This is used to manipulate web pages without using a browser
    interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCDIFF**: This is a tool to work out the differences between a set of files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closure Compiler**: This is a tool to optimize and minify the JavaScript
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jetty**: This is a tool that provides a simple HTTP server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this is tied together with some custom glue from Sencha, supported by
    Apache Ant—a build tool commonly used in the Java world.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a complex yet powerfully customizable tool. The use of Ant allows
    almost all of the features of Sencha Cmd to be tweaked and extended, while Sencha's
    additions provide a straightforward command-line interface to this power.
  prefs: []
  type: TYPE_NORMAL
- en: For the application architect, Sencha Cmd provides a centralized workflow for
    your developers and a reproducible build process. It can speed up development
    time and provides a way to add customer- or business-specific deployment tasks
    to your team's toolset.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Ext JS was developed under the assumption that its users will most likely
    work with Sencha Cmd too, there's no hard and fast rule that dictates that it
    must be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're not going to cover the installation of Sencha Cmd here. The latest installer
    is available on the Sencha website ([http://www.sencha.com/](http://www.sencha.com/))
    and should be a straightforward process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few pages, we'll create a small application without using Sencha
    Cmd and examine a couple of sticking points we'll hit on the way.
  prefs: []
  type: TYPE_NORMAL
- en: The act of creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of these sticking points comes up straightaway. With Sencha Cmd, creating
    a new application is as easy as the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Within seconds, Sencha Cmd creates a new directory called `my-app` containing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The specified Ext JS SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An app directory containing model, controller, store, and view directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `app.js`, `app.json`, and `Application.js` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index.html` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Bootstrap files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sass directory with configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.sencha` directory and a `build.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, much of this is part of the Sencha Cmd support infrastructure that we can
    discard. We're going to have to manually create a lot of the preceding detailed
    items. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the application directory and copy the Ext JS SDK in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The act of creation](img/5308OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bare-bones application directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `index.html` page. We can create a standard HTML5 page and need
    to hook up the JavaScript and HTML for Ext JS. In an application generated by
    Sencha Cmd, we''d have the Bootstrap files to help us here. They go through your
    application''s dependency tree and autoload files accordingly. Without Sencha
    Cmd, we have to include these files manually. So, we end up with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now begin to build our application, starting with a small "Hello World"
    that displays a message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next step is to turn this into an MVVM application. Once we've built the directory
    structure by adding `app`, `app/model`, `app/store`, and `app/view`, we can add
    our first view. Remember that everything we've done so far would have been created
    with a single call to Sencha Cmd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for our view classes; the view model comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is entirely standard and is followed by the view itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in comparison with our previous apps, we have to explicitly require
    the view model and view controller. We''ll come back to this in a moment. Finally,
    here''s the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's go back to the `requires` option. When working with Sencha Cmd, the `viewModel`
    and controller configuration options are parsed as auto-dependencies. When we
    run the meta-command (or another command such as build that calls the meta-command),
    it compiles your code and produces Bootstrap files that tell Ext JS how to load
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Without Sencha Cmd, we have no autodependencies, so they must be specified explicitly
    with the `requires` option. That's another couple of lines of code that we could
    have avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not to mention the fact that all of these view-related files could have been
    generated with just one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re already seeing how setting up our application and adding new features
    is simplified with Sencha Cmd. Let''s look briefly at the other end of the process:
    deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to ensure that our users have a production build as slim as possible
    to minimize download times. With Sencha Cmd, we can use the `build` command to
    create a set of files for deployment that meet our requirements. Sencha Cmd will
    parse our JavaScript files and metadata and create a minimized JS file that only
    contains the classes we're actually using in our application. It does this by
    examining the requirements that each class has and building a tree of dependencies
    that can be combined into a single download.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without Sencha Cmd, where are we? Here are the steps we''ll need to take on
    each production build:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a list of all the files used by our application (including those in the
    Ext JS framework itself).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Combine them together and then minimize them.     Replace the JavaScript files we reference in `index.html` with this new file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, this is only for JavaScript! Sencha Cmd can perform a similar process
    for CSS and compile the application's Sass files into a single download.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ext JS uses `Ext.Loader`, a class that ensures the classes you require are loaded,
    and if not, requests the relevant files using Ajax and parses them—all on the
    fly. It also means that a file could be loaded from anywhere in your code that
    requires it—there's no single point of reference.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, the nature of an Ext JS application is such that performing this kind
    of production optimization becomes a lengthy process and is prone to errors. In
    the rest of this chapter, we'll show how your builds and the rest of your workflow
    will become quicker, easily reproducible, and result in a higher-quality end product.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sencha Cmd supports an advanced concept described as workspaces. In complex
    projects, there may be the need for multiple pages or sections, in essence, applications
    within the larger app. Workspaces allow you to share common code (such as session
    management, custom UI components, and helper classes across these various subapplications).
    It also avoids the need to duplicate framework code (that is, the Ext JS source)
    across the subapps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sencha Cmd documentation has detailed documentation on workspaces at [http://docs.sencha.com/cmd/5.x/workspaces.html](http://docs.sencha.com/cmd/5.x/workspaces.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a workspace can be done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply adds some configuration files for the workspace. The extra magic
    comes when you generate an application for this workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The key difference here is that the SDK will be held at the workspace root rather
    than the application root. So, the subapplications will all use the same SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use Sencha Cmd to generate just an application, which
    we''ve already touched on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will build on the standard application template we've used many times before.
  prefs: []
  type: TYPE_NORMAL
- en: While workspaces are a useful method to organize your code and promote code
    reuse, we're going to focus on single applications for the rest of the book. All
    the ideas we're discussing can be implemented on an application level without
    the distraction of a workspace.
  prefs: []
  type: TYPE_NORMAL
- en: The generation game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From here, we can quickly build out the skeleton of our application. The key
    MVVM classes are controllers, models, and views (with their associated view controllers
    and view models). Sencha Cmd can assist with quickly creating all of these classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The generation of code using a command-line tool is often known as "scaffolding"
    and was popularized by Ruby On Rails. For more on the subject, refer to [http://en.wikipedia.org/wiki/Scaffold_(programming)](http://en.wikipedia.org/wiki/Scaffold_(programming)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For controllers, it''s simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the model generator invoked looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`MyModel` is the name of the model straightforward. The next parameters allow
    generation of fields in the model (provided as a comma-separated list of `name:type`
    field pairs). In this case, we''re creating two fields: `fullName` of type string
    and `age` of type integer. This gives us the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there''s the following view generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a few files for us, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this command, as we're creating multiple files, we have the opportunity
    to create a directory and corresponding namespace to contain them. In this case,
    we created the `my` directory at `app/view/my` for these three files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pay attention to the case of names of your models, views, and controllers here.
    Sencha Cmd doesn't do anything special to correct the case to keep with expected
    naming conventions. So, whatever you type will be directly carried over to the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more commands we can run with generate: `theme` and `package`,
    but we''ll cover these in more detail later in [Chapter 9](ch09.html "Chapter 9. A
    Shopping Application"), *A Shopping Application*, when we build a packaged component
    with a custom theme.'
  prefs: []
  type: TYPE_NORMAL
- en: Develop in style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're up and running with a Sencha Cmd-powered application, we can
    start to look at the ways Sencha Cmd can ease our ongoing development process.
    These range from generating application metadata to compiling theme files.
  prefs: []
  type: TYPE_NORMAL
- en: Here to serve – a website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A standard HTML web page can be run directly from your computer without requiring
    a web server. The browser just reads the files directly from your local drive.
    With the increasing popularity of JavaScript-based web applications, browsers
    have introduced a variety of security restrictions to prevent malicious sites
    from reading your local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: This causes issues with Ext JS because when developing, `Ext.Loader` will dynamically
    load and parse the JavaScript files your application depends on from your application
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to solve this issue is to simply run your code through a web server
    as the browser normally expects. Fortunately, to avoid having to configure a full-blown
    web server on your development machine, Sencha Cmd gives you a simple way of starting
    up a lightweight server in the current directory. Simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Here to serve – a website](img/5308OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sure enough, visit `http://localhost:1841` in your web browser and your
    application will be ready and waiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Here to serve – a website](img/5308OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we can override the port the server uses. In order to start it on
    port `1999`, we will issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Bootstrap process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sencha Cmd's JavaScript compiler isn't just a way of concatenating and minifying.
    It understands your code and will process certain parts in order to simplify dependency
    management.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a wildcard `requires` option such as `Ext.grid.*` will be expanded
    so that all of the files and classes under `Ext.grid` will be included. Certain
    configuration options, such as controller or ViewModel, will be converted into
    their full class reference. This is the Bootstrap process—the way in which dependency
    information is converted into a list of actual files to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This metadata trickery comes with a small price. In certain situations, you
    need to refresh the Bootstrap data in order for Ext JS to load your application
    successfully. One way of doing this is to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will quickly rebuild the files needed to Bootstrap your app. However,
    we can go one step further and kill two birds with one stone by running a development
    web server that refreshes the app when needed. It''s as simple as running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have the same web server functionality as web start combined with
    a process that watches for metadata changes and alterations to Sass files. It
    will automatically rebuild Bootstrap data and CSS when it detects a change.
  prefs: []
  type: TYPE_NORMAL
- en: Care for the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sencha Cmd supports the concept of environments to allow different behavior
    depending on the stage of your workflow. We've already mentioned that Sencha Cmd
    leverages the power of the Ant build system to allow customization of the process.
    The different environments simply define variables that are consumed by Ant and
    passed into the build process to enable, disable, or amend a part of the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the default build variables by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces something that includes the following code along with a million
    and one other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here the variable `app.output.js` has the value `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that build variables and configuration variables are two separate things.
    Configuration variables are used by Sencha Cmd as a whole, not just the build
    process. We'll only be discussing configuration variables, as they're most commonly
    used and provide the most "bang for your buck". We just don't have space to cover
    every variable.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to take a closer look at environments now. They are used with the
    `app build` subcommand and give us a lot of power to customize our code for production.
  prefs: []
  type: TYPE_NORMAL
- en: The final product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a production build, we want to make our code as lean as possible,
    removing logging, debugging, and making sure that we compress JavaScript and CSS
    and use all optimizations available. Let''s look at the overrides for the product
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at each option in turn, ignoring the comment on the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable Ext JS framework logging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell the compiler to remove code designated as debug code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the YUI Compressor to minify the JavaScript code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable custom optimizations (such as removing the `requires` option) that are
    no longer needed when the dependency tree is already known. This can result in
    a slightly smaller code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate an HTML cache manifest file. This instructs the browser to cache the
    application's `index.html` file to reduce network activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compress the CSS files and other resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compress the "microloader" JavaScript that boots our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along with the huge range of other configuration options, we have a mechanism
    to tailor our final build to suit our needs. For tracking production issues, you
    may wish to enable logging to the browser console, so you can toggle this option.
  prefs: []
  type: TYPE_NORMAL
- en: You could even create a custom environment that skips parts of the build for
    a quicker process. It's worth poring through the output that `sencha ant .props`
    creates in order to see where you can tailor the process for the needs of your
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Before the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 3](ch03.html "Chapter 3. Application Structure"), *Application
    Structure*, we touched on the `build.xml` file that Sencha Cmd generates as part
    of an application template. Now, we'll take a closer look to see how we can use
    this file to hook into the build process and leverage it for our own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already mentioned that Sencha Cmd uses Ant, an XML-based build system
    at its core. A key concept of Ant is that of "targets", a term that describes
    a bundle of tasks that perform a part of the build process from the Ant manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A target is a container of tasks that cooperate to reach a desired state
    during the build process."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our case, Sencha Cmd comes with a set of pre-existing targets that we can
    use to hook into various parts of the build process. The `build.xml` file contains
    stubs for these targets as well as some comments on what they do. We're going
    to hook into one of these and implement a task that will halt the build process
    if certain conditions are not met.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we discussed the role of the architect, we speculated that there may be
    a requirement to enforce coding standards on the development team. We can use
    automated tools to make sure that best practice is used in a code base. Here,
    we''ll use JSHint: a JavaScript code quality tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Ant is widely used and, as such, has many community-created additions. For JSHint,
    developer Phil Mander has created a task to use it in an Ant target. For more
    information, refer to [https://github.com/philmander/ant-jshint](https://github.com/philmander/ant-jshint).
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to download the Java JAR containing the new task at [http://git.io/VSZvRQ](http://git.io/VSZvRQ).
  prefs: []
  type: TYPE_NORMAL
- en: I simply placed it in the application root along with the `build.xml` file,
    but if you've got a lot of extra tasks, it's definitely worth creating a new directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now configure our `build.xml` file to use this new task as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several steps to hook up this new task:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `taskdef` element to make Ant aware of the `ant-jshint` task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the target element with a name `–before-build`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `jshint` element configured as per the documentation on GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's only one really special thing to note about the way we've configured
    the JSHint task and that's the need to add Ext to the `globals` setting. As `ant-jshint`
    hasn't been told where the Ext JS framework is, we tell it to assume that a global
    variable called Ext is defined elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: We can now run `sencha app build` again and JSHint will parse through our code
    and check it against its rule set. If our code doesn't pass, the whole build will
    fail and a file called `jshint.out` will be created in the root of our application
    and will show the details of any JSHint errors and the lines on which they occurred.
  prefs: []
  type: TYPE_NORMAL
- en: With only ten minutes work, we've already created a low-friction method of ensuring
    buggy or low-quality code is less likely to reach production.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just one example of a prebuild check. You could also:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run code-complexity checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By preventing a build from being created if these checks don't pass, you're
    enforcing a standard way of working across the board and forcing developers to
    check all of the little things that go towards creating a quality product.
  prefs: []
  type: TYPE_NORMAL
- en: Code complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once our quality checks have passed, we want to look at deploying the application.
    Again, we have an opportunity to codify some practices to make sure your team
    performs the same actions time and time again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set out a typical process that represents a deployment to production:'
  prefs: []
  type: TYPE_NORMAL
- en: Quality checks such as tests and coding standards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minification and other optimization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bump the application version number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push to production server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number one was taken care of by our `before-init` step. Minification and optimization
    is taken care of by Sencha Cmd's build-in tasks. We're left with three tasks that
    we'd like to complete before pushing to production, so we'll look at them in turn,
    but first, let's have a brief interlude and talk about Ant.
  prefs: []
  type: TYPE_NORMAL
- en: An application for Ant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In effect, the next few pages are a tutorial for Ant, rather than Sencha Cmd
    or application architecture. There are many, many resources for Ant online and
    in print form, so why go over old ground?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this book isn't a list of facts and figures or code listings to
    type in line by line. It's supposed to get the brain thinking about the application
    from a top-down perspective and see how you can help your team build a strong
    product for your client.
  prefs: []
  type: TYPE_NORMAL
- en: An architect isn't just there to draw pictures of the house. They are there
    to make sure a beautiful house is built and the homeowner walks away happy.
  prefs: []
  type: TYPE_NORMAL
- en: Version numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back to Ant. There are multiple reasons why you want to label an application
    with a build or version number—a key one is to let stakeholders know the version
    they're reviewing to see whether it contains the bug fixes they'd expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Versioning the application is a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new build number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert it in a JavaScript file for display on the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ant provides a task to make step one fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `propertyfile` task to specify that a file called `app.properties`
    will contain an entry called `build.number`. Every time we run the task, it triggers
    an operation to increment `thisentry` by one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, we read the `app.properties` file to understand how to use the property
    task, which makes the properties it contains available to further tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we do a search and replace in the generated JS for a `{VERSION}` token
    and replace it with the `build.number` property. Let''s see it as a full `build.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''re using the `after-page` target as a hook. This fires after
    Sencha Cmd has assembled all of the application''s dependencies and created a
    single file to contain them. This is the file we do our search and replace on,
    which means that our original source files remain intact. You could have a JavaScript
    file such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Also, the `{VERSION}` token would be replaced, enabling you to use the version
    number across your application, perhaps in a footer or an **About** screen.
  prefs: []
  type: TYPE_NORMAL
- en: From release to production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our code is neat and tidy, we know what version we''re releasing. The next
    step is to push it to a production server. We''ll use SFTP to transfer files to
    a remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the `afterbuild` target, which means that all other aspects of the build
    are complete and the final production files have been built. As it's a really
    bad idea to hardcode security credentials, we use the input task to request input
    from the user on the command line. The resulting input gets assigned to the property
    specified in `addproperty`.
  prefs: []
  type: TYPE_NORMAL
- en: The `scp` task's `remoteToDir` attribute should be customized according to your
    needs, but the `scp.username` and `scp.password` values will be filled with the
    previous user input. In the `fileset` task, we specify that the whole `build/production`
    directory will be pushed up to the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: We've shown how we can leverage the power of Ant to hook into key aspects of
    the Sencha Cmd build process, converting error-prone manual tasks to automated
    ones that can be easily shared with your development team.
  prefs: []
  type: TYPE_NORMAL
- en: The best of the rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've barely touched the surface of what Sencha Cmd can do. We're looking at
    Sencha Cmd from the perspective of a highly interested architect, but an architect
    needs a strong awareness of the full stack of tools available to their developers.
    Let's do a whistle-stop tour of some of the features that Ext JS developers can
    use to ease their work on the details of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packages are a way of reusing code between projects. Sencha Cmd and Ext JS recognize
    packages as fleshed out concepts in the Sencha ecosystem, so developers should
    be aware that they're available for use. The workspace concept, which we discussed
    earlier, assists with development of packages, but they can be consumed at the
    application level, providing a tidy bundle of CSS, JavaScript, and other resources
    for an app to consume from a local or remote source.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sencha documentation at [http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html](http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html)
    provides instructions on creating packages.
  prefs: []
  type: TYPE_NORMAL
- en: At an enterprise level, packages are a key method to provide reusable logic
    and user interface elements that can be shared between teams. Code reuse is something
    that needs to be considered at an architectural level to avoid reinventing the
    wheel, so packages can be an important tool when looking at the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two approaches to working with CSS and images in Ext JS: first there''s
    the full-blown theme option in which you create a package of images, Sass files,
    and JavaScript customization to build an entirely bespoke look and feel for your
    application. In many cases, some minor tweaks to the standard Ext JS components
    combined with some extra styles for your own UI elements are all that are needed.
    In this case, Sencha Cmd provides `sencha compass compile` to transform Sass files
    into CSS that is included in your app. Don''t forget that `sencha app watch` also
    takes care of this step automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Compilations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command's build process relies on a subcommand called compile, which is responsible
    for parsing the files that make up your application. This subcommand can be invoked
    independently and could be used to create a list of application dependencies that
    could be further processed by tools other than Sencha Cmd.
  prefs: []
  type: TYPE_NORMAL
- en: In the greater JavaScript ecosystem, there are a growing number of build tools
    (such as Grunt and Gulp) that your developers may be more familiar with. By using
    a small portion of Sencha Cmd's features, your team could continue to leverage
    these tools while working with the Ext JS framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standards and process are key responsibilities of a software architect and Sencha
    Cmd is an indispensable tool to help fulfill these responsibilities. We saw how
    it can touch all parts of the application lifecycle, from quickly getting up and
    running with a template to bolting on segments of a developing code base, to creating
    a final optimized product.
  prefs: []
  type: TYPE_NORMAL
- en: More than this, the various hooks with Sencha Cmd provides flexibility. It works
    with you and your team to help ease the development process and save time that
    would otherwise be wasted with manual tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we'll look at how we can piece together everything
    we've learned so far about Ext JS application architecture and use some practical
    examples to further demonstrate how to build fantastic products for your clients.
  prefs: []
  type: TYPE_NORMAL
