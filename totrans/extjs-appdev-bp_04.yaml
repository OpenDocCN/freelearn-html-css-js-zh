- en: Chapter 4. Sencha Cmd
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. Sencha Cmd
- en: In [Chapter 3](ch03.html "Chapter 3. Application Structure"), *Application Structure*,
    we described the nature of an Ext JS application as, essentially, a collection
    of HTML, JavaScript, and CSS. Just a web page. However, taking this point of view
    not only oversimplifies the issue, but it also means that your application won't
    reach its full potential; you'll be ignoring things like dependency management,
    code optimization, and many other matters that a high-quality application should
    incorporate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 应用结构")中，我们描述了Ext JS应用程序的本质，即HTML、JavaScript和CSS的集合。本质上就是一个网页。然而，仅仅从这个角度来看不仅过于简化了问题，而且也意味着你的应用程序无法达到其全部潜力；你将忽略诸如依赖管理、代码优化以及许多其他高质量应用程序应该包含的问题。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that application architecture, just like building architecture, isn't
    just about piecing together parts of a whole. It's about brick-and-mortar, the
    materials used in construction, and the methodology used to construct the final
    product.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，应用程序架构，就像建筑架构一样，不仅仅是将整体的部分拼凑在一起。它关乎砖石和建筑材料，以及构建最终产品的方法。
- en: 'Sencha Cmd can be an important part of architecting your project. It gives
    you a strong foundation, a smooth workflow, and a polished final product. In this
    chapter, we''ll look at:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd可以是构建你的项目的重要部分。它为你提供了一个强大的基础，流畅的工作流程，以及精致的最后产品。在本章中，我们将探讨：
- en: What Sencha Cmd actually is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sencha Cmd实际上是什么
- en: Why Sencha Cmd is important in your development process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Sencha Cmd在开发过程中很重要
- en: The way in which it helps you build an initial application template and then
    assists with adding new pieces of functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助你构建初始应用程序模板，然后协助添加新功能块的方式
- en: How it provides useful tools for the ongoing development process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它如何提供有用的工具来支持持续的开发过程
- en: The deployment process—producing optimized builds for various platforms and
    customizing the build process for more specific requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署过程——为各种平台生成优化的构建，并为更具体的需求定制构建过程
- en: At the end of the chapter, you will understand how and why an application built
    with Sencha Cmd is significantly easier to develop and deploy. You'll have a strong
    understanding of the various parts of Sencha Cmd and how to configure and augment
    it to fit your requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解为什么使用Sencha Cmd构建的应用程序开发部署会显著更容易。你将对Sencha Cmd的各个部分以及如何配置和增强它以适应你的需求有一个深入的理解。
- en: What is Sencha Cmd?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Sencha Cmd？
- en: 'In short, Sencha Cmd is an executable that provides a series of further commands
    to assist with your Sencha application development. Under the hood, it comprises
    a number of third-party utilities and scripts that combine to provide this functionality.
    Here are a few of the things it bundles in its installation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Sencha Cmd是一个可执行文件，它提供了一系列进一步命令来帮助你进行Sencha应用程序开发。在底层，它包含了一系列第三方实用工具和脚本，它们组合起来提供这种功能。以下是它安装中包含的一些内容：
- en: '**PhantomJS**: This is used to manipulate web pages without using a browser
    interface'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PhantomJS**：这是一个用于在不使用浏览器界面的情况下操作网页的工具'
- en: '**VCDIFF**: This is a tool to work out the differences between a set of files'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VCDIFF**：这是一个用于计算一组文件之间差异的工具'
- en: '**Closure Compiler**: This is a tool to optimize and minify the JavaScript
    code'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Closure Compiler**：这是一个用于优化和压缩JavaScript代码的工具'
- en: '**Jetty**: This is a tool that provides a simple HTTP server'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jetty**：这是一个提供简单HTTP服务器的工具'
- en: All of this is tied together with some custom glue from Sencha, supported by
    Apache Ant—a build tool commonly used in the Java world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都被Sencha的一些自定义胶水连接在一起，由Apache Ant支持——这是一个在Java世界中常用的构建工具。
- en: The result is a complex yet powerfully customizable tool. The use of Ant allows
    almost all of the features of Sencha Cmd to be tweaked and extended, while Sencha's
    additions provide a straightforward command-line interface to this power.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个复杂但功能强大的可定制工具。使用Ant几乎可以调整和扩展Sencha Cmd的所有功能，而Sencha的添加提供了一个直接的命令行界面来访问这些功能。
- en: For the application architect, Sencha Cmd provides a centralized workflow for
    your developers and a reproducible build process. It can speed up development
    time and provides a way to add customer- or business-specific deployment tasks
    to your team's toolset.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用架构师来说，Sencha Cmd为你的开发者提供了一个集中的工作流程和一个可重复的构建过程。它可以加快开发时间，并为你的团队工具集添加客户或业务特定的部署任务提供了一种方式。
- en: Why is it important?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么它很重要？
- en: While Ext JS was developed under the assumption that its users will most likely
    work with Sencha Cmd too, there's no hard and fast rule that dictates that it
    must be used.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ext JS 是在假设其用户很可能会使用 Sencha Cmd 的情况下开发的，但并没有硬性规定它必须使用。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We're not going to cover the installation of Sencha Cmd here. The latest installer
    is available on the Sencha website ([http://www.sencha.com/](http://www.sencha.com/))
    and should be a straightforward process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会介绍 Sencha Cmd 的安装。最新的安装程序可在 Sencha 网站上找到（[http://www.sencha.com/](http://www.sencha.com/)），应该是一个简单的流程。
- en: In the next few pages, we'll create a small application without using Sencha
    Cmd and examine a couple of sticking points we'll hit on the way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将创建一个不使用 Sencha Cmd 的小型应用程序，并检查我们在路上会遇到的一些难题。
- en: The act of creation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创造的行为
- en: 'One of these sticking points comes up straightaway. With Sencha Cmd, creating
    a new application is as easy as the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个难题立即出现。使用 Sencha Cmd，创建一个新应用程序就像以下命令一样简单：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within seconds, Sencha Cmd creates a new directory called `my-app` containing
    the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟内，Sencha Cmd 就会创建一个名为 `my-app` 的新目录，包含以下内容：
- en: The specified Ext JS SDK
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 Ext JS SDK
- en: An app directory containing model, controller, store, and view directories
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含模型、控制器、存储和视图目录的应用程序目录
- en: The `app.js`, `app.json`, and `Application.js` files
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`、`app.json` 和 `Application.js` 文件'
- en: The `index.html` file
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html` 文件'
- en: The Bootstrap files
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap 文件
- en: A sass directory with configuration files
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含配置文件的 sass 目录
- en: The `.sencha` directory and a `build.xml`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sencha` 目录和 `build.xml`'
- en: Now, much of this is part of the Sencha Cmd support infrastructure that we can
    discard. We're going to have to manually create a lot of the preceding detailed
    items. Let's get started.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，其中大部分是 Sencha Cmd 支持基础设施的一部分，我们可以将其丢弃。我们将不得不手动创建前面详细说明的大多数项目。让我们开始吧。
- en: 'Let''s create the application directory and copy the Ext JS SDK in here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建应用程序目录并将 Ext JS SDK 复制到这里：
- en: '![The act of creation](img/5308OT_04_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创造的行为](img/5308OT_04_01.jpg)'
- en: Bare-bones application directory
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的应用程序目录
- en: 'Next up is the `index.html` page. We can create a standard HTML5 page and need
    to hook up the JavaScript and HTML for Ext JS. In an application generated by
    Sencha Cmd, we''d have the Bootstrap files to help us here. They go through your
    application''s dependency tree and autoload files accordingly. Without Sencha
    Cmd, we have to include these files manually. So, we end up with the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `index.html` 页面。我们可以创建一个标准的 HTML5 页面，并需要连接 Ext JS 的 JavaScript 和 HTML。在由
    Sencha Cmd 生成的应用程序中，我们会有一组 Bootstrap 文件来帮助我们。它们遍历您应用程序的依赖关系树并相应地自动加载文件。没有 Sencha
    Cmd，我们必须手动包含这些文件。因此，我们最终得到以下代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now begin to build our application, starting with a small "Hello World"
    that displays a message box:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始构建我们的应用程序，从一个显示消息框的简单“Hello World”开始：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next step is to turn this into an MVVM application. Once we've built the directory
    structure by adding `app`, `app/model`, `app/store`, and `app/view`, we can add
    our first view. Remember that everything we've done so far would have been created
    with a single call to Sencha Cmd.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将它转换成一个 MVVM 应用程序。一旦我们通过添加 `app`、`app/model`、`app/store` 和 `app/view` 来构建目录结构，我们就可以添加我们的第一个视图。记住，到目前为止我们所做的一切都将是通过
    Sencha Cmd 的单个调用创建的。
- en: 'Here''s the code for our view classes; the view model comes first:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的视图类代码；视图模型首先：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is entirely standard and is followed by the view itself:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是标准的，紧随其后的是视图本身：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that in comparison with our previous apps, we have to explicitly require
    the view model and view controller. We''ll come back to this in a moment. Finally,
    here''s the view controller:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与我们的前几个应用程序相比，我们必须显式地要求视图模型和视图控制器。我们稍后会回到这个问题。最后，这是视图控制器：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's go back to the `requires` option. When working with Sencha Cmd, the `viewModel`
    and controller configuration options are parsed as auto-dependencies. When we
    run the meta-command (or another command such as build that calls the meta-command),
    it compiles your code and produces Bootstrap files that tell Ext JS how to load
    your application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `requires` 选项。当使用 Sencha Cmd 时，`viewModel` 和控制器配置选项被解析为自动依赖项。当我们运行元命令（或调用元命令的其他命令，如构建）时，它会编译您的代码并生成
    Bootstrap 文件，告诉 Ext JS 如何加载您的应用程序。
- en: Without Sencha Cmd, we have no autodependencies, so they must be specified explicitly
    with the `requires` option. That's another couple of lines of code that we could
    have avoided.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Sencha Cmd，我们没有自动依赖项，因此必须使用`requires`选项显式指定。这又避免了我们本可以避免的几行代码。
- en: 'Not to mention the fact that all of these view-related files could have been
    generated with just one command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不提及其他所有与视图相关的文件都可以只用一个命令生成的事实：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''re already seeing how setting up our application and adding new features
    is simplified with Sencha Cmd. Let''s look briefly at the other end of the process:
    deployment.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到使用Sencha Cmd设置应用程序和添加新功能是如何简化的。让我们简要看看流程的另一端：部署。
- en: We want to ensure that our users have a production build as slim as possible
    to minimize download times. With Sencha Cmd, we can use the `build` command to
    create a set of files for deployment that meet our requirements. Sencha Cmd will
    parse our JavaScript files and metadata and create a minimized JS file that only
    contains the classes we're actually using in our application. It does this by
    examining the requirements that each class has and building a tree of dependencies
    that can be combined into a single download.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保我们的用户拥有尽可能瘦的生产构建，以最小化下载时间。使用Sencha Cmd，我们可以使用`build`命令创建一组满足我们要求的部署文件。Sencha
    Cmd将解析我们的JavaScript文件和元数据，并创建一个仅包含我们在应用程序中实际使用的类的最小化JS文件。它是通过检查每个类的要求并构建一个可以组合成单个下载的依赖关系树来做到这一点的。
- en: 'Without Sencha Cmd, where are we? Here are the steps we''ll need to take on
    each production build:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Sencha Cmd，我们将何去何从？以下是我们在每个生产构建中需要采取的步骤：
- en: Make a list of all the files used by our application (including those in the
    Ext JS framework itself).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出我们应用程序使用的所有文件（包括Ext JS框架本身中的文件）。
- en: 'Combine them together and then minimize them.     Replace the JavaScript files we reference in `index.html` with this new file.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们组合在一起，然后最小化。用这个新文件替换`index.html`中引用的JavaScript文件。
- en: Remember, this is only for JavaScript! Sencha Cmd can perform a similar process
    for CSS and compile the application's Sass files into a single download.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这仅适用于JavaScript！Sencha Cmd可以为CSS执行类似的过程，并将应用程序的Sass文件编译成一个单独的下载。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ext JS uses `Ext.Loader`, a class that ensures the classes you require are loaded,
    and if not, requests the relevant files using Ajax and parses them—all on the
    fly. It also means that a file could be loaded from anywhere in your code that
    requires it—there's no single point of reference.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS使用`Ext.Loader`，这是一个确保所需的类被加载的类，如果没有，则使用Ajax请求相关文件并解析它们——这一切都是即时的。这也意味着文件可以从代码的任何需要它的地方加载——没有单一的参考点。
- en: In truth, the nature of an Ext JS application is such that performing this kind
    of production optimization becomes a lengthy process and is prone to errors. In
    the rest of this chapter, we'll show how your builds and the rest of your workflow
    will become quicker, easily reproducible, and result in a higher-quality end product.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Ext JS应用程序的本质使得进行这种类型的生产优化变成一个漫长的过程，并且容易出错。在本章的剩余部分，我们将展示如何使您的构建和整个工作流程变得更加快速、易于重复，并最终产生更高品质的最终产品。
- en: Setting up your application
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的应用程序
- en: Sencha Cmd supports an advanced concept described as workspaces. In complex
    projects, there may be the need for multiple pages or sections, in essence, applications
    within the larger app. Workspaces allow you to share common code (such as session
    management, custom UI components, and helper classes across these various subapplications).
    It also avoids the need to duplicate framework code (that is, the Ext JS source)
    across the subapps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd支持一个称为工作区的先进概念。在复杂的项目中，可能需要多个页面或部分，本质上是在更大的应用程序中的应用程序。工作区允许您共享常用代码（例如会话管理、自定义UI组件和辅助类跨这些各种子应用程序）。它还避免了在子应用程序中重复框架代码（即Ext
    JS源代码）的需要。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Sencha Cmd documentation has detailed documentation on workspaces at [http://docs.sencha.com/cmd/5.x/workspaces.html](http://docs.sencha.com/cmd/5.x/workspaces.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd文档在[http://docs.sencha.com/cmd/5.x/workspaces.html](http://docs.sencha.com/cmd/5.x/workspaces.html)有关于工作区的详细文档。
- en: 'Generating a workspace can be done with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令生成工作区：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This simply adds some configuration files for the workspace. The extra magic
    comes when you generate an application for this workspace:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为工作区添加了一些配置文件。当您为该工作区生成应用程序时，额外的魔力就会出现：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The key difference here is that the SDK will be held at the workspace root rather
    than the application root. So, the subapplications will all use the same SDK.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别是 SDK 将位于工作区根目录而不是应用程序根目录。因此，所有子应用程序都将使用相同的 SDK。
- en: 'Alternatively, you can use Sencha Cmd to generate just an application, which
    we''ve already touched on:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 Sencha Cmd 生成一个应用程序，这我们已经提到过：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will build on the standard application template we've used many times before.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基于我们之前多次使用过的标准应用程序模板。
- en: While workspaces are a useful method to organize your code and promote code
    reuse, we're going to focus on single applications for the rest of the book. All
    the ideas we're discussing can be implemented on an application level without
    the distraction of a workspace.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然工作区是组织代码和促进代码重用的有用方法，但我们将在本书的剩余部分专注于单个应用程序。我们讨论的所有想法都可以在应用程序级别实现，而不会受到工作区的干扰。
- en: The generation game
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成游戏
- en: From here, we can quickly build out the skeleton of our application. The key
    MVVM classes are controllers, models, and views (with their associated view controllers
    and view models). Sencha Cmd can assist with quickly creating all of these classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以快速构建我们应用程序的骨架。关键的 MVVM 类包括控制器、模型和视图（及其关联的视图控制器和视图模型）。Sencha Cmd 可以帮助我们快速创建所有这些类。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The generation of code using a command-line tool is often known as "scaffolding"
    and was popularized by Ruby On Rails. For more on the subject, refer to [http://en.wikipedia.org/wiki/Scaffold_(programming)](http://en.wikipedia.org/wiki/Scaffold_(programming)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行工具生成代码通常被称为“脚手架”，并由 Ruby On Rails 流行起来。有关更多内容，请参阅[http://en.wikipedia.org/wiki/Scaffold_(programming)](http://en.wikipedia.org/wiki/Scaffold_(programming))。
- en: 'For controllers, it''s simple:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制器，很简单：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding command produces:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令会产生以下结果：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, the model generator invoked looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模型生成器调用如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MyModel` is the name of the model straightforward. The next parameters allow
    generation of fields in the model (provided as a comma-separated list of `name:type`
    field pairs). In this case, we''re creating two fields: `fullName` of type string
    and `age` of type integer. This gives us the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyModel` 是模型名称的直接表示。下一个参数允许在模型中生成字段（以逗号分隔的 `name:type` 字段对列表提供）。在这种情况下，我们创建了两个字段：`fullName`
    类型为字符串和 `age` 类型为整数。这给我们以下代码：'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, there''s the following view generator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是一个视图生成器：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This creates a few files for us, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们创建几个文件，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this command, as we're creating multiple files, we have the opportunity
    to create a directory and corresponding namespace to contain them. In this case,
    we created the `my` directory at `app/view/my` for these three files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，由于我们正在创建多个文件，我们有创建目录和相应命名空间来包含它们的机遇。在这种情况下，我们在 `app/view/my` 创建了 `my`
    目录以存放这三个文件。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pay attention to the case of names of your models, views, and controllers here.
    Sencha Cmd doesn't do anything special to correct the case to keep with expected
    naming conventions. So, whatever you type will be directly carried over to the
    class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里请注意你模型、视图和控制器名称的大小写。Sencha Cmd 并不会对大小写做特殊处理以保持预期的命名约定。因此，你输入的任何内容都将直接传递到类中。
- en: 'There are two more commands we can run with generate: `theme` and `package`,
    but we''ll cover these in more detail later in [Chapter 9](ch09.html "Chapter 9. A
    Shopping Application"), *A Shopping Application*, when we build a packaged component
    with a custom theme.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 generate 运行两个额外的命令：`theme` 和 `package`，但我们将更详细地介绍这些内容，在[第 9 章](ch09.html
    "第 9 章。购物应用程序")，*购物应用程序*中，当我们使用自定义主题构建打包组件时。
- en: Develop in style
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以风格开发
- en: Now that we're up and running with a Sencha Cmd-powered application, we can
    start to look at the ways Sencha Cmd can ease our ongoing development process.
    These range from generating application metadata to compiling theme files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 Sencha Cmd 驱动的应用程序启动并运行，我们可以开始探讨 Sencha Cmd 可以如何简化我们的持续开发过程。这些包括从生成应用程序元数据到编译主题文件。
- en: Here to serve – a website
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这里提供 – 一个网站
- en: A standard HTML web page can be run directly from your computer without requiring
    a web server. The browser just reads the files directly from your local drive.
    With the increasing popularity of JavaScript-based web applications, browsers
    have introduced a variety of security restrictions to prevent malicious sites
    from reading your local filesystem.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准的HTML网页可以直接从你的电脑上运行，无需Web服务器。浏览器直接从你的本地驱动器读取文件。随着基于JavaScript的Web应用的日益流行，浏览器已经引入了各种安全限制，以防止恶意网站读取你的本地文件系统。
- en: This causes issues with Ext JS because when developing, `Ext.Loader` will dynamically
    load and parse the JavaScript files your application depends on from your application
    directory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了Ext JS的问题，因为在开发时，`Ext.Loader`会从你的应用目录动态加载和解析你的应用所依赖的JavaScript文件。
- en: 'The best way to solve this issue is to simply run your code through a web server
    as the browser normally expects. Fortunately, to avoid having to configure a full-blown
    web server on your development machine, Sencha Cmd gives you a simple way of starting
    up a lightweight server in the current directory. Simply run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最好方法是将你的代码通过Web服务器运行，因为浏览器通常期望这样做。幸运的是，为了避免在开发机器上配置完整的Web服务器，Sencha Cmd为你提供了一个简单的方法来在当前目录中启动一个轻量级服务器。只需运行以下命令：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should get an output along these lines:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似以下的输出：
- en: '![Here to serve – a website](img/5308OT_04_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![这里提供服务 - 一个网站](img/5308OT_04_02.jpg)'
- en: 'And sure enough, visit `http://localhost:1841` in your web browser and your
    application will be ready and waiting:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，在你的网络浏览器中访问`http://localhost:1841`，你的应用将准备就绪并等待：
- en: '![Here to serve – a website](img/5308OT_04_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![这里提供服务 - 一个网站](img/5308OT_04_03.jpg)'
- en: 'Note that we can override the port the server uses. In order to start it on
    port `1999`, we will issue the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以覆盖服务器使用的端口。为了在端口`1999`上启动它，我们将发出以下命令：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Bootstrap process
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap过程
- en: Sencha Cmd's JavaScript compiler isn't just a way of concatenating and minifying.
    It understands your code and will process certain parts in order to simplify dependency
    management.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd的JavaScript编译器不仅仅是合并和压缩。它理解你的代码，并将处理某些部分以简化依赖管理。
- en: For example, a wildcard `requires` option such as `Ext.grid.*` will be expanded
    so that all of the files and classes under `Ext.grid` will be included. Certain
    configuration options, such as controller or ViewModel, will be converted into
    their full class reference. This is the Bootstrap process—the way in which dependency
    information is converted into a list of actual files to be loaded.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个通配符`requires`选项，如`Ext.grid.*`将被展开，以便包括`Ext.grid`下的所有文件和类。某些配置选项，如控制器或ViewModel，将被转换为它们的完整类引用。这就是Bootstrap过程——将依赖信息转换为实际要加载的文件列表的方式。
- en: 'This metadata trickery comes with a small price. In certain situations, you
    need to refresh the Bootstrap data in order for Ext JS to load your application
    successfully. One way of doing this is to run the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种元数据技巧需要付出一点代价。在某些情况下，你需要刷新Bootstrap数据，以便Ext JS能够成功加载你的应用。一种方法是通过运行以下命令：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will quickly rebuild the files needed to Bootstrap your app. However,
    we can go one step further and kill two birds with one stone by running a development
    web server that refreshes the app when needed. It''s as simple as running the
    following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将快速重建启动你的应用所需的文件。然而，我们可以更进一步，通过运行一个在需要时刷新应用的开发Web服务器来一石二鸟。这就像运行以下命令一样简单：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this, we have the same web server functionality as web start combined with
    a process that watches for metadata changes and alterations to Sass files. It
    will automatically rebuild Bootstrap data and CSS when it detects a change.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们拥有了与Web Start相同的功能，并结合了一个监视元数据更改和Sass文件变更的过程。当它检测到变化时，它会自动重建Bootstrap数据和CSS。
- en: Care for the environment
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关心环境
- en: Sencha Cmd supports the concept of environments to allow different behavior
    depending on the stage of your workflow. We've already mentioned that Sencha Cmd
    leverages the power of the Ant build system to allow customization of the process.
    The different environments simply define variables that are consumed by Ant and
    passed into the build process to enable, disable, or amend a part of the build.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd支持环境的概念，允许根据工作流程的阶段有不同的行为。我们已经提到，Sencha Cmd利用Ant构建系统的力量来允许自定义过程。不同的环境只是定义了Ant消费并传递到构建过程中的变量，以启用、禁用或修改构建的一部分。
- en: 'You can see the default build variables by running the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来查看默认的构建变量：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This produces something that includes the following code along with a million
    and one other variables:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一些代码，其中包括以下代码以及成千上万个其他变量：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here the variable `app.output.js` has the value `app.js`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里变量`app.output.js`的值为`app.js`。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that build variables and configuration variables are two separate things.
    Configuration variables are used by Sencha Cmd as a whole, not just the build
    process. We'll only be discussing configuration variables, as they're most commonly
    used and provide the most "bang for your buck". We just don't have space to cover
    every variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构建变量和配置变量是两件不同的事情。配置变量由Sencha Cmd整体使用，而不仅仅是构建过程。我们只将讨论配置变量，因为它们最常用，并且提供了最多的“物有所值”。我们只是没有空间涵盖每个变量。
- en: We're going to take a closer look at environments now. They are used with the
    `app build` subcommand and give us a lot of power to customize our code for production.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更仔细地查看环境。它们与`app build`子命令一起使用，为我们提供了大量自定义生产代码的权力。
- en: The final product
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终产品
- en: 'When creating a production build, we want to make our code as lean as possible,
    removing logging, debugging, and making sure that we compress JavaScript and CSS
    and use all optimizations available. Let''s look at the overrides for the product
    environment:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建生产构建时，我们希望使我们的代码尽可能精简，删除日志、调试，并确保压缩JavaScript和CSS，并使用所有可用的优化。让我们看看产品环境的覆盖设置：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s look at each option in turn, ignoring the comment on the first line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每个选项，忽略第一行的注释：
- en: Disable Ext JS framework logging.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用Ext JS框架日志。
- en: Tell the compiler to remove code designated as debug code.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉编译器删除标记为调试代码的部分。
- en: Use the YUI Compressor to minify the JavaScript code.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用YUI Compressor压缩JavaScript代码。
- en: Enable custom optimizations (such as removing the `requires` option) that are
    no longer needed when the dependency tree is already known. This can result in
    a slightly smaller code base.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用自定义优化（例如删除`requires`选项），当依赖树已知时不再需要。这可能会导致代码库略微减小。
- en: Generate an HTML cache manifest file. This instructs the browser to cache the
    application's `index.html` file to reduce network activity.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个HTML缓存清单文件。这指示浏览器缓存应用程序的`index.html`文件以减少网络活动。
- en: Compress the CSS files and other resources.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩CSS文件和其他资源。
- en: Compress the "microloader" JavaScript that boots our application.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩启动我们应用程序的"microloader" JavaScript。
- en: Along with the huge range of other configuration options, we have a mechanism
    to tailor our final build to suit our needs. For tracking production issues, you
    may wish to enable logging to the browser console, so you can toggle this option.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了大量的其他配置选项之外，我们还有一个机制来定制我们的最终构建以满足我们的需求。为了跟踪生产问题，您可能希望启用将日志记录到浏览器控制台，以便您可以切换此选项。
- en: You could even create a custom environment that skips parts of the build for
    a quicker process. It's worth poring through the output that `sencha ant .props`
    creates in order to see where you can tailor the process for the needs of your
    team.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以创建一个自定义环境，跳过构建的部分以加快过程。查看`sencha ant .props`创建的输出，以了解您可以为团队的需求定制过程的地方是值得的。
- en: Before the build
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建之前
- en: Back in [Chapter 3](ch03.html "Chapter 3. Application Structure"), *Application
    Structure*, we touched on the `build.xml` file that Sencha Cmd generates as part
    of an application template. Now, we'll take a closer look to see how we can use
    this file to hook into the build process and leverage it for our own purposes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第3章](ch03.html "第3章。应用程序结构")，*应用程序结构*，我们提到了Sencha Cmd作为应用程序模板的一部分生成的`build.xml`文件。现在，我们将更仔细地查看，看看我们如何使用此文件来挂钩构建过程并利用它来实现我们的目的。
- en: 'We''ve already mentioned that Sencha Cmd uses Ant, an XML-based build system
    at its core. A key concept of Ant is that of "targets", a term that describes
    a bundle of tasks that perform a part of the build process from the Ant manual:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到Sencha Cmd使用Ant，这是一个基于XML的构建系统，作为其核心。Ant的一个关键概念是“目标”，这是一个术语，描述了一组执行构建过程一部分的任务，如Ant手册中所述：
- en: '*"A target is a container of tasks that cooperate to reach a desired state
    during the build process."*'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"目标是在构建过程中协同完成任务以达到期望状态的容器。"*'
- en: In our case, Sencha Cmd comes with a set of pre-existing targets that we can
    use to hook into various parts of the build process. The `build.xml` file contains
    stubs for these targets as well as some comments on what they do. We're going
    to hook into one of these and implement a task that will halt the build process
    if certain conditions are not met.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'When we discussed the role of the architect, we speculated that there may be
    a requirement to enforce coding standards on the development team. We can use
    automated tools to make sure that best practice is used in a code base. Here,
    we''ll use JSHint: a JavaScript code quality tool.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Ant is widely used and, as such, has many community-created additions. For JSHint,
    developer Phil Mander has created a task to use it in an Ant target. For more
    information, refer to [https://github.com/philmander/ant-jshint](https://github.com/philmander/ant-jshint).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to download the Java JAR containing the new task at [http://git.io/VSZvRQ](http://git.io/VSZvRQ).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: I simply placed it in the application root along with the `build.xml` file,
    but if you've got a lot of extra tasks, it's definitely worth creating a new directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now configure our `build.xml` file to use this new task as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are several steps to hook up this new task:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Add a `taskdef` element to make Ant aware of the `ant-jshint` task
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the target element with a name `–before-build`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `jshint` element configured as per the documentation on GitHub
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's only one really special thing to note about the way we've configured
    the JSHint task and that's the need to add Ext to the `globals` setting. As `ant-jshint`
    hasn't been told where the Ext JS framework is, we tell it to assume that a global
    variable called Ext is defined elsewhere.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We can now run `sencha app build` again and JSHint will parse through our code
    and check it against its rule set. If our code doesn't pass, the whole build will
    fail and a file called `jshint.out` will be created in the root of our application
    and will show the details of any JSHint errors and the lines on which they occurred.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: With only ten minutes work, we've already created a low-friction method of ensuring
    buggy or low-quality code is less likely to reach production.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just one example of a prebuild check. You could also:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Run a test suite
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run code-complexity checks
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By preventing a build from being created if these checks don't pass, you're
    enforcing a standard way of working across the board and forcing developers to
    check all of the little things that go towards creating a quality product.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Code complete
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once our quality checks have passed, we want to look at deploying the application.
    Again, we have an opportunity to codify some practices to make sure your team
    performs the same actions time and time again.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set out a typical process that represents a deployment to production:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Quality checks such as tests and coding standards.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minification and other optimization.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bump the application version number.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提高应用程序版本号。
- en: Push to production server.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送到生产服务器。
- en: Number one was taken care of by our `before-init` step. Minification and optimization
    is taken care of by Sencha Cmd's build-in tasks. We're left with three tasks that
    we'd like to complete before pushing to production, so we'll look at them in turn,
    but first, let's have a brief interlude and talk about Ant.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是由我们的`before-init`步骤处理的。压缩和优化由Sencha Cmd的内置任务处理。我们剩下三个任务需要在推送到生产之前完成，所以我们将依次查看它们，但首先，让我们有一个简短的休息，并谈谈Ant。
- en: An application for Ant
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ant的应用程序
- en: In effect, the next few pages are a tutorial for Ant, rather than Sencha Cmd
    or application architecture. There are many, many resources for Ant online and
    in print form, so why go over old ground?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，接下来的几页是Ant的教程，而不是Sencha Cmd或应用程序架构。网上和印刷形式中有很多关于Ant的资源，那么为什么还要重复旧的内容呢？
- en: Remember that this book isn't a list of facts and figures or code listings to
    type in line by line. It's supposed to get the brain thinking about the application
    from a top-down perspective and see how you can help your team build a strong
    product for your client.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这本书不是事实和数字的列表或逐行输入的代码列表。它旨在从自上而下的角度思考应用程序，并了解你如何帮助你的团队为客户构建一个强大的产品。
- en: An architect isn't just there to draw pictures of the house. They are there
    to make sure a beautiful house is built and the homeowner walks away happy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个建筑师不仅仅是为了画房子的图片。他们是为了确保建造了一座美丽的房子，房主离开时感到高兴。
- en: Version numbers
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本号
- en: Back to Ant. There are multiple reasons why you want to label an application
    with a build or version number—a key one is to let stakeholders know the version
    they're reviewing to see whether it contains the bug fixes they'd expect.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Ant。你想要用构建或版本号标记应用程序的多个原因之一是让利益相关者知道他们正在审查的版本，以查看它是否包含他们预期的错误修复。
- en: 'Versioning the application is a two-step process:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序版本化是一个两步过程：
- en: Generate a new build number.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个新的构建号。
- en: Insert it in a JavaScript file for display on the UI.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其插入JavaScript文件以在UI上显示。
- en: 'Ant provides a task to make step one fairly simple:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Ant提供了一个任务，使第一步变得相当简单：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use the `propertyfile` task to specify that a file called `app.properties`
    will contain an entry called `build.number`. Every time we run the task, it triggers
    an operation to increment `thisentry` by one as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`propertyfile`任务指定一个名为`app.properties`的文件将包含一个名为`build.number`的条目。每次我们运行任务时，它都会触发一个操作，将`thisentry`增加一，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we read the `app.properties` file to understand how to use the property
    task, which makes the properties it contains available to further tasks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们读取`app.properties`文件，了解如何使用属性任务，该任务使它包含的属性可用于后续任务。
- en: 'Finally, we do a search and replace in the generated JS for a `{VERSION}` token
    and replace it with the `build.number` property. Let''s see it as a full `build.xml`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在生成的JS文件中对`{VERSION}`令牌进行搜索和替换，并将其替换为`build.number`属性。让我们看看完整的`build.xml`：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that we''re using the `after-page` target as a hook. This fires after
    Sencha Cmd has assembled all of the application''s dependencies and created a
    single file to contain them. This is the file we do our search and replace on,
    which means that our original source files remain intact. You could have a JavaScript
    file such as this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`after-page`目标作为钩子。这个钩子在Sencha Cmd组装完所有应用程序的依赖项并创建一个包含它们的单个文件之后触发。这是我们进行搜索和替换的文件，这意味着我们的原始源文件保持完好。你可以有一个像这样的JavaScript文件：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Also, the `{VERSION}` token would be replaced, enabling you to use the version
    number across your application, perhaps in a footer or an **About** screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`{VERSION}`令牌将被替换，使你能够在整个应用程序中使用版本号，也许在页脚或**关于**屏幕上。
- en: From release to production
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从发布到生产
- en: 'Our code is neat and tidy, we know what version we''re releasing. The next
    step is to push it to a production server. We''ll use SFTP to transfer files to
    a remote server:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码整洁有序，我们知道我们正在发布哪个版本。下一步是将它推送到生产服务器。我们将使用SFTP将文件传输到远程服务器：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use the `afterbuild` target, which means that all other aspects of the build
    are complete and the final production files have been built. As it's a really
    bad idea to hardcode security credentials, we use the input task to request input
    from the user on the command line. The resulting input gets assigned to the property
    specified in `addproperty`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`afterbuild`目标，这意味着构建的所有其他方面都已完成，最终的生产文件也已构建。由于硬编码安全凭证是一个非常糟糕的主意，我们使用输入任务从命令行请求用户输入。结果输入被分配给`addproperty`中指定的属性。
- en: The `scp` task's `remoteToDir` attribute should be customized according to your
    needs, but the `scp.username` and `scp.password` values will be filled with the
    previous user input. In the `fileset` task, we specify that the whole `build/production`
    directory will be pushed up to the remote server.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`scp`任务的`remoteToDir`属性应根据您的需求进行定制，但`scp.username`和`scp.password`的值将填充之前用户输入的内容。在`fileset`任务中，我们指定将整个`build/production`目录推送到远程服务器。'
- en: We've shown how we can leverage the power of Ant to hook into key aspects of
    the Sencha Cmd build process, converting error-prone manual tasks to automated
    ones that can be easily shared with your development team.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何利用Ant的力量钩入Sencha Cmd构建过程的关键方面，将容易出错的手动任务转换为可以轻松与开发团队共享的自动化任务。
- en: The best of the rest
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其余最佳选择
- en: We've barely touched the surface of what Sencha Cmd can do. We're looking at
    Sencha Cmd from the perspective of a highly interested architect, but an architect
    needs a strong awareness of the full stack of tools available to their developers.
    Let's do a whistle-stop tour of some of the features that Ext JS developers can
    use to ease their work on the details of an application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了Sencha Cmd能做什么的表面。我们从一个高度感兴趣的架构师的角度来看Sencha Cmd，但架构师需要对其开发者可用的完整工具栈有强烈的认识。让我们快速浏览一下Ext
    JS开发者可以使用的一些功能，以简化他们在应用程序细节上的工作。
- en: Packages
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: Packages are a way of reusing code between projects. Sencha Cmd and Ext JS recognize
    packages as fleshed out concepts in the Sencha ecosystem, so developers should
    be aware that they're available for use. The workspace concept, which we discussed
    earlier, assists with development of packages, but they can be consumed at the
    application level, providing a tidy bundle of CSS, JavaScript, and other resources
    for an app to consume from a local or remote source.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 包是在项目之间重用代码的一种方式。Sencha Cmd和Ext JS将包视为Sencha生态系统中的具体概念，因此开发者应该意识到它们可供使用。我们之前讨论的工作空间概念有助于包的开发，但它们可以在应用级别进行消费，为应用提供一个整洁的CSS、JavaScript和其他资源的捆绑包，以便从本地或远程源使用。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Sencha documentation at [http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html](http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html)
    provides instructions on creating packages.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html](http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html)的Sencha文档提供了创建包的说明。
- en: At an enterprise level, packages are a key method to provide reusable logic
    and user interface elements that can be shared between teams. Code reuse is something
    that needs to be considered at an architectural level to avoid reinventing the
    wheel, so packages can be an important tool when looking at the bigger picture.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业层面，包是提供可重用逻辑和用户界面元素的关键方法，这些元素可以在团队之间共享。代码重用需要在架构层面考虑，以避免重复造轮子，因此当考虑大局时，包可以是一个重要的工具。
- en: Themes
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题
- en: 'There are two approaches to working with CSS and images in Ext JS: first there''s
    the full-blown theme option in which you create a package of images, Sass files,
    and JavaScript customization to build an entirely bespoke look and feel for your
    application. In many cases, some minor tweaks to the standard Ext JS components
    combined with some extra styles for your own UI elements are all that are needed.
    In this case, Sencha Cmd provides `sencha compass compile` to transform Sass files
    into CSS that is included in your app. Don''t forget that `sencha app watch` also
    takes care of this step automatically.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS中处理CSS和图像有两种方法：首先是有完整主题选项，您创建一个包含图像、Sass文件和JavaScript定制的包，为您的应用程序构建一个完全定制的视觉和感觉。在许多情况下，只需要对标准Ext
    JS组件进行一些微调，以及为您的UI元素添加一些额外样式就足够了。在这种情况下，Sencha Cmd提供`sencha compass compile`将Sass文件转换为包含在您的应用程序中的CSS。别忘了`sencha
    app watch`也会自动处理这一步骤。
- en: Compilations
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: Command's build process relies on a subcommand called compile, which is responsible
    for parsing the files that make up your application. This subcommand can be invoked
    independently and could be used to create a list of application dependencies that
    could be further processed by tools other than Sencha Cmd.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的构建过程依赖于一个名为 compile 的子命令，该子命令负责解析构成您应用程序的文件。这个子命令可以独立调用，并且可以用来创建一个应用程序依赖项列表，该列表可以被
    Sencha Cmd 以外的工具进一步处理。
- en: In the greater JavaScript ecosystem, there are a growing number of build tools
    (such as Grunt and Gulp) that your developers may be more familiar with. By using
    a small portion of Sencha Cmd's features, your team could continue to leverage
    these tools while working with the Ext JS framework.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的 JavaScript 生态系统内，开发者可能更熟悉的构建工具（如 Grunt 和 Gulp）的数量正在增长。通过使用 Sencha Cmd 的一小部分功能，您的团队可以在使用
    Ext JS 框架的同时继续利用这些工具。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Standards and process are key responsibilities of a software architect and Sencha
    Cmd is an indispensable tool to help fulfill these responsibilities. We saw how
    it can touch all parts of the application lifecycle, from quickly getting up and
    running with a template to bolting on segments of a developing code base, to creating
    a final optimized product.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 标准和流程是软件架构师的关键职责，而 Sencha Cmd 是帮助履行这些职责的不可或缺的工具。我们看到了它如何触及应用程序生命周期的各个部分，从快速使用模板启动到将开发代码库的各个部分连接起来，再到创建一个最终优化的产品。
- en: More than this, the various hooks with Sencha Cmd provides flexibility. It works
    with you and your team to help ease the development process and save time that
    would otherwise be wasted with manual tasks.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，Sencha Cmd 提供的各种钩子提供了灵活性。它与您和您的团队合作，帮助简化开发过程并节省本可以浪费在手动任务上的时间。
- en: In the next few chapters, we'll look at how we can piece together everything
    we've learned so far about Ext JS application architecture and use some practical
    examples to further demonstrate how to build fantastic products for your clients.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将探讨如何将我们迄今为止关于 Ext JS 应用程序架构所学的所有内容拼凑起来，并使用一些实际例子进一步展示如何为客户构建出色的产品。
