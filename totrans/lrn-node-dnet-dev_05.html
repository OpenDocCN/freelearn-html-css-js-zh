<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Creating Dynamic Websites</h1></div></div></div><p>Now that we have established a basic structure for our application, we can start to add more functionality and build a dynamic website that responds to user input.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Adding a new module to our application for storing and deleting data</li><li class="listitem">Exposing a JSON API to handle user-submitted data</li><li class="listitem">Implementing communication between the client and server using Ajax</li><li class="listitem">Building up more complex HTML views using partial templates</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Handling user-submitted data</h1></div></div></div><p>We're going to implement the <a id="id155" class="indexterm"/>classic guessing game of Hangman (see <a class="ulink" href="https://en.wikipedia.org/wiki/Hangman_(game)">https://en.wikipedia.org/wiki/Hangman_(game)</a>). Users will be able to post new words to guess, and to guess words posted by others. We'll look at creating new<a id="id156" class="indexterm"/> games first.</p><p>First, we'll <a id="id157" class="indexterm"/>add a new module for managing our games. For now, we'll just store our games in the memory. If we want to put games in some persistent storage in future, this is the module we will change. The interface (that is, the functions added to <code class="literal">module.exports</code>) can remain the same though.</p><p>We add the following code under <code class="literal">services/games.js</code>:</p><div><pre class="programlisting">'use strict';

const games = [];
let nextId = 1;

class Game {
    constructor(id, setBy, word) {
        this.id = id;
        this.setBy = setBy;
        this.word = word.toUpperCase();
    }
}

module.exports.create = (userId, word) =&gt; {
    const newGame = new Game(nextId++, userId, word); 
    games.push(newGame);
    return newGame;
}

module.exports.get =
  (id) =&gt; games.find(game =&gt; game.id === parseInt(id, 10));</pre></div><p>Now let's go <a id="id158" class="indexterm"/>through our application from the top down. In <a id="id159" class="indexterm"/>our index view (<code class="literal">views/index.hjs</code>), we'll add simple a HTML form for creating a new game.</p><div><pre class="programlisting">  &lt;body&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
<strong>    &lt;form action="/games" method="POST"&gt;</strong>
<strong>      &lt;input type="text" name="word"</strong>
<strong>             placeholder="Enter a word to guess..." /&gt;</strong>
<strong>      &lt;input type="submit" /&gt;</strong>
<strong>    &lt;/form&gt;</strong>
  &lt;body&gt;</pre></div><p>When submitted, this form will make a POST request to <code class="literal">/games</code>. At the moment, this would return a 404 error since we have nothing mounted at that route  (you can try this in a browser it if you like). We can add a new games route to handle this request. We add the following code under <code class="literal">routes/games.js</code>:</p><div><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const service = require('../services/games');

router.post('/', function(req, res, next) {
    const word = req.body.word;
    if (word &amp;&amp; /^[A-Za-z]{3,}$/.test(word)) {
        service.create(req.user.id, word);
        res.redirect('/');
    } else {
        res.status(400).send('Word must be at least three characters long and contain only letters');
    }
});

module.exports = router;</pre></div><p>There is quite a lot going on in our new routing middleware:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">router.post</code> creates a handler for an HTTP POST request.</li><li class="listitem"><code class="literal">req.body</code> contains form values, thanks to the <code class="literal">bodyParser</code> middleware in <code class="literal">app.js</code>.</li><li class="listitem"><code class="literal">req.user.id</code> contains the current user, thanks to our users middleware.</li><li class="listitem"><code class="literal">res.redirect()</code> issues a redirect to reload the page. It is important to always issue a redirect after a successful POST request. This avoids duplicate form submissions.</li><li class="listitem"><code class="literal">res.status()</code> sets an alternative HTTP status code for the response, in this case a 400 for a validation failure.</li></ul></div><p>Our route<a id="id160" class="indexterm"/> looks for a field named <code class="literal">word</code> in the request body. It then checks this field is defined and not empty (both undefined and the empty<a id="id161" class="indexterm"/> string are <em>falsey</em> in JavaScript, so they behave as false in conditional tests). It also checks that the field matches a regular expression specifying our validity rule.</p><p>Finally, the route makes use of our service module to actually create the new game. It is common practice for routing middleware to delegate application logic to other modules. Its main responsibility is to define the HTTP interface of the application. Other modules are responsible for implementing the actual application logic. In this way, our routes and middleware are comparable to controllers in MVC frameworks.</p><p>We also need to mount this route at the <code class="literal">/games </code>path. The following code is from <code class="literal">app.js</code>:</p><div><pre class="programlisting">var routes = require('./routes/index');
<strong>var games = require('./routes/games');</strong>
...
app.use('/', routes);
<strong>app.use('/games', games);</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Communicating via Ajax</h1></div></div></div><p>Having <a id="id162" class="indexterm"/>created a game, we need a way of playing it. Since<a id="id163" class="indexterm"/> the whole point of a guessing game is that the word is secret, we don't want to send the whole word to the client. Instead, we just want to let clients know the length of the word and provide a way for them to verify their guesses.</p><p>To do this, we'll first need to expand our games service module:</p><div><pre class="programlisting">class Game {
    constructor(id, setBy, word) {
        this.id = id;
        this.setBy = setBy;
        this.word = word.toUpperCase();
    }
    
<strong>    positionsOf(character) {</strong>
<strong>        let positions = [];</strong>
<strong>        for (let i in this.word) {</strong>
<strong>            if (this.word[i] === character.toUpperCase()) {</strong>
<strong>                positions.push(i);</strong>
<strong>            }</strong>
<strong>        }</strong>
<strong>        return positions;</strong>
<strong>    }</strong>
}</pre></div><p>Now we<a id="id164" class="indexterm"/> can add two new routes to our games <a id="id165" class="indexterm"/>route:</p><div><pre class="programlisting">const checkGameExists = function(id, res, callback) {
    const game = service.get(id);
    if (game) {
        callback(game);
    } else {
        res.status(404).send('Non-existent game ID');
    }
}

router.get('/:id', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; res.render('game', {
            length: game.word.length,
            id: game.id
        }));
});

router.post('/:id/guesses', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; {
            res.send({
                positions: game.positionsOf(req.body.letter)
            });
        }
    );
});</pre></div><p>These two routes make use of a shared function for retrieving the game and returning a 404 status code if it does not exist. The GET handler renders a view, as with our index route. The <a id="id166" class="indexterm"/>POST handler calls <code class="literal">res.send()</code>, passing in a<a id="id167" class="indexterm"/> JavaScript object. Express will automatically turn this into a JSON response to the client. This makes it very easy to build JSON-based APIs in express.</p><p>We'll now create a view and client-side script for communicating with this API. We add the following code under <code class="literal">views/game.hjs</code>:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hangman - Game #{{id}}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
    &lt;script src="img/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="img/game.js"&gt;&lt;/script&gt;
    &lt;base href="/games/{{ id }}/"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hangman - Game #{{id}}&lt;/h1&gt;
    &lt;h2 id="word" data-length="{{ length }}"&gt;&lt;/h2&gt;
    &lt;p&gt;Press letter keys to guess&lt;/p&gt;
    &lt;h3&gt;Missed letters:&lt;/h3&gt;
    &lt;p id="missedLetters"&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>We add the following code under <code class="literal">public/scripts/game.js</code>:</p><div><pre class="programlisting">$(function() {
    'use strict';
    
    var word = $('#word');
    var length = word.data('length');
    
    // Create placeholders for each letter
    for (var i = 0; i &lt; length; ++i) {
        word.append('&lt;span&gt;_&lt;/span&gt;');
    }
    
    var guessedLetters = [];
    var guessLetter = function(letter) {
        $.post('guesses', { letter: letter })
            .done(function(data) {
                if (data.positions.length) {
                    data.positions.forEach(function(position) {
                        word.find('span').eq(position).text(letter);
                    });
                } else {
                    $('#missedLetters')
                        .append('&lt;span&gt;' + letter + '&lt;/span&gt;');
                }
            });
    }
    
    $(document).keydown(function(event) {
        // Letter keys have key codes in the range 65-90
        if (event.which &gt;= 65 &amp;&amp; event.which &lt;= 90) {
            var letter = String.fromCharCode(event.which);
            if (guessedLetters.indexOf(letter) === -1) {
                guessedLetters.push(letter);
                guessLetter(letter);
            }
        }
    });
});</pre></div><p>Note that in the<a id="id168" class="indexterm"/> client-side script we drop back to<a id="id169" class="indexterm"/> the ECMAScript 5 standard (for example, <code class="literal">var</code> instead of <code class="literal">let</code>, and no arrow function). This ensures the widest possible compatibility. The latest versions of all mainstream browsers would support the elements of ES2015 syntax that we've been using so far though.</p><p>Also note that we don't have Node.js modules available on the client side. We fall back to wrapping our code in a function to isolate the scope. We'll look at ways to make client-side code more modular in a later chapter.</p><p>Our client-side script uses jQuery. We won't go into detail on client-side frameworks, but it's worth quickly explaining the features used here. The jQuery library provides a consistent API for DOM manipulation that works across all browsers, as well as a number of useful tools for client-side functionality.</p><p>The main jQuery API is available through the <code class="literal">$</code> object, which is a function. The first thing our script does is call <code class="literal">$</code> and pass it a callback, which jQuery will execute once the page has finished loading. Our other calls to <code class="literal">$</code> pass in a string or a DOM element. Strings are interpreted as a CSS selector for choosing elements. In both cases, <code class="literal">$</code> returns a wrapper around a set of DOM elements with some useful methods, for example:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">data</code> method allows us to read the elements' <code class="literal">data-</code> attributes</li><li class="listitem">The <code class="literal">append</code> method allows us to add new child elements</li><li class="listitem">Methods such as <code class="literal">keydown</code> allow us to bind handler functions for events</li></ul></div><p>There<a id="id170" class="indexterm"/> are also some utility methods defined on the <code class="literal">$</code> object itself. These are more like static methods and don't relate to a specific DOM element. The <code class="literal">post()</code> method is an example of this.</p><p>Our script <a id="id171" class="indexterm"/>uses jQuery's <code class="literal">post()</code> method to issue an Ajax POST request. This returns an object with a <code class="literal">done()</code> method, to which we can pass a callback to be executed when the request completes. Here, we can make use of the JSON data returned by our API. In this case, we fill in any positions that match our guessed letter.</p><p>If we run the application at this point, we have a (very) minimal working game. First, visit <code class="literal">http://localhost:3000/</code> and create a new game by submitting a valid word. Then visit <code class="literal">http://localhost:3000/games/1</code> to play. It should look something like the following:</p><div><img src="img/image00215.jpeg" alt="Communicating via Ajax"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Implementing other data operations</h1></div></div></div><p>So far, we<a id="id172" class="indexterm"/> have seen how to create or retrieve a single game, or submit a single guess for a game. Applications also commonly need to list data or delete entries. The principles here are much the same as we've seen already. But to<a id="id173" class="indexterm"/> implement these operations, we'll need some new syntax.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Listing data in views</h2></div></div></div><p>Let's first allow<a id="id174" class="indexterm"/> users to see a list of games they've created or that have been created by others. Our chosen view engine, Hogan, is based on Mustache, which has a very simple syntax for displaying lists. We can add these two lists to our <code class="literal">index.hjs</code> view, as follows:</p><div><pre class="programlisting">    &lt;h2&gt;Games created by you&lt;/h2&gt;
    &lt;ul id="createdGames"&gt;
      {{#createdGames}}
        &lt;li&gt;{{word}}&lt;/li&gt;
      {{/createdGames}}
    &lt;/ul&gt;
    &lt;h2&gt;Games available to play&lt;/h2&gt;
    &lt;ul id="availableGames"&gt;
      {{#availableGames}}
        &lt;li&gt;&lt;a href="/games/{{id}}"&gt;#{{id}}&lt;/a&gt;&lt;/li&gt;
      {{/availableGames}}
    &lt;/ul&gt;</pre></div><p>In order to populate these lists, we'll need a couple of new methods in our <code class="literal">games.js</code> service module:</p><div><pre class="programlisting">module.exports.createdBy =
  (userId) =&gt; games.filter(game =&gt; game.setBy === userId);

module.exports.availableTo =
  (userId) =&gt; games.filter(game =&gt; game.setBy !== userId);</pre></div><p>Finally, we'll need to expose these to our index view from our route:</p><div><pre class="programlisting">var express = require('express');
var router = express.Router();
<strong>var games = require('../services/games');</strong>

router.get('/', function(req, res, next) {
  res.render('index', {
    title: 'Hangman',
    userId: req.user.id,
<strong>    createdGames: games.createdBy(req.user.id),</strong>
<strong>    availableGames: games.availableTo(req.user.id)</strong>
  });
});

module.exports = router;</pre></div><p>Now, our<a id="id175" class="indexterm"/> index page shows games created by the current user and provides convenient links to games created by others. You can experiment with this functionality by using two separate browser sessions again to visit <code class="literal">http://localhost:3000</code>. The result should look something like the following:</p><div><img src="img/image00216.jpeg" alt="Listing data in views"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Issuing a delete request from the client</h2></div></div></div><p>To allow<a id="id176" class="indexterm"/> users to remove games that they have created, we'll first need to add a method to our Game class:</p><div><pre class="programlisting">class Game {
    constructor(id, setBy, word) {
        this.id = id;
        this.setBy = setBy;
        this.word = word.toUpperCase();
    }
    
    positionsOf(character) {
        let positions = [];
        for (let i in this.word) {
            if (this.word[i] === character.toUpperCase()) {
                positions.push(i);
            }
        }
        return positions;
    }
    
<strong>    remove() {</strong>
<strong>        games.splice(games.indexOf(this), 1);</strong>
<strong>    }</strong>
}</pre></div><p>Next we <a id="id177" class="indexterm"/>can create a new handler for <code class="literal">delete</code> requests in our games route:</p><div><pre class="programlisting">router.delete('/:id', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; {
            if (game.setBy === req.user.id) {
                game.remove();
                res.send();
            } else {
                res.status(403).send(
                    'You don't have permission to delete this game'
                );
            }
        }
    );
});</pre></div><p>Finally, we can make use of this from the client. The following code is from <code class="literal">views/index.hjs</code>:</p><div><pre class="programlisting">  &lt;head&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
<strong>    &lt;script src="img/jquery.min.js"&gt;&lt;/script&gt;</strong>
<strong>    &lt;script src="img/index.js"&gt;&lt;/script&gt;</strong>
  &lt;/head&gt;

  ...

      {{#createdGames}}
<strong>        &lt;li class="game"&gt;</strong>
<strong>          {{word}}</strong>
<strong>          &lt;a class="delete" href="/games/{{id}}"&gt;(delete)&lt;/a&gt;</strong>
<strong>        &lt;/li&gt;</strong>
      {{/createdGames}}</pre></div><p>We add the following code under <a id="id178" class="indexterm"/>
<code class="literal">public/scripts/index.js</code>:</p><div><pre class="programlisting">$(function() {
    'use strict';
    
    $('#createdGames').on('click', '.delete', function() {
        var $this = $(this);
        $.ajax($this.attr('href'), {
            method: 'delete'
        }).done(function() {
            $this.closest('.game').remove();
        });
        event.preventDefault();
    });
});</pre></div><p>Note that, unlike GET and POST, jQuery has no convenience function for <code class="literal">delete</code> requests. So we drop back to the lower level <code class="literal">.ajax()</code> function and specify the HTTP method explicitly.</p><p>If you visit the application in a browser and create a new game again, you should now see a link to delete the game.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Splitting up Express views using partials</h2></div></div></div><p>Deleting <a id="id179" class="indexterm"/>a game does not cause the page to<a id="id180" class="indexterm"/> refresh, but creating a new game does. We can fix this by creating games via an Ajax call, consistent with how we delete games. In order for this to work, the client-side script that handles the call needs to know which HTML to add to the page when a new game is created.</p><p>We could repeat the HTML structure of the view within the client-side JavaScript. However, it would be better for the server to return the correct HTML fragment, and to reuse the same template for this as it uses it to render the list on the page initially.</p><p>We can do this by splitting the HTML structure for a game within the list into a partial view. This is a view template for an HTML fragment rather than a complete page. We add the following code under <code class="literal">views/createdGame.hjs</code>:</p><div><pre class="programlisting">&lt;li class="game"&gt;
  {{word}}
  &lt;a class="delete" href="/games/{{id}}"&gt;(delete)&lt;/a&gt;
&lt;/li&gt;</pre></div><p>With the <a id="id181" class="indexterm"/>view engine that we're using (Hogan), we <a id="id182" class="indexterm"/>need to let views know about available partials when rendering them (other view engines allow partials to be resolved automatically). The following code is from <code class="literal">routes/index.js</code>:</p><div><pre class="programlisting">  res.render('index', {
    title: 'Hangman',
    userId: req.user.id,
    createdGames: games.createdBy(req.user.id),
    availableGames: games.availableTo(req.user.id),
<strong>    partials: { createdGame: 'createdGame' }</strong>
  });</pre></div><p>We can use the partial within our main view as follows. We'll also add IDs to our HTML elements, which we will reference from our client-side JavaScript shortly. The following code is from <code class="literal">views/index.hjs</code>:</p><div><pre class="programlisting"><strong>    &lt;form action="/games" method="POST" id="createGame"&gt;</strong>
<strong>      &lt;input type="text" name="word" id="word"</strong>
             placeholder="Enter a word to guess..." /&gt;
      &lt;input type="submit" /&gt;    &lt;/form&gt;
    &lt;h2&gt;Games created by you&lt;/h2&gt;  
    &lt;ul id="createdGames"&gt;
      {{#createdGames}}
<strong>        {{&gt; createdGame}}</strong>
      {{/createdGames}}
    &lt;/ul&gt;</pre></div><p>Now we can update our games route to return only this fragment to the client when creating a new game. The following code is from <code class="literal">routes/games.js</code>:</p><div><pre class="programlisting">router.post('/', function(req, res, next) {
    let word = req.body.word;
    if (word &amp;&amp; /^[A-Za-z]{3,}$/.test(word)) {
        const game = service.create(req.user.id, word); 
<strong>        res.redirect(`/games/${game.id}/created`);</strong>
    } else {
        ...
    }
});
...
<strong>router.get('/:id/created', function(req, res, next) {</strong>
<strong>    checkGameExists(</strong>
<strong>        req.params.id,</strong>
<strong>        res,</strong>
<strong>        game =&gt; res.render('createdGame', game));</strong>
});</pre></div><p>Finally, we <a id="id183" class="indexterm"/>can make use of this in our client-side<a id="id184" class="indexterm"/> script. The following code is from <code class="literal">public/scripts/index.js</code>:</p><div><pre class="programlisting">$(function() {
  'use strict';    
<strong>  $('#createGame').submit(function(event) {</strong>
<strong>    $.post($(this).attr('action'), { word: $('#word').val() },</strong>
<strong>      function(result) {</strong>
<strong>        $('#createdGames').append(result);</strong>
<strong>      });</strong>
<strong>   event.preventDefault();</strong>
<strong>  });</strong>
  ...
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we have started building out our own application by creating new middleware and service modules. We've read user-submitted data from forms and acted on it. We've implemented a JSON API on the server side and communicated with this from the client using Ajax. We've used partial views to render common components.</p><p>So far, we've seen how to write JavaScript code and implement various functionality in Node.js. This is good for prototyping, but isn't enough for a maintainable project. It's also important to write automated tests for our code, which is the subject of the next chapter.</p></div></body></html>