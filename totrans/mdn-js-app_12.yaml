- en: Chapter 12. New Features of Angular 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 Angular 2的新特性
- en: Angular 1 was based on the MVC architecture whereas Angular 2 is based on a
    components-and-services architecture. Angular 1 and Angular 2 are completely different
    in terms of architecture and APIs, so previous knowledge of Angular 1 is unlikely
    to help you much in learning Angular 2\. In this chapter, we will learn Angular
    2 without comparing it with Angular 1 as doing that will create confusion and
    is unnecessary. Even if you don't have knowledge about Angular 1, you can continue
    with this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1基于MVC架构，而Angular 2基于组件和服务架构。Angular 1和Angular 2在架构和API方面完全不同，因此对Angular
    1的了解不太可能对学习Angular 2有很大帮助。在本章中，我们将学习Angular 2，而不将其与Angular 1进行比较，因为这样做会引发混淆，且不必要。即使你没有Angular
    1的知识，你也可以继续本章。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Web components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web组件
- en: The Angular 2 architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2架构
- en: Template language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板语言
- en: Component inputs and outputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件输入和输出
- en: The component life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: Services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: And much more...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The Angular 2 architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2架构
- en: Angular 2 is a framework for building the client side of web applications, based
    on a services-and-components architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2是一个基于服务和组件架构构建Web应用程序客户端的框架。
- en: An Angular 2 application is composed of a view and various services. Services
    are simple JavaScript objects that hold application logic and state. Services
    should be reusable. Views consume services, and services can also interact with
    each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular 2应用程序由视图和各种服务组成。服务是简单的JavaScript对象，包含应用程序逻辑和状态。服务应该是可重用的。视图消费服务，服务也可以相互交互。
- en: Views and services are loosely coupled so that an Angular 2 view can be used
    with any other architecture, such as Flux. Similarly, services can be used with
    any other view, such as React.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和服务松散耦合，因此Angular 2视图可以与任何其他架构一起使用，例如Flux。同样，服务可以与任何其他视图一起使用，例如React。
- en: Angular 2 views are based on component-oriented architecture. In component-oriented
    architecture, the application UI is divided into reusable components. A component
    has a UI with code to update the UI and handle user actions on the UI. A custom
    tag is associated with a component, and whenever the custom tag appears, a new
    instance of the component is created and rendered. So, we can say that component-oriented
    architecture is architecture for the view of an application. Actually, the components
    consume the services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2视图基于面向组件的架构。在面向组件的架构中，应用程序UI被划分为可重用组件。一个组件具有一个UI，其中包含更新UI和处理UI上用户操作的代码。一个自定义标签与一个组件相关联，每当自定义标签出现时，就会创建并渲染该组件的新实例。因此，我们可以说面向组件的架构是应用程序视图的架构。实际上，组件消耗服务。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous two chapters, we studied React, which is also based on component-oriented
    architecture, since with React, we build an application as a set of components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，我们学习了React，它也是基于面向组件的架构，因为使用React，我们构建应用程序作为一组组件。
- en: 'Here is a diagram from the official Angular 2 website ([https://angular.io](https://angular.io))
    that shows the complete architecture of Angular 2:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自官方Angular 2网站的图表（[https://angular.io](https://angular.io)），展示了Angular
    2的完整架构：
- en: '![The Angular 2 architecture](img/B05154_12_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2架构](img/B05154_12_02.jpg)'
- en: Here, you can see that the UI of a **Component** is defined using a **Template**.
    Templates are written using template HTML, that is, a combination of HTML and
    many other tokens. A component also holds the UI state and event handlers of the
    UI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到**组件**的UI是使用**模板**定义的。模板是用模板HTML编写的，即HTML和许多其他标记的组合。组件还持有UI状态和事件处理程序。
- en: We shouldn't store application logic and state inside a component, as it will
    have an impact on code reusability and cause issues while developing large and
    complex apps. Application state and logic should be stored in services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该在组件内部存储应用程序逻辑和状态，因为这会影响代码的可重用性，并在开发大型和复杂的应用程序时引发问题。应用程序状态和逻辑应该存储在服务中。
- en: Angular 2 only implements one-way data binding. This makes large and complex
    apps easier to debug.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2仅实现单向数据绑定。这使得大型和复杂的应用程序更容易调试。
- en: Services are injected into specific components that need them, and not all the
    components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 服务被注入到需要它们的特定组件中，而不是所有组件。
- en: Introducing web components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Web组件
- en: Before we get into web components, you need to know why we are learning about
    them. Well, we are learning about web components because Angular 2 components
    utilize shadow DOM and templates, which are a part of web components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解Web组件之前，你需要知道我们为什么要学习它们。嗯，我们学习Web组件是因为Angular 2组件利用了Shadow DOM和模板，这些都是Web组件的一部分。
- en: In a nutshell, web components are a collection of four different browser specifications
    that enable the creation of reusable components in web pages. These four specifications
    are **HTML imports**, **shadow DOM**, **templates**, and **custom elements**.
    They can be used together or separately.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Web组件是一组四个不同的浏览器规范，这些规范使得在网页中创建可重用组件成为可能。这四个规范是**HTML imports**、**shadow
    DOM**、**templates**和**custom elements**。它们可以一起使用，也可以单独使用。
- en: Web components provide native implementation of component-oriented architecture.
    A component created using web components is called a web component as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件提供了面向组件架构的原生实现。使用Web组件创建的组件也被称为Web组件。
- en: Before we learn about web components, let's consider a project for demonstration
    purposes. Create a directory named `web-components`, and then create a file named
    `index.html` in it. Web components have pretty poor browser support, so let's
    download `webcomponents.js polyfill`. Download the `webcomponents.js` file from
    [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    and place it in the `web-components` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习Web组件之前，让我们考虑一个用于演示的项目。创建一个名为`web-components`的目录，然后在其中创建一个名为`index.html`的文件。Web组件在浏览器中的支持相当差，所以让我们下载`webcomponents.js
    polyfill`。从[https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)下载`webcomponents.js`文件，并将其放置在`web-components`目录中。
- en: 'Now, place this code in the `index.html` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此代码放置在`index.html`文件中：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's now look at an overview of shadow DOM, templates, and custom elements
    by building a component to display a card that has an image, title, and description.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过构建一个用于显示包含图片、标题和描述的卡片组件来概述shadow DOM、模板和自定义元素。
- en: Templates
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: '**Templates** are used to define reusable code. A template is defined using
    the `<template>` tag. Code for the template is placed inside this tag. We can
    place any tag, such as `<script>` and `<style>`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**用于定义可重用代码。模板使用`<template>`标签定义。模板的代码放置在这个标签内。我们可以放置任何标签，例如`<script>`和`<style>`。'
- en: The code inside the `<template>` tag is only parsed, not rendered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<template>`标签内的代码只被解析，没有被渲染。'
- en: 'Here is an example of how to create a template. Place this code in the `body`
    tag:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何创建模板的一个例子。将此代码放置在`body`标签中：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the template holds the UI code for the card component. Now, if you open
    the `index.html` file in a browser, you won't see anything because the `<template>`
    tag is only parsed, not rendered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板包含了卡片组件的UI代码。现在，如果你在浏览器中打开`index.html`文件，你将看不到任何内容，因为`<template>`标签只被解析，没有被渲染。
- en: Custom elements
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义元素
- en: '**Custom elements** let us define new types of HTML elements (that is, new
    types of HTML tags). When we use a tag name that''s not recognized by the browser,
    the browser simply treats it like a `<span>` tag. But when we register a `custom`
    tag, it gets recognized by the browser. It can inherit other elements, lets us
    perform different operations on different stages of the element lifecycle, and
    much more.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义元素**让我们能够定义新的HTML元素类型（即新的HTML标签）。当我们使用浏览器不认识的标签名时，浏览器会简单地将其视为`<span>`标签。但当我们注册一个`custom`标签时，它会被浏览器识别。它可以继承其他元素，让我们能够在元素生命周期的不同阶段执行不同的操作，等等。'
- en: Let's create a `custom` element for our component. Wherever the tag appears,
    a new instance of the component will be displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的组件创建一个`custom`元素。无论这个标签出现在哪里，都会显示组件的新实例。
- en: 'Here is the code to display the `custom` element. Place it in the `<body>`
    tag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示`custom`元素的代码。将其放置在`<body>`标签中：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have to use the `-` character in the custom element name. This is compulsory
    because this restriction allows the parser to distinguish custom elements from
    regular elements and ensures forward compatibility when new tags are added to
    HTML. Here, we are passing properties of the component as data attributes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在自定义元素名称中使用`-`字符。这是强制性的，因为这个限制使得解析器能够区分自定义元素和常规元素，并确保在HTML中添加新标签时的向前兼容性。在这里，我们通过数据属性传递组件的属性。
- en: 'Now, let''s define `<custom-card>` as a custom element and place the template
    code inside the tag whenever a new instance of `<custom-card>` is created. To
    do that, place this code in the `<script>` tag:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `<custom-card>` 定义为一个自定义元素，并在创建 `<custom-card>` 的新实例时将模板代码放在标签内部。为此，请将此代码放在
    `<script>` 标签中：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is how the code works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何工作的代码：
- en: By default, custom elements inherit methods and properties of `HTMLElement`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，自定义元素继承自 `HTMLElement` 的方法和属性。
- en: To register a custom element, we need to use the `document.registerElement`
    method. The first argument is the custom tag name and the second argument is an
    optional object. This optional object can take a property called **prototype**.
    The `prototype` property defines the HTML element it inherits, that is, the properties
    and methods of the HTML element it inherits. By default, it's assigned to `Object.create(HTMLElement.prototype)`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注册自定义元素，我们需要使用 `document.registerElement` 方法。第一个参数是自定义标签名，第二个参数是可选对象。这个可选对象可以有一个名为
    **prototype** 的属性。`prototype` 属性定义了它继承的 HTML 元素，即它继承的属性和方法。默认情况下，它被分配给 `Object.create(HTMLElement.prototype)`。
- en: We can also add new properties and methods to our custom element by adding new
    properties and methods to the object assigned to the `prototype` property.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以通过向分配给 `prototype` 属性的对象中添加新的属性和方法来向我们的自定义元素添加新的属性和方法。
- en: Here, we've added a method called `createdCallback`, which is invoked whenever
    an instance of a custom element is created, that is, either an instance created
    using JavaScript or HTML.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，我们添加了一个名为 `createdCallback` 的方法，该方法在创建自定义元素的实例时被调用，即使用 JavaScript 或 HTML
    创建的实例。
- en: Inside `createdCallback`, we are retrieving our template and setting the image
    source, title, and description and then appending it to the custom element by
    creating a clone of it, as many custom elements will share the same template.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `createdCallback` 中，我们正在检索我们的模板并设置图像源、标题和描述，然后通过创建它的副本将其附加到自定义元素上，因为许多自定义元素将共享相同的模板。
- en: 'Now, if you open `index.html` in a browser, you will see this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器中打开 `index.html`，你会看到以下输出：
- en: '![Custom elements](img/B05154_12_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![自定义元素](img/B05154_12_01.jpg)'
- en: Shadow DOM
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影 DOM
- en: '**Shadow DOM** allows HTML elements to get a new kind of node called a shadow
    root associated with them. An element that has a shadow root associated with it
    is called a shadow host. The content of a shadow host isn''t rendered; the content
    of the shadow root is rendered instead. A shadow root can have another shadow
    root below it.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**阴影 DOM** 允许 HTML 元素获得一种新的节点，称为与它们关联的阴影根。与阴影根关联的元素称为阴影宿主。阴影宿主的内容不会被渲染；而是渲染阴影根的内容。一个阴影根可以有一个在其下面的另一个阴影根。'
- en: The benefit of shadow DOM is that CSS styles defined inside a shadow root won't
    affect its parent document, and CSS styles defined outside the shadow root will
    not affect the elements inside the shadow root. This is useful to define styles
    specific to the components. In short, we can say that shadow DOM provides style
    encapsulation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影 DOM 的好处是，在阴影根内部定义的 CSS 样式不会影响其父文档，而在阴影根外部定义的 CSS 样式也不会影响阴影根内部的元素。这对于定义特定于组件的样式非常有用。简而言之，我们可以这样说，阴影
    DOM 提供了样式封装。
- en: Style encapsulation is not the only benefit of shadow DOM. The HTML inside the
    shadow root is protected from accidental modification from JavaScript. We can
    still inspect the shadow root in browser developer tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影 DOM 的好处不仅仅是样式封装。阴影根内部的 HTML 可以防止 JavaScript 误操作。我们仍然可以在浏览器开发者工具中检查阴影根。
- en: Many native element, such as `<video>` and `<audio>`, have a shadow root, but
    when you inspect it, you won't see the shadow root. Browsers by default hide the
    shadow roots of these elements. To see their shadow roots, you need to change
    browser-specific settings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多原生元素，如 `<video>` 和 `<audio>`，都有一个阴影根，但当你检查它时，你不会看到阴影根。浏览器默认隐藏这些元素的阴影根。要查看它们的阴影根，你需要更改浏览器特定的设置。
- en: 'Let''s modify the previous custom element code to render the template inside
    shadow DOM. Replace the previous `createdCallback` method with this one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的自定义元素代码，以在阴影 DOM 中渲染模板。用下面的这个方法替换之前的 `createdCallback` 方法：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, instead of appending the template code directly to the custom element,
    we created a shadow root using `createShadowRoot` and appended the template code
    to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们不是直接将模板代码附加到自定义元素上，而是使用 `createShadowRoot` 创建了一个阴影根，并将模板代码附加到它上面。
- en: Setting up an Angular 2 project
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Angular 2 项目
- en: Angular 2 code can be written in JavaScript, TypeScript, or Dart. In case you
    are writing Angular 2 code in TypeScript or Dart, you will need to transpile the
    code to JavaScript before serving to the client. We will use JavaScript to write
    Angular 2 code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2代码可以用JavaScript、TypeScript或Dart编写。如果你在TypeScript或Dart中编写Angular 2代码，你需要在向客户端提供服务之前将代码转换为JavaScript。我们将使用JavaScript来编写Angular
    2代码。
- en: Create a directory named `angular2-demo`. Then, inside the directory, create
    the `app.js` and `package.json` files. Then, create a directory named `public`,
    and inside the directory, create four more directories named `html`, `js`, `componentTemplates`,
    and `componentStyles`. Now, create a file named `index.html` and place it in the
    `html` directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`angular2-demo`的目录。然后，在目录内创建`app.js`和`package.json`文件。然后，创建一个名为`public`的目录，并在该目录内创建四个更多名为`html`、`js`、`componentTemplates`和`componentStyles`的目录。现在，创建一个名为`index.html`的文件，并将其放置在`html`目录中。
- en: Then, download `angular2-polyfills.js`, `Rx.umd.js`, and `angular2-all.umd.js`
    from [https://cdnjs.com/libraries/angular.js/](https://cdnjs.com/libraries/angular.js/)
    and place them in the `angular2-demo/js` directory. These files are what they
    sound like. You can also enqueue the CDN links directly if you want to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从[https://cdnjs.com/libraries/angular.js/](https://cdnjs.com/libraries/angular.js/)下载`angular2-polyfills.js`、`Rx.umd.js`和`angular2-all.umd.js`，并将它们放置在`angular2-demo/js`目录中。这些文件就是它们听起来那样。如果你愿意，也可以直接排队CDN链接。
- en: 'Inside the `index.html` file, place this starting code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，放置以下起始代码：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the `app.js` file, place this code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，放置以下代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the server-side code. It's self-explanatory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是服务器端代码。它很直观。
- en: 'Now, in the `package.json` file, place this code and run `npm install` to download
    the `express` package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`package.json`文件中，放置以下代码并运行`npm install`以下载`express`包：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To start the server, run `node app.js`. Then, open the app using `localhost:8080`
    as the address in a browser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，运行`node app.js`。然后，使用浏览器以`localhost:8080`作为地址打开应用程序。
- en: Angular 2 fundamentals
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2基础知识
- en: An Angular 2 application is completely split into components. Technically, an
    Angular 2 component is a reusable `custom` tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2应用程序完全分解为组件。技术上讲，Angular 2组件是一个可重用的`custom`标签，它是可变的，并且封装了一个嵌入的状态，即状态或属性的更改将导致UI的突变。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that Angular 2 doesn't register the custom tag name as a custom element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Angular 2不会将自定义标签名注册为自定义元素。
- en: All the components of the application are arranged in a tree structure, with
    a component as the root node.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的所有组件都按照树状结构排列，其中组件是根节点。
- en: 'Here is an example of how to create a component. It creates a card component
    that displays an image, title, and description. Place this code in the `<script>`
    tag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建组件的示例。它创建了一个显示图片、标题和描述的卡片组件。将以下代码放入`<script>`标签中：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, create a file named `card-template.html`, and place it in the `componentTemplates`
    directory. Place this code in the file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`card-template.html`的文件，并将其放置在`componentTemplates`目录中。将以下代码放入该文件：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, create a file named `card-style.css` and place it in the `componentStyles`
    directory. Place this code in the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建一个名为`card-style.css`的文件，并将其放置在`componentStyles`目录中。将以下代码放入该文件：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is how these three code snippets work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这三个代码片段是如何工作的：
- en: A component needs to be created by chaining `Component` and `Class` methods
    that belong to an `ng.core` object.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件需要通过链式调用属于`ng.core`对象的`Component`和`Class`方法来创建。
- en: The `Component` method takes a configuration object with various properties,
    whereas the `Class` method takes an object with component lifecycle methods, constructors,
    and UI action handlers.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component`方法接受一个包含各种属性的配置对象，而`Class`方法接受一个包含组件生命周期方法、构造函数和UI操作处理器的对象。'
- en: Here, the configuration properties we've provided are `selector`, `inputs`,
    `templateUrl`, and `styleUrls`. The `selector` property is used to define the
    custom tag for the component. The `inputs` property is used to define the attributes
    that the custom tag takes. The `templateUrl` property is used to define the file
    containing the template of the component. You can also use `template` if you want
    to inline the template code. Finally, `styleUrls` is used to define the CSS files
    containing the style for the component. You can also use the `styles` property
    to inline CSS code, or you can define CSS using a `<style>` tag inside the template
    itself. CSS defined in any of these three ways won't affect other components,
    that is, it's encapsulated to the component itself.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在这里，我们提供的配置属性是 `selector`、`inputs`、`templateUrl` 和 `styleUrls`。`selector` 属性用于定义组件的自定义标签。`inputs`
    属性用于定义自定义标签接受的属性。`templateUrl` 属性用于定义包含组件模板的文件。如果您想内联模板代码，也可以使用 `template`。最后，`styleUrls`
    用于定义包含组件样式的 CSS 文件。您也可以使用 `styles` 属性来内联 CSS 代码，或者您可以在模板内部使用 `<style>` 标签来定义 CSS。以这三种方式定义的
    CSS 不会影响其他组件，也就是说，它是封装在组件本身的。 '
- en: In the `Class` method, we will have to provide the `constructor` method even
    if it does nothing. It's invoked during the construction of a new instance of
    the component. By construction of the component, I mean the construction of the
    component in memory—not resolving attributes, resolving its children, rendering
    its view, and so on. The primary use of the `constructor` method is to inject
    services into the component. Services cannot be injected automatically as we may
    sometimes need to initialize services for every component, and Angular is unaware
    of how to do this. The `constructor` method has access to the state of the component
    but not its properties. Here, we shouldn't do any heavy work or something else
    that would slow down or cause the construction of the component to fail. `constructor`
    is not a component lifecycle method.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Class` 方法中，即使它不做任何事情，我们也必须提供 `constructor` 方法。它在新组件实例构建期间被调用。通过构建组件，我指的是在内存中构建组件——不是解析属性、解析其子组件、渲染其视图等等。`constructor`
    方法的首要用途是将服务注入到组件中。服务不能自动注入，因为我们有时可能需要为每个组件初始化服务，而 Angular 并不知道如何做这件事。`constructor`
    方法可以访问组件的状态，但不能访问其属性。在这里，我们不应该做任何重负载工作或可能导致组件构建失败的其他事情。`constructor` 不是一个组件生命周期方法。
- en: Then, we have the component template code. In this template file, we are simply
    rendering the properties passed to the component. To render anything that's in
    the component state, we need to use the `{{}}` token.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有组件模板代码。在这个模板文件中，我们只是渲染传递给组件的属性。要渲染组件状态中的任何内容，我们需要使用 `{{}}` 符号。
- en: Let's create another component called `Cards`, which displays a list of cards.
    It gets information about cards from a service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为 `Cards` 的组件，它显示一张卡片列表。它从服务中获取有关卡片的信息。
- en: 'Place this code in the `<script>` tag of the `index.html` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入 `index.html` 文件的 `<script>` 标签中：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, create a file named `cards-template.html` in the `componentTemplates`
    directory and place this code in it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `componentTemplates` 目录下创建一个名为 `cards-template.html` 的文件，并将此代码放入其中：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create a file named `app-template.html` in the `componentTemplates` directory
    and place this code in it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `componentTemplates` 目录下创建一个名为 `app-template.html` 的文件，并将此代码放入其中：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in the `<body>` tag of the `index.html` file, place this code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `index.html` 文件的 `<body>` 标签中放置此代码：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is how these four code snippets work:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何这四个代码片段工作的：
- en: To create a service, we need to use the `ng.core.Class` method. It takes an
    object with the `constructor` method and other methods or properties that the
    service exposes. While injecting the service into other services or components,
    a new instance of the service is created and injected. While creating a new instance
    of a service, the `constructor` method is called. We have to provide this method
    even if it doesn't do anything. The primary purpose of this method is to inject
    services that this service depends on. Here, our `CardsService` method is not
    dependent on any other service, so we have no code inside the `constructor` method.
    Then, we defined a `getCards` method, which returns data of three different cards
    to display.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个服务，我们需要使用`ng.core.Class`方法。它需要一个具有`constructor`方法以及其他服务公开的方法或属性的对象。在将服务注入到其他服务或组件时，会创建并注入服务的新实例。在创建服务的新实例时，会调用`constructor`方法。即使这个方法不做任何事情，我们也必须提供这个方法。这个方法的主要目的是注入这个服务所依赖的服务。在这里，我们的`CardsService`方法不依赖于任何其他服务，所以`constructor`方法中没有代码。然后，我们定义了一个`getCards`方法，它返回三个不同卡片的显示数据。
- en: Then, we created a `Cards` component. It takes the data from `CardsService`
    and renders a `Card` component for each card data. While creating the `Cards`
    component, we provide `viewProviders` and `directives` properties to the configuration
    object. `viewProviders` is the list of services the component is dependent on,
    and `directives` is the list of other components this component renders. Here,
    you can see that instead of directly assigning a function to the `constructor`
    property, we are assigning an array with a list of services the component depends
    upon and the last array item as the actual function. This is the format of injecting
    services into components. Inside the `constructor` method, we store references
    to the methods or properties of the service that the component needs, that is,
    we can use services inside the `constructor` method. We will learn more about
    `viewProviders` later on. The `this` keyword in any of the methods passed to the
    `Class` method points to the state of the component. After a component instance
    has been created, whenever the component state changes, the template bindings
    are updated. We have another method here, called `ngOnInit`. It's a lifecycle
    method that's invoked after a new instance of the component has been created and
    its attributes resolved. Inside this, we call the `getCards` method and store
    the returned value inside the `cards` property of the state. Note that the attributes
    passed to a component tag are accessible using the `this` keyword after the component
    instance has been created.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`Cards`组件。它从`CardsService`获取数据，并为每张卡片数据渲染一个`Card`组件。在创建`Cards`组件时，我们将`viewProviders`和`directives`属性提供给配置对象。`viewProviders`是组件所依赖的服务列表，而`directives`是组件渲染的其他组件列表。在这里，你可以看到，我们不是直接将函数分配给`constructor`属性，而是将一个包含组件所依赖的服务列表的数组以及最后一个数组项作为实际函数分配。这就是将服务注入到组件中的格式。在`constructor`方法内部，我们存储组件需要的服务的引用或属性，也就是说，我们可以在`constructor`方法中使用服务。我们将在稍后学习更多关于`viewProviders`的内容。传递给`Class`方法的任何方法中的`this`关键字都指向组件的状态。在创建组件实例后，每当组件状态发生变化时，模板绑定都会更新。这里还有一个方法，称为`ngOnInit`。它是一个生命周期方法，在创建组件的新实例并解析其属性后调用。在这个方法中，我们调用`getCards`方法并将返回值存储在状态中的`cards`属性中。请注意，传递给组件标签的属性在组件实例创建后可以通过`this`关键字访问。
- en: Inside the template of `CardsComponent`, we are using the `*ngFor` directive
    to display the cards. We will learn more about directives later.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CardsComponent`模板内部，我们使用`*ngFor`指令来显示卡片。我们将在稍后学习更多关于指令的内容。
- en: Then, we create an `App` component, which acts as the root of our component.
    Inside this component, we are displaying the `Cards` component.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`App`组件，它作为我们组件的根组件。在这个组件内部，我们显示了`Cards`组件。
- en: Finally, we initialize the application. An Angular 2 application is initialized
    explicitly. While initializing it, we need to provide a reference to the root
    component. This is done to ensure that applications are composed of nested components
    all the way down. The root component is the one that's added to the `<body>` tag.
    Adding tags of other components to the body tag will not do anything.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们初始化应用程序。Angular 2应用程序是显式初始化的。在初始化时，我们需要提供一个根组件的引用。这样做是为了确保应用程序由嵌套组件组成。根组件是添加到`<body>`标签的组件。将其他组件的标签添加到`<body>`标签上不会产生任何效果。
- en: 'Now, if you refresh your `localhost:8080` page in your browser, you will see
    this output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器中刷新你的`localhost:8080`页面，你将看到以下输出：
- en: '![Angular 2 fundamentals](img/B05154_12_03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2基础知识](img/B05154_12_03.jpg)'
- en: Styling components and shadow DOM
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件样式和shadow DOM
- en: Earlier, we saw that there are three ways of defining styles specific to components
    (styles encapsulated in the component template scope). A component's CSS doesn't
    even affect the components it owns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了定义特定于组件的样式（在组件模板作用域中封装的样式）的三种方法。组件的CSS甚至不会影响它所拥有的组件。
- en: Angular 2 doesn't use shadow DOM by default; instead, it uses a different technique
    to achieve style encapsulation. This is due to the lack of browser support.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2默认不使用shadow DOM；相反，它使用不同的技术来实现样式封装。这是由于浏览器支持不足的原因。
- en: 'By default, Angular 2 modifies the CSS selector in such a way that it only
    targets the elements in the component, and it then places the CSS in the `<head>`
    tag of the page. If you inspect our current app using browser developer tools,
    you will see this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 2修改CSS选择器，使其仅针对组件中的元素，然后将CSS放置在页面的`<head>`标签中。如果你使用浏览器开发者工具检查我们的当前应用，你会看到以下内容：
- en: '![Styling components and shadow DOM](img/B05154_12_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![组件样式和shadow DOM](img/B05154_12_04.jpg)'
- en: Here, you can see that the CSS has been modified and inserted into the `<head>`
    tag.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到CSS已经被修改并插入到`<head>`标签中。
- en: To force Angular 2 to use shadow DOM, we need to assign the encapsulation property
    of the component configuration object to `ng.core.ViewEncapsulation.Native`. By
    default, it's assigned to `ng.core.ViewEncapsulation.Emulated`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制Angular 2使用shadow DOM，我们需要将组件配置对象的封装属性分配给`ng.core.ViewEncapsulation.Native`。默认情况下，它分配给`ng.core.ViewEncapsulation.Emulated`。
- en: 'When you inspect the app after assigning the encapsulation property of the
    `Card` and `Cards` components to `ng.core.ViewEncapsulation.Native`, you will
    see something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在将`Card`和`Cards`组件的封装属性分配给`ng.core.ViewEncapsulation.Native`之后检查应用时，你会看到类似以下的内容：
- en: '![Styling components and shadow DOM](img/B05154_12_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![组件样式和shadow DOM](img/B05154_12_05.jpg)'
- en: Here, you can see that shadow DOM was used to achieve style encapsulation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到使用了shadow DOM来实现样式封装。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you don't want style encapsulation for a component, you can assign the
    encapsulation property to `ng.core.ViewEncapsulation.None`. In this case, all
    of the CSS will be placed directly in the `<head>` tag.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想为组件启用样式封装，可以将封装属性分配给`ng.core.ViewEncapsulation.None`。在这种情况下，所有的CSS都将直接放置在`<head>`标签中。
- en: Angular 2 change detection
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2状态检测
- en: '**Change detection** is the process of detecting component state change. The
    state of a component is stored and manipulated using the `this` keyword. Therefore,
    there is no direct way for Angular 2 to detect when the state changes. So, Angular
    2 uses complex algorithms and third-party libraries to detect state changes.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态检测**是检测组件状态变化的过程。组件的状态是通过使用`this`关键字来存储和操作的。因此，Angular 2没有直接检测状态变化的方法。所以，Angular
    2使用复杂的算法和第三方库来检测状态变化。'
- en: The first thing Angular 2 does for detecting state changes is that it pretends
    that all the changes happen asynchronously. Then, it uses the `zone.js` library
    to monitor browser events, timers, AJAX requests, WebSockets, and other asynchronous
    things that are supported by `zone.js`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2检测状态变化的第一件事是，它假装所有变化都是异步发生的。然后，它使用`zone.js`库来监控浏览器事件、计时器、AJAX请求、WebSockets以及其他由`zone.js`支持的异步操作。
- en: Now, whenever any of these asynchronous activities takes place, it checks everything
    that could change, including object properties and array elements of the `this`
    keyword of all the components from the root node; if any change is detected, then
    the template bindings of the component are updated. Angular 2 doesn't simply re-render
    the whole component. Instead, it checks for the bindings that have changed and
    selects and updates them specifically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当这些异步活动之一发生时，它会检查所有可能发生变化的内容，包括从根节点开始的所有组件的`this`关键字的属性和数组元素；如果检测到任何变化，则更新组件的模板绑定。Angular
    2不会简单地重新渲染整个组件。相反，它会检查已更改的绑定，并选择性地更新它们。
- en: Some components can have a lot of state data, and checking the state for every
    asynchronous operation will unnecessarily impact app performance if their state
    has not changed. Therefore, Angular 2 provides an option to mark such kinds of
    components so that it does not check their states unless the component itself
    tells Angular 2 to check its state during the next detection cycle, that is, when
    the next asynchronous activity occurs. Let's look at an example to demonstrate
    this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件可能包含大量的状态数据，如果它们的状态没有改变，检查每个异步操作的状态将无谓地影响应用程序的性能。因此，Angular 2 提供了一个选项来标记这类组件，这样它就不会检查它们的状态，除非组件本身告诉
    Angular 2 在下一个检测周期（即下一个异步活动发生时）检查其状态。让我们通过一个示例来演示这一点。
- en: 'Place this code above the `App` component code in the `<script>` tag of the
    `index.html` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置在`index.html`文件的`<script>`标签中`App`组件代码之上：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add `SampleComponent1` to the `directives` array of the `App` component.
    So now, the `App` component''s code should be this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`SampleComponent1`添加到`App`组件的`directives`数组中。因此，现在`App`组件的代码应该是这样的：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, add this code to the end of the `app-template.html` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此代码添加到`app-template.html`文件的末尾：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is how these three code snippets work:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个代码片段是如何工作的：
- en: In this example, we are displaying a value that gets incremented every 2 seconds
    and the template is re-rendered to display the updated value.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们显示了一个每2秒增加一次的值，并且模板被重新渲染以显示更新的值。
- en: At first, we create a component called `SampleComponent1`. It simply displays
    `value`. We have set the `changeDetection` property to `ng.core.ChangeDetectionStrategy.Detached`,
    which tells Angular 2 to not check its state change. By default, the `changeDetection`
    property is assigned to `ng.core.ChangeDetectionStrategy.Default`, which tells
    Angular 2 to check its state change during every change-detection cycle. We then
    inject the `ng.core.ChangeDetectorRef` service into the component, which provides
    various APIs related to change detection. And then, in the `ngOnInit` method,
    we increment the value of `value` every 2 seconds, after which we call the `markForCheck`
    method of `ng.core.ChangeDetectorRef`, which tells Angular 2 to check for changes
    in the state of the component during the next change-detection cycle. `markForCheck`
    will make Angular 2 check for a change in state for the next detection cycle only,
    not for the ones after that.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`SampleComponent1`的组件。它简单地显示`value`。我们已经将`changeDetection`属性设置为`ng.core.ChangeDetectionStrategy.Detached`，这告诉
    Angular 2 不要检查其状态变化。默认情况下，`changeDetection`属性被分配为`ng.core.ChangeDetectionStrategy.Default`，这告诉
    Angular 2 在每个变更检测周期中检查其状态变化。然后，我们将`ng.core.ChangeDetectorRef`服务注入到组件中，该服务提供与变更检测相关的各种
    API。然后，在`ngOnInit`方法中，我们每2秒增加`value`的值，之后调用`ng.core.ChangeDetectorRef`的`markForCheck`方法，这告诉
    Angular 2 在下一个变更检测周期中检查组件状态的变化。`markForCheck`将使 Angular 2 仅在下一个检测周期中检查状态变化，而不是在之后的周期中。
- en: Then, we simply display `SampleComponent1` in the `App` component.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们简单地显示`SampleComponent1`在`App`组件中。
- en: If a component depends only on its inputs and/or UI events or if you want a
    component's state change, check only whether its inputs have changed or events
    have been fired; then, you can assign `changeDetection` to `ng.core.ChangeDetectionStrategy.OnPush`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件只依赖于其输入和/或 UI 事件，或者如果你想检查组件的状态变化，只需检查其输入是否已更改或事件是否已被触发；然后，你可以将`changeDetection`分配给`ng.core.ChangeDetectionStrategy.OnPush`。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If at any time you want to force a change-detection cycle instead of waiting
    for an asynchronous operation to happen, you can call the `detectChanges` method
    of the `ng.core.ChangeDetectorRef` service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候你想强制执行变更检测周期而不是等待异步操作发生，你可以调用`ng.core.ChangeDetectorRef`服务的`detectChanges`方法。
- en: Understanding view children and content children
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解视图子元素和内容子元素
- en: Elements present inside the tags of a component are called **content children**,
    and elements present inside the template of a component are called **view children**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 存在于组件标签内的元素被称为**内容子元素**，存在于组件模板内的元素被称为**视图子元素**。
- en: To display the content children of a component in the component's view, we need
    to use the `<ng-content>` tag. Let's look at an example of this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件视图中显示组件的内容子元素，我们需要使用`<ng-content>`标签。让我们看看一个示例。
- en: 'Place this code above the `App` component''s code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置在`App`组件代码之上：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, change the `App` component''s code to this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`App`组件的代码更改为以下内容：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To the end of the `app-template.html` file, add this code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`app-template.html`文件的末尾：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of this code is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '![Understanding view children and content children](img/B05154_12_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![理解视图子组件和内容子组件](img/B05154_12_06.jpg)'
- en: 'This is how these three code snippets work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这三个代码片段是如何工作的：
- en: In the `App` component's template file, we add a `<list>` tag, which displays
    a list. And inside its opening and closing tags, we define the individual list
    items that it should display.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件的模板文件中，我们添加一个`<list>`标签，用于显示列表。在其开标签和闭标签内，我们定义了它应该显示的各个列表项。
- en: We create `ListItem` and `List` components that are bound to `<list>` and `<item>`
    tags, respectively.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了`ListItem`和`List`组件，分别绑定到`<list>`和`<item>`标签。
- en: We add `List` component to the `directives` property of the `App` component,
    not `List`, because the `<list>` tag is present in the template of the `App` component,
    and the `App` component is responsible for creating its instances.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`List`组件添加到`App`组件的`directives`属性中，而不是`List`，因为`<list>`标签存在于`App`组件的模板中，`App`组件负责创建其实例。
- en: The `App` component looks for the `<ng-content>` tag in the template of the
    `List` component and renders the `List` component instances there.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App`组件在`List`组件的模板中查找`<ng-content>`标签，并在那里渲染`List`组件实例。'
- en: '`<ng-content>` takes an optional `select` attribute that''s assigned to a CSS
    selector that indicates which elements of the content children we want to display.
    There can be multiple `<ng-content>` tags in a template. If the `select` attribute
    has not been provided, then all the content children will be rendered. Here, the
    `select` attribute is not required; we are using it just for demonstration.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<ng-content>`可以接受一个可选的`select`属性，该属性被分配给一个CSS选择器，指示我们想要显示的内容子组件中的哪些元素。一个模板中可以有多个`<ng-content>`标签。如果没有提供`select`属性，则将渲染所有内容子组件。在这里，`select`属性不是必需的；我们只是用它来演示。'
- en: Getting the reference of components of content children and view children
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取内容子组件和视图子组件的组件引用
- en: To get access to the reference of components of view children or content children,
    we can use the `ng.core.ContentChildren`, `ng.coreViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ViewChild` constructors. The difference between `ng.core.ContentChildren`
    and `ng.core.ContentChild` is that the first one returns all the references of
    a given component whereas the second one returns the reference of the first occurrence.
    The same difference also stands for `ng.core.ViewChild` and `ng.core.ViewChildren`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取视图子组件或内容子组件的引用，我们可以使用`ng.core.ContentChildren`、`ng.coreViewChildren`、`ng.core.ContentChild`和`ng.core.ViewChild`构造函数。`ng.core.ContentChildren`和`ng.core.ContentChild`之间的区别在于，前者返回给定组件的所有引用，而后者返回第一个出现的引用。同样的区别也适用于`ng.core.ViewChild`和`ng.core.ViewChildren`。
- en: 'Here is an example to demonstrate `ng.core.ContentChildren`. Replace the code
    for the `List` component with this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示`ng.core.ContentChildren`。将`List`组件的代码替换为以下内容：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of this code in the console is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在控制台中的输出如下：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Most of this code is self-explanatory. What's new is the `ngAfterContentInit`
    lifecycle method. It's triggered after the content children have been initialized.
    Similarly, if we want to access the view children, we need to use the `ngAfterViewInit`
    lifecycle method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是自解释的。新的内容是`ngAfterContentInit`生命周期方法。它在内容子组件初始化后触发。同样，如果我们想访问视图子组件，我们需要使用`ngAfterViewInit`生命周期方法。
- en: Note that we only have access to the state of the components—nothing else.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只能访问组件的状态——没有其他内容。
- en: Local template variables
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部模板变量
- en: We can assign a local template variable to a content child or view child. Local
    template variables let us get the reference of any element of the content children
    or view children, that is, component references or HTML element references.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将局部模板变量分配给内容子组件或视图子组件。局部模板变量允许我们获取内容子组件或视图子组件中任何元素的引用，即组件引用或HTML元素引用。
- en: To assign a local template variable to an element of the view children or content
    children, we need to place `#variable_name` in the opening tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要将局部模板变量分配给视图子组件或内容子组件的元素，我们需要在开标签中放置`#variable_name`。
- en: 'Here is an example to demonstrate how local template variables work. Place
    this code above the `App` component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示局部模板变量是如何工作的。将此代码放置在`App`组件上方：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change the `App` component''s code to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码更改为以下内容：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, add this code to the end of the `app-template.html` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到`app-template.html`文件的末尾：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of this code is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![Local template variables](img/B05154_12_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![局部模板变量](img/B05154_12_07.jpg)'
- en: 'Here is how these three code snippets work:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这三个代码片段的说明：
- en: We create a new component named `SampleComponent2`, which displays an HTML input
    text element. We assign the input element to a local template variable named `input`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的组件名为 `SampleComponent2`，它显示一个 HTML 输入文本元素。我们将输入元素分配给一个名为 `input` 的局部模板变量。
- en: Then, we use the `ng.core.ViewChild` to get a reference to the element. If we
    pass a string to `ng.core.ViewChild`, `ng.core.ViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ContentChildren`, then they will look for the elements with the same
    local variable name as the string, and if we pass a component, they will look
    for the component, like we saw before.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `ng.core.ViewChild` 来获取元素的引用。如果我们向 `ng.core.ViewChild`、`ng.core.ViewChildren`、`ng.core.ContentChild`
    和 `ng.core.ContentChildren` 传递一个字符串，那么它们将寻找与字符串具有相同局部变量名的元素，如果我们传递一个组件，它们将寻找之前看到的组件。
- en: The reference of the components we get from the local template variable is of
    the same interface we got before. But for HTML element references, we can access
    the real DOM of the element by using the `nativeElement` property.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从局部模板变量获取的组件引用与之前获得的接口相同。但对于 HTML 元素引用，我们可以通过使用 `nativeElement` 属性来访问元素的真正 DOM。
- en: Component lifecycle methods
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: When a `component` tag appears, Angular 2 creates an instance of a component,
    renders it, checks for changes in attributes, checks for changes in state, and
    destroys it when it's no longer needed. These steps together form the lifecycle
    of a component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现 `component` 标签时，Angular 2 创建组件的一个实例，渲染它，检查属性的变化，检查状态的变化，并在不再需要时销毁它。这些步骤共同构成了组件的生命周期。
- en: Angular 2 lets us register methods that are called at various stages of the
    component lifecycle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 允许我们在组件生命周期的各个阶段注册方法。
- en: 'Here are the various lifecycle methods provided by Angular 2; lifecycle hooks
    are explained in the order they occur:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Angular 2 提供的各种生命周期方法；生命周期钩子的解释按照它们发生的顺序：
- en: '`ngOnChanges`: This is invoked whenever the attributes of a component change.
    It''s also invoked after the attributes of a component are resolved for the first
    time after the creation of a new instance of the component. It''s invoked after
    the state has been changed due to the attributes but before the view is updated.
    This method receives the current and previous values of the attributes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnChanges`：每当组件的属性发生变化时，都会调用此方法。它还在创建组件的新实例后，首次解析组件的属性之后调用。它在由于属性变化而更改状态之后，但在视图更新之前调用。此方法接收属性的当前值和前一个值。'
- en: '`ngOnInit`: This is invoked after the first instance of `ngOnChanges`. It states
    that the component has been successfully created and attributes have been read.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnInit`：在第一次调用 `ngOnChanges` 之后调用此方法。它表示组件已成功创建，并且已读取属性。'
- en: '`ngDoCheck`: This is called during every change-detection cycle and right after
    `ngOnInit`. We can detect and act upon changes that Angular 2 can''t or won''t
    detect on its own. This is invoked after Angular 2 is done checking state changes
    for the component and has updated the state if there was any change in the attributes
    but before the component view is updated. After this call is over, the view is
    rendered, and while rendering it, `ngAfterContentInit`, `ngAfterContentChecked`,
    `ngAfterViewInit`, and `ngAfterViewChecked` are invoked.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngDoCheck`：在每次变更检测周期中调用，紧随 `ngOnInit` 之后。我们可以检测并处理 Angular 2 无法或不会自动检测的变化。它在
    Angular 2 完成检查组件的状态变化并更新状态（如果有任何属性变化）之后，但在组件视图更新之前调用。在此调用完成后，视图被渲染，在渲染过程中，会调用
    `ngAfterContentInit`、`ngAfterContentChecked`、`ngAfterViewInit` 和 `ngAfterViewChecked`。'
- en: '`ngAfterContentInit`: This is invoked after content children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, and `ngAfterContentChecked` methods of the content children
    have been called.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterContentInit`：在内容子元素初始化但尚未渲染之后调用此方法，即 `ngOnChanges`、`ngOnInit`、`ngDoCheck`、`ngAfterContentInit`
    和 `ngAfterContentChecked` 方法调用内容子元素之后。'
- en: '`ngAfterContentChecked`: This is invoked whenever the change-detection cycle
    checks whether the content children have changed as well as right after `ngAfterContentInit`.
    If there is a change, it''s invoked before the views of the content children are
    updated. Before invoking it, the query results of `ng.core.ViewChildren`, `ng.core.ContentChildren`,
    and so on are updated, that is, it''s invoked after `ngAfterContentChecked` of
    the content children has been invoked. After this call, the content children views
    are updated.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterContentChecked`：在每次变更检测周期检查内容子组件是否发生变化以及`ngAfterContentInit`之后立即调用。如果有变化，它将在内容子组件的视图更新之前被调用。在调用之前，`ng.core.ViewChildren`、`ng.core.ContentChildren`等查询结果被更新，即它在内容子组件的`ngAfterContentChecked`之后被调用。在此调用之后，内容子组件的视图被更新。'
- en: '`ngAfterViewInit`: This is invoked after view children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, and `ngAfterViewChecked`
    methods of the view children have been called.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterViewInit`：在视图子组件初始化但尚未渲染之后调用，即`ngOnChanges`、`ngOnInit`、`ngDoCheck`、`ngAfterContentInit`、`ngAfterContentChecked`、`ngAfterViewInit`和`ngAfterViewChecked`方法调用之后。'
- en: '`ngAfterViewChecked`: This is invoked whenever the change-detection cycle checks
    whether the view children have changed as well as right after `ngAfterViewInit`.
    If there is a change, it''s invoked before the views of the view children are
    updated but after the `ngAfterViewChecked` methods of the view children have been
    invoked.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterViewChecked`：在每次变更检测周期检查视图子组件是否发生变化以及`ngAfterViewInit`之后立即调用。如果有变化，它将在视图子组件的视图更新之前被调用，但在视图子组件的`ngAfterViewChecked`方法调用之后。'
- en: '`ngOnDestroy`: This is invoked before a component is destroyed. The `ngOnDestroy`
    method of a component is invoked before the `ngOnDestroy` methods of its content
    children and view children.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnDestroy`：在组件销毁之前调用。组件的`ngOnDestroy`方法在其内容子组件和视图子组件的`ngOnDestroy`方法之前被调用。'
- en: Writing templates
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模板
- en: We need to use template language to write component templates. Template language
    is composed of HTML along with the `{}`, `[]`, `()`, `[()]`, `*`, `|`, and `#`
    tokens. Let's see what each of these is used for and how to use them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用模板语言来编写组件模板。模板语言由HTML以及`{}`, `[]`, `()`, `[()]`, `*`, `|`, 和 `#` 标记组成。让我们看看这些标记分别用于什么，以及如何使用它们。
- en: Rendering a value
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染一个值
- en: To simply render a property of the `this` keyword, we need to use the `{{}}`
    token. Inside these braces, we can simply place the property name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要简单地渲染`this`关键字的一个属性，我们需要使用`{{}}`标记。在这些大括号内，我们可以简单地放置属性名。
- en: 'We can only place expressions inside braces. The expressions we place inside
    them look like JavaScript. But there are a few JavaScript expressions that we
    are not allowed to use inside these braces. Here they are:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在大括号内放置表达式。我们放置在其中的表达式看起来像JavaScript。但有一些JavaScript表达式我们不允许在这些大括号内使用。以下是它们：
- en: Assignments (`=`, `+=`, `-=`)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符（`=`, `+=`, `-=`）
- en: The `new` operator
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`运算符'
- en: Chaining expressions with `;` or `,`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`;`或`,`连接表达式
- en: Increment and decrement operators (`++` and `--`)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量和减量运算符（`++` 和 `--`）
- en: The bitwise operators `|` and `&`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符 `|` 和 `&`
- en: Pipes
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: We can also place `pipes` in braces. A pipe is a function that accepts an input
    value and returns a transformed value. A pipe is represented by the `|` operator.
    The final result of expressions inside braces can be transformed using pipes.
    There can be as many pipes in the braces as we want. A pipe can also take parameters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在大括号中放置`管道`。管道是一个接受输入值并返回转换后值的函数。管道由`|`运算符表示。大括号内表达式的最终结果可以使用管道进行转换。我们可以根据需要在大括号中放置任意数量的管道。管道也可以接受参数。
- en: 'Angular 2 provides some built-in pipes: `date`, `uppercase`, `lowercase`, `currency`,
    and `percent`. We can also create our own pipes.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 提供了一些内置管道：`date`、`uppercase`、`lowercase`、`currency` 和 `percent`。我们也可以创建自己的管道。
- en: 'Here is an example of using `{{}}`. Place this code above the `App` component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`{{}}`的一个示例。将此代码放置在`App`组件上方：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace the `App` component code with this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件代码替换为以下内容：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then, place this in the `app-template.html` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下内容放置在`app-template.html`文件中：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the code is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![Pipes](img/B05154_12_08.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Pipes](img/B05154_12_08.jpg)'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the final result of the expression inside the braces is converted
    into a string if the final value is not a string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果最终值不是字符串，则大括号内表达式的最终结果将被转换为字符串。
- en: Handling events
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: 'To handle events of elements in a template, we need to use the `()` operator.
    Here is an example of how to handle events. Place this code above the `App` component
    code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理模板中元素的的事件，我们需要使用`()`运算符。以下是如何处理事件的示例。将此代码放置在`App`组件代码上方：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Replace the `App` component code with this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件代码替换为以下内容：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Place this code in `app-template.html`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置在`app-template.html`中：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is self-explanatory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是自我解释的。
- en: Binding state to element attributes
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定状态到元素属性
- en: 'To bind the value of a property of the `this` keyword to the attribute of an
    element in a template, we can simply use `{{}}`, like this, for example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将`this`关键字属性值绑定到模板中元素的属性，我们可以简单地使用`{{}}`，例如：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But if you want to pass an object, this method will not work, as the expression
    inside the `{{}}` token is always converted to a string. Therefore, Angular 2
    provides the `[]` operator, which enables a component to pass an object through
    attributes to a component in its template.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您想传递一个对象，此方法将不起作用，因为`{{}}`标记内的表达式始终被转换为字符串。因此，Angular 2提供了`[]`运算符，它使组件能够通过属性将对象传递到模板中的组件。
- en: 'Here is an example to demonstrate this. Place this code above the `App` component
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点。将此代码放置在`App`组件代码上方：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件代码替换为以下内容：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Place this code at the end of the `app-template.html` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置在`app-template.html`文件的末尾：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of this code is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![Binding state to element attributes](img/B05154_12_09.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![绑定状态到元素属性](img/B05154_12_09.jpg)'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that while assigning attributes to an HTML tag, if we assign an attribute
    that's not native to the element, we need to prefix the attribute name using `attr.`.
    For example, to assign a `value` attribute to a `<span>` tag, we need to name
    the attribute `attr.value`, not simply `value`. Otherwise, Angular 2 will throw
    an error. This is because while interpreting a template and creating its DOM,
    Angular 2 sets the attributes by assigning the values to the properties of DOM
    elements. So when we use the `attr.` prefix, it signals Angular 2 to use `setAttribute`
    instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在将属性分配给HTML标签时，如果我们分配一个不是元素本地的属性，我们需要使用`attr.`前缀来指定属性名。例如，要将`value`属性分配给`<span>`标签，我们需要将属性命名为`attr.value`，而不是简单地命名为`value`。否则，Angular
    2将抛出错误。这是因为当解释模板并创建其DOM时，Angular 2通过将值分配给DOM元素的属性来设置属性。因此，当我们使用`attr.`前缀时，它向Angular
    2发出信号，使用`setAttribute`代替。
- en: Two-way data binding
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: By default, Angular 2 doesn't use two-way data binding. It uses unidirectional
    binding but offers the `[()]` operator for two-way data binding, if needed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 2不使用双向数据绑定。它使用单向绑定，但提供`[()]`运算符以供需要时使用双向数据绑定。
- en: 'Here is an example to demonstrate `[()]`. Place this code above the `App` component''s
    code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示`[()]`。将此代码放置在`App`组件代码上方：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace the `App` component code with this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件代码替换为以下内容：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Place this code in the `app-template.html` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置在`app-template.html`文件中：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of this code is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![Two-way data binding](img/B05154_12_10.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![双向数据绑定](img/B05154_12_10.jpg)'
- en: Here, enter something in the text field and click on the button. You will see
    an alert box with the text field's value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在文本字段中输入一些内容并点击按钮。您将看到一个包含文本字段值的警告框。
- en: To capture the value of HTML form elements, we need to place `ngModel` inside
    the `[()]` brackets. We can place an attribute name if we are setting up two-way
    data binding between inputs and outputs. We will learn more about outputs later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获HTML表单元素的值，我们需要在`[()]`括号内放置`ngModel`。如果我们正在设置输入和输出之间的双向数据绑定，我们可以放置一个属性名。我们将在后面了解更多关于输出的内容。
- en: Directives
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: '**Directives** are used to change the DOM based on the state. There are two
    types of directives: attribute directives and structural directives. Let''s look
    at each of them.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令**用于根据状态改变DOM。有两种类型的指令：属性指令和结构指令。让我们看看每一个。'
- en: Attribute directives
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性指令
- en: An **attribute directive** changes the appearance or behavior of a DOM element
    based on a change in state. `ngClass` and `ngStyle` are the built-in attribute
    directives. We can also create our own attribute directives.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性指令**根据状态的变化改变DOM元素的外观或行为。`ngClass`和`ngStyle`是内置的属性指令。我们也可以创建自己的属性指令。'
- en: The `ngClass` directive is used to add or remove CSS classes from an element
    whereas the `ngStyle` directive is used to set inline styles.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`指令用于向元素添加或删除CSS类，而`ngStyle`指令用于设置内联样式。'
- en: 'Here is an example of how to use the `ngClass` and `ngStyle` directives. Place
    this code above the `App` component''s code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用`ngClass`和`ngStyle`指令的一个例子。将此代码放置在`App`组件的代码上方：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码替换为以下内容：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then, place this code at the end of the `app-template.html` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码放置在`app-template.html`文件的末尾：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, if you inspect the `<sampleeight>` tag in browser developer tools, you
    will see this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器开发者工具中检查`<sampleeight>`标签，你会看到以下内容：
- en: '![Attribute directives](img/B05154_12_11.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![属性指令](img/B05154_12_11.jpg)'
- en: Most of this code is self-explanatory. You can see that the same `[]` token
    is also used for attribute directives. When the `[]` token is used, Angular 2
    first checks to see whether a built-in attribute directive or custom directive
    is present with that name, and if not, it treats it as an attribute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是自解释的。你可以看到相同的`[]`令牌也用于属性指令。当使用`[]`令牌时，Angular 2首先检查是否存在具有该名称的内置属性指令或自定义指令，如果不存在，则将其视为属性。
- en: Structural directives
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化指令
- en: A **structural directive** changes the DOM layout by adding or removing DOM
    elements. `ngIf`, `ngSwitch`, and `ngFor` are the three built-in structural directives.
    We can also create our own custom structural directives.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**结构化指令**通过添加或删除DOM元素来改变DOM布局。`ngIf`、`ngSwitch`和`ngFor`是三个内置的结构化指令。我们也可以创建自己的自定义结构化指令。
- en: 'Here is an example to demonstrate `ngIf` and `ngSwitch`. We have already seen
    an example of `ngFor` previously. Place this code above the `App` component''s
    code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个演示`ngIf`和`ngSwitch`的例子。我们之前已经看到了`ngFor`的例子。将此代码放置在`App`组件的代码上方：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file named `samplecomponent9-template.html`, and place it in the `componentTemplates`
    directory. Place this code in that file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`samplecomponent9-template.html`的文件，并将其放置在`componentTemplates`目录中。将此代码放置在该文件中：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码替换为以下内容：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, place this code in the `app-template.html` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将此代码放置在`app-template.html`文件的末尾：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of this code is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![Structural directives](img/B05154_12_13.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![结构化指令](img/B05154_12_13.jpg)'
- en: Most of this code is self-explanatory. You can see that we are using the `*`
    token for structural directives. The `*` token treats the element as a template,
    that is, it doesn't render the element but uses it as a template to create the
    DOM.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是自解释的。你可以看到我们正在使用`*`令牌作为结构化指令。`*`令牌将元素视为模板，也就是说，它不会渲染元素，而是将其用作模板来创建DOM。
- en: 'Actually, both attribute and structural directives are written using the `[]`
    token, but writing code using structural directives with the `[]` token makes
    the code longer. Therefore, Angular 2 introduced the `*` token, which makes it
    easy to write code using structural directives. Internally, Angular 2 translates
    the code that uses the `*` token to use the `[]` token. Learn more about it here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，属性和结构化指令都是使用`[]`令牌编写的，但使用`[]`令牌编写结构化指令的代码会更长。因此，Angular 2引入了`*`令牌，这使得使用结构化指令编写代码变得容易。内部，Angular
    2将使用`*`令牌的代码转换为使用`[]`令牌的代码。更多关于它的信息请在这里了解：
- en: '[https://angular.io/docs/ts/latest/guide/template-syntax.html#](https://angular.io/docs/ts/latest/guide/template-syntax.html#)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://angular.io/docs/ts/latest/guide/template-syntax.html#](https://angular.io/docs/ts/latest/guide/template-syntax.html#)'
- en: Outputs
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出
- en: '**Outputs** allow components to emit custom events. For example, if we have
    a component that displays a button and we want the parent component to be able
    to add an event handler for the click event of the child component, we can achieve
    this using outputs.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**允许组件发出自定义事件。例如，如果我们有一个显示按钮的组件，并且我们希望父组件能够为子组件的点击事件添加事件处理器，我们可以通过使用输出来实现这一点。'
- en: 'Here is an example of how to integrate outputs. Place this code above the `App`
    component''s code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何集成输出的一个例子。将此代码放置在`App`组件的代码上方：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码替换为以下内容：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, place this code at the end of the `app-template.html` file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将此代码放置在`app-template.html`文件的末尾：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, you will start seeing a counter appear on the page.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将开始在页面上看到计数器出现。
- en: The `outputs` property is used to define the events the component emits. We
    need to create a property in this keyword with the same name as the output and
    assign it to a new instance of `ng.core.EventEmitter` so that it can emit events.
    `ng.core.EventEmitter` provides observer patterns to objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs`属性用于定义组件发出的事件。我们需要在这个关键字中创建一个与输出同名的属性，并将其分配给一个新的`ng.core.EventEmitter`实例，以便它可以发出事件。`ng.core.EventEmitter`为对象提供了观察者模式。'
- en: To capture events, we need to use the `()` token, just like we used it to capture
    native UI events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获事件，我们需要使用`()`标记，就像我们用来捕获原生UI事件一样。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we need to assign output to a new instance of `ng.core.EventEmitter`
    inside the constructor property, that is, during the creation of a new instance
    of the component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要在构造函数属性内部分配输出到一个新的`ng.core.EventEmitter`实例，即在创建组件新实例的过程中。
- en: Two-way data binding with inputs and outputs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和输出的双向数据绑定
- en: You can implement two-way data binding between inputs and outputs. For example,
    if a parent component passes an attribute to a component of the view children
    and the child component notifies the parent component whenever the input value
    changes, then instead of using `()` and `[]` separately, we can use `[()]`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输入和输出之间实现双向数据绑定。例如，如果一个父组件将属性传递给视图子组件，并且子组件在输入值更改时通知父组件，那么我们不需要分别使用`()`和`[]`，我们可以使用`[()]`。
- en: 'Here is an example to demonstrate this. Place this code above the `App` component''s
    code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点。将以下代码放置在`App`组件代码上方：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码替换为以下内容：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, add this code to the end of the `app-template.html` file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到`app-template.html`文件的末尾：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, the output is same as the previous example. Most of the things are self-explanatory.
    The only thing you need to know is that both these code snippets do the same thing:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，输出与上一个示例相同。大多数内容都是不言自明的。唯一需要知道的是，这两个代码片段执行的是相同的功能：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Understanding providers
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解提供者
- en: A **provider** tells Angular 2 how to create an instance of a service while
    injecting it. A provider is set using the `providers` or `viewProviders` properties
    of a component.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供者**告诉Angular 2如何创建服务的实例并在注入时使用它。提供者是通过组件的`providers`或`viewProviders`属性设置的。'
- en: 'Let''s look at an example of how to create providers. Place this code above
    the `App` component''s code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建提供者的一个示例。将以下代码放置在`App`组件代码上方：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码替换为以下内容：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, add this to the end of the `app-template.html` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下内容添加到`app-template.html`文件的末尾：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is the console output of the code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的控制台输出：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is how it works:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理：
- en: 'First, we create four services: `Service1`, `Service2`, `Service3`, and `Service4`.
    They all have a `getValue` method, which returns a string. `Service4` is dependent
    on `Service2` and `Service3`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建了四个服务：`Service1`、`Service2`、`Service3`和`Service4`。它们都有一个`getValue`方法，该方法返回一个字符串。`Service4`依赖于`Service2`和`Service3`。
- en: Then, we create a component called `ServiceTest1`. It's dependent on `Service1`.
    In the `viewProviders` property, we passed an array of providers. A provider is
    created using the `ng.core.provide` method. It takes two arguments; the first
    one is the service name, and the second one is the configuration object, which
    states how to create an instance of this service. The `useClass` property tells
    Angular 2 to create a instance of this service when an instance of the service
    in the first argument is requested. So here, when an instance of `Service1` is
    required, an instance of `Service4` is what is actually created. Similarly, `useValue`
    is used to provide a value, and `useFactory` is used to pass control to a function
    to decide what to return when a new instance is requested. So here, when an instance
    of `Service2` is requested, we get the `def` string, and when `Service3` is requested,
    we get the `mno` string.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个名为`ServiceTest1`的组件。它依赖于`Service1`。在`viewProviders`属性中，我们传递了一个提供者数组。一个提供者是通过`ng.core.provide`方法创建的。它接受两个参数；第一个是服务名称，第二个是配置对象，它说明了如何创建此服务的实例。`useClass`属性告诉Angular
    2在请求第一个参数中的服务实例时创建此服务的实例。所以在这里，当需要`Service1`的实例时，实际上创建的是`Service4`的实例。同样，`useValue`用于提供值，而`useFactory`用于将控制传递给一个函数，以决定在请求新实例时返回什么。所以在这里，当请求`Service2`的实例时，我们得到`def`字符串，当请求`Service3`时，我们得到`mno`字符串。
- en: Earlier in this chapter, we were simply assigning `viewProviders` to the services
    themselves. A service also implements the interface of a provider such that it
    creates the instance of the service itself.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们只是将 `viewProviders` 赋值给服务本身。服务还实现了提供者接口，以便创建服务本身的实例。
- en: If there are multiple providers matching a service, then the latest one overrides
    the previous one.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个提供者匹配一个服务，则最新的一个将覆盖先前的提供者。
- en: The difference between providers and the viewProviders property
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者和 `viewProviders` 属性之间的区别
- en: The `viewProviders` property allows us to make providers available to the component's
    view only, whereas the `providers` property makes a provider available to its
    content children and view children.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewProviders` 属性允许我们仅将提供者使组件视图可用，而 `providers` 属性则使提供者对其内容子组件和视图子组件可用。'
- en: 'The `providers` property creates a service instance only once and provides
    the same to whichever component asks for it. We have already seen how `viewProviders`
    works. Let''s look at an example of how `providers` works. Place this code above
    the App component''s code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`providers` 属性仅创建一个服务实例，并将其提供给任何请求它的组件。我们已经看到了 `viewProviders` 的工作方式。让我们看看
    `providers` 的工作示例。将此代码放置在 App 组件代码之上：'
- en: '[PRE57]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换 `App` 组件的代码：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, at the end of the `app-template.html` file, place this code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `app-template.html` 文件末尾，放置以下代码：
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The console output of this code is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的控制台输出如下：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Most of the things in this code are self-explanatory. We are using `providers`
    instead of `viewProviders`. The `ServiceTest2` component is dependent on `Service5`,
    but it doesn't have a provider for `Service5`, so Angular 2 uses the provider
    provided by `ServiceTest3`, as `ServiceTest3` is its parent. If `ServiceTest3`
    hadn't had a provider for `Service5`, Angular 2 would have gone further above
    and looked for the provider in the `App` component.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的大部分内容都是不言自明的。我们使用 `providers` 而不是 `viewProviders`。`ServiceTest2` 组件依赖于 `Service5`，但它没有为
    `Service5` 提供提供者，因此 Angular 2 使用 `ServiceTest3` 提供的提供者，因为 `ServiceTest3` 是其父组件。如果
    `ServiceTest3` 没有为 `Service5` 提供提供者，Angular 2 将进一步向上查找 `App` 组件中的提供者。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ng.platform.browser.bootstrap` method also takes a second argument, which
    is a list of providers that is available to all the components. So, instead of
    passing providers in the `App` component, we can pass them through the `ng.platform.browser.bootstrap`
    method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng.platform.browser.bootstrap` 方法还接受第二个参数，这是一个提供给所有组件的提供者列表。因此，我们不必在 `App`
    组件中传递提供者，而是可以通过 `ng.platform.browser.bootstrap` 方法传递它们。'
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Angular 2\. We saw what components are, how
    to write templates, how to create services, and so on. We also learned about web
    components and how Angular 2 takes advantage of them. You should now be comfortable
    with building Angular 2 applications.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Angular 2。我们了解了组件是什么，如何编写模板，如何创建服务，等等。我们还学习了关于 Web 组件以及 Angular 2
    如何利用它们的内容。你现在应该能够舒适地构建 Angular 2 应用程序。
- en: In the next chapter, we will learn how to build an SPA using Angular 2 by building
    a complete app.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过构建一个完整的应用程序来使用 Angular 2 构建一个单页应用程序（SPA）。
