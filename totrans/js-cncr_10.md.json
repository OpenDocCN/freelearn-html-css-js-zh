["```js\n// The core Node modules we'll need.\nvar http = require('http');\n\n// Commander is an \"npm\" package, and is very helpful\n// with parsing command line arguments.\nvar commander = require('commander');\n\n// Our request handler functions that respond to\n// requests.\nvar handlers = require('./handlers');\n\n// The routes array contains route-handler parings. That \n// is, when a given route RegExp matches against the \n// request URL, the associated handler function is \n// called.\nvar routes = [\n    [ /^\\/api\\/chat\\/(.+)\\/message/i, \n        handlers.sendMessage ],\n    [ /^\\/api\\/chat\\/(.+)\\/join$/i, handlers.joinChat ],\n    [ /^\\/api\\/chat\\/(.+)$/i, handlers.loadChat ],\n    [ /^\\/api\\/chat$/i, handlers.createChat ],\n    [ /^\\/(.+)\\.js$/i, handlers.staticFile ],\n    [ /^\\/(.*)$/i, handlers.index ]\n];\n\n// Adds command line options using the \"commander\" library,\n// and parses them. We're only interested in the \"host\" and\n// the \"port\" values right now. Both options have default\n// values.\ncommander\n    .option('-p, --port <port>', \n        'The port to listen on', 8081)\n    .option('-H --host <host>', \n        'The host to serve from', 'localhost')\n    .parse(process.argv);\n\n// Creates an HTTP server. This handler will iterate over\n// our \"routes\" array, and test for a match. If found, the\n// handler is called with the request, the response, and\n// the regular expression result.\nhttp.createServer((req, res) => {\n    for (let route of routes) {\n        let result = route[0].exec(req.url);\n\n        if (result) {\n            route[1](req, res, result);\n            break;\n        }\n    }\n}).listen(commander.port, commander.host);\n\nconsole.log(`listening\nat http://${commander.host}:${commander.port}`);\n```", "```js\n// This function returns a promise, which is resolved\n// with parsed form data as an object.\nfunction formFields(req) {\n    return new Promise((resolve, reject) => {\n\n        // Use the \"IncomingForm\" class from the\n        // \"formidable\" lib to parse the data. This\n        // \"parse()\" method is async, so we resolve or\n        // reject the promise in the callback.\n        new formidable.IncomingForm()\n            .parse(req, (err, fields) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(fields);\n                }\n            });\n    });\n}\n```", "```js\n// The \"create chat\" API. This endpoint\n// creates a new chat object and stores it in memory.\nexports.createChat = co.wrap(function* (req, res) {\n    if (!ensureMethod(req, res, 'POST')) {\n        return;\n    }\n\n    // Yield the promise returned by \"formFields()\".\n    // This pauses the execution of this handler because\n    // it's a co-routine, created using \"co.wrap()\".\n    var fields = yield formFields(req);\n\n    // The ID for the new chat.\n    var chatId = id();\n\n    // The timestamp used for both the chat, and the\n    // added user.\n    var timestamp = new Date().getTime();\n\n    // Creates the new chat object and stores it. The\n    // \"users\" array is populated with the user that\n    // created the chat. The \"messages\" array is empty\n    // by default.\n    var chat = chats[chatId] = {\n        timestamp: timestamp,\n        topic: fields.topic,\n        users: [{\n            timestamp: timestamp,\n            name: fields.user\n        }],\n        messages: []\n    };\n\n    // The response is the JSON encoded version of the\n    // chat object. The chat ID is added to the response\n    // since it's stored as a key, not a chat property.\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(Object.assign({\n        id: chatId\n    }, chat)));\n});\n```", "```js\n// This endpoint allows a user to join an existing\n// chat that's been shared with them (a URL).\nexports.joinChat = co.wrap(function* (req, res, id) {\n    if (!ensureMethod(req, res, 'POST')) {\n        return;\n    }\n\n    // Load the chat from the memory - the \"chats\"\n    // object.\n    var chat = chats[id[1]];\n\n    if (!ensureFound(req, res, chat)) {\n        return;\n    }\n\n    // Yield to get the parsed form fields. This\n    // function is a co-routine created using \"co.wrap()\".\n    var fields = yield formFields(req);\n\n    chat.timestamp = new Date().getTime();\n\n    // Adds the new user to the chat.\n    chat.users.push({\n        timestamp: chat.timestamp,\n        name: fields.user\n    });\n\n    // Responds with the JSON encoded chat string. We\n    // need to add the ID separately as it's not a\n    // chat property.\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(Object.assign({\n        id: id[1],\n    }, chat)));\n});\n```", "```js\n// This endpoint loads a chat. This function\n// isn't wrapped as a co-routine because there's\n// no asynchronous actions to wait for.\nexports.loadChat = function(req, res, id) {\n\n    // Lookup the chat, using the \"id\" from the URL\n    // as the key.\n    var chat = chats[id[1]];\n\n    if (!ensureFound(req, res, chat)) {\n        return;\n    }\n\n    // Respond with the JSON encoded string version\n    // of the chat.\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(chat));\n};\n```", "```js\n// This handler posts a new message to a given chat. It's\n// also a co-routine function since it needs to wait for\n// asynchronous actions to complete.\nexports.sendMessage = co.wrap(function* (req, res, id) {\n    if (!ensureMethod(req, res, 'POST')) {\n        return;\n    }\n\n    // Load the chat and ensures that it's found.\n    var chat = chats[id[1]];\n\n    if (!ensureFound(req, res, chat)) {\n        return;\n    }\n\n    // Get's the parsed form fields by yielding the\n    // promise returned from \"formFields()\".\n    var fields = yield formFields(req);\n\n    chat.timestamp = new Date().getTime();\n\n    // Pushes the new message object to the \"messages\" \n    // property.\n    chat.messages.push({\n        timestamp: chat.timestamp,\n        user: fields.user,\n        message: fields.message\n    });\n\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(chat));\n});\n```", "```js\n// Helper function used to serve static files.\nfunction serveFile(req, res, file) {\n\n    // Creates a stream to read the file.\n    var stream = fs.createReadStream(file);\n\n    // End the response when there's no more input.\n    stream.on('end', () => {\n        res.end();\n    });\n\n    // Pipe the input file to the HTTP response,\n    // which is a writable stream.\n    stream.pipe(res);\n}\n\n// Serves the requested path as a static file.\nexports.staticFile = function(req, res) {\n    serveFile(req, res,\n        path.join(__dirname, req.url));\n};\n\n// By default, we want to serve the \"index.html\" file.\nexports.index = function index(req, res) {\n    res.setHeader('ContentType', 'text/html');\n\n    serveFile(req, res,\n        path.join(__dirname, 'index.html'));\n};\n```", "```js\n// A generic function used to send HTTP requests to the\n// API. The \"method\" is the HTTP method, the \"path\" is\n// the request path, and the \"data\" is the optional\n// request payload.\nfunction api(method, path, data) {\n\n    // Returns a promise to the called, resolved with\n    // the API response, or failure.\n    return new Promise((resolve, reject) => {\n        var request = new XMLHttpRequest();\n\n        // Resolves the promise using the parsed JSON\n        // object - usually a chat.\n        request.addEventListener('load', (e) => {\n            resolve(JSON.parse(e.target.responseText));\n        });\n\n        // Rejects the promise when there's a problem with\n        // the API.\n        request.addEventListener('error', (e) => {\n            reject(e.target.statusText || 'unknown error');\n        });\n\n        request.addEventListener('abort', resolve);\n\n        request.open(method, path);\n\n        // If there's no \"data\", we can simply \"send()\"\n        // the request. Otherwise, we have to create a\n        // new \"FormData\" instance to properly encode\n        // the form data for the request.\n        if (Object.is(data, undefined)) {\n            request.send();\n        } else {\n            var form = new FormData();\n\n            Object.keys(data).forEach((key) => {\n                form.append(key, data[key]);\n            });\n\n            request.send(form);\n        }\n    });\n}\n```", "```js\n// Filters the \"chat\" object to include only new users\n// and new messages. That is, data with a newer\n// \"timestamp\" than when we last checked.\nfunction filterChat(chat) {\n    Object.assign(chat, {\n\n        // Assigns the filtered arrays to the\n        // corresponding \"chat\" properties.\n        users: chat.users.filter(\n            user => user.timestamp > timestamp\n        ),\n        messages: chat.messages.filter(\n            message => message.timestamp > timestamp\n        )\n    });\n\n    // Reset the \"timestamp\" so we can look for newer\n    // data next time around. We return the modified\n    // chat instance.\n    timestamp = chat.timestamp;\n    return chat;\n}\n\n// Creates a chat using the given \"topic\" and \"user\".\n// The returned promise is resolved with the created\n// chat data.\nfunction createChat(topic, user) {\n    return api('post', 'api/chat', {\n        topic: topic,\n        user: user\n    });\n}\n\n// Joins the given \"user\" to the given chat \"id\".\n// The returned promise is resolved with the\n// joined chat data.\nfunction joinChat(id, user) {\n    return api('post', `api/chat/${id}/join`, {\n        user: user\n    }).then(filterChat);\n}\n\n// Loads the given chat \"id\". The returned promise\n// is resolved with filtered chat data.\nfunction loadChat(id) {\n    return api('get', `api/chat/${id}`)\n        .then(filterChat);\n};\n\n// Posts a \"message\" from the given \"user\" to the given\n// chat \"id\". The returned promise is resolved with\n// filtered chat data.\nfunction sendMessage(id, user, message) {\n    return api('post', `api/chat/${id}/message`, {\n        user: user,\n        message: message\n    }).then(filterChat);\n}\n```", "```js\n<div id=\"create\" class=\"hide\">\n    <h1>Create Chat</h1>\n    <p>\n        <label for=\"topic\">Topic:</label>\n        <input name=\"topic\" id=\"topic\" autofocus/>\n    </p>\n    <p>\n        <label for=\"create-user\">Your Name:</label>\n        <input name=\"create-user\" id=\"create-user\"/>\n    </p>\n    <button>Create</button>\n</div>\n<div id=\"join\" class=\"hide\">\n    <h1>Join Chat</h1>\n    <p>\n        <label for=\"join-user\">Your Name:</label>\n        <input name=\"join-user\" id=\"join-user\" autofocus/>\n    </p>\n    <button>Join</button>\n</div>\n<div id=\"view\" class=\"hide\">\n    <h1></h1>\n    <div>\n        <div>\n            <ul id=\"messages\"></ul>\n            <input placeholder=\"message\" autofocus/>\n        </div>\n        <ul id=\"users\"></ul>\n    </div>\n</div>\n```", "```js\n// Updates the given \"chat\" in the DOM.\nfunction drawChat(chat) {\n\n    // Our main DOM components. \"$users\" is the\n    // list of users in the chat. \"$messages\" is the\n    // list of messages in the chat. \"$view\" is the\n    // container element for both lists.\n    var $users = document.getElementById('users'),\n    $messages = document.getElementById('messages'),\n    $view = document.getElementById('view');\n\n    // Update the document title to reflect the chat\n    // \"topic\", display the chat container by removing\n    // the \"hide\" class, and update the title of the\n    // chat in bold heading.\n    document.querySelector('title')\n        .textContent = chat.topic;\n    $view.classList.remove('hide');\n    $view.querySelector('h1')\n        .textContent = chat.topic;\n\n    // Iterates over the messages, making no assumptions\n    // about filtering or anything like that.\n    for (var message of chat.messages) {\n\n        // Constructs the DOM elements we'll need for\n        // the user portion of the message.\n        var $user = document.createElement('li'),\n            $strong = document.createElement('strong'),\n            $em = document.createElement('em');\n\n        // Assemble the DOM structure...\n        $user.appendChild($strong);\n        $user.appendChild($em);\n        $user.classList.add('user');\n\n        // Add content - the user name, and time the message\n        // was posted.\n        $strong.textContent = message.user + ' ';\n        $em.textContent = new Date(message.timestamp)\n            .toLocaleString();\n\n        // The message itself...\n        var $message = document.createElement('li');\n        $message.textContent = message.message;\n\n        // Attach the user portion and the message portion,\n        // to the DOM.\n        $messages.appendChild($user);\n        $messages.appendChild($message);\n    }\n\n    // Iterates over the users in the chat, making no\n    // assumptions about the data, only displaying it.\n    for (var user of chat.users) {\n        var $user = document.createElement('li');\n        $user.textContent = user.name;\n\n        $users.appendChild($user);\n    }\n\n    // Make sure that the user can see the newly-rendered\n    // content.\n    $messages.scrollTop = $messages.scrollHeight;\n\n    // Return the chat so that this function can be used\n    // as a resolver in a promise resolution chain.\n    return chat;\n}\n```", "```js\n// When the page loads...\nwindow.addEventListener('load', (e) => {\n\n    // The \"chatId\" comes from the page URL. The \"user\"\n    // might already exist in localStorage.\n    var chatId = location.pathname.slice(1),\n        user = localStorage.getItem('user'),\n        $create = document.getElementById('create'),\n        $join = document.getElementById('join');\n\n    // If there's no chat ID in the URL, then we display\n    // the create chat screen, populating the user\n    // input if it was found in localStorage.\n    if (!chatId) {\n        $create.classList.remove('hide');\n\n        if (user) {\n            document.getElementById('create-user')\n               .value = user;\n        }\n\n        return;\n    }\n\n    // If there's no user name found in localStorage,\n    // we display the join screen which allows them\n    // to enter their name before joining the chat.\n    if (!user) {\n        $join.classList.remove('hide');\n        return;\n    }\n\n    // We load the chat, draw it using drawChat(), and\n    // start the chat polling process.\n    api.postMessage({\n        action: 'loadChat',\n        chatId: chatId\n    }).then(drawChat).then((chat) => {\n\n        // If the user isn't part of the chat already,\n        // we join it. This happens when the user name\n        // is cached in localStorage. If the user creates\n        // a chat, then loads it, they'll already belong\n        // to the chat.\n        if (chat.users.map(u => u.name).indexOf(user) < 0) {\n            api.postMessage({\n                action: 'joinChat',\n                chatId: chatId,\n                user: user\n            }).then(drawChat).then(() => {\n                poll(chatId);\n            });\n        } else {\n            poll(chatId);\n         }\n    });\n});\n```", "```js\n// Starts polling the API for the given chat \"id\".\nfunction poll(chatId) {\n    setInterval(() => {\n        api.postMessage({\n            action: 'loadChat',\n            chatId: chatId\n        }).then(drawChat);\n    }, 3000);\n}\n```", "```js\n// This will generate unique IDs. We need them to\n// map tasks executed by web workers to the larger\n// operation that created them.\nfunction* genID() {\n    var id = 0;\n\n    while (true) {\n        yield id++;\n    }\n}\n\n// Creates the global \"id\" generator.\nvar id = genID();\n\n// This object holds the resolver functions from promises,\n// as results come back from workers, we look them up here,\n// based on ID.\nvar resolvers = {};\n\nvar rejectors = {};\n\n// Keep the original implementation of \"postMessage()\"\n// so we can call it later on, in our custom \"postMessage()\"\n// implementation.\nvar postMessage = Worker.prototype.postMessage;\n\n// Replace \"postMessage()\" with our custom implementation.\nWorker.prototype.postMessage = function(data) {\n    return new Promise((resolve, reject) => {\n\n        // The ID that's used to tie together a web worker\n        // response, and a resolver function.\n        var msgId = id.next().value;\n\n        // Stores the resolver so in can be used later, in\n        // the web worker message callback.\n        resolvers[msgId] = resolve;\n\n        rejectors[msgId] = reject;\n\n        // Run the original \"Worker.postMessage()\"\n        // implementation, which takes care of \n        // actually posting the message to the \n        // worker thread.\n        postMessage.call(this, Object.assign({\n            msgId: msgId,\n        }, data));\n    });\n};\n\n// Starts our worker...\nvar api = new Worker('ui-api.js');\n\n// Resolves the promise that was returned by\n// \"postMessage()\" when the worker responds.\napi.addEventListener('message', (e) => {\n\n    // If the data is in an error state, then\n    // we want the rejector function, and we call\n    // that with the error. Otherwise, call the\n    // regular resolver function with the data returned\n    // from the worker.\n    var source = e.data.error ? rejectors : resolvers,\n        callback = source[e.data.msgId],\n        data = e.data.error ? e.data.error : e.data;\n\n    callback(data);\n\n    // Don't need'em, delete'em.\n    delete resolvers[e.data.msgId];\n    delete rejectors[e.data.msgId];\n});\n```", "```js\n// Listens for messages coming from the main thread.\naddEventListener('message', (e) => {\n\n    // The generic promise resolver function. It's\n    // job is to post data back to the main thread\n    // using \"postMessage()\". It also returns the\n    // data so that it may be used further down in\n    // the promise resolution chain.\n    function resolve(data) {\n        postMessage(Object.assign({\n            msgId: e.data.msgId\n        }, data));\n\n        return data;\n    }\n\n    // The generic rejector function posts data back\n    // to the main thread. The difference here is that\n    // it marks the data as an error. This allows the\n    // promise on the other end to be rejected.\n    function reject(error) {\n        postMessage({\n            msgId: e.data.msgId,\n            error: error.toString()\n        });\n\n        return error;\n    }\n\n    // This switch decides which function to call based\n    // on the \"action\" message property. The \"resolve()\"\n    // function is passed as the resolver to each returned \n    // promise.\n    switch (e.data.action) {\n        case 'createChat':\n            createChat(e.data.topic, e.data.user)\n                .then(resolve, reject);\n            break;\n        case 'joinChat':\n            joinChat(e.data.chatId, e.data.user)\n                .then(resolve, reject);\n            break;\n        case 'loadChat':\n            loadChat(e.data.chatId)\n                .then(resolve, reject)\n            break;\n        case 'sendMessage':\n            sendMessage(\n                e.data.chatId,\n                e.data.user,\n                e.data.message\n            ).then(resolve, reject);\n            break;\n    }\n});\n```"]