- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Thinking Functionally – A First Example
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式思考 – 第一个例子
- en: In [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, we
    went over what FP is, mentioned some advantages of applying it, and listed some
    tools we’d need in JavaScript. For now, let’s leave the theory behind and start
    by considering a simple problem and how to solve it in a functional way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B19301_01.xhtml#_idTextAnchor015)，*成为函数式开发者*中，我们介绍了什么是函数式编程（FP），提到了应用它的某些优点，并列出了我们在
    JavaScript 中需要的工具。现在，让我们先放下理论，考虑一个简单的问题以及如何以函数式方式解决它。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Look at a simple, e-commerce-related problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看一个简单、与电子商务相关的问题
- en: Consider several usual ways to solve it (with their associated defects)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑几种通常的解决方法（及其相关缺陷）
- en: Find a way to solve the problem by looking at it functionally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数式思考找到解决问题的方法
- en: Devise a higher-order solution that can be applied to other problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个可以应用于其他问题的更高阶解决方案
- en: Work out how to carry out unit testing for functional solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何进行功能解决方案的单元测试
- en: In future chapters, we’ll be returning to some of the topics listed here, so
    we won’t be going into too much detail. We’ll just show how FP can give a different
    outlook on our problem and leave further details for later.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将回到这里列出的某些主题，所以我们将不会深入探讨。我们只会展示函数式编程如何以不同的视角看待我们的问题，并将更多细节留到以后。
- en: After working through this chapter, you will have had a first look at a common
    problem and at a way of solving it by thinking functionally, as a prelude for
    the rest of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，你将首次接触到常见问题及其通过函数式思考方式解决问题的方法，这为本书后续内容做了铺垫。
- en: Our problem – doing something only once
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的问题 – 只做一次的事情
- en: Let’s consider a simple but common situation. You have developed an e-commerce
    site; the user can fill their shopping cart, and in the end, they must click on
    a **Bill me** button so that their credit card will be charged. However, the user
    shouldn’t click twice (or more), or they will be billed several times.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单但常见的情况。你已经开发了一个电子商务网站；用户可以填写他们的购物车，最后，他们必须点击一个**账单**按钮，以便他们的信用卡被扣款。然而，用户不应该点击两次（或更多次），否则他们将被多次扣款。
- en: 'The HTML part of your application might have something like this somewhere:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序的 HTML 部分可能在某个地方有类似以下内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, among the scripts, you’d have something similar to the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，你可能会看到以下类似的代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A bad example
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个糟糕的例子
- en: Assigning the events handler directly in HTML, the way I did it, isn’t recommended.
    Instead, unobtrusively, you should set the handler through code. So, *do as I
    say, not as* *I do!*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在 HTML 中分配事件处理器，就像我这样做的那样，是不推荐的。相反，你应该通过代码隐秘地设置处理器。所以，*照我说的做，别像我那样做*！
- en: This is a bare-bones explanation of the web page problem, but it’s enough for
    our purposes. Now, let’s get to thinking about ways of avoiding repeated clicks
    on that button. How can we manage to prevent the user from clicking more than
    once? That’s an interesting problem, with several possible solutions – let’s start
    by looking at bad ones!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对网页问题的简单解释，但对我们来说已经足够了。现在，让我们开始思考如何避免重复点击该按钮。我们如何防止用户多次点击？这是一个有趣的问题，有几种可能的解决方案
    – 让我们先看看不好的那些！
- en: How many ways can you think of to solve our problem? Let’s go over several solutions
    and analyze their quality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到多少种解决我们问题的方法？让我们回顾几种解决方案并分析它们的质量。
- en: Solution 1 – hoping for the best!
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1 – 期望最好的结果！
- en: 'How can we solve the problem? The first solution may seem like a joke: do nothing,
    tell the user not to click twice, and hope for the best! Your page might look
    like *Figure 2**.1*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？第一个解决方案可能听起来像是一个玩笑：什么都不做，告诉用户不要点击两次，并期望最好的结果！你的页面可能看起来像*图 2**.1*：
- en: '![Figure 2.1 – An actual screenshot of a page, just warning you against clicking
    more than once](img/Figure_2.1_B19301.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 一页实际的截图，只是提醒你避免多次点击](img/Figure_2.1_B19301.jpg)'
- en: Figure 2.1 – An actual screenshot of a page, just warning you against clicking
    more than once
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 一页实际的截图，只是提醒你避免多次点击
- en: This is a way to weasel out of the problem; I’ve seen several websites that
    just warn the user about the risks of clicking more than once and do nothing to
    prevent the situation. So, the user got billed twice? We warned them... it’s their
    fault!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种逃避问题的方法；我见过一些网站只是警告用户关于多次点击的风险，却没有采取任何预防措施。所以，用户被扣款两次？我们警告过他们...这是他们的错！
- en: 'Your solution might simply look like the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解决方案可能看起来像以下代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, this isn’t an actual solution; let’s move on to more serious proposals.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不是一个真正的解决方案；让我们继续探讨更严肃的提议。
- en: Solution 2 – using a global flag
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2 – 使用全局标志
- en: 'The solution most people would probably think of first is using some global
    variable to record whether the user has already clicked on the button. You define
    a flag named something like `clicked`, initialized with `false`. When the user
    clicks on the button, if `clicked` is `false`, you change it to `true` and execute
    the function; otherwise, you do nothing at all. This can be seen in the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能首先想到的解决方案是使用一些全局变量来记录用户是否已经点击了按钮。你可以定义一个名为 `clicked` 的标志，初始化为 `false`。当用户点击按钮时，如果
    `clicked` 是 `false`，你将其更改为 `true` 并执行函数；否则，你什么都不做。这可以在以下代码中看到：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This works, but it has several problems that must be addressed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但它有几个必须解决的问题：
- en: You are using a global variable, and you could change its value by accident.
    Global variables aren’t a good idea, in JavaScript or other languages. You must
    also remember to re-initialize it to `false` when the user starts buying again.
    If you don’t, the user won’t be able to make a second purchase because paying
    will become impossible.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在使用全局变量，并且可能会意外地更改其值。在 JavaScript 或其他语言中，全局变量不是一个好主意。你还必须记得在用户再次开始购买时将其重新初始化为
    `false`。如果你不这样做，用户将无法进行第二次购买，因为支付将变得不可能。
- en: You will have difficulties testing this code because it depends on external
    things (that is, the clicked variable).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将难以测试此代码，因为它依赖于外部事物（即，点击变量）。
- en: So, this isn’t a very good solution. Let’s keep thinking!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这不是一个非常好的解决方案。让我们继续思考！
- en: Solution 3 – removing the handler
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 3 – 移除处理程序
- en: 'We may go for a lateral kind of solution, and instead of having the function
    avoid repeated clicks, we might just remove the possibility of clicking altogether.
    The following code does just that; the first thing that `billTheUser()` does is
    remove the `onclick` handler from the button, so no further calls will be possible:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能寻求一种横向的解决方案，而不是让函数避免重复点击，我们可能完全移除点击的可能性。以下代码正是这样做的；`billTheUser()` 做的第一件事就是从按钮中移除
    `onclick` 处理程序，因此将不再可能进行进一步的调用：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This solution also has some problems:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案也有一些问题：
- en: The code is tightly coupled to the button, so you won’t be able to reuse it
    elsewhere
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码与按钮紧密耦合，因此你无法在其他地方重用它。
- en: You must remember to reset the handler; otherwise, the user won’t be able to
    make a second purchase
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须记得重置处理程序；否则，用户将无法进行第二次购买。
- en: Testing will also be more complex because you’ll have to provide some DOM elements
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试也将变得更加复杂，因为你将必须提供一些 DOM 元素。
- en: 'We can enhance this solution a bit and avoid coupling the function to the button
    by providing the latter’s ID as an extra argument in the call. (This idea can
    also be applied to some of the further solutions that we’ll see.) The HTML part
    would be as follows; note the extra argument to `billTheUser()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增强这个解决方案，并通过在调用中提供按钮的 ID 作为额外的参数来避免将函数耦合到按钮上。（这个想法也可以应用于我们将会看到的某些其他解决方案。）HTML
    部分如下；注意 `billTheUser()` 的额外参数：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also have to change the called function so that it will use the received
    `buttonId` value to access the corresponding button:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更改调用的函数，以便它将使用接收到的 `buttonId` 值来访问相应的按钮：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This solution is somewhat better. But, in essence, we are still using a global
    element – not a variable, but the `onclick` value. So, despite the enhancement,
    this isn’t a very good solution either. Let’s move on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案稍微好一些。但，本质上，我们仍在使用一个全局元素 – 不是变量，而是 `onclick` 值。所以，尽管有所改进，但这也不是一个非常好的解决方案。让我们继续前进。
- en: Solution 4 – changing the handler
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 4 – 更改处理程序
- en: 'A variant to the previous solution would be not to remove the click function,
    but to assign a new one instead. We are using functions as first-class objects
    here when we assign the `alreadyBilled()` function to the click event. The function
    warning the user that they have already clicked could look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个解决方案的一个变体可能不是删除点击函数，而是分配一个新的函数。在这里，当我们将 `alreadyBilled()` 函数分配给点击事件时，我们正在使用函数作为一等对象。警告用户他们已经点击的函数可能看起来像这样：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our `billTheUser()` function would then be like the following code – note how
    instead of assigning `null` to the `onclick` handler as in the previous section,
    now, the `alreadyBilled()` function is assigned:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `billTheUser()` 函数将如下所示 – 注意与上一节中分配 `null` 到 `onclick` 处理程序不同，现在分配的是 `alreadyBilled()`
    函数：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There’s a good point to this solution; if the user clicks a second time, they’ll
    get a warning not to do that, but they won’t be billed again. (From the point
    of view of user experience, it’s better.) However, this solution still has the
    very same objections as the previous one (code coupled to the button, needing
    to reset the handler, and harder testing), so we don’t consider it quite good
    anyway.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案也有优点；如果用户第二次点击，他们会收到警告不要这样做，但不会再次收费。（从用户体验的角度来看，这更好。）然而，这个解决方案仍然有与上一个相同的反对意见（代码与按钮耦合，需要重置处理器，以及更困难的测试），所以我们仍然认为它并不好。
- en: Solution 5 – disabling the button
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 5 – 禁用按钮
- en: 'A similar idea here is instead of removing the event handler, we can disable
    the button so the user won’t be able to click. You might have a function such
    as the one shown in the following code, which does exactly that by setting the
    `disabled` attribute of the button:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一个类似的想法：我们不是移除事件处理器，而是禁用按钮，这样用户就无法点击。你可能有一个如下所示的函数，它通过设置按钮的`disabled`属性来执行这一操作：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This also works, but we still have objections as with the previous solutions
    (coupling the code to the button, needing to re-enable the button, and harder
    testing), so we don’t like this solution either.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这也行得通，但我们仍然有与之前解决方案相同的反对意见（将代码与按钮耦合，需要重新启用按钮，以及更困难的测试），所以我们也不喜欢这个解决方案。
- en: Solution 6 – redefining the handler
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 6 – 重新定义处理器
- en: 'Another idea: instead of changing anything in the button, let’s have the event
    handler change itself. The trick is in the second line of the following code;
    by assigning a new value to the `billTheUser` variable, we are dynamically changing
    what the function does! The first time you call the function, it will do its thing,
    but it will also change itself out of existence by giving its name to a new function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法：我们不是在按钮上做任何改变，而是让事件处理器改变自己。技巧在于以下代码的第二行；通过给`billTheUser`变量赋一个新的值，我们动态地改变了函数的行为！第一次调用函数时，它会执行其操作，但它也会通过将其名称赋予一个新的函数来改变自己消失：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There’s a special trick in the solution. Functions are global, so the `billTheUser=...`
    line changes the function’s inner workings. From that point on, `billTheUser`
    will be the new (null) function. This solution is still hard to test. Even worse,
    how would you restore the functionality of `billTheUser`, setting it back to its
    original objective?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中有一个特殊的技巧。函数是全局的，所以`billTheUser=...`这一行改变了函数的内部工作方式。从那时起，`billTheUser`将变成新的（空）函数。这个解决方案仍然很难测试。更糟糕的是，你该如何恢复`billTheUser`的功能，将其恢复到原始目标？
- en: Solution 7 – using a local flag
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 7 – 使用局部标志
- en: 'We can go back to the idea of using a flag, but instead of making it global
    (which was our main objection to the second solution), we can use an `clicked`
    will be local to the function and not visible anywhere else:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到使用标志的想法，但不是将其设置为全局的（这是我们反对第二个解决方案的主要原因），我们可以使用一个`clicked`，它将只对函数是局部的，在其他任何地方都不可见：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This solution is along the lines of the global variable solution, but using
    a private, local variable is an enhancement. (Note how `clicked` gets its initial
    value from the call at the end.) The only drawback we could find is that we'll
    have to rework every function that needs to be called only once to work in this
    fashion (and, as we’ll see in the following section, our FP solution is similar
    to it in some ways). Okay, it’s not too hard to do, but don’t forget the **Don’t
    Repeat Yourself** (**DRY**), usual advice!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案与全局变量解决方案类似，但使用私有、局部变量是一种改进。（注意`clicked`是如何从最后的调用中获得其初始值的。）我们唯一能找到的缺点是，我们必须重写每个只需要调用一次的函数，以便以这种方式工作（而且，正如我们将在下一节中看到的，我们的函数式解决方案在某些方面与之相似）。好吧，这并不太难做，但别忘了**不要重复自己**（**DRY**）的常规建议！
- en: We have now gone through multiple ways of solving our “do something only once”
    problem – but as we’ve seen, they were not very good! Let’s think about the problem
    functionally so that we get a more general solution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了多种解决“只做一次”问题的方法 – 但正如我们所看到的，它们并不很好！让我们从功能的角度思考这个问题，以便我们得到一个更通用的解决方案。
- en: A functional solution to our problem
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们问题的功能解决方案
- en: 'Let’s try to be more general; after all, requiring that some function or other
    be executed only once isn’t that outlandish, and may be required elsewhere! Let’s
    lay down some principles:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更通用一些；毕竟，要求某些函数或其他函数只执行一次并不荒谬，可能在其他地方也需要！让我们制定一些原则：
- en: The original function (the one that may be called only once) should do whatever
    it is expected to do and nothing else
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始函数（可能只能调用一次的函数）应该执行它预期执行的所有操作，而不做其他任何事情
- en: We don’t want to modify the original function in any way
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不希望以任何方式修改原始函数
- en: We need a new function that will call the original one only once
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个新函数，它将只调用原始函数一次
- en: We want a general solution that we can apply to any number of original functions
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望得到一个通用的解决方案，可以应用于任意数量的原始函数
- en: A SOLID base
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 基础
- en: The first principle listed previously is the single responsibility principle
    (the S in the **SOLID** acronym), which states that every function should be responsible
    for a single functionality. For more on SOLID, check the article by Uncle Bob
    (Robert C. Martin, who wrote the five principles) at [butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的第一个原则是单一职责原则（SOLID 缩写中的 S），它指出每个函数都应该负责单一功能。有关 SOLID 的更多信息，请参阅 Uncle Bob（罗伯特·马丁，他写了这五个原则）的文章，见
    [butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)。
- en: Can we do it? Yes, and we’ll write a higher-order function, which we’ll be able
    to apply to any function, to produce a new function that will work only once.
    Let’s see how! We will introduce higher-order functions in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*. There, we’ll go about testing our functional solution,
    as well as making some enhancements to it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能行吗？是的，我们将编写一个高阶函数，它将能够应用于任何函数，以生成一个新的函数，该函数将只工作一次。让我们看看怎么做！我们将在[*第6章*](B19301_06.xhtml#_idTextAnchor107)“生成函数”中介绍高阶函数。在那里，我们将测试我们的函数解决方案，并对它进行一些改进。
- en: A higher-order solution
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶解决方案
- en: If we don’t want to modify the original function, we can create a higher-order
    function, which we’ll (inspiredly!) name `once()`. This function will receive
    a function as a parameter and return a new function, which will work only once.
    (As we mentioned previously, we’ll be seeing more of higher-order functions later;
    in particular, see the *Doing things once, revisited* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,*
    *Producing Functions*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望修改原始函数，我们可以创建一个高阶函数，我们可以（富有创意地！）将其命名为 `once()`。这个函数将接收一个函数作为参数，并返回一个新的函数，该函数将只工作一次。（正如我们之前提到的，我们将在后面看到更多关于高阶函数的内容；特别是，请参阅[*第6章*](B19301_06.xhtml#_idTextAnchor107)*，*“一次做事情，重访”部分*）。
- en: Many solutions
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多解决方案
- en: Underscore and Lodash already have a similar function, invoked as `_.once()`.
    Ramda also provides `R.once()`, and most FP libraries include similar functionality,
    so you wouldn’t have to program it on your own.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore 和 Lodash 已经有一个类似的函数，称为 `_.once()`。Ramda 也提供了 `R.once()`，大多数 FP 库都包括类似的功能，所以你不必自己编写它。
- en: 'Our `once()` function may seem imposing at first, but as you get accustomed
    to working in an FP fashion, you’ll get used to this sort of code and find it
    to be quite understable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `once()` 函数一开始可能看起来有些吓人，但随着你习惯以 FP 风格工作，你会习惯这种代码，并发现它相当易于理解：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s go over some of the finer points of this function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个函数的一些细节：
- en: Our `once()` function receives a function (`fn`) as its parameter and returns
    a new function, of the same type. (We’ll discuss this typing in more detail shortly.)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `once()` 函数接收一个函数（`fn`）作为其参数，并返回一个相同类型的新的函数。（我们将在稍后更详细地讨论这种类型。）
- en: We define an internal, private `done` variable, by taking advantage of *closure*,
    as in *Solution 7*. We opted not to call it `clicked` (as we did previously) because
    you don’t necessarily need to click on a button to call the function; we went
    for a more general term. Each time you apply `once()` to some function, a new,
    distinct `done` variable will be created and will be accessible only from the
    returned function.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过利用 *闭包*，就像在 *解决方案7* 中那样，定义了一个内部、私有的 `done` 变量。我们选择不将其命名为 `clicked`（如我们之前所做的那样），因为你不一定需要点击按钮来调用函数；我们选择了更通用的术语。每次你将
    `once()` 应用到某个函数时，都会创建一个新的、独特的 `done` 变量，并且只能从返回的函数中访问。
- en: The `return` statement shows that `once()` will return a function, with the
    same type of parameters as the original `fn()` one. We are using the spread syntax
    we saw in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*.
    With older versions of JavaScript, you’d have to work with the arguments object;
    see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)
    for more on that. The modern way is simpler and shorter!
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 语句显示 `once()` 将返回一个函数，其参数类型与原始 `fn()` 相同。我们使用了在 [*第1章*](B19301_01.xhtml#_idTextAnchor015)
    *成为函数式* 中看到的展开语法。在 JavaScript 的旧版本中，你必须处理参数对象；有关更多信息，请参阅 [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)。现代方式更简单、更简洁！'
- en: We assign `done = true` before calling `fn()`, just in case that function throws
    an exception. Of course, if you don’t want to disable the function unless it has
    successfully ended, you could move the assignment below the `fn()` call. (See
    *Question 2.4* in the *Questions* section for another take on this.)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用 `fn()` 之前，我们将 `done = true` 赋值，以防该函数抛出异常。当然，如果你不想在函数成功结束之前禁用它，你可以将赋值移动到
    `fn()` 调用下面。（有关此点的另一种看法，请参阅 *问题* 部分的 *问题2.4*。）
- en: After the setting is done, we finally call the original function. Note the use
    of the spread operator to pass along whatever parameters the original `fn()` had.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置完成后，我们最终调用原始函数。注意使用了展开运算符来传递原始 `fn()` 所有的参数。
- en: 'Typing for `once()` may be obscure. We have to specify that the type of the
    input function and the type of `once()` are the same, and that’s the reason for
    defining `FNType`. *Figure 2**.2* shows that TypeScript correctly understands
    this (Check the answer to *Question 1.7* at the end of this book for another example
    of this):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`once()` 的类型定义可能有些晦涩。我们必须指定输入函数的类型和 `once()` 的类型是相同的，这就是定义 `FNType` 的原因。*图2.2*
    显示 TypeScript 正确理解了这一点（查看本书末尾 *问题1.7* 的答案以获取此例的另一个示例）：'
- en: '![Figure 2.2 – Hovering shows that the type of once()’s output matches the
    type of its input](img/Figure_2.2_B19301.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 悬停显示 once() 输出的类型与输入的类型匹配](img/Figure_2.2_B19301.jpg)'
- en: Figure 2.2 – Hovering shows that the type of once()’s output matches the type
    of its input
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 悬停显示 once() 输出的类型与输入的类型匹配
- en: 'If you’re not still used to TypeScript, let’s see the pure JavaScript equivalent,
    which is the same code but for typing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有习惯使用 TypeScript，让我们看看纯 JavaScript 的等效代码，这同样是相同的代码，但用于类型定义：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, how would we use it? We first create a new version of the billing function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何使用它呢？我们首先创建一个计费函数的新版本。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we rewrite the `onclick` method as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `onclick` 方法重写如下：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the user clicks on the button, the function that gets called with the `(some,
    sales, data)` argument isn’t the original `billTheUser()` but rather the result
    of having applied `once()` to it. The result of that is a function that can be
    called only a single time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，调用带有 `(some, sales, data)` 参数的函数不是原始的 `billTheUser()`，而是应用了 `once()`
    的结果。结果是只能调用一次的函数。
- en: You can’t always get what you want!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能总是得到你想要的！
- en: Note that our `once()` function uses functions such as first-class objects,
    arrow functions, closures, and the spread operator. Back in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015),
    *Becoming Functional*, we said we’d be needing those, so we’re keeping our word!
    All we are missing from that chapter is recursion, but as the Rolling Stones sang,
    *You Can’t Always Get What* *You Want!*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `once()` 函数使用了诸如一等对象、箭头函数、闭包和展开运算符等函数。在 [*第1章*](B19301_01.xhtml#_idTextAnchor015)
    *成为函数式* 中，我们说过我们需要这些，所以我们信守承诺！我们唯一缺少的是递归，但正如滚石乐队所唱的，*你不可能总是得到你想要的*！
- en: We now have a functional way of getting a function to do its thing only once,
    but how would we test it? Let’s get into that topic now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一种功能方式来让函数只做一次事情，但我们应该如何测试它呢？现在让我们来探讨这个话题。
- en: Testing the solution manually
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动测试解决方案
- en: 'We can run a simple test. Let’s write a `squeak()` function that will, appropriately,
    *squeak* when called! The code is simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行一个简单的测试。让我们编写一个 `squeak()` 函数，当被调用时，它将适当地发出 *吱吱声*！代码很简单：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we apply `once()` to it, we get a new function that will squeak only once.
    See the highlighted line in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `once()` 应用到它上面，我们得到一个新的函数，它只会发出一次吱吱声。请看以下代码中高亮的行：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous steps showed us how we could test our `once()` function by hand,
    but our method is not exactly ideal. In the next section, we’ll see why and how
    to do better.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的步骤展示了我们如何手动测试我们的`once()`函数，但我们的方法并不完全理想。在下一节中，我们将看到为什么以及如何做得更好。
- en: Testing the solution automatically
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动测试解决方案
- en: 'Running tests by hand isn’t suitable: it gets tiresome and boring, and it leads,
    after a while, to not running the tests any longer. Let’s do better and write
    some automatic tests with **Jest**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行测试并不合适：它会变得令人厌烦和无聊，而且过一段时间后，会导致不再运行测试。让我们做得更好，并使用**Jest**编写一些自动测试：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are several points to note here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的点：
- en: To spy on a function (for instance, to count how many times it was called),
    we need to pass it as an argument to `jest.fn()`; we can apply tests to the result,
    which works exactly like the original function, but can be spied on.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要监视一个函数（例如，统计它被调用的次数），我们需要将其作为参数传递给`jest.fn()`；我们可以对结果应用测试，它的工作方式与原始函数完全一样，但可以被监视。
- en: When you spy on a function, Jest intercepts your calls and registers that the
    function was called, with which arguments, and how many times it was called.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你监视一个函数时，Jest会拦截你的调用并记录该函数被调用，以及调用次数和参数。
- en: The first test only checks that if we call the function several times, it gets
    called that number of times. This is trivial, but we’d be doing something wrong
    if that didn’t happen!
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次测试只是检查如果我们多次调用函数，它会被调用相应次数。这很简单，但如果这种情况没有发生，我们就做错了什么！
- en: In the second test, we apply `once()` to a (dummy) `myFn()` function, and we
    call the result (`onceFn()`) several times. We then check that `myFn()` was called
    only once, though `onceFn()` was called three times.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们将`once()`应用于一个（虚拟的）`myFn()`函数，并多次调用结果（`onceFn()`）。然后我们检查`myFn()`只被调用了一次，尽管`onceFn()`被调用了三次。
- en: 'We can see the results in *Figure 2**.3*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图2**.3*中看到结果：
- en: '![Figure 2.3 – Running automatic tests on our function with Jest](img/Figure_2.3_B19301.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 使用Jest对我们函数进行自动测试](img/Figure_2.3_B19301.jpg)'
- en: Figure 2.3 – Running automatic tests on our function with Jest
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 使用Jest对我们函数进行自动测试
- en: With that, we have seen not only how to test our functional solution by hand
    but also in an automatic way, so we are done with testing. Let’s just finish by
    considering an even better solution, also achieved in a functional way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们不仅看到了如何手动测试我们的函数解决方案，还看到了自动测试的方法，所以我们已经完成了测试。让我们最后考虑一个更好的解决方案，也是以函数方式实现的。
- en: Producing an even better solution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产生一个更好的解决方案
- en: 'In one of the previous solutions, we mentioned that it would be a good idea
    to do something every time after the first click, and not silently ignore the
    user’s clicks. We’ll write a new higher-order function that takes a second parameter
    – a function to be called every time from the second call onward. Our new function
    will be called `onceAndAfter()` and can be written as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的解决方案中，我们提到每次第一次点击后做一些事情是个好主意，而不是默默地忽略用户的点击。我们将编写一个新的高阶函数，它接受第二个参数——一个从第二次调用开始每次都要调用的函数。我们的新函数将被称为`onceAndAfter()`，可以写成以下形式：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have ventured further into higher-order functions; `onceAndAfter()` takes
    two functions as parameters and produces a third one, which includes the other
    two within.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进一步探索了高阶函数；`onceAndAfter()`接受两个函数作为参数并产生一个第三个函数，它包含其他两个函数。
- en: Function as default
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为默认值
- en: You could make `onceAndAfter()` more powerful by giving a default value for
    `g`, such as `() => {}`, so if you didn’t specify the second function, it would
    still work fine because the default do-nothing function would be called instead
    of causing an error.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为`g`提供一个默认值（例如`() => {}`）来使`onceAndAfter()`更强大，这样如果你没有指定第二个函数，它仍然可以正常工作，因为默认的不做任何事情函数会被调用而不是导致错误。
- en: 'We can do a quick-and-dirty test along the same lines as we did earlier. Let’s
    add a `creak()` creaking function to our previous `squeak()` one and check out
    what happens if we apply `onceAndAfter()` to them. We can then get a `makeSound()`
    function that should squeak once and creak afterward:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样进行快速测试。让我们向之前的`squeak()`函数添加一个`creak()`吱吱作响函数，并检查如果我们将`onceAndAfter()`应用于它们会发生什么。然后我们可以得到一个`makeSound()`函数，它应该先吱吱作响然后吱吱作响：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Writing a test for this new function isn’t hard, only a bit longer. We have
    to check which function was called and how many times:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个新函数编写测试并不难，只是稍微长一点。我们必须检查哪个函数被调用以及调用了多少次：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we always check that `func1()` is called only once. Similarly, we
    check `func2()`; the count of calls starts at zero (the time that `func1()` is
    called), and from then on, it goes up by one on each call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们始终检查 `func1()` 只被调用一次。同样，我们检查 `func2()`；调用次数从零开始（即 `func1()` 被调用时），然后每次调用增加一。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve seen a common, simple problem based on a real-life situation.
    After analyzing several typical ways of solving that, we went for a functional
    thinking solution. We saw how to apply FP to our problem and found a more general
    higher-order solution that we could apply to similar problems with no further
    code changes. We saw how to write unit tests for our code to round out the development
    job.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了一个基于现实生活情况的常见简单问题。在分析了多种解决该问题的典型方法后，我们选择了函数式思考的解决方案。我们看到了如何将 FP 应用到我们的问题上，并找到了一个更通用的更高阶解决方案，我们可以将其应用于类似的问题，而无需进一步修改代码。我们还看到了如何为我们的代码编写单元测试，以完善开发工作。
- en: Finally, we produced an even better solution (from the point of view of the
    user experience) and saw how to code it and how to unit-test it. Now, you’ve started
    to get a grip on how to solve a problem functionally; next, in [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, we’ll delve more deeply into functions, which are
    at the core of all FP.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们产生了一个更好的解决方案（从用户体验的角度来看），并看到了如何编码它以及如何进行单元测试。现在，你已经开始掌握如何以函数式的方式解决问题；接下来，在
    [*第3章*](B19301_03.xhtml#_idTextAnchor054)，*从函数开始*，我们将更深入地探讨函数，这是所有 FP 的核心。
- en: Questions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 2.1 `done`, to mark whether the function had already been called. Not that it
    matters, but could you make do without using any extra variables? Note that we
    aren’t telling you not to use any variables, it’s just a matter of not adding
    any new ones, such as `done`, and only as an exercise!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 `done`，用来标记函数是否已经被调用。虽然这并不重要，但你能否不使用任何额外的变量来完成这个任务？请注意，我们并没有告诉你不要使用任何变量，只是不添加任何新的变量，例如
    `done`，这只是一个练习！
- en: '2.2 `onceAndAfter()` function, can you write an `alternator()` higher-order
    function that gets two functions as arguments and, on each call, alternatively
    calls one and another? The expected behavior should be as in the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 `onceAndAfter()` 函数，你能编写一个 `alternator()` 高阶函数，它接受两个函数作为参数，并在每次调用时交替调用其中一个和另一个吗？预期的行为应如下例所示：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 2.3 `once()`, could you write a higher-order function, `thisManyTimes(fn,n)`,
    that would let you call the `fn()` function up to *n* times, but would do nothing
    afterward? To give an example, `once(fn)` and `thisManyTimes(fn,1)` would produce
    functions that behave the same way. Do also write tests for it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3 `once()`，你能编写一个高阶函数 `thisManyTimes(fn,n)`，它将允许你最多调用 `fn()` 函数 *n* 次，但在之后不做任何事情吗？为了举例，`once(fn)`
    和 `thisManyTimes(fn,1)` 将产生具有相同行为的函数。也要为它编写测试。
- en: 2.4 `once()` to a function, and the first time that function gets called, it
    crashes. Here, we may want to allow a second call to the function, hoping it wouldn’t
    crash again. We want an `onceIfSuccess()` function, that will get a function as
    a parameter and produce a new function that will run successfully only once, but
    will be allowed to fail (throwing exceptions) many times if need be. Implement
    `onceIfSuccess()`, and don’t forget to write unit tests for it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2.4 将 `once()` 函数传递给一个函数，并且当该函数第一次被调用时崩溃。在这里，我们可能希望允许对该函数的第二次调用，希望它不会再次崩溃。我们需要一个
    `onceIfSuccess()` 函数，它将接受一个函数作为参数，并生成一个新的函数，该函数只能成功运行一次，但在必要时允许失败（抛出异常）。实现 `onceIfSuccess()`，并且别忘了为它编写单元测试。
- en: 2.5 `once()` using classic functions, instead of arrow functions. This is just
    meant to help you explore the slightly different needed data typing syntax.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 2.5 使用经典函数而不是箭头函数来实现 `once()`。这只是为了帮助你探索所需的数据类型语法略有不同的需求。
