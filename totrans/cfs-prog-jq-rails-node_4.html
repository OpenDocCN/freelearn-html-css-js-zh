<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. CoffeeScript and Rails</h1></div></div></div><p>Ruby on Rails is a web framework that came around in 2004. It was written by David Heinemeier Hansson and was extracted as a framework from <strong>Basecamp</strong>
<a id="id208" class="indexterm"/>, a project management web application he had written in Ruby for his company <strong>37signals</strong>.</p><p>Rails<a id="id209" class="indexterm"/> immediately impressed a lot of people by how effortlessly and quickly one could go about writing web applications and soon became quite popular.</p><p>At the time it was developed, Ruby was an obscure scripting language from Japan that no one had really heard of. Ruby was really at the heart of why Rails was so successful. It has proved to be a powerful and succinct programming language, and many programmers have stated that it makes programming fun again.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>What makes Rails special?</h1></div></div></div><p>Rails has <a id="id210" class="indexterm"/>pushed the envelope on how web developers approach writing applications. Its core philosophy consists of the following two important principles:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Convention over configuration</li><li class="listitem" style="list-style-type: disc">Don't repeat yourself, or DRY</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Convention over configuration</h2></div></div></div><p>Rails is designed to <a id="id211" class="indexterm"/>assume that the programmer will follow certain known conventions, which if used, provide great benefit and much less need to configure the framework. It's often called an opinionated framework<a id="id212" class="indexterm"/>. That means that the framework makes assumptions on how a typical application should be built and structured and it doesn't try to be overly flexible and configurable. This helps you spend less time on mundane tasks like configuring and wiring up an application architecture and more time on actually building your app.</p><p>For instance, Rails will model tables in your database with objects corresponding to their names, so a record in the <code class="literal">Transactions</code> database will automatically map to a <code class="literal">Transactions</code> class<a id="id213" class="indexterm"/> instance, as will a record in the <code class="literal">people</code> database table automatically map to a <code class="literal">Person</code> class instance.</p><p>Rails will generally use conventions to do smart things for you. Let's say our <code class="literal">people</code> table also has a <code class="literal">datetime</code> field called <code class="literal">created_at</code> and <code class="literal">updated_at</code>. Rails will be smart enough to now automatically update the timestamps on these two fields when a record gets created or updated.</p><p>The most important thing about Rails' conventions is that you should know about them and not fight the framework, or try to diverge too much from the Rails way, without good reason. Often, this can cancel out any of the benefits you get from these conventions, or even make it harder on yourself to try and find workarounds.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Don't repeat yourself (DRY)</h2></div></div></div><p>This<a id="id214" class="indexterm"/> software <a id="id215" class="indexterm"/>engineering principle can also be stated as follows:</p><div><blockquote class="blockquote"><p>Every piece of knowledge must have a single, unambiguous, and authoritative representation within a system.</p></blockquote></div><p>This means that Rails strives to remove duplication and boilerplate wherever it can.</p><p>For instance, a <code class="literal">Person</code> class that models records in the <code class="literal">people</code> table will not need to define its fields, since they are already defined as columns in your database table. Here, Rails can use the powerful metaprogramming capabilities of Ruby to magically add attributes to the <code class="literal">Person</code> class that correspond to columns in your database.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p><strong>Metaprogramming</strong>
<a id="id216" class="indexterm"/> is the concept of writing code that acts on other code as data structures. In other words, metaprogramming is writing code that writes code. It is used heavily in the Ruby community and the Rails source code in particular.</p><p>The Ruby language has very powerful metaprogramming abilities that are tied to the concept of open classes and objects, meaning that you can easily "open up" an existing class definition and redefine and add members to it.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Rails and JavaScript</h1></div></div></div><p>For a long <a id="id217" class="indexterm"/>time, <a id="id218" class="indexterm"/>Rails was shipped with the <code class="literal">Prototype.js</code> and <code class="literal">Script.aculo.us</code> JavaScript libraries for AJAX, page animation, and effects.</p><p>Rails has the concept of view helpers—these are Ruby methods that can be used in views to abstract away <a id="id219" class="indexterm"/>common <a id="id220" class="indexterm"/>HTML constructs. Many of the view helpers that deal with client-side code and AJAX were built on top of these two frameworks, and thus they were completely baked in the framework without an easy way of using alternatives.</p><p><code class="literal">Prototype.js</code> shares many of the same ideas and goals as jQuery, but over time, jQuery has grown to be perceived as a more elegant and powerful library by many programmers.</p><p>As jQuery became more popular, many developers in the Rails community started experimenting by using jQuery with Rails instead of the default JavaScript libraries. A standard set of libraries or <strong>gems</strong>
<a id="id221" class="indexterm"/> emerged for replacing the built-in Prototype library with jQuery.</p><p>In Rails Version 3.1, it was announced that jQuery will be the default JavaScript library. Because jQuery already had most of the animation and page effect features of <code class="literal">Script.aculo.us</code>, this library was also not needed anymore.</p><p>This move seemed to have been a long time coming and generally had the blessings of most of the Rails community.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Rails and CoffeeScript</h1></div></div></div><p>Another <a id="id222" class="indexterm"/>big <a id="id223" class="indexterm"/>addition to Rails 3.1 was the asset pipeline. Its main goal is to make it easy to treat assets such as JavaScript and CSS as first-class citizens in your Rails app. Prior to this, JavaScript and CSS were just served as static content. It also provides an organizational skeleton that helps you to organize your JavaScript and CSS and provides a DSL for accessing them.</p><p>With the asset pipeline, you can organize and manage dependencies between assets using manifest files. Rails will also use the pipeline to minify and concatenate JavaScript as well as apply fingerprints for cache busting.</p><p>The asset pipeline also has a pre-processor chain that will allow you to run files through a series of input-output processors before they are served. It knows which pre-processors to run using file extension names.</p><p>Before Rails 3.1 was released, it was announced that the CoffeeScript compiler would be supported out of the box using the asset pipeline. This was a huge announcement since CoffeeScript is still quite a young language and it stoked quite some controversy within the Rails community, with some lamenting the fact that they didn't want to learn or use this new language.</p><p>The Rails maintainers have stuck to their guns though, and at present it couldn't be easier to use CoffeeScript in Rails. The fact that CoffeeScript is the default for writing client-side JavaScript code has been a huge boost for CoffeeScript, and a lot of Rails developers have since gotten to <a id="id224" class="indexterm"/>know and embraced the language.</p><p>We've been going on about how wonderful Rails is and how well it works with CoffeeScript, so let's get Rails installed so that you can see for yourself what all the fuss is about.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Installing Rails</h1></div></div></div><p>There are<a id="id225" class="indexterm"/> many different ways of installing Ruby and Rails on your <a id="id226" class="indexterm"/>development machine depending on your operating system, which <a id="id227" class="indexterm"/>version of Ruby you would like to use, if you're using version managers, building from source, and dozens of other options. In this book, we will only briefly cover the most common ways of installing it on Windows, Mac, and Linux. Please note that in this book we'll be using a Rails version of at least 3.2 and higher and Ruby 1.9.2 and higher.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Installing Rails using RailsInstaller</h2></div></div></div><p>On Windows, or <a id="id228" class="indexterm"/>optionally on a Mac, <a id="id229" class="indexterm"/>I would recommend <a id="id230" class="indexterm"/>
<a id="id231" class="indexterm"/>
<strong>RailsInstaller</strong> (<a class="ulink" href="http://railsinstaller.org/">http://railsinstaller.org/</a>). It contains everything you need to start with Rails, including the latest version of Ruby itself. After downloading the setup program, installation couldn't be much easier; just run it and step through the wizard. After the installation, you should be presented with an open console command prompt. Try entering <code class="literal">rails -v</code>. If you see a version number, you should be good to go.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Installing Rails using RVM</h2></div></div></div><p>Installing <a id="id232" class="indexterm"/>Ruby and Rails on a Mac and Linux can be really easy using <strong>RVM</strong>, <a id="id233" class="indexterm"/>or the <strong>Ruby Version Manager</strong>,<a id="id234" class="indexterm"/> from <a class="ulink" href="https://rvm.io/">https://rvm.io/</a>.</p><p>The Ruby <a id="id235" class="indexterm"/>language has grown to be very popular over the past few years, and this has resulted in multiple implementations of the language being written, which can run on difference platforms. <strong>Matz's Ruby Interpreter</strong><a id="id236" class="indexterm"/> (<strong>MRI</strong>), the standard implementation of Ruby, has also gone through several versions. RVM is great for managing and installing different versions of Ruby. It comes with a one-stop installer bash script that will install both the latest Ruby and Rails. Just run the following command from the terminal:</p><div><pre class="programlisting">curl -L https://get.rvm.io | bash -s stable --rails</pre></div><p>This might take quite a while to finish. Once it's done, you should try entering <code class="literal">rails -v</code> in the terminal. If you see a version number of at least 3.2, you should be good to go.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Got Rails installed?</h2></div></div></div><p>Now that we have Rails installed, let's go ahead and build an application using CoffeeScript.</p><p>If you ran into any problem or want more information on installing Rails, the best place to start would be on the <strong>Download</strong> section of the Ruby on Rails site (<a class="ulink" href="http://rubyonrails.org/download">http://rubyonrails.org/download</a>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Developing our Rails application</h1></div></div></div><p>We'll take<a id="id237" class="indexterm"/> parts of our existing to-do list application and extend it with a server-side backend using Rails. If you weren't following along in the previous chapter, then you should be able to just copy the code for that chapter as needed.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>This chapter isn't meant to be a complete introduction to all of Ruby on Rails or Ruby, the language. Here, we would like to focus on building a simple Rails app within the context of how you would go about using Rails with CoffeeScript.</p><p>We will not go into everything in too much detail, and we'll trust in the fact that Ruby is quite a simple and readable language and that Rails code is simple to understand. Even if you aren't familiar with the language and the framework, it should not be too hard to follow along.</p></div></div><p>First, we'll start out by creating an empty base Rails application using the <code class="literal">rails</code> command. Navigate to a folder where you would like to create your app and then run this command:</p><div><pre class="programlisting">rails new todo</pre></div><p>This will create a <code class="literal">todo</code> folder with a whole bunch of files and folders for your web application. In Rails' spirit of following conventions, your web application will be organized in a certain manner.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">rails</code> command is used for many things besides generating a new application and serves as your entry point into many of the common day-to-day Rails tasks. We'll be covering a few of them in this book and if you want to see the full list of what it can do, you can run <code class="literal">rails -h</code>.</p></div></div><p>Let's briefly talk about how Rails organizes our application. Most of your application code will probably live<a id="id238" class="indexterm"/> in the top-level <code class="literal">app</code> folder. This folder contains the following four important subfolders:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assets:</code> This is the folder from which the asset pipeline operates. This is where all your CoffeeScript (or JavaScript) and CSS source code, as well as images used by our web app, will be.</li><li class="listitem" style="list-style-type: disc"><code class="literal">controllers</code>: This is where your controllers live. These are responsible for handling routed requests for the application and they talk to your views and models.</li><li class="listitem" style="list-style-type: disc"><code class="literal">models</code>: This is where you'll find the domain models. Models represent domain objects in a system and correspond to database tables using the <code class="literal">ActiveRecord</code> base class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">views</code>: This folder contains view templates that are used to render your application's HTML. By default, Rails uses ERB templates, which allow us to include snippets of Ruby code within an HTML template that will be evaluated to generate the final output HTML.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl3sec04"/>MVC</h2></div></div></div><p><strong>MVC</strong>, or <strong>Model-View-Controller</strong>, <a id="id239" class="indexterm"/>is a widely used application architecture pattern that aims to simplify code and reduce coupling by splitting application concerns into three domain object types.</p><p>Rails follows the MVC pattern very closely, and most Rails applications will be structured very heavily in terms of models, controllers, and views.</p><p>Another pattern on top of MVC that has been espoused by many Rails programmers over the last few years is fat models, skinny controllers. This concept encourages the practice of placing most of your domain logic within models, and that controllers should only be concerned about routing and interaction between models and views.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Running our application</h2></div></div></div><p>At this stage we<a id="id240" class="indexterm"/> can already run our Rails application to see if it all worked. From the terminal, enter:</p><div><pre class="programlisting">cd todo
rails server</pre></div><p>Rails will now start hosting a local web server for our application on port <strong>3000</strong>. You can test it by browsing to <code class="literal">http://localhost:3000/</code>. If all went well, then you should see the following friendly welcome message:</p><div><img src="img/9588_04_01.jpg" alt="Running our application"/></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Remember to keep this server running in a separate console window as we test our application. You can also check the output of this process for any errors that might occur while it's running.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Our todo_items resource</h2></div></div></div><p>So, we now <a id="id241" class="indexterm"/>have a running application, but it doesn't<a id="id242" class="indexterm"/> do much except show us a welcome page.</p><p>To get to our goal of being able to track to-do tasks, we'll generate a resource for our to-do items. In Rails parlance, a resource consists of a model, a controller with some actions, as well as views for those actions.</p><p>At the terminal, run the following command:</p><div><pre class="programlisting">rails generate resource todo_item title:string completed:boolean</pre></div><p>What did this do? This is an example of Rails' generator syntax, which can be used to generate boilerplate code. Here, we tell it to create a "resourceful" controller named <code class="literal">TodoItemsController</code>
<a id="id243" class="indexterm"/> and a model, <code class="literal">TodoItem</code>, which has a <code class="literal">string</code> field for its title and a <code class="literal">boolean</code> flag to mark it as completed.</p><p>As you can see from the command output, it has generated a bunch of files as well as modified an existing one, in <code class="literal">config/routes.rb</code>. Let's start by opening this file.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>routes.rb</h2></div></div></div><p>Here is <a id="id244" class="indexterm"/>what you should see at the top of the <code class="literal">routes.rb</code> file:</p><div><pre class="programlisting">Todo::Application.routes.draw do
<strong>  resources :todo_items</strong>
</pre></div><p>In Rails, <code class="literal">routes.rb</code> defines how HTTP calls to URLs map to controller actions that can handle them.</p><p>Here, the generator <a id="id245" class="indexterm"/>added a line for us, which uses the <code class="literal">resources</code> method. This method creates the routes for the most common actions of a "resourceful" controller. This means it exposes a single domain resource in your application using the HTTP verbs, GET, POST, PUT, and DELETE.</p><p>Usually, this will create routes for seven different controller actions, <code class="literal">index</code>, <code class="literal">show</code>, <code class="literal">new</code>, <code class="literal">create</code>, <code class="literal">edit</code>, <code class="literal">update</code>, and <code class="literal">destroy</code>. As you will see later on, we won't need to create all these actions for our controller, so we'll tell the <code class="literal">resources</code> method to filter out only the ones we want. Modify the file to look like the following code snippet:</p><div><pre class="programlisting">Todo::Application.routes.draw do
<strong>  resources :todo_items, only: [:index, :create, :update, :destroy]</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>The controller</h2></div></div></div><p>In the call to<a id="id246" class="indexterm"/> <code class="literal">resources</code>, Rails uses the <code class="literal">:todo_items</code> symbol to <a id="id247" class="indexterm"/>conventionally map the <code class="literal">resources</code> method to <code class="literal">TodoItemsController</code>, which was also generated for us.</p><p>Open the <code class="literal">app/controllers/todo_items_controller.rb</code> file; here is what you'll see:</p><div><pre class="programlisting">class TodoItemsController &lt; ApplicationController
end</pre></div><p>As you can see, there isn't a whole lot in here. A class named <code class="literal">TodoItemController</code> is declared, and it derives from the <code class="literal">ApplicationController</code> class. The <code class="literal">ApplicationController</code> class<a id="id248" class="indexterm"/> was also generated for us when we created the app, and it derives from <code class="literal">ActionController::Base</code>, which gives it a whole lot of functionality and lets it behave like a Rails controller.</p><p>We should now be able to test out our controller by navigating to the <code class="literal">http://localhost:3000/todo_items</code> URL.</p><p>What do you see? <a id="id249" class="indexterm"/>You should get the <strong>Unknown action</strong> error page stating that the <code class="literal">index</code> action could not be found for <code class="literal">TodoItemsController</code>.</p><p>This is because the controller doesn't yet have an <code class="literal">index</code> action defined, as specified in our <code class="literal">routes.rb</code> file. Let's go ahead and add a method to our <code class="literal">TodoItemsController</code> class to handle that action; this is shown in the following code snippet:</p><div><pre class="programlisting">class TodoItemsController &lt; ApplicationController
<strong>  def index</strong>
<strong>  end</strong>
end</pre></div><p>If we refresh the page, we get a different error message: <strong>Template is missing</strong>. This happens because we don't have a template for the <code class="literal">index</code> action. By default, Rails will always try to return a rendered template that corresponds to the <code class="literal">index</code> action name. Let's go ahead and add one now.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>The view</h2></div></div></div><p>Rails views<a id="id250" class="indexterm"/> are saved in the <code class="literal">app/views</code> folder. Each controller will <a id="id251" class="indexterm"/>have a subfolder here containing its views. We already have an <code class="literal">index.html</code> file from the previous chapter, which we'll re-use here. To do this, we'll need to copy everything that is inside the <code class="literal">body</code> tag, excluding the last two <code class="literal">script</code> tags from the old <code class="literal">index.html</code> file, into a file called <code class="literal">app/views/todo_items/index.html.erb</code>.</p><p>You should end up with the following markup:</p><div><pre class="programlisting">&lt;section id="todoapp"&gt;
  &lt;header id="header"&gt;
    &lt;h1&gt;todos&lt;/h1&gt;
    &lt;input id="new-todo" placeholder="What needs to be done?" autofocus&gt;
  &lt;/header&gt;
  &lt;section id="main"&gt;
    &lt;ul id="todo-list"&gt;
      
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;footer id="footer"&gt;
      &lt;button id="clear-completed"&gt;Clear completed&lt;/button&gt;
  &lt;/footer&gt;
&lt;/section&gt;</pre></div><p>Looking at this, you might be wondering where the rest of the HTML such as the enclosing <code class="literal">html</code>, <code class="literal">head</code>, and <code class="literal">body</code> tags have gone.</p><p>Well, Rails has<a id="id252" class="indexterm"/> the concept of a layout file, which acts as a wrapper for all the other views. This way you can have a consistent skeleton for your site that you don't need to create for each view. Our view will be embedded inside the default layout file: <code class="literal">app/views/layouts/application.html.erb</code>. Let's have a look at that file:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Todo&lt;/title&gt;
  &lt;%= stylesheet_link_tag    "application", :media =&gt; "all" %&gt;
  &lt;%= javascript_include_tag "application" %&gt;
  &lt;%= csrf_meta_tags %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The <code class="literal">stylesheet_link_tag</code>
<a id="id253" class="indexterm"/> and <code class="literal">javascript_include_tag</code> methods <a id="id254" class="indexterm"/>will make sure that all the files specified in the <code class="literal">assets</code> folder are included in the HTML. The <code class="literal">&lt;%= yield %&gt;</code> line is where the current view will be rendered, which is <code class="literal">index.html.erb</code> in our case.</p><p>When we refresh the page now, we'll see the <code class="literal">index</code> page. Have a look at the source code to get an idea of how the final HTML is output.</p><p>As you can see, our page is still unstyled and looks quite dull. Let's see if we can make it look pretty again.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>The CSS</h2></div></div></div><p>By default,<a id="id255" class="indexterm"/> the asset pipeline will look for CSS files in the <code class="literal">app/assets/stylesheets</code> folder. When we <a id="id256" class="indexterm"/>browse to this folder, we'll see a file named <code class="literal">todo_items.css.scss</code>, which was generated for us when we created the controller.</p><p>Copy the contents of the previous chapter's <code class="literal">styles.css</code> file into this file. Our <code class="literal">index</code> page should now look decent again.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>This file with the strange <code class="literal">.css.scss</code> extension is a Saas file (<a class="ulink" href="http://sass-lang.com/">http://sass-lang.com/</a>).</p><p>Like CoffeeScript, Sass is an extended version of the normal CSS language, with a lot of nice features that make writing CSS easier and less repetitive.</p><p>As with CoffeeScript, it is the default CSS compiler in the Rails asset pipeline. The flavor of Sass that we're using is a superset of CSS, which means we can use normal CSS in this file without using any of the Sass features and it will work fine.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Our model</h2></div></div></div><p>So now we can <a id="id257" class="indexterm"/>see our to-do list, but we don't have any items showing up. <a id="id258" class="indexterm"/>This time, instead of storing them locally, we'll store them in the database. Luckily for us, we already have a database model that was generated for us when we created the resource and the <code class="literal">TodoItem</code> model<a id="id259" class="indexterm"/>, which is defined in <code class="literal">app/models/todo_item.rb</code>:</p><div><pre class="programlisting">class TodoItem &lt; ActiveRecord::Base
  attr_accessible :completed, :title
end</pre></div><p>Here, like with controllers, you can see that Rails models get most of their functionality by deriving from <code class="literal">ActiveRecord::Base</code>. The <code class="literal">attr_accessible</code> line tells <code class="literal">ActiveRecord</code> which fields on this model can be assigned to and from user input.</p><p>How do we use the model? Add the following highlighted code in <code class="literal">todo_items_controller.rb</code>:</p><div><pre class="programlisting">  def index
<strong>    @todo_items = TodoItem.all</strong>
  end</pre></div><p>This line uses an <code class="literal">all</code> class method on the <code class="literal">TodoItem</code> class, which is also provided by <code class="literal">ActiveRecord</code>. This will return a new instance of the <code class="literal">TodoItem</code> class for each record in the database, which we can assign to an instance variable called <code class="literal">@todo_items</code> (in Ruby all instance variables start with an <code class="literal">@</code> symbol).</p><p>When Rails executes a controller action, it will automatically make any of the controller instance variables available to the view being rendered, which is why we're assigning it here. We'll get to use it in our view soon.</p><p>Let's refresh the page again to see if this worked. Yet again, we get a <strong>Could not find table 'todo_items'</strong> error.</p><p>You've probably guessed that we're supposed to create a table called <code class="literal">todo_items</code> in a database somewhere. Luckily, Rails has already taken care of the hard work, using something called migration.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Migrations</h2></div></div></div><p>When we generated our resource, Rails not only created a model for us, but also a database script written in Ruby, or <strong>migration</strong>
<a id="id260" class="indexterm"/>. We should be able to open it in the <code class="literal">db/migrations</code> folder. The actual file will be prefixed with a timestamp and will<a id="id261" class="indexterm"/> end with <code class="literal">_create_todo_items.rb</code>. It should look similar to the following code snippet:</p><div><pre class="programlisting">class CreateTodoItems &lt; ActiveRecord::Migration
  def change
    create_table :todo_items do |t|
      t.string :title
      t.boolean :completed

      t.timestamps
    end
  end
end</pre></div><p>This script will create a table named <code class="literal">todo_items</code> with the fields that we had specified when we generated the <code class="literal">todo_item</code> resource. It also creates two timestamp fields named <code class="literal">created_at</code> and <code class="literal">updated_at</code> using the <code class="literal">t.timestamps</code> method<a id="id262" class="indexterm"/>. Rails will make sure that fields with those names get updated with the appropriate timestamp when a record gets created or updated.</p><p>Migration scripts are a wonderful way of automating database changes, even allowing you to roll back a previous change. You don't have to rely on migrations created by resource or model generators either. Custom migrations can be generated by running the following command:</p><div><pre class="programlisting">rails generate migration migration_name</pre></div><p>After generating your custom migration, you can just implement the <code class="literal">up</code> and <code class="literal">down</code> methods, which will be called when your migration gets executed or rolled back.</p><p>Migrations are executed with the <code class="literal">rake</code> command. <code class="literal">rake</code> is a task-management tool that allows you to write tasks as Ruby scripts, which are then run using the <code class="literal">rake</code> command-line utility. Rails comes with a whole lot of built-in <code class="literal">rake</code> tasks, and you can see the full list of them by using:</p><div><pre class="programlisting">rake –T</pre></div><p>The task that we're interested in the moment is called <code class="literal">db:migrate</code>
<a id="id263" class="indexterm"/>, let's run it and see what happens:</p><div><pre class="programlisting">rake db:migrate</pre></div><p>You should see the following output:</p><p><strong>==  CreateTodoItems: migrating ================================================</strong></p><p><strong>-- create_table(:todo_items)</strong></p><p><strong>   -&gt; 0.0011s</strong></p><p><strong>==  CreateTodoItems: migrated (0.0013s) =======================================</strong></p><p>This means Rails has successfully created a <code class="literal">todo_items</code> table for us in the database. When we refresh the application page, we should see that the error is gone and we're seeing our blank to-do list.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p><strong>Where is the database?</strong></p><p>You might have wondered where our actual database lives at the moment. Rails defaults to using an embedded SQLite database. SQLite (<a class="ulink" href="http://www.sqlite.org">http://www.sqlite.org</a>) is a self-contained, file-based database that doesn't need a server to be configured for it to run. This makes it really nice and easy to get up and running quickly when developing an application.</p><p>Once you actually deploy your web app, you would probably want to go with a more traditional database server, such as MySQL or PostgreSQL. You can easily change your database connection settings in the <code class="literal">config/database.yml</code> file.</p></div></div><p>We still haven't hooked <a id="id264" class="indexterm"/>up our view to actually show the list of to-do items. Before we do that, let's manually create a couple of to-do items in the database.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>The Rails console<a id="id265" class="indexterm"/>
</h2></div></div></div><p>Rails has a <a id="id266" class="indexterm"/>nifty way of interactively playing with your code by using the Rails console. This is an interactive Ruby interpreter, or <strong>irb</strong>, session with all the Rails project code loaded. Let's fire it up by using the following command:</p><div><pre class="programlisting">rails console</pre></div><p>Once you're in the console you can enter any valid Ruby code. You can also access all the models in your Rails app. Let's try it with the <code class="literal">TodoItem.all</code> method that we used earlier; this is shown in the following screenshot:</p><div><img src="img/9588_04_02.jpg" alt="The Rails consoleRails consoleabout"/></div><p>At the moment it returns an empty array, since our table is still empty. Notice that Rails also outputted the <a id="id267" class="indexterm"/>SQL query that it has generated to get all the records.</p><p>From here we can also create a new to-do item using our model. The following code will do that:</p><div><pre class="programlisting">TodoItem.create(title: "Hook up our index view", completed: false)</pre></div><p>Now, we should have a single to-do item in our table. You can verify this by using <code class="literal">TodoItem.first</code>, which will return the first item in our table.</p><p>I want to make sure that our model always has a title. <code class="literal">ActiveRecord</code> has very powerful validation features that are built-in, which allows for specifying constraints on model attributes in a very declarative manner. Let's make sure that our model always checks for the presence of a title before saving; to do this, add the following highlighted code:</p><div><pre class="programlisting">class TodoItem &lt; ActiveRecord::Base
  attr_accessible :completed, :title
<strong>  validates :title,  :presence =&gt; true</strong>
end</pre></div><p>Go ahead and create a couple of other to-do items. Once you have done this, try running <code class="literal">TodoItem.all</code> again. This time it returns an array of <code class="literal">TodoItem</code> instances.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>To exit the rails console, just enter <code class="literal">exit</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Displaying the items in our view using ERB</h2></div></div></div><p>To display <a id="id268" class="indexterm"/>our to-do items<a id="id269" class="indexterm"/> in our view, we'll use the <code class="literal">@todo_items</code> instance variable that we created in our controller action. Let's modify the <code class="literal">app/views/todo_items.html.erb</code> file and mix in some Ruby using ERB; add the code that is highlighted in the following code snippet:</p><div><pre class="programlisting">&lt;section id="todoapp"&gt;
  &lt;header id="header"&gt;
    &lt;h1&gt;todos&lt;/h1&gt;
    &lt;input id="new-todo" placeholder="What needs to be done?" autofocus&gt;
  &lt;/header&gt;
  &lt;section id="main"&gt;
    &lt;ul id="todo-list"&gt;
<strong>      &lt;% @todo_items.each do |item| %&gt;</strong>
<strong>        &lt;li class="&lt;%= item.completed ? "completed" : "" %&gt;" data-id="&lt;%= item.id %&gt;"&gt;</strong>
<strong>          &lt;div class="view"&gt;</strong>
<strong>            &lt;input class="toggle" type="checkbox" &lt;%= "checked" if item.completed %&gt;&gt;</strong>
<strong>            &lt;label&gt;&lt;%= item.title %&gt;&lt;/label&gt;</strong>
<strong>            &lt;button class="destroy"&gt;&lt;/button&gt;</strong>
<strong>          &lt;/div&gt;</strong>
<strong>        &lt;/li&gt; </strong>
<strong>      &lt;% end %&gt;</strong>
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;footer id="footer"&gt;
      &lt;button id="clear-completed"&gt;Clear completed&lt;/button&gt;
  &lt;/footer&gt;
&lt;/section&gt;</pre></div><p>ERB templates<a id="id270" class="indexterm"/> are<a id="id271" class="indexterm"/> quite simple to understand. The <a id="id272" class="indexterm"/>basic idea is that you write your HTML as normal and mix in Ruby using ERB tags. The following three tags are important:</p><div><pre class="programlisting">&lt;% These tags will be just be executed  %&gt;
&lt;%= These should contain a Ruby expression that will be evaluated and included in the document %&gt;
&lt;%# This is a comment and will be ignored %&gt;</pre></div><p>In our <code class="literal">index</code> ERB template, we use Ruby's <code class="literal">each</code> iterator<a id="id273" class="indexterm"/> to loop through all the elements in the <code class="literal">@todo_items</code> array instance variable; <code class="literal">each</code> takes a Ruby block as an argument. A block is a piece of code that can be passed to a method as data, similar to how functions can be passed as arguments in CoffeeScript.</p><p>This block will be executed for each item in the array, passing it in as the item variable. For each item, we create its markup, using the item's <code class="literal">title</code> and <code class="literal">completed</code> attributes inside of our ERB tags.</p><p>When we refresh the page, we should now finally see our list of to-do items! If you are curious, have a look at the<a id="id274" class="indexterm"/> HTML source of the document and compare it to the ERB template, this should give you a good idea of how it was generated. The output page is shown in the following screenshot:</p><div><img src="img/9588_04_03.jpg" alt="Displaying the items in our view using ERB"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Creating a partial</h2></div></div></div><p>At the moment,<a id="id275" class="indexterm"/> our view code is starting to get a bit messy, especially the <a id="id276" class="indexterm"/>to-do items list. We can clean it up a bit by using a <strong>view partial</strong>
<a id="id277" class="indexterm"/>, which allows us to pull out snippets of our view into a separate file. This can then be rendered where we need it in the main view. Add the line of code highlighted in the following code snippet to your file:</p><div><pre class="programlisting">  &lt;section id="main"&gt;
    &lt;ul id="todo-list"&gt;
      &lt;% @todo_items.each do |item| %&gt;
<strong>        &lt;%= render partial: 'todo_item', locals: {item: item} %&gt;</strong>
      &lt;% end %&gt;
    &lt;/ul&gt;

  &lt;/section&gt;</pre></div><p>We'll move the to-do item markup to its own partial file. By convention, partial filenames start with an underscore, and when rendering a partial, Rails will look for a file with the same name as the specified partial, with a leading underscore. Go ahead and create a file: <code class="literal">app/views/todo_items/_todo_item.html.erb </code>with the following content:</p><div><pre class="programlisting">&lt;li class="&lt;%= item.completed ? "completed" : "" %&gt;" data-id="&lt;%= item.id %&gt;"&gt;
  &lt;div class="view"&gt;
    &lt;input class="toggle" type="checkbox" &lt;%= "checked" if item.completed %&gt;&gt;
    &lt;label&gt;&lt;%= item.title %&gt;&lt;/label&gt;
    &lt;button class="destroy"&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/li&gt;</pre></div><p>If all went well, our<a id="id278" class="indexterm"/> view should still work as before, and we have <a id="id279" class="indexterm"/>cleaned up the main view code nicely. Simplifying views with partials are also great for reusability, which we'll see later on.</p><p>Our to-do list app still needs some work. At the moment, we can't add new tasks and the completed task and delete actions don't work either. This calls for some client-side code, which means we can finally start using some CoffeeScript.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Adding new items</h2></div></div></div><p>To add <a id="id280" class="indexterm"/>new items<a id="id281" class="indexterm"/> to our to-do list, we'll use some of Rails' native AJAX capabilities. The following code snippet is a modified version of the <code class="literal">todo</code> input on our <code class="literal">index</code> view:</p><div><pre class="programlisting">  &lt;header id="header"&gt;
    &lt;h1&gt;todos&lt;/h1&gt;
<strong>    &lt;%= form_for TodoItem.new, :method =&gt; :post, :remote =&gt; true do |f| %&gt;    </strong>
<strong>      &lt;%= f.text_field :title, id:'new-todo', placeholder: 'What needs to be done?', autofocus: true  %&gt;</strong>
<strong>    &lt;% end %&gt;</strong>
  &lt;/header&gt;</pre></div><p>So what has changed here? First, you'll notice that we have included the <code class="literal">form_for</code> method, with another call to <code class="literal">text_field</code> inside of its block. These are Rails' view helpers, which are Ruby methods available inside of views, that provide ways of building the HTML output.</p><p>The <code class="literal">form_for</code> method<a id="id282" class="indexterm"/> will output an HTML <code class="literal">form</code> tag, and the <code class="literal">text_field</code> method will generate an <code class="literal">input</code> tag inside the form, which will be of type <code class="literal">text</code>.</p><p>We pass a new instance of <code class="literal">TodoItem</code> as a parameter to the <code class="literal">form_for</code> method. Rails is smart enough to know from the <code class="literal">TodoItem</code> instance that the form's URL should point to <code class="literal">TodoItemController</code>, and will use attributes of the <code class="literal">TodoItem</code> model as names of inputs inside the form.</p><p>The real magic<a id="id283" class="indexterm"/> comes in with the <code class="literal">:remote =&gt; true</code> parameter sent to the <code class="literal">form_for</code> method. This tells Rails that you want this form to be submitted using AJAX. Rails will take care of all of this in the background.</p><p>So which controller action will my form be submitted to? Since we specified its action as <code class="literal">post</code>, it will map to a <code class="literal">create</code> action in <code class="literal">TodoItemController</code>. We don't have one yet, so let's go and write it:</p><div><pre class="programlisting">  def create 
    @todo_item = TodoItem.create(params[:todo_item])
  end</pre></div><p>Here, we create <code class="literal">TodoItem</code> <a id="id284" class="indexterm"/>using the <code class="literal">:todo_item</code> key in <code class="literal">params</code>—<code class="literal">params</code>, which is a Ruby hash that Rails created. It contains a value with the key, <code class="literal">:todo_items</code>, which is a hash containing all the parameter values that were submitted from the form. When we pass this hash to the <code class="literal">TodoItem.create</code> method, Rails will know how to map them to attributes on our new model and save it to the database.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Let's try and add a to-do item</h2></div></div></div><p>Type a title in our input box for a new to-do item and hit <em>Enter</em>.</p><p>However, it <a id="id285" class="indexterm"/>seems like nothing happened. We can head over <a id="id286" class="indexterm"/>to the output of our running Rails server session to see if we can spot any errors. If you scroll around a bit, you should see an error similar to the following error message:</p><p><strong>ActionView::MissingTemplate (Missing template todo_items/create, application/create with {:locale=&gt;[:en], :formats=&gt;[:js, "application/</strong></p><p><strong>ecmascript", "application/x-ecmascript", :html, :text, :js, :css, :ics, :csv, :png, :jpeg, :gif, :bmp, :tiff, :mpeg, :xml, :rss, :atom,</strong></p><p><strong> :yaml, :multipart_form, :url_encoded_form, :json, :pdf, :zip], :handlers=&gt;[:erb, :builder, :coffee]}. Searched in:</strong></p><p><strong>  * "/home/michael/dev/todo/app/views"</strong></p><p><strong>)</strong></p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Adding a CoffeeScript view</h2></div></div></div><p>So, it seems we still <a id="id287" class="indexterm"/>need to do one more thing. All controller <a id="id288" class="indexterm"/>actions will try and render a view by default. When we try adding a to-do item now, we would get the same <strong>Template is missing</strong> error as earlier. It might not be clear what should happen, since the form was posted using AJAX. Should we still render a view? And how would it look?</p><p>Looking at the <a id="id289" class="indexterm"/>error message a bit more closely might give us a clue. Since our action was invoked using AJAX, Rails will, by default, look for a CoffeeScript view to render as JavaScript.</p><p>The generated <a id="id290" class="indexterm"/>JavaScript will serve as the response to the AJAX call and will be executed on completion. This also seems like the perfect place to update our to-do items list, after creating it on the server.</p><p>We'll create a CoffeeScript view template for our <code class="literal">create</code> action in <code class="literal">app/views/todo_items/create.js.coffee</code>.</p><div><pre class="programlisting">$('#new-todo').val('')
html = "&lt;%= escape_javascript(render partial: 'todo_item', locals: {item: @todo_item}) %&gt;"
$("#todo-list").append(html)</pre></div><p>Here, in the previous code snippet, we grab the <code class="literal">#new-todo</code> input and clear its value. We then render the same <code class="literal">todo_item</code> partial that we used before, passing in the <code class="literal">@todo_item</code> instance variable that we created in our controller action.</p><p>We wrap the render call in an <code class="literal">escape_javascript</code> helper method, which will ensure that any special JavaScript character will be escaped in our string. We then append the newly rendered partial to our <code class="literal">#todo-list</code> element.</p><p>Try it out. We can now finally create to-do list items!</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p><strong>Where did jQuery come from?</strong></p><p>Rails already included jQuery for us. The Rails asset pipeline uses a manifest file, <code class="literal">app/assets/javascript/application.js</code> to include required dependencies, for instance jQuery.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/>CoffeeScript in the asset pipeline</h2></div></div></div><p>Notice how seamless this all was? Rails treats CoffeeScript as a first-class citizen in its stack, and will make sure that the <code class="literal">.coffee</code> files get compiled into JavaScript before they are used. The fact that you can also pre-process your CoffeeScript using ERB templates on the server makes this even more powerful.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>Completing the to-do items</h2></div></div></div><p>Let's hook up this <a id="id291" class="indexterm"/>functionality. This time, we will do things a bit differently to show you a different style of writing CoffeeScript in Rails<a id="id292" class="indexterm"/>. We'll follow the more traditional approach of handling the AJAX call ourselves.</p><p>Rails has already created a file where we can put our client-side code, back when we created the controller. <a id="id293" class="indexterm"/>Each controller will get its own CoffeeScript file, which will be included in the page automatically for any action on that controller.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>There is also an <code class="literal">application.js.coffee</code> file, where global client-side code can be added.</p></div></div><p>The file that we're interested in will be <code class="literal">app/assets/views/javascripts/todo_items.js.coffee</code>. We can replace the contents of it with the following code, which will handle the AJAX call when completing a task:</p><div><pre class="programlisting">toggleItem = (elem) -&gt;
  $li = $(elem).closest('li').toggleClass("completed")
  id = $li.data 'id'

  data = "todo_item[completed]=#{elem.checked}"
  url = "/todo_items/#{id}"
  $.ajax
    type: 'PUT'
    url: url
    data: data

$ -&gt;
  $("#todo-list").on 'change', '.toggle', (e) -&gt; toggleItem e.target</pre></div><p>First, we define a function called <code class="literal">toggleItem</code>, which we set up to be called when a checkbox value changes. In this function we toggle the parent <code class="literal">li</code> element's <code class="literal">completed</code> class and get the ID of the to-do item using its <code class="literal">data</code> attribute. We then make an AJAX call to <code class="literal">TodoItemController</code> to update the item with the current checked value of the checkbox.</p><p>Before we can run this code, we'll need to add an <code class="literal">update</code> action to our controller, which is shown in the following code snippet:</p><div><pre class="programlisting">  def update
    item = TodoItem.find params[:id]
    item.update_attributes params[:todo_item]
    render nothing: true
  end</pre></div><p><code class="literal">params[:id]</code> will <a id="id294" class="indexterm"/>be the value of the ID in the URL. We use this to find the to-do item and then call the <code class="literal">update_attributes</code> method, which do just that, update our model and save it to the database. Note that we explicitly tell Rails not to render a view here by calling <code class="literal">render nothing: true</code>.</p><p>Setting tasks to completed should now work. Notice that when you refresh the page, tasks stay completed, since they were saved to the database.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec70"/>Removing tasks</h2></div></div></div><p>For removing <a id="id295" class="indexterm"/>tasks, <a id="id296" class="indexterm"/>we'll follow a very similar pattern.</p><p>In <code class="literal">todo_items.js.coffee</code>, add the following code:</p><div><pre class="programlisting">
<strong>destroyItem = (elem) -&gt;</strong>
<strong>  $li = $(elem).closest('li')</strong>
<strong>  id = $li.data 'id'</strong>
<strong>  url = "/todo_items/#{id}"</strong>
<strong>  $.ajax</strong>
<strong>    url: url</strong>
<strong>    type: 'DELETE'</strong>
<strong>    success: -&gt; $li.remove()</strong>

$ -&gt;
  $("#todo-list").on 'change', '.toggle', (e) -&gt; toggleItem e.target
<strong>  $("#todo-list").on 'click', '.destroy', (e) -&gt; destroyItem e.target</strong>
</pre></div><p>In our controller, add the following code:</p><div><pre class="programlisting">  def destroy
    TodoItem.find(params[:id]).destroy
    render nothing: true
  end</pre></div><p>That should be all we need to remove list items. Notice that here we only remove the element once the AJAX call was successful, by handling the <code class="literal">success</code> callback.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Now, it's your turn</h2></div></div></div><p>As a final exercise to you, I will ask you to make the <strong>Clear completed</strong> button work. As a hint, you should be able to use the existing <code class="literal">destroyItem</code> method functionality.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Summary</h1></div></div></div><p>This chapter started with a whirlwind tour of Ruby on Rails. You have hopefully grown to appreciate some of the magic that Rails offers web developers and how much fun it can be developing a Rails app. We have also spent some time discovering how easy it is to use CoffeeScript in a Rails app, and the different approaches and techniques you would typically use to write client-side code.</p><p>If you haven't done so already, I encourage you to spend some more time learning Rails as well as Ruby, and immersing yourself in the wonderful communities they support.</p><p>In the next chapter, we'll explore yet another new exciting server framework that was built using JavaScript, and how CoffeeScript relates to it.</p></div></body></html>