<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;CoffeeScript and Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. CoffeeScript and Node.js</h1></div></div></div><p>Ryan Dahl created Node.js in 2009. His goal was to create a system with which one can write network server applications having high performance, using JavaScript. At that time, JavaScript was mostly run inside browsers, so a server-side framework needed some way to run JavaScript without it. Node uses Google's V8 JavaScript engine, originally written for the Chrome browser, but since it's a separate piece of software, it can run JavaScript code anywhere. Node.js lets you write JavaScript code that can be executed on the server. It can make full use of your operating system, databases, and other external network resources.</p><p>Let's talk about some of the features of Node.js.</p><div class="section" title="Node is event-driven"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Node is event-driven</h1></div></div></div><p>The Node.js<a id="id297" class="indexterm"/> framework only allows non-blocking, asynchronous I/O. This means that any I/O operation that is accessing an external resource, such as the operating system, a database, or a network resource must happen asynchronously. This works by using events, or callbacks that are fired once the operation succeeds or fails.</p><a id="id298" class="indexterm"/><p>The benefit of this is that your application becomes much more scalable, because requests don't have to wait around for slow I/O operations to finish and can instead handle more incoming requests.</p><p>Similar frameworks do exist in other languages, such as <span class="strong"><strong>Twisted</strong></span>
<a id="id299" class="indexterm"/> and <span class="strong"><strong>Tornado</strong></span>
<a id="id300" class="indexterm"/> in Python, and <span class="strong"><strong>EventMachine</strong></span>
<a id="id301" class="indexterm"/> in Ruby. A big problem with these frameworks is that all I/O libraries they use must also be non-blocking. Often, one can end up accidentally using code that blocks an I/O operation.</p><p>Node.js was built from the ground up with an event-driven philosophy and only allows non-blocking I/O, thus avoiding this problem.</p></div></div>
<div class="section" title="Node is fast and scalable"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Node is fast and scalable</h1></div></div></div><p>The V8 JavaScript engine used by Node.js is highly optimized for performance, thus making Node.js applications very fast. The fact that Node is non-blocking will ensure that your applications will be able to handle many concurrent client requests without using a lot of system resources.</p></div>
<div class="section" title="Node is not Rails"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Node is not Rails</h1></div></div></div><p>Although Node and Rails are often used to build similar types of applications, they are in fact, quite different. Rails strives to be a full-stack solution to building web applications, whereas Node.js is more of a low-level system for writing any type of fast and scalable network application. It does not make a lot of assumptions on how your application should be structured at all, except for the fact that you'll use an event-based architecture.</p><p>Because of this, Node developers often choose from a variety of frameworks and modules that have been built on top of Node for writing web applications, such as Express or Flatiron.</p></div>
<div class="section" title="Node and CoffeeScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Node and CoffeeScript</h1></div></div></div><p>As we've seen before, <a id="id302" class="indexterm"/>CoffeeScript is available as an npm module. Therefore, writing Node.js applications <a id="id303" class="indexterm"/>with CoffeeScript couldn't be much easier. In fact, the <code class="literal">coffee</code> command that we <a id="id304" class="indexterm"/>discussed earlier will run <code class="literal">.coffee</code> scripts using Node by default. To get Node installed with CoffeeScript, see <a class="link" href="ch02.html" title="Chapter 2. Running CoffeeScript">Chapter 2</a>, <span class="emphasis"><em>Running CoffeeScript</em></span>.</p></div>
<div class="section" title="&quot;Hello World&quot; in Node"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>"Hello World" in Node</h1></div></div></div><p>Let's write the simplest<a id="id305" class="indexterm"/> Node app we can using CoffeeScript. Create a file named <code class="literal">hello.coffee</code> and enter the following code in it:</p><div class="informalexample"><pre class="programlisting">http = require('http')

server = http.createServer (req, res) -&gt;
  res.writeHead 200
  res.end 'Hello World'

server.listen 8080</pre></div><p>This uses the <code class="literal">http</code> module of Node.js, which provides capabilities for building an HTTP server. The <code class="literal">require('http')</code> function will return an instance of the <code class="literal">http</code> module, which exports a <code class="literal">createServer</code> function. This function takes a <code class="literal">requestListener</code> argument, which is a function that will respond to client requests. In this case, we respond with an HTTP status code <code class="literal">200</code> and end the response with <code class="literal">Hello World</code> as the request body. Finally,<a id="id306" class="indexterm"/> we call the <code class="literal">listen</code> method on the returned server to start it up. When this method is called, the server will listen for and handle requests until we stop it.</p><p>We can run this file with the coffee command, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">coffee hello.coffee</pre></div><p>We can test our server by browsing to <code class="literal">http://localhost:8080/</code>. We should see a simple page with only the text as <span class="strong"><strong>Hello World</strong></span>.</p></div>
<div class="section" title="Express"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Express</h1></div></div></div><p>As you can see,<a id="id307" class="indexterm"/> Node out of the box is very low-level and bare-boned. Building web applications basically means writing a raw HTTP server. Luckily, a bunch of libraries has been developed over the last few years to help out with writing web applications on Node and to abstract away a lot of the low-level details.</p><p>Arguably, the most popular of these is <span class="strong"><strong>Express</strong></span>
<a id="id308" class="indexterm"/> (<a class="ulink" href="http://expressjs.com/">http://expressjs.com/</a>). Similar to Rails, it has quite a lot of nice features that make it easier to perform common web application tasks, such as routing, rendering views, and hosting static resources.</p><p>In this chapter, we'll be writing a web application in Express using CoffeeScript.</p></div>
<div class="section" title="WebSocket"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>WebSocket</h1></div></div></div><p>Since I would like to show<a id="id309" class="indexterm"/> off some of the scalability features of Node and the types of applications that it's normally used for, we'll be making use of another interesting modern web technology, known as <span class="strong"><strong>WebSocket</strong></span>.</p><p>The WebSocket protocol is a standard for allowing raw, bi-directional, and full-duplex (simultaneous in both directions) TCP connections over the standard HTTP port <span class="strong"><strong>80</strong></span>. This allows for a client and server to establish a long-running TCP connection with which the server can perform push operations, which has traditionally not been possible with HTTP. It is often used in applications where there needs to be lots of low-latency interaction between the client and server.</p></div>
<div class="section" title="Jade"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Jade</h1></div></div></div><p>Jade is a lightweight, markup templating language that lets you write elegant and short HTML in a syntax <a id="id310" class="indexterm"/>that closely resembles CoffeeScript. It uses quite a few features such as syntactical whitespace to reduce the number of keystrokes you need to write HTML documents. It is usually installed by default when you run Express, and we'll be using it in this book.</p></div>
<div class="section" title="Our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Our application</h1></div></div></div><p>In this chapter, we're going to build a<a id="id311" class="indexterm"/> collaborative to-do list application. This means that you'll be able to share your to-do list with other people in real time. One or more people will be able to add, complete, or remove to-do list items at the same time. Changes to the to-do list will be automatically propagated to all users. This is the type of application that Node is perfect for.</p><p>Our Node.js code will consist of two distinct parts, the normal web application that will serve static HTML, CSS, and JavaScript, and a WebSocket server that handles the real-time updating of all the to-do list clients. Together with this, we'll have a jQuery-driven client that will look very similar to our application in <a class="link" href="ch03.html" title="Chapter 3. CoffeeScript and jQuery">Chapter 3</a>, <span class="emphasis"><em>CoffeeScript and jQuery</em></span>.</p><p>We'll use some of the assets (stylesheets and images) from our existing to-do list applications. We'll also re-use the client-side jQuery code from <a class="link" href="ch03.html" title="Chapter 3. CoffeeScript and jQuery">Chapter 3</a>, <span class="emphasis"><em>CoffeeScript and jQuery</em></span> and tweak it to fit our application. If you weren't following along in the previous chapters, you should be able to just copy assets from the code for this chapter as needed.</p></div>
<div class="section" title="Let's get started"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Let's get started</h1></div></div></div><p>To get going, we'll do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a folder for our application.</li><li class="listitem">Specify our app dependencies using a <code class="literal">package.json</code> file.</li><li class="listitem">Install our dependencies.</li><li class="listitem">Create an <code class="literal">app.coffee</code> file.</li><li class="listitem">Run our app for the first time.</li></ol></div><div class="section" title="package.json"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>package.json</h2></div></div></div><p>Create a new folder <a id="id312" class="indexterm"/>named <code class="literal">todo</code>. Inside this folder, we'll <a id="id313" class="indexterm"/>create a file with the name <code class="literal">package.json</code>. Add the following code to this file:</p><div class="informalexample"><pre class="programlisting">{
  "name": "todo",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node app"
  },
  "dependencies": {
    "express": "3.0.0beta6",
    "jade": "*",
    "socket.io": "*",
    "coffee-script": "*",
    "connect-assets": "*"
  }
}</pre></div><p>This is a simple JSON file that serves as an application manifest and is used to tell npm which dependencies you rely on in<a id="id314" class="indexterm"/> your application. Here, we're using Express as our web framework and Jade as our templating language. Since we're going to use WebSocket, we'll pull in <code class="literal">socket.io</code>. We can also make sure that CoffeeScript is installed by adding it to our file. Lastly, we'll use <code class="literal">connect-assets</code>, a module that manages client-side assets in much the same way as the Rails asset pipeline.</p><p>When dealing with the Node.js framework, you'll notice that applications are often weaved together out of npm modules in this manner. A good place to look for npm modules is the Node toolbox site (<a class="ulink" href="http://nodetoolbox.com">nodetoolbox.com</a>).</p></div><div class="section" title="Installing our modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Installing our modules</h2></div></div></div><p>To install the <a id="id315" class="indexterm"/>dependencies in our <code class="literal">package.json</code> file, navigate to the project folder on the command-line tool and run the following command:</p><div class="informalexample"><pre class="programlisting">npm install</pre></div><p>If all went well, then we should now have all our project dependencies installed. To verify this or just to see what npm did, you can run the following command:</p><div class="informalexample"><pre class="programlisting">npm ls</pre></div><p>This will output a list of installed modules with their dependencies in a tree-like format.</p></div><div class="section" title="Creating our app"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Creating our app</h2></div></div></div><p>All we need to run our <a id="id316" class="indexterm"/>application is to create a main, entry point file, which is used to hook up our Express application and specify our routes. In the root folder, create a file named <code class="literal">app.coffee</code>, and add the following code to it:</p><div class="informalexample"><pre class="programlisting">express = require 'express'
app = express()

app.get '/', (req, res) -&gt;
  res.send('Hello Express')

app.listen(3000)
console.log('Listening on port 3000')</pre></div><p>This looks very similar to our "Hello World" example.</p><p>First, we load the Express module using the <code class="literal">require</code> function. Node modules are simple; each module corresponds <a id="id317" class="indexterm"/>to a single file. Each module can declare code, which will be exported when it is required. When you call <code class="literal">require</code>, and the module's name is not that of a native module or a file path, Node will automatically look for the file in the <code class="literal">node_modules</code> folder. This is of course where npm installs modules.</p><p>On the next line, we create our Express app by calling the <code class="literal">express</code> function and assigning it to an <code class="literal">app</code> variable.</p><p>We then create an index route for our application using the <code class="literal">get</code> method. We specify the path to be <code class="literal">'/'</code> and then pass in an anonymous function to handle the request. It takes two parameters, the <code class="literal">req</code> and <code class="literal">res</code> parameters. Right now, we just write <code class="literal">Hello Express</code> to the response and return.</p><p>We then start our app using the <code class="literal">listen</code> method and tell it to run on port <code class="literal">3000</code>. Lastly, we write to the standard output so that we'll know the app has started.</p><p>As you can see, the Express magic comes in with setting up routes declaratively. With Express you can easily create routes by specifying an HTTP method, URL path, and a function to handle the request.</p></div><div class="section" title="Running our application"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Running our application</h2></div></div></div><p>Let's run our application <a id="id318" class="indexterm"/>to see if everything worked. Inside our app folder, type the following on the command-line tool:</p><div class="informalexample"><pre class="programlisting">coffee app.coffee</pre></div><p>You should see the output as <span class="strong"><strong>Listening on port 3000</strong></span>.</p><p>Point your browser to <code class="literal">http://localhost:3000/</code>. You should see the text <span class="strong"><strong>Hello Express</strong></span>.</p><p>To stop the Node process on the command-line tool, just use <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span>.</p></div></div>
<div class="section" title="Creating a view"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Creating a view</h1></div></div></div><p>Similar to other <a id="id319" class="indexterm"/>web frameworks such as Rails, Express has the<a id="id320" class="indexterm"/> concepts of views, which let you separate your UI from your application using separate files. Usually, these are written using a templating language such as Jade. Let's create a view for our root action.</p><p>To do this, we'll need to:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">views</code> folder and add a Jade view file.</li><li class="listitem">Configure our Express application to be aware of a folder where the views will be stored, and which templating library we're using.</li><li class="listitem">Change our index route to render our view.</li></ol></div><p>Let's create a new folder in our project root called <code class="literal">views</code>. Inside this folder, we create a new file named <code class="literal">index.jade</code>. This is how it should look:</p><div class="informalexample"><pre class="programlisting">doctype 5
html
  head
    title Our Jade view
  body
    p= message</pre></div><p>As you can see, Jade offers a very clean and terse syntax for normal HTML. You don't have enclosing tags in angle brackets. Similar to CoffeeScript, it also uses indentation to delimit blocks, so that you don't have to enter closing tags. The line <code class="literal">p= message</code> creates a <code class="literal">&lt;p&gt;</code> tag whose contents will be evaluated to be the value of the <code class="literal">message</code> field, which should be passed into our view options.</p><p>In our <code class="literal">app.coffee</code> file, we'll add the following code:</p><div class="informalexample"><pre class="programlisting">express = require 'express'
<span class="strong"><strong>path = require 'path'</strong></span>
app = express()

<span class="strong"><strong>app.set 'views', path.join __dirname, 'views'</strong></span>
<span class="strong"><strong>app.set 'view engine', 'jade'</strong></span>

app.get '/', (req, res) -&gt;
<span class="strong"><strong>  res.render 'index', message: "Now we're cooking with gas!"</strong></span>

app.listen(3000)
console.log('Listening on port 3000')</pre></div><p>Here, we set the <code class="literal">views</code> folder using the <code class="literal">set</code> function and assigning the <code class="literal">'views'</code> key. We use the <code class="literal">path</code> module that we included at the top of the file to create and join our current folder name to the <code class="literal">views</code> subfolder. <code class="literal">__dirname</code> is a global variable that refers to the currently working folder. We also set the view engine to <code class="literal">'jade'</code>.</p><p>Next up, we<a id="id321" class="indexterm"/> change<a id="id322" class="indexterm"/> our <code class="literal">get '/'</code> route to render the index template and pass in a hash of options, containing the message. This is the value that then gets rendered in our view.</p><p>Once we run our application again and refresh the page, we should now see that our page has been updated with the new text.</p></div>
<div class="section" title="node-supervisor"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>node-supervisor</h1></div></div></div><p>By now, you might<a id="id323" class="indexterm"/> be wondering if you'll need to restart our Node application each time we make a change to our code. Ideally in development, we would like our code to be reloaded automatically each time we make a change, similar to how it works in Rails.</p><p>Luckily, there <a id="id324" class="indexterm"/>
<a id="id325" class="indexterm"/>is a neat, open source library that we can use that does exactly that: <span class="strong"><strong>node-supervisor</strong></span> (<a class="ulink" href="https://github.com/isaacs/node-supervisor">https://github.com/isaacs/node-supervisor</a>). We install it like any other npm module, we just make sure to pass the <code class="literal">-g</code> flag to install it globally, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">npm install supervisor -g</pre></div><p>In the terminal, you should now be able to run the supervisor by using the following command:</p><div class="informalexample"><pre class="programlisting">supervisor app.coffee</pre></div><p>Keep this process running in a separate window. To see if this worked, let's edit our message that gets sent to our view; the edited message is highlighted in the following code snippet:</p><div class="informalexample"><pre class="programlisting">app.get '/', (req, res) -&gt;
<span class="strong"><strong>  res.render 'index', message: "Now we're cooking with supervisor!"</strong></span>
</pre></div><p>If we now refresh our page, we'll see that it has been updated. From here on, we can make sure to keep the supervisor running and we shouldn't need to restart our Node process to make changes.</p></div>
<div class="section" title="The to-do list view"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>The to-do list view</h1></div></div></div><p>Now let's<a id="id326" class="indexterm"/> expand our view to look like our real to-do application. <a id="id327" class="indexterm"/>Edit the <code class="literal">index.jade</code> file to look like the following:</p><div class="informalexample"><pre class="programlisting">doctype 5
html
  head
<span class="strong"><strong>  title Collaborative Todo</strong></span>
  body
<span class="strong"><strong>    section#todoapp</strong></span>
<span class="strong"><strong>      header#header</strong></span>
<span class="strong"><strong>        h1 todos</strong></span>
<span class="strong"><strong>        input#new-todo(placeholder="What needs to be done?", autofocus=true)</strong></span>
<span class="strong"><strong>      section#main</strong></span>
<span class="strong"><strong>        ul#todo-list</strong></span>
<span class="strong"><strong>      footer#footer</strong></span>
<span class="strong"><strong>        button#clear-completed Clear completed</strong></span>
</pre></div><p>Here is some new Jade syntax that we haven't seen before. Tag IDs are denoted by the <code class="literal">#</code> symbol, so <code class="literal">header#header</code> becomes <code class="literal">&lt;header id="header"&gt;</code>. Tag attributes are specified within brackets, like so: <code class="literal">tag(name="value")</code>.</p><p>Since we're not using the <code class="literal">message</code> variable in our template anymore, we'll remove it from our <code class="literal">render</code> call in the <code class="literal">app.coffee</code> file, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">app.get '/', (req, res) -&gt;
<span class="strong"><strong>  res.render 'index'</strong></span>
</pre></div><p>Our page will now be updated, but it won't look too good. We'll use the same stylesheet that we used in the previous project to style our page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p><span class="strong"><strong>Not working as expected?</strong></span></p><p>Remember to keep an eye on the output of the supervisor process to see if you have any syntax errors in your CoffeeScript or Jade template, especially if you're not seeing the expected output.</p></div></div><p>Before we use the stylesheet, we need to set up Express to serve static files for us. Modify the <code class="literal">app.coffee</code> file to look like the following:</p><div class="informalexample"><pre class="programlisting">express = require 'express'
path = require 'path'

app = express()

app.set 'views', path.join __dirname, 'views'
app.set 'view engine', 'jade'
<span class="strong"><strong>app.use(express.static(path.join __dirname, 'public'))</strong></span>
</pre></div><p>So what's happening in the previous code snippet? We've added support for serving static files in a single line, but how does this work? The answer lies in how Node uses middleware.</p><div class="section" title="Middleware"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Middleware</h2></div></div></div><p>The Express framework is built on top of a lower-level framework called <span class="strong"><strong>Connect</strong></span>
<a id="id328" class="indexterm"/> (<a class="ulink" href="http://www.senchalabs.org/connect/">http://www.senchalabs.org/connect/</a>). <a id="id329" class="indexterm"/>The basic idea of Connect is to provide middleware for web requests.</p><p>Middleware<a id="id330" class="indexterm"/> can be chained together to <a id="id331" class="indexterm"/>produce a web application stack. Each piece of middleware is only concerned in providing a small set of functionality by modifying the output response or the control flow of the request.</p><p>In our example, we tell our application to use the middleware created by the <code class="literal">express.static</code> function<a id="id332" class="indexterm"/>. This function will create a static file server for the provided file path.</p></div><div class="section" title="Our stylesheet"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Our stylesheet</h2></div></div></div><p>Create a folder <a id="id333" class="indexterm"/>named <code class="literal">public</code> with a subfolder named <code class="literal">css</code>. Save the stylesheet as <code class="literal">todo.css</code> in this folder. We still need to include the stylesheet in our <code class="literal">index</code> view. Add the following line—highlighted in the code snippet—to the <code class="literal">index.jade</code> file in the <code class="literal">views</code> folder:</p><div class="informalexample"><pre class="programlisting">doctype 5
html
  head
  title  Collaborative Todo
<span class="strong"><strong>  link(rel="stylesheet", href="css/todo.css")</strong></span>
  body</pre></div><p>Once we have linked to our stylesheet, we should be able to refresh our view. It should now look much nicer.</p></div></div>
<div class="section" title="The client side"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>The client side</h1></div></div></div><p>To make <a id="id334" class="indexterm"/>our to-do application work, we're going to copy the client-side jQuery code<a id="id335" class="indexterm"/> that we created in <a class="link" href="ch03.html" title="Chapter 3. CoffeeScript and jQuery">Chapter 3</a>, <span class="emphasis"><em>CoffeeScript and jQuery</em></span>. We're going to put it in a file named <code class="literal">todo.coffee</code>.</p><p>Our next decision is, where shall we put this file? How will we compile and use its output in our application?</p><p>We could do the same thing as we did when we built our application in <a class="link" href="ch03.html" title="Chapter 3. CoffeeScript and jQuery">Chapter 3</a>, <span class="emphasis"><em>CoffeeScript and jQuery</em></span>, that is, create a <code class="literal">src</code> folder containing the client-side offeeScript code, then compile it using the <code class="literal">coffee</code> command with the <code class="literal">--watch</code> flag. The outputted JavaScript could then go in our <code class="literal">public</code> folder where we can include it as normal. But this would mean we would have two separate background tasks running, the supervisor task <a id="id336" class="indexterm"/>for running our server and another for compiling our client-side code.</p><p>Luckily there is a <a id="id337" class="indexterm"/>better way. You might recall that we had a reference to the <code class="literal">connect-assets</code> module in our <code class="literal">package.json</code> file. It provides us with an asset pipeline that is very similar to what you get in Rails. It will take care of compilation and dependency management transparently.</p><p>We'll need to use the middleware in our <code class="literal">app.coffee</code> file, as highlighted in the following code snippet:</p><div class="informalexample"><pre class="programlisting">app.set 'views', path.join __dirname, 'views'
app.set 'view engine', 'jade'
app.use(express.static(path.join __dirname, 'public'))
<span class="strong"><strong>app.use require('connect-assets')()</strong></span>
</pre></div><p>The <code class="literal">connect-assets</code> module will, by default, use the <code class="literal">assets</code> folder to manage and serve assets from. Let's create a folder named <code class="literal">assets/js</code> inside our root folder. We'll create a new file in this folder named <code class="literal">todo.coffee</code>, containing the following code:</p><div class="informalexample"><pre class="programlisting">Storage::setObj = (key, obj) -&gt;
  localStorage.setItem key, JSON.stringify(obj)

Storage::getObj = (key) -&gt;
  JSON.parse this.getItem(key)

class TodoApp

  constructor: -&gt;
    @cacheElements()
    @bindEvents()
    @displayItems()

  cacheElements: -&gt;
    @$input = $('#new-todo')
    @$todoList = $('#todo-list')
    @$clearCompleted = $('#clear-completed')

  bindEvents: -&gt;
    @$input.on 'keyup', (e) =&gt; @create e
    @$todoList.on 'click', '.destroy', (e) =&gt; @destroy e.target
    @$todoList.on 'change', '.toggle', (e) =&gt; @toggle e.target
    @$clearCompleted.on 'click', (e) =&gt; @clearCompleted()

  create: (e) -&gt;
    val = $.trim @$input.val()
    return unless e.which == 13 and val

    randomId = Math.floor Math.random()*999999

    localStorage.setObj randomId,{
      id: randomId
      title: val
        completed: false
    }
    @$input.val ''
    @displayItems()

  displayItems: -&gt;
    @clearItems()
    @addItem(localStorage.getObj(id)) for id in Object.keys(localStorage)

  clearItems: -&gt;
    @$todoList.empty()

  addItem: (item) -&gt;
    html = """
      &lt;li #{if item.completed then 'class="completed"' else ''} data-id="#{item.id}"&gt;
        &lt;div class="view"&gt;
          &lt;input class="toggle" type="checkbox" #{if item.completed then 'checked' else ''}&gt;
          &lt;label&gt;#{item.title}&lt;/label&gt;
          &lt;button class="destroy"&gt;&lt;/button&gt;
        &lt;/div&gt;
     &lt;/li&gt;
    """
    @$todoList.append html

  destroy: (elem) -&gt;
    id = ($(elem).closest 'li').data('id')
    localStorage.removeItem id
    @displayItems()

  toggle: (elem) -&gt;
    id = $(elem).closest('li').data('id')
    item = localStorage.getObj(id)
    item.completed = !item.completed
    localStorage.setObj(id, item)

  clearCompleted: -&gt;
    (localStorage.removeItem id for id in Object.keys(localStorage) \
      when (localStorage.getObj id).completed)
    @displayItems()

$ -&gt;
  app = new TodoApp()</pre></div><p>If you were following along in <a class="link" href="ch03.html" title="Chapter 3. CoffeeScript and jQuery">Chapter 3</a>, <span class="emphasis"><em>CoffeeScript and jQuery</em></span>, then this code should be familiar. It's our complete, client-side application that displays to-do items and creates, updates, and destroys items in <code class="literal">localStorage</code>.</p><p>To use this file in <a id="id338" class="indexterm"/>our HTML we still need to include a <code class="literal">script</code> tag. Since we're using jQuery, we'll also need to include the library in our HTML.</p><p>Add the following code to the bottom of the <code class="literal">index.jade</code> file:</p><div class="informalexample"><pre class="programlisting">script(src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js")
!= js('todo')</pre></div><p>As you can see, we include a link to jQuery using the Google CDN. We then use the <code class="literal">js</code> helper function, which is provided by <code class="literal">connect-assets</code>, to create a <code class="literal">script</code> tag that points to our compiled <code class="literal">todo.js</code> file (the <code class="literal">connect-assets</code> module will have compiled our CoffeeScript transparently). The <code class="literal">!=</code> notation is Jade's syntax for running a JavaScript function along with its result.</p><p>If all went well, we should be able to refresh the page and have a working, client-side page for our app. Try adding new items, marking items as complete, deleting items, and clearing completed items.</p></div>
<div class="section" title="Adding collaboration"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Adding collaboration</h1></div></div></div><p>Now we're ready to <a id="id339" class="indexterm"/>add collaboration to our to-do list application. We<a id="id340" class="indexterm"/> need to create a page where multiple users can connect to the same to-do list and can edit it simultaneously, seeing the results in real time.</p><p>We would like to support <a id="id341" class="indexterm"/>the idea of named lists, which you can join with others to collaborate on.</p><p>Before we dive into the functionality, let's tweak our UI a bit to support all of this.</p></div>
<div class="section" title="Creating the collaboration UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Creating the collaboration UI</h1></div></div></div><p>First, we'll add an input <a id="id342" class="indexterm"/>field to specify a list name and <a id="id343" class="indexterm"/>a button to join the specified list.</p><p>Make the following changes (highlighted in the code snippet) to our <code class="literal">index.jade</code> file, which will add an <code class="literal">input</code> element and a <code class="literal">button</code> element to specify our list name and join it:</p><div class="informalexample"><pre class="programlisting">      footer#footer
<span class="strong"><strong>        | Join list:</strong></span>
<span class="strong"><strong>        input#join-list-name</strong></span>
<span class="strong"><strong>        button#join Join</strong></span>
        button#clear-completed Clear completed
  script(src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js")
  != js('todo')</pre></div><p>Our page should now look like the page displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/9588_05_01.jpg" alt="Creating the collaboration UI"/></div></div>
<div class="section" title="WebSocket on the client"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>WebSocket on the client</h1></div></div></div><p>Now let's add an<a id="id344" class="indexterm"/> event handler to <a id="id345" class="indexterm"/>connect to a room when the user clicks the <span class="strong"><strong>Join</strong></span> button.</p><p>In our <code class="literal">todo.coffee</code> file, we'll add the following code to our <code class="literal">cacheElements</code> and <code class="literal">bindEvents</code> functions:</p><div class="informalexample"><pre class="programlisting">cacheElements: -&gt;
    @$input = $('#new-todo')
    @$todoList = $('#todo-list')
    @$clearCompleted = $('#clear-completed')
<span class="strong"><strong>    @$joinListName = $("#join-list-name")</strong></span>
<span class="strong"><strong>    @$join = $('#join')</strong></span>

  bindEvents: -&gt;
    @$input.on 'keyup', (e) =&gt; @create e
    @$todoList.on 'click', '.destroy', (e) =&gt; @destroy e.target
    @$todoList.on  'change', '.toggle', (e) =&gt; @toggle e.target
    @$clearCompleted.on 'click', (e) =&gt; @clearCompleted()
<span class="strong"><strong>    @$join.on 'click', (e) =&gt; @joinList()</strong></span>
</pre></div><p>We grab the <code class="literal">join-list-name</code> input and <code class="literal">join</code> button elements and store them in two instance variables. <a id="id346" class="indexterm"/>We then set up the <code class="literal">click</code> handler on the <code class="literal">@$join</code> button to call a new function called <code class="literal">joinList</code>
<a id="id347" class="indexterm"/>. Let's go ahead and define this function now. Add it to the end of the class after the <code class="literal">bindEvents</code> function is defined:</p><div class="informalexample"><pre class="programlisting">clearCompleted: -&gt;
    (localStorage.removeItem id for id in Object.keys(localStorage) \
      when (localStorage.getObj id).completed)
    @displayItems()

<span class="strong"><strong>  joinList: -&gt;</strong></span>
<span class="strong"><strong>    @socket = io.connect('http://localhost:3000')</strong></span>

<span class="strong"><strong>    @socket.on 'connect', =&gt;</strong></span>
<span class="strong"><strong>@socket.emit 'joinList', @$joinListName.val()</strong></span>
</pre></div><p>Here is where we start to use Socket.IO. The Socket.IO library comes in two parts: the client-side library for opening a WebSocket connection, making requests, and receiving responses, as well as the server-side node module for handling the requests.</p><p>In the preceding code, the <code class="literal">joinList</code> function opens a new socket using the <code class="literal">io.connect</code> function and passing in the URL. It then uses the <code class="literal">on</code> function to pass a handler function that will run after the WebSocket connection has been made.</p><p>The successful connection handler function will in turn use the <code class="literal">socket.emit</code> function<a id="id348" class="indexterm"/>, which allows us to send a custom message to the server using <code class="literal">joinList</code> as the identifier. We pass the value of the <code class="literal">@joinListName</code>
<a id="id349" class="indexterm"/> input as its value.</p><p>Before we can start implementing the server-side code, we still need to include a <code class="literal">script</code> tag to use the <code class="literal">socket.io</code> client library. Add the following highlighted<code class="literal"> script</code> tag at the bottom of the <code class="literal">index.jade</code> file:</p><div class="informalexample"><pre class="programlisting">script(src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js")
<span class="strong"><strong>script(src="/socket.io/socket.io.js")</strong></span>
!= js('todo')</pre></div><p>You might be wondering where this file comes from. Next, we'll set up the Socket.IO middleware in our <code class="literal">app.coffee</code> file. This will host the client-side library for us.</p></div>
<div class="section" title="WebSocket on the server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>WebSocket on the server</h1></div></div></div><p>We have our client-side code <a id="id350" class="indexterm"/>ready to make WebSocket requests;<a id="id351" class="indexterm"/> now we can move on to our Node backend. First, we'll need to set up our Socket.IO middleware. There is a small caveat to this, in that we cannot use Socket.IO as a middleware of the Express application directly, since Socket.IO expects a Node.js HTTP server and has no direct support for Express. Instead, we'll create a web server using the built-in Node.js HTTP module, passing our Express application as <code class="literal">requestListener</code>
<a id="id352" class="indexterm"/>. We can then use the <code class="literal">listen</code> function in Socket.IO to connect to the server.</p><p>The following is how the code looks in our <code class="literal">app.coffee</code> file:</p><div class="informalexample"><pre class="programlisting">express = require 'express'
path = require 'path'

app = express()
<span class="strong"><strong>server = (require 'http').createServer app</strong></span>
<span class="strong"><strong>io = (require 'socket.io').listen server</strong></span>

app.set 'views', path.join __dirname, 'views'
app.set 'view engine', 'jade'
app.use(express.static(path.join __dirname, 'public'))
app.use (require 'connect-assets')()

app.get '/', (req, res) -&gt;
  res.render 'index'

<span class="strong"><strong>io.sockets.on 'connection', (socket) =&gt;</strong></span>
<span class="strong"><strong>  console.log('connected')</strong></span>
<span class="strong"><strong>  socket.on 'joinList', (list) =&gt; console.log "Joining list #{list}"</strong></span>

<span class="strong"><strong>server.listen(3000)</strong></span>
console.log('Listening on port 3000')</pre></div><p>The <code class="literal">io.sockets.on 'connection'</code> function handles the event when a client connects. Here, we log to the console that we're connected to and then set up the <code class="literal">joinList</code> message handler. Right now, we'll just log the value that we receive from the client to the console.</p><p>We should now be able to test connecting to a list. Refresh our to-do list home page and enter a list name to join. <a id="id353" class="indexterm"/>After you clicked the <span class="strong"><strong>Join</strong></span> button, head over to our background supervisor task. You should see something similar to the following message:</p><p><span class="strong"><strong>connected</strong></span></p><p><span class="strong"><strong>Joining list Michael's List</strong></span></p><p>It worked! We've successfully created a bi-directional WebSocket connection. We still haven't really joined a list so far, so let's go ahead and do that now.</p></div>
<div class="section" title="Joining a list"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Joining a list</h1></div></div></div><p>To join a list, <a id="id354" class="indexterm"/>we'll use a feature of Socket.IO called <span class="strong"><strong>rooms</strong></span>
<a id="id355" class="indexterm"/>. It allows the Socket.IO server to segment its clients and emit messages to <a id="id356" class="indexterm"/>subsets of all the connected clients. On the server, we'll keep track of the to-do lists of each room and then tell the client to sync its local list when connected.</p><p>We'll update the <code class="literal">app.coffee</code> file with the highlighted code shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@todos = {}</strong></span>
io.sockets.on 'connection', (socket) =&gt;
  console.log('connected')
  socket.on 'joinList', (list) =&gt;
    console.log "Joining list #{list}"
<span class="strong"><strong>    socket.list = list</strong></span>
<span class="strong"><strong>    socket.join(list)</strong></span>
<span class="strong"><strong>    @todos[list] ?= []</strong></span>
<span class="strong"><strong>    socket.emit 'syncItems', @todos[list]</strong></span>
</pre></div><p>We initialize the <code class="literal">@todos</code> instance variable to be an empty hash. It will hold the to-do lists for each room, using the list name as a key. In the <code class="literal">joinList</code> handler function, we set the <code class="literal">list</code> property of the <code class="literal">socket</code> variable to equal the list name that the client passed in.</p><p>We then use the <code class="literal">socket.join</code> function that will join our list to a room with that name. If the room doesn't exist yet, it will be created. We then assign an empty array value to the item in <code class="literal">@todos</code> with the key equal to <code class="literal">list</code>. The <code class="literal">?=</code> operator will only assign the value on the right-hand side to the object on the left-hand side if it's <code class="literal">null</code>.</p><p>Lastly, we send a message <a id="id357" class="indexterm"/>to the client using the <code class="literal">socket.emit</code> function. The <code class="literal">syncItems</code> identifier will tell it to sync its local data with the to-do list items that we're passing it.</p><p>To handle the <code class="literal">syncItems</code> message, we'll need to update the <code class="literal">todo.coffee</code> file with the following highlighted code:</p><div class="informalexample"><pre class="programlisting">  joinList: -&gt;
    @socket = io.connect('http://localhost:3000')
    @socket.on 'connect', =&gt; 
   @socket.emit 'joinList', @$joinListName.val()

<span class="strong"><strong>    @socket.on 'syncItems', (items) =&gt;</strong></span>
<span class="strong"><strong>      @syncItems(items)</strong></span>
    

<span class="strong"><strong>  syncItems: (items) -&gt;</strong></span>
<span class="strong"><strong>    console.log 'syncing items'</strong></span>
<span class="strong"><strong>    localStorage.clear()</strong></span>
<span class="strong"><strong>    localStorage.setObj item.id, item for item in items</strong></span>
<span class="strong"><strong>    @displayItems()</strong></span>
</pre></div><p>After joining a list, we set up our client connection to handle the <code class="literal">syncItems</code> message. We expect to receive all the to-do items for the list that we have just joined. The <code class="literal">syncItems</code> function will clear all the current items in <code class="literal">localStorage</code>, add all the new items, and then display them.</p><div class="section" title="The UI"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>The UI</h2></div></div></div><p>Lastly, let's update our UI so<a id="id358" class="indexterm"/> that the user will know when they've joined a list and let them leave it. We'll modify our <code class="literal">#footer div</code> tag as follows in our <code class="literal">index.jade</code> file:</p><div class="informalexample"><pre class="programlisting">doctype 5
html
  head
  title  Collaborative Todo
  link(rel="stylesheet", href="css/todo.css")
  body
    section#todoapp
      header#header
        h1 todos
        input#new-todo(placeholder="What needs to be done?", autofocus=true)
      section#main
        ul#todo-list
<span class="strong"><strong>      footer#footer</strong></span>
<span class="strong"><strong>        section#connect</strong></span>
          | Join list:
          input#join-list-name
          button#join Join
          button#clear-completed Clear completed
<span class="strong"><strong>        section#disconnect.hidden</strong></span>
<span class="strong"><strong>          | Joined list: &amp;nbsp</strong></span>
<span class="strong"><strong>          span#connected-list List name</strong></span>
<span class="strong"><strong>          button#leave Leave</strong></span>
    script(src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js")
    script(src="/socket.io/socket.io.js")
    != js('todo')</pre></div><p>In the previous markup, we've <a id="id359" class="indexterm"/>added two new sections to our <code class="literal">footer div</code> tag. Each section will either be hidden or visible depending on which state we are in, <code class="literal">connected</code> or <code class="literal">disconnected</code> from a list. The <code class="literal">connect</code> section is the same as before. The <code class="literal">disconnect</code> section will display which list you are currently connected to and has a <span class="strong"><strong>Leave</strong></span> button.</p><p>Now we'll add code to our <code class="literal">todo.coffee</code> file to update the UI when a list is joined.</p><p>First, we'll cache the new elements in our <code class="literal">cacheElements</code> function, as highlighted in the following code snippet:</p><div class="informalexample"><pre class="programlisting">cacheElements: -&gt;
    @$input = $('#new-todo')
    @$todoList = $('#todo-list')
    @$clearCompleted = $('#clear-completed')
<span class="strong"><strong>    @$joinListName = $("#join-list-name")</strong></span>
<span class="strong"><strong>    @$join = $('#join')</strong></span>
<span class="strong"><strong>    @$connect = $('#connect')</strong></span>
<span class="strong"><strong>    @$disconnect = $('#disconnect')</strong></span>
<span class="strong"><strong>    @$connectedList = $('#connected-list')</strong></span>
<span class="strong"><strong>    @$leave = $('#leave')</strong></span>
</pre></div><p>Next, we'll change the UI to display that we're in a <code class="literal">connected</code> state when <code class="literal">syncItems</code> have been called (which gets fired by the server after successfully joining a list). We use the <code class="literal">@currentList</code> function, which we'll set in the <code class="literal">joinList</code> function; add the code highlighted in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  joinList: -&gt;
    @socket = io.connect('http://localhost:3000')
    @socket.on 'connect', =&gt;
<span class="strong"><strong>      @currentList = @$joinListName.val()</strong></span>
      @socket.emit 'joinList', @currentList

    @socket.on 'syncItems', (items) =&gt; @syncItems(items)
  
  syncItems: (items) -&gt;
    console.log 'syncing items'
    localStorage.clear()
    localStorage.setObj item.id, item for item in items
    @displayItems()
<span class="strong"><strong>    @displayConnected(@currentList)</strong></span>

<span class="strong"><strong>  displayConnected: (listName) -&gt;</strong></span>
<span class="strong"><strong>    @$disconnect.removeClass 'hidden'</strong></span>
<span class="strong"><strong>    @$connectedList.text listName</strong></span>
<span class="strong"><strong>    @$connect.addClass 'hidden'</strong></span>
</pre></div><p>The <code class="literal">displayConnected</code> function<a id="id360" class="indexterm"/> will just hide the <code class="literal">connect</code> section and show the <code class="literal">disconnect</code> section.</p></div><div class="section" title="Leaving a list"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Leaving a list</h2></div></div></div><p>Leaving a list should be<a id="id361" class="indexterm"/> quite easy. We disconnect the current socket connection and then update the UI.</p><p>To handle the <code class="literal">disconnect</code> action when a button is clicked, we add a handler in our <code class="literal">bindEvents</code> function, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">bindEvents: -&gt;
    @$input.on 'keyup', (e) =&gt; @create e
    @$todoList.on 'click', '.destroy', (e) =&gt; @destroy e.target
    @$todoList.on  'change', '.toggle', (e) =&gt; @toggle e.target
    @$clearCompleted.on 'click', (e) =&gt; @clearCompleted()
    @$join.on 'click', (e) =&gt; @joinList()
<span class="strong"><strong>    @$leave.on 'click', (e) =&gt; @leaveList()</strong></span>
</pre></div><p>As you can see, the handler we've added will just call a <code class="literal">leaveList</code> function. We still need to implement it. Add the following two functions to the end of the class after the last function defined in our <code class="literal">TodoApp</code> class:</p><div class="informalexample"><pre class="programlisting"> leaveList: -&gt;
    @socket.disconnect() if @socket
    @displayDisconnected()

  displayDisconnected: () -&gt;
    @$disconnect.addClass 'hidden'
    @$connect.removeClass 'hidden'</pre></div></div><div class="section" title="Testing it all"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Testing it all</h2></div></div></div><p>Now let's test our list joining and leaving code. <a id="id362" class="indexterm"/>To see it all in action, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">http://localhost:3000/</code> in your browser.</li><li class="listitem">In the browser window, type a list name and hit <span class="strong"><strong>Join List</strong></span>. The UI should update as expected.</li><li class="listitem">Once you've joined a list, add a few to-do items.</li><li class="listitem">Now open the site again, this time using a second browser. Since <code class="literal">localStorage</code> is unique to a browser, we do this to have a clean list of to-do items.</li><li class="listitem">Once again, type the same list name as you did in the other browser and hit <span class="strong"><strong>Join List</strong></span>.</li><li class="listitem">As the list is synced, you should now see the list items you've added in before showing up.</li><li class="listitem">Lastly, disconnect from a list using the <span class="strong"><strong>Leave</strong></span> button.</li></ol></div><div class="mediaobject"><img src="graphics/9588_05_02.jpg" alt="Testing it all"/><div class="caption"><p>Two lists synced from different browsers</p></div></div><p>This is great! We can now see the power of WebSockets in action. Our client is notified when it should sync items without having to poll the server.</p><p>However, once we're <a id="id363" class="indexterm"/>connected to the list, we still cannot add new items to have them show up in all the other clients in the room. Let's implement that.</p></div></div>
<div class="section" title="Adding to-do items to a shared list"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Adding to-do items to a shared list</h1></div></div></div><p>First, we'll handle<a id="id364" class="indexterm"/> adding new items on the server. <a id="id365" class="indexterm"/>The best place to handle this would be in the existing <code class="literal">create</code> function for creating to-do items. Instead of just adding them to <code class="literal">localStorage</code>, we'll also emit a message to the server telling it that a new to-do item has been created, and pass it as a parameter. Modify the <code class="literal">create</code> function to look like the following code:</p><div class="informalexample"><pre class="programlisting">create: (e) -&gt;
    val = $.trim @$input.val()
    return unless e.which == 13 and val

    randomId = Math.floor Math.random()*999999

<span class="strong"><strong>    newItem =</strong></span>
<span class="strong"><strong>       id: randomId</strong></span>
<span class="strong"><strong>       title: val</strong></span>
<span class="strong"><strong>       completed: false</strong></span>

<span class="strong"><strong>    localStorage.setObj randomId, newItem</strong></span>
<span class="strong"><strong>    @socket.emit 'newItem', newItem if @socket</strong></span>
    @$input.val ''
    @displayItems()</pre></div><p>We need to handle<a id="id366" class="indexterm"/> the <code class="literal">newItem</code> message on the server. We'll set up the code to do so when a client joins a list, in <code class="literal">app.coffee</code>.</p><p>Let's modify the <code class="literal">joinList</code> event handler that we added before; add the highlighted code in the following code snippet:</p><div class="informalexample"><pre class="programlisting">io.sockets.on 'connection', (socket) =&gt;
  console.log("connected")
  socket.on 'joinList', (list) =&gt;
    console.log "Joining list #{list}"
    socket.list = list
    socket.join(list)
    @todos[list] ?= []

    socket.emit 'syncItems', @todos[list]

<span class="strong"><strong>    socket.on 'newItem', (todo) =&gt;</strong></span>
<span class="strong"><strong>      console.log "new todo #{todo.title}"</strong></span>
<span class="strong"><strong>      @todos[list].push todo</strong></span>
<span class="strong"><strong>      io.sockets.in(socket.list).emit('itemAdded', todo)</strong></span>
</pre></div><p>In this code snippet, we set up yet another <code class="literal">socket</code> event when a user joins a list. In this case, it's for the <code class="literal">newItem</code> event. <a id="id367" class="indexterm"/>We add the new to-do item to our <code class="literal">@todos</code> array using the <code class="literal">push</code> function. Then we emit a new <code class="literal">itemAdded</code> message to all the clients in the current list.</p><p>What will happen with this <code class="literal">itemAdded</code> message? You guessed it; it will get handled in the client again. This kind of back and forth messaging is very common in WebSocket applications and does take some getting used to. Don't fret though; it gets easier once you get the hang of it.</p><p>Meanwhile let's handle the <code class="literal">itemAdded</code> event on the client. We also set up this code in our <code class="literal">joinList</code> method <a id="id368" class="indexterm"/>by adding the highlighted code in the following code snippet:</p><div class="informalexample"><pre class="programlisting">joinList: -&gt;
    @socket = io.connect('http://localhost:3000')
    @socket.on 'connect', =&gt;
      @currentList = @$joinListName.val()
      @socket.emit 'joinList', @currentList

    @socket.on 'syncItems', (items) =&gt; @syncItems(items)

<span class="strong"><strong>    @socket.on 'itemAdded', (item) =&gt;</strong></span>
<span class="strong"><strong>      localStorage.setObj item.id, item</strong></span>
<span class="strong"><strong>      @displayItems()</strong></span>
</pre></div><p>We handle the <code class="literal">itemAdded</code> event by calling <code class="literal">localStorage.setObject</code> with the item ID and value. This will either create a new to-do item if it's not present in <code class="literal">localStorage</code>, or it will update the existing value.</p><p>And that's it! We should now be able to add items to all the clients in the list. To test it, we'll follow similar steps to what we did earlier:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">http://localhost:3000/</code> in your browser.</li><li class="listitem">In the browser window, type a list name and hit <span class="strong"><strong>Join List</strong></span>. The UI should update as expected.</li><li class="listitem">Now open the site again, this time using a second browser.</li><li class="listitem">Once again, type the same list name as you did in the other browser and hit <span class="strong"><strong>Join List</strong></span>.</li><li class="listitem">Add new to-do items in either browser. You'll see the to-do items appear in the other browser immediately.</li></ol></div><p>Wow! Isn't this impressive?</p></div>
<div class="section" title="Removing to-do items from a shared list"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Removing to-do items from a shared list</h1></div></div></div><p>To remove to-do items from a<a id="id369" class="indexterm"/> shared list, we'll<a id="id370" class="indexterm"/> follow a similar pattern to adding items. In the <code class="literal">destroy</code> function in <code class="literal">todo.coffee</code>, we'll emit a <code class="literal">removeItem</code> message to our socket to let the server know that a item should be removed, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">destroy: (elem) -&gt;
    id = ($(elem).closest 'li').data('id')
    localStorage.removeItem id
<span class="strong"><strong>    @socket.emit 'removeItem', id if @socket</strong></span>
    @displayItems()</pre></div><p>Once again, we set up the server-side code to handle this message by removing the item from the shared list in<a id="id371" class="indexterm"/> memory, and then notify all clients connected to the list that the item has been removed:</p><div class="informalexample"><pre class="programlisting">io.sockets.on 'connection', (socket) =&gt;
  console.log("connected")
  socket.on 'joinList', (list) =&gt;
    console.log "Joining list #{list}"
    socket.list = list
    socket.join(list)
    @todos[list] ?= []

    socket.emit 'syncItems', @todos[list]

    socket.on 'newItem', (todo) =&gt;
      console.log "new todo #{todo.title}"
      @todos[list].push todo
      io.sockets.in(socket.list).emit('itemAdded', todo)

<span class="strong"><strong>    socket.on 'removeItem', (id) =&gt;</strong></span>
<span class="strong"><strong>      @todos[list] = @todos[list].filter (item) -&gt; item.id isnt id</strong></span>
<span class="strong"><strong>      io.sockets.in(socket.list).emit('itemRemoved', id)</strong></span>
</pre></div><p>The <code class="literal">removeItem</code> socket event handler<a id="id372" class="indexterm"/> gets the ID of the to-do item to remove the task passed into it. It removes the to-do item from the list by assigning the current value of the shared list to a new value that we create using JavaScript's array <code class="literal">filter</code> function<a id="id373" class="indexterm"/>. This will select all the items that don't have the passed ID. It then calls <code class="literal">emit</code> on all the client socket connections in the shared list with the <code class="literal">itemRemoved</code> message.</p><p>Lastly, we'll need to <a id="id374" class="indexterm"/>handle the <code class="literal">itemRemoved</code> message in our client. Similar to when we added items, we'll set this up in the <code class="literal">joinList</code> function in <code class="literal">todo.coffee</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">joinList: -&gt;
    @socket = io.connect('http://localhost:3000')
    @socket.on 'connect', =&gt;
      @currentList = @$joinListName.val()
      @socket.emit 'joinList', @currentList

    @socket.on 'syncItems', (items) =&gt; @syncItems(items)

    @socket.on 'itemAdded', (item) =&gt;
      localStorage.setObj item.id, item
      @displayItems()

<span class="strong"><strong>    @socket.on 'itemRemoved', (id) =&gt;</strong></span>
<span class="strong"><strong>      localStorage.removeItem id</strong></span>
<span class="strong"><strong>      @displayItems()</strong></span>
</pre></div><p>We remove the item from <code class="literal">localStorage</code> and update the UI.</p><p>To test removing items, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">http://localhost:3000/</code> in your browser.</li><li class="listitem">In the<a id="id375" class="indexterm"/> browser window, type a list name and hit <span class="strong"><strong>Join List</strong></span>. The UI should update as expected.</li><li class="listitem">Once you've connected to the shared list, add a few to-do items.</li><li class="listitem">Now open the site again, this time using a second browser.</li><li class="listitem">Once again, type the same list name as you did in the other browser and hit <span class="strong"><strong>Join List</strong></span>. Your to-do list will be synced with the shared list and will contain the items that you have added in the other browser.</li><li class="listitem">Click the remove icon to delete to-do items in either browser. You'll see the deleted to-do items disappear in the other browser immediately.</li></ol></div><div class="section" title="Now, it's your turn"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Now, it's your turn</h2></div></div></div><p>As a final exercise to you, I will ask you to make the <span class="strong"><strong>Clear completed</strong></span> button work. As a hint, you should be able to use the existing <code class="literal">destroyItem</code> method functionality.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec65"/>Summary</h1></div></div></div><p>In this chapter, we completed our tour of the CoffeeScript ecosystem by exploring Node.js as a fast, event-driven platform that lets you use JavaScript or CoffeeScript to write server applications. I hope that you have been given a glimpse of the joy of being able to write web applications using CoffeeScript on the server as well as in the browser at the same time.</p><p>We also spent some time with some of the wonderful open source libraries and frameworks that have been written for Node.js, like expressjs, connect, and Socket.IO and have seen how we can successfully use npm to manage dependencies and modules in our applications.</p><p>Our sample application was exactly the kind of thing that you would use Node.js for, and we saw how its event-driven model lends itself to writing applications where there are lots of constant interactions between the client and server.</p><p>Now that we've come to an end to our journey, I hope to have instilled in you the eagerness and skills to go out and use CoffeeScript to change the world. We've spent some time exploring not just the language but also the wonderful tools, libraries, and frameworks that enable us to develop powerful applications more rapidly using less code.</p><p>The future of CoffeeScript and the JavaScript ecosystem is bright, and hopefully you'll be a part of it!</p></div></body></html>