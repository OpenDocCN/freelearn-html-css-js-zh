<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer085">
<h1 class="chapter-number" id="_idParaDest-165"><a id="_idTextAnchor166"/>8</h1>
<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Building the Driving Game</h1>
<p>It may not be easy to believe it, but we are officially past the halfway point – while the end is still not in sight, we’ve made so much progress it’s tough to see our starting point. In the previous six chapters, we built out a huge amount of functionality encompassing an almost breathtaking diversity of subjects. The following figure shows where we were before and where we are now:</p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 8.1 – How it started versus how it’s going. A montage of screenshots showing our progress&#13;&#10;" height="857" src="image/Figure_8.01_B17266.jpg" width="1076"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – How it started versus how it’s going. A montage of screenshots showing our progress</p>
<p>From setting up the basic web application to implementing random encounters, a lot has gone into our code base to get to this point, but we’re not stopping or even slowing down any time soon! Making it this far into this book shows admirable persistence and determination – this chapter is where all of that will pay off. One of the more enjoyable aspects of game development is also one of the more obvious ones – the part of getting to work on the core gameplay and logic code. Unfortunately, and as people with experience of developing and shipping software will attest, all the other activities that go into building and delivering software tend to take up the lion’s share of available project time. </p>
<p>Throughout this chapter, we’re going to be building out the driving phase of Space-Truckers. Along with some of the techniques we learned earlier, we’re going to introduce a few new tools for the ol’ toolbox. We’re going to take things up a notch by adding a second camera to our scene that will render the <strong class="bold">Graphical User Interface</strong> (<strong class="bold">GUI</strong>). We’ll generate a route based on the previous phase’s simulated route and allow players to drive their trucks along it, avoiding obstacles (if they can). Our scene will use physics as the previous phase does, but instead of mainly using it as a gravitational simulation, we’re going to make use of the physics engine’s capabilities to simulate the results of collisions, friction, and more. Some things we’re going to introduce but defer more detailed examination until upcoming chapters – when this is the case, the relevant chapters and sections will be linked for easy reference. </p>
<p>All those exciting topics will hopefully more than make up for the more mundane but no less important task of building the necessary logic ahead of us. By the end of this chapter, we’ll have a playable driving game that sets us up for the following chapter, where we will continue to finish the overall game’s life cycle as we learn how to calculate and display scoring results.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Prototyping the Driving Phase</li>
<li>Integrating with the Application</li>
<li>Adding Encounters </li>
<li>Making the Mini-Map</li>
</ul>
<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Technical Requirements</h1>
<p>Nothing in this chapter is required from a technical perspective that hasn’t already been listed as being needed for the previous chapters, but there are some technical areas where it might be useful to have working knowledge as you read through this chapter:</p>
<ul>
<li><strong class="bold">MultiViews</strong>: <a href="https://doc.babylonjs.com/divingDeeper/cameras/multiViewsPart2">https://doc.babylonjs.com/divingDeeper/cameras/multiViewsPart2</a></li>
<li><strong class="bold">Layer Masks</strong>: <a href="https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam">https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam</a></li>
<li><strong class="bold">In-Depth Layer Masks</strong>: <a href="https://doc.babylonjs.com/divingDeeper/scene/layermask">https://doc.babylonjs.com/divingDeeper/scene/layermask</a></li>
<li><strong class="bold">Loading Any File Type</strong>: <a href="https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes">https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes</a></li>
<li><strong class="bold">Polar Coordinates</strong>: <a href="https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx">https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx</a> and <a href="https://math.etsu.edu/multicalc/prealpha/Chap3/Chap3-2/">https://math.etsu.edu/multicalc/prealpha/Chap3/Chap3-2/</a></li>
</ul>
<h1 id="_idParaDest-168"><a id="_idTextAnchor169"/>Prototyping the Driving Phase</h1>
<p>There’s a lot to do, so let’s dive right into it. Due to the way the driving phase is designed, players must navigate their trucks along a route that’s been pre-determined by the players in the<a id="_idIndexMarker577"/> previous game phase. The nature of the overall planned route<a id="_idIndexMarker578"/> determines similar overall characteristics of the driving route. Factors such as total transit time, distance, and velocities all fall into that kind of characteristic. Others, such as random encounters along the path, are more localized to a <a id="_idIndexMarker579"/>specific portion of the path. The behavior of each encounter is variable, but all will have a general form of forcing the player to make choices to avoid/obtain a collision while piloting their space-truck. Capturing the correlations between the two phases is an important design specification that will be useful – here’s what is listed on the Space-Trucker Issue created for that purpose:</p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 8.2 – Comparison of Route Planning versus driving phase variables. Source: https://github.com/jelster/space-truckers/issues/84" height="602" src="image/Figure_8.02_B17266.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Comparison of Route Planning versus driving phase variables. Source: <a href="https://github.com/jelster/space-truckers/issues/84">https://github.com/jelster/space-truckers/issues/84</a></p>
<p>Some of the properties have a direct 1:1 correlation between phases, such as total transit time and distance traveled. Others are used as scale or other indirect influencing factors, such as the point velocity affecting the route’s diameter. This will all be quite useful a bit further down this chapter’s journey, but for now, we will turn our attention to building out a Playground demonstrating the core principles of the driving phase. </p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>Playground Overview</h2>
<p>Prototyping in software is all about reducing a particular problem or area of interest to its bare essence. It forces us to ask the question – what is the smallest set of characteristics, attributes, features, and so on needed to evaluate the viability of a particular approach? In the case of our driving phase prototype, we don’t need to play through the planning phase to accomplish our goals – we just need to be able to process the route data generated by that phase. Focusing in, the problem of hooking up our route data to the driving phase isn’t the problem we’re trying to solve right now (though we can certainly do our future selves a solid by structuring our code in ways that facilitate building that logic!). This saves mental bandwidth and energy that can be put to good use elsewhere, which is where we will begin.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The Playground at <a href="https://playground.babylonjs.com/%23WU7235%2349">https://playground.babylonjs.com/#WU7235#49</a> is the reference for this section of this chapter.</p>
<p>We’ll need physics to be working so that we can playtest the interactions and relationships between the truck, obstacles, and velocities. We need to determine the proper scaling, orientation, and import settings for loading the first 3D asset <a id="_idIndexMarker580"/>model into the game – the semi-truck. Finally, we need to figure out how we’re going to plot oncoming obstacles in the radar GUI presented to the player. This seems like quite a lot to take on, but thanks to the functionality built into Babylon.js there’s much less complexity than it might seem. The following screenshot illustrates how these elements all come together in the Playground demo: </p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 8.3 – Space-Truckers driving phase Playground at https://playground.babylonjs.com/#WU7235#49" height="1096" src="image/Figure_8.03_B17266.jpg" width="1645"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Space-Truckers driving phase Playground at <a href="https://playground.babylonjs.com/%23WU7235%2349">https://playground.babylonjs.com/#WU7235#49</a></p>
<p>In the center of the viewport is our game’s protagonist, the eponymous space-trucker. The space-road stretches out in front of them, littered with the untextured blocks that are filling the place of encounters. In the lower-left part of the screen, a radar display sweeps in a circle, revealing upcoming obstacles as blips. The camera is chained to the truck so that the player’s perspective is always behind and a bit above the truck – the classic Third-Person Perspective. The controls are simple – <em class="italic">W</em> and <em class="italic">S</em> accelerate and decelerate in the truck’s forward direction, while <em class="italic">A</em> and <em class="italic">D</em> accelerate to the left and right, respectively. Vertical acceleration is managed with the<a id="_idIndexMarker581"/> <em class="italic">up arrow</em> and <em class="italic">down arrow</em> keys, and rotation with the <em class="italic">right arrow</em> and <em class="italic">left arrow</em>; resetting the demo is done by pressing the <em class="italic">Delete</em> key. Try to make it to the end of the path as fast as you can!</p>
<p>Let’s swap over to looking at the code for the demo, and how the demo is structured. Right away, we can see some similarities but also some differences from how we’ve structured our previous Playground demos. At the very top are the various asset URL and <strong class="bold">BABYLON</strong> namespace aliases; moving down, we have a rather hefty <strong class="source-inline">gameData</strong> object, and then we get to the most striking difference yet: the <strong class="source-inline">async drive(scene)</strong> function. </p>
<p>This is, as implied by the <strong class="source-inline">async</strong> prefix, an <strong class="bold">asynchronous</strong> JavaScript<a id="_idIndexMarker582"/> function. Its purpose is two-fold: one, to allow the use of the <strong class="source-inline">await</strong> statement in expressions within the function body, and two, to provide a container for closure over all the *<strong class="bold">var</strong>*-ious objects and values used by the demo.</p>
<p class="callout-heading">Note</p>
<p class="callout">The editors of this book apologize for subjecting you to the inredibad pun that was just made.</p>
<p>Furious punning discharged, we will continue with the first few lines of the PG above the <strong class="source-inline">drive</strong> function. To load our route data, we’ll choose the simple approach of wrapping a call to <strong class="source-inline">jQuery.getJSON</strong> in a promise that resolves to the array of route path points:</p>
<pre class="source-code">&#13;
var scriptLoaded = new Promise(&#13;
    (resolve, reject) =&gt;&#13;
        $.getJSON(routeDataURL)&#13;
            .done(d =&gt; resolve(d))&#13;
);</pre>
<p>This requires us to specify our <strong class="source-inline">createScene</strong> method as <strong class="source-inline">async</strong>, allowing us to write a simple harness to instantiate and return the Playground’s Scene after doing the same for the driving phase initialization logic:</p>
<pre class="source-code">&#13;
var createScene = async function () {&#13;
    var routeJSON = await scriptLoaded;&#13;
    var scene = new BABYLON.Scene(engine);&#13;
    const run = await drive(scene, routeJSON);&#13;
    run();&#13;
    return scene;&#13;
};</pre>
<p>The <strong class="source-inline">drive</strong> function is responsible for creating and/or loading any type of asset or resource that might require a bit of time to complete, so it is also marked as async. There’s a ton of code that goes into this function, so to make it easier to work with, the logic is split up into a few helper methods. Before those, the logic for basic scene and environment setup is constructed or defined. These are elements that might be needed by any or all the (potentially asynchronous) helper functions that include the invocation of those helper functions in the proper order. Once those tasks are complete, the <strong class="source-inline">run</strong> function is returned:</p>
<pre class="source-code">&#13;
await loadAssets();&#13;
initializeDrivingPhase();&#13;
initializeGui();&#13;
return run;</pre>
<p>We’ll cover the <strong class="source-inline">initializeGui</strong> method in this chapter’s <em class="italic">Making a Mini-Map</em> section after we establish a bit more context. Earlier in the <strong class="source-inline">drive</strong> function is probably the most important helper function that we want to prove out in the Playground, and <a id="_idIndexMarker583"/>that is the <strong class="source-inline">calculateRouteParameters(routeData)</strong> method. This is the workhorse function of the driving phase’s world creation and has probably the largest impact on how gameplay evolves in the form of dictating the properties of the route driven by the player. </p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Generating the Driving Path</h2>
<p>In <a href="B17266_07_Final_AM.xhtml#_idTextAnchor142"><em class="italic">Chapter 7</em></a>, <em class="italic">Processing Route Data</em>, we set up <strong class="source-inline">cargoUnit</strong> to log <strong class="source-inline">routeData</strong>: timing, position, velocity, rotation, and gravity <a id="_idIndexMarker584"/>are all captured every few frames of rendering into a collection of data points (along with encounters, which we’ll get to in the <em class="italic">Adding Encounters</em> section). The telemetry data is a deep well for creative and <a id="_idIndexMarker585"/>interesting ideas (see <em class="italic">Extended Topics</em>), but for now, we’ll just use the position, velocity, and gravity route values described in the <em class="italic">Playground Overview</em> section to generate the route path. </p>
<p>The beginning of the function grabs <strong class="source-inline">routeDataScalingFactor</strong> from <strong class="source-inline">gameData</strong>; though currently set to a value of <strong class="bold">1.0</strong>, changing this allows us to scale the route size and length consistently, easily, and quickly across route elements. In a concession to our desire to load up captured route telemetry from a JSON file, we iterate through the data array to ensure that the position, gravity, and velocity elements have been instantiated to their respective <strong class="source-inline">Vector3</strong> values, as opposed to a Plain Ol’ JavaScript Object. </p>
<p class="callout-heading">Important note</p>
<p class="callout">Taking proactive steps like this to reduce friction on quick iteration is key to building momentum!</p>
<p>Once that’s done, we use the positional vectors from the telemetry data to construct a new <strong class="source-inline">Path3D</strong> instance:</p>
<pre class="source-code">&#13;
let path3d = new Path3D(pathPoints.map(p =&gt; p.position),&#13;
  new Vector3(0, 1, 0), false, false);&#13;
let curve = path3d.getCurve();</pre>
<p>From the Babylon.js docs (<a href="https://doc.babylonjs.com/divingDeeper/mesh/path3D">https://doc.babylonjs.com/divingDeeper/mesh/path3D</a>), </p>
<p class="author-quote">“A Path3D is a mathematical object created from a sequence of position vectors of points on a curve.” </p>
<p><strong class="source-inline">Error! Hyperlink reference not valid.</strong> </p>
<p>Put another way, a <strong class="source-inline">Path3D</strong> represents an ordered set of coordinate points with some interesting and useful properties. </p>
<p class="callout-heading">Note</p>
<p class="callout">The reason for calling it a “mathematical object” is because it is not a member of the Scene and does not take part in rendering. This also sounds a lot cooler than calling it a “non-rendered abstract geometrical data structure.”</p>
<p>The <strong class="source-inline">getCurve()</strong> method is a utility method that spits back the sequence of points that define the path, but there are even more useful nuggets of value tucked away in <strong class="source-inline">Path3D</strong> that we’ll soon be exploring. First, though, we want to display the specific<a id="_idIndexMarker586"/> path taken by the player during the planning phase as a straight line going down the middle of the space-road. This is easy – we use the curve array in a call to <strong class="source-inline">MeshBuilder.CreateLines</strong> and that’s all there is to it! For more on this, see <a href="https://doc.babylonjs.com/divingDeeper/mesh/creation/param/lines">https://doc.babylonjs.com/divingDeeper/mesh/creation/param/lines</a>. After that is when we start constructing the geometry for the space-road, which is where things start to get interesting. </p>
<p>The geometric shape forming the base of <a id="_idIndexMarker587"/>our space-road is a Ribbon – a series of one or more paths, each with at least two <strong class="source-inline">Vector3</strong> points. The order the paths are provided works in conjunction with the paths themselves to produce geometry with a huge range of flexibility, and though potentially entertaining, it would be counterproductive to attempt to reproduce the excellent examples already created as part of the Ribbon’s documentation at <a href="https://doc.babylonjs.com/divingDeeper/mesh/creation/param/ribbon_extra">https://doc.babylonjs.com/divingDeeper/mesh/creation/param/ribbon_extra</a>. From those docs, this thought experiment nicely explains the concept we’re looking at currently:</p>
<p class="author-quote">“Imagine a long ribbon of narrow width in the real world with a wire running down its length. Closing the paths forms a loop of ribbon while closing the array would form a tube.”</p>
<p>Closing the array seems like the option we want rather than closing the paths themselves since we want our road to be enclosed, but not like a donut or loop. This faces us with a bit of a choice regarding how we’d like to approach<a id="_idIndexMarker588"/> implementing this, but only after we have established the value in doing it via prototyping, which in this circumstance becomes the link back to our choice of implementation paths in an endlessly circular argument.</p>
<p>When prototyping out the path creation (or any prototyping process in software), there’s a certain point in the process where you realize the <a id="_idIndexMarker589"/>need to transition from throwing something together to see if it works and taking consideration to build something more robust with the knowledge that it will be incorporated into the final product. Playground snippet <strong class="bold">#WU7235#11</strong> (<a href="https://playground.babylonjs.com/%23WU7235%2311">https://playground.babylonjs.com/#WU7235#11</a>) shows, starting around <strong class="bold">line 168</strong>, what this prototyped logic can look like (comments have been removed for clarity):</p>
<pre class="source-code">&#13;
let pathA = [];&#13;
let pathB = [];&#13;
let pathC = [];&#13;
let pathD = [];&#13;
for (let i = 0; i &lt; pathPoints.length; i++) {&#13;
    const { position, gravity, velocity } = pathPoints[i];&#13;
    let p = position;&#13;
    let speed = velocity.length();&#13;
    let pA = new Vector3(p.x+speed, p.y-speed, p.z+speed);&#13;
    let pB = new Vector3(p.x-speed, p.y-speed, p.z-speed);&#13;
    let pC = pB.clone().addInPlaceFromFloats(0, speed * 2,&#13;
      0);&#13;
    let pD = pA.clone().addInPlaceFromFloats(0, speed * 2,&#13;
      0);&#13;
    pathA.push(pA);&#13;
    pathB.push(pB);&#13;
    pathC.push(pC);&#13;
    pathD.push(pD);&#13;
}</pre>
<p>This is a scheme for path geometry that takes the form of a four-sided box (the ends are open). The preceding code uses four separate arrays of points – one for each corner – to capture the paths as it loops through each of the points along the route. This is what that looks like:</p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 8.4 – Prototype path geometry hardcoded to make a four-sided box with open ends. Four paths are used. Simple and effective, yet extremely limited (https://playground.babylonjs.com/#WU7235#11)" height="1074" src="image/Figure_8.04_B17266.jpg" width="1611"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Prototype path geometry hardcoded to make a four-sided box with open ends. Four paths are used. Simple and effective, yet extremely limited (<a href="https://playground.babylonjs.com/%23WU7235%2311">https://playground.babylonjs.com/#WU7235#11</a>)</p>
<p>Mission accomplished! We’re done here, right? Wrong. This is just the beginning! It’s OK to celebrate accomplishments, but it’s best to keep any celebrations proportional to the achievement in the context of the end goal. A box shape works to prove that we<a id="_idIndexMarker590"/> can create a playable path demo from actual route data, but it’s not particularly fun or attractive to look at. To step this up to a place where it’s something that will surprise and delight users, we need to make it more spherical and less boxy. We need to add more path segments to do this, and that’s where our prototype reaches its limits.</p>
<p>Referring to the previous code listing, each path of the ribbon has been predefined in the form of the <strong class="source-inline">pathA</strong>, <strong class="source-inline">pathB</strong>, <strong class="source-inline">pathC</strong>, and <strong class="source-inline">pathD</strong> arrays. If we want to add more segments, we need to manually add the additional path array, along with the appropriate logic, to locate path segments that aren’t at 90-degree right-angles to each <a id="_idIndexMarker591"/>other correctly – and that makes our current approach much tougher. There’s a certain mindset that prefers to attack this sort of problem head-on, with brute force. They might add <strong class="source-inline">pathE</strong>, <strong class="source-inline">pathF</strong>, or <strong class="source-inline">pathG</strong> arrays and pre-calculate the paths’ offsets relative to one another based on hardcoded numbers and after the dust settles, what comes out will probably work just fine… until the need arises to change the number of segments again. Or worse yet, the need arises to <em class="italic">dynamically</em> set the number of paths based on, for example, device performance characteristics. That’s why it’s necessary to come up with a Better Way Forward. </p>
<p>Let’s jump back to the original Playground we started with – <strong class="bold">#WU7235#23</strong> – and look at how it’s evolved starting at<a id="_idIndexMarker592"/> line 140. First things first, we know that we need to be able to specify how many separate paths should be created. That’s easy – just define a <strong class="source-inline">NUM_SEGMENTS</strong> constant. Next, we need to instantiate new path arrays to hold each path. We do this in a simple loop:</p>
<pre class="source-code">&#13;
const NUM_SEGMENTS = 24;&#13;
let paths = [];&#13;
for (let i = 0; i &lt; NUM_SEGMENTS; i++) {&#13;
    paths.push([]);&#13;
}</pre>
<p>Great – we have our array of path arrays ready to go. Now, it’s time to populate those paths, so we set up an outer loop over <strong class="source-inline">routePath</strong> containing an inner loop over each path array. But how do we figure out where each point of each path is supposed <a id="_idIndexMarker593"/>to be located? It’s not enough to use the simple constant offsets to each point position like we did in the prototype; each path segment’s points will have different offset values from each other. In the following diagram, the hoop or ring shape is a single cross-section segment, with all points lying in the same plane (math folks call this an affine set of points):</p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 8.5 – Creating a point of route geometry starts from the center point that moves clockwise around the diameter, adding path points for each discrete segment" height="788" src="image/Figure_8.05_B17266.jpg" width="942"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Creating a point of route geometry starts from the center point that moves clockwise around the diameter, adding path points for each discrete segment</p>
<p>Start from the current route position and use it as the center point. Now, focusing on one individual execution of the outer-most loop through <strong class="source-inline">routeData</strong>, we know that we need to create points equal in number to the number of desired segments. We also know that those segments should be evenly and contiguously distributed around the diameter of a hypothetical circle.</p>
<p class="callout-heading">Note</p>
<p class="callout">The reason we use a circle rather than a sphere is that relative to a given route point, the <em class="italic">Z</em>-axis values will always be the same for every path segment around that point. This is rather tautological since that’s also a somewhat meandering way to define a circle!</p>
<p>Putting those facts together and combining them with what we already know regarding circles and trig functions, we have a way to do just what we want. There’s just one remaining obstacle: how can we vary the position offset on the individual path being computed? Fortunately, this isn’t as big of an issue as it might seem at first. </p>
<p>Let’s remind ourselves of these facts about circles and trigonometric functions. The sine and cosine functions each take an input angle (in radians for this text unless otherwise noted) and output a value between -1 and 1 corresponding to the angle-dependent <em class="italic">X</em>- and <em class="italic">Y</em>-axis values, respectively. A full circle comprises two times Pi (3.14159…) radians, or about 6.28 radians. If we divide the number of segments by 6.28 radians, we would get the arc that an individual segment traverses, but if we divide the number of segments by the zero-based index of the <a id="_idIndexMarker594"/>currently iterating segment, then we get something more useful – the position <a id="_idIndexMarker595"/>between 0..1 of our current segment. A percentage, or ratio in other words. By multiplying that ratio with our two times Pi value, we get… the position of the segment, in radians! All that’s left is to scale the result by a value representing the desired radius (or diameter, for the <em class="italic">X</em>-axis) and add it to the path collection:</p>
<pre class="source-code">&#13;
for (let i = 0; i &lt; pathPoints.length; i++) {&#13;
    let { position, velocity } = pathPoints[i];&#13;
    const last = position;&#13;
    for (let pathIdx = 0; pathIdx &lt; NUM_SEGMENTS;&#13;
      pathIdx++) {&#13;
        let radiix = (pathIdx / NUM_SEGMENTS) *&#13;
          Scalar.TwoPi;&#13;
        let speed = velocity.length();&#13;
        let path = paths[pathIdx];&#13;
        let pathPoint = last.clone().addInPlaceFromFloats(&#13;
            Math.sin(radiix) * speed * 2,&#13;
            Math.cos(radiix) * speed, 0);&#13;
        path.push(pathPoint);&#13;
    }&#13;
}</pre>
<p>In the preceding code listing from <strong class="bold">#WU7235#25</strong>, we are using the <strong class="bold">length</strong> of the point’s <strong class="source-inline">velocity</strong> vector to determine the size of the space-road. We must <strong class="source-inline">clone</strong> the <strong class="source-inline">last</strong> point before mutating it; otherwise, we will end up corrupting the data needed by the rest of the application. By setting the value of <strong class="source-inline">NUM_SEGMENTS</strong> to <strong class="source-inline">4</strong> and progressively running the Playground at increasing numbers, it’s easy to see that the updated logic can now handle an arbitrary amount of line segments – an enormous improvement over our first-generation prototype! This code will be ready to integrate with the application when we’re ready to begin that process starting in the <em class="italic">Initializing the Driving Phase</em> section. There are still a few more things to prove out in other areas before that can happen, though. The <strong class="source-inline">loadAssets</strong> function is next up on our list.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Loading Assets Asynchronously</h2>
<p>In this Playground, we’re going to be loading two things asynchronously as part of the <strong class="source-inline">loadAssets</strong> function – the semi-truck model <a id="_idIndexMarker596"/>and the radar procedural texture asset. We need to make sure that all the asynchronous function calls have been completed <a id="_idIndexMarker597"/>before continuing by returning a promise that resolves only when all of its constituent promises have done so as well. Here’s what that looks like in <strong class="source-inline">loadAssets()</strong>:</p>
<pre class="source-code">&#13;
return Promise.all([nodeMatProm, truckLoadProm])&#13;
          .then(v =&gt; console.log('finished loading&#13;
            assets'));</pre>
<p><strong class="source-inline">nodeMatProm</strong> is created using a pattern that is used throughout Babylon.js and one we most recently used in the previous chapter’s discussion on loading JSON for a <strong class="source-inline">ParticleSystemSet</strong>, only for this Playground, instead of loading JSON directly, we will load data from the Babylon.js Snippet Server. Specifically, we are loading a snippet from the <strong class="bold">Node Material Editor</strong> (<strong class="bold">NME</strong>) that we will then use to create the radar procedural texture that is displayed on the GUI. Further details on those elements will have to wait until <a href="B17266_11_Final_AM.xhtml#_idTextAnchor230"><em class="italic">Chapter 11</em></a>, <em class="italic">Scratching the Surface of Shaders</em>:</p>
<pre class="source-code">&#13;
const nodeMatProm = NodeMaterial.ParseFromSnippetAsync&#13;
  (radarNodeMatSnippet, scene)&#13;
      .then(nodeMat =&gt; {&#13;
         radarTexture = nodeMat.createProceduralTexture(&#13;
         radarTextureResolution, scene);&#13;
      });</pre>
<p>While it may be obvious that <strong class="source-inline">radarTexture</strong> is a variable containing <a id="_idIndexMarker598"/>the <strong class="bold">procedural texture</strong>, it’s less obvious where the <strong class="source-inline">radarTextureResolution</strong> value comes in. One of the difficulties in creating a “simple” game prototype is that even something simple requires creating and managing a fair amount of configuration data. The <strong class="source-inline">gameData</strong> structure serves the purpose of centralizing and consolidating access to these types of values; when <a id="_idIndexMarker599"/>we want to utilize one or more of these values in a function, we can use JavaScript’s <strong class="bold">deconstruction</strong> feature to simplify and make our code much more readable:</p>
<pre class="source-code">&#13;
const { &#13;
        truckModelName, &#13;
        truckModelScaling, &#13;
        radarTextureResolution } = gameData;</pre>
<p>As we saw in the preceding code block, <strong class="source-inline">radarTextureResolution</strong> is used for determining the render height and width in pixels of the procedural texture, whereas we’ll shortly see how <strong class="source-inline">truckModelName</strong> and <strong class="source-inline">truckModelScaling</strong> are used. The <strong class="source-inline">SceneLoader.ImportMeshAsync</strong> method (new to v5!) takes an optional list of model names, along with the path and filename of an appropriate file containing the meshes to load (for example, <strong class="source-inline">.glb</strong>, <strong class="source-inline">.gltf</strong>, <strong class="source-inline">.obj</strong>, and so on), along with the current scene. The promise that’s returned resolves to an object containing the loaded file’s <strong class="source-inline">meshes</strong>, <strong class="source-inline">particleSystems</strong>, <strong class="source-inline">skeletons</strong>, and <strong class="source-inline">animationGroups</strong>, although we’re only going to be using the meshes collection for this scenario. </p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about <strong class="source-inline">SceneLoader</strong> and its related functionality at <a href="https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes#sceneloaderimportmesh">https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes#sceneloaderimportmesh</a>.</p>
<p>Once we’ve loaded the semi-truck’s model file, we’ve got a bit more work to do before we can start using the loaded asset. Models saved in <a id="_idIndexMarker600"/>the GLTF or GLB formats are imported into Babylon.js with some additional properties that are going to get in our way, so let’s simplify and set up <strong class="source-inline">truckModel</strong> for the game world:</p>
<pre class="source-code">&#13;
const truckLoadProm = SceneLoader.ImportMeshAsync&#13;
  (truckModelName, truckModelURL, "", scene)&#13;
    .then((result) =&gt; {&#13;
        let { meshes } = result;&#13;
        let m = meshes[1];&#13;
        truckModel = m;&#13;
        truckModel.setParent(null);&#13;
        meshes[0].dispose();&#13;
        truckModel.layerMask = SCENE_MASK;&#13;
        truckModel.rotation = Vector3.Zero();&#13;
        truckModel.position = Vector3.Zero();&#13;
        truckModel.scaling.setAll(truckModelScaling);&#13;
        truckModel.bakeCurrentTransformIntoVertices();&#13;
        m.refreshBoundingInfo();&#13;
    }).catch(msg =&gt; console.log(msg));</pre>
<p>The first few lines of our processing pipeline perform some convenient setup for the variables from the result structure, but then we do something a bit unusual by setting the parent of <strong class="source-inline">truckModel</strong> to <strong class="source-inline">null</strong> before disposing of the first mesh in the <strong class="source-inline">meshes</strong> array – what’s up with that, and what’s with <strong class="source-inline">SCENE_MASK</strong>? </p>
<p class="callout-heading">Note</p>
<p class="callout">For more on layer masks<a id="_idIndexMarker601"/> and how they operate, see the docs at <a href="https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam">https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam</a>.</p>
<p>The answer to the second is, briefly, that cameras can be assigned a specific number that only allows meshes with a compatible <strong class="source-inline">layerMask</strong> to be rendered by that camera. We use the <strong class="source-inline">layerMask</strong> property to hide non-GUI meshes from the main scene camera, for example. The answer to the first lies in the specifics of how an asset is loaded from a GLB or GLTF file. When Babylon.js reads in the file, there is an invisible <a id="_idIndexMarker602"/>transform node named <strong class="source-inline">__root__</strong> placed at the root of the model hierarchy. Although it doesn’t cause any problems in simple scenarios, when dealing with physics, parenting, collisions, and transforms, it becomes a major hindrance. The following screenshot <a id="_idIndexMarker603"/>illustrates what this looks like in the <strong class="bold">Scene Inspector</strong> window:</p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 8.6 – The Alien.gltf model. The Scene Inspector window shows the __root__ transform node. From https://playground.babylonjs.com/#8IMNBM#1" height="1076" src="image/Figure_8.06_B17266.jpg" width="1485"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – The Alien.gltf model. The Scene Inspector window shows the __root__ transform node. From <a href="https://playground.babylonjs.com/%238IMNBM%231">https://playground.babylonjs.com/#8IMNBM#1</a></p>
<p>The Alien geometry is what we’re interested in working with, but because it is parented to the <strong class="source-inline">__root__</strong> node, any changes to the position, rotation, or scaling of <strong class="source-inline">Alien</strong> are evaluated in a coordinate space relative to that root node, resulting in undesired and unpredictable results. The solution to this is simple and answers our earlier question regarding <a id="_idIndexMarker604"/>what was up with our <strong class="source-inline">loadAssets</strong> code – unparent the desired mesh and dispose of the root. Once that’s accomplished, the rest of the code in our truck loading method is all housekeeping setup for the model – with some important considerations to keep in mind: </p>
<ul>
<li>Order of operations is important, but not in the way you might think. Changes to a <strong class="source-inline">TransformNode</strong> (which <strong class="source-inline">Mesh</strong> is a descendent of) over a given<a id="_idIndexMarker605"/> frame are applied in the fixed order of <strong class="bold">Transform, Rotate, Scale</strong> (<strong class="bold">TRS</strong>).</li>
<li>Use <strong class="source-inline">setParent(null)</strong> rather than the alternative of setting <strong class="source-inline">mesh.parent = null</strong>. The <strong class="source-inline">setParent</strong> function preserves positional and rotational values, whereas setting the parent to null does not. This results in any root transformations being removed from the mesh, which is why we need to reset the position and rotation vectors.</li>
<li>Once the transformations have been cleared and the scaling has been set to world-appropriate values, the mesh geometry will need to have new bounding information generated. Otherwise, collisions won’t work properly. The solution to this is the two-step process of calling <strong class="source-inline">mesh.bakeCurrentTransformIntoVertices()</strong> before calling <strong class="source-inline">mesh.refreshBoundingInfo()</strong>. </li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Normally, it’s not recommended to call <strong class="source-inline">bakeCurrentTransformIntoVertices</strong> when there are better options such as <strong class="bold">parenting</strong> and <strong class="bold">pivotPoints</strong> that might work. In this case, we need to perform this step since we’ve removed the parenting to root. See <a href="https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/bakingTransforms">https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/bakingTransforms</a> for more information and guidance on this topic.</p>
<p>As mentioned previously, the result of calling <strong class="source-inline">Promise.all</strong> with the unresolved promises is the returned <strong class="bold">Promise</strong> from <strong class="source-inline">loadAssets</strong>, bringing us full circle back to where this discussion started! Initialization is mostly done – or at least the portion of it taking the longest time is complete – and now with the availability of the semi-truck model, the <strong class="source-inline">initializeDrivingPhase</strong> function has been invoked to set up the rest of the scene’s elements. This function sets <a id="_idIndexMarker606"/>up the cameras, creates the ground ribbon mesh from the <strong class="source-inline">routePaths</strong>, sets up physics, and more. </p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>Initializing the Driving Phase Scene</h2>
<p>As mentioned in this chapter’s introduction, the viewpoint for the player is in a third-person perspective, with the camera behind the semi-truck and <a id="_idIndexMarker607"/>looking over its top. As the truck moves (translation) or rotates (um, rotation), the camera mimics every movement from its offset position. The way this is accomplished is one of those situations where real-world analogies match well to software, in the form of <strong class="source-inline">cameraDolly</strong>.</p>
<p>A camera dolly is normally an engineered sort of cart used in the film industry that allows the Grip operating the camera to smoothly move in multiple dimensions while capturing footage. Our camera dolly doesn’t run on tracks, but it fulfills a similar <a id="_idIndexMarker608"/>purpose by moving with the truck to maintain the same forward-facing orientation regardless of the truck’s world-space orientation. This can be accomplished in just a few steps:</p>
<ol>
<li>Create a <strong class="source-inline">TransformNode</strong> to serve as the “camera dolly:”<p class="source-code">var cameraDolly = new TransformNode("dolly", scene);</p></li>
<li>Define an <strong class="source-inline">ArcRotateCamera</strong> and set up its basic properties. We’re patching property values in from <strong class="source-inline">gameData</strong> structures to reduce the amount of code:<p class="source-code">for (var k in followCamSetup) {</p><p class="source-code">    followCamera[k] = followCamSetup[k];</p><p class="source-code">}</p></li>
<li>Order of operations is important for this and the next step! First, parent <strong class="source-inline">cameraDolly</strong> to <strong class="source-inline">truckMesh</strong>.</li>
<li>Now, parent <strong class="source-inline">followCamera</strong> to <strong class="source-inline">cameraDolly</strong>:<p class="source-code">        cameraDolly.parent = truckModel;</p><p class="source-code">        followCamera.parent = cameraDolly;</p></li>
</ol>
<p>The first thing that happens in the <strong class="source-inline">initializeDrivingPhase</strong> method is that the camera gets created and the Viewport is set up. A quick aside to explain a bit more about that.</p>
<p>If a <strong class="bold">Camera</strong> is a bridge between a <strong class="bold">Scene</strong> and the <strong class="bold">Display</strong>, then a <strong class="bold">Viewport</strong> is what defines the Display aspect of that bridge. The default Viewport is fixed <a id="_idIndexMarker609"/>at coordinates <strong class="source-inline">(0,0)</strong> and has a size of <strong class="source-inline">(1,1)</strong>. In other words, the default Viewport’s top-left corner is located at <strong class="source-inline">(0,0)</strong> and the bottom-right corner is located at <strong class="source-inline">(1,1)</strong>; the entire screen is covered by it. This is greatly desired when a Scene has but a single camera, but there are many circumstances where it is useful to have a second camera positioned somewhere in the scene that renders to a smaller segment of the full screen – think of strategy games that provide a mini-map or racing games that have a rear-view mirror display. </p>
<p>In most cases, there are elements of the scene that should be rendered just in one camera, but not in another, which is finally where we make the connection with Layer Masks. By setting <strong class="source-inline">layerMask</strong> of all the involved cameras and meshes, we can efficiently show or hide geometry according to the mesh’s role in the scene. Our driving screen currently has two separate layer masks: <strong class="source-inline">SCENE_MASK</strong> and <strong class="source-inline">GUI_MASK</strong>. Cleverly toggling a mesh’s <strong class="source-inline">layerMask</strong> property can allow fine-grained control over camera rendering; if we want to display the mesh on one camera or the other, we can explicitly set its <strong class="source-inline">layerMask</strong> to <strong class="source-inline">SCENE_MASK</strong> or <strong class="source-inline">GUI_MASK</strong> (<strong class="source-inline">0x00000001</strong> and <strong class="source-inline">0x00000002</strong>, respectively). If we wish to display a mesh on <em class="italic">both</em> cameras, we can set and/or leave the default layer mask value in place (<strong class="source-inline">0xFFFFFFFF</strong>). Now that we know what’s going on with the viewport, we can get back to the function code.</p>
<p>After setting up the viewport, the parenting steps listed previously are executed. The <strong class="source-inline">MeshBuilder.CreateRibbon</strong> method is the next point of interest, where we pass the array or path arrays into the options of the function and get back our path geometry, which then gets some property tweaks and a grid material (for now) assigned:</p>
<pre class="source-code">&#13;
var groundMat = new GridMaterial("roadMat", scene);&#13;
var ground = MeshBuilder.CreateRibbon("road", {&#13;
    pathArray: route.paths,&#13;
    sideOrientation: Mesh.DOUBLESIDE&#13;
}, scene);&#13;
ground.layerMask = SCENE_MASK;&#13;
ground.material = groundMat;&#13;
ground.visibility = 0.67;&#13;
ground.physicsImpostor = new PhysicsImpostor(ground,&#13;
    <strong class="bold">PhysicsImpostor.MeshImpostor</strong>,&#13;
    {&#13;
        mass: 0,&#13;
        restitution: 0.25&#13;
    }, scene);</pre>
<p>With the ribbon created, material assigned, and a physics impostor similarly created and assigned to the ground mesh, the restitution property makes anything hitting the wall rebound with a little less momentum than before. That’s new, but there’s a bit of a twist (highlighted in the preceding code block) with the type of impostor we’re using here as well – <strong class="source-inline">MeshImpostor</strong>. Previously only available in the CannonJS physics plugin, where it is limited to interacting only with spheres, <strong class="source-inline">MeshImpostor</strong> is different from the other <strong class="source-inline">PhysicsImpostor</strong> types we’ve previously looked at (<strong class="source-inline">Box</strong> and <strong class="source-inline">Sphere</strong>). </p>
<p>Instead of using a rough approximation of the physics-enabled object’s geometry, it uses that very geometry itself to provide precise <a id="_idIndexMarker610"/>collision detection! The trade-off is that collision computation becomes more expensive the more complex the mesh’s geometry is structured. We should be OK for our needs though, since we don’t need our obstacles (that is, encounters) to interact with the path, leaving just the truck with complex collision calculation needs. Just a few more tasks remain before we will be done with our preparations and be ready to write the runtime logic!</p>
<p>After setting up the physics of <strong class="source-inline">truckModel</strong> – albeit using the equally applicable and much simpler <strong class="source-inline">BoxImpostor</strong> – we spawn some sample obstacles along the path before setting up an <strong class="source-inline">OnIntersectionExitTrigger</strong> that calls <strong class="source-inline">killTruck</strong> whenever the truck exits the <strong class="source-inline">routePath</strong> ribbon mesh’s confines. The <strong class="source-inline">spawnObstacles</strong> function will ultimately be discussed in the <em class="italic">Adding Encounters</em> section, so skipping over a discussion of that leads us to the familiar-in-practice of setting up <strong class="source-inline">ground.actionManager</strong> with the appropriate trigger (see the section on <em class="italic">Defining the EncounterZones in </em><a href="B17266_07_Final_AM.xhtml#_idTextAnchor142"><em class="italic">Chapter 7</em></a><em class="italic">, Processing Route Data</em>) – another place that is familiar enough to skip past. Now, we approach the final act of the <strong class="source-inline">initializeDrivingPhase</strong> function – (re)setting the truck to its starting position and state.</p>
<p>Using our sample route data, we could empirically determine what coordinates in the world space the truck should start at, its initial rotation, and other such values. We would iteratively refine our values through trial and error until the results were satisfactory, but would that satisfy our requirements? No.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you ever see a question asked in the preceding fashion, the answer is almost always “No.” This is the second instance in this chapter of that kind of rhetorical writing. Can you spot the third?</p>
<p>That entire trial and error approach will not “satisfy our requirements,” no thank you sir! We can make this extremely easy on ourselves by recalling that we already know exactly and precisely where the truck should start, where it should be <a id="_idIndexMarker611"/>pointing, and how fast it should be moving in the form of our pal <strong class="source-inline">route.path3d</strong>. It was mentioned in the earlier discussion on <strong class="source-inline">Path3D</strong>, it is a mathematical construct, and two of the more useful functions it provides, <strong class="source-inline">getPointAt</strong> and <strong class="source-inline">getTangentAt</strong>, are used to help us position the truck, but we didn’t get much into the details of why they’re useful.</p>
<p>Think about a path of some arbitrary length that consists of several points. Every point along that path has a set of vectors <a id="_idIndexMarker612"/>describing the position (naturally!), the <strong class="bold">tangent</strong> (a vector pointing in the direction of travel at that specific <a id="_idIndexMarker613"/>point along the curve), the <strong class="bold">normal</strong> (an arbitrarily chosen vector pointing perpendicularly to the tangent), and <a id="_idIndexMarker614"/>the <strong class="bold">binormal</strong> (a vector chosen to be perpendicular to the <strong class="bold">normal</strong>). These are all computed for us by the <strong class="source-inline">Path3D</strong> instance, making it easy to work with.</p>
<p>If we think of the point’s position in the path’s collection of points (that is, what index it occupies in the array) as being the ratio between the index and the total number of elements, then we can easily picture that ratio being a percentage, or a number between 0 and 1 (inclusive of both). <strong class="bold">Interpolated functions</strong> of <a id="_idIndexMarker615"/>the <strong class="source-inline">Path3D</strong> module all accept a number representing the percentage (between 0 and 1) along the path to operate against and include the related <strong class="source-inline">getNormalAt</strong>, <strong class="source-inline">getBinormalAt</strong>, and <strong class="source-inline">getDistanceAt</strong> functions. </p>
<p class="callout-heading">Note</p>
<p class="callout">There are more<a id="_idIndexMarker616"/> interpolation functions to explore! See <a href="https://doc.babylonjs.com/divingDeeper/mesh/path3D#interpolatio">https://doc.babylonjs.com/divingDeeper/mesh/path3D#interpolatio</a> for the full list.</p>
<p>This is useful because you don’t need to know what the length of the path is or how many points are in it to obtain useful information. In the <strong class="source-inline">resetTruck</strong> function, we get the position and the tangent of the first point in the route – the beginning of the path – then set the truck’s properties accordingly:</p>
<pre class="source-code">&#13;
const curve = route.path3d.getPointAt(0);&#13;
const curveTan = route.path3d.getTangentAt(0);&#13;
truckModel.position.copyFrom(curve);&#13;
truckModel.rotationQuaternion =&#13;
  Quaternion.FromLookDirectionRH(curveTan, truckModel.up);&#13;
truckModel.physicsImpostor.setAngularVelocity(currAngVel);&#13;
truckModel.physicsImpostor.setLinearVelocity(currVelocity);</pre>
<p>Since the physics engine sets and uses the <strong class="source-inline">rotationQuaternion</strong> property, we can’t just use the vector provided by <strong class="source-inline">getTangentAt(0)</strong> – we need to convert it into a Quaternion using the <strong class="source-inline">FromLookDirectionRH</strong> method. This function takes two vectors for its arguments: the first, a vector representing the desired forward direction, and then another vector representing the orthogonal (for example, perpendicular along all axis), with the return<a id="_idIndexMarker617"/> value being a Quaternion representing the input vectors. After setting the truck’s position and rotation, it’s necessary to reset the truck’s physical values for velocity since, from the physics engine’s perspective, the effects of being moved and rotated would need to be considered. Therefore, the <strong class="source-inline">reset</strong> method is a deterministic function – the effect on the state of the scene is always the same whenever it is called. This makes it especially useful to use it both immediately post-initialization and any time that the player chooses to do so. We listen for that player input in this Playground’s update method.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>Running the Update Loop</h2>
<p>Most of the code discussed up to this point has been code that directly relates to the context at hand. That’s the great thing <a id="_idIndexMarker618"/>about Babylon.js and its tooling – many common tasks are possible to complete with just a few lines of code. The <strong class="source-inline">update</strong> method is a good example of that but it’s also an example of one of the few places in the Playground<a id="_idIndexMarker619"/> where the code will need to be changed around completely to integrate it with the application, simply due to the more complex nature of the application versus the much more narrowly scoped Playground (see the next section, <em class="italic">Integrating with the Application</em>, for more). For that reason, we aren’t going to look too hard at the specifics of the function and instead focus on the mechanics of how the truck is controlled by the logic in it.</p>
<p>The truck can be controlled in the three translational axes (forward/back, left/right, up/down) and one rotational axis (the yaw axis), which might seem to make for a total of eight separate pieces of logic to handle the motion. However, since pairs of actions (for example, left and right) are simply the negated values of each other, we only need to figure it out for four – a nice reduction in complexity. In each frame, the delta frame time variable is used to scale <strong class="source-inline">truckAcceleration</strong> and <strong class="source-inline">truckTurnSpeedRadians</strong> to the correct values; the <strong class="source-inline">currVelocity</strong> and <strong class="source-inline">currAngVel</strong> counter variables track the accumulated changes that are then applied to the physics model’s linear and angular velocities at the end of the update process. This is like what we’ve done in the past, but some mathematical tools are being employed that we’ve not yet seen that are worth taking a closer look at.</p>
<p>Changing the forward or backward translational velocity is simple – just get the current forward vector for the truck mesh, scale it by <strong class="source-inline">currAccel</strong>, then add it to the <strong class="source-inline">currVelocity</strong> counter; the backward vector  consists of the negated value of the forward vector:</p>
<pre class="source-code">&#13;
if (keyMap['KeyW']) {&#13;
    currVelocity.addInPlace(currDir.scale(currAccel));&#13;
}&#13;
else if (keyMap['KeyS']) {&#13;
    currVelocity.addInPlace(currDir.scale(currAccel)&#13;
        <strong class="bold">.negateInPlace()</strong>);&#13;
}</pre>
<p>All of the various <strong class="source-inline">Vector3</strong> math methods come in various flavors that allow the developer to control whether or not the operation should allocate memory or reuse an existing object. In this case, we are using the <strong class="source-inline">addInPlace</strong> function to avoid <a id="_idIndexMarker620"/>creating a new vector object, whereas we create a new <strong class="source-inline">Vector3</strong> with the <strong class="source-inline">currDir.scale(currAccel)</strong> function call to avoid corrupting the truck mesh’s forward vector – a value relied upon by the engine for proper rendering.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Knowing when and what to perform memory allocation and disposal with can be key to a smoothly rendered scene. See <a href="B17266_13_Final_AM.xhtml#_idTextAnchor264"><em class="italic">Chapter 13</em></a>, <em class="italic">Converting the Application to a PWA</em>, for more information and guidance.</p>
<p>Back to our truck’s control logic, the mathematical trick is in how we figure out what direction to apply the remaining translational and rotational forces. Translating to the truck’s left or right is done by taking the cross product of the <a id="_idIndexMarker621"/>truck’s forward vector and the truck’s up vector – the result is a vector pointing in either the left or right direction (the same trick with <strong class="source-inline">negateInPlace</strong> can yield the opposite side from the same inputs):</p>
<pre class="source-code">&#13;
let left = Vector3.Cross(currDir, truckModel.up);&#13;
currVelocity.addInPlace(left.scale(currAccel / 2));</pre>
<p>Allowing players to side-strafe at the same speed as the other directions feels a bit too easy to lose control of the truck, so we cut the value in half to help players keep their speed under control. After integrating the accumulated changes to velocities and resetting the accumulation counters, the respective linear and angular physics properties are set along with an angular “damping” mechanism to help ease control:</p>
<pre class="source-code">&#13;
linVel.addInPlace(currVelocity);&#13;
truckModel.physicsImpostor.setLinearVelocity(linVel);&#13;
angVel.addInPlace(currAngVel);&#13;
currVelocity.setAll(0);&#13;
currAngVel.setAll(0);&#13;
// dampen any tendencies to pitch, roll, or yaw from&#13;
   physics effects&#13;
angVel.scaleInPlace(0.987);&#13;
truckModel.physicsImpostor.setAngularVelocity(angVel);</pre>
<p>That’s the end of the Playground’s update method, as well as the end of our examination of the driving phase prototype. After looking through what we want to accomplish overall with the Playground, we learned how to take the raw route data and turn it into a segmented tube encompassing the path. In an asynchronous loading method, we saw how a GLTF model can be imported and prepared for use with a Scene before we saw how the <strong class="source-inline">initializeDrivingPhase</strong> function sets up the camera dolly, physics, and obstacles along the path. With the <strong class="source-inline">reset</strong> method, we saw how to use the <strong class="source-inline">Path3D</strong> methods to properly position <a id="_idIndexMarker622"/>the truck, regardless of where it is and what state it is in. Not counting the GUI (which we’ll cover in the next chapter), we’ve seen how each of our objectives for the prototype is accomplished. This is a great foundation for the next step in progressing the<a id="_idIndexMarker623"/> game along, which is the less fun but ultimately more rewarding aspect of integrating our playground into the rest of the game.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor175"/>Integrating with the Application</h1>
<p>By constructing the playground driving demo, we’ve uncovered the techniques and basic design approach to use for the application code. The structure of our code is such that we should be able to simply lift and shift key pieces of functionality straight into the application’s code base, but only after we make modifications to prepare the way.</p>
<p>Playground logic aside, there are various hooks in <strong class="source-inline">SpaceTruckerApplication</strong> that need to be added <a id="_idIndexMarker624"/>or modified to get the driving phase to work properly, some of which include the ability to load into the driving game without going through Route Planning. Our basic input controls will need to be adapted to the input system of Space-Truckers, as well as the converse need to add new pieces of functionality to the input system. All of this starts with de-structuring and bringing in code from the Playground.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/>Splitting Up the Playground</h2>
<p><strong class="source-inline">spaceTruckerDrivingScreen</strong> is where the primary logic will reside for the driving phase, and similarly to how we tucked the Route Planning<a id="_idIndexMarker625"/> modules into the <strong class="source-inline">/src/route-planning</strong> subdirectory, we put the driving phase code and data into a <strong class="source-inline">/src/driving</strong> folder. Within that folder and, again, like the <strong class="source-inline">route-planning</strong> folder, is the <strong class="source-inline">gameData.js</strong> file, where we will place the equivalently named Playground object. A new addition to the <strong class="source-inline">gameData</strong> object from the Playground is the <strong class="source-inline">environmentConfig</strong> section; this data contains information such as the environment texture URL and other pieces of deployment-time-specific information.</p>
<p class="callout-heading">Note</p>
<p class="callout">We will be using the Encounter system (see the <em class="italic">Adding Encounters</em> section, later in this chapter) to populate the path with obstacles so that the <strong class="source-inline">obstacleCount</strong> property is omitted from the application code.</p>
<p>Although it is less consistent with the code design for Route Planning, the <strong class="source-inline">Driving</strong> screen breaks out the environment creation code into its own module, <strong class="source-inline">environment.js</strong>. Exporting just the <strong class="source-inline">initializeEnvironment</strong> function, this module demonstrates how it isn’t always necessary to create JavaScript classes to encapsulate and abstract logic – sometimes, a simple function will do the job just as well:</p>
<pre class="source-code">&#13;
const initializeEnvironment = (screen) =&gt; {&#13;
    const { scene } = screen;&#13;
    var light = new HemisphericLight("light", new&#13;
      Vector3(0, 1, 0), scene);&#13;
    light.intensity = 1;&#13;
    var skyTexture = new CubeTexture(envTextureUrl, scene);&#13;
    skyTexture.coordinatesMode = Texture.SKYBOX_MODE;&#13;
    scene.reflectionTexture = skyTexture;&#13;
    var skyBox = scene.createDefaultSkybox(skyTexture,&#13;
      false, skyBoxSize);&#13;
    skyBox.layerMask = SCENE_MASK;&#13;
    screen.environment = { skyBox, light, skyTexture };&#13;
    return screen.environment;&#13;
};&#13;
export default initializeEnvironment;</pre>
<p>None of the code in the preceding listing is particularly different from what we’ve already looked at in the Playground, except for the screen parameter <a id="_idIndexMarker626"/>representing the <strong class="source-inline">SpaceTruckerDrivingScreen</strong> instance being targeted by the function. To ensure that we can access (and later dispose of properly) the environment data, a composite data structure is returned to the caller containing <strong class="source-inline">skyBox</strong>, <strong class="source-inline">hemisphericLight</strong>, and <strong class="source-inline">skyTexture</strong>. This is similar to how the <strong class="source-inline">initializeEnvironment</strong> method of <strong class="source-inline">environment.js</strong>, <strong class="source-inline">driving-gui.js</strong> contains the <strong class="source-inline">initializeGui</strong> function. A minor detail for this is that, unlike <strong class="source-inline">initializeEnvironment</strong>, the <strong class="source-inline">initializeGui</strong> method is marked as <strong class="source-inline">async</strong>, but the details of what’s going on in this module will have to <strong class="bold">await</strong> the next chapter.</p>
<p class="callout-heading">Note</p>
<p class="callout">Is there any limit to how bad a pun can get before intervention becomes necessary?</p>
<p>Our last component of the driving phase is the humble truck. The driving phase analog of the Route Planning’s <strong class="source-inline">cargoUnit</strong>, our <strong class="source-inline">Truck</strong> class is derived from <strong class="source-inline">BaseGameObject</strong>, where it inherits the <strong class="source-inline">update</strong>, <strong class="source-inline">dispose</strong>, and various other properties of its base. We’re able to use most of the code from the Playground’s <strong class="source-inline">loadAssets</strong> method verbatim, and we only need to grab the non-input handling code from the Playground’s <strong class="source-inline">update</strong> method to use it with the truck (the screen will host the input actions and processing). Now that we’ve defined the <a id="_idIndexMarker627"/>logic and behavior for the screen, let’s look at how that logic is applied to the application.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>Transitioning to the Driving Screen</h2>
<p>During regular gameplay, the Driving phase is<a id="_idIndexMarker628"/> preceded immediately by the Route Planning phase. When the player manages to get the cargo unit to its destination, they are asked to confirm the route or retry. On the choice to confirm, the screen raises <strong class="source-inline">routeAcceptedObservable</strong> to notify interested parties of the event, the main subscriber to which is the <strong class="source-inline">initialize</strong> method of <strong class="source-inline">SpaceTruckerApplication</strong>:</p>
<pre class="source-code">&#13;
this._routePlanningScene.routeAcceptedObservable.add(() &#13;
  =&gt; {&#13;
    const routeData = this._routePlanningScene.routePath;&#13;
    this.goToDrivingState(routeData);&#13;
});</pre>
<p>For the other Screens (Main Menu, Splash Screen, and Route Planning), we’ve taken the approach of creating and loading up the screens as part of the <strong class="source-inline">SpaceTruckerApplication.initialize</strong> method. This obviates delay when transitioning between the Screens mentioned previously, but this approach won’t work with the Driving screen.</p>
<p>The Driving screen, as you might recall from earlier discussions in this chapter, needs to have <strong class="source-inline">routeData</strong> supplied to it at construction time. As we are yet unable to determine a player’s route before they’ve created it, so we must defer construction of the Screen until that time. We should also keep in mind that though a Screen might not be taking up render time, it will certainly consume memory – it would be prudent of us to dispose of the Route Planning screen and free up its resources as we transition to our new game state. This is the job of the <strong class="source-inline">goToDrivingPhase</strong> function:</p>
<pre class="source-code">&#13;
goToDrivingState(routeData) {&#13;
    this._engine.displayLoadingUI();&#13;
    routeData = routeData ??&#13;
      this._routePlanningScene.routePath;&#13;
    this._currentScene?.actionProcessor?.detachControl();&#13;
    this._engine.loadingUIText = "Loading Driving&#13;
      Screen...";&#13;
    this._drivingScene = new SpaceTruckerDrivingScreen&#13;
      (this._engine, routeData, this.inputManager);     &#13;
    this._currentScene = this._drivingScene;&#13;
    this._routePlanningScene.dispose();&#13;
    this._routePlanningScene = null;&#13;
    this.moveNextAppState(AppStates.DRIVING);&#13;
    this._currentScene.actionProcessor.attachControl();&#13;
}</pre>
<p>Many of the code is standard to the family of methods we’ve written to handle state transitions, such as the process of detaching control from <strong class="source-inline">_currentScene</strong> and attaching it to the new <strong class="source-inline">_drivingScene</strong> and <strong class="source-inline">moveNextAppState</strong>, with the main difference being in the disposal of <strong class="source-inline">_routePlanningScene</strong>. </p>
<p>The disposal logic for a Screen is fairly simple. Most resources associated directly with the Scene will be disposed of along with the Scene, but it’s also necessary to ensure that <strong class="source-inline">SoundManager</strong> is disposed of along with <strong class="source-inline">EncounterManager</strong>:</p>
<pre class="source-code">&#13;
dispose() {&#13;
    this.soundManager.dispose();&#13;
    this.onStateChangeObservable.clear();&#13;
    this.routeAcceptedObservable.clear();&#13;
    this.encounterManager.dispose();&#13;
    this.scene.dispose();&#13;
}</pre>
<p>The <strong class="source-inline">Observable.clear()</strong> method is useful when disposing of an object that you have control over because it precludes any need to know or have any references to the original subscription created via <strong class="source-inline">Observable.add</strong>. The final piece of the Driving phase transition is a shortcut to having the application directly load the Driving phase <a id="_idIndexMarker629"/>when launched, using the sample route data instead of a player’s simulated route. This is done by including the <strong class="source-inline">testDrive</strong> Query String value in the browser’s URL; when it is present and the player skips the Splash Screen, it will use the sample JSON route data:</p>
<pre class="source-code">&#13;
const queryString = window.location.search;&#13;
if (queryString.includes("testDrive")) {&#13;
    this.goToDrivingState(sampleRoute);&#13;
}</pre>
<p>This is a nice trick enabled by the fundamentally web-based nature of Babylon.js – we can easily use familiar web development tricks and tools to ease testing! Being able to quickly jump to a populated, “known good” Driving phase lets us quickly add and test various pieces of code for the application, which leads us to the major area of difference between the Playground and our application – how the <strong class="source-inline">Truck</strong> component is updated with input. </p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Truck Update and Input Controls</h2>
<p>Right away, there’s one obvious difference that needs to be addressed, and that’s the aspect of handling user input. Our Playground used a very simple input scheme, which will need to be refactored to use <strong class="source-inline">SpaceTruckerInputProcessor</strong> (see <a href="B17266_05_Final_AM.xhtml#_idTextAnchor103"><em class="italic">Chapter 5</em></a>,<em class="italic"> Adding a Cut Scene and Handling Input</em>). With the delegation of the actual per-frame update<a id="_idIndexMarker630"/> logic to the <strong class="source-inline">Truck</strong> component (see the <em class="italic">Splitting Up the Playground</em> section), the <strong class="source-inline">update</strong> method of <strong class="source-inline">SpaceTruckerDrivingScreen</strong> becomes very simple:</p>
<pre class="source-code">&#13;
update(deltaTime) {&#13;
        const dT = deltaTime ?? &#13;
          (this.scene.getEngine().getDeltaTime() / 1000);&#13;
        this.actionProcessor?.update();&#13;
        if (this.isLoaded) {&#13;
            this.truck.update(dT);&#13;
        }&#13;
    }</pre>
<p>The <strong class="source-inline">isLoaded</strong> flag is used to help prevent extraneous updates from being processing during/while the async initialization logic is executing. Input must be updated before calling the Truck’s update method, to ensure that the latest values have been read and set. Looking at the control scheme for the Drive phase, it’s also obvious that there are differences between it and the controls for the Route Planning phase. The application needs a way to specify new or modified control map schemes that can apply just to the currently active Screen.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Patching the input map</h2>
<p>The original <strong class="source-inline">inputActionMap</strong> defined the set of actions relevant to the Route Planning screen and the Main Menu, but there are additional <a id="_idIndexMarker631"/>actions that we need to support that aren’t present in the mapping file. We also need to redefine specific inputs that are used to control the camera during Route Planning. Consolidating those changes, we have a “patch” of sorts that we can apply to <strong class="source-inline">inputActionMap</strong>:</p>
<pre class="source-code">&#13;
const inputMapPatches = {&#13;
    w: "MOVE_IN", W: "MOVE_IN",&#13;
    s: "MOVE_OUT", S: "MOVE_OUT",&#13;
    ArrowUp: 'MOVE_UP',&#13;
    ArrowDown: 'MOVE_DOWN',&#13;
    ArrowLeft: 'ROTATE_LEFT',&#13;
    ArrowRight: 'ROTATE_RIGHT'&#13;
};&#13;
<strong class="bold">SpaceTruckerInputManager.patchControlMap</strong>(inputMapPatches);</pre>
<p>The <strong class="source-inline">patchControlMap</strong> function is a static method of the <strong class="source-inline">SpaceTruckerInputManager</strong> class. It has a corresponding <strong class="source-inline">unPatchControlMap</strong> function that reverts a given input map patch to the previous values:</p>
<pre class="source-code">&#13;
static patchControlMap(newMaps) {&#13;
    tempControlsMap = Object.assign({}, controlsMap);&#13;
    Object.assign(controlsMap, newMaps);&#13;
}&#13;
static unPatchControlMap() {&#13;
    controlsMap = tempControlsMap;&#13;
    tempControlsMap = {};&#13;
}</pre>
<p>The two different uses of <strong class="source-inline">Object.assign</strong> are interesting to note. The first uses a new, empty object (<strong class="source-inline">{}</strong>) to create a copy or clone of the original <strong class="source-inline">controlsMap</strong>, while the second copies the properties from <strong class="source-inline">newMaps</strong> into the existing <strong class="source-inline">controlsMap</strong>. This has the effect of overwriting any pre-existing properties, as well as creating new properties from the input patch. While the unpatching can be done manually, by adding it to the <strong class="source-inline">SpaceTruckerInputManager.dispose()</strong> function, it is performed automatically as part of the <strong class="source-inline">dispose</strong> function. </p>
<p>If it seems like we’re starting to move a lot faster now than we were earlier in this chapter, which is because it’s true – we’ve gotten the most complex part of the Driving Screen out of the way with our Playground demo. The Playground code is factored into different functions that can be split off and made into their own source files (with some modifications), and then consumed and orchestrated by <strong class="source-inline">SpaceTruckerDrivingScreen</strong>. We looked at the state machine changes to <strong class="source-inline">SpaceTruckerApplication</strong> that were needed to load sample route data by appending a query string to the browser URL before turning our attention <a id="_idIndexMarker632"/>to updating the control scheme and adding the ability for a screen to patch the input control map. Now that we’ve seen how it has been integrated with the application, it’s time to look at how encounters factor into the Driving phase gameplay.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor180"/>Adding Encounters </h1>
<p>The first thing needed to get encounters from Route Planning into the driving phase is to capture them into the route in the first place. Making a slight<a id="_idIndexMarker633"/> modification to the <strong class="source-inline">SpaceTruckerEncounterManager.onEncounter</strong> function gets the job done:</p>
<pre class="source-code">&#13;
const cargoData = this.cargo.lastFlightPoint;&#13;
<strong class="bold">cargoData.encounter = encounter;</strong></pre>
<p>The addition to the code (highlighted) adds the encounter instance to the last telemetry data point in the route, making it available to us later when we process the route. In <strong class="source-inline">calculateRouteParameters</strong>, we are making sure to include the encounter data in the resulting <strong class="source-inline">routePath</strong> structure, along with the position, velocity, and gravitational acceleration. </p>
<p>Now that the encounters have been located and processed, we can spawn the encounters themselves. For the time being, we are creating a temporary spherical mesh in the constructor to serve as a template for when we spawn the encounters:</p>
<pre class="source-code">&#13;
// temporary until the encounter spawner is implemented&#13;
this.tempObstacleMesh = CreateSphere("tempObstacle",&#13;
  this.scene);&#13;
this.tempObstacleMesh.visibility = 1;&#13;
this.tempObstacleMesh.layerMask = 0;</pre>
<p>It may seem contradictory to set <strong class="source-inline">tempObstacleMesh.visibility</strong> to <strong class="source-inline">1</strong> (fully visible) along with <strong class="source-inline">layerMask = 0</strong> (not rendered at all), but it makes sense when we look at the <strong class="source-inline">spawnObstacle(seed)</strong> function body and how it uses <strong class="source-inline">tempObstacle mesh</strong> as a template from which to create individual <strong class="bold">Instances</strong> of the mesh:</p>
<pre class="source-code">&#13;
let point = pathPoints[seed];&#13;
let {encounter, position, gravity, velocity} = point;&#13;
let encounterMesh = tempObstacleMesh.createInstance&#13;
  (encounter.id + '-' + seed);</pre>
<p>In <a href="B17266_06_Final_AM.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing the Game Mechanics</em>, we saw a few different ways of efficiently replicating a single mesh across a scene, hundreds or even thousands of times. In that case, we used Thin Instances to procedurally generate and render the asteroid <a id="_idIndexMarker634"/>belt because the balance of features and friction met our needs. In this case, we are creating more CPU-bound Instance meshes because we want to enable physics, animate properties such as scale and position, and have more control over the characteristics of the resultant mesh. At the same time, because Instances are all drawn during the same draw call on the GPU (and therefore share render characteristics), changing the visibility property would have the same effect across all instances. <strong class="source-inline">layerMask</strong> is not shared between Instances, though, hence why we use it to hide the mesh used for Instancing. </p>
<p>We are retaining some vestiges of the Playground, even though those elements don’t need to remain in the code base in the long term; an example of this is <strong class="source-inline">tempObstacleMesh</strong>. Though it will be very important for us to switch this out for a more appropriate set of meshes that match the encounters, it is not a feature that is needed to make immediate progress. How do we ensure that we do not neglect to return to this area in the future? Since we’re using GitHub, we can create an Issue to track it. </p>
<p class="callout-heading">Note</p>
<p class="callout">See <a href="https://github.com/jelster/space-truckers/issues/92">https://github.com/jelster/space-truckers/issues/92</a> to read about the history of the issue described previously.</p>
<p>Unlike the needs captured in the Issue, being able to place encounters as obstacles in the driving route is a critical-path piece of <a id="_idIndexMarker635"/>functionality because, without it, we wouldn’t be able to properly plot those obstacles into the player’s radar UI display. Now that we do have them, we have enough context to look at how encounters are combined with the GUI system to make the mini-map.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/>Making the Mini-Map</h1>
<p>While the bulk of the next chapter will focus on the Babylon.js GUI, we’ll dip our feet into the waters of<a id="_idIndexMarker636"/> the topic of <strong class="bold">User Interfaces</strong> (<strong class="bold">UIs</strong>) as we take a moment<a id="_idIndexMarker637"/> to discuss coordinate systems and polar coordinates. First, though, let’s look at how we get to the point where talk of coordinate systems becomes necessary by examining the <strong class="source-inline">initializeGui</strong> method of our Playground.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the application, this logic is contained in the <strong class="source-inline">driving-gui.js</strong> module in <strong class="source-inline">/src/driving/</strong>. Aside from moving the code to load the Node Material into it, the code is identical to the Playground.</p>
<p>At the beginning of this chapter, we talked about Viewports in the <em class="italic">Initializing the Driving Phase Scene</em> section, and we described two main characteristics – the viewport’s size and position. For the main Scene camera, the Viewport stretches the full size of the screen, but for our GUI system, the Viewport is defined differently.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>The GUI Camera</h2>
<p>The <strong class="source-inline">initializeGui</strong> function starts its business<a id="_idIndexMarker638"/> by immediately defining the camera and Viewport, but it also sets the camera up in Orthographic mode. This is a different way of rendering the 3D scene onto a 2D screen that can be essentially summarized as being a camera mode that renders objects without distance or perspective corrections:</p>
<pre class="source-code">&#13;
let guiCamera = new UniversalCamera("guiCam", new&#13;
  Vector3(0, 50, 0), scene);&#13;
    guiCamera.layerMask = GUI_MASK;&#13;
    guiCamera.viewport = new Viewport(0, 0, 1 - 0.6, &#13;
      1 - 0.6);&#13;
    guiCamera.mode = UniversalCamera.ORTHOGRAPHIC_CAMERA;&#13;
    guiCamera.orthoTop = guiViewportSize / 2;&#13;
    guiCamera.orthoRight = guiViewportSize / 2;&#13;
    guiCamera.orthoLeft = -guiViewportSize / 2;&#13;
    guiCamera.orthoBottom = -guiViewportSize / 2;&#13;
    scene.activeCameras.push(guiCamera);</pre>
<p>In our code, <strong class="source-inline">guiViewportSize</strong> corresponds to the number of units that the camera should cover in its field of view. That value is taken and used to compute the respective top, right, left, and bottom coordinates for the camera. Lastly, <strong class="source-inline">guiCamera</strong> is <a id="_idIndexMarker639"/>pushed onto the Scene’s <strong class="source-inline">activeCameras</strong> array to begin rendering through the camera. Once the camera and Viewport have been set up, the camera needs to have something to render, and that is the job of <strong class="source-inline">radarMesh</strong>. </p>
<p>As a simple Plane, <strong class="source-inline">radarMesh</strong> gets its magic from the textures assigned to its <strong class="source-inline">StandardMaterial</strong>. The first texture is one we mentioned earlier, and that’s the radar procedural texture created from <strong class="source-inline">NodeMaterial</strong> that we loaded up (see <a href="B17266_11_Final_AM.xhtml#_idTextAnchor230"><em class="italic">Chapter 11</em></a>, <em class="italic">Scratching the Surface of Shaders</em>, for more on <strong class="source-inline">NodeMaterial</strong> and the NME), and the second is a variant of our old friend <strong class="source-inline">AdvancedDynamicTexture</strong>:</p>
<pre class="source-code">&#13;
let radarMesh = MeshBuilder.CreatePlane("radarMesh", &#13;
  { width: guiViewportSize, height: guiViewportSize },&#13;
  scene);&#13;
radarMesh.layerMask = GUI_MASK;&#13;
radarMesh.rotation.x = Math.PI / 2;&#13;
//...&#13;
let radarGui =&#13;
  AdvancedDynamicTexture.CreateForMeshTexture(radarMesh,&#13;
  radarTextureResolution, radarTextureResolution, false);</pre>
<p><strong class="source-inline">CreateFullScreenUI</strong> is what we’ve used in the past when defining our GUI containers, and <strong class="source-inline">CreateForMeshTexture</strong> is quite similar. Instead of creating a texture the height and width of the screen, <strong class="source-inline">CreateForMeshTexture</strong> does the same for a specific mesh. The GUI texture can then be assigned to the mesh’s material as one of its textures:</p>
<pre class="source-code">&#13;
radarMesh.material = radarMaterial;&#13;
radarMaterial.diffuseTexture = radarGui;</pre>
<p>After the GUI system has been set up and assigned to the radar mesh, the encounters are looped over to create individual GUI “blips” to represent each:</p>
<pre class="source-code">&#13;
encounters.forEach((o, i) =&gt; {&#13;
    let blip = new Rectangle("radar-obstacle-" + i);&#13;
    o.uiBlip = blip;&#13;
    blip.width = "3%";&#13;
    blip.height = "3%";&#13;
    blip.background = "white";&#13;
    blip.color = "white";&#13;
    blip.cornerRadius = "1000";&#13;
    radarGui.addControl(blip);&#13;
});&#13;
var gl = new GlowLayer("gl", scene, { blurKernelSize: 4,&#13;
  camera: guiCamera });</pre>
<p>Developers familiar with CSS may recall using the trick of setting a high corner radius on a square to turn it into a circle, but otherwise, there isn’t anything we haven’t seen before in this code. The last thing to happen in the <strong class="source-inline">initializeGui</strong> function <a id="_idIndexMarker640"/>is the creation of a GUI-specific Glow Layer to help illuminate the radar and punch up its look. Defining the GUI elements involved putting a few new tools into our tool belt, and what better way to validate those tools than to put them to use in the runtime behavior of the radar?</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Blip Plotting in Polar Coordinates</h2>
<p>Normally, when we talk about the position of a particular object such as an encounter, we refer to it in terms of it representing a position in the World Space, the top-level 3D coordinate space for a rendered Scene. Sometimes, usually in the context of a model and its submeshes or bones, the position referred to is given relative to the parent mesh or transform node’s origin, or center. This is called a Local Space position <a id="_idIndexMarker641"/>and relates to a World Position via the World Matrix. In this chapter, we saw an example of working with these elements when we loaded the semi-truck model and removed the parent root node (see the <em class="italic">Loading Assets Asynchronously</em> section earlier in this chapter). The following diagram depicts some different ways of representing coordinates:</p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 8.7 – Local and World Space coordinate systems are Cartesian coordinate systems that depict locations as a combination of vector elements" height="683" src="image/Figure_8.07_B17266.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Local and World Space coordinate systems are Cartesian coordinate systems that depict locations as a combination of vector elements</p>
<p>Sometimes, it can be advantageous<a id="_idIndexMarker642"/> to represent coordinates in a different form. A Polar Coordinate system is one of those alternate ways of representing the position of something concerning another.</p>
<p>In polar coordinates, the origin of the<a id="_idIndexMarker643"/> plot represents the unit’s location in space with all other objects plotted around the center of that circle. Those objects’ coordinates can be captured into just two variables: <strong class="bold">angle</strong> (<strong class="bold">theta</strong>, or <strong class="bold">θ</strong>) and <strong class="bold">distance</strong> (<strong class="bold">r</strong>, or radius). </p>
<p class="callout-heading">Important note</p>
<p class="callout">Since the radar is in two dimensions but the location is in three, we use the <em class="italic">X</em>- and <em class="italic">Z</em>-axes while the <em class="italic">Y</em>-axis is discarded. Information about the object’s position along that axis is preserved as part of the Vector distance between the origin and the object being plotted. </p>
<p>The math to accomplish this is deceptively easy once we know the operations needed. To determine the vector distance, we could subtract the position of the encounter obstacle from the truck and obtain it via the <strong class="source-inline">Vector3.length()</strong> function, but the more direct path is to use the static <strong class="source-inline">Vector3.Distance()</strong> function instead. The value for <strong class="source-inline">theta</strong> has multiple paths to the same end:</p>
<pre class="source-code">&#13;
let r = Vector3.Distance(obstacle.absolutePosition,&#13;
  absolutePosition);&#13;
let theta = Vector3.GetAngleBetweenVectorsOnPlane&#13;
  (absolutePosition, up, obstacle.absolutePosition);</pre>
<p><strong class="source-inline">Vector3.GetAngleBetweenVectorsOnPlane</strong> is perfect for our use because it will automatically take differences in altitude between the truck and the obstacle into account by projecting each onto<a id="_idIndexMarker644"/> the same plane defined by the truck’s up vector. The next part is a bit tricky, though, because our coordinate system places <strong class="source-inline">(0, 0)</strong> at the center, whereas the GUI system placement puts the origin at the top-left bounds:</p>
<pre class="source-code">&#13;
let posLeft = Math.cos(theta) * r;&#13;
let posTop = -1 * Math.sin(theta) * r;&#13;
uiBlip.left = posLeft * 4.96 - (r * 0.5);&#13;
uiBlip.top = posTop * 4.96 - (r * 0.5);</pre>
<p>When setting the left and top <a id="_idIndexMarker645"/>properties of <strong class="source-inline">uiBlip</strong>, the points are scaled to the mesh’s size before correcting for origin locations. The result, as shown in the following screenshot, is circular blips that show their position relative to the player in a cool-looking way:</p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 8.8 – The radar GUI element plots the positions of encounters in terms of their relative distance and angle from the player (at the center of the circle)" height="750" src="image/Figure_8.08_B17266.jpg" width="1259"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The radar GUI element plots the positions of encounters in terms of their relative distance and angle from the player (at the center of the circle)</p>
<p>Though this section <a id="_idIndexMarker646"/>may have been short, it has certainly been full of sweet knowledge and results. There remain several mysteries to uncover <a id="_idIndexMarker647"/>regarding the radar mesh texture and its construction, but those will have to await a later chapter of our journey. We come out of this section knowing how to plot polar coordinates as well as how to set up a multi-camera scene with layer masks and Viewports. It’s a nice way to wrap up our work in this area and prepares us for what comes next!</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Summary</h1>
<p>Let’s take a step back and look at how far we’ve come during this chapter. When we started it, all we had was some route data and a vague idea of what we wanted to happen. Having completed it, we now have a game that can be played from end to end from Route Planning to Driving! </p>
<p>Along the way, we’ve leveraged the Playground to help us define a prototype demo of the driving phase gameplay. It was in that Playground that we learned how to take the raw route data and turn it into a configurable Ribbon mesh with as many or few segments as we’d like. The semi-truck GLB asset was introduced as we learned how to load and prepare assets like this for use in our Scene. Once we learned how to set up the scene, we defined physics and gave our truck the ability to bounce off the route’s walls with <strong class="source-inline">MeshImpostor</strong>, as well as a way to automatically “kill” the truck if it wanders out of bounds. All that work set us up for smooth integration with the application.</p>
<p>Beginning with a divide-and-conquer approach, we split the code from the Playground up into its different functional areas of responsibility. Then, we hooked up the plumbing to transition from either the splash screen (with the <strong class="source-inline">?testDrive</strong> URL Query string) or the <strong class="source-inline">onCargoAccepted</strong> event of the Route Planning Screen. Having the ability to quickly jump into the driving phase using sample route data made it easy to iterate and test through the rest of the integration with the runtime and input systems.</p>
<p>Our input handling needs for the Driving Phase are different from those of the Planning Phase, so to support that, we added the ability to path the base input action map with an updated set of input-to-action mappings. To keep our space-truck from getting lonely along its route, we turned our attention to hooking up encounters with the Driving screen via <strong class="source-inline">routeData</strong>.</p>
<p>Once we’d added encounter data to the overall <strong class="source-inline">routeData</strong>, it was straightforward to use a (for now) sphere mesh as a source for Instances of an Encounter. We’ll be changing this around later, but at this time, we don’t want to arrest any of the hard-earned momenta gained to take on any side-quests. Similarly, we learned how to set up our alternate GUI camera along with the polar coordinates – plotting encounters onto our radar procedural texture/GUI mesh. Put all together, we are in a great place to begin the next chapter in our journey, where we will cover the GUI. </p>
<p>Up until now, we’ve kept our GUI to a minimum. Even so, what amounts to basic boilerplate code while assigning values to properties can be quite astonishing. Nobody wants to have to write all that code and nobody wants to have to maintain it. In the next chapter, we’ll learn how we solve both of those problems while covering some other problems we didn’t even know existed when we go in-depth into the brand-new <strong class="bold">Babylon.js GUI Editor</strong>.</p>
<p>Until then, if you want to spend some more time exploring the ideas and concepts from this chapter, check out the <em class="italic">Extended Topics</em> section next for ideas and projects. As always, Space-Truckers: The Discussion Boards at <a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a> is the place to ask questions and exchange ideas with fellow Space-Truckers, while the Babylon.js forums are where to engage with the greater Babylon.js community. See a problem with the code or have an idea you’d like to see implemented? Feel free to create an Issue in the Space-Truckers repository!</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/>Extended Topics</h1>
<p>The following are some extended topics for you to try out:</p>
<ul>
<li>Add an “encounter warning” UI indication whenever the truck is within a set distance of an encounter</li>
<li>When the ship hits the side of the wall, play an appropriate sound effect. The volume of the played effect should scale with the energy of the impact. Bonus points for spatially locating the sound at the location of the collision.</li>
<li>An Encounter Table implies something static. Make encounters more dynamic by loading the list of potential encounters from a remote index repository hosted on GitHub. Community members can contribute new encounters by submitting a Pull Request containing the new encounter’s definition. Once accepted and merged, the encounter becomes available to be used in a game session.</li>
<li>As a prerequisite for the preceding bullet, adding the ability for each encounter to use a different mesh/material combination is a necessity. Read the mesh URL from the encounter data but be careful that you’re not creating new meshes/materials for every instance of an encounter!</li>
<li>Another Encounter feature could be the ability for each encounter type to define and control its behavior. An easy and cool way to do this is outlined in the very next chapter in the <em class="italic">Advanced Coroutine Usage</em> section.</li>
</ul>
</div>
<div>
<div id="_idContainer086">
</div>
</div>
</div></body></html>