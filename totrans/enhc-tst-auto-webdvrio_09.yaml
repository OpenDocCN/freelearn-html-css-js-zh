- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ancient Spell Book – Building the Page Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All frameworks have three to four abstraction layers. This might best be visualized
    as a book of ancient spells. The easiest incantations are at the beginning. These
    are building blocks for more complex and powerful enchantments in the middle.
    And the darkest secrets are always at the end of the cryptic grimoire. Similarly,
    there is the Test layer, which calls upon the methods referencing objects in the
    middle Page Object Class layer, which in turn utilizes helper wrappers and other
    functionality at the bottom-most Core layer. In a Cucumber framework, there is
    an additional abstraction layer from the Test Feature File layer to the step definitions
    to the Glue code to the core code layer. In this chapter, we focus on creating
    page elements and the methods used to perform actions on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that, here''s a list of all the main topics we''ll be covering in the
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what page object model is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a page class for the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding object selectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module.exports statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing code with common objects and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POM using Klassi-js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All test examples can be found at this GitHub repository: [https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO)'
  prefs: []
  type: TYPE_NORMAL
- en: What is Page Object Model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Page Object Model** (**POM**) is a design pattern used in test automation
    to create a structured and maintainable framework for web application testing.
    It promotes the separation of test code from the implementation details of the
    web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: In POM, each web page is represented as a separate class, and the properties
    and behaviors of the page are encapsulated within that class. Test methods interact
    with the web pages using the methods provided by the page classes, rather than
    directly accessing the web elements or using low-level browser APIs.
  prefs: []
  type: TYPE_NORMAL
- en: POM can be implemented in Node.js using frameworks such as WebdriverIO or Klassi-js
  prefs: []
  type: TYPE_NORMAL
- en: What constitutes a good Page Object pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good Page Object pattern in test automation is one that promotes the maintainability,
    reusability, and readability of the code. Some characteristics of a well-implemented
    Page Object pattern are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adheres to the Single Responsibility Principle (SRP)**: Each page class should
    have a single responsibility and represent a specific page or component of the
    application. This ensures that the code is well-organized and easy to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: The page class should encapsulate the details and behavior
    of the web page or component it represents. It should provide methods to interact
    with the page elements without exposing the underlying implementation details.
    This abstraction simplifies test code and makes it more readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modular and reusable**: Page classes should be modular and reusable across
    different tests and test suites. They should provide a consistent interface to
    interact with the page elements, allowing for easy reuse and reducing code duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adheres to separation of concerns (SoC)**: The Page Object pattern separates
    the test logic from the implementation details of the web pages. Test methods
    should utilize the methods provided by the page classes rather than directly interacting
    with the web elements or using low-level browser APIs. This separation improves
    code maintainability and makes it easier to update the tests when the application
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent of test framework**: Page classes should be independent of the
    specific test framework being used. They should not have any dependency on the
    testing framework, such as assertions or test execution logic. This ensures that
    the page classes can be easily reused with different testing frameworks or tools.
    Take a look at the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Clear naming conventions**: Page classes, methods, and variables should have
    meaningful and descriptive names that accurately represent their purpose and functionality.
    This helps improve code readability and understanding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Undergoes regular maintenance**: Page classes should be regularly maintained
    and updated as the application evolves. They should be kept in sync with the changes
    in the application’s UI and functionality. Regularly reviewing and updating page
    classes helps ensure their accuracy and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a page class for the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a `LoginPage` class that represents a specific page of the web
    application. The web element selectors are defined as getters using the `$` function
    from WebdriverIO, which allows us to locate elements on the page using CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: The class also includes page methods such as `enterUsername`, `enterPassword`,
    and `clickLoginButton`. These methods encapsulate actions that can be performed
    on the page, such as entering text into input fields and clicking buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mkdir` command in Linux/Unix allows users to create or make new directories.
    `mkdir` stands for “make directory”:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your `mkdir` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding object selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TestClass` test class utilizes the exported instances of the page classes.
    In the test case, we interact with the web pages using the methods defined in
    the page objects.
  prefs: []
  type: TYPE_NORMAL
- en: // LoginPage.ts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LoginPage`: This class encapsulates the properties and behaviors of it respective
    web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: // HomePage.ts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HomePage`: This class encapsulates the properties and behaviors of their respective
    web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: module.exports = new HomePage();Calling methods to be used in the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `module.exports` statement is used to export an instance of each page class
    as a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: // TestName.ts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TestName` test file utilizes the exported instances of the page classes.
    In this example test case, we interact with the LoginPage and the HomePage web
    pages using the methods and objects defined in the respective page classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reducing code with common objects and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reducing code duplication and improving maintainability can be achieved by
    leveraging common objects and methods in your Page Object pattern. Some strategies
    to achieve code reduction are set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base page class**: Create a base page class that contains common objects
    and methods shared across multiple pages. This base class can encapsulate elements
    and behaviors that are common to multiple pages, such as a **Home** button, **Halloween
    Party** button, and then a **Find My Candy!** button, to reduce duplication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Header of CandyMapper party page website with links common to
    all pages](img/B19395_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Header of CandyMapper party page website with links common to all
    pages
  prefs: []
  type: TYPE_NORMAL
- en: These elements appear in the header of every page of the website. So, it makes
    sense to declare them in the top-level page class and extend it to all other pages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Header page of the Candymapper landing page with three  common
    links](img/B19395_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Header page of the Candymapper landing page with three common links
  prefs: []
  type: TYPE_NORMAL
- en: 'If the selectors were in every page class, there would be an increasing level
    of maintenance over time. So, we will create selectors in the common page class
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 9.3 – Highlight of HOME link from the link selector](img/B19395_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Highlight of HOME link from the link selector
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a moment to look at these three examples as some changes could be
    made. These selectors match buttons in the header and the footer of the page.
    We could lock into just the first element match like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 9.4 – Locator identified for first Halloween Party link](img/B19395_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Locator identified for first Halloween Party link
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these elements are common to all our pages, it would make sense to create
    a common base `Page` class and store all of them there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Other page classes can now inherit from this base `Page` class all its common
    objects and functionality. We can use the `extends` keyword to add these object
    to any `Page` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Last, we use the `super` keyword to reference objects and methods in the common
    parent class to reduce repeated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we find only the case of the text of common elements is different from page
    to page or is frequently changing release to release , we can use this next approach
    to reduce maintenance. Consider the ''FIND MY CANDY'' link element below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 9.5 – Case insensitive match Locator for Find my candy! link](img/B19395_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Case insensitive match Locator for Find my candy! link
  prefs: []
  type: TYPE_NORMAL
- en: This is done via the display or visibility property of the element style. There
    is a single trick to find only elements that are visible. Ultimately, a collection
    of elements could be returned and each check for immediate visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Other page classes can be inherited from this base class and inherit its common
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Page components**: Identify common components or sections within your application’s
    pages that are repeated across multiple pages. Create separate page component
    classes to represent these reusable components. Then, include these components
    within your page classes to reuse the common functionality and reduce code duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helper methods**: Identify common operations or actions performed across
    multiple pages, such as logging in, navigating between pages, or handling popups.
    Extract these operations into helper methods that can be called from different
    page classes. This centralizes the implementation and avoids duplicating the code
    for these common actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameterization**: If you have similar elements or actions that vary based
    on input parameters, you can create parameterized methods in your page classes.
    These methods can accept parameters and perform the desired actions based on the
    provided input, reducing the need for separate methods for similar functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External configuration**: Move configurable values such as URLs, timeouts,
    or test data into external configuration files. This allows you to centralize
    and reuse the configuration across multiple tests and pages, reducing the need
    for hardcoding values in individual page classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainable selectors:** Use a reliable and maintainable way to locate elements
    on the page, such as CSS selectors or XPath expressions. Avoid using hardcoded
    selectors in your test methods. Instead, define selectors as properties within
    your page classes, making it easier to update them if the UI changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POM using Klassi-js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Klassi-js is a robust and versatile **behavior-driven development** (**BDD**)
    JavaScript test automation framework that empowers developers and QA professionals
    to create and execute comprehensive tests for web and mobile applications. At
    its core, Klassi-js leverages the power of WebdriverIO, which is a cutting-edge
    automation framework for Node.js. This foundation allows Klassi-js to seamlessly
    interact with web browsers and mobile devices, making it an excellent choice for
    cross-browser and cross-platform testing.
  prefs: []
  type: TYPE_NORMAL
- en: One of Klassi-js’s standout features is its seamless integration with cucumber.js,
    a popular BDD testing tool. This integration allows for the creation of human-readable,
    expressive test scenarios that foster better collaboration between developers,
    testers, and other stakeholders. It promotes a common language for discussing
    application behavior and helps in building more reliable tests.
  prefs: []
  type: TYPE_NORMAL
- en: Klassi-js goes a step further by offering integrated visual, accessibility,
    and API testing capabilities, ensuring that your application not only works but
    is also user-friendly, compliant with accessibility standards, and delivers the
    expected API responses. Moreover, Klassi-js provides the flexibility to run tests
    locally or harness the power of cloud-based testing platforms such as LambdaTest,
    BrowserStack, or Sauce Labs, allowing for scalable and efficient testing across
    various environments.
  prefs: []
  type: TYPE_NORMAL
- en: POM is a design pattern for organizing your UI automation code to make it more
    maintainable and readable. When using Klassi-js with Cucumber, you can implement
    the POM design pattern as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, organize your project structure to separate different concerns. A common
    structure might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`features`: Stores your Cucumber feature files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step-definitions`: Stores your Cucumber step definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pages`: Stores your page objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber feature files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create Cucumber feature files in the features directory of your project. These
    feature files describe the behavior of your application in plain text. For example,
    you can create a `login.feature` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Page objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a page object for each web page or component you want to interact with.
    Here’s an example, `login.page.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Cucumber step definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your step definitions, use page objects to interact with web elements. Here’s
    an example, `login.steps.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run your Cucumber tests as usual with Klassi-js. Use a command such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Klassi-js will automatically discover your Cucumber feature files and execute
    the corresponding step definitions.
  prefs: []
  type: TYPE_NORMAL
- en: With this structure, your UI automation code becomes more modular and easier
    to maintain. Each page object encapsulates the functionality and interactions
    with a specific page or component, making it easier to update and manage your
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the aforementioned principles, you can create a Page Object pattern
    akin to the meticulous planning of a superhero, ensuring your code becomes more
    maintainable, reusable, and readable. Just as a superhero fine-tunes their abilities
    to be more effective, by adhering to these strategies, you can reduce code duplication
    and enhance maintainability in your Page Object pattern. Reusing common objects,
    methods, and components across pages is like harnessing the compartments of a
    superhero's utility belt, streamlining your code and ensuring that modifications
    are easy to implement and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to amplify our framework's prowess by
    leveraging system variables and dynamic configurations, much like a superhero
    adapts to different environments, to seamlessly switch between dev and stage landing
    pages.
  prefs: []
  type: TYPE_NORMAL
