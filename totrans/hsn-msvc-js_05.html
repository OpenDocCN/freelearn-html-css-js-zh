<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor074"/>5</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Basic CRUD Microservices</h1>
			<p>Our previous chapters are proof that microservices development is not just about implementation. You need to at least have a clear understanding of the pros and cons of using microservices compared with other approaches we looked at in the previous chapters – monolith and service-oriented – and you need to have an essential understanding of the technologies you want to apply when building microservices.</p>
			<p>Applying all theoretical knowledge you have in practice is also not an easy task. This chapter will help us to apply microservices in practice and is one step forward to real-world microservices implementation. In this chapter, we plan to provide a solid foundation for further practical chapters.</p>
			<p>Implementing a microservice approach in your project means that you mostly have a complex business domain and the conceptual boundary of your microservice requires you to implement a part of this complex logic. It indicates that microservice development is more than <strong class="bold">Create</strong>, <strong class="bold">Retrieve/Read</strong>, <strong class="bold">Update</strong>, <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) but to have a basic understanding of the microservice application structure, this chapter is a good starting point.</p>
			<p>We’re going to explore the following topics:</p>
			<ul>
				<li>Understanding business requirements</li>
				<li>Tools to develop a basic microservice</li>
				<li>Preparing our first project</li>
				<li>Defining the internal architecture of our microservice</li>
				<li>Hands-on account microservice development</li>
				<li>Running and testing our first microservice</li>
			</ul>
			<p>Let’s get into it!</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p>To develop and test our first microservice, we’ll need the following tools:</p>
			<ul>
				<li>An IDE of your choice (we prefer Visual Studio Code)</li>
				<li>Postman</li>
				<li>MongoDB</li>
				<li>A browser of your choice</li>
			</ul>
			<p>It’s recommended that you download this book’s GitHub repository from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript</a> folder to easily follow our code snippets.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>Understanding business requirements</h1>
			<p>Before you jump into building microservices with JavaScript, it’s important to clearly understand what your services need to do. Then, based on what your project requires, you can pick the right tools to help you create those microservices.</p>
			<p>The team doesn’t consist of only developers. The business domain people are also an integral part of<a id="_idIndexMarker296"/> the team when it comes to building business valuable applications. In software development, the final and main artifact is code and it should reflect the real business. Applying domain language that everyone speaks will make your code a valuable source of truth and it is only possible if you have zero translation between business and developers. The most popular approach to developing such types of microservices with a single language that everyone speaks is <strong class="bold">Domain-driven Design</strong> (<strong class="bold">DDD</strong>). Everyone in <a id="_idIndexMarker297"/>a team should use the same language that describes the business in a given <a id="_idIndexMarker298"/>boundary. This is called <strong class="bold">Ubiquitous Language</strong> (<strong class="bold">UL</strong>). Using UL, everyone in a team will speak the same language and the language will be reflected in your code. It means business helps your design and developers help businesses to have more clearer understanding.</p>
			<p>Throughout our learning process, we’ll mention some ideas from DDD, despite this not being a DDD book. Please refer to <em class="italic">Implementing Domain-Driven Design</em>, by Vaugh Vernon, and <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, by Eric Evans, to learn more.</p>
			<p>This book is not about analyzing and gathering the business requirements. There are really good sources out there that focus exactly on this topic. To make things simple and less theoretical, we’ll start with distilled requirements with clear boundaries.</p>
			<p>We will build an account <a id="_idIndexMarker299"/>building microservice that requires the following <em class="italic">core functionalities</em>:</p>
			<ul>
				<li>Create account</li>
				<li>Update account</li>
				<li>Get all account information</li>
				<li>Get an account for the given ID</li>
				<li>Delete unused account</li>
			</ul>
			<p>Then, we have the following <em class="italic">non-functional</em> requirements:</p>
			<ul>
				<li><strong class="bold">Scalability</strong>: The<a id="_idIndexMarker300"/> microservice should be able to<a id="_idIndexMarker301"/> handle more and more requests as it gets used by more people.</li>
				<li><strong class="bold">Performance</strong>: The microservice should respond to requests quickly to keep users happy.</li>
				<li><strong class="bold">Resilience</strong>: The microservice should be able to bounce back from problems and keep working properly.</li>
				<li><strong class="bold">Easy testing</strong>: The microservice should be simple to test to make sure it’s working correctly.</li>
				<li><strong class="bold">Stateless</strong>: The microservice shouldn’t rely on remembering past interactions with users, and should instead store any important information in a database.</li>
				<li><strong class="bold">Easy updates</strong>: The microservice should be straightforward to put to use and update whenever needed. Of course, usually, you’ll have more non-functional requirements than these. However, for getting started, these should be more than enough.</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Tools to develop a basic microservice</h1>
			<p>Developing an application is not just a coding process. In this chapter, to develop our microservice, we also need to select the Node.js framework and store information in our database:</p>
			<ul>
				<li><strong class="bold">Database</strong>: We need to store information somewhere. It’s better to keep the service itself simple and <a id="_idIndexMarker302"/>store the information in a separate database:<p class="list-inset">For this service, we’ll be using <em class="italic">MongoDB</em>, a popular database that works differently than traditional SQL databases. MongoDB is a popular choice for building web services with Node.js technology.</p><p class="list-inset">It’s designed to handle situations where users mostly read information, and it can store a lot of data efficiently. MongoDB can be easily expanded by adding more servers as needed.</p></li>
				<li><strong class="bold">Node.js framework</strong>: You can build a fully functional microservice using just Node.js but it takes some time and a lot of lines of code. Nowadays, most developers use the Node.js<a id="_idIndexMarker303"/> frameworks to build services fast with a minimal amount of code lines. Node.js on its own is a low-level environment. Frameworks provide a predefined structure and organization for your code, making it easier to manage and maintain as your project grows. They often come with common functionalities such as <em class="italic">routing</em> (handling different URL requests), <em class="italic">templating</em> (generating web page content), and database interaction already built-in. This saves you time from writing those parts yourself.<p class="list-inset">Popular Node.js frameworks have large communities of developers. This means you have access to a wealth of resources, tutorials, and solutions online if you encounter problems. There’s also a bigger pool of developers familiar with the framework for potential collaboration.</p><p class="list-inset">Frameworks can help mitigate security vulnerabilities by providing established coding practices and features to prevent common attacks.</p></li>
			</ul>
			<p>For this chapter, we’re going to use <em class="italic">Express.js</em>, one of the most popular Node.js frameworks for building microservices.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Preparing our first project</h1>
			<p>Our focus in this chapter is to create a microservice that provides really simple CRUD operations. So, it’s going to be mostly domain-centric. That’s why we start our application from the database.</p>
			<p>To follow our examples, open the <code>Ch05</code> folder in this book’s GitHub repository and open it using your favorite text editor.</p>
			<p><em class="italic">There’s a difference between knowing the path and walking </em><em class="italic">the path.</em></p>
			<p>We prefer that you don’t just download and explore the repository and that you also try to write some code with us. This will help you gain valuable practice.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Understanding the concept of packages</h2>
			<p>Building software doesn’t mean that you should implement everything from scratch and this fact doesn’t depend on programming languages. It is also applicable for Node.js development. Our main <a id="_idIndexMarker304"/>focus should always be solving business problems and making this process fast, easy, secure, and reliable. Almost every popular programming<a id="_idIndexMarker305"/> language provides a collection of libraries. In Node.js, these are called <strong class="bold">packages</strong>. Node.js development mostly starts with package configuration.</p>
			<p>When you install Node.js, you <a id="_idIndexMarker306"/>automatically install the <code>npm</code> a great and reliable source for development. For example, if you need validation for your application, you shouldn’t build everything from scratch. Why not use popular practices that have already been implemented in popular libraries? We mostly build only business-specific functionalities by ourselves. Other relevant functionalities, such as connecting to the database, validation, security, logging, and more, can be installed as packages and reused.</p>
			<p>Here’s how you can interact with <code>npm</code> and configure it:</p>
			<ol>
				<li>Open your favorite text editor (we’re using Visual Studio Code).</li>
				<li>Create a folder (in our case, <code>Ch05</code>).</li>
				<li>Navigate to that folder using your terminal (Use <code>cd folder_name</code> command to navigate to your empty folder – that is, use <code>cd Ch05</code>).</li>
				<li> Type <code>npm init</code> and follow the instructions provided (<em class="italic">Figure 5</em><em class="italic">.1</em>):</li>
			</ol>
			<div><div><img alt="Figure 5.1: Creating a package.json file" src="img/B09148_05_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Creating a package.json file</p>
			<ol>
				<li value="5">Hit <em class="italic">Enter</em> to generate <strong class="bold">package </strong><strong class="bold">configuration</strong> (<em class="italic">package.json</em>).</li>
				<li>At this point, we have a special file called <code>package.json</code> in our project with the following JSON content:<pre class="source-code">
{
  "name": "accountmicroservice",
  "version": "1.0.0",
  "description": "simple account microservice with crud functionalities",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/PacktPublishing/Hands-on-
             Microservices-with-JavaScript.git"
  },
  "author": "Suleymani Tural",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/PacktPublishing/Hands-on-
             Microservices-with-JavaScript/issues"
  },
  "homepage": "https://github.com/PacktPublishing/Hands-on-
                Microservices-with-JavaScript#readme"
}</pre></li>				<li>For learning purposes, it is<a id="_idIndexMarker308"/> also OK to use the <code>npm init -y</code> command instead of <code>npm init</code> as it will generate a minimal <code>package.json</code> file for you to get started with (<em class="italic">Figure 5</em><em class="italic">.2</em>). After generation, you can manually update any line you want:</li>
			</ol>
			<div><div><img alt="Figure 5.2: Generated package.json file" src="img/B09148_05_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Generated package.json file</p>
			<p>Let’s learn more<a id="_idIndexMarker309"/> about the <code>package.json</code> file.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Understanding the package.json file</h2>
			<p>The <code>package.json</code> file is a<a id="_idIndexMarker310"/> vital component in Node.js projects. It acts like a <a id="_idIndexMarker311"/>project manifest, storing crucial information about your project.</p>
			<p>Let’s summarize the role of the <code>package.json</code> file in our Node.js projects:</p>
			<ul>
				<li>It lists all the external modules (dependencies) your project relies on to function.</li>
				<li>Along with the names, it specifies the required versions using semantic versioning for compatibility. This ensures that everyone working on the project uses the same compatible versions of dependencies.</li>
				<li>It serves as a central location for project metadata, such as the project’s name, version, description, license, and author information (see <em class="italic">Figure 5</em><em class="italic">.2</em>).</li>
				<li>You can define custom scripts in the <code>package.json</code> file to automate repetitive tasks within your project. These scripts can do anything from starting the development server to running tests or building the project for deployment.</li>
				<li>If you plan to publish your project as a reusable package for others to use, <code>package.json</code> becomes even more important. It provides essential information for the package manager (such as <code>npm</code>) to understand how to install and use your project <a id="_idIndexMarker312"/>effectively.</li>
			</ul>
			<p>Long story short, <code>package.json</code> keeps your project organized, ensures consistent dependencies, and simplifies collaboration<a id="_idIndexMarker313"/> among developers.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>Understanding index.js files</h2>
			<p>Throughout this <a id="_idIndexMarker314"/>chapter, you’ll encounter files named <code>index.js</code>. These files play a couple of important roles.</p>
			<p>By convention, <code>index.js</code> acts as <a id="_idIndexMarker315"/>the entry point for our Node.js application. When we run our application using node, the <code>index.js</code> file is the starting point where the application’s execution begins.</p>
			<p>Inside <code>index.js</code>, you can typically find code that imports necessary modules and libraries using the required statements to configure your application (for example, setting up a web server and connecting to databases) and defines the main logic or event listeners for your application.</p>
			<p>These files can also serve for namespacing and organization within your project. Consider a folder containing multiple JavaScript files with related functionalities. An <code>index.js</code> file inside that folder can act as a central point for importing those related files and re-exporting specific functions or classes from those files, making them accessible outside the folder using a single import statement.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It’s important to note that <code>index.js</code> is a convention, not a strict requirement. You can name your entry point file differently (for example, <code>app.js</code> or <code>main.js</code>). So long as you specify the correct filename when you’re running your application with node, it will work.</p>
			<p>In summary, <code>index.js</code> files serve as a common entry point and a way to organize code within folders in your Node.js projects. They provide a clean and consistent approach to structuring your <a id="_idIndexMarker316"/>application’s starting point and managing related functionalities.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Installing the required packages</h2>
			<p>By itself, <code>package.json</code> doesn’t contain any required package that we plan to use by default. It is just <a id="_idIndexMarker317"/>boilerplate for getting started. Here’s a list of packages that we’ll be using in this chapter, along with their installation commands:</p>
			<ul>
				<li>Express ( <code>npm </code><code>install express</code>)</li>
				<li>Joi ( <code>npm </code><code>install joi</code>)</li>
				<li>mongoose ( <code>npm </code><code>install mongoose</code>)</li>
				<li>dotenv ( <code>npm install </code><code>dotenv –save</code>)</li>
			</ul>
			<p>Here’s what the <code>package.json</code> file’s dependencies and <code>devDependencies</code> look like:</p>
			<pre class="console">
"dependencies": {
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "joi": "^17.12.3",
    "mongoose": "^8.3.2"
  }</pre>			<p>You’ve probably already realized that, when installing our first package, the node automatically generates another file called <code>package-lock.json</code>. Let’s summarize its roles:</p>
			<p>It acts as a lock file, specifying the exact versions of packages and their dependencies that were installed. This guarantees that regardless of who installs the project or on what machine, the same set of versions will be used, leading to consistent behavior.</p>
			<p>By locking down versions, <code>package-lock.json</code> enables developers to reproduce the project’s environment exactly. This is essential for maintaining stability and avoiding unexpected issues during deployments or across different development machines.</p>
			<p>When shared within a team or used in <code>package-lock.json</code> ensures everyone involved is working with the same <a id="_idIndexMarker318"/>dependencies. This streamlines collaboration and automates reliable builds.</p>
			<p>It works in conjunction with <code>package.json</code>. While <code>package.json</code> specifies the desired dependencies <a id="_idIndexMarker319"/>and their version ranges, <code>package-lock.json</code> pins down the exact versions that are used during installation.</p>
			<p>Overall, <code>package-lock.json</code> is important for maintaining consistent and reproducible Node.js project environments across installations and team workflows.</p>
			<p>You may have noticed that we have one more folder: <code>node_modules</code>. In Node.js projects, the  <code>node_modules</code> folder is a special directory that stores all the third-party libraries and dependencies your project relies on. These libraries provide pre-written code for functionalities you don’t need to build from scratch, saving you time and effort.</p>
			<p>Node.js projects often depend on external code from various sources. The <code>node_modules</code> folder keeps all these dependencies organized in one place. Each project can have its own set of dependencies specific to its needs. This way, different projects can use different versions of the same library without conflicts.</p>
			<p>At this point, we have an initial skeleton for our application. So, it’s time to start the actual development process.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Defining the internal architecture of our microservice</h1>
			<p>Imagine that after carefully analyzing, we decided to have a special microservice that’s responsible for working with <a id="_idIndexMarker320"/>account information and we called it the <em class="italic">account microservice</em>. Our account consists of an <em class="italic">ID</em>, <em class="italic">account name</em>, <em class="italic">account type</em>, <em class="italic">account status</em>, and <em class="italic">account number</em>. To track changes, we’re going to add <code>createdAt</code> and <code>updatedAt</code> fields.</p>
			<p>The microservice approach has been applied to our whole project and now we have multiple services. However, the internal design of our concrete microservice depends on the requirements and it’s up to the team regarding which architectural pattern to apply. One of the most popular and classical architectural patterns in software development is <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>). To make things simple and understandable, we will apply it to our microservice design.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor085"/>MVC architectural pattern</h2>
			<p>The MVC architectural <a id="_idIndexMarker321"/>pattern is a popular choice for<a id="_idIndexMarker322"/> structuring Node.js APIs due to its emphasis on separation of concerns.</p>
			<p>It has the following main components:</p>
			<ul>
				<li><strong class="bold">Model</strong>:<ul><li>Represents the<a id="_idIndexMarker323"/> data layer of your API.</li><li>Encapsulates data access logic and interacts with databases (for example, MongoDB, MySQL, and so on).</li><li>Handles data persistence and retrieval.</li></ul></li>
				<li><strong class="bold">View</strong> (not directly used in Node.js APIs):<ul><li>Traditionally <a id="_idIndexMarker324"/>deals with UI presentation in web applications.</li><li>Not directly applicable in Node.js APIs as they are data-centric.</li><li>Note that the concept of <em class="italic">view</em> can be extended to represent the response format (JSON, XML) for the API.</li></ul></li>
				<li><code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>).</li><li>Interacts with the model to fetch or manipulate data based on the request.</li><li>Prepares the response data in the desired format (JSON, XML).</li><li>Returns the response to the client.</li></ul></li>
			</ul>
			<p>But why it is beneficial to use MVC for Node.js APIs?</p>
			<ul>
				<li><strong class="bold">Separation of concerns</strong>: Makes <a id="_idIndexMarker326"/>code more organized and maintainable by dividing functionalities.</li>
				<li><strong class="bold">Improved testability</strong>: Each layer (model, view, and controller) can be tested independently.</li>
				<li><strong class="bold">Flexibility</strong>: Easier to modify or update specific parts of the API without affecting others.</li>
				<li><strong class="bold">Scalability</strong>: Easier to scale the application by adding more controllers or models.</li>
			</ul>
			<p>Now that we have enough<a id="_idIndexMarker327"/> theoretical knowledge about MVC, it’s time to apply it in practice.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Integrating MVC into our Node.js project</h2>
			<p>While Node.js doesn’t have a<a id="_idIndexMarker328"/> built-in MVC framework, popular web frameworks such as <em class="italic">Express.js</em> can be used to implement the pattern. Express.js handles routing (mapping URLs to controllers) and simplifies request-response handling.</p>
			<p>You’ll typically structure your project with separate folders for models and controllers.</p>
			<p>We’ll use the <em class="italic">N-Layered Architecture</em> to structure our code. This architecture is popular because it promotes the separation of concerns, making the application more modular, maintainable, and scalable.</p>
			<p>Since we don’t have complex requirements, getting started with it is a good initial point. Using both MVC and the N-layered architecture in your Node.js Express project can lead to a well-structured and maintainable API. The following are some common layers you’ll encounter:</p>
			<ul>
				<li>Presentation Layer (UI or API)</li>
				<li>Business Logic Layer (core application logic)</li>
				<li>Data Access Layer (interaction with databases)</li>
			</ul>
			<p>The model, representing data and its logic, aligns with the data access layer’s responsibilities. Scripts in the <code>services</code> folder will store our business logic. The controller, which handles<a id="_idIndexMarker329"/> requests and manipulates data, shouldn’t contain any business logic. Instead, it should act as a bridge that forwards the user’s request to the business logic layer.</p>
			<p>Now that we’ve defined a general architecture for our application, we’re ready to focus on the implementation details. Starting from the next section, we’ll implement the functional behaviors of our first microservice.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor087"/>Hands-on account microservice development</h1>
			<p>To start from scratch, let’s create a folder called <code>src</code>. We plan to organize our main application structure<a id="_idIndexMarker330"/> under this folder. This is going to be a data-centric application, so it’s better to start development from the database segment.</p>
			<p>In the end, we plan to build the following project  structure for our application:</p>
			<div><div><img alt="Figure 5.3: The final project structure" src="img/B09148_05_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: The final project structure</p>
			<p>To follow along <a id="_idIndexMarker331"/>with ease, don’t forget to download the source code from our repository.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>Implementing our data-access functionalities</h2>
			<p>We always store data <a id="_idIndexMarker332"/>somewhere. The most used storage for data is a database. The data access that we plan to implement relies on MongoDB and isolates us from the difficulties of querying a database using SQL. It’s like using arrays or lists but under the hood, it interacts with a database.</p>
			<p>To start creating our account microservice, do the following:</p>
			<p>Create a <code>db</code> folder under <code>src</code>.</p>
			<ol>
				<li>Add the <code>index.js</code> file to the <code>db</code> folder.</li>
				<li>First, we need to handle<a id="_idIndexMarker333"/> the database communication process. That’s why our current file (<code>index.js</code>) will serve connection and disconnection functionalities:<pre class="source-code">
const db = require('mongoose');
let mongoUrl;
async function connect({ mongo: { url } }) {
    mongoUrl = url;
    try {
        await db.connect(mongoUrl);
    } catch (err) {
        setTimeout(connect, 8000);
    }
}
const dbConnection = db.connection;
function disconnect() {
    dbConnection.removeAllListeners();
    return db.disconnect();
}
module.exports = {
    connect,
    disconnect,
};</pre><p class="list-inset">We’ve already mentioned the <code>mongoose</code> package. To use packages like this, we have the <code>required</code> command. Node.js automatically handles packages from the <code>node_modules</code> folder without specifying any relative or full path.</p><p class="list-inset">Here, we’ve implemented<a id="_idIndexMarker334"/> two main functionalities. They mostly act as wrappers over existing functionalities:</p><ul><li>The <code>connect</code> function tries to connect to the given database. In case of errors, we have one more attempt to try to connect to the database after <code>8</code> seconds. It is up to you to configure this but having a connection attempt after an unsuccessful operation makes sense.</li><li>The <code>disconnect</code> function handles the disconnection case. Here, we’re removing all listeners of our database via <code>db.disconnect()</code> manually.</li></ul><p class="list-inset">Node.js has a file-based module approach. This means that every file, by itself, can be treated as a module and other modules can use it to build more complex modules. One of the ways you can make some functionalities of your module accessible to others is by using <code>exports</code>. You should only provide the required functions with the following proper encapsulation. If some of your functions are used by other functions in the same module and they are not part of your module’s contract, it’s better not to specify them in the <code>exports</code> list. In our case, we have two functions – <code>connect</code> and <code>disconnect</code> – that we’re providing outside to be consumed by other modules.</p></li>			</ol>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>Implementing the M in MVC</h2>
			<p>In our project, the <a id="_idIndexMarker335"/>responsibility of models is to act as a data access layer. This layer covers the main operations, such as <code>INSERT</code>, <code>UPDATE</code>, <code>SELECT</code>, and <code>DELETE</code>. We have <code>account.js</code> under the <code>src/models</code> folder; this is where all the database-related functionalities live. Here’s what it looks like:</p>
			<pre class="source-code">
const mongoose = require('mongoose');
const { Schema } = mongoose;
const AccountSchema = new Schema(
    {
        name: {
            type: String,
            required: true,
        },
        number: {
            type: String,
            required: true,
        },
        type: {
            type: String,
            enum: ['root', 'sub'],
            default: 'root',
        },
        status: {
            type: String,
            enum: ['new', 'active', 'inactive', 'blocked'],
            default: 'new',
        },
        createdAt: {
            type: Date,
            default: Date.now,
        },
        updatedAt: Date,
    },
    { optimisticConcurrency: true },
);
module.exports = mongoose.model('account', AccountSchema);</pre>			<p>Let’s walk through<a id="_idIndexMarker336"/> this code:</p>
			<ul>
				<li><code>const mongoose = require('mongoose');</code>: This line imports the Mongoose library, which is used for interacting with MongoDB databases in Node.js.</li>
				<li><code>const { Schema } = mongoose;</code>: This line uses destructuring to extract the <code>Schema</code> class from the <code>mongoose</code> object. This makes the code more concise and easier to read.</li>
				<li><code>new Schema({ ... })</code>: This line creates a new Mongoose schema object. The object that’s passed as an argument defines the structure of the documents that will be stored in the account collection within your MongoDB database. Within the curly braces, <code>{}</code>, you define the properties (fields) of each document in the collection. Here’s a breakdown of each property:<ul><li><code>name</code>:<ul><li><code>type: String</code>: This specifies that the <code>name</code> property should be a string.</li><li><code>required: true</code>: This makes the <code>name</code> property mandatory. A document cannot be saved without a value for the name.</li></ul></li><li><code>number</code>: Similar to <code>name</code>, but also required.</li><li><code>type</code>:<ul><li><code>type: String:</code> The <code>status</code> property is a string.</li><li><code>enum: ['new', 'active', 'inactive', 'blocked']</code>: Similar to <code>type</code>, this defines a list of allowed values for the status: <code>'new'</code>, <code>'active'</code>, <code>'inactive'</code>, or <code>'blocked'</code>.</li><li><code>default: 'new'</code>: If no status is specified, it will default to <code>'new'</code>.</li></ul></li><li><code>createdAt</code>:<ul><li><code>type: Date</code>: This property stores the date and time the document was created using the current time (<code>Date.now</code>).</li></ul></li><li><code>updatedAt</code>:<ul><li><code>type: Date:</code> This property is intended to store the date and time the document was last updated. However, it’s not explicitly set to a default value here. You’ll likely need to update this field manually in your application logic.</li></ul></li><li><code>  { optimisticConcurrency: true }</code>: This option is used for optimistic<a id="_idIndexMarker337"/> concurrency control, which is a mechanism that helps prevent data inconsistencies during updates (<a href="https://mongoosejs.com/docs/guide.html#optimisticConcurrency">https://mongoosejs.com/docs/guide.html#optimisticConcurrency</a>).</li></ul></li>
				<li><code>module.exports = mongoose.model('account', AccountSchema);</code>: This line creates a Mongoose model named <code>account</code> based on your defined <code>AccountSchema</code>. The model acts as a blueprint for interacting with <code>account</code> documents in your MongoDB database. By exporting the model, you make it available for use in other parts of your Node.js application.</li>
			</ul>
			<p>Long story short, this code sets up a Mongoose schema for storing account information in a MongoDB collection. It defines properties such as <code>name</code>, <code>number</code>, <code>type</code>, <code>status</code>, <code>creation time</code>, and <code>last update time</code>, with validation rules and defaults. The code then exports a model that allows you to create, read, update, and delete account documents in your <a id="_idIndexMarker338"/>database.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Storing configuration</h2>
			<p>We need to store application-based configuration somewhere. For the current situation, we need MongoDB URL and port information. It isn’t a good idea to hard-code this information directly into your <a id="_idIndexMarker339"/>code because of maintainability, reusability, and extensibility. Instead, we prefer to store it in a separate file. That’s why we’ve installed the <code>dotenv</code> package.</p>
			<p>The <code>dotenv</code> package in Node.js helps you manage environment variables for your project. It offers a way to store configuration settings, such as API keys or database credentials, outside of your code in a <code>.env</code> file. This improves security by keeping sensitive data out of your codebase.</p>
			<p>Why use <code>dotenv</code>?</p>
			<ul>
				<li><strong class="bold">Security</strong>: It keeps sensitive <a id="_idIndexMarker340"/>data out of your code base, reducing the risk of accidental exposure</li>
				<li><strong class="bold">Separation of concerns</strong>: It separates configuration from code, making your code cleaner and easier to manage</li>
				<li><code>.env</code> files for different environments (development, staging, and production) with specific configurations for each</li>
			</ul>
			<p>The <code>.env</code> file itself shouldn’t be included in version control systems such as Git to avoid committing sensitive information. We can create a <code>.env.example</code> file with placeholder values to guide developers on how to set up their environment variables. However, for this book, we will include the .<code>env</code> file in our Git repository as is, to facilitate the learning process.</p>
			<p>We have the <code>configs</code> folder under the <code>Ch05</code> folder. It is a root-level folder and contains a <code>.env</code> file without a name. Here’s its content:</p>
			<pre class="console">
PORT=3001
MONGODB_URL=mongodb://localhost:27017/account-microservice</pre>			<p>We need to validate and create a configuration object based on the configuration we’ve looked at. That’s why we<a id="_idIndexMarker341"/> need one more folder called <code>config</code> under the <code>src</code> folder. So, let’s create <code>config.js</code> with the following content:</p>
			<pre class="source-code">
const dotenv = require('dotenv');
const Joi = require('joi');
const envVarsSchema = Joi.object()
    .keys({
        PORT: Joi.number().default(3000),
        MONGODB_URL: Joi.string().required().description('Mongo DB url')
    })
    .unknown();
function createConfig(configPath) {
    dotenv.config({ path: configPath });
    const { value: envVars, error } = envVarsSchema
        .prefs({ errors: { label: 'key' } })
        .validate(process.env);
    if (error) {
        throw new Error(`Config validation error: ${error.message}`);
    }
    return {
        port: envVars.PORT,
        mongo: {
            url: envVars.MONGODB_URL,
        }
    };
}
module.exports = {
    createConfig,
};</pre>			<p>Using the <code>createConfig</code> function, we’re able to read <a id="_idIndexMarker342"/>and build config objects.</p>
			<p>There are a lot of packages out there that can be used for data validation. We prefer to use Joi because it’s popular and easy to use. Joi is a popular open source package that provides a declarative way to define data schemas and perform validation against those schemas.</p>
			<p>it allows you to<a id="_idIndexMarker343"/> create JavaScript objects that represent the expected structure and data types for your application’s inputs (request body, query parameters, and so on).</p>
			<p>It offers a wide range of validation rules for common data types such as strings, numbers, arrays, and objects. You can define rules for presence, format, length, and more.</p>
			<p>It integrates seamlessly with Express.js middleware, allowing you to validate data directly within your route handlers.</p>
			<p>By separating validation logic from your route handlers, your code becomes cleaner and easier to understand.</p>
			<p>Overall, Joi is a valuable tool for building robust and secure Node.js applications. By incorporating data validation with Joi, you can ensure that your application receives clean, reliable data, leading to a more stable and secure development experience.</p>
			<p>We’ll be using it in our<a id="_idIndexMarker344"/> application entry point (<code>src/index.js</code>).</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Implementing the business layer</h2>
			<p>The business layer is the heart of an N-layered architecture. It’s responsible for the core functionality of the application and implements the specific business rules that govern how the application operates. It <a id="_idIndexMarker345"/>translates user requests into actions and decisions based on the business rules. It also determines how data should be processed, validated, and manipulated to fulfill those requests. Furthermore, it acts as an intermediary between the presentation layer (user interface) and the data access layer (database). It receives data requests from the presentation layer, retrieves the necessary data from the data access layer, and then applies business logic before returning the processed data.</p>
			<p>By separating business logic from the presentation and data access layers, the business layer promotes loose coupling and reusability. This makes the application easier to maintain, test, and modify as business needs evolve.</p>
			<p>We have a <code>services</code> folder under <code>src</code> to physically locate service functionalities. We mostly have five functions in <code>account.js</code> to cover the main operations related to CRUD: <code>getAccountById</code>, <code>getAllAccounts</code>, <code>createAccount</code>, <code>deleteAccountById</code>, and <code>updateAccountById</code>. Let’s look at the first four here:</p>
			<pre class="source-code">
const Account = require('../models/account');
//get account info by id
function getAccountById(id) {
    return Account.findById(id);
}
//get all account information
function getAllAccounts() {
    return Account.find({});
}
//create account based on name,number,type and status
function createAccount(name, number, type, status) {
    return Account.create({ number, name, type, status });
}
//delete account by account id
async function deleteAccountById(id) {
    const deletedAccount = await Account.findByIdAndDelete(id);
    if(deletedAccount)
     return true;
     else
     return false;
 }</pre>			<p>The first four functions are easy to understand. Using <code>require</code>, we import our account from models. Then, we<a id="_idIndexMarker346"/> wrap our data access operations with business functions. The biggest function in this module is <code>updateAccountById</code>. Let’s take a closer look:</p>
			<pre class="source-code">
//'new', 'active', 'inactive', 'blocked'
const availableAccountStatusesForUpdate = {
    new: ['active', 'blocked'],
    active: ['inactive', 'blocked'],
    inactive: ['active'],
    blocked: ['active'],
};
//'root', 'sub'
const availableAccountTypesForUpdate = {
    root: ['sub'],
    sub: ['root'],
};
const NO_VALID_DATA_TO_UPDATE = 0;
const INVALID_STATUS_CODE = 1;
const INVALID_TYPE_CODE = 2;
const INVALID_ACCOUNT = 3;
const INVALID_STATE_TRANSITION = 4;
const INVALID_TYPE_TRANSITION = 5;
async function updateAccountById(id, { name, number, type, status }) {
    if (!name &amp;&amp; !number &amp;&amp; !type &amp;&amp; !status) {
        return { error: 'provide at least one valid data to be 
          updated', code: NO_VALID_DATA_TO_UPDATE };
    }
    if (status &amp;&amp; !(status in availableAccountStatusesForUpdate)) {
        return { error: 'invalid status for account', code: INVALID_
          STATUS_CODE };
    }
    if (type &amp;&amp; !(type in availableAccountTypesForUpdate)) {
        return { error: 'invalid type for account', code: INVALID_
          TYPE_CODE };
    }
    const account = await Account.findById(id);
    if (!account) {
        return { error: 'account not found', code: INVALID_ACCOUNT };
    }
    //check for available status and transition
    if (status) {
    const allowedStatuses = 
        availableAccountStatusesForUpdate[
            account.status];
        if (!allowedStatuses.includes(status)) {
            return {
                error: `cannot update status from '${account.status}' 
                  to '${status}'`,
                code: INVALID_STATE_TRANSITION,
            };
        }
    }
    //check for available type and transition
    if (type) {
        const allowedTypes = availableAccountTypesForUpdate[account
          .type];
        if (!allowedTypes.includes(type)) {
            return {
                error: `cannot update type from '${account.type}' to 
                  '${type}'`,
                code: INVALID_TYPE_TRANSITION,
            };
        }
    }
    account.status = status ?? account.status;
    account.type = type ?? account.type;
    account.name = name ?? account.name;
    account.number = number ?? account.number;
    account.updatedAt = Date.now();
    await account.save();
    return account;
}</pre>			<p>In the end, we need to export the required code blocks so that they can be used by other<a id="_idIndexMarker347"/> services:</p>
			<pre class="source-code">
module.exports = {
    getAccountById,
    getAllAccounts,
    createAccount,
    updateAccountById,
    deleteAccountById,
    errorCodes: {
        NO_VALID_DATA_TO_UPDATE,
        INVALID_STATUS_CODE,
        INVALID_TYPE_CODE,
        INVALID_ACCOUNT,
        INVALID_STATE_TRANSITION,
        INVALID_TYPE_TRANSITION,
    },
};</pre>			<p>We have the following checks before updating our account information:</p>
			<ul>
				<li>Only allow an update to occur if one of the fields is provided.</li>
				<li>Return an error if an invalid status code is provided.</li>
				<li>Return an error if an invalid type is provided.</li>
				<li>If the account for the given ID doesn’t exist, we need to return the error.</li>
			</ul>
			<p>We have some rules to update the status. First, <code>availableAccountStatusesForUpdate</code> describes the rules: if the status is <code>new</code>, then it can be updated to <code>active</code> or <code>blocked</code>. For <code>active</code>, it is possible to update to <code>inactive</code> and <code>blocked</code>. If the status is <code>inactive</code>, then only <code>active</code> is allowed. The <code>blocked</code> status can only be transitioned to <code>active</code>.</p>
			<p>These are not all the <a id="_idIndexMarker348"/>possible validations you can implement, but they show how you can apply check logic to update functionality. In the end, we expose functions with error codes outside to be used by the preceding layer.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>Implementing the controller</h2>
			<p>In a Node.js project using the MVC pattern, the controller acts as the central nervous system, handling user requests and coordinating the application’s response. It is the first point of contact for incoming<a id="_idIndexMarker349"/> requests from the user. It interprets the URL, HTTP method (<code>GET</code>, <code>POST</code>, and so on), and any parameters included in the request. The controller, by its nature, doesn’t implement the business logic itself; instead, it directs the flow of the application based on the request. It might interact with the model to retrieve or manipulate data, or it could perform some basic validation or processing before moving on.</p>
			<p>The controller interacts with the model to get the data needed to fulfill the user’s request. This could involve fetching data from a database, performing calculations, or any other operations defined in the model layer.</p>
			<p>Once the controller has the data or has processed the request, it selects the appropriate view to render the response for the classical UI application. It might also prepare the data so that it can be consumed by the view, such as formatting it into a specific template. In our case, we don’t have a complete UI, and our JSON representation of data acts as a UI for us.</p>
			<p>Finally, the controller generates the response that gets sent back to the user. This could be an HTML page, JSON data for an API, or any other format suitable for the request.</p>
			<p>In essence, the controller acts as a middleman, managing the communication flow between the user (through the view) and the data layer (through the model). It keeps the view and model separate, promoting cleaner code and easier maintenance.</p>
			<p>To implement a controller mechanism in our project, we need to create a folder called <code>controllers</code> under the <code>src</code> folder and add a new JavaScript file called <code>account.js</code>:</p>
			<pre class="source-code">
const accountService = require('../services/account');
const getAccounts = async (req, res) =&gt; {
    const result = await accountService.getAllAccounts();
    res.status(200).json({ success: true, account: result.map(x =&gt; 
      mapToResponse(x)) });
};
const createAccount = async (req, res) =&gt; {
    const { name, number, type, status } = req.body;
    const result = await accountService.createAccount(name, number, 
      type, status);
    res.status(201).json({
        success: true,
        Account: mapToResponse(result),
    });
};
const deleteAccountById = async (req, res) =&gt; {
    const isDeleted = await accountService.deleteAccountById(req
      .params.id);
    if(isDeleted)
     res.status(204).json({
         success: true
     });
     else
     res.status(400).json({ success: false, message: 'No valid data to 
       delete' });
 };</pre>			<p>Things are straightforward when it comes to implementing retrieve (get), create, and delete accounts. However, we should consider some additional factors when we update our account information:</p>
			<p>First, <code>getAccounts</code> calls the <code>getallAcccounts</code> service function and returns <code>200</code> responses.</p>
			<p>Then, <code>createAccount</code> calls the same named function from the service and returns <code>201</code>, which means the<a id="_idIndexMarker350"/> resource has been created.</p>
			<p>Finally, <code>deleteAccountById</code> calls the same named function from the service and returns <code>204</code>, which means success with no content. If the delete operation fails, it will return a <code>400</code> status code.</p>
			<p>Next, let’s take a look at the update implementation:</p>
			<pre class="source-code">
const updateAccountById = async (req, res) =&gt; {
    const result = await accountService.updateAccountById(
      req.params.id, req.body);
    if (result.error) {
        switch (result.code) {
            case accountService.errorCodes.NO_VALID_DATA_TO_UPDATE:
                res.status(400).json({ success: false, message: 
                  result.error });
                return;
            case accountService.errorCodes.INVALID_STATUS_CODE:
                res.status(400).json({ success: false, message: 
                  'invalid status' });
                return;
            case accountService.errorCodes.INVALID_TYPE_CODE:
                res.status(400).json({ success: false, message: 
                  'invalid type' });
                return;
            case accountService.errorCodes.INVALID_ACCOUNT:
                res.status(404).json({ success: false, message: 
                  'Account not found' });
                return;
            case accountService.errorCodes.INVALID_STATE_TRANSITION:
                res.status(400).json({ success: false, message: 
                  result.error });
                return;
            case accountService.errorCodes.INVALID_TYPE_TRANSITION:
                res.status(400).json({ success: false, message: 
                  result.error });
                return;
            default:
                res.status(500).json({ success: false, message: 
                  'internal server error' });
                return;
        }
    }
    res.status(200).json({
        success: true,
        Account: mapToResponse(result),
    });
};</pre>			<p>Here, <code>updateAccountById</code> has a few more lines of code. Based on exported error codes, it prepares different HTTP status codes. If the provided data is valid, it returns a <code>200</code> success code.</p>
			<p>We also have a simple<a id="_idIndexMarker351"/> function called <code>mapToResponse</code>. In Node.js, <code>mapToResponse</code> serves as a utility function to transform or map an account object to a specific format or structure that’s suitable for sending as a response, typically in an API. Here’s what it looks like:</p>
			<pre class="source-code">
function mapToResponse(account) {
    const {
        id, name, number, type, status,
    } = account;
    return {
        id,
        name,
        number,
        type,
        status
    };
}
module.exports = {
    getAccountById,
    getAccounts,
    createAccount,
    deleteAccountById,
    updateAccountById,
};</pre>			<p>The only additional <code>private</code> function that we haven’t exported is <code>mapToResponse</code>. As you know, the user <a id="_idIndexMarker352"/>may not need to retrieve the whole account data structure. Using this function, we only return the required fields to the user as a response.</p>
			<p>The final piece of code is retrieving the account by ID (<code>getAccountById</code>):</p>
			<pre class="source-code">
const accountService = require('../services/account');
const getAccountById = async (req, res) =&gt; {
    const result = await accountService.getAccountById(req.params.id);
    if (result) {
        res.status(200).json({ success: true, account:
          mapToResponse(result) });
    } else {
        res.status(404).json({ success: false, message: 'Account not 
          found' });
    }
};</pre>			<p>Here, <code>getAccountById</code> redirects the query to the appropriate service and, based on the service’s response, returns a success or not found message.</p>
			<p>In the end, to use the main controller functions in the routing process, we must export them.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>Simple data validation for your API</h2>
			<p>Unvalidated data can lead to unexpected behavior, errors, and security vulnerabilities. Validation helps ensure <a id="_idIndexMarker353"/>that data received from users or external sources conforms to your application’s expectations.</p>
			<p>Malicious users might try to inject invalid or unexpected data into your application. Validation helps prevent these attacks by rejecting data that doesn’t adhere to the defined rules.</p>
			<p>By defining validation rules upfront, you can catch errors early in the development process, reducing debugging time and improving code maintainability.</p>
			<p>Let’s create a validation folder under <code>src</code> with the <code>account.js</code> file that contains the following lines of code:</p>
			<pre class="source-code">
const Joi = require('joi');
const objectId = Joi.string().regex(/^[0-9a-fA-F]{24}$/);
const getAccountById = {
  params: Joi.object().keys({
    id: objectId.required(),
  }),
};
const deleteAccountById = {
  params: Joi.object().keys({
    id: objectId.required(),
  }),
};
const createAccount = {
  body: Joi.object().keys({
    name: Joi.string().required(),
    number: Joi.string().required(),
    status: Joi.string().valid('new', 'active', 'completed', 
      'cancelled').optional(),
    type: Joi.string().valid('root', 'sub').optional(),
  }),
};</pre>			<p>Let’s take a closer<a id="_idIndexMarker354"/> look at the code:</p>
			<ul>
				<li>After installing the <code>Joi</code> package, it is enough to specify it in the <code>require</code> command.</li>
				<li>The regular expression defines a rule to validate the ID. We’ll use this ID for <code>GET</code>, <code>PUT</code>, and <code>DELETE</code> operations.</li>
				<li><code>const createAccount = { ... }</code>: This line declares a constant variable named <code>createAccount</code> and assigns an object literal to it. This object will hold the validation schema for creating an account.</li>
				<li><code>body</code>: This property name specifies that the validation schema applies to the request body (typically, data sent in the body of a <code>POST</code> request).</li>
				<li><code>Joi.object()</code>: This creates a Joi object schema that validates the structure (presence of specific properties) of the request body.</li>
				<li><code>.keys({ ... })</code>: This defines the set of properties to be expected in the request body and their corresponding validation rules.</li>
				<li><code>name: Joi.string().required()</code>: This validates the presence of a property named <code>name</code> and ensures it’s a string value. The <code>.required()</code> part makes it mandatory.</li>
				<li><code>number: Joi.string().required()</code>: Similar to <code>name</code>, this validates a required string property named <code>number</code>.</li>
				<li><code>status: Joi.string().valid('new', 'active', 'completed', 'cancelled').optional()</code>: This validates an optional string property named <code>status</code>. The <code>.valid()</code> method restricts the allowed values to <code>'new'</code>, <code>'active'</code>, <code>'completed'</code>, and <code>'cancelled'</code>.</li>
				<li><code>type: Joi.string().valid('root', 'sub').optional()</code>: Similar to <code>status</code>, this validates an optional string property named <code>type</code> with allowed values of <code>'root'</code> and <code>'sub'</code>.</li>
				<li>In general, the preceding code ensures that a request to create an account must include the<a id="_idIndexMarker355"/> following properties:<ul><li><code>name</code>: Required string value</li><li><code>number</code>: Required string value</li><li><code>status</code>: An optional string value that is either <code>'new'</code>, <code>'active'</code>, <code>'completed'</code>, or <code>'cancelled'</code></li><li><code>type</code>: An optional string value that is either <code>'root'</code> or <code>'sub'</code></li></ul></li>
			</ul>
			<p>By using this schema, you can guarantee that the data that’s received for creating an account adheres to the expected format and prevents unexpected or invalid data from entering your application:</p>
			<pre class="source-code">
const updateAccountById = {
  params: Joi.object().keys({
    id: objectId.required(),
  }),
  body: Joi.object().keys({
    name: Joi.string().required(),
    number: Joi.string().required(),
    status: Joi.string().valid('new', 'active', 'completed', 
      'cancelled').optional(),
    type: Joi.string().valid('root', 'sub').optional(),
  }),
};
module.exports = {
  getAccountById,
  createAccount,
  deleteAccountById,
  updateAccountById,
};</pre>			<p>The <code>updateAccountById</code> object specifies that the parameters must include an <code>id</code> parameter, which is required and must be a valid object ID. The <code>body</code> part of the request must contain <code>name</code> and <code>number</code> fields, both of which are required strings, and optionally a <code>status</code> field that can only be one of the specified values <code>('new'</code>, <code>'active'</code>, <code>'completed'</code>, or <code>'cancelled'</code>) and a <code>type</code> field that can be either <code>'root'</code> or <code>'sub'</code>. This <a id="_idIndexMarker356"/>validation ensures that incoming requests to update an account adhere to the expected format and data types. In the end, to use these rules, we need to export them using <code>module.exports</code>.</p>
			<p>We have another module related to data validation that’s placed in the <code>middleware</code> folder under the <code>src</code> folder. <code>validate.js</code> file with the following content:</p>
			<pre class="source-code">
const Joi = require('joi');
function take(object, keys) {
    return Object.assign({}, ...keys
        .filter(key =&gt; object.hasOwnProperty(key))
        .map(key =&gt; ({ [key]: object[key] })));
}
function validate(schema) {
    return (req, res, next) =&gt; {
        // Extract relevant parts of the schema based on request type
        const selectedSchema = take(schema, ['params', 'query', 
          'body']);
        const objectToValidate = take(req, 
          Object.keys(selectedSchema));
        // Perform Joi validation with improved error handling
        const { error, value } = Joi.compile(selectedSchema)
            .prefs({ errors: { label: 'key' }, abortEarly: false })
            .validate(objectToValidate);
        if (error) {
            const errorMsg = error.details.map(d =&gt; d.message).join(', 
              ');
            return res.status(400).json({ success: false, message: 
              errorMsg });
        }
        // Attach validated data to the request object
        Object.assign(req, value);
        next();
    };
}</pre>			<p>If an error exists, the middleware extracts individual error messages using <code>error.details.map(...)</code> and joins them into a comma-separated string (<code>errorMessage</code>). A <code>400 Bad Request</code> response is sent with the error message in JSON format.</p>
			<p>If validation passes (<code>!error</code>), the validated data (value) obtained from Joi is attached to the <code>req</code> object <a id="_idIndexMarker359"/>using <code>Object.assign</code>. This makes the validated data readily available in subsequent route handlers.</p>
			<p>This middleware acts as a gatekeeper for your routes, ensuring that incoming requests adhere to the provided validation schema.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>Implementing routing</h2>
			<p><strong class="bold">Routing</strong> is a fundamental <a id="_idIndexMarker360"/>aspect of building<a id="_idIndexMarker361"/> web applications with Node.js and Express. It essentially directs incoming HTTP requests to the appropriate handlers within your application.</p>
			<p>Routing allows you to define a clear separation between URLs (endpoints) and the code that handles them. This promotes modularity and makes your code base more readable and manageable.</p>
			<p>It also enables you to define handlers specific to each HTTP method for a particular URL. This allows you to handle requests for retrieving data (<code>GET</code>), submitting data (<code>POST</code>), updating data (<code>PUT</code>), or deleting data (<code>DELETE</code>) appropriately.</p>
			<p>By defining routes that map to resources and corresponding HTTP methods, you can establish a well-structured and predictable API that other applications can interact with.</p>
			<p>As your application evolves, routing <a id="_idIndexMarker362"/>helps you easily add new features and functionalities.</p>
			<p>You can create separate route handlers for new features, keeping your code base organized and scalable.</p>
			<p>Routing also allows you to <a id="_idIndexMarker363"/>group related routes, promoting the reusability of code across different parts of your application.</p>
			<p>In simpler terms, routing acts like a traffic controller for your application, directing incoming requests to the designated destinations (handlers) based on their URLs and HTTP methods. This keeps your code organized and maintainable and enables you to build robust and scalable web applications and APIs.</p>
			<p>We have a <code>routes</code> folder under the <code>src</code> folder where we define all the routing rules for our application. Currently, it is our first version, so the <code>v1</code> folder indicates the first version of our API. <strong class="bold">Versioning</strong> allows <a id="_idIndexMarker364"/>you to introduce changes while maintaining compatibility with existing clients.</p>
			<p>Let’s add the <code>accounts</code> folder and the <code>index.js</code> file to our <code>v1</code> folder and define our routing rules.</p>
			<p>The full path to the file will be <code>src/routers/v1/accounts/index.js</code>:</p>
			<pre class="source-code">
const { Router } = require('express');
const accountController = require('../../../controllers/account');
const accountValidation = require('../../../validation/account');
const validate = require('../../../middlewares/validate');
const router = Router();
router.get('/', accountController.getAccounts);
router.get('/:id',
  validate(accountValidation.getAccountById),
  accountController.getAccountById);
router.post('/',
  validate(accountValidation.createAccount),
  accountController.createAccount);
router.put('/:id',
  validate(accountValidation.updateAccountById),
  accountController.updateAccountById);
router.delete('/:id',
  validate(accountValidation.deleteAccountById),
  accountController.deleteAccountById);
module.exports = router;</pre>			<p>Express.js provides routing functionality. Using it, we’ve defined the following:</p>
			<ul>
				<li>Users can <em class="italic">get</em> an account by ID using <code>/accounts/:id</code></li>
				<li>Users can <em class="italic">create</em> a <a id="_idIndexMarker365"/>new account by sending a <code>POST</code> request to <code>/accounts</code></li>
				<li>Users can <em class="italic">update</em> an account by ID sending a <code>PUT</code> request to <code>/accounts/:id</code></li>
				<li>Users can <em class="italic">delete</em> an account by ID sending a <code>DELETE</code> request to <code>/accounts/:id</code></li>
			</ul>
			<p>The validation middleware ensures that requests adhere to the expected format before reaching the controller functions, which handle the actual account management logic.</p>
			<p>As you might have guessed, we don’t have any indicator for our route to be used with the <code>/</code><code>accounts</code> prefix.</p>
			<p>We need one more JavaScript file to handle this. Let’s create <code>index.js</code> under the <code>routes/v1</code> folder with<a id="_idIndexMarker366"/> the following implementation:</p>
			<pre class="source-code">
const { Router } = require('express');
const accountRouter = require('./accounts');
const router = Router();
router.use('/accounts', accountRouter);
module.exports = router;
module.exports = router;</pre>			<p>Now, we’ll be able to<a id="_idIndexMarker367"/> navigate to our resource using the <code>/</code><code>accounts</code> prefix.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Constructing our web application</h2>
			<p>Now, it’s time to define our <a id="_idIndexMarker368"/>basic structure for a Node.js application using the Express.js framework.</p>
			<p>Let’s create an <code>app.js</code> file under the <code>src</code> folder with the following code structure:</p>
			<pre class="source-code">
const express = require('express');
const v1 = require('./routes/v1');
const app = express();
// service
app.use(express.json());
// V1 API
app.use('/v1', v1);
module.exports = app;</pre>			<p>This code snippet defines a<a id="_idIndexMarker369"/> basic structure for building our web application:</p>
			<ul>
				<li><code>const express = require('express');</code>: This line imports the Express.js framework, providing functionalities for building web servers and handling HTTP requests and responses.</li>
				<li><code>const v1 = require('./routes/v1');</code>: This line imports a module named <code>v1.js</code> located in a folder named <code>routes/v1</code>. This module defines routes (URL paths) for version 1 of your application’s API.</li>
				<li><code>const app = express();</code>: This line creates an instance of the Express application using the <code>express()</code> function. This <code>app</code> object will be used to define routes and middleware, as well as handle application logic.</li>
				<li><code>.use(express.json())</code>: This line registers a middleware function with the Express application. The <code>express.json()</code> middleware parses incoming JSON data in request bodies, making it accessible in your route handlers.</li>
				<li><code>.use('/v1', v1);</code>: This line is crucial for routing. It mounts the routes defined in the imported <code>v1</code> module onto the <code>/v1</code> path of your application. Any requests to URLs starting with <code>/v1</code> will be handled by the functions in the <code>v1</code> module.</li>
				<li><code>module.exports = app;</code>: This line exports the <code>app</code> object, which is the core of your Express application. This allows other modules in your project to import and use this application instance.</li>
			</ul>
			<p>In essence, this code creates an Express application, configures middleware for JSON handling, mounts routes<a id="_idIndexMarker370"/> from a separate module for version 1 of your API, and makes the application instance available for import by other parts of your project.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Combining all the elements</h2>
			<p>The final step in our <a id="_idIndexMarker371"/>application is to construct everything together, like using Lego. This Lego is going to be a main runnable application that will help us to communicate between elements of our application.</p>
			<p>Let’s create an <code>index.js</code> file under the <code>src</code> folder that contains the following code:</p>
			<pre class="source-code">
const path = require('path');
const db = require('./db');
const app = require('./app');
const { createConfig } = require('./config/config');
async function execute() {
    const configPath = path.join(__dirname, '../configs/.env');
    const appConfig = createConfig(configPath);
    await db.connect(appConfig);
    const server = app.listen(appConfig.port, () =&gt; {
        console.log('account service started', { port: appConfig.port 
          });
    });
    const closeServer = () =&gt; {
        if (server) {
            server.close(() =&gt; {
                console.log('server closed');
                process.exit(1);
            });
        } else {
            process.exit(1);
        }
    };
    const unexpectedError = (error) =&gt; {
        console.log('unhandled error', { error });
        closeServer();
    };
    process.on('uncaughtException', unexpectedError);
    process.on('unhandledRejection', unexpectedError);
}
execute();</pre>			<p>This Node.js code defines <a id="_idIndexMarker372"/>an asynchronous function named <code>execute</code> that serves as the entry point for your application. Here’s a breakdown of its functionality:</p>
			<ul>
				<li><code>const path = require('path');</code>: Imports the <code>path</code> module for manipulating file paths</li><li><code>const db = require('./db');</code>: Imports the <code>db</code> module, likely containing functions for connecting and interacting with your database</li><li><code>const app = require('./app');</code>: Imports the main application module, likely containing the Express application instance and your application logic</li><li><code>const { createConfig } = require('./config/config');</code>: Imports the <code>createConfig</code> function from the <code>config/config.js</code> module, likely responsible for creating your application configuration</li></ul></li>
				<li><code>async function execute() { ... }</code>: Defines an asynchronous function named <code>execute</code> that will be executed when the script starts</li><li><code>const configPath = path.join(__dirname, '../configs/.env');</code>: Uses the <code>path</code> module to construct the absolute path to your configuration file (likely a <code>.env</code> file) two directories above the <a id="_idIndexMarker373"/>current script’s location</li><li><code>const appConfig = createConfig(configPath);</code>: Calls the imported <code>createConfig</code> function with the configuration file path, presumably to read and parse the configuration settings</li></ul></li>
				<li><code>await db.connect(appConfig);</code>: Attempts to connect to the database using the <code>db</code> module and the loaded configuration (<code>appConfig</code>) object. This line is asynchronous, so the function waits for the connection to be established before proceeding.</li></ul></li>
				<li><code>const server = app.listen(appConfig.port, ...);</code>: Calls a method (likely <code>listen</code>) on the imported <code>app</code> object, which is probably an Express application. This starts the server listening on the port specified in the configuration (<code>appConfig.port</code>). The callback function logs a message when the server starts successfully.</li></ul></li>
				<li><code>const closeServer = () =&gt; { ... }</code>: Defines an arrow function named <code>closeServer</code> that gracefully shuts down the server. It checks whether the server object exists and then calls its <code>close</code> method. The callback function for <code>close</code> logs a message when the server is closed and exits the <a id="_idIndexMarker374"/>process with an exit code of <code>1</code>.</li></ul></li>
				<li><code>const unexpectedError = (error) =&gt; { ... }</code>: Defines an arrow function named <code>unexpectedErrorHandler</code> that handles uncaught errors or unhandled promise rejections. It logs the error message. It calls the <code>closeServer</code> function to gracefully shut down the server</li></ul></li>
				<li><code>process.on('uncaughtException', unexpectedError);</code>: Attaches the <code>unexpectedErrorHandler</code> function to the <code>uncaughtException</code> event of the <code>process</code> object. This ensures that any errors thrown outside of an <code>async</code> function or promise chain are caught and handled.</li><li><code>process.on('unhandledRejection', unexpectedError);</code>: Attaches the <code>unexpectedErrorHandler</code> function to the <code>unhandledRejection</code> event of the <code>process</code> object. This ensures that any unhandled rejections from promises are caught and handled.</li></ul></li>
				<li><code>execute();</code>: Calls the <code>execute</code> function to start the application. Since <code>execute</code> is asynchronous, the entire application startup process becomes asynchronous, ensuring<a id="_idIndexMarker375"/> the database connection and server startup are completed before the application continues.</li></ul></li>
			</ul>
			<p>In summary, this code sets up the application configuration, connects to the database, starts the server, and implements error handling for a robust and graceful startup and shutdown process.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>Running and testing our first microservice</h1>
			<p>We’re not going to write any unit or integrate tests in this chapter. In <a href="B09148_11.xhtml#_idTextAnchor174"><em class="italic">Chapter 11</em></a>, where we’ll dive into the<a id="_idIndexMarker376"/> details of those topics. For this chapter, we’ll do manual testing via Postman. To run our <a id="_idIndexMarker377"/>application, follow these steps:</p>
			<ol>
				<li>Download <code>Ch05</code> from our GitHub repository.</li>
				<li>Open the project (<code>Ch05</code>) via Visual Studio Code.</li>
				<li>Go to <strong class="bold">Terminal</strong> | <strong class="bold">New Terminal</strong>.</li>
				<li>Run the <code>npm install</code> command from the <code>Ch05</code> folder to load the required packages.</li>
				<li>Change directories to <code>src</code> (using the <code>cd </code><code>src</code> command).</li>
				<li>Run the <code>node index.js</code> command. Mongo should be installed before you run this command. Check out <a href="B09148_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a> for more information about the installation process for<a id="_idIndexMarker378"/> Mongo.</li>
				<li>Open Postman.</li>
			</ol>
			<p>In the next few <a id="_idIndexMarker379"/>subsections, we’ll test our endpoints one by one.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Creating a new account</h2>
			<p>To create a new account, follow<a id="_idIndexMarker380"/> these steps:</p>
			<ol>
				<li>Create a new tab in Postman.</li>
				<li>Select <code>POST</code> from <strong class="bold">HTTP verbs</strong>.</li>
				<li>Type <code>localhost:3001/v1/accounts</code> in the <strong class="bold">URL</strong> section.</li>
				<li>Go to the <code>raw</code> and change <code>Text</code> to <code>JSON</code>. Add the following JSON to the text area:<pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "name":"AccName1",</strong>
<strong class="bold">    "number":"Ac21345",</strong>
<strong class="bold">    "type":"root",</strong>
<strong class="bold">    "status":"new"</strong>
<strong class="bold">}</strong></pre></li>				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from the endpoint:<pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "Account": {</strong>
<strong class="bold">        "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">        "name": "AccName1",</strong>
<strong class="bold">        "number": "Ac21345",</strong>
<strong class="bold">        "type": "root",</strong>
<strong class="bold">        "status": "new"</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>Now, let’s get the <a id="_idIndexMarker381"/>account by ID.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Getting an account by ID</h2>
			<p>To get an account with the <a id="_idIndexMarker382"/>given ID, follow these steps:</p>
			<ol>
				<li>Create a new tab in Postman.</li>
				<li>Select <code>GET</code> from <strong class="bold">HTTP verbs</strong>.</li>
				<li>Type <code>localhost:3001/v1/accounts/{accountID}</code> in the <code>662c081370bd2ba6b5f04e94</code>.</li>
				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from the endpoint:<pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "account": {</strong>
<strong class="bold">        "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">        "name": "AccName1",</strong>
<strong class="bold">        "number": "Ac21345",</strong>
<strong class="bold">        "type": "root",</strong>
<strong class="bold">        "status": "new"</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>Now, let’s learn how to <a id="_idIndexMarker383"/>update our existing account.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Updating an account by ID</h2>
			<p>To update your given <a id="_idIndexMarker384"/>account, follow these steps:</p>
			<ol>
				<li>Create a new tab in Postman.</li>
				<li>Select <code>PUT</code> from <strong class="bold">HTTP verbs</strong>.</li>
				<li>Type <code>localhost:3001/v1/accounts/{accountID}</code> in the URL section.</li>
				<li>Go to the <code>raw</code> and change <code>Text</code> to <code>JSON</code>. Add the following JSON to the text area:<pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "name":"updated account",</strong>
<strong class="bold">    "number":"AE33333"</strong>
<strong class="bold">}</strong></pre></li>				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from the endpoint:<pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "Account": {</strong>
<strong class="bold">        "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">        "name": "updated account",</strong>
<strong class="bold">        "number": "AE33333",</strong>
<strong class="bold">        "type": "root",</strong>
<strong class="bold">        "status": "new"</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>For most of the APIs, we <a id="_idIndexMarker385"/>usually want to retrieve all data. Next, we’ll learn how to get all account information.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Gettings all accounts</h2>
			<p>To retrieve all accounts, follow<a id="_idIndexMarker386"/> these steps:</p>
			<ol>
				<li>Create a new tab in Postman.</li>
				<li>Select <code>GET</code> from <strong class="bold">HTTP verbs</strong>.</li>
				<li>Type <code>localhost:3001/v1/accounts</code> in the <strong class="bold">URL</strong> section.</li>
				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from the endpoint:<pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "account": [</strong>
<strong class="bold">        {</strong>
<strong class="bold">            "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">            "name": "updated account",</strong>
<strong class="bold">            "number": "AE33333",</strong>
<strong class="bold">            "type": "root",</strong>
<strong class="bold">            "status": "new"</strong>
<strong class="bold">        }</strong>
<strong class="bold">    ]</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>The final endpoint<a id="_idIndexMarker387"/> involves deleting the account. Let’s check it.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Deleting account by ID</h2>
			<p>Finally, to delete your <a id="_idIndexMarker388"/>already existing account by its ID, follow these steps:</p>
			<ol>
				<li>Create a new tab in Postman.</li>
				<li>Select <code>DELETE</code> from <strong class="bold">HTTP verbs</strong>.</li>
				<li>Type <code>localhost:3001/v1/accounts/{accountID}</code> in the <strong class="bold">URL</strong> section. Provide the valid <strong class="bold">accountID</strong> value to delete the record.</li>
				<li>Click the <code>204 no-content</code> response from the endpoint.</li>
			</ol>
			<p>With that, we have fully functional CRUD endpoints for accounts. We may not have a complex business case, but the purpose of this chapter was to show you how to implement endpoints for your microservices.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Summary</h1>
			<p>In this chapter, we created our first microservice. This was our first practical chapter about creating microservices. For this, having a clear understanding of your requirements is important. We provided simple requirements to make our first microservice more understandable and easy to follow. There, we learned how to set up our project. We talked about the tools we need to develop our first microservice; before every microservice development process can be undertaken, we need to define which tools and technologies we plan to use. We also created our internal structure using MVC and N-layered architecture. These are the most popular choices, so using them for your first development project is a great chance for you to learn popular techniques. The practical aspect of this chapter covered creating models, business logic, and controllers. There, we learned about the basics of validation using the JOI package. The application requires a separate file to store configuration, hence why we used the <code>dotenv</code> package. We also learn about routing, which is important if we wish to access our functionalities. Then, we integrated routing using Express.js.</p>
			<p>In the end, we learned how to check our functionalities using Postman. In the upcoming chapters, we will delve into the development of a second microservice, focusing on establishing synchronous communication between microservices. We will introduce a new stack for the transaction microservice, using tools like NestJS, Prisma, and Axios, to demonstrate the versatility of JavaScript in microservice development.</p>
		</div>
	</body></html>