<html><head></head><body>
		<div id="_idContainer055">
			<h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor074"/>5</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Basic CRUD Microservices</h1>
			<p>Our previous chapters are proof that microservices development is not just about implementation. You need to at least have a clear understanding of the pros and cons of using microservices compared with other approaches we looked at in the previous chapters – monolith and service-oriented – and you need to have an essential understanding of the technologies you want to apply when <span class="No-Break">building microservices.</span></p>
			<p>Applying all theoretical knowledge you have in practice is also not an easy task. This chapter will help us to apply microservices in practice and is one step forward to real-world microservices implementation. In this chapter, we plan to provide a solid foundation for further <span class="No-Break">practical chapters.</span></p>
			<p>Implementing a microservice approach in your project means that you mostly have a complex business domain and the conceptual boundary of your microservice requires you to implement a part of this complex logic. It indicates that microservice development is more than <strong class="bold">Create</strong>, <strong class="bold">Retrieve/Read</strong>, <strong class="bold">Update</strong>, <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) but to have a basic understanding of the microservice application structure, this chapter is a good <span class="No-Break">starting point.</span></p>
			<p>We’re going to explore the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">business requirements</span></li>
				<li>Tools to develop a <span class="No-Break">basic microservice</span></li>
				<li>Preparing our <span class="No-Break">first project</span></li>
				<li>Defining the internal architecture of <span class="No-Break">our microservice</span></li>
				<li>Hands-on account <span class="No-Break">microservice development</span></li>
				<li>Running and testing our <span class="No-Break">first microservice</span></li>
			</ul>
			<p>Let’s get <span class="No-Break">into it!</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p>To develop and test our first microservice, we’ll need the <span class="No-Break">following tools:</span></p>
			<ul>
				<li>An IDE of your choice (we prefer Visual <span class="No-Break">Studio Code)</span></li>
				<li><span class="No-Break">Postman</span></li>
				<li><span class="No-Break">MongoDB</span></li>
				<li>A browser of <span class="No-Break">your choice</span></li>
			</ul>
			<p>It’s recommended that you download this book’s GitHub repository from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript</a> folder to easily follow our <span class="No-Break">code snippets.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>Understanding business requirements</h1>
			<p>Before you jump into building microservices with JavaScript, it’s important to clearly understand what your services need to do. Then, based on what your project requires, you can pick the right tools to help you create <span class="No-Break">those microservices.</span></p>
			<p>The team doesn’t consist of only developers. The business domain people are also an integral part of<a id="_idIndexMarker296"/> the team when it comes to building business valuable applications. In software development, the final and main artifact is code and it should reflect the real business. Applying domain language that everyone speaks will make your code a valuable source of truth and it is only possible if you have zero translation between business and developers. The most popular approach to developing such types of microservices with a single language that everyone speaks is <strong class="bold">Domain-driven Design</strong> (<strong class="bold">DDD</strong>). Everyone in <a id="_idIndexMarker297"/>a team should use the same language that describes the business in a given <a id="_idIndexMarker298"/>boundary. This is called <strong class="bold">Ubiquitous Language</strong> (<strong class="bold">UL</strong>). Using UL, everyone in a team will speak the same language and the language will be reflected in your code. It means business helps your design and developers help businesses to have more <span class="No-Break">clearer understanding.</span></p>
			<p>Throughout our learning process, we’ll mention some ideas from DDD, despite this not being a DDD book. Please refer to <em class="italic">Implementing Domain-Driven Design</em>, by Vaugh Vernon, and <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, by Eric Evans, to <span class="No-Break">learn more.</span></p>
			<p>This book is not about analyzing and gathering the business requirements. There are really good sources out there that focus exactly on this topic. To make things simple and less theoretical, we’ll start with distilled requirements with <span class="No-Break">clear boundaries.</span></p>
			<p>We will build an account <a id="_idIndexMarker299"/>building microservice that requires the following <span class="No-Break"><em class="italic">core functionalities</em></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">Create account</span></li>
				<li><span class="No-Break">Update account</span></li>
				<li>Get all <span class="No-Break">account information</span></li>
				<li>Get an account for the <span class="No-Break">given ID</span></li>
				<li>Delete <span class="No-Break">unused account</span></li>
			</ul>
			<p>Then, we have the following <span class="No-Break"><em class="italic">non-functional</em></span><span class="No-Break"> requirements:</span></p>
			<ul>
				<li><strong class="bold">Scalability</strong>: The<a id="_idIndexMarker300"/> microservice should be able to<a id="_idIndexMarker301"/> handle more and more requests as it gets used by <span class="No-Break">more people.</span></li>
				<li><strong class="bold">Performance</strong>: The microservice should respond to requests quickly to keep <span class="No-Break">users happy.</span></li>
				<li><strong class="bold">Resilience</strong>: The microservice should be able to bounce back from problems and keep <span class="No-Break">working properly.</span></li>
				<li><strong class="bold">Easy testing</strong>: The microservice should be simple to test to make sure it’s <span class="No-Break">working correctly.</span></li>
				<li><strong class="bold">Stateless</strong>: The microservice shouldn’t rely on remembering past interactions with users, and should instead store any important information in <span class="No-Break">a database.</span></li>
				<li><strong class="bold">Easy updates</strong>: The microservice should be straightforward to put to use and update whenever needed. Of course, usually, you’ll have more non-functional requirements than these. However, for getting started, these should be more <span class="No-Break">than enough.</span></li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Tools to develop a basic microservice</h1>
			<p>Developing an application is not just a coding process. In this chapter, to develop our microservice, we also need to select the Node.js framework and store information in <span class="No-Break">our database:</span></p>
			<ul>
				<li><strong class="bold">Database</strong>: We need to store information somewhere. It’s better to keep the service itself simple and <a id="_idIndexMarker302"/>store the information in a <span class="No-Break">separate database:</span><p class="list-inset">For this service, we’ll be using <em class="italic">MongoDB</em>, a popular database that works differently than traditional SQL databases. MongoDB is a popular choice for building web services with <span class="No-Break">Node.js technology.</span></p><p class="list-inset">It’s designed to handle situations where users mostly read information, and it can store a lot of data efficiently. MongoDB can be easily expanded by adding more servers <span class="No-Break">as needed.</span></p></li>
				<li><strong class="bold">Node.js framework</strong>: You can build a fully functional microservice using just Node.js but it takes some time and a lot of lines of code. Nowadays, most developers use the Node.js<a id="_idIndexMarker303"/> frameworks to build services fast with a minimal amount of code lines. Node.js on its own is a low-level environment. Frameworks provide a predefined structure and organization for your code, making it easier to manage and maintain as your project grows. They often come with common functionalities such as <em class="italic">routing</em> (handling different URL requests), <em class="italic">templating</em> (generating web page content), and database interaction already built-in. This saves you time from writing those <span class="No-Break">parts yourself.</span><p class="list-inset">Popular Node.js frameworks have large communities of developers. This means you have access to a wealth of resources, tutorials, and solutions online if you encounter problems. There’s also a bigger pool of developers familiar with the framework for <span class="No-Break">potential collaboration.</span></p><p class="list-inset">Frameworks can help mitigate security vulnerabilities by providing established coding practices and features to prevent <span class="No-Break">common attacks.</span></p></li>
			</ul>
			<p>For this chapter, we’re going to use <em class="italic">Express.js</em>, one of the most popular Node.js frameworks for <span class="No-Break">building microservices.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Preparing our first project</h1>
			<p>Our focus in this chapter is to create a microservice that provides really simple CRUD operations. So, it’s going to be mostly domain-centric. That’s why we start our application from <span class="No-Break">the database.</span></p>
			<p>To follow our examples, open the <strong class="source-inline">Ch05</strong> folder in this book’s GitHub repository and open it using your favorite <span class="No-Break">text editor.</span></p>
			<p><em class="italic">There’s a difference between knowing the path and walking </em><span class="No-Break"><em class="italic">the path.</em></span></p>
			<p>We prefer that you don’t just download and explore the repository and that you also try to write some code with us. This will help you gain <span class="No-Break">valuable practice.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Understanding the concept of packages</h2>
			<p>Building software doesn’t mean that you should implement everything from scratch and this fact doesn’t depend on programming languages. It is also applicable for Node.js development. Our main <a id="_idIndexMarker304"/>focus should always be solving business problems and making this process fast, easy, secure, and reliable. Almost every popular programming<a id="_idIndexMarker305"/> language provides a collection of libraries. In Node.js, these are called <strong class="bold">packages</strong>. Node.js development mostly starts with <span class="No-Break">package configuration.</span></p>
			<p>When you install Node.js, you <a id="_idIndexMarker306"/>automatically install the <strong class="bold">Node package manager</strong> (<strong class="bold">npm</strong>) tool. This tool allows you to find, build, and manage packages. You can find almost any package for your daily-basis needs. People use, test, maintain, and fix bugs and that makes <strong class="source-inline">npm</strong> a great and reliable source for development. For example, if you need validation for your application, you shouldn’t build everything from scratch. Why not use popular practices that have already been implemented in popular libraries? We mostly build only business-specific functionalities by ourselves. Other relevant functionalities, such as connecting to the database, validation, security, logging, and more, can be installed as packages <span class="No-Break">and reused.</span></p>
			<p>Here’s how you can interact with <strong class="source-inline">npm</strong> and <span class="No-Break">configure it:</span></p>
			<ol>
				<li>Open your favorite text editor (we’re using Visual <span class="No-Break">Studio Code).</span></li>
				<li>Create a folder (in our <span class="No-Break">case, </span><span class="No-Break"><strong class="source-inline">Ch05</strong></span><span class="No-Break">).</span></li>
				<li>Navigate to that folder using your terminal (Use <strong class="bold">Terminal</strong> | <strong class="bold">New terminal</strong> from Visual Studio <a id="_idIndexMarker307"/>Code and run the <strong class="source-inline">cd folder_name</strong> command to navigate to your empty folder – that is, use <span class="No-Break"><strong class="source-inline">cd Ch05</strong></span><span class="No-Break">).</span></li>
				<li> Type <strong class="source-inline">npm init</strong> and follow the instructions provided (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 5.1: Creating a package.json file" src="image/B09148_05_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Creating a package.json file</p>
			<ol>
				<li value="5">Hit <em class="italic">Enter</em> to generate <strong class="bold">package </strong><span class="No-Break"><strong class="bold">configuration</strong></span><span class="No-Break"> (</span><span class="No-Break"><em class="italic">package.json</em></span><span class="No-Break">).</span></li>
				<li>At this point, we have a special file called <strong class="source-inline">package.json</strong> in our project with the following <span class="No-Break">JSON content:</span><pre class="source-code">
{
  "name": "accountmicroservice",
  "version": "1.0.0",
  "description": "simple account microservice with crud functionalities",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/PacktPublishing/Hands-on-
             Microservices-with-JavaScript.git"
  },
  "author": "Suleymani Tural",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/PacktPublishing/Hands-on-
             Microservices-with-JavaScript/issues"
  },
  "homepage": "https://github.com/PacktPublishing/Hands-on-
                Microservices-with-JavaScript#readme"
}</pre></li>				<li>For learning purposes, it is<a id="_idIndexMarker308"/> also OK to use the <strong class="source-inline">npm init -y</strong> command instead of <strong class="source-inline">npm init</strong> as it will generate a minimal <strong class="source-inline">package.json</strong> file for you to get started with (<span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>). After generation, you can manually update any line <span class="No-Break">you want:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 5.2: Generated package.json file" src="image/B09148_05_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Generated package.json file</p>
			<p>Let’s learn more<a id="_idIndexMarker309"/> about the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Understanding the package.json file</h2>
			<p>The <strong class="source-inline">package.json</strong> file is a<a id="_idIndexMarker310"/> vital component in Node.js projects. It acts like a <a id="_idIndexMarker311"/>project manifest, storing crucial information about <span class="No-Break">your project.</span></p>
			<p>Let’s summarize the role of the <strong class="source-inline">package.json</strong> file in our <span class="No-Break">Node.js projects:</span></p>
			<ul>
				<li>It lists all the external modules (dependencies) your project relies on <span class="No-Break">to function.</span></li>
				<li>Along with the names, it specifies the required versions using semantic versioning for compatibility. This ensures that everyone working on the project uses the same compatible versions <span class="No-Break">of dependencies.</span></li>
				<li>It serves as a central location for project metadata, such as the project’s name, version, description, license, and author information (see <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>You can define custom scripts in the <strong class="source-inline">package.json</strong> file to automate repetitive tasks within your project. These scripts can do anything from starting the development server to running tests or building the project <span class="No-Break">for deployment.</span></li>
				<li>If you plan to publish your project as a reusable package for others to use, <strong class="source-inline">package.json</strong> becomes even more important. It provides essential information for the package manager (such as <strong class="source-inline">npm</strong>) to understand how to install and use your <span class="No-Break">project </span><span class="No-Break"><a id="_idIndexMarker312"/></span><span class="No-Break">effectively.</span></li>
			</ul>
			<p>Long story short, <strong class="source-inline">package.json</strong> keeps your project organized, ensures consistent dependencies, and simplifies collaboration<a id="_idIndexMarker313"/> <span class="No-Break">among developers.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>Understanding index.js files</h2>
			<p>Throughout this <a id="_idIndexMarker314"/>chapter, you’ll encounter files named <strong class="source-inline">index.js</strong>. These files play a couple of <span class="No-Break">important roles.</span></p>
			<p>By convention, <strong class="source-inline">index.js</strong> acts as <a id="_idIndexMarker315"/>the entry point for our Node.js application. When we run our application using node, the <strong class="source-inline">index.js</strong> file is the starting point where the application’s <span class="No-Break">execution begins.</span></p>
			<p>Inside <strong class="source-inline">index.js</strong>, you can typically find code that imports necessary modules and libraries using the required statements to configure your application (for example, setting up a web server and connecting to databases) and defines the main logic or event listeners for <span class="No-Break">your application.</span></p>
			<p>These files can also serve for namespacing and organization within your project. Consider a folder containing multiple JavaScript files with related functionalities. An <strong class="source-inline">index.js</strong> file inside that folder can act as a central point for importing those related files and re-exporting specific functions or classes from those files, making them accessible outside the folder using a single <span class="No-Break">import statement.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It’s important to note that <strong class="source-inline">index.js</strong> is a convention, not a strict requirement. You can name your entry point file differently (for example, <strong class="source-inline">app.js</strong> or <strong class="source-inline">main.js</strong>). So long as you specify the correct filename when you’re running your application with node, it <span class="No-Break">will work.</span></p>
			<p>In summary, <strong class="source-inline">index.js</strong> files serve as a common entry point and a way to organize code within folders in your Node.js projects. They provide a clean and consistent approach to structuring your <a id="_idIndexMarker316"/>application’s starting point and managing <span class="No-Break">related functionalities.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Installing the required packages</h2>
			<p>By itself, <strong class="source-inline">package.json</strong> doesn’t contain any required package that we plan to use by default. It is just <a id="_idIndexMarker317"/>boilerplate for getting started. Here’s a list of packages that we’ll be using in this chapter, along with their <span class="No-Break">installation commands:</span></p>
			<ul>
				<li>Express ( <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">install express</strong></span><span class="No-Break">)</span></li>
				<li>Joi ( <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">install joi</strong></span><span class="No-Break">)</span></li>
				<li>mongoose ( <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">install mongoose</strong></span><span class="No-Break">)</span></li>
				<li>dotenv ( <strong class="source-inline">npm install </strong><span class="No-Break"><strong class="source-inline">dotenv –save</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Here’s what the <strong class="source-inline">package.json</strong> file’s dependencies and <strong class="source-inline">devDependencies</strong> <span class="No-Break">look like:</span></p>
			<pre class="console">
"dependencies": {
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "joi": "^17.12.3",
    "mongoose": "^8.3.2"
  }</pre>			<p>You’ve probably already realized that, when installing our first package, the node automatically generates another file called <strong class="source-inline">package-lock.json</strong>. Let’s summarize <span class="No-Break">its roles:</span></p>
			<p>It acts as a lock file, specifying the exact versions of packages and their dependencies that were installed. This guarantees that regardless of who installs the project or on what machine, the same set of versions will be used, leading to <span class="No-Break">consistent behavior.</span></p>
			<p>By locking down versions, <strong class="source-inline">package-lock.json</strong> enables developers to reproduce the project’s environment exactly. This is essential for maintaining stability and avoiding unexpected issues during deployments or across different <span class="No-Break">development machines.</span></p>
			<p>When shared within a team or used in <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines, <strong class="source-inline">package-lock.json</strong> ensures everyone involved is working with the same <a id="_idIndexMarker318"/>dependencies. This streamlines collaboration and automates <span class="No-Break">reliable builds.</span></p>
			<p>It works in conjunction with <strong class="source-inline">package.json</strong>. While <strong class="source-inline">package.json</strong> specifies the desired dependencies <a id="_idIndexMarker319"/>and their version ranges, <strong class="source-inline">package-lock.json</strong> pins down the exact versions that are used <span class="No-Break">during installation.</span></p>
			<p>Overall, <strong class="source-inline">package-lock.json</strong> is important for maintaining consistent and reproducible Node.js project environments across installations and <span class="No-Break">team workflows.</span></p>
			<p>You may have noticed that we have one more folder: <strong class="source-inline">node_modules</strong>. In Node.js projects, the  <strong class="source-inline">node_modules</strong> folder is a special directory that stores all the third-party libraries and dependencies your project relies on. These libraries provide pre-written code for functionalities you don’t need to build from scratch, saving you time <span class="No-Break">and effort.</span></p>
			<p>Node.js projects often depend on external code from various sources. The <strong class="source-inline">node_modules</strong> folder keeps all these dependencies organized in one place. Each project can have its own set of dependencies specific to its needs. This way, different projects can use different versions of the same library <span class="No-Break">without conflicts.</span></p>
			<p>At this point, we have an initial skeleton for our application. So, it’s time to start the actual <span class="No-Break">development process.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Defining the internal architecture of our microservice</h1>
			<p>Imagine that after carefully analyzing, we decided to have a special microservice that’s responsible for working with <a id="_idIndexMarker320"/>account information and we called it the <em class="italic">account microservice</em>. Our account consists of an <em class="italic">ID</em>, <em class="italic">account name</em>, <em class="italic">account type</em>, <em class="italic">account status</em>, and <em class="italic">account number</em>. To track changes, we’re going to add <strong class="source-inline">createdAt</strong> and <span class="No-Break"><strong class="source-inline">updatedAt</strong></span><span class="No-Break"> fields.</span></p>
			<p>The microservice approach has been applied to our whole project and now we have multiple services. However, the internal design of our concrete microservice depends on the requirements and it’s up to the team regarding which architectural pattern to apply. One of the most popular and classical architectural patterns in software development is <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>). To make things simple and understandable, we will apply it to our <span class="No-Break">microservice design.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor085"/>MVC architectural pattern</h2>
			<p>The MVC architectural <a id="_idIndexMarker321"/>pattern is a popular choice for<a id="_idIndexMarker322"/> structuring Node.js APIs due to its emphasis on separation <span class="No-Break">of concerns.</span></p>
			<p>It has the following <span class="No-Break">main components:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Model</strong></span><span class="No-Break">:</span><ul><li>Represents the<a id="_idIndexMarker323"/> data layer of <span class="No-Break">your API.</span></li><li>Encapsulates data access logic and interacts with databases (for example, MongoDB, MySQL, and <span class="No-Break">so on).</span></li><li>Handles data persistence <span class="No-Break">and retrieval.</span></li></ul></li>
				<li><strong class="bold">View</strong> (not directly used in <span class="No-Break">Node.js APIs):</span><ul><li>Traditionally <a id="_idIndexMarker324"/>deals with UI presentation in <span class="No-Break">web applications.</span></li><li>Not directly applicable in Node.js APIs as they <span class="No-Break">are data-centric.</span></li><li>Note that the concept of <em class="italic">view</em> can be extended to represent the response format (JSON, XML) for <span class="No-Break">the API.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Controller</strong></span><span class="No-Break">:</span><ul><li>Acts as the <a id="_idIndexMarker325"/>central coordinator of <span class="No-Break">your API.</span></li><li>Receives incoming HTTP requests from clients (for example, <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">).</span></li><li>Interacts with the model to fetch or manipulate data based on <span class="No-Break">the request.</span></li><li>Prepares the response data in the desired format (<span class="No-Break">JSON, XML).</span></li><li>Returns the response to <span class="No-Break">the client.</span></li></ul></li>
			</ul>
			<p>But why it is beneficial to use MVC for <span class="No-Break">Node.js APIs?</span></p>
			<ul>
				<li><strong class="bold">Separation of concerns</strong>: Makes <a id="_idIndexMarker326"/>code more organized and maintainable by <span class="No-Break">dividing functionalities.</span></li>
				<li><strong class="bold">Improved testability</strong>: Each layer (model, view, and controller) can be <span class="No-Break">tested independently.</span></li>
				<li><strong class="bold">Flexibility</strong>: Easier to modify or update specific parts of the API without <span class="No-Break">affecting others.</span></li>
				<li><strong class="bold">Scalability</strong>: Easier to scale the application by adding more controllers <span class="No-Break">or models.</span></li>
			</ul>
			<p>Now that we have enough<a id="_idIndexMarker327"/> theoretical knowledge about MVC, it’s time to apply it <span class="No-Break">in practice.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Integrating MVC into our Node.js project</h2>
			<p>While Node.js doesn’t have a<a id="_idIndexMarker328"/> built-in MVC framework, popular web frameworks such as <em class="italic">Express.js</em> can be used to implement the pattern. Express.js handles routing (mapping URLs to controllers) and simplifies <span class="No-Break">request-response handling.</span></p>
			<p>You’ll typically structure your project with separate folders for models <span class="No-Break">and controllers.</span></p>
			<p>We’ll use the <em class="italic">N-Layered Architecture</em> to structure our code. This architecture is popular because it promotes the separation of concerns, making the application more modular, maintainable, <span class="No-Break">and scalable.</span></p>
			<p>Since we don’t have complex requirements, getting started with it is a good initial point. Using both MVC and the N-layered architecture in your Node.js Express project can lead to a well-structured and maintainable API. The following are some common layers <span class="No-Break">you’ll encounter:</span></p>
			<ul>
				<li>Presentation Layer (UI <span class="No-Break">or API)</span></li>
				<li>Business Logic Layer (core <span class="No-Break">application logic)</span></li>
				<li>Data Access Layer (interaction <span class="No-Break">with databases)</span></li>
			</ul>
			<p>The model, representing data and its logic, aligns with the data access layer’s responsibilities. Scripts in the <strong class="source-inline">services</strong> folder will store our business logic. The controller, which handles<a id="_idIndexMarker329"/> requests and manipulates data, shouldn’t contain any business logic. Instead, it should act as a bridge that forwards the user’s request to the business <span class="No-Break">logic layer.</span></p>
			<p>Now that we’ve defined a general architecture for our application, we’re ready to focus on the implementation details. Starting from the next section, we’ll implement the functional behaviors of our <span class="No-Break">first microservice.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor087"/>Hands-on account microservice development</h1>
			<p>To start from scratch, let’s create a folder called <strong class="source-inline">src</strong>. We plan to organize our main application structure<a id="_idIndexMarker330"/> under this folder. This is going to be a data-centric application, so it’s better to start development from the <span class="No-Break">database segment.</span></p>
			<p>In the end, we plan to build the following project  structure for <span class="No-Break">our application:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 5.3: The final project structure" src="image/B09148_05_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: The final project structure</p>
			<p>To follow along <a id="_idIndexMarker331"/>with ease, don’t forget to download the source code from <span class="No-Break">our repository.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>Implementing our data-access functionalities</h2>
			<p>We always store data <a id="_idIndexMarker332"/>somewhere. The most used storage for data is a database. The data access that we plan to implement relies on MongoDB and isolates us from the difficulties of querying a database using SQL. It’s like using arrays or lists but under the hood, it interacts with <span class="No-Break">a database.</span></p>
			<p>To start creating our account microservice, do <span class="No-Break">the following:</span></p>
			<p>Create a <strong class="source-inline">db</strong> folder <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li>Add the <strong class="source-inline">index.js</strong> file to the <span class="No-Break"><strong class="source-inline">db</strong></span><span class="No-Break"> folder.</span></li>
				<li>First, we need to handle<a id="_idIndexMarker333"/> the database communication process. That’s why our current file (<strong class="source-inline">index.js</strong>) will serve connection and <span class="No-Break">disconnection functionalities:</span><pre class="source-code">
const db = require('mongoose');
let mongoUrl;
async function connect({ mongo: { url } }) {
    mongoUrl = url;
    try {
        await db.connect(mongoUrl);
    } catch (err) {
        setTimeout(connect, 8000);
    }
}
const dbConnection = db.connection;
function disconnect() {
    dbConnection.removeAllListeners();
    return db.disconnect();
}
module.exports = {
    connect,
    disconnect,
};</pre><p class="list-inset">We’ve already mentioned the <strong class="source-inline">mongoose</strong> package. To use packages like this, we have the <strong class="source-inline">required</strong> command. Node.js automatically handles packages from the <strong class="source-inline">node_modules</strong> folder without specifying any relative or <span class="No-Break">full path.</span></p><p class="list-inset">Here, we’ve implemented<a id="_idIndexMarker334"/> two main functionalities. They mostly act as wrappers over <span class="No-Break">existing functionalities:</span></p><ul><li>The <strong class="source-inline">connect</strong> function tries to connect to the given database. In case of errors, we have one more attempt to try to connect to the database after <strong class="source-inline">8</strong> seconds. It is up to you to configure this but having a connection attempt after an unsuccessful operation <span class="No-Break">makes sense.</span></li><li>The <strong class="source-inline">disconnect</strong> function handles the disconnection case. Here, we’re removing all listeners of our database via <span class="No-Break"><strong class="source-inline">db.disconnect()</strong></span><span class="No-Break"> manually.</span></li></ul><p class="list-inset">Node.js has a file-based module approach. This means that every file, by itself, can be treated as a module and other modules can use it to build more complex modules. One of the ways you can make some functionalities of your module accessible to others is by using <strong class="source-inline">exports</strong>. You should only provide the required functions with the following proper encapsulation. If some of your functions are used by other functions in the same module and they are not part of your module’s contract, it’s better not to specify them in the <strong class="source-inline">exports</strong> list. In our case, we have two functions – <strong class="source-inline">connect</strong> and <strong class="source-inline">disconnect</strong> – that we’re providing outside to be consumed by <span class="No-Break">other modules.</span></p></li>			</ol>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>Implementing the M in MVC</h2>
			<p>In our project, the <a id="_idIndexMarker335"/>responsibility of models is to act as a data access layer. This layer covers the main operations, such as <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">SELECT</strong>, and <strong class="source-inline">DELETE</strong>. We have <strong class="source-inline">account.js</strong> under the <strong class="source-inline">src/models</strong> folder; this is where all the database-related functionalities live. Here’s what it <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
const mongoose = require('mongoose');
const { Schema } = mongoose;
const AccountSchema = new Schema(
    {
        name: {
            type: String,
            required: true,
        },
        number: {
            type: String,
            required: true,
        },
        type: {
            type: String,
            enum: ['root', 'sub'],
            default: 'root',
        },
        status: {
            type: String,
            enum: ['new', 'active', 'inactive', 'blocked'],
            default: 'new',
        },
        createdAt: {
            type: Date,
            default: Date.now,
        },
        updatedAt: Date,
    },
    { optimisticConcurrency: true },
);
module.exports = mongoose.model('account', AccountSchema);</pre>			<p>Let’s walk through<a id="_idIndexMarker336"/> <span class="No-Break">this code:</span></p>
			<ul>
				<li><strong class="source-inline">const mongoose = require('mongoose');</strong>: This line imports the Mongoose library, which is used for interacting with MongoDB databases <span class="No-Break">in Node.js.</span></li>
				<li><strong class="source-inline">const { Schema } = mongoose;</strong>: This line uses destructuring to extract the <strong class="source-inline">Schema</strong> class from the <strong class="source-inline">mongoose</strong> object. This makes the code more concise and easier <span class="No-Break">to read.</span></li>
				<li><strong class="source-inline">new Schema({ ... })</strong>: This line creates a new Mongoose schema object. The object that’s passed as an argument defines the structure of the documents that will be stored in the account collection within your MongoDB database. Within the curly braces, <strong class="source-inline">{}</strong>, you define the properties (fields) of each document in the collection. Here’s a breakdown of <span class="No-Break">each property:</span><ul><li><span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">type: String</strong>: This specifies that the <strong class="source-inline">name</strong> property should be <span class="No-Break">a string.</span></li><li><strong class="source-inline">required: true</strong>: This makes the <strong class="source-inline">name</strong> property mandatory. A document cannot be saved without a value for <span class="No-Break">the name.</span></li></ul></li><li><strong class="source-inline">number</strong>: Similar to <strong class="source-inline">name</strong>, but <span class="No-Break">also required.</span></li><li><span class="No-Break"><strong class="source-inline">type</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">type: String:</strong> The <strong class="source-inline">status</strong> property is <span class="No-Break">a string.</span></li><li><strong class="source-inline">enum: ['new', 'active', 'inactive', 'blocked']</strong>: Similar to <strong class="source-inline">type</strong>, this defines a list of allowed values for the status: <strong class="source-inline">'new'</strong>, <strong class="source-inline">'active'</strong>, <strong class="source-inline">'inactive'</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">'blocked'</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">default: 'new'</strong>: If no status is specified, it will default <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">'new'</strong></span><span class="No-Break">.</span></li></ul></li><li><span class="No-Break"><strong class="source-inline">createdAt</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">type: Date</strong>: This property stores the date and time the document was created using the current <span class="No-Break">time (</span><span class="No-Break"><strong class="source-inline">Date.now</strong></span><span class="No-Break">).</span></li></ul></li><li><span class="No-Break"><strong class="source-inline">updatedAt</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">type: Date:</strong> This property is intended to store the date and time the document was last updated. However, it’s not explicitly set to a default value here. You’ll likely need to update this field manually in your <span class="No-Break">application logic.</span></li></ul></li><li><strong class="source-inline">  { optimisticConcurrency: true }</strong>: This option is used for optimistic<a id="_idIndexMarker337"/> concurrency control, which is a mechanism that helps prevent data inconsistencies during <span class="No-Break">updates (</span><a href="https://mongoosejs.com/docs/guide.html#optimisticConcurrency"><span class="No-Break">https://mongoosejs.com/docs/guide.html#optimisticConcurrency</span></a><span class="No-Break">).</span></li></ul></li>
				<li><strong class="source-inline">module.exports = mongoose.model('account', AccountSchema);</strong>: This line creates a Mongoose model named <strong class="source-inline">account</strong> based on your defined <strong class="source-inline">AccountSchema</strong>. The model acts as a blueprint for interacting with <strong class="source-inline">account</strong> documents in your MongoDB database. By exporting the model, you make it available for use in other parts of your <span class="No-Break">Node.js application.</span></li>
			</ul>
			<p>Long story short, this code sets up a Mongoose schema for storing account information in a MongoDB collection. It defines properties such as <strong class="source-inline">name</strong>, <strong class="source-inline">number</strong>, <strong class="source-inline">type</strong>, <strong class="source-inline">status</strong>, <strong class="source-inline">creation time</strong>, and <strong class="source-inline">last update time</strong>, with validation rules and defaults. The code then exports a model that allows you to create, read, update, and delete account documents in <span class="No-Break">your </span><span class="No-Break"><a id="_idIndexMarker338"/></span><span class="No-Break">database.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Storing configuration</h2>
			<p>We need to store application-based configuration somewhere. For the current situation, we need MongoDB URL and port information. It isn’t a good idea to hard-code this information directly into your <a id="_idIndexMarker339"/>code because of maintainability, reusability, and extensibility. Instead, we prefer to store it in a separate file. That’s why we’ve installed the <span class="No-Break"><strong class="source-inline">dotenv</strong></span><span class="No-Break"> package.</span></p>
			<p>The <strong class="source-inline">dotenv</strong> package in Node.js helps you manage environment variables for your project. It offers a way to store configuration settings, such as API keys or database credentials, outside of your code in a <strong class="source-inline">.env</strong> file. This improves security by keeping sensitive data out of <span class="No-Break">your codebase.</span></p>
			<p>Why <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">dotenv</strong></span><span class="No-Break">?</span></p>
			<ul>
				<li><strong class="bold">Security</strong>: It keeps sensitive <a id="_idIndexMarker340"/>data out of your code base, reducing the risk of <span class="No-Break">accidental exposure</span></li>
				<li><strong class="bold">Separation of concerns</strong>: It separates configuration from code, making your code cleaner and easier <span class="No-Break">to manage</span></li>
				<li><strong class="bold">Multiple environments</strong>: You can create different <strong class="source-inline">.env</strong> files for different environments (development, staging, and production) with specific configurations <span class="No-Break">for each</span></li>
			</ul>
			<p>The <strong class="source-inline">.env</strong> file itself shouldn’t be included in version control systems such as Git to avoid committing sensitive information. We can create a <strong class="source-inline">.env.example</strong> file with placeholder values to guide developers on how to set up their environment variables. However, for this book, we will include the .<strong class="source-inline">env</strong> file in our Git repository as is, to facilitate the <span class="No-Break">learning process.</span></p>
			<p>We have the <strong class="source-inline">configs</strong> folder under the <strong class="source-inline">Ch05</strong> folder. It is a root-level folder and contains a <strong class="source-inline">.env</strong> file without a name. Here’s <span class="No-Break">its content:</span></p>
			<pre class="console">
PORT=3001
MONGODB_URL=mongodb://localhost:27017/account-microservice</pre>			<p>We need to validate and create a configuration object based on the configuration we’ve looked at. That’s why we<a id="_idIndexMarker341"/> need one more folder called <strong class="source-inline">config</strong> under the <strong class="source-inline">src</strong> folder. So, let’s create <strong class="source-inline">config.js</strong> with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
const dotenv = require('dotenv');
const Joi = require('joi');
const envVarsSchema = Joi.object()
    .keys({
        PORT: Joi.number().default(3000),
        MONGODB_URL: Joi.string().required().description('Mongo DB url')
    })
    .unknown();
function createConfig(configPath) {
    dotenv.config({ path: configPath });
    const { value: envVars, error } = envVarsSchema
        .prefs({ errors: { label: 'key' } })
        .validate(process.env);
    if (error) {
        throw new Error(`Config validation error: ${error.message}`);
    }
    return {
        port: envVars.PORT,
        mongo: {
            url: envVars.MONGODB_URL,
        }
    };
}
module.exports = {
    createConfig,
};</pre>			<p>Using the <strong class="bold">Joi</strong> package, we validate our configuration, and using the <strong class="source-inline">createConfig</strong> function, we’re able to read <a id="_idIndexMarker342"/>and build <span class="No-Break">config objects.</span></p>
			<p>There are a lot of packages out there that can be used for data validation. We prefer to use Joi because it’s popular and easy to use. Joi is a popular open source package that provides a declarative way to define data schemas and perform validation against <span class="No-Break">those schemas.</span></p>
			<p>it allows you to<a id="_idIndexMarker343"/> create JavaScript objects that represent the expected structure and data types for your application’s inputs (request body, query parameters, and <span class="No-Break">so on).</span></p>
			<p>It offers a wide range of validation rules for common data types such as strings, numbers, arrays, and objects. You can define rules for presence, format, length, <span class="No-Break">and more.</span></p>
			<p>It integrates seamlessly with Express.js middleware, allowing you to validate data directly within your <span class="No-Break">route handlers.</span></p>
			<p>By separating validation logic from your route handlers, your code becomes cleaner and easier <span class="No-Break">to understand.</span></p>
			<p>Overall, Joi is a valuable tool for building robust and secure Node.js applications. By incorporating data validation with Joi, you can ensure that your application receives clean, reliable data, leading to a more stable and secure <span class="No-Break">development experience.</span></p>
			<p>We’ll be using it in our<a id="_idIndexMarker344"/> application entry <span class="No-Break">point (</span><span class="No-Break"><strong class="source-inline">src/index.js</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Implementing the business layer</h2>
			<p>The business layer is the heart of an N-layered architecture. It’s responsible for the core functionality of the application and implements the specific business rules that govern how the application operates. It <a id="_idIndexMarker345"/>translates user requests into actions and decisions based on the business rules. It also determines how data should be processed, validated, and manipulated to fulfill those requests. Furthermore, it acts as an intermediary between the presentation layer (user interface) and the data access layer (database). It receives data requests from the presentation layer, retrieves the necessary data from the data access layer, and then applies business logic before returning the <span class="No-Break">processed data.</span></p>
			<p>By separating business logic from the presentation and data access layers, the business layer promotes loose coupling and reusability. This makes the application easier to maintain, test, and modify as business <span class="No-Break">needs evolve.</span></p>
			<p>We have a <strong class="source-inline">services</strong> folder under <strong class="source-inline">src</strong> to physically locate service functionalities. We mostly have five functions in <strong class="source-inline">account.js</strong> to cover the main operations related to CRUD: <strong class="source-inline">getAccountById</strong>, <strong class="source-inline">getAllAccounts</strong>, <strong class="source-inline">createAccount</strong>, <strong class="source-inline">deleteAccountById</strong>, and <strong class="source-inline">updateAccountById</strong>. Let’s look at the first <span class="No-Break">four here:</span></p>
			<pre class="source-code">
const Account = require('../models/account');
//get account info by id
function getAccountById(id) {
    return Account.findById(id);
}
//get all account information
function getAllAccounts() {
    return Account.find({});
}
//create account based on name,number,type and status
function createAccount(name, number, type, status) {
    return Account.create({ number, name, type, status });
}
//delete account by account id
async function deleteAccountById(id) {
    const deletedAccount = await Account.findByIdAndDelete(id);
    if(deletedAccount)
     return true;
     else
     return false;
 }</pre>			<p>The first four functions are easy to understand. Using <strong class="source-inline">require</strong>, we import our account from models. Then, we<a id="_idIndexMarker346"/> wrap our data access operations with business functions. The biggest function in this module is <strong class="source-inline">updateAccountById</strong>. Let’s take a <span class="No-Break">closer look:</span></p>
			<pre class="source-code">
//'new', 'active', 'inactive', 'blocked'
const availableAccountStatusesForUpdate = {
    new: ['active', 'blocked'],
    active: ['inactive', 'blocked'],
    inactive: ['active'],
    blocked: ['active'],
};
//'root', 'sub'
const availableAccountTypesForUpdate = {
    root: ['sub'],
    sub: ['root'],
};
const NO_VALID_DATA_TO_UPDATE = 0;
const INVALID_STATUS_CODE = 1;
const INVALID_TYPE_CODE = 2;
const INVALID_ACCOUNT = 3;
const INVALID_STATE_TRANSITION = 4;
const INVALID_TYPE_TRANSITION = 5;
async function updateAccountById(id, { name, number, type, status }) {
    if (!name &amp;&amp; !number &amp;&amp; !type &amp;&amp; !status) {
        return { error: 'provide at least one valid data to be 
          updated', code: NO_VALID_DATA_TO_UPDATE };
    }
    if (status &amp;&amp; !(status in availableAccountStatusesForUpdate)) {
        return { error: 'invalid status for account', code: INVALID_
          STATUS_CODE };
    }
    if (type &amp;&amp; !(type in availableAccountTypesForUpdate)) {
        return { error: 'invalid type for account', code: INVALID_
          TYPE_CODE };
    }
    const account = await Account.findById(id);
    if (!account) {
        return { error: 'account not found', code: INVALID_ACCOUNT };
    }
    //check for available status and transition
    if (status) {
    const allowedStatuses = 
        availableAccountStatusesForUpdate[
            account.status];
        if (!allowedStatuses.includes(status)) {
            return {
                error: `cannot update status from '${account.status}' 
                  to '${status}'`,
                code: INVALID_STATE_TRANSITION,
            };
        }
    }
    //check for available type and transition
    if (type) {
        const allowedTypes = availableAccountTypesForUpdate[account
          .type];
        if (!allowedTypes.includes(type)) {
            return {
                error: `cannot update type from '${account.type}' to 
                  '${type}'`,
                code: INVALID_TYPE_TRANSITION,
            };
        }
    }
    account.status = status ?? account.status;
    account.type = type ?? account.type;
    account.name = name ?? account.name;
    account.number = number ?? account.number;
    account.updatedAt = Date.now();
    await account.save();
    return account;
}</pre>			<p>In the end, we need to export the required code blocks so that they can be used by <span class="No-Break">other</span><span class="No-Break"><a id="_idIndexMarker347"/></span><span class="No-Break"> services:</span></p>
			<pre class="source-code">
module.exports = {
    getAccountById,
    getAllAccounts,
    createAccount,
    updateAccountById,
    deleteAccountById,
    errorCodes: {
        NO_VALID_DATA_TO_UPDATE,
        INVALID_STATUS_CODE,
        INVALID_TYPE_CODE,
        INVALID_ACCOUNT,
        INVALID_STATE_TRANSITION,
        INVALID_TYPE_TRANSITION,
    },
};</pre>			<p>We have the following checks before updating our <span class="No-Break">account information:</span></p>
			<ul>
				<li>Only allow an update to occur if one of the fields <span class="No-Break">is provided.</span></li>
				<li>Return an error if an invalid status code <span class="No-Break">is provided.</span></li>
				<li>Return an error if an invalid type <span class="No-Break">is provided.</span></li>
				<li>If the account for the given ID doesn’t exist, we need to return <span class="No-Break">the error.</span></li>
			</ul>
			<p>We have some rules to update the status. First, <strong class="source-inline">availableAccountStatusesForUpdate</strong> describes the rules: if the status is <strong class="source-inline">new</strong>, then it can be updated to <strong class="source-inline">active</strong> or <strong class="source-inline">blocked</strong>. For <strong class="source-inline">active</strong>, it is possible to update to <strong class="source-inline">inactive</strong> and <strong class="source-inline">blocked</strong>. If the status is <strong class="source-inline">inactive</strong>, then only <strong class="source-inline">active</strong> is allowed. The <strong class="source-inline">blocked</strong> status can only be transitioned <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">active</strong></span><span class="No-Break">.</span></p>
			<p>These are not all the <a id="_idIndexMarker348"/>possible validations you can implement, but they show how you can apply check logic to update functionality. In the end, we expose functions with error codes outside to be used by the <span class="No-Break">preceding layer.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>Implementing the controller</h2>
			<p>In a Node.js project using the MVC pattern, the controller acts as the central nervous system, handling user requests and coordinating the application’s response. It is the first point of contact for incoming<a id="_idIndexMarker349"/> requests from the user. It interprets the URL, HTTP method (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and so on), and any parameters included in the request. The controller, by its nature, doesn’t implement the business logic itself; instead, it directs the flow of the application based on the request. It might interact with the model to retrieve or manipulate data, or it could perform some basic validation or processing before <span class="No-Break">moving on.</span></p>
			<p>The controller interacts with the model to get the data needed to fulfill the user’s request. This could involve fetching data from a database, performing calculations, or any other operations defined in the <span class="No-Break">model layer.</span></p>
			<p>Once the controller has the data or has processed the request, it selects the appropriate view to render the response for the classical UI application. It might also prepare the data so that it can be consumed by the view, such as formatting it into a specific template. In our case, we don’t have a complete UI, and our JSON representation of data acts as a UI <span class="No-Break">for us.</span></p>
			<p>Finally, the controller generates the response that gets sent back to the user. This could be an HTML page, JSON data for an API, or any other format suitable for <span class="No-Break">the request.</span></p>
			<p>In essence, the controller acts as a middleman, managing the communication flow between the user (through the view) and the data layer (through the model). It keeps the view and model separate, promoting cleaner code and <span class="No-Break">easier maintenance.</span></p>
			<p>To implement a controller mechanism in our project, we need to create a folder called <strong class="source-inline">controllers</strong> under the <strong class="source-inline">src</strong> folder and add a new JavaScript file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">account.js</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const accountService = require('../services/account');
const getAccounts = async (req, res) =&gt; {
    const result = await accountService.getAllAccounts();
    res.status(200).json({ success: true, account: result.map(x =&gt; 
      mapToResponse(x)) });
};
const createAccount = async (req, res) =&gt; {
    const { name, number, type, status } = req.body;
    const result = await accountService.createAccount(name, number, 
      type, status);
    res.status(201).json({
        success: true,
        Account: mapToResponse(result),
    });
};
const deleteAccountById = async (req, res) =&gt; {
    const isDeleted = await accountService.deleteAccountById(req
      .params.id);
    if(isDeleted)
     res.status(204).json({
         success: true
     });
     else
     res.status(400).json({ success: false, message: 'No valid data to 
       delete' });
 };</pre>			<p>Things are straightforward when it comes to implementing retrieve (get), create, and delete accounts. However, we should consider some additional factors when we update our <span class="No-Break">account information:</span></p>
			<p>First, <strong class="source-inline">getAccounts</strong> calls the <strong class="source-inline">getallAcccounts</strong> service function and returns <span class="No-Break"><strong class="source-inline">200</strong></span><span class="No-Break"> responses.</span></p>
			<p>Then, <strong class="source-inline">createAccount</strong> calls the same named function from the service and returns <strong class="source-inline">201</strong>, which means the<a id="_idIndexMarker350"/> resource has <span class="No-Break">been created.</span></p>
			<p>Finally, <strong class="source-inline">deleteAccountById</strong> calls the same named function from the service and returns <strong class="source-inline">204</strong>, which means success with no content. If the delete operation fails, it will return a <strong class="source-inline">400</strong> <span class="No-Break">status code.</span></p>
			<p>Next, let’s take a look at the <span class="No-Break">update implementation:</span></p>
			<pre class="source-code">
const updateAccountById = async (req, res) =&gt; {
    const result = await accountService.updateAccountById(
      req.params.id, req.body);
    if (result.error) {
        switch (result.code) {
            case accountService.errorCodes.NO_VALID_DATA_TO_UPDATE:
                res.status(400).json({ success: false, message: 
                  result.error });
                return;
            case accountService.errorCodes.INVALID_STATUS_CODE:
                res.status(400).json({ success: false, message: 
                  'invalid status' });
                return;
            case accountService.errorCodes.INVALID_TYPE_CODE:
                res.status(400).json({ success: false, message: 
                  'invalid type' });
                return;
            case accountService.errorCodes.INVALID_ACCOUNT:
                res.status(404).json({ success: false, message: 
                  'Account not found' });
                return;
            case accountService.errorCodes.INVALID_STATE_TRANSITION:
                res.status(400).json({ success: false, message: 
                  result.error });
                return;
            case accountService.errorCodes.INVALID_TYPE_TRANSITION:
                res.status(400).json({ success: false, message: 
                  result.error });
                return;
            default:
                res.status(500).json({ success: false, message: 
                  'internal server error' });
                return;
        }
    }
    res.status(200).json({
        success: true,
        Account: mapToResponse(result),
    });
};</pre>			<p>Here, <strong class="source-inline">updateAccountById</strong> has a few more lines of code. Based on exported error codes, it prepares different HTTP status codes. If the provided data is valid, it returns a <strong class="source-inline">200</strong> <span class="No-Break">success code.</span></p>
			<p>We also have a simple<a id="_idIndexMarker351"/> function called <strong class="source-inline">mapToResponse</strong>. In Node.js, <strong class="source-inline">mapToResponse</strong> serves as a utility function to transform or map an account object to a specific format or structure that’s suitable for sending as a response, typically in an API. Here’s what it <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
function mapToResponse(account) {
    const {
        id, name, number, type, status,
    } = account;
    return {
        id,
        name,
        number,
        type,
        status
    };
}
module.exports = {
    getAccountById,
    getAccounts,
    createAccount,
    deleteAccountById,
    updateAccountById,
};</pre>			<p>The only additional <strong class="source-inline">private</strong> function that we haven’t exported is <strong class="source-inline">mapToResponse</strong>. As you know, the user <a id="_idIndexMarker352"/>may not need to retrieve the whole account data structure. Using this function, we only return the required fields to the user as <span class="No-Break">a response.</span></p>
			<p>The final piece of code is retrieving the account by <span class="No-Break">ID (</span><span class="No-Break"><strong class="source-inline">getAccountById</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
const accountService = require('../services/account');
const getAccountById = async (req, res) =&gt; {
    const result = await accountService.getAccountById(req.params.id);
    if (result) {
        res.status(200).json({ success: true, account:
          mapToResponse(result) });
    } else {
        res.status(404).json({ success: false, message: 'Account not 
          found' });
    }
};</pre>			<p>Here, <strong class="source-inline">getAccountById</strong> redirects the query to the appropriate service and, based on the service’s response, returns a success or not <span class="No-Break">found message.</span></p>
			<p>In the end, to use the main controller functions in the routing process, we must <span class="No-Break">export them.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>Simple data validation for your API</h2>
			<p>Unvalidated data can lead to unexpected behavior, errors, and security vulnerabilities. Validation helps ensure <a id="_idIndexMarker353"/>that data received from users or external sources conforms to your <span class="No-Break">application’s expectations.</span></p>
			<p>Malicious users might try to inject invalid or unexpected data into your application. Validation helps prevent these attacks by rejecting data that doesn’t adhere to the <span class="No-Break">defined rules.</span></p>
			<p>By defining validation rules upfront, you can catch errors early in the development process, reducing debugging time and improving <span class="No-Break">code maintainability.</span></p>
			<p>Let’s create a validation folder under <strong class="source-inline">src</strong> with the <strong class="source-inline">account.js</strong> file that contains the following lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const Joi = require('joi');
const objectId = Joi.string().regex(/^[0-9a-fA-F]{24}$/);
const getAccountById = {
  params: Joi.object().keys({
    id: objectId.required(),
  }),
};
const deleteAccountById = {
  params: Joi.object().keys({
    id: objectId.required(),
  }),
};
const createAccount = {
  body: Joi.object().keys({
    name: Joi.string().required(),
    number: Joi.string().required(),
    status: Joi.string().valid('new', 'active', 'completed', 
      'cancelled').optional(),
    type: Joi.string().valid('root', 'sub').optional(),
  }),
};</pre>			<p>Let’s take a closer<a id="_idIndexMarker354"/> look at <span class="No-Break">the code:</span></p>
			<ul>
				<li>After installing the <strong class="source-inline">Joi</strong> package, it is enough to specify it in the <span class="No-Break"><strong class="source-inline">require</strong></span><span class="No-Break"> command.</span></li>
				<li>The regular expression defines a rule to validate the ID. We’ll use this ID for <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> operations.</span></li>
				<li><strong class="source-inline">const createAccount = { ... }</strong>: This line declares a constant variable named <strong class="source-inline">createAccount</strong> and assigns an object literal to it. This object will hold the validation schema for creating <span class="No-Break">an account.</span></li>
				<li><strong class="source-inline">body</strong>: This property name specifies that the validation schema applies to the request body (typically, data sent in the body of a <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request).</span></li>
				<li><strong class="source-inline">Joi.object()</strong>: This creates a Joi object schema that validates the structure (presence of specific properties) of the <span class="No-Break">request body.</span></li>
				<li><strong class="source-inline">.keys({ ... })</strong>: This defines the set of properties to be expected in the request body and their corresponding <span class="No-Break">validation rules.</span></li>
				<li><strong class="source-inline">name: Joi.string().required()</strong>: This validates the presence of a property named <strong class="source-inline">name</strong> and ensures it’s a string value. The <strong class="source-inline">.required()</strong> part makes <span class="No-Break">it mandatory.</span></li>
				<li><strong class="source-inline">number: Joi.string().required()</strong>: Similar to <strong class="source-inline">name</strong>, this validates a required string property <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">status: Joi.string().valid('new', 'active', 'completed', 'cancelled').optional()</strong>: This validates an optional string property named <strong class="source-inline">status</strong>. The <strong class="source-inline">.valid()</strong> method restricts the allowed values to <strong class="source-inline">'new'</strong>, <strong class="source-inline">'active'</strong>, <strong class="source-inline">'completed'</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">'cancelled'</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">type: Joi.string().valid('root', 'sub').optional()</strong>: Similar to <strong class="source-inline">status</strong>, this validates an optional string property named <strong class="source-inline">type</strong> with allowed values of <strong class="source-inline">'root'</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">'sub'</strong></span><span class="No-Break">.</span></li>
				<li>In general, the preceding code ensures that a request to create an account must include the<a id="_idIndexMarker355"/> <span class="No-Break">following properties:</span><ul><li><strong class="source-inline">name</strong>: Required <span class="No-Break">string value</span></li><li><strong class="source-inline">number</strong>: Required <span class="No-Break">string value</span></li><li><strong class="source-inline">status</strong>: An optional string value that is either <strong class="source-inline">'new'</strong>, <strong class="source-inline">'active'</strong>, <strong class="source-inline">'completed'</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">'cancelled'</strong></span></li><li><strong class="source-inline">type</strong>: An optional string value that is either <strong class="source-inline">'root'</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">'sub'</strong></span></li></ul></li>
			</ul>
			<p>By using this schema, you can guarantee that the data that’s received for creating an account adheres to the expected format and prevents unexpected or invalid data from entering <span class="No-Break">your application:</span></p>
			<pre class="source-code">
const updateAccountById = {
  params: Joi.object().keys({
    id: objectId.required(),
  }),
  body: Joi.object().keys({
    name: Joi.string().required(),
    number: Joi.string().required(),
    status: Joi.string().valid('new', 'active', 'completed', 
      'cancelled').optional(),
    type: Joi.string().valid('root', 'sub').optional(),
  }),
};
module.exports = {
  getAccountById,
  createAccount,
  deleteAccountById,
  updateAccountById,
};</pre>			<p>The <strong class="source-inline">updateAccountById</strong> object specifies that the parameters must include an <strong class="source-inline">id</strong> parameter, which is required and must be a valid object ID. The <strong class="source-inline">body</strong> part of the request must contain <strong class="source-inline">name</strong> and <strong class="source-inline">number</strong> fields, both of which are required strings, and optionally a <strong class="source-inline">status</strong> field that can only be one of the specified values <strong class="source-inline">('new'</strong>, <strong class="source-inline">'active'</strong>, <strong class="source-inline">'completed'</strong>, or <strong class="source-inline">'cancelled'</strong>) and a <strong class="source-inline">type</strong> field that can be either <strong class="source-inline">'root'</strong> or <strong class="source-inline">'sub'</strong>. This <a id="_idIndexMarker356"/>validation ensures that incoming requests to update an account adhere to the expected format and data types. In the end, to use these rules, we need to export them <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">module.exports</strong></span><span class="No-Break">.</span></p>
			<p>We have another module related to data validation that’s placed in the <strong class="source-inline">middleware</strong> folder under the <strong class="source-inline">src</strong> folder. <strong class="bold">Middleware</strong> refers to<a id="_idIndexMarker357"/> functions that can intercept and manipulate both incoming requests and outgoing responses before they reach their designated route handlers. Create<a id="_idIndexMarker358"/> the <strong class="source-inline">validate.js</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
const Joi = require('joi');
function take(object, keys) {
    return Object.assign({}, ...keys
        .filter(key =&gt; object.hasOwnProperty(key))
        .map(key =&gt; ({ [key]: object[key] })));
}
function validate(schema) {
    return (req, res, next) =&gt; {
        // Extract relevant parts of the schema based on request type
        const selectedSchema = take(schema, ['params', 'query', 
          'body']);
        const objectToValidate = take(req, 
          Object.keys(selectedSchema));
        // Perform Joi validation with improved error handling
        const { error, value } = Joi.compile(selectedSchema)
            .prefs({ errors: { label: 'key' }, abortEarly: false })
            .validate(objectToValidate);
        if (error) {
            const errorMsg = error.details.map(d =&gt; d.message).join(', 
              ');
            return res.status(400).json({ success: false, message: 
              errorMsg });
        }
        // Attach validated data to the request object
        Object.assign(req, value);
        next();
    };
}</pre>			<p>If an error exists, the middleware extracts individual error messages using <strong class="source-inline">error.details.map(...)</strong> and joins them into a comma-separated string (<strong class="source-inline">errorMessage</strong>). A <strong class="source-inline">400 Bad Request</strong> response is sent with the error message in <span class="No-Break">JSON format.</span></p>
			<p>If validation passes (<strong class="source-inline">!error</strong>), the validated data (value) obtained from Joi is attached to the <strong class="source-inline">req</strong> object <a id="_idIndexMarker359"/>using <strong class="source-inline">Object.assign</strong>. This makes the validated data readily available in subsequent <span class="No-Break">route handlers.</span></p>
			<p>This middleware acts as a gatekeeper for your routes, ensuring that incoming requests adhere to the provided <span class="No-Break">validation schema.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>Implementing routing</h2>
			<p><strong class="bold">Routing</strong> is a fundamental <a id="_idIndexMarker360"/>aspect of building<a id="_idIndexMarker361"/> web applications with Node.js and Express. It essentially directs incoming HTTP requests to the appropriate handlers within <span class="No-Break">your application.</span></p>
			<p>Routing allows you to define a clear separation between URLs (endpoints) and the code that handles them. This promotes modularity and makes your code base more readable <span class="No-Break">and manageable.</span></p>
			<p>It also enables you to define handlers specific to each HTTP method for a particular URL. This allows you to handle requests for retrieving data (<strong class="source-inline">GET</strong>), submitting data (<strong class="source-inline">POST</strong>), updating data (<strong class="source-inline">PUT</strong>), or deleting data (<span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">) appropriately.</span></p>
			<p>By defining routes that map to resources and corresponding HTTP methods, you can establish a well-structured and predictable API that other applications can <span class="No-Break">interact with.</span></p>
			<p>As your application evolves, routing <a id="_idIndexMarker362"/>helps you easily add new features <span class="No-Break">and functionalities.</span></p>
			<p>You can create separate route handlers for new features, keeping your code base organized <span class="No-Break">and scalable.</span></p>
			<p>Routing also allows you to <a id="_idIndexMarker363"/>group related routes, promoting the reusability of code across different parts of <span class="No-Break">your application.</span></p>
			<p>In simpler terms, routing acts like a traffic controller for your application, directing incoming requests to the designated destinations (handlers) based on their URLs and HTTP methods. This keeps your code organized and maintainable and enables you to build robust and scalable web applications <span class="No-Break">and APIs.</span></p>
			<p>We have a <strong class="source-inline">routes</strong> folder under the <strong class="source-inline">src</strong> folder where we define all the routing rules for our application. Currently, it is our first version, so the <strong class="source-inline">v1</strong> folder indicates the first version of our API. <strong class="bold">Versioning</strong> allows <a id="_idIndexMarker364"/>you to introduce changes while maintaining compatibility with <span class="No-Break">existing clients.</span></p>
			<p>Let’s add the <strong class="source-inline">accounts</strong> folder and the <strong class="source-inline">index.js</strong> file to our <strong class="source-inline">v1</strong> folder and define our <span class="No-Break">routing rules.</span></p>
			<p>The full path to the file will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">src/routers/v1/accounts/index.js</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const { Router } = require('express');
const accountController = require('../../../controllers/account');
const accountValidation = require('../../../validation/account');
const validate = require('../../../middlewares/validate');
const router = Router();
router.get('/', accountController.getAccounts);
router.get('/:id',
  validate(accountValidation.getAccountById),
  accountController.getAccountById);
router.post('/',
  validate(accountValidation.createAccount),
  accountController.createAccount);
router.put('/:id',
  validate(accountValidation.updateAccountById),
  accountController.updateAccountById);
router.delete('/:id',
  validate(accountValidation.deleteAccountById),
  accountController.deleteAccountById);
module.exports = router;</pre>			<p>Express.js provides routing functionality. Using it, we’ve defined <span class="No-Break">the following:</span></p>
			<ul>
				<li>Users can <em class="italic">get</em> an account by ID <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">/accounts/:id</strong></span></li>
				<li>Users can <em class="italic">create</em> a <a id="_idIndexMarker365"/>new account by sending a <strong class="source-inline">POST</strong> request <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/accounts</strong></span></li>
				<li>Users can <em class="italic">update</em> an account by ID sending a <strong class="source-inline">PUT</strong> request <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/accounts/:id</strong></span></li>
				<li>Users can <em class="italic">delete</em> an account by ID sending a <strong class="source-inline">DELETE</strong> request <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/accounts/:id</strong></span></li>
			</ul>
			<p>The validation middleware ensures that requests adhere to the expected format before reaching the controller functions, which handle the actual account <span class="No-Break">management logic.</span></p>
			<p>As you might have guessed, we don’t have any indicator for our route to be used with the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">accounts</strong></span><span class="No-Break"> prefix.</span></p>
			<p>We need one more JavaScript file to handle this. Let’s create <strong class="source-inline">index.js</strong> under the <strong class="source-inline">routes/v1</strong> folder with<a id="_idIndexMarker366"/> the <span class="No-Break">following implementation:</span></p>
			<pre class="source-code">
const { Router } = require('express');
const accountRouter = require('./accounts');
const router = Router();
router.use('/accounts', accountRouter);
module.exports = router;
module.exports = router;</pre>			<p>Now, we’ll be able to<a id="_idIndexMarker367"/> navigate to our resource using the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">accounts</strong></span><span class="No-Break"> prefix.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Constructing our web application</h2>
			<p>Now, it’s time to define our <a id="_idIndexMarker368"/>basic structure for a Node.js application using the <span class="No-Break">Express.js framework.</span></p>
			<p>Let’s create an <strong class="source-inline">app.js</strong> file under the <strong class="source-inline">src</strong> folder with the following <span class="No-Break">code structure:</span></p>
			<pre class="source-code">
const express = require('express');
const v1 = require('./routes/v1');
const app = express();
// service
app.use(express.json());
// V1 API
app.use('/v1', v1);
module.exports = app;</pre>			<p>This code snippet defines a<a id="_idIndexMarker369"/> basic structure for building our <span class="No-Break">web application:</span></p>
			<ul>
				<li><strong class="source-inline">const express = require('express');</strong>: This line imports the Express.js framework, providing functionalities for building web servers and handling HTTP requests <span class="No-Break">and responses.</span></li>
				<li><strong class="source-inline">const v1 = require('./routes/v1');</strong>: This line imports a module named <strong class="source-inline">v1.js</strong> located in a folder named <strong class="source-inline">routes/v1</strong>. This module defines routes (URL paths) for version 1 of your <span class="No-Break">application’s API.</span></li>
				<li><strong class="source-inline">const app = express();</strong>: This line creates an instance of the Express application using the <strong class="source-inline">express()</strong> function. This <strong class="source-inline">app</strong> object will be used to define routes and middleware, as well as handle <span class="No-Break">application logic.</span></li>
				<li><strong class="source-inline">.use(express.json())</strong>: This line registers a middleware function with the Express application. The <strong class="source-inline">express.json()</strong> middleware parses incoming JSON data in request bodies, making it accessible in your <span class="No-Break">route handlers.</span></li>
				<li><strong class="source-inline">.use('/v1', v1);</strong>: This line is crucial for routing. It mounts the routes defined in the imported <strong class="source-inline">v1</strong> module onto the <strong class="source-inline">/v1</strong> path of your application. Any requests to URLs starting with <strong class="source-inline">/v1</strong> will be handled by the functions in the <span class="No-Break"><strong class="source-inline">v1</strong></span><span class="No-Break"> module.</span></li>
				<li><strong class="source-inline">module.exports = app;</strong>: This line exports the <strong class="source-inline">app</strong> object, which is the core of your Express application. This allows other modules in your project to import and use this <span class="No-Break">application instance.</span></li>
			</ul>
			<p>In essence, this code creates an Express application, configures middleware for JSON handling, mounts routes<a id="_idIndexMarker370"/> from a separate module for version 1 of your API, and makes the application instance available for import by other parts of <span class="No-Break">your project.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Combining all the elements</h2>
			<p>The final step in our <a id="_idIndexMarker371"/>application is to construct everything together, like using Lego. This Lego is going to be a main runnable application that will help us to communicate between elements of <span class="No-Break">our application.</span></p>
			<p>Let’s create an <strong class="source-inline">index.js</strong> file under the <strong class="source-inline">src</strong> folder that contains the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const path = require('path');
const db = require('./db');
const app = require('./app');
const { createConfig } = require('./config/config');
async function execute() {
    const configPath = path.join(__dirname, '../configs/.env');
    const appConfig = createConfig(configPath);
    await db.connect(appConfig);
    const server = app.listen(appConfig.port, () =&gt; {
        console.log('account service started', { port: appConfig.port 
          });
    });
    const closeServer = () =&gt; {
        if (server) {
            server.close(() =&gt; {
                console.log('server closed');
                process.exit(1);
            });
        } else {
            process.exit(1);
        }
    };
    const unexpectedError = (error) =&gt; {
        console.log('unhandled error', { error });
        closeServer();
    };
    process.on('uncaughtException', unexpectedError);
    process.on('unhandledRejection', unexpectedError);
}
execute();</pre>			<p>This Node.js code defines <a id="_idIndexMarker372"/>an asynchronous function named <strong class="source-inline">execute</strong> that serves as the entry point for your application. Here’s a breakdown of <span class="No-Break">its functionality:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Importing modules</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">const path = require('path');</strong>: Imports the <strong class="source-inline">path</strong> module for manipulating <span class="No-Break">file paths</span></li><li><strong class="source-inline">const db = require('./db');</strong>: Imports the <strong class="source-inline">db</strong> module, likely containing functions for connecting and interacting with <span class="No-Break">your database</span></li><li><strong class="source-inline">const app = require('./app');</strong>: Imports the main application module, likely containing the Express application instance and your <span class="No-Break">application logic</span></li><li><strong class="source-inline">const { createConfig } = require('./config/config');</strong>: Imports the <strong class="source-inline">createConfig</strong> function from the <strong class="source-inline">config/config.js</strong> module, likely responsible for creating your <span class="No-Break">application configuration</span></li></ul></li>
				<li><strong class="bold">Configuration </strong><span class="No-Break"><strong class="bold">setup (async)</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">async function execute() { ... }</strong>: Defines an asynchronous function named <strong class="source-inline">execute</strong> that will be executed when the <span class="No-Break">script starts</span></li><li><strong class="source-inline">const configPath = path.join(__dirname, '../configs/.env');</strong>: Uses the <strong class="source-inline">path</strong> module to construct the absolute path to your configuration file (likely a <strong class="source-inline">.env</strong> file) two directories above the <a id="_idIndexMarker373"/>current <span class="No-Break">script’s location</span></li><li><strong class="source-inline">const appConfig = createConfig(configPath);</strong>: Calls the imported <strong class="source-inline">createConfig</strong> function with the configuration file path, presumably to read and parse the <span class="No-Break">configuration settings</span></li></ul></li>
				<li><strong class="bold">Database </strong><span class="No-Break"><strong class="bold">connection (async)</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">await db.connect(appConfig);</strong>: Attempts to connect to the database using the <strong class="source-inline">db</strong> module and the loaded configuration (<strong class="source-inline">appConfig</strong>) object. This line is asynchronous, so the function waits for the connection to be established <span class="No-Break">before proceeding.</span></li></ul></li>
				<li><strong class="bold">Starting </strong><span class="No-Break"><strong class="bold">the server</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">const server = app.listen(appConfig.port, ...);</strong>: Calls a method (likely <strong class="source-inline">listen</strong>) on the imported <strong class="source-inline">app</strong> object, which is probably an Express application. This starts the server listening on the port specified in the configuration (<strong class="source-inline">appConfig.port</strong>). The callback function logs a message when the server <span class="No-Break">starts successfully.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Graceful shutdown</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">const closeServer = () =&gt; { ... }</strong>: Defines an arrow function named <strong class="source-inline">closeServer</strong> that gracefully shuts down the server. It checks whether the server object exists and then calls its <strong class="source-inline">close</strong> method. The callback function for <strong class="source-inline">close</strong> logs a message when the server is closed and exits the <a id="_idIndexMarker374"/>process with an exit code <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Error handling</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">const unexpectedError = (error) =&gt; { ... }</strong>: Defines an arrow function named <strong class="source-inline">unexpectedErrorHandler</strong> that handles uncaught errors or unhandled promise rejections. It logs the error message. It calls the <strong class="source-inline">closeServer</strong> function to gracefully shut down <span class="No-Break">the server</span></li></ul></li>
				<li><strong class="bold">Attaching </strong><span class="No-Break"><strong class="bold">event listeners</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">process.on('uncaughtException', unexpectedError);</strong>: Attaches the <strong class="source-inline">unexpectedErrorHandler</strong> function to the <strong class="source-inline">uncaughtException</strong> event of the <strong class="source-inline">process</strong> object. This ensures that any errors thrown outside of an <strong class="source-inline">async</strong> function or promise chain are caught <span class="No-Break">and handled.</span></li><li><strong class="source-inline">process.on('unhandledRejection', unexpectedError);</strong>: Attaches the <strong class="source-inline">unexpectedErrorHandler</strong> function to the <strong class="source-inline">unhandledRejection</strong> event of the <strong class="source-inline">process</strong> object. This ensures that any unhandled rejections from promises are caught <span class="No-Break">and handled.</span></li></ul></li>
				<li><strong class="bold">Running </strong><span class="No-Break"><strong class="bold">the application</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">execute();</strong>: Calls the <strong class="source-inline">execute</strong> function to start the application. Since <strong class="source-inline">execute</strong> is asynchronous, the entire application startup process becomes asynchronous, ensuring<a id="_idIndexMarker375"/> the database connection and server startup are completed before the <span class="No-Break">application continues.</span></li></ul></li>
			</ul>
			<p>In summary, this code sets up the application configuration, connects to the database, starts the server, and implements error handling for a robust and graceful startup and <span class="No-Break">shutdown process.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>Running and testing our first microservice</h1>
			<p>We’re not going to write any unit or integrate tests in this chapter. In <a href="B09148_11.xhtml#_idTextAnchor174"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, where we’ll dive into the<a id="_idIndexMarker376"/> details of those topics. For this chapter, we’ll do manual testing via Postman. To run our <a id="_idIndexMarker377"/>application, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Download <strong class="source-inline">Ch05</strong> from our <span class="No-Break">GitHub repository.</span></li>
				<li>Open the project (<strong class="source-inline">Ch05</strong>) via Visual <span class="No-Break">Studio Code.</span></li>
				<li>Go to <strong class="bold">Terminal</strong> | <span class="No-Break"><strong class="bold">New Terminal</strong></span><span class="No-Break">.</span></li>
				<li>Run the <strong class="source-inline">npm install</strong> command from the <strong class="source-inline">Ch05</strong> folder to load the <span class="No-Break">required packages.</span></li>
				<li>Change directories to <strong class="source-inline">src</strong> (using the <strong class="source-inline">cd </strong><span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> command).</span></li>
				<li>Run the <strong class="source-inline">node index.js</strong> command. Mongo should be installed before you run this command. Check out <a href="B09148_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> for more information about the installation process <span class="No-Break">for</span><span class="No-Break"><a id="_idIndexMarker378"/></span><span class="No-Break"> Mongo.</span></li>
				<li><span class="No-Break">Open Postman.</span></li>
			</ol>
			<p>In the next few <a id="_idIndexMarker379"/>subsections, we’ll test our endpoints one <span class="No-Break">by one.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Creating a new account</h2>
			<p>To create a new account, follow<a id="_idIndexMarker380"/> <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new tab <span class="No-Break">in Postman.</span></li>
				<li>Select <strong class="source-inline">POST</strong> from <span class="No-Break"><strong class="bold">HTTP verbs</strong></span><span class="No-Break">.</span></li>
				<li>Type <strong class="source-inline">localhost:3001/v1/accounts</strong> in the <span class="No-Break"><strong class="bold">URL</strong></span><span class="No-Break"> section.</span></li>
				<li>Go to the <strong class="bold">Body</strong> section. Select <strong class="source-inline">raw</strong> and change <strong class="source-inline">Text</strong> to <strong class="source-inline">JSON</strong>. Add the following JSON to the <span class="No-Break">text area:</span><pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "name":"AccName1",</strong>
<strong class="bold">    "number":"Ac21345",</strong>
<strong class="bold">    "type":"root",</strong>
<strong class="bold">    "status":"new"</strong>
<strong class="bold">}</strong></pre></li>				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from <span class="No-Break">the endpoint:</span><pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "Account": {</strong>
<strong class="bold">        "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">        "name": "AccName1",</strong>
<strong class="bold">        "number": "Ac21345",</strong>
<strong class="bold">        "type": "root",</strong>
<strong class="bold">        "status": "new"</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>Now, let’s get the <a id="_idIndexMarker381"/>account <span class="No-Break">by ID.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Getting an account by ID</h2>
			<p>To get an account with the <a id="_idIndexMarker382"/>given ID, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new tab <span class="No-Break">in Postman.</span></li>
				<li>Select <strong class="source-inline">GET</strong> from <span class="No-Break"><strong class="bold">HTTP verbs</strong></span><span class="No-Break">.</span></li>
				<li>Type <strong class="source-inline">localhost:3001/v1/accounts/{accountID}</strong> in the <strong class="bold">URL</strong> section. In our case, <strong class="bold">accountID</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">662c081370bd2ba6b5f04e94</strong></span><span class="No-Break">.</span></li>
				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from <span class="No-Break">the endpoint:</span><pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "account": {</strong>
<strong class="bold">        "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">        "name": "AccName1",</strong>
<strong class="bold">        "number": "Ac21345",</strong>
<strong class="bold">        "type": "root",</strong>
<strong class="bold">        "status": "new"</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>Now, let’s learn how to <a id="_idIndexMarker383"/>update our <span class="No-Break">existing account.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Updating an account by ID</h2>
			<p>To update your given <a id="_idIndexMarker384"/>account, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new tab <span class="No-Break">in Postman.</span></li>
				<li>Select <strong class="source-inline">PUT</strong> from <span class="No-Break"><strong class="bold">HTTP verbs</strong></span><span class="No-Break">.</span></li>
				<li>Type <strong class="source-inline">localhost:3001/v1/accounts/{accountID}</strong> in the <span class="No-Break">URL section.</span></li>
				<li>Go to the <strong class="bold">Body</strong> section. Select <strong class="source-inline">raw</strong> and change <strong class="source-inline">Text</strong> to <strong class="source-inline">JSON</strong>. Add the following JSON to the <span class="No-Break">text area:</span><pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "name":"updated account",</strong>
<strong class="bold">    "number":"AE33333"</strong>
<strong class="bold">}</strong></pre></li>				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from <span class="No-Break">the endpoint:</span><pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "Account": {</strong>
<strong class="bold">        "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">        "name": "updated account",</strong>
<strong class="bold">        "number": "AE33333",</strong>
<strong class="bold">        "type": "root",</strong>
<strong class="bold">        "status": "new"</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>For most of the APIs, we <a id="_idIndexMarker385"/>usually want to retrieve all data. Next, we’ll learn how to get all <span class="No-Break">account information.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Gettings all accounts</h2>
			<p>To retrieve all accounts, follow<a id="_idIndexMarker386"/> <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new tab <span class="No-Break">in Postman.</span></li>
				<li>Select <strong class="source-inline">GET</strong> from <span class="No-Break"><strong class="bold">HTTP verbs</strong></span><span class="No-Break">.</span></li>
				<li>Type <strong class="source-inline">localhost:3001/v1/accounts</strong> in the <span class="No-Break"><strong class="bold">URL</strong></span><span class="No-Break"> section.</span></li>
				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get the following response from <span class="No-Break">the endpoint:</span><pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">    "success": true,</strong>
<strong class="bold">    "account": [</strong>
<strong class="bold">        {</strong>
<strong class="bold">            "id": "662c081370bd2ba6b5f04e94",</strong>
<strong class="bold">            "name": "updated account",</strong>
<strong class="bold">            "number": "AE33333",</strong>
<strong class="bold">            "type": "root",</strong>
<strong class="bold">            "status": "new"</strong>
<strong class="bold">        }</strong>
<strong class="bold">    ]</strong>
<strong class="bold">}</strong></pre></li>			</ol>
			<p>The final endpoint<a id="_idIndexMarker387"/> involves deleting the account. Let’s <span class="No-Break">check it.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Deleting account by ID</h2>
			<p>Finally, to delete your <a id="_idIndexMarker388"/>already existing account by its ID, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new tab <span class="No-Break">in Postman.</span></li>
				<li>Select <strong class="source-inline">DELETE</strong> from <span class="No-Break"><strong class="bold">HTTP verbs</strong></span><span class="No-Break">.</span></li>
				<li>Type <strong class="source-inline">localhost:3001/v1/accounts/{accountID}</strong> in the <strong class="bold">URL</strong> section. Provide the valid <strong class="bold">accountID</strong> value to delete <span class="No-Break">the record.</span></li>
				<li>Click the <strong class="bold">Send</strong> button to send the request. You’ll get a <strong class="source-inline">204 no-content</strong> response from <span class="No-Break">the endpoint.</span></li>
			</ol>
			<p>With that, we have fully functional CRUD endpoints for accounts. We may not have a complex business case, but the purpose of this chapter was to show you how to implement endpoints for <span class="No-Break">your microservices.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Summary</h1>
			<p>In this chapter, we created our first microservice. This was our first practical chapter about creating microservices. For this, having a clear understanding of your requirements is important. We provided simple requirements to make our first microservice more understandable and easy to follow. There, we learned how to set up our project. We talked about the tools we need to develop our first microservice; before every microservice development process can be undertaken, we need to define which tools and technologies we plan to use. We also created our internal structure using MVC and N-layered architecture. These are the most popular choices, so using them for your first development project is a great chance for you to learn popular techniques. The practical aspect of this chapter covered creating models, business logic, and controllers. There, we learned about the basics of validation using the JOI package. The application requires a separate file to store configuration, hence why we used the <strong class="source-inline">dotenv</strong> package. We also learn about routing, which is important if we wish to access our functionalities. Then, we integrated routing <span class="No-Break">using Express.js.</span></p>
			<p>In the end, we learned how to check our functionalities using Postman. In the upcoming chapters, we will delve into the development of a second microservice, focusing on establishing synchronous communication between microservices. We will introduce a new stack for the transaction microservice, using tools like NestJS, Prisma, and Axios, to demonstrate the versatility of JavaScript in <span class="No-Break">microservice development.</span></p>
		</div>
	</body></html>