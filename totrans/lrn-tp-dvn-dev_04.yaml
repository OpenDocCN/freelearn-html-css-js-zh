- en: Grouping Values Together in Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类型中组合值
- en: In the previous chapter, we saw a way to group types and values together so
    that they can be accessed under a single namespace, and we saw how these namespaces
    (modules) themselves have types. Modules are not, however, convenient for passing
    around values during runtime. We need a lightweight way to build more structured
    types out of simpler types, to model real-world problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了一种将类型和值组合在一起的方法，以便它们可以在单个命名空间下访问，我们还看到了这些命名空间（模块）本身也有类型。然而，模块在运行时传递值时并不方便。我们需要一种轻量级的方法来从更简单的类型构建更结构化的类型，以模拟现实世界问题。
- en: 'In this chapter, we will cover these structured types, specifically:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍这些结构化类型，特别是：
- en: Record types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录类型
- en: Tuple types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组类型
- en: Object types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类型
- en: JavaScript object types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript对象类型
- en: Collectively, these types are referred to as **product types** because the number
    of possible values a product type can contain is the *product* of the number of
    possible values each of its component types can contain. This is an interesting
    result in type theory, and it gives us a hint to the fact that types obey certain
    algebraic laws. I will provide further reading materials on this later on in the
    book, after we have developed our type knowledge more.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些类型被称为**乘积类型**，因为乘积类型可以包含的可能值的数量是其每个组成部分类型可以包含的可能值的数量的乘积。这是类型理论中的一个有趣的结果，它给我们一个暗示，即类型遵循某些代数定律。我将在本书稍后提供更多阅读材料，在我们对类型知识有更多了解之后。
- en: Record types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录类型
- en: 'We''ve used record types in several places in the book so far, mostly to build
    a `person` type with an ID and a name. Let''s examine this simple record type
    a bit more closely and pick apart what exactly happens when it is created:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中几个地方使用了记录类型，主要是用来构建一个具有ID和名称的`person`类型。让我们更仔细地检查这个简单的记录类型，并分析创建它时究竟发生了什么：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a whole, this type definition creates a new *nominal* type called `person`
    with two named fields: `id` and `name`, with specific `int` and `string` types.
    A nominal type is one that is distinguished by the typechecker from other types
    solely by name.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 整个类型定义创建了一个新的*名义*类型`person`，它有两个命名字段：`id`和`name`，具有特定的`int`和`string`类型。名义类型是类型检查器仅通过名称与其他类型区分的类型。
- en: This is as opposed to structural types, which are considered by the typechecker
    to be equal to their constituent types. For example, we saw in the previous chapter
    that modules are structurally typed. We'll see some more examples in this chapter
    and the next one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这与结构类型相对，结构类型在类型检查器中被认为是其构成类型的等价。例如，我们在上一章中看到模块是结构类型。我们将在本章和下一章中看到更多示例。
- en: 'At any rate, nominal types cannot be used interchangeably, even if they have
    the exact same definition. For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，名义类型不能互换使用，即使它们有完全相同的定义。例如：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding error message, notice that we defined a new record type `person`
    in `Ch03_Greet`, created a value of this type, and tried to call the `greet` function
    with it. But the `greet` function only accepts `Ch02_Demo.person` values and errors
    on our `person` value that have the same structure but a different name (the module
    path is considered to be part of the name for this purpose):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的错误信息中，请注意我们在`Ch03_Greet`中定义了一个新的记录类型`person`，创建了这个类型的值，并尝试用这个值调用`greet`函数。但是`greet`函数只接受`Ch02_Demo.person`类型的值，并在我们的具有相同结构但名称不同的`person`值上出错（在这个目的上，模块路径被认为是名称的一部分）：
- en: '![](img/019817df-50ca-4b34-9ca3-2dd33233086d.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/019817df-50ca-4b34-9ca3-2dd33233086d.png)'
- en: Type mismatch between nominal types with the same definition
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同定义的名义类型之间的类型不匹配
- en: Record literals
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录字面量
- en: 'We can create record values using the record-literal syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用记录字面量语法创建记录值：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are the typical variations of record literals:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是记录字面量的典型变体：
- en: 'Standard record-literal syntax for a record type with the `field1` to `fieldN` fields
    is: `{field1: expression1, ..., fieldN: expressionN}`. Note one of the most significant
    things about records: *field order doesn''t matter.* Here we defined a record
    literal with field names in the opposite order to the record-type definition.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '记录类型的标准记录字面量语法为具有`field1`到`fieldN`字段的记录：`{field1: expression1, ..., fieldN:
    expressionN}`。注意记录的一个最显著特点：*字段顺序不重要*。在这里，我们定义了一个记录字面量，其字段名称的顺序与记录类型定义相反。'
- en: We can start an enclosed scope with brackets so that the names declared inside
    (`id`, `name`) will not be visible from outside, and the last expression (`{id,
    name}`) in the enclosed scope will be the result value of the scope. Note that
    the scope delimiter brackets are separate from the record delimiter brackets.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用括号来开始一个封闭的作用域，这样内部声明的名称（`id`，`name`）将不会对外部可见，并且封闭作用域中的最后一个表达式（`{id, name}`）将是作用域的结果值。请注意，作用域分隔括号与记录分隔括号是分开的。
- en: We can use the *record field punning* syntax to write record literals when there
    is a name in the scope that's identical to the field name. Modern JavaScript has
    gained this punning feature as well.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当作用域中存在与字段名称相同的名称时，我们可以使用*记录字段重命名*语法来编写记录字面量。现代JavaScript也获得了这个重命名功能。
- en: We can fall back on the standard record-literal syntax with any expression if
    we don't have names in the scope identical to the field names.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果作用域中没有与字段名称相同的名称，我们可以使用标准记录字面量语法来使用任何表达式。
- en: Accessing fields and dealing with errors
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问字段和处理错误
- en: 'Record field access syntax looks much like in other languages: `recordValue.fieldName`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记录字段访问语法在其他语言中看起来很相似：`recordValue.fieldName`。
- en: 'To correctly infer the types of record literals though, Reason depends on matching
    up the field names to record types that it knows about. A common error that you
    will see is when Reason can''t find a suitable record type; for example, if we
    delete the `person` type from `Ch04_RecordLiterals`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确推断记录字面量的类型，Reason依赖于将字段名称与它所知道的记录类型匹配。您可能会看到的一个常见错误是当Reason找不到合适的记录类型时；例如，如果我们从`Ch04_RecordLiterals`中删除`person`类型：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This often happens when the record type is defined in another module. We mentioned
    before that Reason doesn''t automatically search through other modules to find
    record types, because different modules could contain record types with the same
    field names; it would be unclear which one you meant. Instead, Reason opts to
    have you be explicit about the module, for example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常发生在记录类型定义在另一个模块中时。我们之前提到，Reason不会自动搜索其他模块以查找记录类型，因为不同的模块可能包含具有相同字段名称的记录类型；这会不清楚您指的是哪一个。相反，Reason选择让您明确指定模块，例如：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now Reason can tell that:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Reason可以告诉我们：
- en: The `id` field you're referring to is in `Ch02_Demo`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您所提到的`id`字段位于`Ch02_Demo`中
- en: The record literal has only the `id` and `name` fields
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录字面量只有`id`和`name`字段
- en: Therefore, the only type this record can possibly be is `Ch02_Demo.person` (it
    can't be `Ch02_Demo.company` because that record type has an `employees` field
    as well)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，这个记录可能只能是`Ch02_Demo.person`类型（它不能是`Ch02_Demo.company`，因为该记录类型也有`employees`字段）
- en: Changing record values
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改记录值
- en: 'Records are by default immutable: once you create one, you can''t change it.
    This is in addition to all Reason values being non-reassignable by default (meaning
    that something such as `let x = 1; x = 2;` is a compile error). This rigidity
    is for good reason: if you know that values can''t change, it becomes really easy
    to think about each part of your program in isolation and then be confident that
    the parts will behave consistently when put back together. This is one of the
    core principles of *functional programming,* which Reason''s statically typed
    techniques are built on.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记录默认是不可变的：一旦创建，就无法更改。这还意味着所有的Reason值默认都是不可重新分配的（这意味着像`let x = 1; x = 2;`这样的代码会导致编译错误）。这种刚性有很好的理由：如果您知道值不会改变，那么单独考虑程序中的每个部分并将它们放在一起时，您会更容易地确信这些部分的行为将是一致的。这是*函数式编程*的核心原则之一，Reason的静态类型技术就是建立在这一点上的。
- en: 'But completely unchangeable values are not very useful. You''ll usually need
    to change values at runtime to model the behaviors you''re interested in. So Reason
    provides two ways to change record values: immutable updates and mutable fields.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但完全不可更改的值并不很有用。通常，您需要在运行时更改值来模拟您感兴趣的行为。因此，Reason提供了两种更改记录值的方法：不可变更新和可变字段。
- en: Immutable updates
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变更新
- en: 'This is what we will be using most of the time. With *immutable updates,* we
    literally create new record values using old ones. Reason provides a special syntax
    for this, which comes in very handy when the record type has two or more fields.
    But no matter how many fields, we can always build record values by just using
    the normal record-literal syntax. The following are some examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将最常使用的方法。使用*不可变更新*，我们实际上使用旧值创建新的记录值。Reason为此提供了一种特殊的语法，当记录类型有两个或更多字段时，它非常有用。但无论字段有多少，我们都可以仅使用正常的记录字面量语法来构建记录值。以下是一些示例：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we update Bob''s name to its long form. Note a couple of things:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将鲍勃的名字更新为其完整形式。请注意以下几点：
- en: When we use the immutable update syntax (also known in Reason as the *record
    spread* syntax), Reason creates a new record value that's identical to the old
    one (`bob`), except for the fields that we override. Also, even though the record
    type is defined in another module, we don't need to use a module prefix for any
    fields, because the immutable update forces Reason to look up what the fields
    are and thus it knows about the `name` field when we update it.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用不可变更新语法（在Reason中也称为*记录展开*语法）时，Reason会创建一个新的记录值，它与旧值（`bob`）完全相同，除了我们覆盖的字段。尽管记录类型定义在另一个模块中，但我们不需要为任何字段使用模块前缀，因为不可变更新强制Reason查找字段是什么，因此当我们更新它时，它知道`name`字段。
- en: 'When we use the normal record-literal syntax, we need to define all the record
    fields. If we forget one, we''ll get a rather interesting type of error:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用正常的记录字面量语法时，我们需要定义所有记录字段。如果我们忘记了一个，我们将会得到一种相当有趣的类型错误：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since Reason doesn''t allow null or undefined values, it''s a type error to
    leave out a record field:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Reason不允许null或undefined值，省略记录字段会导致类型错误：
- en: '![](img/9dc9e2f4-8feb-40ae-a355-791c87f6cba8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dc9e2f4-8feb-40ae-a355-791c87f6cba8.png)'
- en: Missing record field type error
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少记录字段类型错误
- en: 'With immutable updates, we can reuse the same name and not have to worry about
    coming up with new names for various transformed values, thanks to shadowing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变更新，我们可以重用相同的名称，并且不必担心为各种转换值想出新名称，这要归功于阴影：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll often use shadowing to perform a series of updates on some value, to convey
    the intention that we're building or transforming the same value toward a final
    use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用阴影对某个值执行一系列更新，以传达我们正在构建或转换同一个值以用于最终目的的意图。
- en: Mutable record fields
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变记录字段
- en: These are used less often because they introduce an element of unsafety into
    a program, and force the developer to be much more defensive in their code. You
    have a binding of a certain value at one point, and at another point it can be
    a different value, and all other parts of the codebase that were behaving in a
    certain way based on the original value will be in for a big surprise if they
    happen to check again and find the new value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用得比较少，因为它们给程序引入了不安全因素，并迫使开发者更加谨慎地编写代码。你在一个点上绑定了一个特定的值，而在另一个点上它可以是不同的值，如果代码库的其他部分基于原始值以某种方式行为，并且它们再次检查并发现新值，那么它们将会遇到一个大的惊喜。
- en: 'Nevertheless, they can be very useful if you need some extra performance from
    some records, and you keep the mutations contained within the scope of a single
    function. Here''s an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果需要从某些记录中获得一些额外的性能，并且将突变包含在单个函数的作用域内，它们可能非常有用。以下是一个示例：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are quite a few things going on here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情：
- en: We make a record field mutable using the `mutable` keyword before the field
    name. In this case, we make only two out of the three fields mutable, because
    the count never needs to change for a given array.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`mutable`关键字在字段名称之前使记录字段可变。在这种情况下，我们只使三个字段中的两个可变，因为对于给定的数组，计数永远不会改变。
- en: We create a new record of the type with the usual literal syntax; we can use
    `0.` as a shorthand for `0.0` for float literals, and the `Array.length` function
    returns the length of a Reason array.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用常规的文本语法创建一个新记录类型；对于浮点字面量，我们可以使用`0.`作为`0.0`的简写，并且`Array.length`函数返回Reason数组的长度。
- en: We use a `for` loop to iterate over the input array whose statistics we want.
    Reason fully supports imperative programming syntax, such as `for` and `while`
    loops; if you're looking to program in any given style, you'll likely be able
    to do it in Reason.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`for`循环遍历我们想要统计的输入数组。Reason完全支持命令式编程语法，如`for`和`while`循环；如果你想要以任何给定风格编程，你很可能能在Reason中做到。
- en: We sum up the array iteratively, by mutating the `sum` field. Mutating a (mutable)
    record field uses the simple `recordVal.field = value` syntax.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过迭代地修改`sum`字段来累加数组。修改（可变的）记录字段使用简单的`recordVal.field = value`语法。
- en: 'We get the element at the given array index using `Array.unsafe_get`, which
    forgoes a bounds check before getting the element. In this example, we don''t
    need a bounds check because we''ve already made sure we won''t go past the end
    of the array when we started the loop. But if we''d made a mistake, say `for (i
    in 0 to result.count) { ... }`, we''d get a runtime error. So it''s good to be
    very careful with unsafe functions. There''s a safe, bounds-checked syntax for
    array element access: `array[i]`.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Array.unsafe_get`获取给定数组索引处的元素，它获取元素前会跳过边界检查。在这个例子中，我们不需要边界检查，因为我们已经在循环开始时确保不会超出数组的末尾。但如果我们犯了错误，比如`for
    (i in 0 to result.count) { ... }`，我们会得到一个运行时错误。所以对不安全函数要非常小心。数组元素访问有一个安全的、带边界检查的语法：`array[i]`。
- en: After we finish iterating through the entire array, we mutate the `mean` field
    to the final mean value.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们遍历整个数组完成后，我们将`mean`字段变异为最终的均值。
- en: We can't divide the float `sum` by the int `count`, so we need to convert the
    int `count` to a float. Note that we don't go the other way round, that is, convert
    the float `sum` to an int, because that would be a lossy conversion!
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能将浮点数`sum`除以整数`count`，因此我们需要将整数`count`转换为浮点数。请注意，我们不会反过来操作，即不将浮点数`sum`转换为整数，因为这会导致有损转换！
- en: Note how overall we are keeping the mutation inside the bounds of a single function.
    Although, this mutation safety is somewhat undermined by just returning the `summaryStats`
    value with two mutable fields to the caller. In future mutation examples, we'll
    show safer usage patterns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何始终将变异操作限制在单个函数的范围内。尽管如此，仅仅将包含两个可变字段的`summaryStats`值返回给调用者，这种变异安全性多少受到了影响。在未来的变异示例中，我们将展示更安全的用法模式。
- en: 'We''re using slightly different operators for float arithmetic: in Reason,
    integer and float arithmetic are completely separate and they don''t mix. The
    float arithmetic operators are the same as the integer arithmetic ones, except
    with a "`.`" appended to them. The Reason philosophy is very much one of *explicit
    is better than implicit*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浮点数算术中使用略微不同的运算符：在Reason中，整数和浮点数算术是完全分开的，它们不混合。浮点数算术运算符与整数算术运算符相同，只是在它们后面附加了一个"`.`"。Reason的哲学非常强调*显式优于隐式*。
- en: To reiterate, for most purposes, immutable records work very well indeed. Mutable
    record fields come in handy in a limited set of situations, and when we do use
    them, we need to take extra precautions against accidental mutations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重复一遍，对于大多数目的，不可变记录确实非常有效。在某些有限的情况下，可变记录字段很有用，并且当我们使用它们时，我们需要采取额外的预防措施以防止意外的变异。
- en: Record patterns
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录模式
- en: 'In [Chapter 2](ff0971a6-9cf3-4680-8010-47acb7663764.xhtml), *Program with Types
    and Values*, we saw that the general syntax for value bindings is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ff0971a6-9cf3-4680-8010-47acb7663764.xhtml)，*使用类型和值编程*中，我们看到了值绑定的通用语法：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This syntax applies to records too, because record literals also act as patterns.
    In the case of record patterns, we call it *destructuring pattern matching,* because
    we bind names by matching against the structure of the record value and pulling
    out its fields. Here are some examples:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法也适用于记录，因为记录字面量也充当模式。在记录模式的情况下，我们称之为*解构模式匹配*，因为我们通过匹配记录值的结构并将字段拉出来来绑定名称。以下是一些示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These are the possible variations of record patterns:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是记录模式的可能变体：
- en: We globally open the record literals module, to get convenient access to the
    types and values defined there, without having to qualify every time. I didn't
    show this in the previous chapter because I deliberately wanted to de-emphasize
    global openings since they are usually more risky. In controlled cases such as
    this one though, they are OK.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们全局打开了记录字面量模块，以便方便地访问那里定义的类型和值，而无需每次都进行限定。我在上一章中没有展示这一点，因为我故意想淡化全局打开的使用，因为它们通常风险更高。但在这种受控情况下，它们是可以接受的。
- en: Record patterns look just like record literals, except what would be the field
    values are also names (`bobId`, `bobName`) and these names get bound to the actual
    values in the record.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录模式看起来就像记录字面量一样，除了那些原本会是字段值的现在也是名称（`bobId`，`bobName`）并且这些名称被绑定到记录中的实际值。
- en: 'We can use a shortcut if we want to bind a name that''s the same as the field
    name: just omit the colon and field value on the right. We can even mix the two
    styles.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想绑定与字段名相同的名称，可以使用快捷方式：只需在右侧省略冒号和字段值。我们甚至可以混合两种风格。
- en: We can bind only some fields of a record to values, and explicitly not bind
    the other fields by binding them to the underscore symbol, which means ignore.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只能将记录的一些字段绑定到值上，并且通过将它们绑定到下划线符号来显式地不绑定其他字段，这意味着忽略。
- en: We can bind some fields to names and unreservedly ignore the rest using the
    underscore symbol.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将一些字段绑定到名称上，并使用下划线符号无保留地忽略其余部分。
- en: We can bind some fields and ignore the rest by completely omitting them. Reason
    will infer the type of the pattern using the field names it sees but may get confused
    if there are multiple record types defined with the same fields.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过完全省略它们来绑定一些字段并忽略其余部分。Reason 将使用它看到的字段名称来推断模式的类型，但如果定义了具有相同字段的多个记录类型，它可能会感到困惑。
- en: As you can see, the record-pattern syntax is very sophisticated and detailed,
    built up over time as Reason's base language, OCaml, has been in active industrial
    use. It will take a little time to get used to all the patterns; start simple
    and use the more succinct ones as needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，记录模式语法非常复杂和详细，这是随着时间的推移，作为 Reason 的基础语言 OCaml 在积极工业应用中发展起来的。要习惯所有这些模式需要一点时间；从简单开始，并在需要时使用更简洁的模式。
- en: 'One last thing to mention about record patterns: they are also irrefutable
    patterns, just like simple value bindings, such as `let x = 1;`. Irrefutability
    simply means that once a pattern is compiled, there is no way it can fail to match
    against the value on the right-hand side at runtime. By this metric, record patterns
    pass because binding them is just a matter of binding their fields to names, and
    simple name bindings are also irrefutable. But we will see examples of refutable
    patterns in the next chapter, so keep an eye out for them.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于记录模式，还有最后一件事要提：它们也是不可反驳的模式，就像简单的值绑定一样，例如 `let x = 1;`。不可反驳意味着一旦模式被编译，在运行时它无法失败地与右侧的值匹配。根据这个标准，记录模式通过绑定它们只是将它们的字段绑定到名称上，而简单的名称绑定也是不可反驳的。但我们在下一章中会看到可反驳模式的例子，所以请留意它们。
- en: Tuple types
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组类型
- en: '*Tuples* are lightweight, structural types. To be precise, they are types made
    up of other types, joined together within parentheses in a particular order, separated
    by commas, and without field names. The tuple value syntax is very simple–open
    parenthesis, comma-separated list of values, close parenthesis. In fact, the value
    syntax closely mimics the type of the tuples themselves.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 是轻量级的结构化类型。更准确地说，它们是由其他类型组成的类型，以特定的顺序在括号内连接，用逗号分隔，并且没有字段名。元组值语法非常简单——开括号，逗号分隔的值列表，闭括号。事实上，值语法与元组本身的类型非常相似。'
- en: '*Tuple* pronunciation varies depending on who you ask, but I usually pronounce
    it to rhyme with *couple*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 的发音因人而异，但我通常把它读作与 *couple* 发音相似。'
- en: 'Why would we use tuples when we have record types with field names? Sometimes,
    we don''t want to spin up a new type, with a definition, just to hold some values
    together. Tuples are a low-ceremony way to do that. But the danger of using them
    over larger portions of a codebase is that they''re not self-describing like record
    types are. Here''s an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要使用元组，而不是具有字段名的记录类型呢？有时，我们不想为了将一些值组合在一起而启动一个新的类型，并为其定义。元组是一种低仪式的方式来做到这一点。但是，在代码库的更大部分中使用它们的危险是，它们不像记录类型那样具有自描述性。以下是一个例子：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I used just two values to make up the tuples here, but Reason supports tuples
    of any size.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里只用了两个值来构成元组，但 Reason 支持任何大小的元组。
- en: 'Notice the last line, which is commented out. If we uncomment that line, we''ll
    get the following error:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一行，它被注释掉了。如果我们取消注释那行代码，我们会得到以下错误：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I removed the descriptive comments to fit all the code in the error message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了描述性注释，以便将所有代码放入错误信息中。
- en: 'The type error tells us the types of the two tuples, and we see that they differ
    purely by the ordering of their component types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误告诉我们两个元组的类型，我们看到它们纯粹是通过其组件类型的顺序不同：
- en: '![](img/cfc7e712-67ea-4c56-a9b5-cdc85a9fc0aa.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfc7e712-67ea-4c56-a9b5-cdc85a9fc0aa.png)'
- en: Tuple type mismatch error
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型不匹配错误
- en: In the preceding error, we also see that Reason doesn't bother to check the
    entire type once it finds even one error in the structure of the tuple types.
    Nine times out of ten, as soon as we investigate this error message, we'll immediately
    see the problem–the values are swapped and so are the types–and fix it in one
    go. The other time, we'll hit another type error after we fix the first one, and
    fix that. I like to think of type-driven development as really *type-error-driven
    development* because hitting type errors is a really good scenario as it means
    one more potential bug that the production code will never see.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的错误中，我们还可以看到 Reason 一旦发现元组类型结构中的错误，就不会费心检查整个类型。十有八九，当我们调查这个错误信息时，我们会立即看到问题——值被交换了，类型也是如此——并且一次性修复它。另一种情况是，我们在修复第一个错误之后会遇到另一个类型错误，并修复它。我喜欢将类型驱动开发视为真正的*类型错误驱动开发*，因为遇到类型错误是一个非常好的场景，因为它意味着又多了一个潜在的错误，生产代码永远不会看到。
- en: Accessing tuple values
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问元组值
- en: 'We can access values inside tuples in two main ways: destructuring pattern
    matching and accessor functions.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种主要方式访问元组内的值：解构模式匹配和访问器函数。
- en: Destructuring pattern matching
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构模式匹配
- en: 'We can bind names to values in tuples using destructuring, similar to records:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用解构将名称绑定到元组中的值，类似于记录：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The general pattern is `(field1, field2, ..., field*N*)` for *N*-tuples. As
    always, the special `_` pattern allows us to disregard fields we don''t care about.
    Unlike with records, though, we can''t omit them altogether–we must list out all
    the fields separated by commas. Because tuples are typed according to their structure,
    omitting a tuple field changes the type we''d be matching against and would be
    a type error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *N*-元组，一般模式是 `(field1, field2, ..., field*N*)`。像往常一样，特殊 `_` 模式允许我们忽略我们不关心的字段。然而，与记录不同，我们不能完全省略它们——我们必须列出所有字段，并用逗号分隔。因为元组是根据其结构进行类型化的，省略元组字段会改变我们将要匹配的类型，这将是一个类型错误：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/abd1f51a-aa22-445d-b837-adf6e61e3b4a.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abd1f51a-aa22-445d-b837-adf6e61e3b4a.png)'
- en: Tuple destructure type error
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 元组解构类型错误
- en: 'We''re seeing two interesting types here: `''a` and `''b` (usually pronounced
    *alpha* and *beta*). We''ll delve into what they mean in a future chapter, but
    right now we can think of them as Reason''s way of saying *I haven''t figured
    out these types yet*. In any case, notice that they don''t trigger the actual
    type error–since Reason doesn''t know what they are, it can''t assume that they''re
    type mismatches. What really causes the error is the missing third element of
    the tuple. Effectively, we''re trying to match a 3-tuple against a 2-tuple, and
    this triggers the type error.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了两种有趣的数据类型：`'a` 和 `'b`（通常发音为 *alpha* 和 *beta*）。我们将在未来的章节中深入探讨它们的意义，但就目前而言，我们可以将它们视为
    Reason 表示*我还没有弄清楚这些类型*的方式。无论如何，请注意，它们不会触发实际的类型错误——因为 Reason 不了解它们是什么，它不能假设它们是类型不匹配。真正导致错误的是元组中缺失的第三个元素。实际上，我们正在尝试将一个
    3 元组与一个 2 元组匹配，这触发了类型错误。
- en: Accessor functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器函数
- en: 'Reason provides two convenience functions, `fst` and `snd`, to get the first
    and second positional values from tuples. Here''s an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 提供了两个便利函数，`fst` 和 `snd`，用于从元组中获取第一个和第二个位置值。以下是一个示例：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These functions often come in handy when we're trying to manage lots of tuples
    and need to tell other functions how to manipulate them. We'll see an example
    of this kind of controlled behavior in the upcoming chapter on functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在我们试图管理大量元组并需要告诉其他函数如何操作它们时非常有用。我们将在即将到来的关于函数的章节中看到一个这种受控行为的示例。
- en: Object types
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类型
- en: '*Objects* are part of OCaml''s full-fledged support for **object-oriented programming**
    (**OOP**). They combine some of the best properties of records and tuples: they
    are structural so we can create them in an adhoc way (without having to define
    their types), and we can provide field names (in OOP terminology, methods) that
    act as descriptive names. Here''s an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是 OCaml 对**面向对象编程**（**OOP**）的全面支持的一部分。它们结合了记录和元组的一些最佳特性：它们是结构化的，因此我们可以以临时方式创建它们（无需定义它们的类型），并且我们可以提供字段名称（在面向对象术语中，方法）作为描述性名称。以下是一个示例：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These show some basic usage of Reason objects:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些展示了 Reason 对象的一些基本用法：
- en: Objects are delimited by brackets and can refer to themselves within the brackets
    using the `this` keyword. However, if we don't use `this`, Reason will warn us
    about an unused value. So we can optionally ignore it using `as _` at the start
    of the object to suppress this warning.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象由括号界定，并且可以在括号内使用 `this` 关键字来引用自身。然而，如果我们不使用 `this`，Reason 将会警告我们关于未使用值。因此，我们可以在对象的开始处使用
    `as _` 来选择性地忽略此警告，以抑制此警告。
- en: We can create objects in an adhoc way by specifying their public methods (that
    is, fields) using the `pub` keyword. Reason will infer the type of the object
    from its public methods.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过指定它们的公共方法（即字段）来以 adhoc 的方式创建对象，使用 `pub` 关键字。Reason 将从其公共方法推断对象的类型。
- en: We can access object fields (that is, call their public methods) using the `#`
    notation. Also, in this case, we need to convert the int ID to a string to concatenate
    it to other strings.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `#` 符号来访问对象字段（即调用它们的公共方法）。此外，在这种情况下，我们需要将 int ID 转换为字符串，以便将其与其他字符串连接起来。
- en: We can call methods on the current object by using `this`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `this` 来调用当前对象的公共方法。
- en: If we load the output JavaScript module, `src/Ch04/Ch04_Objects.bs.js`, in NodeJS,
    Jim's greeting will be printed.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在 NodeJS 中加载输出 JavaScript 模块 `src/Ch04/Ch04_Objects.bs.js`，Jim 的问候语将被打印出来。
- en: If you look at the JavaScript output, you'll see that it's fairly complex. Reason
    objects are indeed fairly heavyweight values because they can contain a lot of
    functionality wrapped up inside them. Often, we don't need this level of power
    because we have other ways of modeling data and behavior. We'll cover more abstraction
    techniques in further chapters that lessen the need for Reason objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 JavaScript 输出，你会发现它相当复杂。Reason 对象确实相当重，因为它们可以包含很多封装在其中的功能。通常，我们不需要这种级别的功能，因为我们有其他方式来建模数据和行为。我们将在后续章节中介绍更多抽象技术，这些技术可以减少对
    Reason 对象的需求。
- en: Inheritance and subtyping
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和子类型
- en: You may be wondering whether Reason objects support inheritance. In fact, they
    do fully support inheritance with runtime dispatch. We won't delve into inheritance
    because OOP style is not the focus of this book; you can find ample resources
    for OOP in the Reason and OCaml documentation (they have equivalent functionality,
    just with different syntax).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 Reason 对象是否支持继承。实际上，它们完全支持使用运行时派发的继承。我们不会深入探讨继承，因为面向对象编程风格不是本书的重点；你可以在
    Reason 和 OCaml 文档中找到大量关于面向对象编程的资源（它们具有等效的功能，只是语法不同）。
- en: The one thing we need to emphasize is that Reason objects are *extensible* in
    a specific way, using a typing technique called **row polymorphism**. This is
    an advanced topic, and we'll cover different kinds of *polymorphism* (giving different
    types of common behaviors) in a future chapter. However, the basic idea is that
    a `u` object that supports a *superset* of all the methods of a `t` object is
    considered to have a `U` type that is a *subtype* of the `T` type of the `t` object.
    So, the `u` object can be safely **upcast** to the `T` type (that is, we can safely
    say that `u` has the `T` type) because that would not be a lossy conversion. In
    other words, objects support *inheritance* simply in terms of their method implementations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要强调的一点是，Reason 对象可以通过一种特定的方式使用称为 **行多态** 的类型技术进行扩展。这是一个高级主题，我们将在未来的章节中介绍不同类型的
    *多态*（提供不同类型的共同行为）。然而，基本思想是，支持所有 `t` 对象方法超集的 `u` 对象被认为具有 `U` 类型，它是 `t` 对象的 `T`
    类型的子类型。因此，`u` 对象可以安全地 **向上转换** 为 `T` 类型（即我们可以安全地说 `u` 具有该 `T` 类型），因为这不会导致数据丢失。换句话说，对象通过其方法实现支持
    *继承*。
- en: 'Let''s look at a concrete example: the `greet` function in the preceding example
    code. We call it with the `jim` object. The function calls two methods on its
    input object: `id` and `name`. Reason actually infers the input object type as
    `{.. id: int, name: string}`. We call this an open object type. The *openness*
    is marked by the two dots right after the opening bracket. It means we can call
    `greet` with subtypes of this type.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们来看一个具体的例子：前一个示例代码中的 `greet` 函数。我们使用 `jim` 对象来调用它。该函数在其输入对象上调用两个方法：`id` 和
    `name`。Reason 实际上推断输入对象类型为 `{.. id: int, name: string}`。我们称这种类型为开放对象类型。*开放性* 由开括号后的两个点标记。这意味着我们可以使用此类型的子类型来调用
    `greet`。'
- en: 'In fact, we do just that, on the line marked `(5)`: we call `greet` with `jim`,
    which is an object with the `id`, `name`, and `sayHi` methods. In other words,
    it''s a subtype of the type that `greet` is expecting, and `greet` accepts it
    because its input parameter type allows subtypes. If you change the call to use
    `bob`, it will succeed as well because `bob` also conforms to the type that has
    `id` and `name` methods of the expected types.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在标记为`(5)`的行中就是这样做的：我们用`jim`调用`greet`，`jim`是一个具有`id`、`name`和`sayHi`方法的对象。换句话说，它是一个`greet`期望的类型子类型。`greet`接受它，因为它的输入参数类型允许子类型。如果您将调用改为使用`bob`，它也会成功，因为`bob`也符合具有`id`和`name`方法的预期类型。
- en: 'However, if you uncomment the last line, you''ll get the following type error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您取消注释最后一行，您将得到以下类型错误：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This error indicates that we're passing in an input that doesn't meet the minimum
    requirements for the `greet` function. Indeed, intuitively we can see that the
    input only has a `name` method, whereas the `greet` function requires both the `id`
    and `name` methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表明我们传递的输入没有满足`greet`函数的最小要求。确实，直观地我们可以看到输入只有一个`name`方法，而`greet`函数需要`id`和`name`方法。
- en: If you think about it, Reason objects behave very much like JavaScript, Python,
    or Ruby objects, in the sense that we can treat them as bags of values and methods.
    The only difference is Reason checks the methods for us at compile time instead
    of runtime!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您这么想，Reason对象在行为上非常类似于JavaScript、Python或Ruby对象，因为我们可以将它们视为值和方法包。唯一的区别是Reason在编译时而不是在运行时为我们检查方法。
- en: JavaScript object types
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript对象类型
- en: The first thing to explain about JavaScript objects in Reason is that they're
    not actually JavaScript objects, they are Reason syntactic constructs that will
    compile down to JavaScript objects. We use the latter term as a shortcut to refer
    to the former.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中解释JavaScript对象的第一件事是，它们实际上不是JavaScript对象，它们是Reason语法结构，将编译成JavaScript对象。我们使用后一个术语作为前一个术语的快捷方式。
- en: 'With the realization that Reason objects behave a lot like JavaScript objects,
    we can understand how Reason''s support for JavaScript objects works. This support
    is baked in, but only if we''re targeting JavaScript using BuckleScript. In this
    project, we are, so here''s an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过意识到Reason对象与JavaScript对象非常相似，我们可以理解Reason对JavaScript对象的支持是如何工作的。这种支持是内置的，但仅当使用BuckleScript针对JavaScript时。在这个项目中，我们就是这样做的，以下是一个例子：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This example shows some typical JavaScript object usage:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了典型的JavaScript对象用法：
- en: Notice how similar the JavaScript object literal is to actual JavaScript. It's
    explicitly designed this way–enclosed in brackets, field names in double-quotes,
    values following the colon.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意JavaScript对象字面量与实际JavaScript的相似性。它是明确这样设计的——用括号括起来，字段名用双引号，值在冒号后面。
- en: The JavaScript object field access looks almost exactly like the Reason object
    method calls, only substituting `#` with `##`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript对象字段访问看起来几乎与Reason对象方法调用完全相同，只是将`#`替换为`##`。
- en: It's possible to give JavaScript objects actual methods that refer to the `this` JavaScript
    value, but it's a very advanced topic, so we're using an `age` field here instead.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以给JavaScript对象实际的方法，使其引用`this` JavaScript值，但这是一个非常高级的话题，所以我们在这里使用`age`字段。
- en: 'Notice at the end that, just like with the Reason objects example, we''re passing
    in an object (`jim`) that exposes a superset of the fields required by the `greet`
    function. This is why we use this special syntax in Reason to model JavaScript
    objects: they act like Reason objects in the sense of supporting subtyping with
    row polymorphism. With this subtyping, we can model many JavaScript idioms with
    an ease that we just couldn''t do with the simpler record types. The preceding
    use of the `greet` function is just one example of that, and, indeed in the JavaScript
    world, it''s common to see objects passed around between functions that use only
    some subset of their properties.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到结尾处，就像Reason对象示例一样，我们传递了一个对象（`jim`），它暴露了`greet`函数所需字段的超集。这就是为什么我们在Reason中使用这种特殊语法来模拟JavaScript对象：它们在支持通过行多态进行子类型化的意义上类似于Reason对象。有了这种子类型化，我们可以轻松地模拟许多JavaScript惯用法，而这用简单的记录类型是做不到的。前面使用`greet`函数的例子就是其中之一，实际上在JavaScript世界中，经常看到在只使用它们属性的一些子集的函数之间传递对象。
- en: If you look at the JavaScript output, notice that it is comparatively very simple–it
    really is just simple JavaScript object manipulation. Thanks to BuckleScript's
    ability to model JavaScript objects using basic OCaml objects, and Reason's nice
    object syntax, we get the best of both worlds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看JavaScript输出，请注意它相对非常简单——它实际上只是简单的JavaScript对象操作。多亏了BuckleScript使用基本OCaml对象来模拟JavaScript对象的能力，以及Reason优雅的对象语法，我们得到了两者的最佳结合。
- en: We won't, as a rule, focus on JavaScript object types in this book, but in real-world
    Reason usage it's very good to understand how they work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中常规关注JavaScript对象类型，但在现实世界的Reason使用中，了解它们是如何工作的非常有益。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we thoroughly explored some of the most important types Reason
    has to offer: product types, such as records, tuples, objects, and JavaScript
    objects. By understanding what they are and how and when to use them, we can now
    model a large portion of our data-processing needs.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面探讨了Reason提供的一些最重要的类型：产品类型，例如记录、元组、对象和JavaScript对象。通过了解它们是什么以及何时何地使用它们，我们现在可以模拟我们大部分数据处理需求。
- en: In the next chapter, we'll cover sum types, which are the flip side of the coin
    from product types, allowing us to model alternatives directly in our data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍求和类型，这是产品类型的另一面，它允许我们直接在我们的数据中模拟替代方案。
