- en: Grouping Values Together in Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw a way to group types and values together so
    that they can be accessed under a single namespace, and we saw how these namespaces
    (modules) themselves have types. Modules are not, however, convenient for passing
    around values during runtime. We need a lightweight way to build more structured
    types out of simpler types, to model real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these structured types, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Record types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectively, these types are referred to as **product types** because the number
    of possible values a product type can contain is the *product* of the number of
    possible values each of its component types can contain. This is an interesting
    result in type theory, and it gives us a hint to the fact that types obey certain
    algebraic laws. I will provide further reading materials on this later on in the
    book, after we have developed our type knowledge more.
  prefs: []
  type: TYPE_NORMAL
- en: Record types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve used record types in several places in the book so far, mostly to build
    a `person` type with an ID and a name. Let''s examine this simple record type
    a bit more closely and pick apart what exactly happens when it is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a whole, this type definition creates a new *nominal* type called `person`
    with two named fields: `id` and `name`, with specific `int` and `string` types.
    A nominal type is one that is distinguished by the typechecker from other types
    solely by name.'
  prefs: []
  type: TYPE_NORMAL
- en: This is as opposed to structural types, which are considered by the typechecker
    to be equal to their constituent types. For example, we saw in the previous chapter
    that modules are structurally typed. We'll see some more examples in this chapter
    and the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any rate, nominal types cannot be used interchangeably, even if they have
    the exact same definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding error message, notice that we defined a new record type `person`
    in `Ch03_Greet`, created a value of this type, and tried to call the `greet` function
    with it. But the `greet` function only accepts `Ch02_Demo.person` values and errors
    on our `person` value that have the same structure but a different name (the module
    path is considered to be part of the name for this purpose):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/019817df-50ca-4b34-9ca3-2dd33233086d.png)'
  prefs: []
  type: TYPE_IMG
- en: Type mismatch between nominal types with the same definition
  prefs: []
  type: TYPE_NORMAL
- en: Record literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create record values using the record-literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the typical variations of record literals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard record-literal syntax for a record type with the `field1` to `fieldN` fields
    is: `{field1: expression1, ..., fieldN: expressionN}`. Note one of the most significant
    things about records: *field order doesn''t matter.* Here we defined a record
    literal with field names in the opposite order to the record-type definition.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can start an enclosed scope with brackets so that the names declared inside
    (`id`, `name`) will not be visible from outside, and the last expression (`{id,
    name}`) in the enclosed scope will be the result value of the scope. Note that
    the scope delimiter brackets are separate from the record delimiter brackets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the *record field punning* syntax to write record literals when there
    is a name in the scope that's identical to the field name. Modern JavaScript has
    gained this punning feature as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can fall back on the standard record-literal syntax with any expression if
    we don't have names in the scope identical to the field names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing fields and dealing with errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Record field access syntax looks much like in other languages: `recordValue.fieldName`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To correctly infer the types of record literals though, Reason depends on matching
    up the field names to record types that it knows about. A common error that you
    will see is when Reason can''t find a suitable record type; for example, if we
    delete the `person` type from `Ch04_RecordLiterals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This often happens when the record type is defined in another module. We mentioned
    before that Reason doesn''t automatically search through other modules to find
    record types, because different modules could contain record types with the same
    field names; it would be unclear which one you meant. Instead, Reason opts to
    have you be explicit about the module, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Reason can tell that:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field you're referring to is in `Ch02_Demo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record literal has only the `id` and `name` fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the only type this record can possibly be is `Ch02_Demo.person` (it
    can't be `Ch02_Demo.company` because that record type has an `employees` field
    as well)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing record values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records are by default immutable: once you create one, you can''t change it.
    This is in addition to all Reason values being non-reassignable by default (meaning
    that something such as `let x = 1; x = 2;` is a compile error). This rigidity
    is for good reason: if you know that values can''t change, it becomes really easy
    to think about each part of your program in isolation and then be confident that
    the parts will behave consistently when put back together. This is one of the
    core principles of *functional programming,* which Reason''s statically typed
    techniques are built on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But completely unchangeable values are not very useful. You''ll usually need
    to change values at runtime to model the behaviors you''re interested in. So Reason
    provides two ways to change record values: immutable updates and mutable fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is what we will be using most of the time. With *immutable updates,* we
    literally create new record values using old ones. Reason provides a special syntax
    for this, which comes in very handy when the record type has two or more fields.
    But no matter how many fields, we can always build record values by just using
    the normal record-literal syntax. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we update Bob''s name to its long form. Note a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the immutable update syntax (also known in Reason as the *record
    spread* syntax), Reason creates a new record value that's identical to the old
    one (`bob`), except for the fields that we override. Also, even though the record
    type is defined in another module, we don't need to use a module prefix for any
    fields, because the immutable update forces Reason to look up what the fields
    are and thus it knows about the `name` field when we update it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we use the normal record-literal syntax, we need to define all the record
    fields. If we forget one, we''ll get a rather interesting type of error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Reason doesn''t allow null or undefined values, it''s a type error to
    leave out a record field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dc9e2f4-8feb-40ae-a355-791c87f6cba8.png)'
  prefs: []
  type: TYPE_IMG
- en: Missing record field type error
  prefs: []
  type: TYPE_NORMAL
- en: 'With immutable updates, we can reuse the same name and not have to worry about
    coming up with new names for various transformed values, thanks to shadowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We'll often use shadowing to perform a series of updates on some value, to convey
    the intention that we're building or transforming the same value toward a final
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable record fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are used less often because they introduce an element of unsafety into
    a program, and force the developer to be much more defensive in their code. You
    have a binding of a certain value at one point, and at another point it can be
    a different value, and all other parts of the codebase that were behaving in a
    certain way based on the original value will be in for a big surprise if they
    happen to check again and find the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, they can be very useful if you need some extra performance from
    some records, and you keep the mutations contained within the scope of a single
    function. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few things going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: We make a record field mutable using the `mutable` keyword before the field
    name. In this case, we make only two out of the three fields mutable, because
    the count never needs to change for a given array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new record of the type with the usual literal syntax; we can use
    `0.` as a shorthand for `0.0` for float literals, and the `Array.length` function
    returns the length of a Reason array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a `for` loop to iterate over the input array whose statistics we want.
    Reason fully supports imperative programming syntax, such as `for` and `while`
    loops; if you're looking to program in any given style, you'll likely be able
    to do it in Reason.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We sum up the array iteratively, by mutating the `sum` field. Mutating a (mutable)
    record field uses the simple `recordVal.field = value` syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We get the element at the given array index using `Array.unsafe_get`, which
    forgoes a bounds check before getting the element. In this example, we don''t
    need a bounds check because we''ve already made sure we won''t go past the end
    of the array when we started the loop. But if we''d made a mistake, say `for (i
    in 0 to result.count) { ... }`, we''d get a runtime error. So it''s good to be
    very careful with unsafe functions. There''s a safe, bounds-checked syntax for
    array element access: `array[i]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we finish iterating through the entire array, we mutate the `mean` field
    to the final mean value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't divide the float `sum` by the int `count`, so we need to convert the
    int `count` to a float. Note that we don't go the other way round, that is, convert
    the float `sum` to an int, because that would be a lossy conversion!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note how overall we are keeping the mutation inside the bounds of a single function.
    Although, this mutation safety is somewhat undermined by just returning the `summaryStats`
    value with two mutable fields to the caller. In future mutation examples, we'll
    show safer usage patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using slightly different operators for float arithmetic: in Reason,
    integer and float arithmetic are completely separate and they don''t mix. The
    float arithmetic operators are the same as the integer arithmetic ones, except
    with a "`.`" appended to them. The Reason philosophy is very much one of *explicit
    is better than implicit*.'
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, for most purposes, immutable records work very well indeed. Mutable
    record fields come in handy in a limited set of situations, and when we do use
    them, we need to take extra precautions against accidental mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Record patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ff0971a6-9cf3-4680-8010-47acb7663764.xhtml), *Program with Types
    and Values*, we saw that the general syntax for value bindings is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax applies to records too, because record literals also act as patterns.
    In the case of record patterns, we call it *destructuring pattern matching,* because
    we bind names by matching against the structure of the record value and pulling
    out its fields. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the possible variations of record patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: We globally open the record literals module, to get convenient access to the
    types and values defined there, without having to qualify every time. I didn't
    show this in the previous chapter because I deliberately wanted to de-emphasize
    global openings since they are usually more risky. In controlled cases such as
    this one though, they are OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record patterns look just like record literals, except what would be the field
    values are also names (`bobId`, `bobName`) and these names get bound to the actual
    values in the record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use a shortcut if we want to bind a name that''s the same as the field
    name: just omit the colon and field value on the right. We can even mix the two
    styles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can bind only some fields of a record to values, and explicitly not bind
    the other fields by binding them to the underscore symbol, which means ignore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can bind some fields to names and unreservedly ignore the rest using the
    underscore symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can bind some fields and ignore the rest by completely omitting them. Reason
    will infer the type of the pattern using the field names it sees but may get confused
    if there are multiple record types defined with the same fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the record-pattern syntax is very sophisticated and detailed,
    built up over time as Reason's base language, OCaml, has been in active industrial
    use. It will take a little time to get used to all the patterns; start simple
    and use the more succinct ones as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to mention about record patterns: they are also irrefutable
    patterns, just like simple value bindings, such as `let x = 1;`. Irrefutability
    simply means that once a pattern is compiled, there is no way it can fail to match
    against the value on the right-hand side at runtime. By this metric, record patterns
    pass because binding them is just a matter of binding their fields to names, and
    simple name bindings are also irrefutable. But we will see examples of refutable
    patterns in the next chapter, so keep an eye out for them.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuple types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Tuples* are lightweight, structural types. To be precise, they are types made
    up of other types, joined together within parentheses in a particular order, separated
    by commas, and without field names. The tuple value syntax is very simple–open
    parenthesis, comma-separated list of values, close parenthesis. In fact, the value
    syntax closely mimics the type of the tuples themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tuple* pronunciation varies depending on who you ask, but I usually pronounce
    it to rhyme with *couple*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would we use tuples when we have record types with field names? Sometimes,
    we don''t want to spin up a new type, with a definition, just to hold some values
    together. Tuples are a low-ceremony way to do that. But the danger of using them
    over larger portions of a codebase is that they''re not self-describing like record
    types are. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I used just two values to make up the tuples here, but Reason supports tuples
    of any size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the last line, which is commented out. If we uncomment that line, we''ll
    get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I removed the descriptive comments to fit all the code in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type error tells us the types of the two tuples, and we see that they differ
    purely by the ordering of their component types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfc7e712-67ea-4c56-a9b5-cdc85a9fc0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Tuple type mismatch error
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding error, we also see that Reason doesn't bother to check the
    entire type once it finds even one error in the structure of the tuple types.
    Nine times out of ten, as soon as we investigate this error message, we'll immediately
    see the problem–the values are swapped and so are the types–and fix it in one
    go. The other time, we'll hit another type error after we fix the first one, and
    fix that. I like to think of type-driven development as really *type-error-driven
    development* because hitting type errors is a really good scenario as it means
    one more potential bug that the production code will never see.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing tuple values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can access values inside tuples in two main ways: destructuring pattern
    matching and accessor functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can bind names to values in tuples using destructuring, similar to records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The general pattern is `(field1, field2, ..., field*N*)` for *N*-tuples. As
    always, the special `_` pattern allows us to disregard fields we don''t care about.
    Unlike with records, though, we can''t omit them altogether–we must list out all
    the fields separated by commas. Because tuples are typed according to their structure,
    omitting a tuple field changes the type we''d be matching against and would be
    a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/abd1f51a-aa22-445d-b837-adf6e61e3b4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Tuple destructure type error
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re seeing two interesting types here: `''a` and `''b` (usually pronounced
    *alpha* and *beta*). We''ll delve into what they mean in a future chapter, but
    right now we can think of them as Reason''s way of saying *I haven''t figured
    out these types yet*. In any case, notice that they don''t trigger the actual
    type error–since Reason doesn''t know what they are, it can''t assume that they''re
    type mismatches. What really causes the error is the missing third element of
    the tuple. Effectively, we''re trying to match a 3-tuple against a 2-tuple, and
    this triggers the type error.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessor functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason provides two convenience functions, `fst` and `snd`, to get the first
    and second positional values from tuples. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These functions often come in handy when we're trying to manage lots of tuples
    and need to tell other functions how to manipulate them. We'll see an example
    of this kind of controlled behavior in the upcoming chapter on functions.
  prefs: []
  type: TYPE_NORMAL
- en: Object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Objects* are part of OCaml''s full-fledged support for **object-oriented programming**
    (**OOP**). They combine some of the best properties of records and tuples: they
    are structural so we can create them in an adhoc way (without having to define
    their types), and we can provide field names (in OOP terminology, methods) that
    act as descriptive names. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These show some basic usage of Reason objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are delimited by brackets and can refer to themselves within the brackets
    using the `this` keyword. However, if we don't use `this`, Reason will warn us
    about an unused value. So we can optionally ignore it using `as _` at the start
    of the object to suppress this warning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can create objects in an adhoc way by specifying their public methods (that
    is, fields) using the `pub` keyword. Reason will infer the type of the object
    from its public methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can access object fields (that is, call their public methods) using the `#`
    notation. Also, in this case, we need to convert the int ID to a string to concatenate
    it to other strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can call methods on the current object by using `this`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we load the output JavaScript module, `src/Ch04/Ch04_Objects.bs.js`, in NodeJS,
    Jim's greeting will be printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you look at the JavaScript output, you'll see that it's fairly complex. Reason
    objects are indeed fairly heavyweight values because they can contain a lot of
    functionality wrapped up inside them. Often, we don't need this level of power
    because we have other ways of modeling data and behavior. We'll cover more abstraction
    techniques in further chapters that lessen the need for Reason objects.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be wondering whether Reason objects support inheritance. In fact, they
    do fully support inheritance with runtime dispatch. We won't delve into inheritance
    because OOP style is not the focus of this book; you can find ample resources
    for OOP in the Reason and OCaml documentation (they have equivalent functionality,
    just with different syntax).
  prefs: []
  type: TYPE_NORMAL
- en: The one thing we need to emphasize is that Reason objects are *extensible* in
    a specific way, using a typing technique called **row polymorphism**. This is
    an advanced topic, and we'll cover different kinds of *polymorphism* (giving different
    types of common behaviors) in a future chapter. However, the basic idea is that
    a `u` object that supports a *superset* of all the methods of a `t` object is
    considered to have a `U` type that is a *subtype* of the `T` type of the `t` object.
    So, the `u` object can be safely **upcast** to the `T` type (that is, we can safely
    say that `u` has the `T` type) because that would not be a lossy conversion. In
    other words, objects support *inheritance* simply in terms of their method implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a concrete example: the `greet` function in the preceding example
    code. We call it with the `jim` object. The function calls two methods on its
    input object: `id` and `name`. Reason actually infers the input object type as
    `{.. id: int, name: string}`. We call this an open object type. The *openness*
    is marked by the two dots right after the opening bracket. It means we can call
    `greet` with subtypes of this type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we do just that, on the line marked `(5)`: we call `greet` with `jim`,
    which is an object with the `id`, `name`, and `sayHi` methods. In other words,
    it''s a subtype of the type that `greet` is expecting, and `greet` accepts it
    because its input parameter type allows subtypes. If you change the call to use
    `bob`, it will succeed as well because `bob` also conforms to the type that has
    `id` and `name` methods of the expected types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you uncomment the last line, you''ll get the following type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This error indicates that we're passing in an input that doesn't meet the minimum
    requirements for the `greet` function. Indeed, intuitively we can see that the
    input only has a `name` method, whereas the `greet` function requires both the `id`
    and `name` methods.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, Reason objects behave very much like JavaScript, Python,
    or Ruby objects, in the sense that we can treat them as bags of values and methods.
    The only difference is Reason checks the methods for us at compile time instead
    of runtime!
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to explain about JavaScript objects in Reason is that they're
    not actually JavaScript objects, they are Reason syntactic constructs that will
    compile down to JavaScript objects. We use the latter term as a shortcut to refer
    to the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the realization that Reason objects behave a lot like JavaScript objects,
    we can understand how Reason''s support for JavaScript objects works. This support
    is baked in, but only if we''re targeting JavaScript using BuckleScript. In this
    project, we are, so here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows some typical JavaScript object usage:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how similar the JavaScript object literal is to actual JavaScript. It's
    explicitly designed this way–enclosed in brackets, field names in double-quotes,
    values following the colon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JavaScript object field access looks almost exactly like the Reason object
    method calls, only substituting `#` with `##`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's possible to give JavaScript objects actual methods that refer to the `this` JavaScript
    value, but it's a very advanced topic, so we're using an `age` field here instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice at the end that, just like with the Reason objects example, we''re passing
    in an object (`jim`) that exposes a superset of the fields required by the `greet`
    function. This is why we use this special syntax in Reason to model JavaScript
    objects: they act like Reason objects in the sense of supporting subtyping with
    row polymorphism. With this subtyping, we can model many JavaScript idioms with
    an ease that we just couldn''t do with the simpler record types. The preceding
    use of the `greet` function is just one example of that, and, indeed in the JavaScript
    world, it''s common to see objects passed around between functions that use only
    some subset of their properties.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the JavaScript output, notice that it is comparatively very simple–it
    really is just simple JavaScript object manipulation. Thanks to BuckleScript's
    ability to model JavaScript objects using basic OCaml objects, and Reason's nice
    object syntax, we get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: We won't, as a rule, focus on JavaScript object types in this book, but in real-world
    Reason usage it's very good to understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we thoroughly explored some of the most important types Reason
    has to offer: product types, such as records, tuples, objects, and JavaScript
    objects. By understanding what they are and how and when to use them, we can now
    model a large portion of our data-processing needs.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover sum types, which are the flip side of the coin
    from product types, allowing us to model alternatives directly in our data.
  prefs: []
  type: TYPE_NORMAL
