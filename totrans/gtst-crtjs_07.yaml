- en: Chapter 7. Developing a Painting Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 开发绘画应用程序
- en: In this chapter, we will create a simple painting application using almost all
    the EaselJS features that we have already discussed in the previous chapters.
    This chapter will be more interactive and challenging, as we need to wrap up everything
    that we have already learned. So let's get started.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个简单的绘画应用程序，使用几乎我们在前几章中已经讨论过的所有 EaselJS 功能。本章将更加互动和具有挑战性，因为我们需要总结我们已经学到的所有内容。所以，让我们开始吧。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing the stage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备舞台
- en: Understanding the `mousemove`, `mouseup`, and `mousedown` events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `mousemove`、`mouseup` 和 `mousedown` 事件
- en: Implementing each callback function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现每个回调函数
- en: Preparing the stage
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备舞台
- en: The overall functionality of this application is almost the same as drag-and-drop
    applications; we will use the `mousedown`, `mouseup`, and `mousemove` events to
    handle the painting logic. First, we will create a `stage` object and then an
    array of colors that will be used for the color of brushes. We will enable the
    *touch feature* for web browsers and for devices that support touch events. Finally,
    we set callback functions for the `mousedown`, `mouseup`, and `mousemove` events
    to handle the drawing feature and draw the lines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的整体功能几乎与拖放应用程序相同；我们将使用 `mousedown`、`mouseup` 和 `mousemove` 事件来处理绘画逻辑。首先，我们将创建一个
    `stage` 对象，然后是一个用于画笔颜色的颜色数组。我们将启用 Web 浏览器和支持触摸事件的设备的 *触摸功能*。最后，我们为 `mousedown`、`mouseup`
    和 `mousemove` 事件设置回调函数来处理绘图功能和绘制线条。
- en: 'The following screenshot shows a preview of our painting application:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的绘画应用程序的预览：
- en: '![Preparing the stage](img/0260OS_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![准备舞台](img/0260OS_07_01.jpg)'
- en: 'The final source code consists of the following functions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的源代码由以下函数组成：
- en: '`init`: It is used to create the stage and prepare other objects.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`: 它用于创建舞台并准备其他对象。'
- en: '`handleMouseDown`: It is used to handle the `mousedown` event and bind the
    `mousemove` event.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleMouseDown`: 它用于处理 `mousedown` 事件并绑定 `mousemove` 事件。'
- en: '`handleMouseMove`: It is used to handle the `mousemove` event and draw the
    line.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleMouseMove`: 它用于处理 `mousemove` 事件并绘制线条。'
- en: '`handleMouseUp`: It is used to handle the `mouseup` event and unbind the `mousemove`
    event to stop drawing.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleMouseUp`: 它用于处理 `mouseup` 事件并解绑 `mousemove` 事件以停止绘图。'
- en: 'The following image illustrates how the events work together to draw a line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了事件如何协同工作以绘制线条：
- en: '![Preparing the stage](img/0260OS_07_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备舞台](img/0260OS_07_02.jpg)'
- en: In further sections, we will discuss more about the source code and how it is
    created.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地讨论源代码及其创建方式。
- en: Understanding the init function
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解初始化函数
- en: Inside the `init` function, we will setup the stage, declare the basic variables,
    and also attach functions to the main events like the `mousedown` event.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 函数内部，我们将设置舞台，声明基本变量，并将函数附加到主要事件，如 `mousedown` 事件。
- en: 'The following code is the source code of the `init` function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `init` 函数的源代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first line of the function's body, we have a global `canvas` variable,
    which refers to our `Canvas` element in the page. We have an `index` variable
    that holds a counter to choose a color for brushes while painting and the next
    line contains an array of colors. We choose one value from this array randomly
    using the `index` variable. After that, as seen in previous examples, we have
    to create a `stage` object; this is also a global variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体的第一行，我们有一个全局的 `canvas` 变量，它指向页面中的 `Canvas` 元素。我们有一个 `index` 变量，它持有计数器以在绘画时选择画笔颜色，下一行包含一个颜色数组。我们使用
    `index` 变量从这个数组中随机选择一个值。之后，如前例所示，我们必须创建一个 `stage` 对象；这也是一个全局变量。
- en: After that, we set the `autoClear` property of `stage` to `false`. This property
    indicates whether the stage should clear the rendered elements on the canvas automatically
    or not. By setting this value to `false`, we can manually control the clearing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将 `stage` 的 `autoClear` 属性设置为 `false`。此属性表示舞台是否应自动清除画布上的渲染元素。通过将此值设置为 `false`，我们可以手动控制清除。
- en: Then, we enabled the **DOM** (**Document Object Model**) events using the `enableDOMEvents`
    method. This method actually enables or disables the event listener, which `stage`
    adds to DOM elements such as window, document, and canvas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `enableDOMEvents` 方法启用了 **DOM**（**文档对象模型**）事件。此方法实际上启用了或禁用了 `stage`
    添加到 DOM 元素（如窗口、文档和画布）的事件监听器。
- en: In the following lines, touch events and **frames per second** (**FPS**) are
    configured. The `setFPS` function sets the target frame rate in frames per second.
    This function is a member o f the `Ticker` class. The `Ticker` class is one of
    the major features of EaselJS that provides a centralized ticker or heartbeat
    and listeners can subscribe to the ticker event to be notified when time elapsed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的行中，配置了触摸事件和**每秒帧数**（**FPS**）。`setFPS`函数设置了目标帧率（以每秒帧数计）。这个函数是`Ticker`类的一个成员。`Ticker`类是EaselJS的主要功能之一，它提供了一个集中的计时器或心跳，监听器可以订阅计时器事件，以便在时间流逝时得到通知。
- en: Then, the global variable `drawingCanvas` is initialized with a `Shape` object
    and it will be our painting shape. In the following events, we will use this variable
    to complete the drawing process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，全局变量`drawingCanvas`使用一个`Shape`对象初始化，它将成为我们的绘画形状。在以下事件中，我们将使用这个变量来完成绘制过程。
- en: Further, the `mousedown` and `mouseup` events are assigned to proper functions
    and then a painting shape is added to `stage`. There are some ways to add an event
    listener and one of them is using the `addEventListener` function. Pass the name
    of the event and the function to it. We used the `addEventListener` function in
    this example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`mousedown`和`mouseup`事件被分配给适当的函数，然后一个绘画形状被添加到`stage`中。添加事件监听器有多种方法，其中之一是使用`addEventListener`函数。将事件名称和函数传递给它。在这个例子中，我们使用了`addEventListener`函数。
- en: Similar to the previous examples, we have to add the shape to `stage` and update
    it using the `update` function. In the following lines, we added the shape to
    `stage` and updated it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，我们必须将形状添加到`stage`中，并使用`update`函数更新它。在下面的行中，我们将形状添加到`stage`中并更新了它。
- en: This is the definition of the `init` function. Actually, this function is a
    bootstrap function to start the painting application. Inside this function, all
    events to paint and draw are configured. In the following sections, we will discuss
    the event callback function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`init`函数的定义。实际上，这个函数是一个引导函数，用于启动绘画应用程序。在这个函数内部，所有用于绘画和绘制的相关事件都进行了配置。在接下来的章节中，我们将讨论事件回调函数。
- en: Implementing the handleMouseDown function
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现handleMouseDown函数
- en: 'The following code is the source code of the `handleMouseDown` function, which
    is used to handle the `mousedown` event:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`handleMouseDown`函数的源代码，该函数用于处理`mousedown`事件：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is used to handle the `mousedown` event and will be called after
    pressing the mouse button. Inside this function, we set the color and size of
    a stroke, and hold the current mouse position to use in the next function call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于处理`mousedown`事件，并在按下鼠标按钮后被调用。在这个函数内部，我们设置了笔触的颜色和大小，并保存当前的鼠标位置以供下一次函数调用使用。
- en: All variables are global, so you can't see any `var` keyword before them in
    order to have the variables in the following function calls and other scopes.
    In the last line, a function also sets the `mousemove` event in order to manage
    the drawing lines. Actually, the `mousemove` event fires whenever the mouse cursor
    moves in `stage`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都是全局的，因此你不会在它们前面看到任何`var`关键字，以便在后续的函数调用和其他作用域中拥有这些变量。在最后一行，一个函数还设置了`mousemove`事件，以便管理绘制线条。实际上，`mousemove`事件会在鼠标光标在`stage`中移动时触发。
- en: The color of the brush is selected from the `colors` array that is defined in
    the `init` function, one after the other, using the `index` variable. What we
    do to select the next color from the array is increase the `index` variable and
    then calculate the division's remainder. With this simple hack, we can choose
    a value between zero and the length of the array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 笔刷的颜色是从`init`函数中定义的`colors`数组中依次选择的，使用`index`变量。我们为了从数组中选择下一个颜色所做的是增加`index`变量，然后计算除法的余数。通过这个简单的技巧，我们可以选择一个介于零和数组长度之间的值。
- en: The size of the brush is selected using the `random` function. The `random`
    function from the `Math` class in JavaScript returns a value between 0 and 1 (but
    not 1). By multiplying this value with 30, we can get a value between 0 and 30
    (but not 30). The round function also rounds up a number in JavaScript.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 笔刷的大小是通过使用`random`函数来选择的。JavaScript中的`Math`类中的`random`函数返回一个介于0和1之间的值（但不包括1）。通过将这个值乘以30，我们可以得到一个介于0和30之间的值（但不包括30）。JavaScript中的`round`函数也会向上取整一个数字。
- en: And the important part of that code is that `stage.mouseX` and `stage.mouseY`
    return the current mouse coordinate on the Canvas element. We use those variables
    to get the mouse position and hold it in a global variable. These values will
    be used to draw the lines and the reason we save them in a global variable is
    to provide accessibility in other scopes and functions. As you can see, we used
    the `Point` class to collect the coordinate of the mouse cursor. The `Point` class
    represents a two-dimensional coordinate system in EaselJS and we use this class
    to save the cursor pointer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码的重要部分是 `stage.mouseX` 和 `stage.mouseY` 返回 Canvas 元素上的当前鼠标坐标。我们使用这些变量来获取鼠标位置并将其保存在全局变量中。这些值将用于绘制线条，我们之所以将它们保存在全局变量中，是为了在其他作用域和函数中提供可访问性。正如你所见，我们使用了
    `Point` 类来收集鼠标光标的坐标。`Point` 类代表 EaselJS 中的二维坐标系，我们使用这个类来保存光标指针。
- en: Using the handleMouseMove function
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `handleMouseMove` 函数
- en: This function actually draws the line and is used to handle the `mousemove`
    event. This is our main function to handle drawing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实际上绘制线条，并用于处理 `mousemove` 事件。这是我们处理绘制的主体函数。
- en: 'The source code of the `mousemove` function is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`mousemove` 函数的源代码如下：'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is called continuously while the mouse cursor is dragging over
    `stage`. In this function, we draw the line using the `beginStroke` function and
    then save the current mouse position again in order to use it in the following
    function calls; actually, the following mouse move. By each move of the mouse
    cursor, this function is called again, so we will have the line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标光标在 `stage` 上拖动时，这个函数会持续被调用。在这个函数中，我们使用 `beginStroke` 函数绘制线条，并再次保存当前的鼠标位置以便在后续的函数调用中使用；实际上，是下一次鼠标移动。随着鼠标光标的每次移动，这个函数都会再次被调用，因此我们将得到线条。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the first line you can see the right shift operator (the `>>` operator).
    We used this function to simplify the `Math.floor(num / 2)`operation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，你可以看到右移操作符（`>>` 操作符）。我们使用这个函数来简化 `Math.floor(num / 2)` 操作。
- en: Actually, `num>> 1` and `Math.floor(num / 2)` have the same result.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`num>> 1` 和 `Math.floor(num / 2)` 有相同的结果。
- en: After that, we update the stage using the `update` function to apply changes
    to the stage and render everything to the canvas.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用 `update` 函数更新 `stage`，以将更改应用到 `stage` 并将一切渲染到画布上。
- en: Utilizing the handleMouseUp function
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `handleMouseUp` 函数
- en: 'This function is called when a user releases the mouse click and uses it to
    end the drawing lines and remove the event from `stage`. Its source code is as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放鼠标点击时，这个函数会被调用，并用于结束绘制线条并从 `stage` 中移除事件。其源代码如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All we do in this function is call `removeEventListener` to remove the `mousemove`
    event and prevent calling the function anymore. After removing this event from
    `stage`, the `handleMouseMove` function won't call anymore. So, by moving the
    mouse cursor, EaselJS won't call our function until the next `mousedown` event.
    That's exactly what we want to handle in the painting logic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们只调用 `removeEventListener` 来移除 `mousemove` 事件，并防止再次调用该函数。在从 `stage`
    中移除此事件后，`handleMouseMove` 函数将不再被调用。因此，通过移动鼠标光标，EaselJS 不会在下一个 `mousedown` 事件之前调用我们的函数。这正是我们在绘画逻辑中想要处理的。
- en: 'In the following screenshot, you can see a preview of this application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图，你可以看到这个应用的预览：
- en: '![Utilizing the handleMouseUp function](img/0260OS_07_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `handleMouseUp` 函数](img/0260OS_07_03.jpg)'
- en: Downloading the source code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载源代码
- en: 'This painting example is one of the basic EaselJS samples. You can download
    the complete source code of the project from EaselJS''s GitHub:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绘画示例是 EaselJS 的基本示例之一。你可以从 EaselJS 的 GitHub 下载项目的完整源代码：
- en: '[https://github.com/CreateJS/EaselJS/blob/master/examples/CurveTo.html](https://github.com/CreateJS/EaselJS/blob/master/examples/CurveTo.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/CreateJS/EaselJS/blob/master/examples/CurveTo.html](https://github.com/CreateJS/EaselJS/blob/master/examples/CurveTo.html)'
- en: Summary
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed how to create a simple painting application
    from scratch using the `mousemove`, `mousedown`, and `mouseup` events, and it's
    a good exercise to understand the concept of those events. Then, we learned how
    to manage mouse events inside each other to draw a line. The `addEventListener`
    and `removeEventListener` functions were used to add and remove an event from
    an object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何从头开始使用 `mousemove`、`mousedown` 和 `mouseup` 事件创建一个简单的绘画应用，这是理解这些事件概念的良好练习。然后，我们学习了如何管理内部鼠标事件以绘制线条。我们使用了
    `addEventListener` 和 `removeEventListener` 函数来添加和移除对象中的事件。
- en: Also, we learned how to use the stroke feature in EaselJS to draw lines with
    a specific color and size. We used the `beginStorke`, `curveTo`, and `moveTo`
    functions to draw the lines and handle the painting logic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学习了如何使用EaselJS中的描边功能来绘制具有特定颜色和大小的线条。我们使用了`beginStroke`、`curveTo`和`moveTo`函数来绘制线条并处理绘图逻辑。
- en: In the next chapter, we will talk about *vector mask* and how to create a mask
    layer in CreateJS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论*矢量蒙版*以及如何在CreateJS中创建蒙版层。
