- en: Chapter 7. Developing a Painting Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a simple painting application using almost all
    the EaselJS features that we have already discussed in the previous chapters.
    This chapter will be more interactive and challenging, as we need to wrap up everything
    that we have already learned. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `mousemove`, `mouseup`, and `mousedown` events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing each callback function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The overall functionality of this application is almost the same as drag-and-drop
    applications; we will use the `mousedown`, `mouseup`, and `mousemove` events to
    handle the painting logic. First, we will create a `stage` object and then an
    array of colors that will be used for the color of brushes. We will enable the
    *touch feature* for web browsers and for devices that support touch events. Finally,
    we set callback functions for the `mousedown`, `mouseup`, and `mousemove` events
    to handle the drawing feature and draw the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a preview of our painting application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the stage](img/0260OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final source code consists of the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`: It is used to create the stage and prepare other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleMouseDown`: It is used to handle the `mousedown` event and bind the
    `mousemove` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleMouseMove`: It is used to handle the `mousemove` event and draw the
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleMouseUp`: It is used to handle the `mouseup` event and unbind the `mousemove`
    event to stop drawing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image illustrates how the events work together to draw a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the stage](img/0260OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In further sections, we will discuss more about the source code and how it is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the init function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `init` function, we will setup the stage, declare the basic variables,
    and also attach functions to the main events like the `mousedown` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the source code of the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the function's body, we have a global `canvas` variable,
    which refers to our `Canvas` element in the page. We have an `index` variable
    that holds a counter to choose a color for brushes while painting and the next
    line contains an array of colors. We choose one value from this array randomly
    using the `index` variable. After that, as seen in previous examples, we have
    to create a `stage` object; this is also a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set the `autoClear` property of `stage` to `false`. This property
    indicates whether the stage should clear the rendered elements on the canvas automatically
    or not. By setting this value to `false`, we can manually control the clearing.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we enabled the **DOM** (**Document Object Model**) events using the `enableDOMEvents`
    method. This method actually enables or disables the event listener, which `stage`
    adds to DOM elements such as window, document, and canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines, touch events and **frames per second** (**FPS**) are
    configured. The `setFPS` function sets the target frame rate in frames per second.
    This function is a member o f the `Ticker` class. The `Ticker` class is one of
    the major features of EaselJS that provides a centralized ticker or heartbeat
    and listeners can subscribe to the ticker event to be notified when time elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the global variable `drawingCanvas` is initialized with a `Shape` object
    and it will be our painting shape. In the following events, we will use this variable
    to complete the drawing process.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the `mousedown` and `mouseup` events are assigned to proper functions
    and then a painting shape is added to `stage`. There are some ways to add an event
    listener and one of them is using the `addEventListener` function. Pass the name
    of the event and the function to it. We used the `addEventListener` function in
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the previous examples, we have to add the shape to `stage` and update
    it using the `update` function. In the following lines, we added the shape to
    `stage` and updated it.
  prefs: []
  type: TYPE_NORMAL
- en: This is the definition of the `init` function. Actually, this function is a
    bootstrap function to start the painting application. Inside this function, all
    events to paint and draw are configured. In the following sections, we will discuss
    the event callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the handleMouseDown function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code is the source code of the `handleMouseDown` function, which
    is used to handle the `mousedown` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function is used to handle the `mousedown` event and will be called after
    pressing the mouse button. Inside this function, we set the color and size of
    a stroke, and hold the current mouse position to use in the next function call.
  prefs: []
  type: TYPE_NORMAL
- en: All variables are global, so you can't see any `var` keyword before them in
    order to have the variables in the following function calls and other scopes.
    In the last line, a function also sets the `mousemove` event in order to manage
    the drawing lines. Actually, the `mousemove` event fires whenever the mouse cursor
    moves in `stage`.
  prefs: []
  type: TYPE_NORMAL
- en: The color of the brush is selected from the `colors` array that is defined in
    the `init` function, one after the other, using the `index` variable. What we
    do to select the next color from the array is increase the `index` variable and
    then calculate the division's remainder. With this simple hack, we can choose
    a value between zero and the length of the array.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the brush is selected using the `random` function. The `random`
    function from the `Math` class in JavaScript returns a value between 0 and 1 (but
    not 1). By multiplying this value with 30, we can get a value between 0 and 30
    (but not 30). The round function also rounds up a number in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: And the important part of that code is that `stage.mouseX` and `stage.mouseY`
    return the current mouse coordinate on the Canvas element. We use those variables
    to get the mouse position and hold it in a global variable. These values will
    be used to draw the lines and the reason we save them in a global variable is
    to provide accessibility in other scopes and functions. As you can see, we used
    the `Point` class to collect the coordinate of the mouse cursor. The `Point` class
    represents a two-dimensional coordinate system in EaselJS and we use this class
    to save the cursor pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the handleMouseMove function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function actually draws the line and is used to handle the `mousemove`
    event. This is our main function to handle drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of the `mousemove` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function is called continuously while the mouse cursor is dragging over
    `stage`. In this function, we draw the line using the `beginStroke` function and
    then save the current mouse position again in order to use it in the following
    function calls; actually, the following mouse move. By each move of the mouse
    cursor, this function is called again, so we will have the line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first line you can see the right shift operator (the `>>` operator).
    We used this function to simplify the `Math.floor(num / 2)`operation.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, `num>> 1` and `Math.floor(num / 2)` have the same result.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we update the stage using the `update` function to apply changes
    to the stage and render everything to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the handleMouseUp function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function is called when a user releases the mouse click and uses it to
    end the drawing lines and remove the event from `stage`. Its source code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All we do in this function is call `removeEventListener` to remove the `mousemove`
    event and prevent calling the function anymore. After removing this event from
    `stage`, the `handleMouseMove` function won't call anymore. So, by moving the
    mouse cursor, EaselJS won't call our function until the next `mousedown` event.
    That's exactly what we want to handle in the painting logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a preview of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing the handleMouseUp function](img/0260OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This painting example is one of the basic EaselJS samples. You can download
    the complete source code of the project from EaselJS''s GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/CreateJS/EaselJS/blob/master/examples/CurveTo.html](https://github.com/CreateJS/EaselJS/blob/master/examples/CurveTo.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to create a simple painting application
    from scratch using the `mousemove`, `mousedown`, and `mouseup` events, and it's
    a good exercise to understand the concept of those events. Then, we learned how
    to manage mouse events inside each other to draw a line. The `addEventListener`
    and `removeEventListener` functions were used to add and remove an event from
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we learned how to use the stroke feature in EaselJS to draw lines with
    a specific color and size. We used the `beginStorke`, `curveTo`, and `moveTo`
    functions to draw the lines and handle the painting logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about *vector mask* and how to create a mask
    layer in CreateJS.
  prefs: []
  type: TYPE_NORMAL
