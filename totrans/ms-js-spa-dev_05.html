<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Its All About the View</h1></div></div></div><p>The UI layer, or <strong>View</strong>, is the most visible component of any application. No matter what is going on underneath the hood, be it REST, Websockets, MQTT, or SOAP, the view is where everything culminates for a full, interactive application experience. Just as with the server side, the view has its own set of complexities and myriad of architectural choices to make from a development perspective. We will now explore some of these choices along with some different design patterns that can be used in the all-encompassing view layer.</p><p>In this chapter, we will cover the following images:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The differences among various JavaScript templating engines</li><li class="listitem" style="list-style-type: disc">The advantages of precompiling JavaScript templates</li><li class="listitem" style="list-style-type: disc">How to optimize your application layout</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>JavaScript templating engines</h1></div></div></div><p>Maintaining the view on the frontend of your application goes a long way toward keeping it server-side agnostic. Even if you are using a MVC framework underneath to serve REST endpoints for your application, keeping the view templates and logic on the frontend will ensure that you can more easily swap out the MVC backend in the future without significantly altering the logical and architectural structure of your application. JavaScript templating engines provide an effective way to manage view templates entirely on the frontend.</p><p>There are many open source JavaScript templating engines available. Next, we will cover the basics of some of the more popular ones:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Underscore.js</li><li class="listitem" style="list-style-type: disc">Mustache.js</li><li class="listitem" style="list-style-type: disc">Handlebars.js</li><li class="listitem" style="list-style-type: disc">Pure.js</li><li class="listitem" style="list-style-type: disc">Pug</li><li class="listitem" style="list-style-type: disc">EJS</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Underscore.js</h1></div></div></div><p>The <strong>Underscore.js</strong> library is well known for its useful JavaScript functional programming helpers and utility methods. One of those utility methods is <code class="literal">_.template()</code>. This method is used to compile strings with expressions into functions that replace those expressions with dynamic values.</p><p>Underscore.js template syntax delimiters resemble those of the <strong>ERB</strong>, or <strong>Embedded Ruby</strong> template syntax, with an <strong>equals</strong> sign following the opening tag:</p><pre class="programlisting">&lt;p&gt;Hello, &lt;%= name %&gt;.&lt;/p&gt; &#13;
</pre><p>An Underscore.js template expression used within HTML looks like the preceding example. The variable name would be dynamically passed in to the compiled function for this template.</p><p>The<code class="literal"> _.template()</code> method can also be used to parse and execute arbitrary JavaScript code within a template. JavaScript code within Underscore.js templates is delimited by using the ERB style tags <em>without</em> an equals sign following the opening tag:</p><pre class="programlisting">&lt;ul&gt; &#13;
    &lt;% _.each(items, function(item) { %&gt; &#13;
        &lt;li&gt;&lt;%= item.property %&gt;&lt;/li&gt; &#13;
    &lt;% } %&gt; &#13;
&lt;/ul&gt; &#13;
</pre><p>As you can see in this example, the ERB tags within the template give the script access to the global <code class="literal">_</code> object and allow it to iterate over a given object or array contained in that context or even up the scope chain from that context using the library's <code class="literal">_.each()</code> method. The fact that the script has access to the <code class="literal">_</code> object shows that any global variable attached to the <code class="literal">window</code> namespace is available to the script.</p><p>Giving templates the ability to execute arbitrary JavaScript code is a subject that has met with much debate in the community, and the general consensus is that the practice is frowned upon. This is due to the lessons learned from other web scripting languages, such as PHP.</p><p>Mixing code for dynamic business logic with HTML directly in your templates can lead to a codebase that is difficult to maintain and debug by other developers and future generations. This type of code also violates the principles of MVC and MVW architectural patterns. It should go without saying that it is up to the developer writing the code how much or how little business logic they choose to include in their templates, but for the creators of many JavaScript templating engines, leaving that door open was not an option. For these reasons, the concept of <em>logic-less</em> templates was born.</p><p>You can learn more about Underscore.js at <code class="literal">underscorejs.org</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Mustache.js</h1></div></div></div><p>
<strong>Mustache.js</strong> is an implementation of the popular <strong>Mustache template system</strong> for JavaScript templating. Mustache touts itself as a <em>logic-less</em> template syntax. The idea behind this concept is not necessarily to have templates completely void of logic, but more to discourage the practice of including a large amount of business logic within your templates.</p><p>Mustache gets its name from the use of double curly braces, which resemble the shape of a mustache, as the default delimiter tags for templates. The major difference between Mustache templates and Underscore.js templates is that Mustache does not allow for the placement of arbitrary JavaScript within an alternate form of its tags; it only allows for expressions.</p><p>In its simplest form, a Mustache template maps values from a JavaScript object directly to their respective template expressions, represented by the keys for those object values. Take an object such as the one shown here, for example:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Udis", &#13;
        "last": "Petroyka" &#13;
    }, &#13;
    "age": "82" &#13;
} &#13;
</pre><p>The values from this object can be represented in a Mustache template like this:</p><pre class="programlisting">&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
&lt;p&gt;Age: {{age}}&lt;/p&gt; &#13;
</pre><p>In this example, you can see that even nested object values can be accessed by using JavaScript dot notation, as shown with <code class="literal">{{name.first}}</code> and <code class="literal">{{name.last}}</code>:</p><pre class="programlisting">&lt;p&gt;Udis Petroyka&lt;/p&gt; &#13;
&lt;p&gt;Age: 82&lt;/p&gt; &#13;
 &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Sections</h2></div></div></div><p>Mustache templates also include the ability to render <em>sections</em>, or <em>blocks of text</em>. This involves using an alternate expression syntax that includes an opening and closing tag syntax. How a section is rendered depends on the value of the key being called for it.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec64"/>Boolean values</h3></div></div></div><p>Given a Boolean value, a section will render or not render depending on if that Boolean is <code class="literal">true</code> or <code class="literal">false</code>:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Jarmond", &#13;
        "last": "Dittlemore" &#13;
    }, &#13;
    "email_subscriber": false &#13;
} &#13;
</pre><p>The delimiter syntax for sections consists of opening curly braces followed by the pound <code class="literal">#</code> symbol and the name of the property to start the section, and closing curly braces followed by the <code class="literal">/</code> symbol and the property name to end the section. This syntax is similar to HTML opening and closing tags:</p><pre class="programlisting">&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#email_subscriber}} &#13;
    &lt;p&gt;Content here will not be shown for this user.&lt;/p&gt; &#13;
{{/email_subscriber}} &#13;
</pre><p>In this example, the <code class="literal">email_subscriber</code> property is set to false, so the template would render the following HTML:</p><pre class="programlisting">&lt;p&gt;Jarmond Dittlemore&lt;/p&gt; &#13;
 &#13;
</pre><p>Essentially, the use of a section with a Boolean value is equivalent to an <code class="literal">if</code> conditional statement. Such a use case does indeed include logic, though in its most basic form. In this way, the term <em>logic-less</em> is proven to not be as stringent as it may initially be perceived.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec65"/>Lists</h3></div></div></div><p>Additionally, sections can be used to iterate over a list of items set as the value for a given object key. Within a section, the context, or variable scope, is shifted to that of the key that is being iterated over. Take the following parent key and corresponding list of values, for example:</p><pre class="programlisting">{ &#13;
    "people": [ &#13;
        { "firstName": "Peebo", "lastName": "Sanderson" }, &#13;
        { "firstName": "Udis", "lastName": "Petroyka" }, &#13;
        { "firstName": "Jarmond", "lastName": "Dittlemore" }, &#13;
        { "firstName": "Chappy", "lastName": "Scrumdinger" } &#13;
    ] &#13;
} &#13;
</pre><p>Given a list of people and their names, a section can be used to render each person's name in an HTML unordered list:</p><pre class="programlisting">&lt;ul&gt; &#13;
{{#people}} &#13;
    &lt;li&gt;{{firstName}} {{lastName}}&lt;/li&gt; &#13;
{{/people}} &#13;
&lt;/ul&gt; &#13;
</pre><p>This template code would render the following HTML, given the preceding example object:</p><pre class="programlisting">&lt;ul&gt; &#13;
    &lt;li&gt;Peebo Sanderson&lt;/li&gt; &#13;
    &lt;li&gt;Udis Petroyka&lt;/li&gt; &#13;
    &lt;li&gt;Jarmond Dittlemore&lt;/li&gt; &#13;
    &lt;li&gt;Chappy Scrumdinger&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec66"/>Lambdas</h3></div></div></div><p>Object property values can also be returned from <em>lambdas</em>, or functions that are passed to return values as data, to the current section's context:</p><pre class="programlisting">{ &#13;
    "people": [ &#13;
        { "firstName": "Peebo", "lastName": "Sanderson" }, &#13;
        { "firstName": "Udis", "lastName": "Petroyka" }, &#13;
        { "firstName": "Jarmond", "lastName": "Dittlemore" }, &#13;
        { "firstName": "Chappy", "lastName": "Scrumdinger" } &#13;
    ], &#13;
    "name": function() { &#13;
        return this.firstName + ' ' + this.lastName; &#13;
    } &#13;
} &#13;
</pre><p>In the case of a list, a lambda will return a value based on the context of the current list item for an iteration:</p><pre class="programlisting">&lt;ul&gt; &#13;
{{#people}} &#13;
    &lt;li&gt;{{name}}&lt;/li&gt; &#13;
{{/people}} &#13;
&lt;/ul&gt; &#13;
</pre><p>In this manner, the preceding template will produce the same output as the previous example:</p><pre class="programlisting">&lt;ul&gt; &#13;
    &lt;li&gt;Peebo Sanderson&lt;/li&gt; &#13;
    &lt;li&gt;Udis Petroyka&lt;/li&gt; &#13;
    &lt;li&gt;Jarmond Dittlemore&lt;/li&gt; &#13;
    &lt;li&gt;Chappy Scrumdinger&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Inverted sections</h2></div></div></div><p>An inverted section in a Mustache template is one that is rendered only when the value for that section's key is <code class="literal">false</code> or <em>falsy</em>, such as <code class="literal">null</code>, <code class="literal">undefined</code>, <code class="literal">0</code>, or an empty list <code class="literal">[]</code>. Take the following object, for example:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Peebo", &#13;
        "last": "Sanderson" &#13;
    }, &#13;
    "email_subscriber": false &#13;
} &#13;
</pre><p>An inverted section begins with a caret <code class="literal">^</code> symbol following the opening curly braces, rather than the pound <code class="literal">#</code> symbol used for a standard section. Given the preceding example object, the following template syntax can be used to render HTML for the <code class="literal">false</code> property value:</p><pre class="programlisting">&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{^email_subscriber}} &#13;
    &lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
{{/email_subscriber}} &#13;
</pre><p>This template would render the following HTML, based on the <code class="literal">false</code> property value in the object:</p><pre class="programlisting">&lt;p&gt;Peebo Sanderson&lt;/p&gt; &#13;
&lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Comments</h2></div></div></div><p>Mustache templates also give you the ability to include comments within your templates. The advantage to using the Mustache syntax for your comments over HTML comments is that they will not be rendered in the HTML output, as would be the case with standard HTML comments:</p><pre class="programlisting">&lt;p&gt;Udis likes to comment{{! hi, this comment won't be rendered }}&lt;/p&gt; &#13;
&lt;!- This is a standard HTML comment -&gt; &#13;
</pre><p>Mustache comments are denoted by a <em>bang</em>, or exclamation point, following the opening curly braces. The preceding template code would render the following:</p><pre class="programlisting">&lt;p&gt;Udis likes to comment&lt;/p&gt; &#13;
&lt;!- This is a standard HTML comment -&gt; &#13;
</pre><p>As shown, the Mustache template comment is not part of the rendered HTML, but the standard HTML comment is. The advantage to using Mustache template comments is in the payload size of the rendered HTML, which you want to keep as small as possible, and there are probably not many cases in which you would actually want to render comments in dynamic HTML. This allows you to have helpful comments for other developers in your template code without it putting a burden on the frontend of the application.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Partials</h2></div></div></div><p>One of the most useful features of Mustache templates is the ability to include <em>partials</em>, or separate templates rendered at runtime within a compiled template. Conceptually, this feature is similar to <em>includes</em> for server-side template languages.</p><p>The syntax for partials uses a greater than <code class="literal">&gt;</code> sign after the opening curly braces followed by the name of the partial. A common file naming convention is to prepend the uncompiled partial filenames with an underscore <code class="literal">_.</code> Consider the following two files:</p><p>
<code class="literal">user.hbs</code>
</p><pre class="programlisting">&lt;h3&gt;{{name.first}} {{name.last}}&lt;/h3&gt; &#13;
{{&gt; user-details}} &#13;
</pre><p>
<code class="literal">_user-details.hbs</code>
</p><pre class="programlisting">&lt;ul&gt; &#13;
    {{^email_subscriber}} &#13;
    &lt;li&gt;I am not an email subscriber&lt;/li&gt; &#13;
    {{/email_subscriber}} &#13;
    &lt;li&gt;Age: {{age}}&lt;/li&gt; &#13;
    &lt;li&gt;Profession: {{profession}}&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre><p>The call to include the partial file is indicated on the second line of user.hbs. This will parse _user-details.hbs in the same context as user.hbs. In a standard compiler setup, the underscore on the partial filename would be excluded from the key name, and the template would be stored within the partials namespace:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Jarmond", &#13;
        "last": "Dittlemore" &#13;
    }, &#13;
    "email_subscriber": false, &#13;
    "age": 24, &#13;
    "profession": "Student" &#13;
} &#13;
</pre><p>Given the preceding example object, the fully rendered HTML from the template would look like the following:</p><pre class="programlisting">&lt;h3&gt;Jarmond Dittlemore&lt;/h3&gt; &#13;
&lt;ul&gt; &#13;
    &lt;li&gt;I am not an email subscriber&lt;/li&gt; &#13;
    &lt;li&gt;Age: 24&lt;/li&gt; &#13;
    &lt;li&gt;Profession: Student&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre><p>As you can see in the example, the key names from the object were used directly in the partial from the same context as the parent template.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Set alternative delimiters</h2></div></div></div><p>One of the more unusual features of Mustache templates is the ability to set <em>alternative </em>delimiters from inside standard Mustache delimiter tags in a template. This is done by using an equals sign <code class="literal">=</code> following the opening standard delimiter tags, inserting the new opening delimiter followed by the new closing delimiter, and an equals sign followed by the standard closing delimiter tags:</p><pre class="programlisting">{{=&lt;% %&gt;=}} &#13;
</pre><p>If this code is placed anywhere inside of a Mustache template, the delimiter tags from below that point will then use the new syntax:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Chappy", &#13;
        "last": "Scrumdinger" &#13;
    }, &#13;
    "email_subscriber": false, &#13;
    "age": 96, &#13;
    "profession": "Oilman" &#13;
} &#13;
</pre><p>Given the preceding object, a template could be constructed using that data combined with alternative delimiter tags for parsing it:</p><pre class="programlisting">&lt;p&gt;Standard tags: {{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{=&lt;% %&gt;=}} &#13;
&lt;p&gt;New tags - Age: &lt;%age%&gt;&lt;/p&gt; &#13;
&lt;%={{ }}=%&gt; &#13;
&lt;p&gt;Standard tags again - Profession: {{profession}}&lt;/p&gt; &#13;
</pre><p>In this example, the standard tags are used once, then the set delimiters feature is used to change the tags to use the ERB style delimiters, then the tags are again changed back to the original standard delimiters:</p><pre class="programlisting">&lt;p&gt;Standard tags: Chappy Scrumdinger&lt;/p&gt; &#13;
&lt;p&gt;New tags - Age: 96&lt;/p&gt; &#13;
&lt;p&gt;Standard tags again - Profession: Oilman&lt;/p&gt; &#13;
</pre><p>The resulting HTML would look like the preceding code, rendered with two entirely different sets of delimiters inside of one template.</p><p>You can learn more about Mustache.js at <a class="ulink" href="http://github.com/janl/mustache.js">github.com/janl/mustache.js</a>, or learn about the original Mustache templates at <a class="ulink" href="http://mustache.github.io">mustache.github.io</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Handlebars.js</h1></div></div></div><p>Handlebars.js templates are also considered <em>logic-less</em> and are largely based on Mustache templates, but provide some additional features. They also exclude some of the features of Mustache templates that the creators did not consider useful.</p><p>Handlebars is one of the more prominent templating engines in the JavaScript community. It is used by several major open source JavaScript frameworks including Backbone.js, Ember.js, and the popular Meteor.js framework. It uses their own reactive flavor of Handlebars templating engine called Spacebars. Due to its popularity, we will cover Handlebars in a bit more depth here.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Explicit path lookup versus recursive path lookup</h2></div></div></div><p>One of the features that differentiates Handlebars templates from Mustache templates is that Handlebars does not support recursive path lookup as Mustache templates do. This concerns sections, or blocks, as they are referred to in Handlebars. When you are in the context of a child property of an object, Handlebars will not automatically look up the scope chain for an expression reference. Instead, you must explicitly define the path to the scope for the variable that you are looking for. This makes the scope in Handlebars templates more meaningful and understandable:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Peebo", &#13;
        "last": "Sanderson" &#13;
    }, &#13;
    "email_subscriber": false, &#13;
    "age": 54, &#13;
    "profession": "Singer" &#13;
} &#13;
</pre><p>Given this object, the following template syntax would work with Mustache templates:</p><pre class="programlisting">&lt;!-- Mustache template --&gt; &#13;
&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#profession}} &#13;
&lt;p&gt;Profession: {{profession}}&lt;/p&gt; &#13;
{{/profession}} &#13;
</pre><p>This template would render the value for the <code class="literal">profession</code> key inside of the block scope for <code class="literal">#profession</code> because Mustache supports recursive path lookup. In other words, a nested context always has access to variables on the parent context above it. This is not the case by default, however, with Handlebars:</p><pre class="programlisting">&lt;!-- Handlebars template --&gt; &#13;
&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#profession}} &#13;
&lt;p&gt;Profession: {{this}}&lt;/p&gt; &#13;
{{/profession}} &#13;
</pre><p>As shown in this example, the <code class="literal">this</code> keyword is used to reference the variable for which the current block context is set. If the <code class="literal">profession</code> variable itself were referenced, this would throw an error in Handlebars.</p><pre class="programlisting">&lt;!-- Handlebars template --&gt; &#13;
&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#profession}} &#13;
&lt;p&gt;Profession: {{../profession}}&lt;/p&gt; &#13;
{{/profession}} &#13;
</pre><p>Additionally, Handlebars can look up the scope chain for a variable with an <strong>explicit path</strong> reference using the <code class="literal">../</code> syntax shown in the preceding code. This syntax mimics that of recursive file path lookups in command-line interfaces. In this example, the <code class="literal">../profession</code> reference simply looks up the variable for which the current block context is set:</p><pre class="programlisting">&lt;p&gt;Peebo Sanderson&lt;/p&gt; &#13;
&lt;p&gt;Profession: Singer&lt;/p&gt; &#13;
</pre><p>The reason Handlebars does not support recursive path lookup by default is for speed. By limiting the path lookup to the current block context, Handlebars templates can render more quickly. A compile time <code class="literal">compat</code> flag is provided to override this functionality and allow recursive path lookups, but the creators of Handlebars advise against this and note that there is a performance cost in doing this.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Helpers</h2></div></div></div><p>Handlebars templates do not support the use of lambdas defined in objects such as Mustache templates, but instead use helpers for added functionality. Helpers in Handlebars are a way to abstract away view logic that might otherwise be done directly in the templates when using a less restrictive templating engine such as Underscore.js. Instead, you can write a helper in the form of a regular JavaScript function, register it on the Handlebars namespace, and in your template, use it as a single expression or a block expression:</p><pre class="programlisting"> &#13;
{ &#13;
    "name": { &#13;
        "first": "Udis", &#13;
        "last": "Petroyka" &#13;
    }, &#13;
    "age": "82" &#13;
} &#13;
 &#13;
</pre><p>Given this example object, a helper can be written to return the user's full name based on the object properties:</p><pre class="programlisting">Handlebars.registerHelper('fullName', function(name) { &#13;
    return name.first + ' ' + name.last; &#13;
}); &#13;
</pre><p>As shown here, the <code class="literal">Handlebars</code> object provides a <code class="literal">registerHelper</code> method that gives you the ability to define a helper by defining the name as the first argument and a lambda as the second argument. Arguments to the lambda can be provided directly from the template context at the point the helper is invoked; in this case, as an expression:</p><pre class="programlisting">&lt;p&gt;Hi, my name is {{fullName name}}.&lt;/p&gt; &#13;
</pre><p>The syntax for the helper, as shown in the preceding example, uses the name of the helper immediately following the opening Handlebars tags followed by any arguments to be passed to the helper; in this case, the <code class="literal">name</code> argument:</p><pre class="programlisting">&lt;p&gt;Hi, my name is Udis Petroyka.&lt;/p&gt; &#13;
</pre><p>The template would then be rendered as HTML with the full name returned from the helper by passing the required object property from the template context.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec67"/>Helpers as block expressions</h3></div></div></div><p>Handlebars templates use block expression syntax to invoke helpers as well. The context for the block expression, however, is entirely dependent upon the way the helper is written. Several built-in block helpers are provided with Handlebars.</p><div><div><div><div><h4 class="title"><a id="ch05lvl4sec28"/>#if block helper</h4></div></div></div><p>A simple <code class="literal">#if</code> block helper is provided with Handlebars for rendering content or not based on Boolean values or truthy versus falsy value resolution. This means that values such as <code class="literal">0</code>, <code class="literal">null</code>, <code class="literal">undefined</code>, and empty lists <code class="literal">[]</code> will resolve as false.</p><p>Consider the following object:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Jarmond", &#13;
        "last": "Dittlemore" &#13;
    }, &#13;
    "email_subscriber": false &#13;
} &#13;
</pre><p>Rather than using the standard Mustache style section implementation, the <code class="literal">#if</code> helper can be invoked on a Boolean value here:</p><pre class="programlisting">&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#if email_subscriber}} &#13;
    &lt;p&gt;I am an email subscriber.&lt;/p&gt; &#13;
{{/if}} &#13;
</pre><p>This template would not render the portion inside of the <code class="literal">#if</code> block because <code class="literal">email_subscriber</code> is <code class="literal">false</code>. The built-in <code class="literal">#if</code> helper also provides the ability to include an <code class="literal">{{else}}</code> section within the <code class="literal">#if</code> block that will render if the passed variable evaluates to <code class="literal">false</code>:</p><pre class="programlisting">&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#if email_subscriber}} &#13;
    &lt;p&gt;I am an email subscriber.&lt;/p&gt; &#13;
{{else}} &#13;
    &lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
{{/if}} &#13;
</pre><p>Given the example object, this template would render the following:</p><pre class="programlisting">&lt;p&gt;Jarmond Dittlemore&lt;/p&gt; &#13;
&lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
</pre><p>Another difference between the <code class="literal">#if</code> helper in Handlebars and a section in Mustache templates is that the context inside of the <code class="literal">#if</code> helper does not change, whereas the context inside of a section is changed to the object property for which it is called.</p></div><div><div><div><div><h4 class="title"><a id="ch05lvl4sec29"/>#unless block helper</h4></div></div></div><p>The <code class="literal">#unless</code> block helper in Handlebars is similar to the inverted section feature in Mustache templates, and it can also be considered the inverse of the Handlebars <code class="literal">#if</code> helper. If the value passed to the <code class="literal">#unless</code> helper is falsy, the block will be rendered:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Chappy", &#13;
        "last": "Scrumdinger" &#13;
    }, &#13;
    "email_subscriber": false &#13;
 &#13;
} &#13;
</pre><p>Consider a template similar to the previous <code class="literal">#if</code> example and based on the preceding object:</p><pre class="programlisting">&lt;p&gt;{{name.first}} {{name.last}}&lt;/p&gt; &#13;
{{#unless email_subscriber}} &#13;
   &lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
{{/if}} &#13;
</pre><p>This template would render the content inside of the <code class="literal">#unless</code> block because the value of <code class="literal">email_subscriber</code> is <code class="literal">false</code>:</p><pre class="programlisting">&lt;p&gt;Chappy Scrumdinger&lt;/p&gt; &#13;
&lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch05lvl4sec30"/>#each block helper</h4></div></div></div><p>The <code class="literal">#each</code> block helper is used to iterate over both lists and objects. In its most basic form, it works just like a Mustache section in the context of a list, but it has additional features that make it much more powerful:</p><pre class="programlisting">{ &#13;
    "people": [ &#13;
        { "firstName": "Peebo", "lastName": "Sanderson" }, &#13;
        { "firstName": "Udis", "lastName": "Petroyka" }, &#13;
        { "firstName": "Jarmond", "lastName": "Dittlemore" }, &#13;
        { "firstName": "Chappy", "lastName": "Scrumdinger" } &#13;
    ] &#13;
} &#13;
</pre><p>In the <code class="literal">#each</code> context for a list, the <code class="literal">this</code> keyword can be used to refer to the current value in the list:</p><pre class="programlisting">&lt;ul&gt; &#13;
{{#each people}} &#13;
    &lt;li&gt;{{this.firstName}} {{this.lastName}}&lt;/li&gt; &#13;
{{/each}} &#13;
&lt;/ul&gt; &#13;
</pre><p>This is similar to the lambda example of iteration for Mustache templates, except that no lambda property value is needed to access the iterated object properties in this case.</p><p>Since the scope for each iteration is constrained to the object that is currently being iterated over in this example, the preceding template could also be more simply written as follows:</p><pre class="programlisting">&lt;ul&gt; &#13;
{{#each people}} &#13;
    &lt;li&gt;{{firstName}} {{lastName}}&lt;/li&gt; &#13;
{{/each}} &#13;
&lt;/ul&gt; &#13;
</pre><p>As you can see, the <code class="literal">this</code> keyword is not necessary to access the properties for each object since the context for each iteration is set to that object.</p></div><div><div><div><div><h4 class="title"><a id="ch05lvl4sec31"/>#with block helper</h4></div></div></div><p>The <code class="literal">#with</code> block helper works much like a standard section in Mustache templates by constraining the context of the current block to the parent key that is passed in:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Peebo", &#13;
        "last": "Sanderson" &#13;
    }, &#13;
    "email_subscriber": false, &#13;
    "age": 54, &#13;
    "profession": "Singer" &#13;
} &#13;
</pre><p>Given this example object, a template can be constructed using the <code class="literal">#with</code> helper to constrain a block to the context of the <code class="literal">name</code> key:</p><pre class="programlisting">&lt;h1&gt;User Information&lt;/h1&gt; &#13;
&lt;dl&gt; &#13;
    &lt;dt&gt;Name&lt;/dt&gt; &#13;
    {{#with name}} &#13;
    &lt;dd&gt;{{first}} {{last}}&lt;/dd&gt; &#13;
    {{/with}} &#13;
    &lt;dt&gt;Age&lt;/dt&gt; &#13;
    &lt;dd&gt;{{age}}&lt;/dd&gt; &#13;
    &lt;dt&gt;Profession&lt;/dt&gt; &#13;
   &lt;dd&gt;{{profession}}&lt;/dd&gt; &#13;
&lt;/dl&gt; &#13;
</pre><p>This template would render the following HTML:</p><pre class="programlisting">&lt;h1&gt;User Information&lt;/h1&gt; &#13;
&lt;dl&gt; &#13;
    &lt;dt&gt;Name&lt;/dt&gt; &#13;
   &lt;dd&gt;Peebo Sanderson&lt;/dd&gt; &#13;
   &lt;dt&gt;Age&lt;/dt&gt; &#13;
    &lt;dd&gt;54&lt;/dd&gt; &#13;
    &lt;dt&gt;Profession&lt;/dt&gt; &#13;
   &lt;dd&gt;Singer&lt;/dd&gt; &#13;
&lt;/dl&gt; &#13;
</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Other differences in Handlebars from Mustache templates</h1></div></div></div><p>Many of the features in Handlebars.js that differentiate it from Mustache.js are designed to make the templates render more quickly in a browser. One of the main features in Handlebars that allows this is the ability to precompile templates, as we covered in <a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>, <em>Model-View-Whatever</em>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Precompiling templates</h2></div></div></div><p>Precompiling the templates converts them to the JavaScript functions that are normally compiled in an application before rendering with other templating engines. Using this feature increases the speed of an application by skipping that step, and it additionally reduces the load on the browser for the application because the JavaScript compiler does not need to be included in the frontend asset payload.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>No alternative delimiters</h2></div></div></div><p>The creators of Handlebars also decided that the ability to set alternative delimiters within a template is not necessary. This further reduces the asset payload for an application if you are not precompiling your templates.</p><p>Usually, the only reason you would want to change the delimiter style for templates, other than personal preference, is to avoid conflicts with another templating language, for example, a server-side templating language that uses the same delimiters. If you were to include your Handlebars templates inside of JavaScript blocks within a server-side template, this issue would materialize. If you precompile your templates or abstract them from your server-side templates by keeping them in their own external JavaScript files, however, that issue can be avoided entirely and there is no need to set alternative delimiters.</p><p>You can learn more about Handlebars.js at <code class="literal">handlbarsjs.com</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Pure.js</h1></div></div></div><p>Pure.js is a JavaScript templating engine that takes the concept of logic-less templates to an even greater extreme than Mustache and Handlebars do. Pure.js uses no special template expression syntax that has to be interpolated before rendering. Instead, it uses only pure HTML tags and CSS selectors, combined with JSON data, to render values in the DOM. In this way, Pure.js uses entirely logic-less views because there is no template markup in which to include any logic.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Markup</h2></div></div></div><p>Using plain HTML, a simple Pure.js template can be constructed like this:</p><pre class="programlisting">&lt;p class="my-template"&gt; &#13;
    Hello, my name is &lt;span&gt;&lt;/span&gt;. &#13;
&lt;/p&gt; &#13;
</pre><p>The empty <code class="literal">&lt;span&gt;</code> element is where you might add data for a particular template, but you can use any HTML tag.</p><pre class="programlisting">var data = { &#13;
    name: 'Udis Petroyka' &#13;
}; &#13;
 &#13;
var directive = { &#13;
    'span': 'name' &#13;
}; &#13;
</pre><p>In this example, we provide the data for the template in the <code class="literal">data</code> variable, and then provide what is called a <code class="literal">directive</code> that tells the templating engine how to map that data:</p><pre class="programlisting">$p('.my-template').render(data, directive); &#13;
</pre><p>Pure.js provides a global <code class="literal">$p</code> object upon which methods for interacting with templates are available. In this case, we are calling the <code class="literal">render()</code> method and passing the <code class="literal">data</code> and the <code class="literal">directive</code> as the arguments:</p><pre class="programlisting">&lt;p class="my-template"&gt; &#13;
    Hello, my name is &lt;span&gt;Udis Petroyka&lt;/span&gt;. &#13;
&lt;/p&gt; &#13;
</pre><p>This would be the rendered result of this simple example. You can learn more about Pure.js at <code class="literal">beebole.com/pure/.</code>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Pug</h1></div></div></div><p>Pug, formally named Jade, is a JavaScript templating engine that is prominent in the Node.js community. It is largely influenced by <strong>HTML abstraction markup language </strong>(<strong>Haml</strong>), which was originally designed to make authoring ERB templates easier by using a cleaner and less verbose syntax than raw HTML. In this way, Pug requires the compilation of not only its expressions, but of the markup language itself.</p><p>Pug is similar to YAML in that hierarchy is denoted by whitespace with indentation for delimiters. This means that no closing element tags are necessary:</p><pre class="programlisting">doctype html &#13;
html(lang="en") &#13;
  head &#13;
    title= pageTitle &#13;
body &#13;
  h1 This is a heading &#13;
  if thisVariableIsTrue &#13;
    p This paragraph will show. &#13;
  else &#13;
    p This paragraph will show instead. &#13;
 &#13;
</pre><p>As shown in this example, Pug can be used as a simple shorthand syntax for HTML. It can also include simple conditionals with variables, all following the same fluid syntax. HTML element attributes are added by including parenthesis after the tag name with the attributes defined inside them, such as <code class="literal">html(lang="en")</code> in the example. Elements populated with variables are indicated by placing an equals sign after the tag name and following it with a JavaScript key name, as shown by <code class="literal">title= pageTitle</code> in the example:</p><pre class="programlisting">{ &#13;
    pageTitle: 'This is a dynamic page title', &#13;
    thisVariableIsTrue: true &#13;
} &#13;
</pre><p>Using this example JavaScript object, the preceding template would render the following HTML:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html lang="en"&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;This is a dynamic page title&lt;/title&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;This is a heading&lt;/h1&gt; &#13;
    &lt;p&gt;This paragraph will show.&lt;/p&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Inline variables can also be used with another syntax that allows for accessing top level properties and nested properties. Consider the following object:</p><pre class="programlisting">{ &#13;
    "name": { &#13;
        "first": "Jarmond", &#13;
        "last": "Dittlemore" &#13;
    }, &#13;
    "email_subscriber": false, &#13;
    "age": 24, &#13;
    "profession": "Student" &#13;
} &#13;
</pre><p>A Pug template can be written to access all variables in this object as follows:</p><pre class="programlisting">h1#title Hello, my name is #{name.first} #{name.last}. &#13;
if email_subscriber &#13;
  p I am an email subscriber. &#13;
else &#13;
  p i am not an email subscriber. &#13;
h2.age Age &#13;
p= 24 &#13;
h2.profession Profession &#13;
p I am a #{profession}. &#13;
</pre><p>In this template, you can see that the inline variable syntax <code class="literal">#{}</code> is used along with a conditional and an element populated with a variable using the <code class="literal">=</code> syntax.</p><p>You will also notice that the <code class="literal">h1</code> tag has a <code class="literal">#</code> symbol immediately following it with the word <code class="literal">title</code>, and the <code class="literal">h2</code> tags have .<code class="literal">className</code> following them. This demonstrates another feature of Pug which allows the use of standard CSS selector syntax to include IDs and classes. The rendered HTML from this template would look as follows:</p><pre class="programlisting">&lt;h1 id="title"&gt;Hello, my name is Jarmond Dittlemore.&lt;/h1&gt; &#13;
&lt;p&gt;I am not an email subscriber.&lt;/p&gt; &#13;
&lt;h2 class="age"&gt;Age&lt;/h2&gt; &#13;
&lt;p&gt;24&lt;/p&gt; &#13;
&lt;h2 class="profession"&gt;Profession&lt;/h2&gt; &#13;
&lt;p&gt;I am a Student.&lt;/p&gt; &#13;
</pre><p>This example shows how much less verbose writing with Pug can be compared to standard HTML combined with another type of template syntax, and that is probably the reason it has become so popular. You can learn more about Pug at <a class="ulink" href="http://pug-lang.com">pug-lang.com</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Embedded JavaScript (EJS)</h1></div></div></div><p>
<strong>EJS</strong> is a JavaScript templating engine that works much like Underscore.js and also uses ERB <code class="literal">&lt;% %&gt;</code> style delimiters. Alternatively, it also allows the use of <code class="literal">[% %]</code> style tags for delimiters.</p><p>Just like Underscore.js, EJS allows arbitrary JavaScript to be parsed when used with the standard <code class="literal">&lt;% %&gt;</code> ERB style syntax, and allows the evaluation of expressions using an equals sign <code class="literal">=</code> following the opening delimiter tag <code class="literal">&lt;%= %&gt;:</code>
</p><pre class="programlisting">&lt;ul&gt; &#13;
&lt;% for (var i = 0; i &lt; people.length; i++) { %&gt; &#13;
    &lt;li&gt;&lt;%= firstName %&gt; &lt;%= lastName %&gt;&lt;/li&gt; &#13;
&lt;% } %&gt; &#13;
&lt;/ul&gt; &#13;
</pre><p>This template can be used to iterate over a list of objects from which key names are evaluated as variables with different values:</p><pre class="programlisting">{ &#13;
    "people": [ &#13;
        { "firstName": "Peebo", "lastName": "Sanderson" }, &#13;
        { "firstName": "Udis", "lastName": "Petroyka" }, &#13;
        { "firstName": "Jarmond", "lastName": "Dittlemore" }, &#13;
        { "firstName": "Chappy", "lastName": "Scrumdinger" } &#13;
    ] &#13;
} &#13;
</pre><p>Iterating over this object with the example template would render the following HTML:</p><pre class="programlisting">&lt;ul&gt; &#13;
    &lt;li&gt;Peebo Sanderson&lt;/li&gt; &#13;
    &lt;li&gt;Udis Petroyka&lt;/li&gt; &#13;
    &lt;li&gt;Jarmond Dittlemore&lt;/li&gt; &#13;
    &lt;li&gt;Chappy Scrumdinger&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Synchronous template loading</h2></div></div></div><p>In a typical EJS use case, each template is stored in a file with the proprietary <code class="literal">.ejs</code> extension. A template is compiled from JavaScript code by creating a new <code class="literal">EJS</code> object, supplying the path to the template file, and calling the render method with the data you want to be interpolated.</p><p>Let's assume the EJS template is saved in a file located in your project at <code class="literal">templates/people.ejs</code>. The following JavaScript could then be written to render it as the HTML shown for this example:</p><pre class="programlisting"> &#13;
var data = { &#13;
    "people": [ &#13;
        { "firstName": "Peebo", "lastName": "Sanderson" }, &#13;
        { "firstName": "Udis", "lastName": "Petroyka" }, &#13;
        { "firstName": "Jarmond", "lastName": "Dittlemore" }, &#13;
        { "firstName": "Chappy", "lastName": "Scrumdinger" } &#13;
    ] &#13;
}; &#13;
var html = new EJS({url: 'templates/people.ejs'}).render(data); &#13;
</pre><p>The global <code class="literal">EJS</code> object is a constructor for which you create a new instance to parse a template and call methods on it for rendering. Note that since the path to the file is referenced in the JavaScript, a <em>synchronous</em> call must be made to initially load the template for parsing. This keeps the initial page load for your application low, but can lead to longer response times when interacting with your app, depending upon both the complexity of the template being loaded and the speed of the server upon which your app is running.</p><p>Once you have the rendered HTML created in your JavaScript code, you simply insert it into the DOM in your application:</p><pre class="programlisting">var html = new EJS({url: 'templates/people.ejs'}).render(data); &#13;
document.body.innerHTML = html; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Asynchronous data loading</h2></div></div></div><p>One unique feature of EJS is the ability to render a template using asynchronous data loaded from an external source. Using the previous example, imagine the JSON data is in an external file named <code class="literal">people.json</code>:</p><pre class="programlisting">new EJS({url: 'templates/people.ejs'}).update('element_id', 'people.json'); &#13;
</pre><p>In this example, the <code class="literal">.update()</code> method is called instead of <code class="literal">.render()</code>. The object instance is also not assigned to a variable because the DOM insertion is handled by the <code class="literal">.update()</code> method as well by passing a DOM node ID. For this method to work, no other CSS selectors can be used for injecting the HTML into the DOM; only an ID will work.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Caching</h2></div></div></div><p>EJS caches templates by default after the first time they are loaded synchronously. This provides an advantage in that templates used multiple times will always load more quickly after the first request, and unused templates will not take up any memory. This approach is in stark contrast to precompiling in which all templates are loaded into memory at the initial page load of the application. Both of these approaches have advantages and disadvantages, so care must be taken to choose the best approach for your particular app.</p><p>Caching can be also be turned off for any template by including a <code class="literal">cache</code> key in the object of options passed into any template instantiation:</p><pre class="programlisting">var html = new EJS({url: 'templates/people.ejs', cache: false}).render(data); &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>View helpers</h2></div></div></div><p>EJS includes some view helpers that are similar to the concept of helpers in Handlebars templates. They allow the use of shorter syntax for some common HTML elements. We will illustrate a few examples here.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec68"/>The link_to view helper</h3></div></div></div><p>The <code class="literal">link_to</code> view helper provides a simple template syntax for insuring HTML hyperlinks:</p><pre class="programlisting">&lt;p&gt;Here is a &lt;%= link_to('link', '/link/path') %&gt; to a path.&lt;/p&gt; &#13;
</pre><p>The first parameter to the <code class="literal">link_to</code> view helper is the displayed text for the link, and the second parameter is the path to be passed to the <code class="literal">href</code> attribute for the link. Also notice that the delimiters for view helpers use the opening expression delimiter syntax. This example would render the following HTML:</p><pre class="programlisting">&lt;p&gt;Here is a &lt;a href="/link/path"&gt;link&lt;/a&gt; to a path.&lt;/p&gt; &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec69"/>The img_tag view helper</h3></div></div></div><p>This <code class="literal">img_tag</code> view helper provides an easy syntax for including images in your rendered HTML:</p><pre class="programlisting">&lt;p&gt;&lt;%= img_tag('/path/to/image.png', 'Description text') %&gt;&lt;/p&gt; &#13;
</pre><p>The first parameter to the <code class="literal">link_to</code> view helper is the path to the image, and the second parameter is the text for the image's <code class="literal">alt</code> attribute. This example would render the following HTML:</p><pre class="programlisting">&lt;p&gt;&lt;img src="img/image.png" alt="Description text"&gt;&lt;/p&gt; &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec70"/>The form_tag view helper</h3></div></div></div><p>The <code class="literal">form_tag</code> view helper provides a syntax for building HTML forms and can be used in conjunction with other view helpers for creating input elements:</p><pre class="programlisting">&lt;%= form_tag('/path/to/action', {method: 'post', multipart: true}) %&gt; &#13;
    &lt;%= input_field_tag('user_input', 'value text here') %&gt; &#13;
    &lt;%= submit_tag('Submit') %&gt; &#13;
&lt;%= form_tag_end() %&gt; &#13;
</pre><p>In this example, four view helpers are used to construct the form. The <code class="literal">form_tag</code> view helper creates the opening form body providing the form action to the first parameter, and other form attributes in the second parameter using a JavaScript object syntax with curly braces. The <code class="literal">input_field_tag</code> view helper is used to create a standard input text field, taking the input name as the first parameter, and optionally, the input value as the second parameter. The <code class="literal">submit_tag</code> view helper creates a form submit input with the button text passed as the first parameter. Finally, the <code class="literal">form_tag_end</code> view helper is used to close the body of the form. This example would render the following HTML:</p><pre class="programlisting">&lt;form action="/path/to/action" method="post" enctype="multipart/form-data"&gt; &#13;
    &lt;input type="text" id="user_input" name="user_input" value="value text here"&gt; &#13;
    &lt;input type="submit" value="Submit"&gt; &#13;
&lt;/form&gt; &#13;
</pre><p>EJS also includes many other view helpers for common HTML elements using the _tag suffix.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Partials</h2></div></div></div><p>EJS has its own implementation of partials that works using its synchronous template loading technique inside of template delimiter tags. To use this feature, a call to the partial template file is made directly inside of the parent template. Consider the following two template files:</p><p>templates/parent.ejs</p><pre class="programlisting">&lt;p&gt;This is the parent template.&lt;/p&gt; &#13;
&lt;%= this.partial({url: 'templates/partial.ejs %&gt; &#13;
</pre><p>templates/partial.ejs</p><pre class="programlisting">&lt;p&gt;This is the partial template.&lt;/p&gt; &#13;
</pre><p>Notice that the call to the partial template references the URL inside of the parent template using the expression syntax delimiters and a call to the <code class="literal">this.partial</code> method. To load the partial template inside of another, only the parent template has to be initialized from your JavaScript code:</p><pre class="programlisting">var html = new EJS({url: 'templates/parent.ejs'}).render(); &#13;
document.body.innerHTML = html; &#13;
</pre><p>The final rendered HTML would look like the following:</p><pre class="programlisting">&lt;p&gt;This is the parent template.&lt;/p&gt; &#13;
&lt;p&gt;This is the partial template.&lt;/p&gt; &#13;
</pre><p>These examples provide a brief overview of EJS, but we will use this templating engine in more depth later. For additional information on EJS templates, visit <code class="literal">embeddedjs.com</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Optimizing your application layout</h1></div></div></div><p>Building a JavaScript SPA can often involve many layers of abstraction including custom application code, third party libraries, frontend frameworks, task runners, transpilers, and more. All of this can end up amounting to a whole lot of JavaScript to be downloaded for the application on the frontend, so steps should always be taken to minimize this impact as much as possible.</p><p>Let's go back to the Node.js example application we have been working with so far. In <a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>, <em>Model-View-Whatever</em> we wrote the index.html layout page for the app with the following script tags included for third party libraries and the compiled templates:</p><pre class="programlisting">&lt;script src="img/jquery.min.js"&gt;&lt;/script&gt; &#13;
&lt;script src="img/handlebars.runtime.min.js"&gt;&lt;/script&gt; &#13;
&lt;script src="img/payload.js"&gt;&lt;/script&gt; &#13;
&lt;script src="img/templates.js"&gt;&lt;/script&gt; &#13;
 &#13;
</pre><p>This is actually a minimal example compared to how many JavaScript files a full-scale application might include.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>UglifyJS and grunt-contrib-uglify</h2></div></div></div><p>A common tool for minifying and concatenating JavaScript files is <strong>UglifyJS</strong>. We can leverage this tool on the command line and automate it using the Grunt task runner and the <strong>grunt-contrib-uglify</strong> task:</p><pre class="programlisting">
<strong>$ npm install grunt-contrib-uglify --save-dev</strong>
</pre><p>Once installed, open up Gruntfile.js and add the following task to existing tasks immediately above the watch task:</p><pre class="programlisting">uglify: { &#13;
    options: { &#13;
        preserveComments: false &#13;
    }, &#13;
    main: { &#13;
        files: { &#13;
            'js/all.min.js': [ &#13;
              'bower_components/jquery/dist/jquery.js', &#13;
              'bower_components/handlebars/handlebars.runtime.js', &#13;
              'bower_components/payloadjs/payload.js', &#13;
              'js/src/templates.js' &#13;
            ] &#13;
        } &#13;
    } &#13;
} &#13;
 &#13;
</pre><p>This sets up the uglify task to remove all comments with the <code class="literal">preserveComments</code> option set to false, to mangle or shorten variable and function names, and to concatenate the indicated list of JavaScript files into the single target filename of <code class="literal">all.min.js</code>. With this setup, UglifyJS will create the smallest possible download size for your JavaScript based on the input files.</p><p>Next, make sure to load the new uglify task at the bottom of Gruntfile.js with the other tasks:</p><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-uglify'); &#13;
</pre><p>Now, all you have to do is run the task on the command line:</p><pre class="programlisting">
<strong>$ grunt uglify</strong>
</pre><p>After running the task, you should see output similar to the following:</p><pre class="programlisting">
<strong>Running "uglify:main" (uglify) task</strong>
<strong>File all.min.js created: 322.28 kB → 108.6 kB</strong>
<strong>&gt;&gt; 1 file created.</strong>
<strong>Done, without errors.</strong>
</pre><p>You will notice that the CLI output indicates the original size of the JavaScript files, and what it is reduced to in the final output on the second line; in this example, showing 322.28 kB → 108.6 kB. In this case, it is compressed to less than half of its original size.</p><p>Now, you can change your index.html layout file to make a call to only one JavaScript file:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;head&gt; &#13;
        &lt;title&gt;My Application&lt;/title&gt; &#13;
    &lt;/head&gt; &#13;
    &lt;body&gt; &#13;
        &lt;div id="app"&gt;&lt;/div&gt; &#13;
        &lt;script src="img/all.min.js"&gt;&lt;/script&gt; &#13;
   &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Placing the <code class="literal">&lt;script&gt;</code> tag at the bottom of the page also ensures that anything above it will be loaded and visible to the user before the JavaScript is entirely downloaded. This is another common practice in optimizing SPAs by preventing a delay before the user sees anything.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>grunt-contrib-handlebars</h2></div></div></div><p>If you are using Handlebars templates in an application, the <strong>grunt-contrib-handlebars</strong> task is available for precompiling them easily from the command line and via the watch task. In <a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>, <em>Model-View-Whatever</em> we created the example <code class="literal">user.handlebars</code> file in the root directory of the project, and in <a class="link" href="ch04.html" title="Chapter 4. REST is Best – Interacting with the Server Side of Your App">Chapter 4</a>, <em>REST is Best - Interacting with the Server Side of Your App</em> we created <code class="literal">users.handlebars</code>. Let's now create a new directory in <code class="literal">js/templates</code> and move the files there. Next, rename the files <code class="literal">user.hbs</code> and <code class="literal">users.hbs</code> for brevity. The <code class="literal">.hbs</code> extension is also widely accepted for Handlebars files:</p><pre class="programlisting">/ &#13;
js/ &#13;
   templates/ &#13;
                   user.hbs &#13;
                   users.hbs &#13;
</pre><p>Next, install the grunt-contrib-handlebars plugin:</p><pre class="programlisting">
<strong>$ npm install grunt-contrib-handlebars --save-dev</strong>
</pre><p>Once installed, add the following task configuration to <code class="literal">Gruntfile.js</code>, just above the <code class="literal">uglify</code> task configuration:</p><pre class="programlisting">handlebars: {&#13;
     options: {&#13;
         namespace: 'Handlebars.templates',&#13;
         processName: <strong>function</strong>(file) {&#13;
             <strong>return</strong> file.replace(/js\/templates\/|\.hbs/g, '');&#13;
         },&#13;
         partialRegex: /.*/,&#13;
         partialsPathRegex: /\/partials\//&#13;
     },&#13;
     files: {&#13;
         src: 'js/templates/**/*.hbs',&#13;
         dest: 'js/src/templates.js'     }&#13;
 } &#13;
</pre><p>The Grunt plugin for Handlebars makes fewer assumptions for you than the Handlebars command-line tool does out of the box, so this configuration does several things for you.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec71"/>Options configuration</h3></div></div></div><p>First, the <code class="literal">options</code> object is passed four parameters. The <code class="literal">namespace</code> option simply tells the compiler what global namespace to use to store the compiled Handlebars template functions. <code class="literal">Handlebars.templates</code>is the default namespace for this with the command line utility, so we will go with that.</p><p>The <code class="literal">processName</code> parameter is passed a function that takes a Handlebars file as the argument and uses it to create the key name for that template in the <code class="literal">Handlebars.templates</code>namespace. In this case, we are using a regex to take the path and filename and remove everything except for the prefix of the filename, so the compiled template function for <code class="literal">user.hbs</code>, for example, would be available at <code class="literal">Handlebars.templates.user</code>.</p><p>The <code class="literal">partialRegex</code> option accepts a regex that is used to identify a pattern for partial filenames. The default for this is a file prefixed with an underscore <code class="literal">_</code>, but in this case, we will be using a directory for partials, so the <code class="literal">partialRegex</code> option is set to <code class="literal">.*</code>, meaning it will identify any file on the given path as a partial.</p><p>The <code class="literal">partialsPathRegex</code> options accepts a regex that is used to identify the path to a directory of partials. We have set it to <code class="literal">/\/partials\//</code> , which will be evaluated as the <code class="literal">/partials</code> directory beneath the main template path that is passed in. Combined with the <code class="literal">partialRegex</code> option, this tells the compiler to parse every file in the <code class="literal">/partials</code> directory as a partial and add its compiled template function to the <code class="literal">Handlebars.partials</code> namespace.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec72"/>Files configuration</h3></div></div></div><p>The files configuration object passed to the Handlebars Grunt task is used to tell the compiler what file pattern to use for finding templates for compiling, and for defining the output filename of the compiled templates:</p><pre class="programlisting">files: { &#13;
    src: 'js/templates/**/*.hbs', &#13;
    dest: 'js/src/templates.js' &#13;
} &#13;
</pre><p>In this case, we have defined the templates <code class="literal">src</code> directory to be located in the <code class="literal">js/templates/</code> under the root path, and to parse all files with the extension <code class="literal">.hbs</code> in that directory and every directory underneath it. The recursive directory lookup is indicated by the <code class="literal">/**/*.hbs</code> syntax.</p><p>The <code class="literal">dest</code> key tells the compiler to create the <code class="literal">js/src/templates.js</code> file with the final compiled output of all the templates.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec73"/>Running the Grunt Handlebars task</h3></div></div></div><p>In order to run the handlebars task, we first need to load the plugin at the bottom of Gruntfile.js:</p><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-handlebars'); &#13;
</pre><p>Next, run the grunt handlebars command from the CLI:</p><pre class="programlisting">
<strong>$ grunt handlebars</strong>
</pre><p>After running the task, you should see output similar to the following:</p><pre class="programlisting">
<strong>Running "handlebars:files" (handlebars) task</strong>
<strong>&gt;&gt; 1 file created.</strong>
<strong>Done, without errors.</strong>
</pre><p>Now, if you look in the <code class="literal">js/src/</code> directory, you should see that a <code class="literal">templates.js</code> file has been created there next to the <code class="literal">app.js</code> file we created in <a class="link" href="ch01.html" title="Chapter 1. Getting Organized with NPM, Bower, and Grunt">Chapter 1</a>, <em>Getting Organized with NPM, Bower, and Grunt</em>. Now that we are storing the <code class="literal">templates.js</code> file here, go ahead and delete the original <code class="literal">templates.js</code> file in the root directory and edit the <code class="literal">files</code> object in the Grunt uglify task to look as follows:</p><pre class="programlisting">files: { &#13;
    'js/all.min.js': [ &#13;
        'bower_components/jquery/dist/jquery.js', &#13;
        'bower_components/handlebars/handlebars.runtime.js', &#13;
        'bower_components/payloadjs/payload.js', &#13;
        'js/src/templates.js' &#13;
    ] &#13;
} &#13;
</pre><p>Now we have added the new <code class="literal">templates.js</code> file to the uglify task so it is included in the full minified application JavaScript.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Watching for changes</h2></div></div></div><p>Now that you are loading the minified JavaScript file, you will probably want to add a watch task to create the file while you are developing so that you do not have to constantly run the command from the CLI.</p><p>For this example, let's assume that we want to detect changes to any files in the <code class="literal">js/src</code> directory where we are actively working. Edit the <code class="literal">watch</code> task configuration in <code class="literal">Gruntfile.js</code> and add the following directly underneath the <code class="literal">jshint</code> target for that task:</p><pre class="programlisting">uglify: { &#13;
    files: ['js/src/*.js'], &#13;
    tasks: ['uglify:main'] &#13;
} &#13;
</pre><p>This tells Grunt to run the <code class="literal">uglify</code> task <code class="literal">main</code> target when it detects changes to files matching the pattern. Additionally, change the <code class="literal">jshint</code> watch task above the <code class="literal">uglify</code> watch task to the following:</p><pre class="programlisting">jshint: { &#13;
    files: ['js/src/*.js', '!js/src/templates.js'], &#13;
    tasks: ['jshint'] &#13;
} &#13;
</pre><p>This tells the watch task to ignore changes to <code class="literal">templates.js</code> for running the jshint task. We want to ignore this file because it is compiled and will not pass JSHint tests.</p><p>Add the same file ignore path to the <em>main </em>
<code class="literal">jshint</code> task <code class="literal">files</code> configuration near the top of the file:</p><pre class="programlisting">files: { &#13;
    src: [ &#13;
        'Gruntfile.js', &#13;
        'js/src/*.js', &#13;
        '!js/src/templates.js' &#13;
    ] &#13;
} &#13;
</pre><p>This will prevent JSHint from checking <code class="literal">templates.js</code> against its defined rules when the <code class="literal">jshint</code> task is run.</p><p>We also need a <code class="literal">watch</code> task for changes to Handlebars template files. Add the following configuration underneath the <code class="literal">uglify</code> target in the <code class="literal">watch</code> task:</p><pre class="programlisting">handlebars: { &#13;
    files: ['js/templates/**/*.hbs'], &#13;
    tasks: ['handlebars'] &#13;
} &#13;
</pre><p>This will watch for any changes to the Handlebars templates and partials and run the <code class="literal">handlebars</code> task accordingly. Doing so will generate the <code class="literal">templates.js</code> file, which will then trigger the uglify watch task to run and compile the full application JavaScript to <code class="literal">all.min.js</code>.</p><p>Next, run the Grunt <code class="literal">watch</code> command from the CLI:</p><pre class="programlisting">
<strong>$ grunt watch</strong>
<strong>Running "watch" task</strong>
<strong>Waiting...</strong>
</pre><p>Now open <code class="literal">user.hbs</code> and change the markup to look like the following example. Note that the <code class="literal">{{name.first}}</code> and <code class="literal">{{name.last}}</code> expressions are updated to the properties we created in MongoDB in <em>
<a class="link" href="ch04.html" title="Chapter 4. REST is Best – Interacting with the Server Side of Your App">Chapter 4</a>, REST is Best - Interacting with the Server Side of Your App </em>:</p><pre class="programlisting">&lt;h3&gt;{{first_name}} {{last_name}}&lt;/h3&gt; &#13;
&lt;p&gt;{{title}}&lt;/&gt; &#13;
</pre><p>Save the file, then check your console where you are running the <code class="literal">watch</code> task. You should see output similar to the following:</p><pre class="programlisting">
<strong>&gt;&gt; File "js/templates/user.hbs" changed.</strong>
<strong>Running "handlebars:files" (handlebars) task</strong>
<strong>&gt;&gt; 1 file created.</strong>
<strong>Done, without errors.</strong>
<strong>Completed in 0.979s - Waiting...</strong>
<strong>&gt;&gt; File "js/src/templates.js" changed.</strong>
<strong>Running "uglify:main" (uglify) task</strong>
<strong>File all.min.js created: 322.28 kB → 108.6 kB</strong>
<strong>&gt;&gt; 1 file created.</strong>
<strong>Done, without errors.</strong>
</pre><p>The change to <code class="literal">user.hbs</code> set off a chain reaction of two tasks to run and your application JavaScript is compiled to the latest version. If you open the compiled <code class="literal">templates.js</code> file, you will see that both a user and a user's property have been created with associated template functions:</p><pre class="programlisting">this["Handlebars"]["templates"]["user"] = Handlebars.template({...}}); &#13;
this["Handlebars"]["templates"]["users"] = Handlebars.template({...}}); &#13;
</pre><p>Next, while the <code class="literal">handlebars</code> task is still running, move the <code class="literal">user.hbs</code> file to the <code class="literal">js/templates/partials</code> directory. This will again trigger the watch task. When it has completed, open <code class="literal">templates.js</code> again and you will notice that the <code class="literal">Handlebars.templates.user</code> property is no longer defined. Instead, a function call to <code class="literal">.registerPartial()</code> is made instead:</p><pre class="programlisting">Handlebars.registerPartial("user", Handlebars.template({...}); &#13;
</pre><p>This will invoke the <code class="literal">user.hbs</code> partial when it is included in a parent template using the Handlebars partials syntax. Now open up <code class="literal">users.hbs</code> and change it to use the <code class="literal">user.hbs</code> partial:</p><pre class="programlisting">{{#each data}} &#13;
    {{&gt; user}} &#13;
{{/each}} &#13;
</pre><p>This will iterate over the user's data provided. In <a class="link" href="ch04.html" title="Chapter 4. REST is Best – Interacting with the Server Side of Your App">Chapter 4</a>, <em>REST is Best - Interacting with the Server Side of Your App</em> we left the test database with only one entry, so let's add another one now to make this example more illustrative.</p><p>In a separate console session, run your local Node.js server with Express:</p><pre class="programlisting">
<strong>$ node server.js</strong>
<strong>App now listening on port 8080</strong>
</pre><p>Now go to localhost:8080 in your browser and add another entry to the database using the POST Request form:</p><pre class="programlisting">First name: Peebo &#13;
Last name: Sanderson &#13;
Title: Singer &#13;
</pre><p>Once you've added an additional record, click on the Load user data link under the GET Request form. You should see output similar to the following:</p><pre class="programlisting">Philip Klauzinski &#13;
Sr. UI Engineer &#13;
 &#13;
Peebo Sanderson &#13;
Singer &#13;
</pre><p>This content was rendered by looping over the user data from MongoDB in <code class="literal">users.hbs</code> and populating the expressions in the <code class="literal">user.hbs</code> partial.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Putting it all together</h2></div></div></div><p>Using a single, minified JavaScript file for your application code, precompiling your JavaScript templates, and loading your JavaScript at the bottom of your application layout page are all good practices to follow in optimizing the download time of your SPA. Including all of the JavaScript in one file versus multiple files is just as important as minifying the JavaScript because it reduces the number of HTTP requests a client has to make in order to load your SPA. This same practice should be used with CSS and can be done with Grunt using plugins such as <code class="literal">grunt-contrib-cssmin</code> and <code class="literal">grunt-postcss</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Summary</h1></div></div></div><p>You should now have a good understanding of the differences among some of the more popular JavaScript templating engines, how to use them for basic views, and some of their advantages and disadvantages. You should also understand the difference between using precompiled templates and templates that are compiled in the browser. Additionally, you have learned about optimizations to use in your layout file to minimize the download size of your app including minification, concatenation into one file, and including JavaScript at the bottom of the document. In the next chapter, we will dive further into the View layer by deconstructing the technique of data binding.</p></div></body></html>