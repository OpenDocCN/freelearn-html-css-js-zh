- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Diving into Microservices Internals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解微服务内部结构
- en: Microservices aren’t just about breaking down a large application into smaller,
    more manageable ones. They also introduce challenges, one of which is communication
    between services. Monolithic applications, which we discussed in the previous
    chapter, make communication between elements relatively straightforward. However,
    in microservice architecture, we have physical isolation between services. Even
    though we want microservices to be independent, as well as easy to reuse, maintain,
    and grow, getting them to talk to each other effectively becomes a major challenge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不仅仅是将大型应用程序拆分成更小、更易于管理的部分。它们还引入了挑战，其中之一就是服务之间的通信。我们在上一章讨论的单一架构应用程序，其元素之间的通信相对简单直接。然而，在微服务架构中，服务之间存在物理隔离。尽管我们希望微服务是独立的，以及易于重用、维护和扩展，但使它们能够有效通信成为一个主要挑战。
- en: Effective microservice communication is crucial for the overall success of architecture.
    It enables services to exchange data, coordinate actions, and trigger events.
    If microservices can’t communicate effectively, they become like isolated islands,
    stopping the application from working properly and keeping it running slowly.
    Well-designed communication patterns ensure that microservices can collaborate
    effectively to deliver the desired functionality. This communication strategy
    also promotes loose coupling, which means that changes in one service have minimal
    impact on others, thereby making the application more resilient and easier to
    maintain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的微服务通信对于架构的整体成功至关重要。它使服务能够交换数据、协调行动并触发事件。如果微服务不能有效通信，它们就像孤岛一样，阻止应用程序正常工作并使其运行缓慢。精心设计的通信模式确保微服务能够有效地协作以提供所需的功能。这种通信策略还促进了松散耦合，这意味着一个服务的更改对其他服务的影响最小，从而使应用程序更具弹性和易于维护。
- en: This chapter is about establishing a strong foundation for the next practical
    chapters, along with providing comprehensive information about microservice communication.
    A solid understanding of microservices communication will help you build reliable,
    consistent, scalable, and fault-tolerant microservice applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为下一章的实践章节奠定坚实的基础，并提供关于微服务通信的全面信息。对微服务通信的深入了解将帮助您构建可靠、一致、可扩展和容错性强的微服务应用程序。
- en: 'In this chapter, we’re going to talk more about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地讨论以下主题：
- en: Microservices communication techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务通信技术
- en: Synchronous microservice communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步微服务通信
- en: Asynchronous microservice communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步微服务通信
- en: Essential communication patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的通信模式
- en: Solidifying the communication
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 巩固通信
- en: As your application grows, managing its complexity becomes increasingly challenging.
    To tackle this, developers rely on best practices, design patterns, and various
    approaches. In traditional software design, techniques like abstraction, encapsulation,
    and decomposition help us deal with complexity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，管理其复杂性变得越来越具有挑战性。为了应对这一挑战，开发者依赖于最佳实践、设计模式和各种方法。在传统的软件开发中，抽象、封装和分解等技术帮助我们处理复杂性。
- en: The microservice architecture offers a provides a powerful solution to complexity
    through the **Separation of Concerns** (**SOC**) principle. This principle breaks
    down a complex system into smaller independent parts, each with a well-defined
    responsibility. Imagine a monolithic application as a mountain; microservices
    allow us to break it down into smaller, more manageable hills through bounded
    contexts. However, this freedom comes at the cost of somehow figuring out how
    to establish communication between microservices. Of course, it is not as easy
    as it was with the monolithic approach, because with that, everything was inside
    one codebase. Creating a connection between elements of a monolith was as simple
    as calling any method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构通过**关注点分离**（**SOC**）原则提供了一种强大的解决方案来应对复杂性。这个原则将复杂系统分解成更小的独立部分，每个部分都有明确的职责。想象一个单一架构应用程序就像一座山；微服务允许我们通过边界上下文将其分解成更小、更易于管理的山丘。然而，这种自由是以某种方式确定如何建立微服务之间通信为代价的。当然，这并不像单一架构方法那样简单，因为那时所有内容都在一个代码库中。创建单体元素之间的连接就像调用任何方法一样简单。
- en: The best way to explain the relationship between monoliths and microservices
    is by using the first two principles of **S.O.L.I.D**, the **Single Responsibility
    Principle** (**SRP**) and the **Open-Closed Principle** (**OCP**), as metaphors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 解释单体和微服务之间关系的最佳方式是利用**S.O.L.I.D**原则的前两个原则，即**单一职责原则**（**SRP**）和**开放封闭原则**（**OCP**），作为隐喻。
- en: The SRP’s core principle of dividing a large problem into smaller, more focused
    units aligns with the microservices approach. We break down the big picture into
    smaller, manageable modules, each with well-defined responsibilities and reasons
    for change. This mirrors the SRP’s aim of splitting classes and modules into manageable
    pieces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SRP的核心原则是将大问题分解为更小、更专注的单元，这与微服务方法相一致。我们将大图分解为更小、更易管理的模块，每个模块都有明确的职责和变更原因。这反映了SRP将类和模块拆分为可管理部分的目标。
- en: '![Figure 2.1: Applying the SRP](img/B09148_02_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：应用 SRP](img/B09148_02_001.jpg)'
- en: 'Figure 2.1: Applying the SRP'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：应用 SRP
- en: The main idea behind the SRP is the SoC, which is also adopted in microservice
    architecture. It promotes dividing a system into independent parts based on functionality.
    This improves maintainability, reduces complexity, and allows for independent
    development and deployment of each part
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SRP背后的主要思想是SoC，这在微服务架构中也得到了采用。它提倡根据功能将系统划分为独立的部分。这提高了可维护性，降低了复杂性，并允许独立开发和部署每个部分。
- en: Metaphorically, the SRP’s abstract idea is to break down the big module into
    smaller one (see Figure 2.2) that are similar to what we get when we divide a
    monolith into smaller services called microservices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从隐喻的角度来看，SRP的抽象思想是将大模块分解为更小的模块（见图 2.2），这与我们将单体分解为称为微服务的较小服务时得到的结果相似。
- en: '![Figure 2.2: Monolithic architecture to microservice architecture](img/B09148_02_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：单体架构到微服务架构](img/B09148_02_002.jpg)'
- en: 'Figure 2.2: Monolithic architecture to microservice architecture'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：单体架构到微服务架构
- en: The final results of splitting up your monolithic application are microservices;
    they are software entities for us in this comparison. Making them open for an
    extension means that there is a team that works on them. This team can extend
    and modify them without depending on other teams or modules. Having loose coupling
    between services allows us to independently work on services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将单体应用程序拆分后的最终结果是微服务；在这个比较中，它们是软件实体。使它们易于扩展意味着有一个团队在处理它们。这个团队能够扩展和修改它们，而不依赖于其他团队或模块。服务之间的松散耦合使我们能够独立工作。
- en: 'However, there’s a catch: *communication*. With multiple smaller entities instead
    of one monolithic class, the application relies on communication to function as
    a whole. While the SRP creates independent subsystems, it doesn’t address the
    challenges of enabling communication between them. In fact, the SRP itself can
    contribute to this complexity. The SRP can leave you with multiple smaller subsystems
    without solving communication issues between them.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个问题：*通信*。与一个单体类相比，多个较小的实体需要依赖通信才能作为一个整体运行。虽然SRP创建了独立的子系统，但它没有解决它们之间通信的挑战。事实上，SRP本身也可能导致这种复杂性。SRP可能会让你拥有多个较小的子系统，但并没有解决它们之间的通信问题。
- en: This is where the OCP comes in. The OCP states that software should be open
    for extension but closed for modification. From a metaphorical perspective, in
    the context of microservices, this means designing communication mechanisms that
    are flexible and adaptable to future changes without requiring modifications to
    existing services.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是OCP发挥作用的地方。OCP指出，软件应该易于扩展但不易于修改。从隐喻的角度来看，在微服务的背景下，这意味着设计灵活且适应未来变化的通信机制，而无需修改现有服务。
- en: When one microservice (we’ll call it *Microservice A*) asks for some resource
    from another microservice (*Microservice B*), it doesn’t need to know the internals
    of Microservice B. In exchange for that, Microservice B may use a different implementation
    form of the same endpoint without notifying Microservice A
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个微服务（我们将它称为*微服务A*）从另一个微服务（我们将它称为*微服务B*）请求某些资源时，它不需要了解微服务B的内部结构。作为交换，微服务B可能使用与微服务A相同的端点但不同实现形式，而无需通知微服务A。
- en: Microservice communication techniques
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务通信技术
- en: The biggest communication challenge with microservices is establishing reliable
    and scalable connections between them. We use different techniques to handle microservices
    communication. It is worth mentioning that there are multiple techniques to achieve
    proper communication between microservices. However, in this chapter, we will
    only focus on the most popular ones, as well as the ones that we think are most
    important. Let’s explore these techniques together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务最大的通信挑战是建立它们之间可靠和可扩展的连接。我们使用不同的技术来处理微服务通信。值得一提的是，有多种技术可以实现微服务之间的适当通信。然而，在本章中，我们只会关注最流行和我们认为最重要的技术。让我们一起来探索这些技术。
- en: Introduction to APIs
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API简介
- en: In software development, **Application Programming Interfaces** (**APIs**) are
    important tools that help us avoid doing the same tasks over and over. APIs protect
    us from the complexities of our working environment and area of expertise, making
    it easier to manage complicated processes and ignore detailed domain knowledge.
    They encapsulate complexity, making it unnecessary to understand the underlying
    implementation details. APIs by themselves are black boxes that provide only the
    required information. This means that we don’t have to worry about the nitty-gritty
    technical stuff and can focus on using the provided interfaces to interact with
    our environment. For example, when we use a framework, we see all the DLLs (packages)
    as APIs that give us the functions that we need.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，**应用程序编程接口**（**APIs**）是帮助我们避免重复做同样任务的重要工具。API保护我们免受工作环境和专业领域的复杂性，使我们更容易管理复杂的过程并忽略详细的领域知识。它们封装了复杂性，使得理解底层实现细节变得不必要。API本身是黑盒，只提供所需的信息。这意味着我们不必担心琐碎的技术细节，可以专注于使用提供的接口与环境交互。例如，当我们使用框架时，我们看到所有的DLL（包）都是API，它们为我们提供了所需的函数。
- en: A web-based API is just a type of API. It’s used to help different programs
    share information over the internet using standard web rules and methods. Usually,
    these APIs are seen as REST APIs or **Simple Object Access Protocol** (**SOAP**)
    services and rely on client-server architecture. This allows for creating connections
    between various online resources such as websites or services, which can help
    in building big systems like microservices or just in sharing data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的API只是API的一种类型。它用于帮助不同的程序通过标准网络规则和方法在互联网上共享信息。通常，这些API被视为REST API或**简单对象访问协议**（**SOAP**）服务，并依赖于客户端-服务器架构。这允许在网站或服务等各种在线资源之间建立连接，有助于构建像微服务或仅仅是在共享数据方面的大型系统。
- en: '![Figure 2.3: Client-server architecture](img/B09148_02_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：客户端-服务器架构](img/B09148_02_003.jpg)'
- en: 'Figure 2.3: Client-server architecture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：客户端-服务器架构
- en: We talked about REST here, but what does it mean? Let’s discuss this in the
    next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论了REST，但它究竟意味着什么？让我们在下一节中讨论这个问题。
- en: What exactly is REST?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST究竟是什么？
- en: '**Representational State Transfer** (**REST**) is a style of architecture that
    is used for building applications that are loosely connected over the HTTP protocol.
    It’s important to note that REST is primarily a design approach rather than a
    strict architectural pattern. When I consider the differences between architectural
    style and pattern, I always perceive abstraction and implementation.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示状态转换**（**REST**）是一种用于构建通过HTTP协议松散连接的应用程序的架构风格。需要注意的是，REST主要是一种设计方法，而不是严格的架构模式。当我考虑架构风格和模式之间的区别时，我总是感知到抽象和实现。'
- en: An architectural *style* defines a set of principles and guidelines for organizing
    a system’s structure. It provides a high-level abstraction of how different components
    should interact and communicate with each other. Architectural styles are broad,
    conceptual approaches to designing software systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑风格定义了一套组织和构建系统结构的原理和指南。它提供了一个高级抽象，说明了不同组件应该如何相互交互和通信。建筑风格是设计软件系统的广泛、概念性的方法。
- en: An architectural *pattern*, on the other hand, is a specific solution to a recurring
    architectural problem. It’s a reusable design blueprint or template that describes
    how to solve a particular design problem within a given architectural style. It
    provides a concrete blueprint for implementing a particular aspect of the style.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，建筑模式是对重复出现的建筑问题的一种特定解决方案。它是一个可重用的设计蓝图或模板，描述了在给定的建筑风格中如何解决特定设计问题。它为实施风格的特定方面提供了一个具体的蓝图。
- en: Many call REST a protocol. However, REST itself isn’t a standardized protocol,
    although it’s commonly implemented using web standards today. While it’s often
    associated with HTTP, it’s not limited to this protocol; REST can work with other
    protocols too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人称 REST 为协议。然而，REST 本身不是一个标准化的协议，尽管它今天通常使用网络标准来实现。虽然它通常与 HTTP 相关，但它并不仅限于这个协议；REST
    也可以与其他协议一起工作。
- en: To simplify, think of REST as a blueprint for how systems should communicate.
    It outlines how a client (such as a web browser) can request information from
    a server, and how the server responds, potentially changing the client’s state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将 REST 视为系统通信的蓝图。它概述了客户端（如网页浏览器）如何从服务器请求信息，以及服务器如何响应，可能改变客户端的状态。
- en: The core ideas behind REST are resource, representation, state, and transfer.
    When a client requests a resource from a server, the server sends back a representation
    of that resource, which is essentially a copy. If the state of the resource changes
    later, the client can request it again to get the latest version. The process
    of sending this resource from server to client is the transfer part of REST.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: REST 的核心思想是资源、表示、状态和传输。当客户端从服务器请求资源时，服务器会发送该资源的表示，这本质上是一个副本。如果资源的状态后来发生变化，客户端可以再次请求它以获取最新版本。将此资源从服务器发送到客户端的过程是
    REST 的传输部分。
- en: '![Figure 2.4: An overview of REST](img/B09148_02_004.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4：REST 概述](img/B09148_02_004.jpg)'
- en: 'Figure 2.4: An overview of REST'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：REST 概述
- en: So, why is REST important?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 REST 很重要？
- en: It separates the client and server, breaking their direct reliance on each other.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将客户端和服务器分开，打破了它们对彼此的直接依赖。
- en: It’s **platform-independent**, meaning that it’s not restricted to any particular
    system.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**平台无关的**，这意味着它不受任何特定系统的限制。
- en: It’s **language-agnostic**. Whether you’re coding in PHP, C#, Node.js, or any
    other language, you can implement REST services.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**语言无关的**。无论你是在用 PHP、C#、Node.js 还是任何其他语言编码，你都可以实现 REST 服务。
- en: It’s flexible with data formats, supporting both XML and JSON, among others.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对数据格式灵活，支持 XML 和 JSON 等多种格式。
- en: It facilitates building distributed systems, enabling components to be spread
    across different locations.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它促进了分布式系统的构建，使组件可以分布在不同的位置。
- en: It offers discoverability, making it easy to identify and access resources.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了可发现性，使得识别和访问资源变得容易。
- en: It’s straightforward to use, simplifying the process of integrating services.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用简单，简化了服务集成的过程。
- en: It leverages **HTTP cache**, improving performance by storing frequently accessed
    data locally.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用 **HTTP 缓存**，通过在本地存储频繁访问的数据来提高性能。
- en: With this understanding, let’s look at some of the constraints of REST.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种理解，让我们来看看 REST 的一些约束。
- en: What are some REST constraints?
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有哪些 REST 限制？
- en: The key indicator that a service follows REST principles lies in the constraints
    it follows. REST adheres to six constraints, five of which are mandatory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务遵循 REST 原则的关键指标在于它遵循的约束。REST 遵循六个约束，其中五个是强制性的。
- en: '`students` is the resource.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`students` 是资源。'
- en: '**Manipulating resources through representation**: If a client can modify a
    resource, metadata about how to do so should be included with the returned representation.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示操作资源**：如果客户端可以修改资源，则应在返回的表示中包含有关如何操作的数据。'
- en: '**Self-descriptive messages**: Each request should contain all necessary information,
    which is typically conveyed via HTTP headers.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我描述的消息**: 每个请求都应该包含所有必要的信息，这些信息通常通过 HTTP 头部传递。'
- en: '**Hypermedia As the Engine of Application State** (**HATEOAS**): Requests should
    provide documentation, enabling clients to discover other resources easily.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态引擎**（**HATEOAS**）：请求应提供文档，使客户端能够轻松发现其他资源。'
- en: '**Client-server constraint**: This constraint separates the client and server.
    Here, a client and server facilitate data exchange. They evolve independently
    and remain ignorant of each other’s architecture.*   **Stateless constraint**:
    This ensures communication without maintaining session data. The servers don’t
    retain client session data, and each request is independent of others.*   **Cacheable
    constraint**: To improve speed and efficiency, responses should be cacheable,
    and the caching should be managed via headers. Instead of fetching data from the
    server every time, we should use the cached version that helps reduce load to
    the server and speed up response times.*   **Layered system**: To reduce complexity,
    the server architecture is organized hierarchically, and each layer only interacts
    with the one adjacent to it.*   **Code on demand constraint**: Servers can provide
    executable code examples to clients, though this is not mandatory due to security
    concerns.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器约束**：这种约束将客户端和服务器分开。在这里，客户端和服务器促进数据交换。它们独立发展，并且对彼此的架构一无所知。'
- en: The most popular implementation based on REST is called **RESTful services**.
    RESTful services heavily rely on REST principles. However, this doesn’t mean that
    using RESTful service creation tools will always ensure that you end up with REST-based
    services. You should learn and apply these principles to make your API more **RESTable**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于REST的最流行实现称为**RESTful服务**。RESTful服务高度依赖于REST原则。但这并不意味着使用RESTful服务创建工具就一定能确保您最终得到基于REST的服务。您应该学习和应用这些原则，使您的API更加**RESTful**。
- en: Think of RESTful APIs as a common language for microservices. One service can
    send an HTTP request (such as `get user data`) to another and get the information
    it needs. This keeps things simple and avoids messy situations wherein services
    need to understand each other’s inner workings
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将RESTful API视为微服务的一种通用语言。一个服务可以向另一个服务发送HTTP请求（例如`获取用户数据`），并获取所需的信息。这使事情变得简单，避免了服务需要理解彼此内部工作的情况。
- en: RESTful APIs act like messengers between microservices, ensuring they work together
    smoothly, even though they’re separate components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API在微服务之间充当信使，确保它们即使作为独立的组件也能顺利协同工作。
- en: How does a RESTful API work?
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTful API是如何工作的？
- en: Imagine information such as pictures, text, or data stored online. This information
    is like a resource. When an application needs this resource, it sends a message,
    which is called a request, to the server to ask for it. Think of the request as
    a polite way to ask for something.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在线存储的信息，如图片、文本或数据。这些信息就像是一种资源。当应用程序需要这种资源时，它会发送一个消息，称为请求，向服务器请求它。将请求视为一种礼貌地请求某物的途径。
- en: To make sure that the server understands the request, the application follows
    a set of instructions, like a recipe. These instructions are called documentation
    and are provided by the server creator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保服务器理解请求，应用程序遵循一系列指令，就像食谱一样。这些指令被称为文档，由服务器创建者提供。
- en: Depending on how sensitive the information is, the server might check the application’s
    identity, similar to checking your ID before entering a secure place. This is
    called authentication. Once the server has received and understood the request,
    it processes it and finds the information. Then the server sends a response back
    to the application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据信息的敏感程度，服务器可能会检查应用程序的身份，类似于进入安全场所前检查您的身份证件。这被称为身份验证。一旦服务器收到并理解了请求，它就会处理它并找到所需的信息。然后服务器将响应发送回应用程序。
- en: HTTP-based REST implementation
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于HTTP的REST实现
- en: Developers often build RESTful APIs using a special language for web communication
    called HTTP, which is like a language for talking to websites. In this language,
    there are special words called **HTTP methods** that tell the server what to do
    with the information (the resource). Let’s discover the most used HTTP methods
    together in the next few subsections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常使用一种称为HTTP的特殊网络通信语言来构建RESTful API，这种语言类似于与网站交谈的语言。在这种语言中，有一些特殊的词汇称为**HTTP方法**，它们告诉服务器如何处理信息（资源）。让我们在接下来的几个小节中一起发现最常用的HTTP方法。
- en: GET
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET
- en: We as developers use the GET method when we want to ask for some representation
    of the given resource without changing it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们作为开发者想要请求给定资源的表示而不更改它时，我们使用 GET 方法。
- en: The HTTP GET method is a request for the server to retrieve a specific resource
    without modifying it. It’s like saying “Please give me this information.”
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP GET 方法是服务器检索特定资源而不对其进行修改的请求。这就像说“请给我这个信息。”
- en: 'Here’s a breakdown of how it works:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何工作的分解：
- en: You (the client, like your web browser) send a request to the server using the
    GET method. This request is like a message asking for the resource you want.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你（客户端，比如你的网络浏览器）使用 GET 方法向服务器发送请求。这个请求就像一条消息，请求你想要的资源。
- en: The website (server) receives the request and understands what you’re asking
    for because of the GET method.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站接收请求，并由于 GET 方法而理解了你的请求。
- en: The website (server) finds the information that you requested and sends it back
    to you in response. This response might include things like text, images, or other
    data.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站找到你请求的信息，并以响应的形式将其发送给你。这个响应可能包括文本、图像或其他数据。
- en: Think of it like asking a friend to show you a picture on their phone. You wouldn’t
    just grab it; you’d politely ask to see it. Similarly, the GET method allows you
    to get information politely from a website.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，请求朋友在他们的手机上给你看一张照片。你不会只是抢过来；你会礼貌地请求看它。同样，GET 方法允许你礼貌地从网站获取信息。
- en: It’s important to note that the GET method is used for retrieving information
    and shouldn’t be used for changing or modifying anything on the website. Think
    of it like borrowing a book from the library, not writing in it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，GET 方法用于检索信息，不应用于更改或修改网站上的任何内容。想象一下，从图书馆借书，而不是在书上写东西。
- en: POST
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST
- en: The POST method is used to create a resource on the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: POST 方法用于在服务器上创建资源。
- en: Think of the POST method as a secure way to send information to the website
    (server). It’s like filling out a form and clicking *submit* to send your data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将 POST 方法想象成一种安全地向网站（服务器）发送信息的方法。这就像填写一个表单并点击 *提交* 来发送你的数据。
- en: 'Here’s how it works:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何工作的：
- en: You (the client) fill out a form with the information you want to send (such
    as your name and email).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你（客户端）填写一个表单，包含你想要发送的信息（如你的名字和电子邮件）。
- en: Your tool (usually a browser) sends a request to the website (server) using
    the POST method. This request includes the information you entered on the form.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的工具（通常是浏览器）使用 POST 方法向网站（服务器）发送请求。这个请求包括你在表单中输入的信息。
- en: The website (server) receives the request and understands the information because
    of the POST method.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站接收请求，并由于 POST 方法而理解了信息。
- en: The server processes the information you send which may involve actions like
    creating an account, storing a comment, or sending an email.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器处理你发送的信息，这可能涉及创建账户、存储评论或发送电子邮件等操作。
- en: The website (server) might then send a response back to you, such as a confirmation
    message or a new page to see.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站可能会然后发送一个响应给你，比如确认消息或一个新页面来查看。
- en: Think of it like sending a package to a friend. You wouldn’t just leave it on
    their doorstep; you’d package it and send it through a reliable service. Similarly,
    the POST method allows you to securely send information to a website.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，向朋友发送包裹。你不会只是把它放在他们的门口；你会打包并通过可靠的快递服务发送。同样，POST 方法允许你安全地向网站发送信息。
- en: It’s crucial to remember that the POST method is primarily used for sending
    and processing information, not just for viewing it. Unlike GET, which retrieves
    information, POST typically triggers actions on the server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，POST 方法主要用于发送和加工信息，而不仅仅是查看信息。与用于检索信息的 GET 不同，POST 通常会在服务器上触发操作。
- en: PUT
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PUT
- en: We use the HTTP PUT method to update the existing information on the server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 HTTP PUT 方法来更新服务器上的现有信息。
- en: Think of PUT as a way to carefully update existing information on a website
    (server). It’s like carefully revising a document or updating your profile details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将 PUT 想象成一种小心地更新网站（服务器）上现有信息的方法。这就像仔细修订文档或更新你的个人资料详情。
- en: 'Here’s a breakdown of how it works:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何工作的分解：
- en: You (the client, like your web browser) prepare the updated information, for
    example, changes to your profile picture or edited text in a document.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你（客户端，比如你的网络浏览器）准备更新的信息，例如更改你的个人资料图片或文档中的编辑文本。
- en: Your browser sends a request to the website (server) using the PUT method. This
    request includes the updated information you prepared.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的浏览器使用 PUT 方法向网站（服务器）发送请求。此请求包含您准备好的更新信息。
- en: The website (server) receives the request and understands what needs to be updated
    because of the PUT method.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站（服务器）通过 PUT 方法接收请求并理解需要更新的内容。
- en: The server carefully replaces the existing information with the updated version
    that you sent. This is similar to carefully replacing a page in a book with a
    revised version.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器仔细地将您发送的更新版本替换现有的信息。这类似于仔细替换书中的修订版页面。
- en: The website (server) might then send a response back to you, such as a confirmation
    message or the updated information itself.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站可能会随后向您发送响应，例如确认消息或更新的信息本身。
- en: It’s important to remember that using PUT requires caution and accuracy because
    it directly modifies existing information. Think of it like carefully editing
    a document; making a mistake could result in changing or losing important information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住使用 PUT 需要谨慎和准确，因为它直接修改现有信息。想象一下，就像仔细编辑文档一样；犯错误可能会导致更改或丢失重要信息。
- en: The PUT method is typically used when you know exactly what information needs
    to be updated and you want to replace it completely. It’s not for retrieving information
    like GET or creating new information like POST.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PUT 方法通常用于您确切知道需要更新的信息，并且希望完全替换它。它不用于检索信息（如 GET）或创建新信息（如 POST）。
- en: DELETE
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DELETE
- en: The HTTP DELETE method acts like a digital eraser, carefully removing a specific
    piece of information from a server. You can think of it as deleting a single item
    from your shopping list, leaving the rest untouched.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP DELETE 方法就像数字橡皮擦，仔细地从服务器中删除特定的信息。您可以将其想象为从您的购物清单中删除单个项目，而其余部分保持不变。
- en: 'Here’s how it works:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何工作的：
- en: You (the client), like your web browser, decide to remove something specific,
    such as an old photo or an outdated article.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您（客户端），就像您的网络浏览器一样，决定删除某些特定内容，例如旧照片或过时的文章。
- en: Your browser sends a DELETE request to the server, pinpointing the exact item
    that you want to remove. This is like pointing your finger at the item on your
    shopping list.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的浏览器向服务器发送 DELETE 请求，精确指出您想要删除的特定项目。这就像在您的购物清单上指明项目一样。
- en: The server receives the request and understands the intention because of the
    DELETE method.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过 DELETE 方法接收请求并理解其意图。
- en: The server carefully removes the specified item from its storage, similar to
    crossing off the item on your list.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器仔细地从其存储中移除指定的项目，类似于在您的清单上划掉项目。
- en: The server might reply with a confirmation message letting you know that the
    deletion happened successfully, or simply remain silent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能会回复一个确认消息，让您知道删除操作已成功完成，或者简单地保持沉默。
- en: 'You should remember that using DELETE is like using an eraser: it’s permanent.
    Once something is gone, it’s usually gone for good. So, be sure that you truly
    want to remove the item before sending the DELETE request.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住使用 DELETE 就像使用橡皮擦一样：它是永久的。一旦某物被删除，通常就会永久消失。因此，在发送 DELETE 请求之前，请确保您确实想要删除该项目。
- en: DELETE is different from other methods. Unlike GET (used for getting information)
    or POST (used for creating new information), DELETE specifically removes something.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 与其他方法不同。与用于获取信息的 GET（或用于创建新信息的 POST）不同，DELETE 专门用于删除某些内容。
- en: It’s important to be precise with DELETE requests, as they target a specific
    item and cannot be undone easily.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DELETE 请求中保持精确很重要，因为它们针对特定项目，并且无法轻易撤销。
- en: PATCH
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PATCH
- en: The PATCH method acts like a touch-up tool for information on a server. It’s
    similar to the PUT method, but PATCH lets you update certain parts of the information,
    like editing specific sections of a document without changing the whole thing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PATCH 方法类似于服务器上信息的修补工具。它与 PUT 方法类似，但 PATCH 允许您更新信息的一部分，例如编辑文档的特定部分而不改变整个文档。
- en: Imagine that you have a shopping list with items like bread, milk, and eggs.
    You realize that you need more milk, but everything else is fine. Instead of rewriting
    the entire list, you can use PATCH to update just the milk quantity. This way,
    the rest of the list stays the same.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一个包含面包、牛奶和鸡蛋等项目的购物清单。您意识到您需要更多的牛奶，但其他一切都很正常。您不必重写整个清单，可以使用 PATCH 仅更新牛奶的数量。这样，清单的其余部分保持不变。
- en: 'Here’s the breakdown:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是分解：
- en: You (the user) decide to change a specific part of something, such as updating
    the price of an item online.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您（用户）决定更改某个特定部分，例如在线更新商品的价格。
- en: You send a PATCH request to the server, pointing out the exact part you want
    to modify, such as the price in our example.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您向服务器发送一个 PATCH 请求，指出您想要修改的确切部分，例如在我们的例子中是价格。
- en: The server understands the request because of the PATCH method.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器因为 PATCH 方法理解了请求。
- en: The server carefully updates only the chosen part, leaving the rest untouched,
    similar to editing just one section of a document.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器仔细地只更新了选定的部分，其余部分保持不变，类似于只编辑文档的一个部分。
- en: The server might then send confirmation or simply show the updated information.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器可能会发送确认信息，或者简单地显示更新后的信息。
- en: Take note that PATCH is a method for making targeted updates, modifying only
    specific parts of a resource. It’s useful when you only want to change specific
    parts of something, keeping the rest the same. This makes it more flexible and
    efficient than completely rewriting everything like with the PUT method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，PATCH 是一种用于进行针对性更新的方法，仅修改资源的具体部分。当您只想更改某个特定部分时，保持其余部分不变，这使其比完全重写（如使用 PUT
    方法）更灵活和高效。
- en: Now that we understand the HTTP verbs, let’s move onto the HTTP status codes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 HTTP 动词，让我们继续讨论 HTTP 状态码。
- en: HTTP response status codes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 响应状态码
- en: HTTP uses client-server architecture. Sending requests always ends with a response.
    Depending on the request, you may end up with different response status codes
    that indicate the result of the operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 使用客户端-服务器架构。发送请求总是以响应结束。根据请求，您可能会得到不同的响应状态码，这些状态码表示操作的结果。
- en: 'HTTP status codes are responses from the server indicating the success or failure
    of your request.These codes are organized into five main groups:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码是服务器对您的请求成功或失败的反应。这些代码被组织成五个主要组：
- en: Informational responses (`100` – `199`)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息响应（`100` – `199`）
- en: Successful responses (`200` – `299`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功响应（`200` – `299`）
- en: Redirection messages (`300` – `399`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向消息（`300` – `399`）
- en: Client error responses (`400` – `499`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端错误响应（`400` – `499`）
- en: Server error responses (`500` – `599`)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器错误响应（`500` – `599`）
- en: 'Let’s cover the most used HTTP response status codes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最常用的 HTTP 响应状态码：
- en: '`2`):'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`):'
- en: '**200 OK**: This is the best message you can get! It means that the server
    understood your request and did what you asked.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 OK**：这是您可以得到的最好的消息！这意味着服务器理解了您的请求并完成了您的要求。'
- en: '**201 Created**: This code means that your request resulted in creating something
    new, such as a new document or account.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 已创建**：这个代码表示您的请求导致创建了新的东西，比如新的文档或账户。'
- en: '`3`):'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`):'
- en: '**301 Moved Permanently**: This tells you that the requested item has been
    moved to a new location permanently. The server usually gives you the new address.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**301 永久移动**：这告诉您请求的项目已经永久移动到新的位置。服务器通常会提供新的地址。'
- en: '**302 Found**: This code means that the requested item is temporarily at a
    new location. The server also provides the new address.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**302 找到**：这个代码表示请求的项目暂时位于新的位置。服务器还提供了新的地址。'
- en: '`4`):'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`):'
- en: '**404 Not Found**: This is a common code indicating that the server couldn’t
    find the item you requested, like a missing book in a library.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 未找到**：这是一个常见的代码，表示服务器找不到您请求的项目，就像图书馆里丢失的一本书一样。'
- en: '**401 Unauthorized**: This code indicates that you are not allowed to access
    the requested item, like trying to enter a locked room.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401 未授权**：这个代码表示您无权访问请求的项目，就像试图进入一个锁着的房间一样。'
- en: '**403 Forbidden**: This code means that you are authorized but don’t have permission
    to access the specific item, like having a key but not being allowed into a specific
    room.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**403 禁止访问**：这个代码表示您有权限，但没有权限访问特定的项目，就像有钥匙但被禁止进入特定的房间一样。'
- en: '**413 Request Entity Too Large**: This code indicates that the data you sent
    in your request is too large for the server to handle, like trying to fit too
    many books into a small box.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**413 请求实体过大**：这个代码表示您在请求中发送的数据对于服务器来说太大，就像试图把太多的书塞进一个小盒子一样。'
- en: '**429 Too Many Requests**: This code means you’ve made too many requests in
    a short period of time, like trying to borrow too many books at once.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**429 请求过多**：这个代码表示您在短时间内发出了过多的请求，就像试图一次性借阅太多的书一样。'
- en: '`5`):'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`):'
- en: '**500 Internal Server Error**: This code means that the computer encountered
    an internal problem and couldn’t fulfill your request, like a library experiencing
    technical issues.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500内部服务器错误**：这个代码意味着计算机遇到了内部问题，无法满足你的请求，就像图书馆遇到技术问题一样。'
- en: '**503 Service Unavailable**: This code indicates that the computer is temporarily
    unavailable due to maintenance or overload, like a library being closed for renovation.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**503服务不可用**：这个代码表示计算机因维护或过载而暂时不可用，就像图书馆因翻修而关闭一样。'
- en: Remember, these are just a few examples but understanding them can help you
    decode the messages from websites and navigate the online world more smoothly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这只是几个例子，但理解它们可以帮助你解码网站上的信息，并更顺畅地在网上导航。
- en: Introduction to GraphQL
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL简介
- en: The two main ways in which we design and work with APIs nowadays are using REST
    and **GraphQL**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在设计和处理API的两种主要方式是使用REST和**GraphQL**。
- en: Usually, when developers begin their journey in API development, they start
    by making a REST API. However, as they dive deeper into the specifics, they realize
    that the REST approach doesn’t always work perfectly for every situation. GraphQL
    then steps in to help when REST isn’t the best fit.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当开发者开始他们的API开发之旅时，他们首先从创建一个REST API开始。然而，随着他们深入了解具体细节，他们意识到REST方法并不总是适用于所有情况。这时，GraphQL就介入以帮助REST不适合的情况。
- en: Even though Facebook started using GraphQL in real projects as early as 2012,
    when it was still called SuperGraph, it wasn’t shared with the public until 2016.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Facebook早在2012年就开始在真实项目中使用GraphQL（当时称为SuperGraph），但它直到2016年才向公众分享。
- en: Today, GraphQL has become the preferred method for designing and interacting
    with APIs, surpassing REST in popularity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GraphQL已经成为设计和交互API的首选方法，在受欢迎程度上超过了REST。
- en: The primary reason for adopting GraphQL was to tackle the issues that arose
    when both the mobile and desktop versions of an application utilized the same
    API, specifically the REST API. Say you’re using a website on your mobile device.
    The desktop version can handle larger amounts of data, so it receives a more comprehensive
    dataset from the server. Unlike desktop versions, mobile apps have limits on data
    use because of slow connections and less processing power, making it impossible
    to handle large data sets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 采用GraphQL的主要原因是为了解决当应用的移动和桌面版本都使用相同的API（特别是REST API）时出现的问题。比如说你正在用手机上的网站。桌面版本可以处理更多的数据，因此从服务器接收的数据集更全面。与桌面版本不同，移动应用由于网络连接缓慢和计算能力有限，对数据的使用有限制，这使得处理大量数据集变得不可能。
- en: 'Here’s an example of a REST response that contains excessive data for mobile
    needs, where we only require a portion of the information:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个REST响应的例子，它包含过多的数据，而我们需要的信息只是其中的一部分：
- en: '[PRE0]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, when the user data is loaded for the first time, we only need a part of
    this data in the mobile version. For this reason, the resource-based distribution
    of the data (using REST) seems to be an ideal choice for design. Since there is
    no problem with internet availability for most desktop users, there is no problem
    with receiving data from different resources and displaying them as a single piece
    of information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当首次加载用户数据时，我们只需要在移动版本中这部分数据。正因为如此，基于资源的（使用REST）数据分发似乎是一个理想的设计选择。由于大多数桌面用户互联网可用性没有问题，所以从不同资源接收数据并将它们显示为单一信息没有问题。
- en: To ensure that we get only the required information, we filter the data based
    on its **ID**. In doing so, we conduct a kind of synchronous operation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们只获取所需的信息，我们根据其**ID**过滤数据。这样做，我们进行了一种同步操作。
- en: However, we are not suggesting an ideal solution for mobile data retrieval.
    Instead, we propose either developing a separate API specifically for mobile devices
    or implementing a more flexible and dynamic resource fetching mechanism by adopting
    an alternative approach to RESTGraphQL offers a more efficient approach to API
    interaction and design, especially when considering mobile and other resource-constrained
    devices. Originally intended for mobile use, GraphQL has evolved to support dynamic
    and effective data exchange across various platforms. Unlike traditional REST
    API design, GraphQL enables the synchronous retrieval of information from multiple
    resources in a single query, eliminating the need to fetch data resource by resource.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不是在建议一个理想的移动数据检索解决方案。相反，我们提出要么为移动设备开发一个专门的API，要么通过采用替代的RESTGraphQL方法来实现一个更灵活和动态的资源获取机制。GraphQL提供了一种更高效的API交互和设计方法，尤其是在考虑移动和其他资源受限设备时。最初旨在用于移动应用，GraphQL已经发展成为一种支持跨各种平台动态和有效数据交换的技术。与传统REST
    API设计不同，GraphQL允许在单个查询中从多个资源同步检索信息，从而消除了按资源逐个获取数据的需求。
- en: In addition to its application in mobile development, GraphQL is now extensively
    utilized in microservice design, further showcasing its versatility and widespread
    adoption in modern software development practices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在移动开发中的应用外，GraphQL现在在微服务设计中得到了广泛的应用，进一步展示了其多功能性和在现代软件开发实践中的广泛应用。
- en: 'Understanding the differences between REST and GraphQL is important when it
    comes to applying them in practice. Let’s define the main differences between
    these two powerful communication techniques:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用REST和GraphQL时，理解它们之间的区别非常重要。让我们定义这两种强大通信技术之间的主要区别：
- en: Mobile apps need slim and efficient data compared to desktop apps. REST APIs,
    which are often used for desktops, can be bulky for mobile. GraphQL solves this
    by letting you request only the specific data your app needs, avoiding unnecessary
    downloads while reducing over-fetching and under-fetching.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与桌面应用相比，移动应用需要更精简和高效的数据。常用于桌面的REST API对于移动应用来说可能会显得庞大。GraphQL通过让您仅请求应用所需的具体数据来解决这一问题，避免了不必要的下载，同时减少了过度获取和不足获取。
- en: REST works by focusing on individual pieces of information such as *users* or
    posts. To get related details, such as information about a specific user’s posts,
    you need to make separate requests for each piece. This can feel slow because
    you have to wait for one request to finish before making the next. Long story
    short, REST APIs typically deliver one set of information for each access point.
    In contrast, GraphQL allows you to request various data combinations from a single
    point, making it more flexible and adaptable.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST通过关注单个信息片段，如*用户*或帖子来工作。要获取相关细节，例如特定用户的帖子信息，您需要为每个片段单独发出请求。这可能会感觉比较慢，因为您必须等待一个请求完成才能发出下一个请求。简而言之，REST
    API通常为每个访问点提供一组信息。相比之下，GraphQL允许您从单个点请求各种数据组合，使其更加灵活和适应性强。
- en: Gathering information from multiple sources in REST requires separate requests,
    which can sometimes cause delays. GraphQL, however, lets you grab data from various
    sources in one go, presenting it to the user as a single unit. This reduces the
    number of requests and makes your app feel smoother.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在REST中，从多个来源收集信息需要单独的请求，这有时会导致延迟。然而，GraphQL允许您一次性从多个来源获取数据，并将其作为一个单一单元呈现给用户。这减少了请求的数量，使您的应用感觉更加流畅。
- en: Updating a REST API often involves versioning it to avoid breaking existing
    apps. GraphQL avoids this complexity by allowing additions without requiring changes
    on the app side, making it easier to keep things up to date.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新REST API通常需要对其进行版本控制，以避免破坏现有应用。GraphQL通过允许在不要求应用端进行更改的情况下添加功能，避免了这种复杂性，使得保持内容更新变得更加容易。
- en: 'Unlike REST, which focuses on managing specific pieces of data, GraphQL is
    built with mobile and frontend experiences in mind. This means it allows you to
    do the following:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与专注于管理特定数据片段的REST不同，GraphQL是考虑到移动和前端体验而构建的。这意味着它允许您做以下事情：
- en: Get only the data your app needs, reducing the amount of information transferred
    (smaller payload size)
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅获取您的应用所需的数据，减少传输的信息量（较小的有效载荷大小）
- en: Avoid unnecessary requests by fetching everything in one go, making your app
    faster and more efficient
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一次性获取所有内容来避免不必要的请求，使您的应用更快、更高效
- en: REST APIs struggle with frequent changes because their structure is fixed. Imagine
    an endpoint that can receive many different instructions or give answers in various
    formats. This can cause issues with REST. GraphQL, however, handles these situations
    much better.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API 由于其结构固定而难以应对频繁的变化。想象一个可以接收许多不同指令或以各种格式提供答案的端点。这可能会对 REST 产生问题。然而，GraphQL
    处理这些情况要好得多。
- en: In microservice architectures, where each service manages its own data, GraphQL
    shines. It allows you to combine information from multiple services in a single
    request, presenting it as one unified piece of data to the user. This makes building
    and managing complex applications much easier.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务管理自己的数据，GraphQL 发挥了作用。它允许你在单个请求中结合来自多个服务的信息，将其作为单一统一的数据块呈现给用户。这使得构建和管理复杂应用程序变得更加容易。
- en: When developing a single-page or native mobile app, GraphQL’s principles of
    “give only the information that the user needs” and “focus on a single unified
    resource” allow us to develop frontend-heavy applications.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发单页或原生移动应用时，GraphQL 的“只提供用户所需的信息”和“专注于单一统一资源”的原则使我们能够开发前端密集型应用程序。
- en: Under GraphQL, the frontend team can work on their tasks (user stories) without
    waiting for the backend team to create specific REST endpoints. This allows for
    faster progress and quicker app updates.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，前端团队可以在不等待后端团队创建特定 REST 端点的情况下工作（用户故事）。这允许更快地进步和更快的应用程序更新。
- en: RESTful APIs employ HTTP methods like PUT, DELETE, POST, and PATCH for data
    modification, collectively termed mutations in GraphQL. On the other hand, GraphQL
    utilizes a Query operation for retrieving data.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API 使用 HTTP 方法如 PUT、DELETE、POST 和 PATCH 进行数据修改，在 GraphQL 中统称为突变。另一方面，GraphQL
    使用查询操作来检索数据。
- en: In most scenarios, having REST and GraphQL will be enough for you. However,
    they are not the only communication mechanisms for your microservices. We have
    another interesting communication protocol called a **Remote Procedure Call**
    (**RPC**). Let’s dive in.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，拥有 REST 和 GraphQL 就足够了。然而，它们并不是微服务的唯一通信机制。我们还有一个有趣的通信协议，称为 **远程过程调用**（**RPC**）。让我们深入了解。
- en: Remote Procedure Call
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: Another communication protocol that we can use when establishing communication
    between microservices is RPC. Using RPC, one microservice can request a service
    from another microservice that is located in another computer on a given network
    without understanding the network details.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立微服务之间的通信时，我们还可以使用 RPC 这样的通信协议。使用 RPC，一个微服务可以请求位于给定网络上另一台计算机上的另一个微服务的服务，而无需了解网络细节。
- en: RPC is a method for these microservices to talk. It’s like one program asking
    another program on a different computer to do something, even though they aren’t
    directly connected. This makes it easier for the microservices to work together.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是这些微服务之间通信的方法。它就像一个程序请求另一台不同计算机上的程序执行某个操作，尽管它们并没有直接连接。这使得微服务更容易协同工作。
- en: 'Let’s define the core RPC flow:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义核心 RPC 流程：
- en: Imagine a microservice asking another microservice on a different computer to
    run a specific function (such as a task). This request is disguised as a normal
    function call, even though it’s happening over a network.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一个微服务请求另一台不同计算机上的微服务运行一个特定的函数（如任务）。这个请求被伪装成常规函数调用，尽管它是在网络上发生的。
- en: A middleman service (called a proxy) intercepts this request and takes care
    of the complex network communication behind the scenes.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个中间人服务（称为代理）拦截这个请求，并处理背后的复杂网络通信。
- en: The proxy sends a message containing the details of the function and any required
    data to the target microservice.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理发送一个包含函数细节和所需数据的消息到目标微服务。
- en: The target microservice receives the message, understands the function request,
    and executes it.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标微服务接收消息，理解功能请求，并执行它。
- en: Once it is done, it sends a response message back through the proxy.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，它将通过代理发送一个响应消息。
- en: Finally, the proxy delivers the response to the requesting microservice, making
    it seem like a regular function call.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，代理将响应发送给请求的微服务，使其看起来像常规函数调用。
- en: This flow sounds familiar, doesn’t it? That is because it is just a simple client-server
    mechanism. With the meaning and flow of RPC made clear, it’s time to understand
    some of its other important aspects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程听起来很熟悉，不是吗？那是因为它只是一个简单的客户端-服务器机制。在 RPC 的意义和流程明确之后，是时候了解其其他一些重要方面了。
- en: Benefits and considerations of RPC
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RPC的优缺点
- en: 'What about the benefits of RPC for microservices? Let’s emphasize the main
    points:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务RPC的好处有哪些？让我们强调主要观点：
- en: '**Easier development**: Using RPC is like making normal function calls, which
    programmers are already familiar with. This makes it simpler to build microservices
    because developers don’t need to worry about the technical details of network
    communication.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易开发**：使用RPC就像进行常规函数调用一样，这是程序员已经熟悉的。这使得构建微服务变得简单，因为开发者不需要担心网络通信的技术细节。'
- en: '**Potentially faster**: RPC can be faster than other methods because it uses
    pre-defined data formats specifically designed for these calls, instead of needing
    to interpret complex formats like JSON or XML.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可能更快**：RPC可能比其他方法更快，因为它使用专门为这些调用设计的预定义数据格式，而不是需要解释像JSON或XML这样的复杂格式。'
- en: What are some important things that you need to consider with RPC?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RPC时，有哪些重要的事项需要考虑？
- en: 'Let’s see here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看：
- en: '**Tight connections**: RPC can make microservices more reliant on each other.
    If one microservice changes the way its functions work (their interface), it can
    affect all the other microservices that rely on it.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密连接**：RPC可以使微服务更加依赖彼此。如果一个微服务更改了其函数的工作方式（它们的接口），它可能会影响所有依赖它的其他微服务。'
- en: '**Limited flexibility**: Choosing a specific RPC framework might make it harder
    to switch to a different one later.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限灵活性**：选择特定的RPC框架可能会使以后切换到另一个框架变得更加困难。'
- en: In conclusion, RPC is a powerful tool for microservices to talk to each other.
    It simplifies development and can be fast, but you should keep in mind the potential
    downsides of tighter connections and limited flexibility when deciding whether
    it’s the right choice for your project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，RPC是微服务之间通信的强大工具。它简化了开发过程，可以快速进行，但在决定它是否适合您的项目时，您应该考虑到更紧密连接和有限灵活性的潜在缺点。
- en: Tools for RPC
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RPC工具
- en: 'There are special programs called RPC frameworks built specifically to make
    communication between microservices smoother. These frameworks act like toolkits
    that simplify the process. Here are a few popular ones:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些专门为使微服务之间的通信更顺畅而构建的RPC框架。这些框架就像工具包一样简化了过程。以下是一些流行的框架：
- en: '**gRPC**: This framework focuses on making things fast and efficient. It uses
    a special format called **Protocol Buffers** to package data in a way that’s compact
    and easy to transmit.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC**：这个框架专注于使事物变得快速和高效。它使用一种特殊的格式，称为**协议缓冲区**，以紧凑且易于传输的方式打包数据。'
- en: '**Apache Thrift**: Another popular option, Thrift is known for working with
    many different programming languages and can handle various data packaging formats.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Thrift**：另一个流行的选择，Thrift以其能够与多种不同的编程语言一起工作而闻名，并且可以处理各种数据打包格式。'
- en: '**SOAP**: Provides a standardized way to encode messages using XML and transport
    them using mostly HTTP and HTTPs protocols . We can use SOAP to implement RPC.
    This allows applications to call procedures on remote servers as if they were
    local procedures. But we should take into account that SOAP is not limited to
    RPC and can be used for more general message exchange processes as well.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOAP**：提供了一种使用XML编码消息并使用HTTP和HTTPs协议（主要是HTTP和HTTPs）传输消息的标准方式。我们可以使用SOAP来实现RPC。这允许应用程序像调用本地过程一样调用远程服务器上的过程。但我们应该考虑到SOAP并不局限于RPC，也可以用于更通用的消息交换过程。'
- en: '**Windows Communication Foundation** (**WCF**): WCF is a framework developed
    by Microsoft for building service-oriented applications. It can be used to implement
    various communication mechanisms, including RPCs. WCF provides a lot more functionality
    than just RPC. It offers features such as data contracts, service hosting, and
    security. So, while WCF can be used for RPC, it’s not limited to that specific
    approach.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Communication Foundation**（**WCF**）：WCF是由微软开发的一个框架，用于构建面向服务的应用程序。它可以用来实现包括RPC在内的各种通信机制。WCF提供的功能远不止RPC。它提供了诸如数据契约、服务托管和安全等功能。因此，虽然WCF可以用于RPC，但它并不局限于这种特定方法。'
- en: RPC is a powerful way for microservices to communicate. It makes development
    easier and can be faster than other methods. However, remember the potential drawbacks
    of tighter connections and limited flexibility when deciding whether it’s the
    best choice for your project. Weigh the pros and cons carefully to make the right
    call for your specific needs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: RPC是微服务之间通信的一种强大方式。它使开发变得更简单，并且可能比其他方法更快。然而，在决定它是否是您项目的最佳选择时，请记住更紧密连接和有限灵活性的潜在缺点。仔细权衡利弊，为您的特定需求做出正确的决定。
- en: After discussing the general idea behind the communication protocols, it is
    time to talk about communication methods for microservices. Understanding the
    strengths and weaknesses of each approach is essential for designing robust and
    scalable microservice architectures.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了通信协议背后的基本思想之后，现在是时候讨论微服务的通信方法了。了解每种方法的优缺点对于设计健壮和可扩展的微服务架构至关重要。
- en: Synchronous microservice communication
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步微服务通信
- en: To exchange some information between microservices, they need to be able to
    talk to each other. In microservice communication, we mostly use two main patterns
    to establish communication between microservices. They are **Synchronous Communication**
    (**sync**) and **Asynchronous** **Communication** (**async**).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在微服务之间交换一些信息，它们需要能够相互交谈。在微服务通信中，我们主要使用两种主要模式来建立微服务之间的通信。它们是**同步通信**（**sync**）和**异步通信**（**async**）。
- en: Sync is the easiest of the two communication patterns.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同步是两种通信模式中最简单的一种。
- en: When one microservice needs information from another, it makes a direct request
    and waits for an answer before moving forward. The communication by itself is
    simpler and more reliable. It is just a function or method call if you compare
    it to a monolith application)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个微服务需要从另一个微服务获取信息时，它会直接发出请求并等待回复，然后再继续前进。这种通信本身更简单、更可靠。如果你将其与单体应用程序进行比较，它只是一个函数或方法调用。
- en: 'Here’s a breakdown of the steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是步骤分解：
- en: The calling microservice sends a message to another microservice.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用微服务向另一个微服务发送消息。
- en: The calling microservice pauses its work and waits for a reply.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用微服务暂停其工作并等待回复。
- en: The other microservice processes the request and sends a response back.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个微服务处理请求并发送响应回来。
- en: Once the calling microservice has received the response, it can continue its
    task.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调用微服务收到响应，它就可以继续其任务。
- en: We mostly use REST, GraphQL, and gRPC when implementing sync between microservices
    that rely on HTTP.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现依赖于HTTP的微服务之间的同步时，我们主要使用REST、GraphQL和gRPC。
- en: This image shows a simple synchronous communication between Order API and Stock
    API.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像展示了订单API和库存API之间简单的同步通信。
- en: '![Figure 2.5: Synchronous microservice communication](img/B09148_02_005.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：同步微服务通信](img/B09148_02_005.jpg)'
- en: 'Figure 2.5: Synchronous microservice communication'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：同步微服务通信
- en: Let’s now see some important aspects of sync.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看同步的一些重要方面。
- en: 'Some of its advantages are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一些优点如下：
- en: '**Simple and predictable**: The flow of execution is straightforward.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且可预测**：执行流程直截了当。'
- en: '**Immediate feedback**: The requestor receives the response immediately, making
    it suitable for interactive applications.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时反馈**：请求者立即收到响应，这使得它适合交互式应用程序。'
- en: 'Of course, as we learned before, nothing is without its downsides. This communication
    form also brings some disadvantages to the table:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们之前所学的，没有什么是没有缺点的。这种沟通形式也带来了一些不利因素：
- en: '**Blocking**: The requestor is blocked until the response arrives, which can
    lead to performance issues if the receiving service takes a long time.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞**：请求者在收到响应之前被阻塞，如果接收服务花费很长时间，可能会导致性能问题。'
- en: '**Coupling**: Services become tightly coupled, making them more difficult to
    change and scale independently.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耦合**：服务变得紧密耦合，这使得它们更难独立更改和扩展。'
- en: '**Single point of failure**: If the responding microservice is unavailable,
    the entire process gets blocked.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点故障**：如果响应的微服务不可用，整个流程将被阻塞。'
- en: After having understood the flow of this communication and some of its advantages
    and disadvantages, it’s also important to see how we might apply this to some
    real-world situations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这种通信的流程以及一些优点和缺点之后，了解我们如何将其应用于一些现实世界的情况也很重要。
- en: 'Here are some real-world examples of sync in microservices:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是微服务中同步的一些现实世界例子：
- en: '**Shopping cart**: Imagine you fill your cart online and hit pay. The cart
    service (like your shopping list) talks directly to the payment service (like
    the cashier) to confirm payment before creating the order. This way, you know
    right away whether the payment went through.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物车**：想象你在网上填满购物车并点击支付。购物车服务（如你的购物清单）会直接与支付服务（如收银员）交谈，在创建订单之前确认支付。这样，你可以立即知道支付是否成功。'
- en: '**Catching cheaters**: When you place an order online, the order service (like
    the order taker) asks the fraud checker (like security guard) to see whether it’s
    okay. The checker says yes or no right away, so only real orders go through.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕捉作弊者**：当你在线下单时，订单服务（如订单接收者）会要求欺诈检查员（如保安）查看是否可以。检查员立即回答是或否，因此只有真实订单才会通过。'
- en: '**Live chat** **support**: When you type a message in a chat, your message
    goes to a service that finds an agent (like finding a helper). The agent gets
    your message and replies directly, so you can chat back and forth quickly.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时聊天** **支持**：当你在一个聊天中输入消息时，你的消息会发送到一个寻找代理（如寻找助手）的服务。代理收到你的消息并直接回复，这样你可以快速地来回聊天。'
- en: '**Online games**: In online games, your actions are sent to a game server (like
    the game referee). The server updates the game world (like changing the score)
    based on your actions and sends it back to everyone playing, keeping the game
    smooth for all.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线游戏**：在在线游戏中，你的动作会发送到游戏服务器（如游戏裁判）。服务器根据你的动作更新游戏世界（如改变分数），并将其发送回所有玩家，保持游戏对所有玩家的流畅。'
- en: '**Stock trading**: When you buy or sell stocks on an app, it talks directly
    to a service at your brokerage (like your investment person). This service makes
    the trade right away, tells the app that it’s done, and updates your account balance.
    This gives you quick confirmation so you can manage your money.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**股票交易**：当你在一个应用中买卖股票时，它会直接与你经纪公司的服务（如你的投资顾问）交谈。这个服务立即进行交易，告诉应用已完成，并更新你的账户余额。这让你能快速确认，以便管理你的资金。'
- en: 'These are just a few examples, and in general, you should understand that sync
    is ideal when you need any of the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是几个例子，总的来说，你应该理解，以下情况下同步是理想的：
- en: Immediate feedback and interaction
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即反馈和互动
- en: Real-time dialogue
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时对话
- en: Real-time decision-making and execution
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时决策和执行
- en: Just-in-time analysis and implementation
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即时分析和实施
- en: Tightly coupled workflows with high dependency
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧密耦合的工作流程，高度依赖
- en: Asynchronous microservice communication
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步微服务通信
- en: Sync is like having a direct conversation, but async is more like leaving a
    message. Microservices don’t wait for a reply, they just send the information
    and move on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 同步就像直接对话，但异步更像是留条子。微服务不会等待回复，它们只是发送信息然后继续。
- en: In asynchronous communication, the requesting service sends a message to the
    receiving service without waiting for an immediate response. The response is delivered
    later, either through a callback or through a separate channel.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步通信中，请求服务向接收服务发送消息，而不等待立即响应。响应稍后通过回调或通过单独的通道传递。
- en: '![Figure 2.6: Asynchronous microservice communication](img/B09148_02_006.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：异步微服务通信](img/B09148_02_006.jpg)'
- en: 'Figure 2.6: Asynchronous microservice communication'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：异步微服务通信
- en: 'Here’s a breakdown of the steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是步骤分解：
- en: '**Send a message**: The calling microservice sends a message with the information
    to another microservice.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发送消息**：调用微服务将包含信息的消息发送给另一个微服务。'
- en: '**Move on**: The calling microservice doesn’t wait for a reply. It continues
    its own task.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**继续进行**：调用微服务不会等待回复。它继续自己的任务。'
- en: '**Process later**: The other microservice receives the message and works on
    it whenever it’s free.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**稍后处理**：其他微服务在空闲时接收消息并对其进行处理。'
- en: '**Reply**: The other microservice might send a response back later, but that’s
    not required.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回复**：其他微服务可能会稍后发送响应，但这不是必需的。'
- en: Think of it like leaving a note for someone – they can get to it when they have
    a chance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 想象成给某人留条子——他们有机会时就会看到。
- en: In most cases, we use a message broker to handle async between microservices.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们使用消息代理来处理微服务之间的异步通信。
- en: For complex communication patterns, high message volume, or critical tasks,
    a message broker is a good choice. For simpler scenarios where reliability is
    less crucial, direct queues or event sourcing can be better alternatives to a
    message broker.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的通信模式、高消息量或关键任务，消息代理是一个不错的选择。对于可靠性不那么关键的场景，直接队列或事件源可能是比消息代理更好的替代方案。
- en: 'Let’s cover the most important advantages of using async between microservices:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用异步在微服务之间最重要的优点：
- en: '**Non-blocking**: The requester can continue processing without waiting for
    the response, improving performance and scalability.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞**：请求者可以在等待响应的同时继续处理，从而提高性能和可扩展性。'
- en: '**Decoupling**: Services are loosely coupled, making them easier to change
    and scale independently.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦**：服务是松散耦合的，这使得它们更容易独立更改和扩展。'
- en: '**Resilience**: Async can handle failures and retries more gracefully than
    sync.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：异步比同步更能优雅地处理失败和重试。'
- en: '**Independent work**: Microservices can focus on their own tasks without worrying
    about others being busy.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立工作**：微服务可以专注于自己的任务，无需担心其他服务正忙。'
- en: 'However, it also has some drawbacks:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点：
- en: '**Delayed results**: You might not know whether the message was received or
    processed right away.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟结果**：你可能无法立即知道消息是否被接收或处理。'
- en: '**More complex**: Setting up async can be trickier than sync. Sync doesn’t
    require an additional layer when establishing communication. However, as I mentioned
    before, for true async you mostly need to use a message broker as middleware between
    communicated services.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更复杂**：设置异步可能比同步更困难。同步在建立通信时不需要额外的层。然而，正如我之前提到的，对于真正的异步，你通常需要在通信服务之间使用消息代理作为中间件。'
- en: 'Next, let us look at some practical applications of this type of communication:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这种通信类型的一些实际应用：
- en: '**Sending emails**: The order service can send an order confirmation email
    without waiting for it to be sent.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送电子邮件**：订单服务可以发送订单确认电子邮件，而无需等待其发送。'
- en: '**Updating inventory**: When a sale is made, the order service can send a message
    to update the inventory. It can keep processing other orders in the meantime.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新库存**：当销售发生时，订单服务可以向更新库存的消息发送消息。在此期间，它还可以继续处理其他订单。'
- en: '**Long-running tasks**: A microservice can send a message to another service
    to do a time-consuming job, such as video encoding, without being stuck waiting.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长时间运行的任务**：微服务可以向另一个服务发送消息以执行耗时的工作，例如视频编码，而无需等待。'
- en: '**Social media feed updates**: Post service publishes a message to the feed
    queue. The feed service subscribes to the queue and updates user feeds in the
    background.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交媒体动态更新**：发布服务向动态队列发布消息。动态服务订阅队列并在后台更新用户动态。'
- en: 'It is better to choose to use async between microservices when any of the following
    conditions apply:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下任何条件适用时，最好选择在微服务之间使用异步：
- en: An immediate response is not essential
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即响应不是必需的
- en: Background tasks or long-running processes are needed
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要后台任务或长时间运行的过程
- en: Decoupling and scalability are key considerations
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦和可扩展性是关键考虑因素
- en: Async is great for tasks that don’t need immediate answers, but sync might be
    better for things that need a quick response.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 异步非常适合不需要立即答案的任务，但对于需要快速响应的事情，同步可能更好。
- en: Essential communication patterns
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的通信模式
- en: When building microservices, we mostly need a single point of entry for our
    clients to consume the services that we develop. You may think about it like a
    decorator or wrapper over your services. Clients talk to your app through a simple
    door (API gateway) instead of needing to know the messy inner workings (microservices).
    The gateway intelligently routes incoming requests to the appropriate microservices
    based on factors such as URL patterns, path variables, or headers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，我们通常需要一个单一的入口点，让我们的客户端消费我们开发的服务。你可以把它想象成覆盖你服务的装饰器或包装器。客户端通过一个简单的门（API网关）与你的应用程序交谈，而不是需要了解混乱的内部工作（微服务）。网关根据URL模式、路径变量或头等因素智能地将传入的请求路由到适当的微服务。
- en: An important component of microservice architecture is an API gateway. This
    API offers several features to help manage and expose common functionalities across
    multiple microservices. Often, a client request might require data from multiple
    microservices. The gateway acts as an orchestrator, fetching data from relevant
    services, aggregating it (if necessary), and returning a cohesive response to
    the client. In short, API gateways are essential components of microservice architecture.
    They provide a single point of entry for clients, enhancing security and manageability,
    as well as the overall effectiveness of your microservices)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个重要组成部分是API网关。这个API提供了几个功能，以帮助管理和暴露多个微服务之间的常见功能。通常，客户端请求可能需要来自多个微服务的数据。网关充当协调者，从相关服务获取数据（如果需要的话），聚合它，并向客户端返回一个连贯的响应。简而言之，API网关是微服务架构的必要组件。它们为客户端提供了一个单一的入口点，增强了安全性、可管理性以及微服务的整体效率）
- en: '![Figure 2.7: An API gateway](img/B09148_02_007.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：API网关](img/B09148_02_007.jpg)'
- en: 'Figure 2.7: An API gateway'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：API网关
- en: 'Now, let’s try to summarize the benefits of API gateways:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试总结API网关的好处：
- en: '**Single entry point**: There is no need to understand the internals of microservices.
    Using an API gateway helps you to be isolated from such details.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一入口点**：无需了解微服务的内部结构。使用API网关可以帮助您隔离这些细节。'
- en: '**Request routing**: An API gateway acts as smart middleware to route queries
    from the users to the exact microservices'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求路由**：API网关充当智能中间件，将用户的查询路由到确切的微服务。'
- en: '**Aggregator**: The gateway acts as an orchestrator, fetching data from relevant
    services, aggregating it (if necessary), and returning a cohesive response to
    the client.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合器**：网关充当协调者，从相关服务获取数据，如果需要的话，聚合它，并向客户端返回一个连贯的响应。'
- en: '**Security**: The gateway can be a central hub for authentication, authorization,
    and rate limiting. It verifies client identities, enforces access controls, and
    prevents potential abuse.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：网关可以成为认证、授权和速率限制的中心枢纽。它验证客户端身份，执行访问控制，并防止潜在的滥用。'
- en: '**Transformation**: The gateway can manipulate requests and responses to match
    the expected formats of backend services or tailor responses for clients. This
    includes tasks such as content negotiation, protocol translation, and data validation.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：网关可以操作请求和响应，以匹配后端服务的预期格式或为客户端定制响应。这包括内容协商、协议转换和数据验证等任务。'
- en: '**Common tasks**: The gateway can handle common tasks such as request validation,
    caching, and logging, reducing the burden on individual microservices.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见任务**：网关可以处理常见的任务，如请求验证、缓存和日志记录，减轻单个微服务的负担。'
- en: '**Load balancing**: When there’s a lot of work to be done (heavy traffic),
    load balancing acts like a traffic director. It cleverly distributes incoming
    requests across multiple copies (instances) of the same microservice. No single
    microservice gets overwhelmed, making the best use of all available resources.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：当有大量工作要做（高流量）时，负载均衡就像一个交通指挥官。它巧妙地将传入请求分配到同一微服务的多个副本（实例）上。没有单个微服务会过载，从而最大限度地利用所有可用资源。'
- en: '**Circuit breaker**: An API gateway often contains a circuit breaker for resiliency,
    cascading failure, and protecting system’s stability. A circuit breaker in microservices
    is like a switch that automatically stops sending requests to a service if it’s
    not responding well, helping prevent system-wide failures.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：API网关通常包含一个断路器，用于弹性、级联故障和系统稳定性保护。微服务中的断路器就像一个开关，如果服务响应不佳，它会自动停止向该服务发送请求，从而帮助防止系统级故障。'
- en: Message brokers
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息代理
- en: In a direct communication model, microservices would have to be aware of each
    other’s locations and availabilities. This creates a tightly coupled system that’s
    difficult to maintain and update.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接通信模型中，微服务必须了解彼此的位置和可用性。这创建了一个紧密耦合的系统，难以维护和更新。
- en: By introducing a message broker, microservices become loosely coupled. They
    simply send messages to the broker, which handles the routing and delivery. This
    allows microservices to operate independently without needing to know the specifics
    of other services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入消息代理，微服务变得松散耦合。它们只需向代理发送消息，代理处理路由和交付。这使得微服务可以独立运行，无需了解其他服务的具体细节。
- en: With message brokers, communication becomes asynchronous. A producer (microservice)
    can send a message without waiting for a response from the consumer (another microservice).
    This improves performance and scalability as microservices don’t have to wait
    on each other.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息代理，通信变得异步。生产者（微服务）可以发送消息，而无需等待消费者的响应（另一个微服务）。这提高了性能和可伸缩性，因为微服务不需要相互等待。
- en: '![Figure 2.8: Message brokers](img/B09148_02_008.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：消息代理](img/B09148_02_008.jpg)'
- en: 'Figure 2.8: Message brokers'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：消息代理
- en: Message brokers use different message storage models. The most popular ones
    are **Message Queues** (**MQs**) and **Topic.** Message brokers store messages
    in an MQ until they are received by consumers. MQs are a crucial part of message
    brokers that act as storage for the data. Unlike Topic, they delete data after
    the consuming process.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理使用不同的消息存储模型。其中最受欢迎的是**消息队列**（**MQs**）和**主题**。消息代理将消息存储在MQ中，直到它们被消费者接收。MQs是消息代理的关键部分，充当数据的存储。与主题不同，它们在消费过程之后会删除数据。
- en: 'Let’s try to understand the components of a typical message broker:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解典型消息代理的组件：
- en: '**Producer (Publisher)**: This is the one that sends a message.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者（发布者）**：这是发送消息的那个。'
- en: '**Consumer (Subscriber)**: This is the one that reads a message.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者（订阅者）**：这是读取消息的那个。'
- en: '**MQ (or Topic)**: This is the one that stores the message. Topic allows for
    a publish-subscribe model, whereby multiple consumers can receive the same message.
    On the other hand, MQ queue follows a **First-In, First-Out** (**FIFO**) approach,
    ensuring messages are processed in the order in which they are received.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MQ（或主题）**：这是存储消息的那个。主题允许发布-订阅模型，其中多个消费者可以接收相同的信息。另一方面，MQ队列遵循**先进先出**（**FIFO**）的方法，确保消息按照接收的顺序进行处理。'
- en: 'There are a lot of popular message broker implementations out there. In practice,
    we will use Apache Kafka, one of the most popular message brokers. Let’s talk
    about the most popular message broker implementations:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有很多流行的消息代理实现。在实践中，我们将使用Apache Kafka，这是最受欢迎的消息代理之一。让我们来谈谈最流行的消息代理实现：
- en: '**RabbitMQ**: This is an open source message broker that is widely known for
    its flexibility and ease of use. It supports different messaging patterns, including
    point-to-point (only one specific application receives a message) and **Publisher
    and Subscriber** (**pub/sub**). It acts as a central post office for your applications.
    Apps can send and receive messages without needing to know each other’s exact
    addresses. It helps us to have tightly coupled communication. It is flexible,
    easy to use, and has a large community.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**：这是一个广为人知的开源消息代理，以其灵活性和易用性而闻名。它支持不同的消息模式，包括点对点（只有一个特定的应用程序接收消息）和**发布者与订阅者**（**pub/sub**）。它充当您应用程序的中心邮局。应用程序可以发送和接收消息，而无需知道彼此的确切地址。它帮助我们实现紧密耦合的通信。它是灵活的、易用的，并且拥有庞大的社区。'
- en: '**Apache Kafka**: It is a powerful option to implement a message broker. It
    has crucial attributes such as high throughput, durability, scalability, fault
    tolerance, real-time processing, and many others. Apache Kafka is more than a
    message broker with data storage and stream processing integration. We will talk
    more about the internals of Kafka in the next chapters.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Kafka**：它是实现消息代理的一个强大选项。它具有高吞吐量、持久性、可伸缩性、容错性、实时处理等关键属性。Apache Kafka不仅仅是一个具有数据存储和流处理集成的消息代理。我们将在下一章中更多地讨论Kafka的内部结构。'
- en: '**Amazon Simple Queue Service** (**SQS**): Like other message broker implementations,
    it provides decouple and scale microservices. SQS acts as a queue where you can
    send messages (data), store them securely, and then retrieve them via other applications
    or services. SQS decouples applications by enabling them to communicate asynchronously.
    The sender doesn’t need to wait for the receiver to be available, improving overall
    application responsiveness and scalability.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Simple Queue Service**（**SQS**）：与其他消息代理实现一样，它提供了解耦和可扩展的微服务。SQS充当一个队列，您可以在其中发送消息（数据），安全地存储它们，然后通过其他应用程序或服务检索它们。SQS通过允许应用程序异步通信来解耦应用程序。发送者不需要等待接收者可用，从而提高了整体应用程序的响应性和可伸缩性。'
- en: If you need real-time stream processing, Apache Kafka might be a better option
    for you rather than RabbitMQ and SQS. On the other hand, if you like to have advanced
    features such as message filtering or priority queues, use RabbitMQ over SQS.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要实时流处理，Apache Kafka可能比RabbitMQ和SQS更适合你。另一方面，如果你喜欢有高级功能，如消息过滤或优先队列，请使用RabbitMQ而不是SQS。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about microservice communication. We talked about different
    communication techniques such as REST, GraphQL, and RPC.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于微服务通信的。我们讨论了不同的通信技术，如REST、GraphQL和RPC。
- en: 'We discussed the fact that we mostly use two types of communication forms between
    microservices: synchronous and asynchronous. Sync is simple and has immediate
    feedback, but it is a blocking operation with attributes such as a single point
    of failure and coupling. We talked about the advantages and disadvantages of sync
    and discussed when to and when not to use it in practice.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了在微服务之间我们主要使用两种通信形式：同步和异步。同步简单且具有即时反馈，但它是一个阻塞操作，具有单点故障和耦合等属性。我们讨论了同步的优点和缺点，并讨论了在实践中的使用和不用同步的情况。
- en: On the other hand, we learned that async is non-blocking and comes with delayed
    responses. It is mostly preferable (depending on the task) but brings additional
    complexity. To make async happen, we learned that we mostly need additional layers
    like message brokers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们了解到异步是非阻塞的，并带有延迟响应。它通常更可取（取决于任务），但带来了额外的复杂性。为了实现异步，我们了解到我们通常需要额外的层，如消息代理。
- en: The last part of the discussion was centered around the most used patterns such
    as API gateway and message broker.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的最后一部分集中在最常用的模式，如API网关和消息代理。
- en: API gateway, as an orchestrator, provides a single point of entry with additional
    functionalities such as security, transformation, load balancing, and so on. It
    is an essential part of microservice communication.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: API网关作为一个编排者，提供了一个单一的入口点，并提供了额外的功能，如安全、转换、负载均衡等。它是微服务通信的一个关键部分。
- en: We further learned about establishing async. Using message broker, we mostly
    establish async between microservices. It is an additional layer between services
    that handles common tasks (depending on message broker implementation). It has
    multiple implementations such as RabbitMQ, Apache Kafka, Amazon SQS, and so on.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步学习了如何建立异步通信。使用消息代理，我们主要在微服务之间建立异步通信。它是在服务之间处理常见任务（取决于消息代理实现）的额外层。它有多个实现，如RabbitMQ、Apache
    Kafka、Amazon SQS等。
- en: Starting from the next chapter, we will cover JavaScript and NodeJS essential
    you need to know before diving into details of microservice development. Stay
    tuned!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将介绍在深入微服务开发细节之前你需要了解的JavaScript和NodeJS基础知识。敬请期待！
