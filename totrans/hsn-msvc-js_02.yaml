- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving into Microservices Internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices aren’t just about breaking down a large application into smaller,
    more manageable ones. They also introduce challenges, one of which is communication
    between services. Monolithic applications, which we discussed in the previous
    chapter, make communication between elements relatively straightforward. However,
    in microservice architecture, we have physical isolation between services. Even
    though we want microservices to be independent, as well as easy to reuse, maintain,
    and grow, getting them to talk to each other effectively becomes a major challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Effective microservice communication is crucial for the overall success of architecture.
    It enables services to exchange data, coordinate actions, and trigger events.
    If microservices can’t communicate effectively, they become like isolated islands,
    stopping the application from working properly and keeping it running slowly.
    Well-designed communication patterns ensure that microservices can collaborate
    effectively to deliver the desired functionality. This communication strategy
    also promotes loose coupling, which means that changes in one service have minimal
    impact on others, thereby making the application more resilient and easier to
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about establishing a strong foundation for the next practical
    chapters, along with providing comprehensive information about microservice communication.
    A solid understanding of microservices communication will help you build reliable,
    consistent, scalable, and fault-tolerant microservice applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to talk more about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices communication techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronous microservice communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous microservice communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential communication patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solidifying the communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your application grows, managing its complexity becomes increasingly challenging.
    To tackle this, developers rely on best practices, design patterns, and various
    approaches. In traditional software design, techniques like abstraction, encapsulation,
    and decomposition help us deal with complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture offers a provides a powerful solution to complexity
    through the **Separation of Concerns** (**SOC**) principle. This principle breaks
    down a complex system into smaller independent parts, each with a well-defined
    responsibility. Imagine a monolithic application as a mountain; microservices
    allow us to break it down into smaller, more manageable hills through bounded
    contexts. However, this freedom comes at the cost of somehow figuring out how
    to establish communication between microservices. Of course, it is not as easy
    as it was with the monolithic approach, because with that, everything was inside
    one codebase. Creating a connection between elements of a monolith was as simple
    as calling any method.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to explain the relationship between monoliths and microservices
    is by using the first two principles of **S.O.L.I.D**, the **Single Responsibility
    Principle** (**SRP**) and the **Open-Closed Principle** (**OCP**), as metaphors.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP’s core principle of dividing a large problem into smaller, more focused
    units aligns with the microservices approach. We break down the big picture into
    smaller, manageable modules, each with well-defined responsibilities and reasons
    for change. This mirrors the SRP’s aim of splitting classes and modules into manageable
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Applying the SRP](img/B09148_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Applying the SRP'
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind the SRP is the SoC, which is also adopted in microservice
    architecture. It promotes dividing a system into independent parts based on functionality.
    This improves maintainability, reduces complexity, and allows for independent
    development and deployment of each part
  prefs: []
  type: TYPE_NORMAL
- en: Metaphorically, the SRP’s abstract idea is to break down the big module into
    smaller one (see Figure 2.2) that are similar to what we get when we divide a
    monolith into smaller services called microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Monolithic architecture to microservice architecture](img/B09148_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Monolithic architecture to microservice architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The final results of splitting up your monolithic application are microservices;
    they are software entities for us in this comparison. Making them open for an
    extension means that there is a team that works on them. This team can extend
    and modify them without depending on other teams or modules. Having loose coupling
    between services allows us to independently work on services.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s a catch: *communication*. With multiple smaller entities instead
    of one monolithic class, the application relies on communication to function as
    a whole. While the SRP creates independent subsystems, it doesn’t address the
    challenges of enabling communication between them. In fact, the SRP itself can
    contribute to this complexity. The SRP can leave you with multiple smaller subsystems
    without solving communication issues between them.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the OCP comes in. The OCP states that software should be open
    for extension but closed for modification. From a metaphorical perspective, in
    the context of microservices, this means designing communication mechanisms that
    are flexible and adaptable to future changes without requiring modifications to
    existing services.
  prefs: []
  type: TYPE_NORMAL
- en: When one microservice (we’ll call it *Microservice A*) asks for some resource
    from another microservice (*Microservice B*), it doesn’t need to know the internals
    of Microservice B. In exchange for that, Microservice B may use a different implementation
    form of the same endpoint without notifying Microservice A
  prefs: []
  type: TYPE_NORMAL
- en: Microservice communication techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest communication challenge with microservices is establishing reliable
    and scalable connections between them. We use different techniques to handle microservices
    communication. It is worth mentioning that there are multiple techniques to achieve
    proper communication between microservices. However, in this chapter, we will
    only focus on the most popular ones, as well as the ones that we think are most
    important. Let’s explore these techniques together.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In software development, **Application Programming Interfaces** (**APIs**) are
    important tools that help us avoid doing the same tasks over and over. APIs protect
    us from the complexities of our working environment and area of expertise, making
    it easier to manage complicated processes and ignore detailed domain knowledge.
    They encapsulate complexity, making it unnecessary to understand the underlying
    implementation details. APIs by themselves are black boxes that provide only the
    required information. This means that we don’t have to worry about the nitty-gritty
    technical stuff and can focus on using the provided interfaces to interact with
    our environment. For example, when we use a framework, we see all the DLLs (packages)
    as APIs that give us the functions that we need.
  prefs: []
  type: TYPE_NORMAL
- en: A web-based API is just a type of API. It’s used to help different programs
    share information over the internet using standard web rules and methods. Usually,
    these APIs are seen as REST APIs or **Simple Object Access Protocol** (**SOAP**)
    services and rely on client-server architecture. This allows for creating connections
    between various online resources such as websites or services, which can help
    in building big systems like microservices or just in sharing data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Client-server architecture](img/B09148_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Client-server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about REST here, but what does it mean? Let’s discuss this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is REST?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is a style of architecture that
    is used for building applications that are loosely connected over the HTTP protocol.
    It’s important to note that REST is primarily a design approach rather than a
    strict architectural pattern. When I consider the differences between architectural
    style and pattern, I always perceive abstraction and implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: An architectural *style* defines a set of principles and guidelines for organizing
    a system’s structure. It provides a high-level abstraction of how different components
    should interact and communicate with each other. Architectural styles are broad,
    conceptual approaches to designing software systems.
  prefs: []
  type: TYPE_NORMAL
- en: An architectural *pattern*, on the other hand, is a specific solution to a recurring
    architectural problem. It’s a reusable design blueprint or template that describes
    how to solve a particular design problem within a given architectural style. It
    provides a concrete blueprint for implementing a particular aspect of the style.
  prefs: []
  type: TYPE_NORMAL
- en: Many call REST a protocol. However, REST itself isn’t a standardized protocol,
    although it’s commonly implemented using web standards today. While it’s often
    associated with HTTP, it’s not limited to this protocol; REST can work with other
    protocols too.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify, think of REST as a blueprint for how systems should communicate.
    It outlines how a client (such as a web browser) can request information from
    a server, and how the server responds, potentially changing the client’s state.
  prefs: []
  type: TYPE_NORMAL
- en: The core ideas behind REST are resource, representation, state, and transfer.
    When a client requests a resource from a server, the server sends back a representation
    of that resource, which is essentially a copy. If the state of the resource changes
    later, the client can request it again to get the latest version. The process
    of sending this resource from server to client is the transfer part of REST.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: An overview of REST](img/B09148_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: An overview of REST'
  prefs: []
  type: TYPE_NORMAL
- en: So, why is REST important?
  prefs: []
  type: TYPE_NORMAL
- en: It separates the client and server, breaking their direct reliance on each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s **platform-independent**, meaning that it’s not restricted to any particular
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s **language-agnostic**. Whether you’re coding in PHP, C#, Node.js, or any
    other language, you can implement REST services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s flexible with data formats, supporting both XML and JSON, among others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It facilitates building distributed systems, enabling components to be spread
    across different locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers discoverability, making it easy to identify and access resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s straightforward to use, simplifying the process of integrating services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leverages **HTTP cache**, improving performance by storing frequently accessed
    data locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this understanding, let’s look at some of the constraints of REST.
  prefs: []
  type: TYPE_NORMAL
- en: What are some REST constraints?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key indicator that a service follows REST principles lies in the constraints
    it follows. REST adheres to six constraints, five of which are mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: '`students` is the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulating resources through representation**: If a client can modify a
    resource, metadata about how to do so should be included with the returned representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-descriptive messages**: Each request should contain all necessary information,
    which is typically conveyed via HTTP headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia As the Engine of Application State** (**HATEOAS**): Requests should
    provide documentation, enabling clients to discover other resources easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-server constraint**: This constraint separates the client and server.
    Here, a client and server facilitate data exchange. They evolve independently
    and remain ignorant of each other’s architecture.*   **Stateless constraint**:
    This ensures communication without maintaining session data. The servers don’t
    retain client session data, and each request is independent of others.*   **Cacheable
    constraint**: To improve speed and efficiency, responses should be cacheable,
    and the caching should be managed via headers. Instead of fetching data from the
    server every time, we should use the cached version that helps reduce load to
    the server and speed up response times.*   **Layered system**: To reduce complexity,
    the server architecture is organized hierarchically, and each layer only interacts
    with the one adjacent to it.*   **Code on demand constraint**: Servers can provide
    executable code examples to clients, though this is not mandatory due to security
    concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most popular implementation based on REST is called **RESTful services**.
    RESTful services heavily rely on REST principles. However, this doesn’t mean that
    using RESTful service creation tools will always ensure that you end up with REST-based
    services. You should learn and apply these principles to make your API more **RESTable**.
  prefs: []
  type: TYPE_NORMAL
- en: Think of RESTful APIs as a common language for microservices. One service can
    send an HTTP request (such as `get user data`) to another and get the information
    it needs. This keeps things simple and avoids messy situations wherein services
    need to understand each other’s inner workings
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs act like messengers between microservices, ensuring they work together
    smoothly, even though they’re separate components.
  prefs: []
  type: TYPE_NORMAL
- en: How does a RESTful API work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine information such as pictures, text, or data stored online. This information
    is like a resource. When an application needs this resource, it sends a message,
    which is called a request, to the server to ask for it. Think of the request as
    a polite way to ask for something.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that the server understands the request, the application follows
    a set of instructions, like a recipe. These instructions are called documentation
    and are provided by the server creator.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how sensitive the information is, the server might check the application’s
    identity, similar to checking your ID before entering a secure place. This is
    called authentication. Once the server has received and understood the request,
    it processes it and finds the information. Then the server sends a response back
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP-based REST implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers often build RESTful APIs using a special language for web communication
    called HTTP, which is like a language for talking to websites. In this language,
    there are special words called **HTTP methods** that tell the server what to do
    with the information (the resource). Let’s discover the most used HTTP methods
    together in the next few subsections.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We as developers use the GET method when we want to ask for some representation
    of the given resource without changing it.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP GET method is a request for the server to retrieve a specific resource
    without modifying it. It’s like saying “Please give me this information.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: You (the client, like your web browser) send a request to the server using the
    GET method. This request is like a message asking for the resource you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website (server) receives the request and understands what you’re asking
    for because of the GET method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website (server) finds the information that you requested and sends it back
    to you in response. This response might include things like text, images, or other
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of it like asking a friend to show you a picture on their phone. You wouldn’t
    just grab it; you’d politely ask to see it. Similarly, the GET method allows you
    to get information politely from a website.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the GET method is used for retrieving information
    and shouldn’t be used for changing or modifying anything on the website. Think
    of it like borrowing a book from the library, not writing in it.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The POST method is used to create a resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the POST method as a secure way to send information to the website
    (server). It’s like filling out a form and clicking *submit* to send your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: You (the client) fill out a form with the information you want to send (such
    as your name and email).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your tool (usually a browser) sends a request to the website (server) using
    the POST method. This request includes the information you entered on the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website (server) receives the request and understands the information because
    of the POST method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server processes the information you send which may involve actions like
    creating an account, storing a comment, or sending an email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website (server) might then send a response back to you, such as a confirmation
    message or a new page to see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of it like sending a package to a friend. You wouldn’t just leave it on
    their doorstep; you’d package it and send it through a reliable service. Similarly,
    the POST method allows you to securely send information to a website.
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to remember that the POST method is primarily used for sending
    and processing information, not just for viewing it. Unlike GET, which retrieves
    information, POST typically triggers actions on the server.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the HTTP PUT method to update the existing information on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Think of PUT as a way to carefully update existing information on a website
    (server). It’s like carefully revising a document or updating your profile details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: You (the client, like your web browser) prepare the updated information, for
    example, changes to your profile picture or edited text in a document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your browser sends a request to the website (server) using the PUT method. This
    request includes the updated information you prepared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website (server) receives the request and understands what needs to be updated
    because of the PUT method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server carefully replaces the existing information with the updated version
    that you sent. This is similar to carefully replacing a page in a book with a
    revised version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website (server) might then send a response back to you, such as a confirmation
    message or the updated information itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to remember that using PUT requires caution and accuracy because
    it directly modifies existing information. Think of it like carefully editing
    a document; making a mistake could result in changing or losing important information.
  prefs: []
  type: TYPE_NORMAL
- en: The PUT method is typically used when you know exactly what information needs
    to be updated and you want to replace it completely. It’s not for retrieving information
    like GET or creating new information like POST.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTTP DELETE method acts like a digital eraser, carefully removing a specific
    piece of information from a server. You can think of it as deleting a single item
    from your shopping list, leaving the rest untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: You (the client), like your web browser, decide to remove something specific,
    such as an old photo or an outdated article.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your browser sends a DELETE request to the server, pinpointing the exact item
    that you want to remove. This is like pointing your finger at the item on your
    shopping list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the request and understands the intention because of the
    DELETE method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server carefully removes the specified item from its storage, similar to
    crossing off the item on your list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server might reply with a confirmation message letting you know that the
    deletion happened successfully, or simply remain silent.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should remember that using DELETE is like using an eraser: it’s permanent.
    Once something is gone, it’s usually gone for good. So, be sure that you truly
    want to remove the item before sending the DELETE request.'
  prefs: []
  type: TYPE_NORMAL
- en: DELETE is different from other methods. Unlike GET (used for getting information)
    or POST (used for creating new information), DELETE specifically removes something.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to be precise with DELETE requests, as they target a specific
    item and cannot be undone easily.
  prefs: []
  type: TYPE_NORMAL
- en: PATCH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PATCH method acts like a touch-up tool for information on a server. It’s
    similar to the PUT method, but PATCH lets you update certain parts of the information,
    like editing specific sections of a document without changing the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a shopping list with items like bread, milk, and eggs.
    You realize that you need more milk, but everything else is fine. Instead of rewriting
    the entire list, you can use PATCH to update just the milk quantity. This way,
    the rest of the list stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: You (the user) decide to change a specific part of something, such as updating
    the price of an item online.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You send a PATCH request to the server, pointing out the exact part you want
    to modify, such as the price in our example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server understands the request because of the PATCH method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server carefully updates only the chosen part, leaving the rest untouched,
    similar to editing just one section of a document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server might then send confirmation or simply show the updated information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take note that PATCH is a method for making targeted updates, modifying only
    specific parts of a resource. It’s useful when you only want to change specific
    parts of something, keeping the rest the same. This makes it more flexible and
    efficient than completely rewriting everything like with the PUT method.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the HTTP verbs, let’s move onto the HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP uses client-server architecture. Sending requests always ends with a response.
    Depending on the request, you may end up with different response status codes
    that indicate the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP status codes are responses from the server indicating the success or failure
    of your request.These codes are organized into five main groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Informational responses (`100` – `199`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successful responses (`200` – `299`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection messages (`300` – `399`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client error responses (`400` – `499`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server error responses (`500` – `599`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s cover the most used HTTP response status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**200 OK**: This is the best message you can get! It means that the server
    understood your request and did what you asked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201 Created**: This code means that your request resulted in creating something
    new, such as a new document or account.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**301 Moved Permanently**: This tells you that the requested item has been
    moved to a new location permanently. The server usually gives you the new address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**302 Found**: This code means that the requested item is temporarily at a
    new location. The server also provides the new address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 Not Found**: This is a common code indicating that the server couldn’t
    find the item you requested, like a missing book in a library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401 Unauthorized**: This code indicates that you are not allowed to access
    the requested item, like trying to enter a locked room.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403 Forbidden**: This code means that you are authorized but don’t have permission
    to access the specific item, like having a key but not being allowed into a specific
    room.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**413 Request Entity Too Large**: This code indicates that the data you sent
    in your request is too large for the server to handle, like trying to fit too
    many books into a small box.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**429 Too Many Requests**: This code means you’ve made too many requests in
    a short period of time, like trying to borrow too many books at once.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 Internal Server Error**: This code means that the computer encountered
    an internal problem and couldn’t fulfill your request, like a library experiencing
    technical issues.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**503 Service Unavailable**: This code indicates that the computer is temporarily
    unavailable due to maintenance or overload, like a library being closed for renovation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, these are just a few examples but understanding them can help you
    decode the messages from websites and navigate the online world more smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main ways in which we design and work with APIs nowadays are using REST
    and **GraphQL**.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when developers begin their journey in API development, they start
    by making a REST API. However, as they dive deeper into the specifics, they realize
    that the REST approach doesn’t always work perfectly for every situation. GraphQL
    then steps in to help when REST isn’t the best fit.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Facebook started using GraphQL in real projects as early as 2012,
    when it was still called SuperGraph, it wasn’t shared with the public until 2016.
  prefs: []
  type: TYPE_NORMAL
- en: Today, GraphQL has become the preferred method for designing and interacting
    with APIs, surpassing REST in popularity.
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for adopting GraphQL was to tackle the issues that arose
    when both the mobile and desktop versions of an application utilized the same
    API, specifically the REST API. Say you’re using a website on your mobile device.
    The desktop version can handle larger amounts of data, so it receives a more comprehensive
    dataset from the server. Unlike desktop versions, mobile apps have limits on data
    use because of slow connections and less processing power, making it impossible
    to handle large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a REST response that contains excessive data for mobile
    needs, where we only require a portion of the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, when the user data is loaded for the first time, we only need a part of
    this data in the mobile version. For this reason, the resource-based distribution
    of the data (using REST) seems to be an ideal choice for design. Since there is
    no problem with internet availability for most desktop users, there is no problem
    with receiving data from different resources and displaying them as a single piece
    of information.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that we get only the required information, we filter the data based
    on its **ID**. In doing so, we conduct a kind of synchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not suggesting an ideal solution for mobile data retrieval.
    Instead, we propose either developing a separate API specifically for mobile devices
    or implementing a more flexible and dynamic resource fetching mechanism by adopting
    an alternative approach to RESTGraphQL offers a more efficient approach to API
    interaction and design, especially when considering mobile and other resource-constrained
    devices. Originally intended for mobile use, GraphQL has evolved to support dynamic
    and effective data exchange across various platforms. Unlike traditional REST
    API design, GraphQL enables the synchronous retrieval of information from multiple
    resources in a single query, eliminating the need to fetch data resource by resource.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its application in mobile development, GraphQL is now extensively
    utilized in microservice design, further showcasing its versatility and widespread
    adoption in modern software development practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the differences between REST and GraphQL is important when it
    comes to applying them in practice. Let’s define the main differences between
    these two powerful communication techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile apps need slim and efficient data compared to desktop apps. REST APIs,
    which are often used for desktops, can be bulky for mobile. GraphQL solves this
    by letting you request only the specific data your app needs, avoiding unnecessary
    downloads while reducing over-fetching and under-fetching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST works by focusing on individual pieces of information such as *users* or
    posts. To get related details, such as information about a specific user’s posts,
    you need to make separate requests for each piece. This can feel slow because
    you have to wait for one request to finish before making the next. Long story
    short, REST APIs typically deliver one set of information for each access point.
    In contrast, GraphQL allows you to request various data combinations from a single
    point, making it more flexible and adaptable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering information from multiple sources in REST requires separate requests,
    which can sometimes cause delays. GraphQL, however, lets you grab data from various
    sources in one go, presenting it to the user as a single unit. This reduces the
    number of requests and makes your app feel smoother.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a REST API often involves versioning it to avoid breaking existing
    apps. GraphQL avoids this complexity by allowing additions without requiring changes
    on the app side, making it easier to keep things up to date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike REST, which focuses on managing specific pieces of data, GraphQL is
    built with mobile and frontend experiences in mind. This means it allows you to
    do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get only the data your app needs, reducing the amount of information transferred
    (smaller payload size)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid unnecessary requests by fetching everything in one go, making your app
    faster and more efficient
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: REST APIs struggle with frequent changes because their structure is fixed. Imagine
    an endpoint that can receive many different instructions or give answers in various
    formats. This can cause issues with REST. GraphQL, however, handles these situations
    much better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In microservice architectures, where each service manages its own data, GraphQL
    shines. It allows you to combine information from multiple services in a single
    request, presenting it as one unified piece of data to the user. This makes building
    and managing complex applications much easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing a single-page or native mobile app, GraphQL’s principles of
    “give only the information that the user needs” and “focus on a single unified
    resource” allow us to develop frontend-heavy applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under GraphQL, the frontend team can work on their tasks (user stories) without
    waiting for the backend team to create specific REST endpoints. This allows for
    faster progress and quicker app updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful APIs employ HTTP methods like PUT, DELETE, POST, and PATCH for data
    modification, collectively termed mutations in GraphQL. On the other hand, GraphQL
    utilizes a Query operation for retrieving data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most scenarios, having REST and GraphQL will be enough for you. However,
    they are not the only communication mechanisms for your microservices. We have
    another interesting communication protocol called a **Remote Procedure Call**
    (**RPC**). Let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Remote Procedure Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another communication protocol that we can use when establishing communication
    between microservices is RPC. Using RPC, one microservice can request a service
    from another microservice that is located in another computer on a given network
    without understanding the network details.
  prefs: []
  type: TYPE_NORMAL
- en: RPC is a method for these microservices to talk. It’s like one program asking
    another program on a different computer to do something, even though they aren’t
    directly connected. This makes it easier for the microservices to work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the core RPC flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a microservice asking another microservice on a different computer to
    run a specific function (such as a task). This request is disguised as a normal
    function call, even though it’s happening over a network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A middleman service (called a proxy) intercepts this request and takes care
    of the complex network communication behind the scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The proxy sends a message containing the details of the function and any required
    data to the target microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target microservice receives the message, understands the function request,
    and executes it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it is done, it sends a response message back through the proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the proxy delivers the response to the requesting microservice, making
    it seem like a regular function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This flow sounds familiar, doesn’t it? That is because it is just a simple client-server
    mechanism. With the meaning and flow of RPC made clear, it’s time to understand
    some of its other important aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and considerations of RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What about the benefits of RPC for microservices? Let’s emphasize the main
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier development**: Using RPC is like making normal function calls, which
    programmers are already familiar with. This makes it simpler to build microservices
    because developers don’t need to worry about the technical details of network
    communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potentially faster**: RPC can be faster than other methods because it uses
    pre-defined data formats specifically designed for these calls, instead of needing
    to interpret complex formats like JSON or XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some important things that you need to consider with RPC?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight connections**: RPC can make microservices more reliant on each other.
    If one microservice changes the way its functions work (their interface), it can
    affect all the other microservices that rely on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited flexibility**: Choosing a specific RPC framework might make it harder
    to switch to a different one later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, RPC is a powerful tool for microservices to talk to each other.
    It simplifies development and can be fast, but you should keep in mind the potential
    downsides of tighter connections and limited flexibility when deciding whether
    it’s the right choice for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are special programs called RPC frameworks built specifically to make
    communication between microservices smoother. These frameworks act like toolkits
    that simplify the process. Here are a few popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gRPC**: This framework focuses on making things fast and efficient. It uses
    a special format called **Protocol Buffers** to package data in a way that’s compact
    and easy to transmit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Thrift**: Another popular option, Thrift is known for working with
    many different programming languages and can handle various data packaging formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOAP**: Provides a standardized way to encode messages using XML and transport
    them using mostly HTTP and HTTPs protocols . We can use SOAP to implement RPC.
    This allows applications to call procedures on remote servers as if they were
    local procedures. But we should take into account that SOAP is not limited to
    RPC and can be used for more general message exchange processes as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Communication Foundation** (**WCF**): WCF is a framework developed
    by Microsoft for building service-oriented applications. It can be used to implement
    various communication mechanisms, including RPCs. WCF provides a lot more functionality
    than just RPC. It offers features such as data contracts, service hosting, and
    security. So, while WCF can be used for RPC, it’s not limited to that specific
    approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RPC is a powerful way for microservices to communicate. It makes development
    easier and can be faster than other methods. However, remember the potential drawbacks
    of tighter connections and limited flexibility when deciding whether it’s the
    best choice for your project. Weigh the pros and cons carefully to make the right
    call for your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the general idea behind the communication protocols, it is
    time to talk about communication methods for microservices. Understanding the
    strengths and weaknesses of each approach is essential for designing robust and
    scalable microservice architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous microservice communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To exchange some information between microservices, they need to be able to
    talk to each other. In microservice communication, we mostly use two main patterns
    to establish communication between microservices. They are **Synchronous Communication**
    (**sync**) and **Asynchronous** **Communication** (**async**).
  prefs: []
  type: TYPE_NORMAL
- en: Sync is the easiest of the two communication patterns.
  prefs: []
  type: TYPE_NORMAL
- en: When one microservice needs information from another, it makes a direct request
    and waits for an answer before moving forward. The communication by itself is
    simpler and more reliable. It is just a function or method call if you compare
    it to a monolith application)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The calling microservice sends a message to another microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The calling microservice pauses its work and waits for a reply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other microservice processes the request and sends a response back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the calling microservice has received the response, it can continue its
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We mostly use REST, GraphQL, and gRPC when implementing sync between microservices
    that rely on HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: This image shows a simple synchronous communication between Order API and Stock
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Synchronous microservice communication](img/B09148_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Synchronous microservice communication'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see some important aspects of sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of its advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple and predictable**: The flow of execution is straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediate feedback**: The requestor receives the response immediately, making
    it suitable for interactive applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, as we learned before, nothing is without its downsides. This communication
    form also brings some disadvantages to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocking**: The requestor is blocked until the response arrives, which can
    lead to performance issues if the receiving service takes a long time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coupling**: Services become tightly coupled, making them more difficult to
    change and scale independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single point of failure**: If the responding microservice is unavailable,
    the entire process gets blocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After having understood the flow of this communication and some of its advantages
    and disadvantages, it’s also important to see how we might apply this to some
    real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some real-world examples of sync in microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shopping cart**: Imagine you fill your cart online and hit pay. The cart
    service (like your shopping list) talks directly to the payment service (like
    the cashier) to confirm payment before creating the order. This way, you know
    right away whether the payment went through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catching cheaters**: When you place an order online, the order service (like
    the order taker) asks the fraud checker (like security guard) to see whether it’s
    okay. The checker says yes or no right away, so only real orders go through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live chat** **support**: When you type a message in a chat, your message
    goes to a service that finds an agent (like finding a helper). The agent gets
    your message and replies directly, so you can chat back and forth quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online games**: In online games, your actions are sent to a game server (like
    the game referee). The server updates the game world (like changing the score)
    based on your actions and sends it back to everyone playing, keeping the game
    smooth for all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stock trading**: When you buy or sell stocks on an app, it talks directly
    to a service at your brokerage (like your investment person). This service makes
    the trade right away, tells the app that it’s done, and updates your account balance.
    This gives you quick confirmation so you can manage your money.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are just a few examples, and in general, you should understand that sync
    is ideal when you need any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Immediate feedback and interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time dialogue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time decision-making and execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just-in-time analysis and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tightly coupled workflows with high dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous microservice communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sync is like having a direct conversation, but async is more like leaving a
    message. Microservices don’t wait for a reply, they just send the information
    and move on.
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous communication, the requesting service sends a message to the
    receiving service without waiting for an immediate response. The response is delivered
    later, either through a callback or through a separate channel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Asynchronous microservice communication](img/B09148_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Asynchronous microservice communication'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Send a message**: The calling microservice sends a message with the information
    to another microservice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Move on**: The calling microservice doesn’t wait for a reply. It continues
    its own task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Process later**: The other microservice receives the message and works on
    it whenever it’s free.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reply**: The other microservice might send a response back later, but that’s
    not required.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of it like leaving a note for someone – they can get to it when they have
    a chance.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, we use a message broker to handle async between microservices.
  prefs: []
  type: TYPE_NORMAL
- en: For complex communication patterns, high message volume, or critical tasks,
    a message broker is a good choice. For simpler scenarios where reliability is
    less crucial, direct queues or event sourcing can be better alternatives to a
    message broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s cover the most important advantages of using async between microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-blocking**: The requester can continue processing without waiting for
    the response, improving performance and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupling**: Services are loosely coupled, making them easier to change
    and scale independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: Async can handle failures and retries more gracefully than
    sync.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent work**: Microservices can focus on their own tasks without worrying
    about others being busy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delayed results**: You might not know whether the message was received or
    processed right away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More complex**: Setting up async can be trickier than sync. Sync doesn’t
    require an additional layer when establishing communication. However, as I mentioned
    before, for true async you mostly need to use a message broker as middleware between
    communicated services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let us look at some practical applications of this type of communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending emails**: The order service can send an order confirmation email
    without waiting for it to be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating inventory**: When a sale is made, the order service can send a message
    to update the inventory. It can keep processing other orders in the meantime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-running tasks**: A microservice can send a message to another service
    to do a time-consuming job, such as video encoding, without being stuck waiting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social media feed updates**: Post service publishes a message to the feed
    queue. The feed service subscribes to the queue and updates user feeds in the
    background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is better to choose to use async between microservices when any of the following
    conditions apply:'
  prefs: []
  type: TYPE_NORMAL
- en: An immediate response is not essential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background tasks or long-running processes are needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling and scalability are key considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async is great for tasks that don’t need immediate answers, but sync might be
    better for things that need a quick response.
  prefs: []
  type: TYPE_NORMAL
- en: Essential communication patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building microservices, we mostly need a single point of entry for our
    clients to consume the services that we develop. You may think about it like a
    decorator or wrapper over your services. Clients talk to your app through a simple
    door (API gateway) instead of needing to know the messy inner workings (microservices).
    The gateway intelligently routes incoming requests to the appropriate microservices
    based on factors such as URL patterns, path variables, or headers.
  prefs: []
  type: TYPE_NORMAL
- en: An important component of microservice architecture is an API gateway. This
    API offers several features to help manage and expose common functionalities across
    multiple microservices. Often, a client request might require data from multiple
    microservices. The gateway acts as an orchestrator, fetching data from relevant
    services, aggregating it (if necessary), and returning a cohesive response to
    the client. In short, API gateways are essential components of microservice architecture.
    They provide a single point of entry for clients, enhancing security and manageability,
    as well as the overall effectiveness of your microservices)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: An API gateway](img/B09148_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: An API gateway'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to summarize the benefits of API gateways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single entry point**: There is no need to understand the internals of microservices.
    Using an API gateway helps you to be isolated from such details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request routing**: An API gateway acts as smart middleware to route queries
    from the users to the exact microservices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregator**: The gateway acts as an orchestrator, fetching data from relevant
    services, aggregating it (if necessary), and returning a cohesive response to
    the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The gateway can be a central hub for authentication, authorization,
    and rate limiting. It verifies client identities, enforces access controls, and
    prevents potential abuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformation**: The gateway can manipulate requests and responses to match
    the expected formats of backend services or tailor responses for clients. This
    includes tasks such as content negotiation, protocol translation, and data validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common tasks**: The gateway can handle common tasks such as request validation,
    caching, and logging, reducing the burden on individual microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: When there’s a lot of work to be done (heavy traffic),
    load balancing acts like a traffic director. It cleverly distributes incoming
    requests across multiple copies (instances) of the same microservice. No single
    microservice gets overwhelmed, making the best use of all available resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaker**: An API gateway often contains a circuit breaker for resiliency,
    cascading failure, and protecting system’s stability. A circuit breaker in microservices
    is like a switch that automatically stops sending requests to a service if it’s
    not responding well, helping prevent system-wide failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message brokers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a direct communication model, microservices would have to be aware of each
    other’s locations and availabilities. This creates a tightly coupled system that’s
    difficult to maintain and update.
  prefs: []
  type: TYPE_NORMAL
- en: By introducing a message broker, microservices become loosely coupled. They
    simply send messages to the broker, which handles the routing and delivery. This
    allows microservices to operate independently without needing to know the specifics
    of other services.
  prefs: []
  type: TYPE_NORMAL
- en: With message brokers, communication becomes asynchronous. A producer (microservice)
    can send a message without waiting for a response from the consumer (another microservice).
    This improves performance and scalability as microservices don’t have to wait
    on each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Message brokers](img/B09148_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Message brokers'
  prefs: []
  type: TYPE_NORMAL
- en: Message brokers use different message storage models. The most popular ones
    are **Message Queues** (**MQs**) and **Topic.** Message brokers store messages
    in an MQ until they are received by consumers. MQs are a crucial part of message
    brokers that act as storage for the data. Unlike Topic, they delete data after
    the consuming process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to understand the components of a typical message broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Producer (Publisher)**: This is the one that sends a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer (Subscriber)**: This is the one that reads a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MQ (or Topic)**: This is the one that stores the message. Topic allows for
    a publish-subscribe model, whereby multiple consumers can receive the same message.
    On the other hand, MQ queue follows a **First-In, First-Out** (**FIFO**) approach,
    ensuring messages are processed in the order in which they are received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a lot of popular message broker implementations out there. In practice,
    we will use Apache Kafka, one of the most popular message brokers. Let’s talk
    about the most popular message broker implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RabbitMQ**: This is an open source message broker that is widely known for
    its flexibility and ease of use. It supports different messaging patterns, including
    point-to-point (only one specific application receives a message) and **Publisher
    and Subscriber** (**pub/sub**). It acts as a central post office for your applications.
    Apps can send and receive messages without needing to know each other’s exact
    addresses. It helps us to have tightly coupled communication. It is flexible,
    easy to use, and has a large community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Kafka**: It is a powerful option to implement a message broker. It
    has crucial attributes such as high throughput, durability, scalability, fault
    tolerance, real-time processing, and many others. Apache Kafka is more than a
    message broker with data storage and stream processing integration. We will talk
    more about the internals of Kafka in the next chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Simple Queue Service** (**SQS**): Like other message broker implementations,
    it provides decouple and scale microservices. SQS acts as a queue where you can
    send messages (data), store them securely, and then retrieve them via other applications
    or services. SQS decouples applications by enabling them to communicate asynchronously.
    The sender doesn’t need to wait for the receiver to be available, improving overall
    application responsiveness and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need real-time stream processing, Apache Kafka might be a better option
    for you rather than RabbitMQ and SQS. On the other hand, if you like to have advanced
    features such as message filtering or priority queues, use RabbitMQ over SQS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about microservice communication. We talked about different
    communication techniques such as REST, GraphQL, and RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed the fact that we mostly use two types of communication forms between
    microservices: synchronous and asynchronous. Sync is simple and has immediate
    feedback, but it is a blocking operation with attributes such as a single point
    of failure and coupling. We talked about the advantages and disadvantages of sync
    and discussed when to and when not to use it in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we learned that async is non-blocking and comes with delayed
    responses. It is mostly preferable (depending on the task) but brings additional
    complexity. To make async happen, we learned that we mostly need additional layers
    like message brokers.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the discussion was centered around the most used patterns such
    as API gateway and message broker.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway, as an orchestrator, provides a single point of entry with additional
    functionalities such as security, transformation, load balancing, and so on. It
    is an essential part of microservice communication.
  prefs: []
  type: TYPE_NORMAL
- en: We further learned about establishing async. Using message broker, we mostly
    establish async between microservices. It is an additional layer between services
    that handles common tasks (depending on message broker implementation). It has
    multiple implementations such as RabbitMQ, Apache Kafka, Amazon SQS, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the next chapter, we will cover JavaScript and NodeJS essential
    you need to know before diving into details of microservice development. Stay
    tuned!
  prefs: []
  type: TYPE_NORMAL
