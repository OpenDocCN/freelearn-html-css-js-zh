<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Designing Simple Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Designing Simple Modules</h1></div></div></div><p>In this chapter, we are going to focus on applying the concepts that we have learned in the previous chapters to design some simple modules for our application.</p><p>We will start by analyzing our application's functionality as a whole and then we will break it down into smaller functional pieces. Once we have decided on our application's functional pieces, we will start creating simple modules to implement the required functionality.</p><p>This chapter is meant to demonstrate the possible steps in the beginning of our application's life cycle, based on our requirements. The goal is to see how using modules can help us design a better architecture and get a feel for the practical advantages of a modular design.</p><p>The simple modules that we create in this chapter will provide the foundation for our final application in this book, which will be a working client-side single page application.</p><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reflecting the overall application requirements in our design</li><li class="listitem" style="list-style-type: disc">Designing the application's main pieces</li><li class="listitem" style="list-style-type: disc">Creating specialized modules for our application's main pieces</li><li class="listitem" style="list-style-type: disc">Collaboration among modules</li><li class="listitem" style="list-style-type: disc">Using object definitions to describe page fragments</li><li class="listitem" style="list-style-type: disc">Dynamically generating pages and page fragments</li></ul></div><div class="section" title="The big picture"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec20"/>The big picture</h1></div></div></div><p>Before we<a id="id138" class="indexterm"/> start any coding at all, we need to have a good understanding of what our application is all about, what the requirements are, and what possible functional pieces are needed to satisfy our requirements.</p><p>While in the beginning of an application's design phase, we try to answer as many questions as possible regarding our application's requirements, we should always try not to get too tied down by the details.</p><p>The idea<a id="id139" class="indexterm"/> is to get the big picture right, understand what it is that we want to deliver, the timelines involved, and the resources available. Based on such analyses, we can start creating a scalable, flexible, and extensible architectural design for our application.</p><p>I'd like<a id="id140" class="indexterm"/> to draw your attention to a very important word that I used here, <span class="strong"><strong>extensible</strong></span>. The ability of an application to be easily extended is very important in a proper design. Keep in mind that no matter how much we try to finalize all of the requirements for an application ahead of time, we won't be able to foresee them all in the beginning.</p><p>Requirements change over time, new requirements are added, and old requirements get modified or even removed altogether from the final draft of the application. The key is to design our application in a way that can accommodate all such changes without a big impact on the overall architecture. This is where the advantages of a modular architecture shine and help to mitigate the adverse effects that such changes might have on the application as a whole.</p><p>As we keep these points in mind, let's talk about the application that we are going to build together in this book.</p><div class="section" title="Our application requirements"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Our application requirements</h2></div></div></div><p>Our <a id="id141" class="indexterm"/>application is a simple yet fully functional image gallery application. The goal is to present the users with a catalog of beautiful images on our site. Our site visitors can click each of the images to see a full view of the image and add the images to their favorite list of images, if they wish to do so.</p><p>The application will have a header, a navigation bar at the top, a main content area in the middle, a footer, and of course a logo.</p><p>As you can tell, there are not many complicated pieces at play here, but I assure you that under the hood there are many modules that can be easily ported from this application to many other more complex applications.</p><p>Let's start by creating an overall layout (wireframe) of our application and see what the big picture looks like.</p><div class="mediaobject"><img src="graphics/B04910_04_01.jpg" alt="Our application requirements"/></div><p>I have <a id="id142" class="indexterm"/>identified the main pieces of our index page in this mock-up. We are going to create modules to build and update this page, its related pieces, and the rest of the application for us.</p></div><div class="section" title="Dynamic views"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Dynamic views</h2></div></div></div><p>I mentioned<a id="id143" class="indexterm"/> that our JavaScript modules are going to build this page for us, and I need to explain this a little further.</p><p>While we are going to create modules to take care of the functional pieces of the application, we are going to take that a step further. We are also going to create modules that will specialize in building our pages (views) dynamically on the client side.</p><p>In this design, we only receive the skeleton of the page from the server. The page will be populated by our view-generating modules based on the object definitions for each page section (fragment) that is sent to the client.</p><p>The <a id="id144" class="indexterm"/>overall architecture of our application is based on <span class="strong"><strong>Single Page Application</strong></span> (<span class="strong"><strong>SPA</strong></span>) design concepts. If you are not familiar with this term, the idea is that as we navigate through our application pages (views), we won't need to load or build the parts of the page that don't change from one view to the next. We simply update the changed pieces of the view dynamically on the client while keeping the rest of the view untouched.</p><p>Since we only do targeted changes in our application's view, the rendering of our views will be more robust and optimized.</p><p>This also means that after the application's initial load, the client will only be requesting the changed parts of the application from the server. Therefore, we will only be transferring the page fragments over the bandwidth as opposed to the full page. Generally speaking, this can be a great advantage when we design applications that need to operate in limited bandwidth scenarios, such as mobile applications.</p><p>For our application in this book, our page fragments are transferred as object definitions to the client side and our view-generating specialized modules will render the required views based on such object definitions.</p><p>You will see how we can achieve this in the near future as we move forward.</p></div></div></div>
<div class="section" title="Designing our SPA main pieces"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Designing our SPA main pieces</h1></div></div></div><p>Usually when designing SPA applications, I create a core application code base which is loaded in the browser at the application's initial load phase. This code base provides application-level functionality that is independent of the application's views. The application core consists of many modules that are loaded together. If<a id="id145" class="indexterm"/> you are familiar with <span class="strong"><strong>Model-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) or <span class="strong"><strong>Model-View-Wildcard</strong></span> (<span class="strong"><strong>MV*</strong></span>) application design patterns, this <a id="id146" class="indexterm"/>core is essentially the controller of the application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>
<span class="strong"><strong>MVC and MV* design patterns</strong></span>
</p><p>These design patterns create a good degree of specialization and separation of concerns in the code. Understanding these patterns is important in creating a good application architecture. While I will be referring to these patterns from time to time, covering them in depth is beyond the scope of this book.</p><p>I recommend <a id="id147" class="indexterm"/>the following resources for more information:</p><p>
<a class="ulink" href="https://www.packtpub.com/application-development/mastering-javascript-design-patterns/">https://www.packtpub.com/application-development/mastering-javascript-design-patterns/</a>
</p><p>
<a class="ulink" href="https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/">https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/</a>
</p></div></div><p>The model and views of the application also have their own specialized modules, some of which are loaded at the initial application load time and some as needed, dynamically, at a later time. This type of approach enables the application to have a small footprint in the browser and load only what it needs, as needed.</p><p>I also usually try to have every page of my application as a separate module (component) both on the server and the client side. This provides the capability to create, modify, or remove pages (components) and their related code without affecting other pieces of the application.</p><p>Note that I'm using the term "module" here as a general term and it does not necessarily mean modules that are built using the module pattern. My intent is to convey the idea that each page is a separate piece in the application, within which one or many JavaScript modules can be used to do the work related to that page and that page only. If you are not sure exactly what this means, rest assured it will all become more clear to you shortly.</p><p>The following figure depicts the main pieces of our application for this book, categorized by their special functionality and design:</p><div class="mediaobject"><img src="graphics/B04910_04_02.jpg" alt="Designing our SPA main pieces"/></div><p>As the figure shows, our overall design is based on three main pieces: <span class="strong"><strong>Controller</strong></span>, <span class="strong"><strong>View</strong></span>, and <span class="strong"><strong>Model</strong></span>. In the rest of this chapter, we will talk about each piece and will start building them based on our modular architecture.</p><div class="section" title="Application controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Application controller</h2></div></div></div><p>The <a id="id148" class="indexterm"/>controller is the piece that contains the main <a id="id149" class="indexterm"/>functionality of the application. Essentially, the controller module is the brain of the application. It will consist of application-level modules that provide application-level functionality. This piece will also be responsible for initializing all the other modules and components in the application as well as gluing them together using a loose coupling approach.</p><div class="section" title="Application controller modules"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Application controller modules</h3></div></div></div><p>Considering <a id="id150" class="indexterm"/>the role of the controller in our application as mentioned, we are going to design this piece based on specialized modules. These modules<a id="id151" class="indexterm"/> together create what we will be referring to as the <span class="strong"><strong>core</strong></span> module.</p><p>Keep in mind that since we are using specialized modules for our core, each module can easily be modified or replaced without affecting the other parts of the application, that is, with the exception of the functionality that is related to that module and that module only.</p><p>Of course, we can also add more modules to the core, if we decide that additional functionality is needed at some point in the future.</p><p>It is the collective functionality of the controller modules that provides the core functionality of the application.</p><p>Based on our application's requirements, I anticipate that we will be needing the following modules in our application's controller:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Page updater module</li><li class="listitem" style="list-style-type: disc">Storage handler module</li><li class="listitem" style="list-style-type: disc">Communication handler module</li><li class="listitem" style="list-style-type: disc">Utilities module</li><li class="listitem" style="list-style-type: disc">Message handler module</li><li class="listitem" style="list-style-type: disc">Logging handler module</li></ul></div><p>Keep in mind that we are making our best guess as to what modules are required. The list can change over time as we proceed further in our implementation. The idea is to design and implement the modules that we think we will be needing at this time, to have a starting baseline. However, the list of the modules, their functionality as well as the names that we choose for them can change over time.</p><p>Let's start by exploring what the functionality of each module in our application's core will be.</p><div class="section" title="Page updater module"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec03"/>Page updater module</h4></div></div></div><p>This <a id="id152" class="indexterm"/>module is responsible for building HTML pieces in our application. It does this task by injecting a string passed to it into a container. This string corresponds to the HTML elements that need to be rendered into the predefined container.</p><p>We will be building various pieces of our application pages and updating them dynamically as required, using this module.</p></div><div class="section" title="Storage handler module"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec04"/>Storage handler module</h4></div></div></div><p>This module has the specific responsibility of storing application-related data. This data can be either<a id="id153" class="indexterm"/> stored in cookies or in other storage facilities provided by the browser, such as HTML 5 local storage.</p></div><div class="section" title="Communication handler module"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec05"/>Communication handler module</h4></div></div></div><p>All <a id="id154" class="indexterm"/>application-related communication is done through this module. This module is mainly designed to use AJAX calls to communicate with the back-end server. However, the method of communication that this module uses might not be limited to AJAX calls at some point in the future.</p></div><div class="section" title="Utilities module"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec06"/>Utilities module</h4></div></div></div><p>This <a id="id155" class="indexterm"/>module is responsible for providing utility type functionality to the application. For instance, it can do string manipulation, object cloning, or page resize calculations.</p></div><div class="section" title="Message handler module"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec07"/>Message handler module</h4></div></div></div><p>As<a id="id156" class="indexterm"/> events take place in the application, we need a way to communicate such events with the users and display messages on the application's pages. This module specializes in this task.</p></div><div class="section" title="Logging handler module"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec08"/>Logging handler module</h4></div></div></div><p>This <a id="id157" class="indexterm"/>module provides all the functionality related to the logging mechanism of the application. The logging can take place on the client side, the server side, or both.</p></div></div></div><div class="section" title="Creating our first core module"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Creating our first core module</h2></div></div></div><p>Now<a id="id158" class="indexterm"/> that we have put together the list of possible required modules for the core, let's create the first module of our application's controller, the <code class="literal">PageUpdater</code> module. This module should be designed in such a way that it can dynamically update a fragment of the page. This fragment can be as small as a text on the page, or as large as the entire displayed page itself. The update to the page fragment can be as trivial as changing the font size or the background color or as complex as completely re-structuring and re-rendering of the page fragment altogether.</p><div class="section" title="Structure of our first module"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Structure of our first module</h3></div></div></div><p>Consider<a id="id159" class="indexterm"/> the following:</p><div class="informalexample"><pre class="programlisting">var PageUpdater = (function(){

    // module private function
    var insertHTMLTxt = function(containerID,newStructure){
        
        var theContainer = document.getElementById(containerID);
        theContainer.innerHTML = newStructure;
    };
    
    // module private function
    var applyElementCSS = function(elementID, className){
        
        var theElement = document.getElementById(elementID);
        theElement.className = className;
    };
    
    return{
        
        // privileged method
        updateElement : function(elemID, htmlTxt){
            
            insertHTMLTxt(elemID,htmlTxt);
        },
        
        // privileged method
        updateElementClass : function(elemId,className){
            
            if(!className){
                
                console.error('No class name has been provided, exiting module!');
            }
            applyElementCSS(elemId,className);
        }
    };
    
})();</pre></div><p>The <a id="id160" class="indexterm"/>preceding code implements a simple module which enables us to do an update on a page fragment. Let's examine the code and see how it is structured.</p><p>We have defined a JavaScript module, using the module pattern. An IIFE is used to execute the code in our anonymous function, which creates a namespace. What gets returned from this function is an object that is assigned to our global variable <code class="literal">PageUpdater</code>.</p><p>In our IIFE, we have defined <code class="literal">insertHTMLTxt</code> and <code class="literal">applyElementCSS</code> method properties, using function expressions. These two methods are kept within the internal private scope of our main container function, and as such no external code can access them. Thus, we are protecting them from accidental and unintended modifications.</p><p>We do<a id="id161" class="indexterm"/> provide controlled and indirect access to these methods through the module's interface, which is the anonymous object that is returned when our container function is executed. A reference to this returned object (our module's interface) is assigned to the <code class="literal">PageUpdater</code> variable.</p><p>So in fact what is really referenced in this variable (<code class="literal">PageUpdater</code>) is the following object:</p><div class="informalexample"><pre class="programlisting">{   
        // privileged method
        updateElement : function(elemID, htmlTxt){
            
            insertHTMLTxt(elemID,htmlTxt);
        },
        // privileged method
        updateElementClass : function(elemId,className){
            
            if(!className){
                
                console.error('No class name has been provided, exiting module!');
            }
            applyElementCSS(elemId,className);
        }
};</pre></div><p>As this is just a normal JavaScript object, we can call its methods from the external code as:</p><div class="informalexample"><pre class="programlisting">PageUpdater.updateElement("headerContainer",headerContainerDef.sectionHTML);</pre></div><p>The <code class="literal">updateElement</code> method of the <code class="literal">PageUpdater</code> object in turn calls <code class="literal">insertHTMLTxt(elemID,htmlTxt)</code>, which is the method inside our container function that does the real work behind the scene.</p><p>This method receives two parameters: the id of the container element (<code class="literal">containerID</code>), which we intend to update its contents, and a string (<code class="literal">newStructure</code>), which is the string representation of the HTML elements that will be rendered inside this container element.</p><p>If you are wondering how <code class="literal">PageUpdater</code> object can call the method inside of our container function and how the link is established between the two, you need to think of one word: closure!</p><p>We did <a id="id162" class="indexterm"/>talk about closures in <a class="link" href="ch02.html" title="Chapter 2. Review of Important JavaScript OOP Concepts">Chapter 2</a>, <span class="emphasis"><em>Review of Important JavaScript OOP Concepts</em></span>. If you recall, because the anonymous object returned from our IIFE was defined inside the container function, it has access to the internal private scope of our container function. This means <code class="literal">PageUpdater</code> has access to all the private variables and methods defined inside of that scope. That is why the methods that<a id="id163" class="indexterm"/> are returned as part of the interface from the module are called, <span class="strong"><strong>privileged methods</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Having problems understanding the module pattern?</strong></span>
</p><p>I took<a id="id164" class="indexterm"/> some time here to explain our first simple module in depth. Moving forward, I will not be explaining the pattern used in creating our modules (module pattern) in as much detail. It is important for you to have a good understanding of this pattern, as our other modules in the application follow a similar structure.</p><p>For a better understanding of the module pattern, I recommend doing two things. First, review <a class="link" href="ch02.html" title="Chapter 2. Review of Important JavaScript OOP Concepts">Chapter 2</a>, <span class="emphasis"><em>Review of Important JavaScript OOP Concepts</em></span> and <a class="link" href="ch03.html" title="Chapter 3. Module Design Pattern">Chapter 3</a>, <span class="emphasis"><em>Module Design Pattern</em></span> again. Second, spend some time analyzing the previous code and read my explanations a couple more times. I'm sure you will get a good grasp of this pattern very soon.</p></div></div><p>Note that the <code class="literal">PageUpdater</code> module is currently capable of doing two things. It can update the <code class="literal">innerHTML</code> of a container element as well as being able to update the <span class="strong"><strong>CSS</strong></span> class of an element on the page.</p></div><div class="section" title="Using our first module's functionality"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Using our first module's functionality</h3></div></div></div><p>The <a id="id165" class="indexterm"/>following is an example of how we can leverage the module's functionality by making calls to its methods:</p><div class="informalexample"><pre class="programlisting">PageUpdater.updateElement("footerContainer", footerContainerDef.sectionHTML);

PageUpdater.updateElementClass("footerParentContainer", "footerContainerClass_Test");</pre></div><p>The first line of the preceding code populates the footer section of our application, based on a predefined object definition, which we will talk about a little later in this chapter. The second line of code changes the CSS class of the footer container to apply a different background color to this page fragment. The code accompanying this chapter has the CSS class definition for this operation.</p><p>As you <a id="id166" class="indexterm"/>can see, we let the module take care of the mechanics of how page fragments are updated, and all we have to do is to make simple calls to it through the interface that has been provided for this module.</p></div><div class="section" title="Mapping our module's methods to its interface"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Mapping our module's methods to its interface</h3></div></div></div><p>There is one important point that we need to note regarding our module's interface, which can easily be missed.</p><p>If you<a id="id167" class="indexterm"/> recall, in <a class="link" href="ch03.html" title="Chapter 3. Module Design Pattern">Chapter 3</a>, <span class="emphasis"><em>Module Design Pattern</em></span>, I mentioned that a module is free to implement how it accomplishes its tasks and this implementation can change over time. However, a module should keep its interface consistent to the outside world. Of course, this is because the interface of a module is the module's contact and that's how the other pieces of the application can interact with it.</p><p>Notice how we have defined the following interface for our <code class="literal">PageUpdater</code> module:</p><div class="informalexample"><pre class="programlisting">updateElementClass : function(elemId,className){
            
            if(!className){
                
                console.error('No class name has been provided, exiting module!');
            }
            applyElementCSS(elemId,className);
}</pre></div><p>As you can see, to the outside world, when a CSS class needs to be applied to an element, the <code class="literal">updateElementClass</code> method should be called on the module. This module in turn calls a method with a different name in the module's definition, which is <code class="literal">applyElementCSS</code>.</p><p>This type of mapping allows us to change the name of the internal method of the module without affecting the module's interface for the external code. The mapping provides a layer of abstraction between the module's internals and its public interface.</p><p>Our module is currently a simple module that does relatively simple things for our application, but it does not have to be limited to what we have defined here.</p><p>As we move along in this book, we will be augmenting this module (and others) to do more things. Nonetheless, we should always keep in mind that this module is specialized to only do tasks that are related to updating of our application pages and nothing beyond that. After all, one of the main ideas behind modular design is that each module only does one type of work and nothing more so we can stay true to the concept of separation of responsibilities and concerns.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>
<span class="strong"><strong>Running the accompanying application's code</strong></span>
</p><p>You'll be able to run the application's code by loading the <code class="literal">index.html</code> page in the browser using any IDE that has a built in web server.</p><p>Please <a id="id168" class="indexterm"/>have a look at the code that accompanies this chapter and use this module to update different fragments of the page as you wish. All the modules discussed in this chapter can be found in the <code class="literal">js</code>/<code class="literal">Modules.js</code> file in the accompanying code.</p></div></div></div></div><div class="section" title="Application view"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Application view</h2></div></div></div><p>Another<a id="id169" class="indexterm"/> main piece of our application is the <span class="strong"><strong>view</strong></span> piece. As the name implies, this piece deals with the view of all the pages and page fragments of the application. The view is what the user actually sees in the browser.</p><p>Since our <a id="id170" class="indexterm"/>application is based on a MV* type architecture (in conjunction with modular architecture), our views interact with the controller as well as the model pieces.</p><p>However, the way we will build our application's views is a little different than traditional MV* applications. Our application views will be designed as modules and because these modules specialize<a id="id171" class="indexterm"/> in creating views, we will be calling them <span class="strong"><strong>components</strong></span>. This is to make the distinction between modules that have views and those that only provide functionality but have no direct relations to our application's views.</p><p>One other thing to keep in mind about components is that they can implement their own MV* architecture. This type of implementation might not be very clear to you at this time, but I assure you that it will all make more sense in the following chapters.</p><p>In this section, we will only focus on how <code class="literal">index.html</code> is built and how it is populated using a few object definitions and the controller methods that we saw in the previous section.</p><p>To create our <code class="literal">index.html</code> page, we will start by building a skeleton for this page and then we will dynamically modify this skeleton to produce its main fragments.</p><div class="section" title="Creating the index.html page skeleton"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Creating the index.html page skeleton</h3></div></div></div><p>The <a id="id172" class="indexterm"/>page skeleton of our application is designed to be as minimalist as possible at this stage.</p><p>Have a look at the page structure as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta content="width=device-width, initial-scale=1.0" name="viewport"&gt;
    &lt;title&gt;Images Inc.&lt;/title&gt;
    &lt;link href="css/app.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header class="headerContainerClass" id="headerContainer" role="banner"&gt;
    &lt;/header&gt;
    &lt;main class="clearfix mainPageContainerClass" id="mainPageContainer" role=
    "main"&gt;&lt;/main&gt;
    &lt;div class="footerContainerClass" id="footerParentContainer"&gt;
        &lt;div class="footerlinksContainerClass" id="footerContainer"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="js/Modules.js" type="text/javascript"&gt;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>When<a id="id173" class="indexterm"/> we render this HTML markup in the browser, we will have the following skeleton of our <code class="literal">index.html</code> page displayed:</p><div class="mediaobject"><img src="graphics/B04910_04_03.jpg" alt="Creating the index.html page skeleton"/></div><p>Notice <a id="id174" class="indexterm"/>that we have created three main containers: <code class="literal">headerContainer</code> (the top section of the page), <code class="literal">mainPageContainer</code> (the middle section of the page), and <code class="literal">footerContainer</code> (the bottom section of the page), which are the three main fragments of the page.</p><p>We will be populating each one of these page fragments with the HTML elements that we need.</p></div><div class="section" title="Creating an object definition for the header"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Creating an object definition for the header</h3></div></div></div><p>If you <a id="id175" class="indexterm"/>recall, I mentioned that we will be using object definitions to define our page fragments in the application.</p><p>As these object definitions are very similar to each other, we will only examine one of them in this section , which is related to the header fragment of the page.</p><p>Here is the object definition for the header section:</p><div class="informalexample"><pre class="programlisting">var headerContainerDef = {
    sectionHTML: '&lt;div class="logo_titleClass" &gt;' +
        '&lt;a href=""&gt;&lt;img src="img/ImagesIncLogo.png" alt="Company Logo" style="max-height:100%;"&gt;&lt;/a&gt;' +
        '&lt;div class="siteTitleClass"&gt;Images Inc.&lt;/div&gt;' + '&lt;/div&gt;' +
        '&lt;nav role="navigation" itemscope itemtype="https://schema.org/SiteNavigationElement"&gt;' +
        '&lt;h1 class="hiddenClass"&gt;Main Navigation&lt;/h1&gt;' +
        '&lt;ul class="navmenuClass" &gt;' +
        '&lt;li&gt;&lt;a href="#" class="active"&gt;Home&lt;/a&gt;&lt;/li&gt;' +
        '&lt;li&gt;&lt;a href="#"&gt;Our Company&lt;/a&gt;&lt;/li&gt;' +
        '&lt;li&gt;&lt;a href="#"&gt;Pricing&lt;/a&gt;&lt;/li&gt;' +
        '&lt;li&gt;&lt;a href="#"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;' + '&lt;/ul&gt;' + '&lt;/nav&gt;'
};</pre></div><p>As you<a id="id176" class="indexterm"/> can see, we have defined an object literal which at this time only contains one property, <code class="literal">sectionHTML</code>.</p><p>This property holds a string that is the string representation of the HTML elements for the header fragment of the page.</p><p>Keep in mind that, as implemented, we currently have a global variable called <code class="literal">headerContainerDef</code> for our object definition. As you know, we should try to avoid using global variables in our code. We will be fixing this issue soon, but at this time it is done so on purpose.</p><p>Now that we have created our first object definition, it is time to create the first view of our application for the Header fragment.</p></div><div class="section" title="Generating the Header fragment dynamically"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec15"/>Generating the Header fragment dynamically</h3></div></div></div><p>As you<a id="id177" class="indexterm"/> saw previously, our application's controller has a module that specializes in generating page fragments on the page and it is called <code class="literal">PageUpdater</code>.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">PageUpdater.updateElement("headerContainer", headerContainerDef.sectionHTML);</pre></div><p>As you can see, we have used our application's <code class="literal">PageUpdater</code> module and have passed the id of the Header fragment as the first parameter to its <code class="literal">updateElement</code> method. The second parameter to this method is the object definition for the Header fragment. This implementation allows us to leverage the functionality of our application's controller to render the Header fragment.</p><p>Of course, we can use the same approach to create other parts (fragments) of our page, such as the footer, as follows:</p><div class="informalexample"><pre class="programlisting">PageUpdater.updateElement("footerContainer", footerContainerDef.sectionHTML)</pre></div><p>The following screenshot shows how the <code class="literal">index.html</code> page for our application is displayed when<a id="id178" class="indexterm"/> the page fragments have been rendered on the page:</p><div class="mediaobject"><img src="graphics/B04910_04_04.jpg" alt="Generating the Header fragment dynamically"/></div><p>The main content area of the page (colored red in the middle of the page), is the area that will be updated as the user navigates through the pages in our application. The header and footer of the page will not be re-rendered for any of the application's pages, as our application is built on SPA principles.</p><p>As you can see, I have used some interesting background colors to depict each fragment of the page. I like to call this color-coding of the page fragments.</p><p>The reason for this coloring schema is to easily distinguish each specific region of the page in our visual design. When we are finished with our application implementation, this page will look a lot better, but for now, this is a good starting point.</p><p>Of course, if you are reading this book in a black and white medium, you only see light and dark shades in the preceding image.</p></div><div class="section" title="Generating client application's view dynamically"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec16"/>Generating client application's view dynamically</h3></div></div></div><p>One<a id="id179" class="indexterm"/> of the techniques that I use in my applications<a id="id180" class="indexterm"/> is what I call <span class="strong"><strong>Dynamic Page Generation</strong></span> (<span class="strong"><strong>DPG</strong></span>).</p><p>The idea is that each main fragment of the page is associated with an object definition, and in this object definition the characteristics of the page fragment are defined. For instance, in our design for this application, I have considered three distinct fragments on the page: the header fragment, the content fragment, and the footer fragment.</p><p>Each <a id="id181" class="indexterm"/>main fragment, in turn, could further be divided into sub-fragments and each sub-fragment may or may not have its own distinct object definition.</p><p>On the other hand, we could have only one object definition for the entire page, which would be used to dynamically generate the page as a whole.</p><p>Generally speaking, the decision on how to associate an object definition to a page fragment or a sub-fragment is in the hands of the user interface developer. The developer makes these decisions by considering factors such as the frequency at which a fragment or sub-fragment needs to be updated, or whether a page fragment needs to be updated independently of other fragments of the page. Of course, performance also plays a major role in such decisions.</p><p>There are also instances when building certain page fragments on the server side is more robust than building them on the client.</p><p>In our application, we are building all the page fragments on the client dynamically. This is so we can explore the full functionality of our modules and components on the client side.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>
<span class="strong"><strong>The look and feel of our application</strong></span>
</p><p>Please note that the aim of this application is to help you understand the concepts of modular design as it relates to JavaScript applications, and as such the focus has not been on the look and feel.</p><p>While we will improve the appearance of the application as we move forward, I'm sure you can improve its appearance quite a bit further on your own. Our application is somewhat responsive based on the browser's view-port but can certainly use more CSS polishing to make it fully responsive.</p><p>However, I do <a id="id182" class="indexterm"/>consider this application as a <span class="strong"><strong>Minimum Viable Product</strong></span> (<span class="strong"><strong>MVP</strong></span>) for our purposes. Please feel free to download the code from the site that accompanies this book and improve it as you desire. Also, I have only tested this application in Chrome 46.0, but a production-quality application needs to be tested in a variety of different browser types and versions.</p></div></div></div></div><div class="section" title="Application model"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Application model</h2></div></div></div><p>The <a id="id183" class="indexterm"/>last main piece of our MV* implantation is the model. The<a id="id184" class="indexterm"/> main role of this piece is to store application-level data. In a client application, such data can be stored in cache, in cookies, or in local or session storage.</p><p>In the main application for this book, we will be using most of such mechanisms to store our application's data. Also, as a general point, depending on the implementation of the MV* architecture, changes in the model's data can trigger changes in the application's view.</p><p>It is very important to shield application-level data from accidental overwrites and modifications. In our implementation, we are going to use the module pattern once again to create a module which will act as our application's model and will provide a good level of protection for the stored data.</p><div class="section" title="Creating a module for our application's model"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Creating a module for our application's model</h3></div></div></div><p>Consider <a id="id185" class="indexterm"/>the following implementation:</p><div class="informalexample"><pre class="programlisting">var GlobalData = (function(){

    var headerContainerDef = {

    sectionHTML :  '&lt;div class="logo_titleClass" &gt;' +
         '&lt;a href=""&gt;&lt;img src="img/ImagesIncLogo.png" alt="Company Logo" style="max-height:100%;"&gt;&lt;/a&gt;' +
                '&lt;div class="siteTitleClass"&gt;Images inc.&lt;/div&gt;' +
        '&lt;/div&gt;' +
        '&lt;nav role="navigation" itemscope itemtype="https://schema.org/SiteNavigationElement"&gt;' +
            '&lt;h1 class="hiddenClass"&gt;Main Navigation&lt;/h1&gt;' +
            '&lt;ul class="navmenuClass" &gt;' +
                '&lt;li&gt;&lt;a href="#" class="active"&gt;Home&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li&gt;&lt;a href="#"&gt;Our Company&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li&gt;&lt;a href="#"&gt;Pricing&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li&gt;&lt;a href="#"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;' +
            '&lt;/ul&gt;' +
        '&lt;/nav&gt;' 
    };
    
    var footerContainerDef = {

        sectionHTML:'&lt;div&gt;' +
                   '&lt;a href="#"&gt;Latest News&lt;/a&gt;' +
                '&lt;/div&gt;' +
                '&lt;div&gt;' +
                    '&lt;a href="#"&gt;Services&lt;/a&gt;' +
                '&lt;/div&gt;' +
                '&lt;div&gt;' +
                    '&lt;a href="#"&gt;Support&lt;/a&gt;' +
                '&lt;/div&gt;'
    };
    
    return {
        
            getHeaderHTMLTxt: function(){
                return headerContainerDef.sectionHTML;
            },
        
            getFooterHTMLTxt: function(){
                return footerContainerDef.sectionHTML;
            }
    };
})();</pre></div><p>As you can see, we have created a <code class="literal">GlobalData</code> module to keep our application-level data.</p><p>I'm sure <a id="id186" class="indexterm"/>you are pretty familiar with how the mechanism works by now. We have created an IIFE to return an object as an interface to our private namespace(module). This object provides two methods: <code class="literal">getHeaderHTMLTxt</code> and <code class="literal">getFooterHTMLTxt</code>.</p><p>These methods return the property values of two private variables <code class="literal">headerContainerDef</code> and <code class="literal">footerContainerDef</code> respectively.</p><p>Note that we have not provided any methods to set the values for these variables, and since they are private variables in our module, we have created a degree of encapsulation. Thus, shielding our data from outside influence.</p><p>The property value of <code class="literal">headerContainerDef</code> is a string representation of the HTML elements in the header fragment.</p><p>This string is used to populate the Header fragment of our application's view, as shown:</p><div class="informalexample"><pre class="programlisting">PageUpdater.updateElement("headerContainer", GlobalData.getHeaderHTMLTxt());</pre></div><p>Just the same, the property value of <code class="literal">footerContainerDef</code> is a string representation of the HTML elements in the Footer fragment.</p><p>This string is used to populate the footer fragment of our application's view, as shown:</p><div class="informalexample"><pre class="programlisting">PageUpdater.updateElement("footerContainer", GlobalData.getFooterHTMLTxt());</pre></div><p>Note that when we rendered our header and footer fragments previously, we used global variables (such as <code class="literal">headerContainerDef</code>) to get the required strings for the page fragments.</p><p>However, in <a id="id187" class="indexterm"/>our new implementation, we access these strings using the <code class="literal">GlobalData</code> interface methods.</p><p>An important point to keep in mind here is that we have implemented two independent modules (<code class="literal">PageUpdater</code> and <code class="literal">GlobalData</code>) that work together to create the building blocks of our application. We will leverage the collaboration among our application modules further as we advance through the next chapters, and will implement the full functionality of our application on such basis.</p><p>Also, notice that our <code class="literal">GlobalData</code> module is only tasked with providing data to other pieces of the application, and <code class="literal">PageUpdater</code> is only responsible for updating fragments of the page.</p><p>Another subtle point to consider is the fact that we can change the internals of both modules as we desire. But as long as the interfaces of the modules don't change, they can still continue working together without the internal changes of one module having any effect on the functionality of the other.</p></div></div><div class="section" title="Creating a logging module"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Creating a logging module</h2></div></div></div><p>As a <a id="id188" class="indexterm"/>further exercise, we are going to create one more module in this chapter. This module will look after all the necessary work related to logging messages for our application.</p><p>The question is, which main application piece does this module belong to?</p><p>To answer this question, we need to do a simple analysis. First, since this module does not have any views associated with it, we need to consider it as a functional module and not a component.</p><p>Second, this module does not store any application data for us. Therefore, this module should belong to the controller piece of our application. As mentioned before, since we consider the controller piece of our application to be the same as the core module, the logging module should belong to the core module.</p><p>Remember that the core module consists of many smaller modules (sub-modules) that build the core together.</p><p>Let's create our simple logger module as follows:</p><div class="informalexample"><pre class="programlisting">var LoggingHandler = (function(){
    
    // module private variables
    var defaultHelloMsg = "this is just to say Hello to the users!",
    theInterface ={};
    
    // privileged method 
    theInterface.logError = function(errorMsg){
        console.error(errorMsg);
    };
    // privileged method 
    theInterface.logInfo = function(infoMsg){
        
        if(!infoMsg){
            infoMsg = defaultHelloMsg;
        }
        console.log(infoMsg);
    };
    
    return theInterface;
    
})();</pre></div><p>This module definition structure is pretty much the same as other module definitions that we have seen so far, but with minor differences.</p><p>We have used a different technique here and have returned a named object instead of an anonymous object from our IIFE. We have named this object <code class="literal">theInterface</code>. Initially, this object is an empty object but then we augment this empty object with two method properties. One of them logs information messages and the other logs error messages to the console.</p><p>In the case that no information message is passed to <code class="literal">theInterface.logInfo</code> method, a default message is logged to greet the user.</p><p>Here is how we call the methods on the interface of this module:</p><div class="informalexample"><pre class="programlisting">LoggingHandler.logError("this is a test for logging errors!")
LoggingHandler.logInfo();</pre></div><p>This is the same way that we call interface methods when we return an anonymous object from a module.</p><p>I have<a id="id189" class="indexterm"/> used this technique of returning a named object from a module here to show you we don't always have to return an anonymous object from an IIFE to create a module interface,  and that there are different ways of implementing the module pattern. We will explore these techniques further in future chapters of the book.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Practical usage of our modules</strong></span>
</p><p>As I like to present the concepts along with their practical aspects,  I recommend that you download the accompanying code for this chapter. Have a look at the simple modules in action, and play around with the code as much as you can. This will help you become more familiar with the concepts and solidify them in your mind. My recommendation applies to this chapter as well as all the other chapters of the book.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we moved from the conceptual design of modules to the practical aspects of implementing them. We started by looking at the high-level requirements of our intended application, and then considered the kind of modules that we might possibly need to fulfill those requirements.</p><p>We briefly discussed the MV* design pattern and structured our application to follow this pattern. Then, based on the functionality and the role that our modules play in our design, we categorized them to be part of the controller, view or model pieces of our application.</p><p>The view for our application was generated by first creating an <code class="literal">index.html</code> page skeleton and then populating its main fragments based on object definitions, using a core module.</p><p>We also created a safe global data repository for our application to act as the model piece of our architecture.</p><p>An example of how modules can collaborate together to complete tasks and provide application level functionality was also presented.</p><p>In the next chapter we will extend our application modules and work further on the building blocks of our application in a modular design approach.</p></div></body></html>