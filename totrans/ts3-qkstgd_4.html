<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Transforming Your Code into Object-Oriented</h1>
                </header>
            
            <article>
                
<p>Object-oriented has its own set of jargon, and TypeScript relies on much of it. In this chapter, all the concepts of object-oriented that TypeScript supports are discussed with examples. We will see what a class is and how to instantiate a class into an object. We will also see how a constructor can be strongly typed with TypeScript, and how, with a shorthand syntax, we can assign a class's fields directly from the constructor. We will cover the principle of encapsulation with visibility, how to implement an interface, and how to bring abstraction to a class.</p>
<p><span>In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="h1">What is a class and how do we define one?</li>
<li class="h1">How type comes into play with a class's constructor</li>
<li class="h1">What is encapsulation using <kbd>public</kbd>, <kbd>private</kbd>, and <kbd>protected</kbd></li>
<li class="h1">Reducing the definition of a field with a value set at construction time</li>
<li class="h1">What is static?</li>
<li class="h1">Use cases for a non-public constructor</li>
<li class="h1">Using an object from a class versus an object literal</li>
<li class="h1">How an interface can be useful in object-oriented</li>
<li class="h1"><span>Bringing</span> abstraction with an abstract class</li>
<li class="h1">How to have a property that is read-only</li>
<li class="h1">Enforcing a specific constructor from an interface</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a class and how do we define one?</h1>
                </header>
            
            <article>
                
<p>At the core of object-oriented is the class. A class is a definition of what is available for an object once instantiated. A class holds variables and functions that were judged cohesive by the developer. A class can share information across all instances of the same class or have its own data, which is unique from the beginning of the life of the object until its death.</p>
<p>The creation of a class starts with the keyword <kbd>class</kbd> followed by the name of the class. It is similar to the creation of an interface:</p>
<pre>export class MyClass {<br/>}</pre>
<p>A class can define variables and functions. Each of them is <kbd>public</kbd> by default, meaning that they are accessible from outside the class by the name of the instance:</p>
<pre>export class Variables {<br/> public a: number = 1;<br/>  private b: number = 2;<br/>  protected c: number = 3;<br/>  d: number = 4; // Also public<br/>}</pre>
<p>Once a class is defined, it can be instantiated. An instantiation means that a class becomes concrete and the life cycle for its content starts. To create an instance of a class, the <kbd>new</kbd> keyword must be used. After <kbd>new</kbd> comes the name of the class with parentheses:</p>
<pre>const d = new Variables();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How type comes into play with a class's constructor</h1>
                </header>
            
            <article>
                
<p>The instantiation of a class calls the constructor of the class. If this one is not defined, nothing is called. When no constructor is defined, the parentheses do not have any argument. <span>The constructor's goal is to provide initialization of data to the class:</span></p>
<pre>const d = new Variables();</pre>
<p>In the case where the parameters are defined, the initialization must provide all the non-optional parameters. In the following code, the instantiation calls the constructor that has two parameters:</p>
<pre>class MyClass {<br/>   constructor(param1: number, param2: string) {<br/>   }<br/>}<br/>const myClassInstance = new MyClass(1, "Must be present");</pre>
<p>A constructor is similar to a function but cannot have an override. There is only a single constructor that can be defined. By default, it is <kbd>public</kbd> if no visibility is provided:</p>
<pre>class MyClass {<br/>   private m1: number;<br/>   private m2: string;<br/>   private m3: number;<br/>   constructor(param1: number, param2: string) {<br/>     this.m1 = param1;<br/>     this.m2 = param2;<br/>     this.m3 = 123;<br/> }<br/>}</pre>
<p>However, a constructor can be overloaded by many signatures. Similar to a function, the use of many definitions is possible with the use of a semicolon. In the following example, you can see that it is possible to instantiate the class with a single number or with a number and a string:</p>
<pre><br/>class ClassWithConstructorOverloaded {<br/> private p1: number;<br/> private p2: string;<br/><br/> constructor(p1: number);<br/> constructor(p1: number, p2?: string) {<br/>   this.p1 = p1;<br/>   if (p2 === undefined) {<br/>     p2 = "default";<br/>   }<br/>   this.p2 = p2;<br/> }<br/>}</pre>
<p>If a class extends another class, it must call <kbd>super</kbd> with the parameter of the right type to the base class. The class that inherits the second class does not need to have the same number of constructor parameters, nor the same type. What is important is the call to <kbd>super</kbd> to respect the type of the extended class. In the following example, <kbd>MyClass</kbd> has a constructor that takes a number and a string. The class that extends <kbd>MyClass</kbd>, <kbd>MyClass2</kbd>, must call <kbd>super</kbd> with a number and a string. The example illustrates that the value can come from the constructor of the class or can be computed directly:</p>
<pre>class MyClass2 extends MyClass {<br/>   constructor(p1: number) {<br/>     super(p1, "Here");<br/>   }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is encapsulation using public, private, and protected</h1>
                </header>
            
            <article>
                
<p>The use of <kbd>var</kbd>, <kbd>let</kbd>, and <kbd>const</kbd> is not available at a class level. Class declares by using the <kbd>public</kbd>, <kbd>private</kbd>, and <kbd>protected</kbd> encapsulation visibility keywords. The scope is conscribed to the class with some minor difference between the three.</p>
<p>A class variable with the <kbd>public</kbd> keyword declaration allows the variable to be available inside and outside the class. The <kbd>public</kbd> modifier brings the instance of the class to allow it to read and write the value outside the class:</p>
<pre>export class Variables {<br/>   public a: number = 1;<br/>}<br/>const d = new Variables();<br/>d.a = 100;<br/>console.log(d.a);</pre>
<p>On the other hand, the <kbd>private</kbd> declaration restrains the access to the class itself. This is true for reading and writing:</p>
<pre>export class Variables {<br/>   private b: number = 2;<br/>}<br/>const d = new Variables();<br/>d.b = 100; // Not allowed, won’t compile<br/>console.log(d.b); // Not allowed, won’t compile</pre>
<p>Finally, a <kbd>protected</kbd> encapsulation is similar to <kbd>private</kbd> but it allows us to read and to write the value of the <kbd>protected</kbd> variable outside the class itself. However, the access is restricted to the class that declares the <kbd>protected</kbd> and the class that extends this one. A <kbd>protected</kbd> variable or function shares access down the hierarchy of classes. That means that all classes that inherit a class with <kbd>protected</kbd> members have access to the <kbd>protected</kbd> member:</p>
<pre>class BaseClass {<br/>  public a: number = 1;<br/>  private b: number = 2;<br/>  protected c: number = 3;<br/>}<br/><br/>class ChildClass extends BaseClass {<br/>  public d: number = 1;<br/>  private e: number = 2;<br/>  protected f: number = 3;<br/>  public f1():void{<br/>   super.a;<br/>   super.c;<br/>   this.a;<br/>   this.c;<br/> }<br/>}<br/><br/>const child = new ChildClass();<br/>console.log(child.a);<br/>console.log(child.d);</pre>
<p>In the example, the child class has access to the base class members that are <kbd>public</kbd> and <kbd>protected</kbd>. Once the child class is instantiated, only <kbd>public</kbd> variables are available. Private members are only available in the class where they are defined. This is true for variables and functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing the definition of a field with a value set at construction time</h1>
                </header>
            
            <article>
                
<p>It can be cumbersome to always set values from the constructor to a field. A possibility is to assign the field directly from the constructor signature into the class:</p>
<pre>class MyClass3{<br/> public constructor(private p1:number, public p2:string){}<br/>}<br/>const myClass3 = new MyClass3(1, "2");<br/>console.log(myClass3.p2);</pre>
<p>By setting the visibility of the encapsulation of each parameter of the constructor, a member is created with the same type. In the preceding example, two fields are created for the class with the name and the type of the parameter. The following code is exactly the same as the previous example, which is heavier in terms of definition and assignation:</p>
<pre>class MyClass3Same {<br/>  private p1: number;<br/>  public p2: string;<br/>  public constructor(p1: number, p2: string) {<br/>   this.p1 = p1;<br/>   this.p2 = p2;<br/> }<br/>}<br/><br/>const myClass3Same = new MyClass3Same (1, "2");<br/>console.log(myClass3.p2);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is static?</h1>
                </header>
            
            <article>
                
<p>A static member is a member that can be accessed without instantiating the class. Everything that is static is shared across all instances for the life of your system. Static variables and functions are associated with the class, not an instance of the class or a particular object. If you are coming from JavaScript, you can see static as being a member associated with the prototype chain instance of the instance.</p>
<p>Contrary to many other languages, TypeScript does not allow us to have a static class. It does not remove much, because if you need to have a static class, you just need to have the function directly inside the module instead of being in a class. If you want to have all your static classes inside a class and prevent the consumer of your library from instantiating the class, you can mark the class as abstract. An abstract class cannot be instantiated without being extended:</p>
<pre>abstract class FakeStaticClass {<br/> public static m1: number;<br/> public static f1(): void { }<br/>}<br/><br/>console.log(FakeStaticClass.m1);<br/>FakeStaticClass.f1();<br/><br/>const instance1 = new FakeStaticClass(); // Doesn't compile</pre>
<p>Static members can be from all encapsulation visibilities: <kbd>public</kbd>, <kbd>protected</kbd>, or <kbd>private</kbd>. However, only <kbd>public</kbd> visibility is accessible from outside the class. The <kbd>private</kbd> and <kbd>protected</kbd> are available within the class that defines the status members. A protected member can be accessed from a class that extends another class with static members:</p>
<pre>class StaticClass {<br/>  public static ps: number;<br/>  private static privateStatic: number;<br/>  protected static protecStatic: number;<br/>}<br/><br/>StaticClass.ps = 1;</pre>
<p>Only <kbd>public static</kbd> members are accessible from outside the class. The <kbd>private</kbd> and <kbd>protected</kbd> are accessible within the class. To use any static members, the name of the class must be specified before the use of the member. This rule is also needed when inside the class. The <kbd>this</kbd> pointer is only available within an instance, and since static is not part of any instance but part of <kbd>class</kbd>, it cannot be reached with the instance's <kbd>this</kbd> pointer:</p>
<pre>class StaticClass {<br/>  public static ps: number;<br/>  private static privateStatic: number;<br/>  protected static protecStatic: number;<br/><br/>  public nonStaticFunction():void{<br/>    StaticClass.ps;<br/>    StaticClass.privateStatic;<br/>    StaticClass.protecStatic;<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use cases for a non-public constructor</h1>
                </header>
            
            <article>
                
<p>A <kbd>private</kbd> constructor revokes the possibility to instantiate the class from the outside. The following code does not compile because the constructor is <kbd>private</kbd>. The same would also be true if the constructor were <kbd>protected</kbd>:</p>
<pre>class PrivateConstructor{<br/> private constructor(){<br/> }<br/>}<br/><br/>const pc = new PrivateConstructor(); // Does not compile</pre>
<p class="mce-root">In that case, the only way to instantiate the class is by using a <kbd>public static</kbd> function that <span>creates the object of the type </span>class and returns it. In the following code, the <kbd>private</kbd> constructor creates an instance; to access this instance, <kbd>GetInstance</kbd> is used, which is static and does not need to have an instance to be called:</p>
<pre>class SingletonClass {<br/> private static instance: SingletonClass;<br/> private constructor() {<br/> SingletonClass.instance = new SingletonClass();<br/> }<br/><br/> public static GetInstance(): SingletonClass {<br/>   return SingletonClass.instance;<br/> }<br/>}<br/>const singletonClass = SingletonClass.GetInstance();</pre>
<p class="mce-root"><span>A known pattern is to have a <kbd>SingletonClass</kbd>. Only a single instance of the class exists and this control can be managed by having a single function that uses <kbd>new</kbd> once and then always returns the same instance. Another use case is to have a factory that creates all the instances.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using an object from a class versus an object literal</h1>
                </header>
            
            <article>
                
<p>An object literal is quick to build and does not need to have the data passed down a constructor or <kbd>public</kbd> members to fill an object. An object literal is an efficient way to move data around. You can read a JSON file, receive the data from an Ajax call or from many sources, and cast to the desired type:</p>
<pre>ajax.then((response:any)=&gt;{<br/>   return response as DataTyped;<br/>};</pre>
<p>However, if you have many functions or more complex logic that needs to be encapsulated, a class is more pragmatic. The reason is that using an object literal would require assigning the function on each instance manually. Also, a class can contain a <kbd>private</kbd> function that you may not want to expose, provide encapsulation with <kbd>private</kbd>/<kbd>protected</kbd> and interfaces. An object literal's fields are <kbd>public</kbd> and accessible. In the following example, we see data returned from an Ajax call. The expected type is <kbd>ObjectDefinition</kbd>, which has a function. The function doesn't come for free like with a class during the initialization. Hence, it must be attached to the object. In that case, we need to refer to a variable that has a function. This can be tedious with complex definitions:</p>
<pre>interface ObjectDefinition {<br/>  m1: string;<br/>  funct1: () =&gt; void;<br/>}<br/><br/>let ajax: any;<br/>const funct1 = () =&gt; { };<br/><br/>ajax.then((response: any) =&gt; {<br/>  const r = response as ObjectDefinition;<br/>  r.funct1 = funct1;<br/>  return r;<br/>});</pre>
<p>It is possible to reduce the burden of the previous example by having a <kbd>function</kbd> that builds each object literal by attaching the functions. In that case, the <kbd>function</kbd> returns the type of the object literal. This <kbd>function</kbd> acts as a constructor:</p>
<pre>function createObj(m1: string): ObjectDefinitionClass {<br/>  return {<br/>   m1: m1,<br/>   funct1: () =&gt; { }<br/>  }<br/>}<br/><br/>ajax.then((response: any) =&gt; {<br/> const r = response as Model;<br/> return createObj(r.m1);<br/>});</pre>
<p>The same code with a class looks like the following code:</p>
<pre>class ObjectDefinitionClass implements ObjectDefinition {<br/> public m1: string;<br/> public funct1(): void { }<br/><br/> constructor(param1: string) {<br/>  this.m1 = param1;<br/> }<br/>}<br/><br/>ajax.then((response: any) =&gt; {<br/> const r = response as ObjectDefinition;<br/> return new ObjectDefinitionClass(r.m1);<br/>});</pre>
<p>In that particular case, what can be interesting is to divide the fields from the functions and pass all the fields by an interface in the constructor. Here is a third version using an interface for the variables and the functions:</p>
<pre>interface Model {<br/> m1: string;<br/>}<br/><br/>interface Funct {<br/> funct1: () =&gt; void;<br/>}<br/><br/>class ObjectDefinitionClass2 implements Model, Funct {<br/> public m1: string;<br/> public funct1(): void { }<br/> constructor(param1: Model) {<br/>   this.m1 = param1.m1;<br/> }<br/>}<br/><br/>ajax.then((response: any) =&gt; {<br/> const r = response as Model;<br/> return new ObjectDefinitionClass2(r);<br/>});</pre>
<p>In terms of testability, a class has the advantage of allowing any of the members to be stubbed easily. Here is a simple example with the Jest library:</p>
<pre>const forTesting = new ObjectDefinitionClass("1");<br/>forTesting.funct1 = jest.fn();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How an interface can be useful in object-oriented</h1>
                </header>
            
            <article>
                
<p>An interface serves many roles. We saw that you can define a contract for particular objects with an interface. However, interfaces can do much more.</p>
<p>An interface defines which members you want the consumer of your library to see and use. The <kbd>public</kbd>, <kbd>private</kbd>, and <kbd>protected</kbd> visibility keywords serve the same purpose. However, in some cases, you may need to have <kbd>public</kbd> members and still not allow everyone to use them. One reason can be that you want to have deep access to unit testing, hence having most of your members <kbd>public</kbd> allows you to black boxing functions testing. However, it might expose too much. Therefore, an interface can define every member that is accessible and be implemented by a class. Instead of passing the reference to the class directly, the interface is distributed externally while you can use the class internally:</p>
<pre>class ClassA {<br/> public mainFunction(): void <br/>{<br/>  this.subFunction1();<br/>  this.subFunction2();<br/> }<br/><br/> private subFunction1(): void { }<br/> private subFunction2(): void { }<br/>}</pre>
<p>The class has two <kbd>private</kbd> functions that are executed by the main function, named <kbd>mainFunction</kbd>. However, the encapsulation does not allow us to unit test the <kbd>private</kbd> function without using some hack to access these functions. We want to avoid casting the main object to any to access the function because, if these functions change, the test might fail not because of wrong logic but because TypeScript was not able to refactor the function since the type was coerced to any. A better practice is to use an interface to keep the type present at all times:</p>
<pre>interface IClassA {<br/> mainFunction(): void;<br/>}<br/><br/>class ClassA2 implements IClassA {<br/> public mainFunction(): void {<br/>   this.subFunction1();<br/>   this.subFunction2();<br/> }<br/><br/> public subFunction1(): void { }<br/> public subFunction2(): void { }<br/>}</pre>
<p>Everything is <kbd>public</kbd>, however, all the system is using <kbd>IClassA</kbd> instead of the class directly providing the encapsulation desired. The unit test can use the class and access the original <kbd>private</kbd> function.</p>
<p>A second case where the interface shines is that it allows us to have many concrete implementations of a specific type. You can define an interface that will be consumed by a function and has many implementations of this one. In the following example, we have a <kbd>consume</kbd> function that takes <kbd>IElement</kbd> as input. There are two concrete implementations of <kbd>IElement</kbd>, which gives the code the flexibility to have many element implementations. This help to reduce customized code in the consuming function by having a type that represents the minimum set of members needed to perform the task:</p>
<pre>interface IElement {<br/> m1: string;<br/>}<br/><br/>class E1 implements IElement { m1: string = "E1-&gt;m1"; a: number = 1; }<br/>class E2 implements IElement { m1: string = "E2-&gt;m1"; b: boolean = true; }<br/><br/>class ClassB {<br/> public consume(element: IElement): void { }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bringing abstraction with an abstract class</h1>
                </header>
            
            <article>
                
<p>Abstraction is an object-oriented concept that allows us to have a base class that delegates the implementation of a function to the class that extends the <kbd>abstract</kbd> class.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following example creates the main class by instantiating the custom logic class. It invokes the main function, which will execute the <kbd>abstract</kbd> function. To the <kbd>MainClass</kbd> class, the <kbd>abstract</kbd> function is a black box. It only knows its name, parameter types, and returns types. The example executes the commented block code A-C-B in that particular order:</p>
<pre>abstract class MainClass {<br/> public mainCoreLogic(): void {<br/>   // Code here [A]<br/>   this.delegatedLogic();<br/>   // Code here [B]<br/> }<br/><br/> public abstract delegatedLogic(): void;<br/><br/>}<br/><br/><br/>class CustomLogic extends MainClass {<br/><br/> public delegatedLogic(): void {<br/>   // Do some custom logic here [C]<br/> }<br/><br/>}<br/><br/>const c: MainClass = new CustomLogic();<br/>c.mainCoreLogic();</pre>
<p>The <kbd>abstract</kbd> is powerful when you pass a computed value to the <kbd>abstract</kbd> class and that this one also returns a result of a custom computation. Here is a second version that shows how two different implementations can occur while the main class remains unchanged. The main class is now named <kbd>Calculus</kbd> and has a <kbd>public</kbd> function that takes two numbers and returns a <kbd>Boolean</kbd>. It does some operations on the parameters and calls the delegated logic. The treatment of the value is unknown to the main class. The significant part of the operation is the result that is then used. On the side of the class that consumes the <kbd>abstract</kbd> class by extending the class. It has to provide all abstract functions or fields. Every <kbd>abstract</kbd> member becomes a <kbd>public</kbd> field at the extended level. In the example, the logic multiplies the two values that return the specified type:</p>
<pre>abstract class Calculus {<br/> public isAboveZero(a: number, b: number): boolean {<br/>   const positiveA = Math.abs(a);<br/>   const positiveB = Math.abs(b);<br/>   const result = this.delegatedLogic(positiveA, positiveB);<br/>   return result &gt; 0;<br/> }<br/><br/> public abstract delegatedLogic(a: number, b: number): number;<br/> }<br/><br/> class AddLogic extends Calculus {<br/>   public delegatedLogic(a: number, b: number): number {<br/>     return a * b;<br/>   }<br/> }<br/><br/> const multi: Calculus = new AddLogic();<br/> multi.isAboveZero(1, 2);</pre>
<p>The code could have been written in a non-object-oriented way by providing by parameter the logic to execute. Here is the same version of the code without an <kbd>abstract</kbd>:</p>
<pre> class CalculusWithoutAbstract {<br/>   public constructor(private delegatedLogic: (a: number, b: number) =&gt; number) {<br/>   }<br/><br/>   public isAboveZero(a: number, b: number): boolean {<br/>     const positiveA = Math.abs(a);<br/>     const positiveB = Math.abs(b);<br/>     const result = this.delegatedLogic(positiveA, positiveB);<br/>     return result &gt; 0;<br/>   }<br/>}<br/><br/>const multi2: CalculusWithoutAbstract = new CalculusWithoutAbstract((a, b) =&gt; a * b);<br/>multi2.isAboveZero(1, 2);</pre>
<p>The version without an <kbd>abstract</kbd> takes in the constructor of the class the function to be called instead of the abstract function. The substitution between the two is a matter of preference. The main difference between the two is that using abstract force the <kbd>abstract</kbd> implementation to be public when the delegate function can remain <kbd>private</kbd>. However, the way to work around the visibility issue is to initialize with the base class instead of the child class:</p>
<pre>const multi: Calculus = new AddLogic(); // Expose only the main function<br/>const multi: AddLogic = new AddLogic(); // Expose the delegate function</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to have a property that is read-only</h1>
                </header>
            
            <article>
                
<p>Read-only fields can be initialized once and don't need to be changed during the lifetime of the instance. The <kbd>readonly</kbd> keyword can be used in an interface to specify that once the field is set, the value doesn't change:</p>
<pre>interface I1 {<br/> readonly id: string;<br/> name: string;<br/>}<br/><br/>let i1: I1 = {<br/> id: "1",<br/> name: "test"<br/>}<br/><br/>i1.id = "123"; // Does not compile</pre>
<p>It can be at the class level where the value can be only set directly at the declaration or in the constructor. When a value is initialized next to the field's declaration, this one can still be redefined by the constructor. The following example shows this edge case. However, it is possible to only set it at declaration or just at the <kbd>constructor</kbd> level, which is often the case:</p>
<pre>class C1 {<br/> public readonly id: string = "C1";<br/><br/> constructor() {<br/>   this.id = "Still can change";<br/> }<br/><br/> public f1(): void {<br/>   this.id = 1; // Doesn't compile<br/> }<br/>}</pre>
<p>Read-only with <kbd>static</kbd> can be useful to have constant for a particular class. The use of <kbd>const</kbd> is not allowed at a class level. If you want to centralize a value in the context of a particular class, the use of <kbd>public</kbd>, <kbd>static</kbd>, and <kbd>readonly</kbd> is an acceptable pattern:</p>
<pre>class C2 {<br/> public static readonly MY_CONST: string = "TEST";<br/> public codeHere(): void {<br/>   C2.MY_CONST;<br/> }<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enforcing a specific constructor from an interface</h1>
                </header>
            
            <article>
                
<p>This is tricky because you cannot enforce by an interface the shape of a constructor. However, you can use an interface to ensure a class passed by the parameter has a specific constructor. The process requires two interfaces. One is the return type of the construction, and one is the interface used in the parameter:</p>
<pre>interface ConstructorReturnType {    <br/>  member1: number;<br/>  funct(): void;<br/>}<br/>interface EntityConstructor {<br/>  new(value: number): ConstructorReturnType;<br/>}</pre>
<p>The first interface in this example has two members: one field and one function. The definition of the interface doesn't matter, it can be anything you want to get an instance of the function. The second interface has a constructor function, known as <em>newable</em>. It uses the <kbd>new</kbd> keyword with the input parameters and what it needs to create. The type should be the first interface created:</p>
<pre>function entityFactory(ctor: EntityConstructor, value: number): ConstructorReturnType {<br/>   return new ctor(value);<br/>}</pre>
<p>The next step is to create a function that takes the <kbd>newable</kbd> function and sets it as a parameter type. Optionally, you can have more parameters. In the example, a value for the constructor is passed. The return type of the function must be the type that the <kbd>newable</kbd> function returns. In this function, you can call <kbd>new</kbd> followed by the parameter of the interface that has the definition of the <kbd>newable</kbd> function. The code instantiates an instance of the class passed by the parameter. Only classes that respect the type contract of the <kbd>newable</kbd> function are accepted:</p>
<pre>class Implementation1 implements ConstructorReturnType {<br/><br/> public member1: number;<br/><br/> constructor(value: number) {<br/>   this.member1 = value;<br/> }<br/><br/> public funct(): void {<br/> }<br/><br/>}<br/>let impl1 = entityFactory(Implementation1, 1);</pre>
<p>In the preceding code, the <kbd>Implementation1</kbd> class implements the returned implementation, hence will be a candidate for this function. It also has the constructor that takes a single-number parameter that will be invoked by the function.</p>
<p>On the other hand, the following code does not compile because the class does not inherit the returned type defined by the <kbd>newable</kbd> function:</p>
<pre>class Implementation2 {<br/>   constructor(value: number) { }<br/>}<br/><br/>let impl2 = entityFactory(Implementation2, 1);</pre>
<p>An example that might not look valid but that compiles is the following code. It extends the returned class but does not respect the <kbd>newable</kbd> function argument that requires it to have a value. It is valid because the definition is only about the returned object and not the constructor. The constructor is called with a parameter, but the class doesn't have to handle it. In the following code, printing the <kbd>arguments</kbd> variable shows that it has the <kbd>1</kbd> value passed as the first parameter even if not explicitly required by the class:</p>
<pre>class Implementation3 implements ConstructorReturnType {<br/>  public member1: number = 1;<br/>  constructor() {<br/>    console.log(arguments);<br/>  }<br/><br/>  public funct(): void {<br/>  }<br/>}<br/><br/>let impl3 = entityFactory(Implementation3, 1);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we visited many object-oriented features. TypeScript is closing the gap with well-known programming languages that are object-oriented <span><span>such as</span></span> C# or Java. TypeScript, being a superset of JavaScript, must palliate some weakness of JavaScript in this regard but finish with its head-up with many features that are acceptable to write a professional application in an object-oriented fashion.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We saw how to work with encapsulation, which allows us to control the visibility of fields and functions. We discussed ways to strongly type a constructor, as well as how to use an interface to be implemented by a class. Within a class, we saw how to have static functions and abstraction functions. The next chapter will cover how we can identify precisely which type, object, or variable we are manipulating, allowing us to leverage specific members that are unique to each of them. We will see how to use JavaScript typecheckers, such as <kbd>typeof</kbd> and <kbd>instanceof</kbd>, and how to pattern with discriminator and defined guard for a structured type.</p>


            </article>

            
        </section>
    </body></html>