- en: Chapter 10. Highcharts APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Highcharts offers a small set of APIs designed for plotting charts with dynamic
    interactions. In order to understand how the APIs work, we must first familiarize
    ourselves with the chart''s internal objects and how they are organized inside
    a chart. In this chapter, we will learn about the chart class model and how to
    call the APIs by referencing the objects. Then we build a simple stock price application
    with PHP, jQuery, and jQuery UI to demonstrate the use of Highcharts APIs. After
    that, we turn our attention to four different ways of updating a series. We experiment
    with all the series update methods with the purpose of building an application
    to illustrate variations in visual effects, and the difference in CPU performance
    between them. Finally, we investigate performance when updating a series with
    popular web browsers, in terms of different sizes of datasets. In this chapter,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Highcharts class model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data in Ajax and displaying new series with `Chart.addSeries`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying multiple series with simultaneous Ajax calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Chart.getSVG` to format SVG data into an image file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Chart.renderer` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring different methods to update series and their performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting with Highcharts performance with large datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Highcharts class model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relationship between Highcharts classes is very simple and obvious. A chart
    is composed of five different classes—`Chart`, `Axis`, `Series`, `Point`, and
    `Renderer`. Some of these classes contain an array of lower-level components and
    an object property to back-reference to a higher level-owner component. For example,
    the `Point` class has the `series` property pointing back to the owner `Series`
    class. Each class also has a set of methods for managing and displaying its own
    layer. In this chapter, we will focus on the set of APIs for dynamically modifying
    charts. The following class diagram describes the association between these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Highcharts class model](img/7451OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Chart` class is the top level class representing the whole chart object.
    It contains method calls to operate the chart as a whole—for example, exporting
    the chart into SVG or other image formats and setting the dimension of the chart.
    The `Chart` class has multiple arrays of `Axis` and `Series` objects; that is,
    a chart can have one or more *x* axes, *y* axes, and series. The `Renderer` class
    is a utility class that has a one-to-one relationship per chart and provides a
    common interface for drawing in SVG and VML-based browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Series` class has an array of `Point` objects. The class has back-reference
    properties towards the `Chart` and `Axis` objects (see the dotted lines in the
    previous diagram) and provides functions for managing its list of `Point` objects.
    The `yAxis` and `xAxis` properties in the `Series` class are necessary, as a chart
    can have multiple axes.
  prefs: []
  type: TYPE_NORMAL
- en: The `Point` class is just a simple object containing x and y values and a back-reference
    to its series object (see the dotted line). The APIs are for managing the data
    points in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Highcharts constructor – Highcharts.Chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Needless to say, the most important method in the APIs is the `Highcharts.Chart`
    method, with which we have seen plenty of action so far. However, there is more
    to this constructor call. `Highcarts.Chart` creates and returns a chart object
    but it also has a second optional parameter known as `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The callback function is called when a chart is created and rendered. Inside
    the function, we can either call the component methods or access the properties
    inside the chart object. The newly created chart object is passed via the only
    callback function parameter. We can also use the '`this`' keyword inside the callback
    function, which also refers to the chart object. Instead of using the `Highcharts.Chart`
    callback parameter, we can achieve the same result by declaring our code inside
    the `chart.events.load` handler, which will be explored in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through Highcharts components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use the Highcharts API, we must navigate to the right object inside
    the class hierarchy. There are several ways to traverse within the chart object:
    through the chart hierarchy model, retrieving the component directly with the
    `Chart.get` method, or a mixture of both.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the object hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that the chart object is created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access the first position of the series'' object with the index
    0 from the chart. Inside the callback handler, we use the `this` keyword to refer
    to the chart object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose there are two *y* axes in the configuration. To retrieve the second
    *y* axis, we can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the third data point object from the second series of the chart,
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Supposing multiple charts are created on the page, a chart object can be accessed
    via the Highcharts namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also retrieve the chart''s container element through the container option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To examine the options structure of a created chart, use the options property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the Chart.get method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of cascading down the object hierarchy, we can directly retrieve the
    component using the `Chart.get` method (the `get` method is only available at
    the chart level, not in each component class). Assigning components with IDs will
    allow you to access them directly using the `get` method instead of traversing
    nodes in the object's hierarchical structure. The configuration uses the option
    key `id`, so this value must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have created a chart with the following configuration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `id` option is not previously configured, we can use the JavaScript
    `filter` method to search for the item based on the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using both the object hierarchy and the Chart.get method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is cumbersome to define the `id` option for every component inside the chart.
    Alternatively, we can navigate through the components using both approaches, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the Highcharts APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build an example using jQuery, jQuery UI, and Highcharts
    to explore each component's APIs. All the example code from here on will be using
    the object hierarchy to access chart components, that is, `chart.series[0].data[0]`.
    The user interface used here has a very minimal look and is far from perfect,
    as the main purpose of this exercise is to examine the Highcharts APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see the usage of this user interface; then we will dissect the
    code to understand how the operations are performed. The following is the final
    UI screenshot that will be created in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Highcharts APIs](img/7451OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a simple web frontend for plotting the stock data chart for the past
    30 days. The top part is a group of buttons for setting the stock symbols, getting
    the stock price, and retrieving the chart image by downloading it or via e-mail.
    The **Add to the list** button is for adding a stock symbol straight to the list
    without getting the stock prices and plotting the data. The **Plot All** button
    is for launching multiple stock price queries from the symbol list simultaneously,
    and to plot the data when all the results arrive. Alternatively, **Add & Plot**
    is a quick option for plotting a single stock symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom half contains a chart that we have already created. The chart is
    displayed with empty data and axes with titles (setting the `showAxes` option
    to `true`). The whole idea is to reuse the existing chart rather than recreating
    a new chart object every time new results arrive. Therefore, there is no flickering
    effect when the chart is destroyed and created and it appears as a smooth update
    animation. This also provides better performance without running extra code to
    regenerate the chart object.
  prefs: []
  type: TYPE_NORMAL
- en: This example is also available online at [http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html](http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html).
  prefs: []
  type: TYPE_NORMAL
- en: Chart configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the chart configuration used for the example. Once a stock
    query is made, the server-side script will request the stock prices for the last
    30 days and format the results into days in units of milliseconds. Hence, the
    *x* axis is configured as a `datetime` type with intervals on a daily basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Getting data in Ajax and displaying a new series with Chart.addSeries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine the action behind the **Add & Plot** button, defined as the
    following HTML syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The jQuery code for the button action is listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code defines the event handler for the **Add & Plot** button''s
    click event. First, it empties all the entries in the stock symbol list box that
    have IDs as `stocklist`. Then, it retrieves the stock symbol value from the input
    field `symbol` and appends the symbol to the list. The next step is to initiate
    a loading message screen on the chart by calling the `chart.showLoading` method.
    The following screenshot shows the loading message screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting data in Ajax and displaying a new series with Chart.addSeries](img/7451OS_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next call is to launch a jQuery Ajax call, `$.getJSON`, to query the stock
    price. The `stockQuery.php` server script (of course, any other server-side language
    can be used) does two tasks: it resolves the symbol into the full name of the
    organization, launches the symbol query from another website ([http://ichart.finance.yahoo.com/table.csv?s=BATS.L](http://ichart.finance.yahoo.com/table.csv?s=BATS.L))
    for the past stock price data, then packs the data into rows and encodes them
    into JSON format. The following is the code in the `stockQuery.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result returned from the server side in the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the JSON result arrives, the data is passed to the definition of the handler
    of `getJSON` and parsed into an array of rows. The following are the details of
    the handler code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we remove all the existing series displayed in the chart by calling
    `Series.remove`. We then construct a series option with a data array of date (in
    UTC time) and price. We then remove the loading screen with `Chart.hideLoading`
    and display a new series with the `Chart.addSeries` methods. The only minor issue
    is that the default color and point marker for the series change when the series
    is reinserted; the internal indices in `chart.options.colors` and `chart.options.symbols`
    are incremented when a series is removed and added back to the chart. We can explicitly
    set the series color and point symbol to resolve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can call `Series.setData` to achieve the same result but,
    once the name (subject) of a series is assigned and the series is created, it
    is not allowed to change. Therefore, we stick to `Chart.addSeries` and `Series.remove`
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of a single stock query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting data in Ajax and displaying a new series with Chart.addSeries](img/7451OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying multiple series with simultaneous Ajax calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next part is to explore how to launch multiple Ajax queries simultaneously
    and plot series together when all the results have been returned. The implementation
    is pretty much the same as plotting a single stock query, except that we build
    up the series array option as we gather the results and plot them only when the
    last result arrives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second Boolean parameter of `Chart.addSeries`, `redraw`, is passed as `false`.
    Instead, we finalize all the updates in one single call, `Chart.redraw`, to save
    CPU time. The following is the screenshot for the multiple stock queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying multiple series with simultaneous Ajax calls](img/7451OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extracting SVG data with Chart.getSVG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to extract chart output and deliver it via
    e-mail or file download. Although we can rely on the exporting module and call
    the `exportChart` method to export the chart into the desired image format, it
    would be beneficial to see the whole process from formatting the original SVG
    content to creating an image file. After that, it is just a matter of calling
    different utilities to deliver the image file on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the data underneath SVG from the displaying chart, the `getSVG`
    method is called, available when the exporting module is loaded. This method is
    similar to `exportChart`: it accepts the `chartOptions` parameter, which is used
    for applying configurations to the export chart output.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the client-side jQuery code for handling both the **Download** and **Email**
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the `protocol` variable to specify the action for the chart and
    both buttons call the defined common function, `deliverChart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `deliverChart` method first calls the Highcharts API `getSVG` to extract
    the SVG content, then launches a `POST` call with both SVG data and action parameters.
    When `$.post` returns with a task status value, it shows a message dialog. As
    for the download chart, we create a hidden `<iframe>` to download the chart image
    file upon the successful return of the task status value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple server-side script for converting the SVG content
    and delivering the exported file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The web server is running on a Linux platform (Ubuntu 12.04). As for the e-mail
    action, we use two command-line utilities to help us. The first is a fast image
    conversion tool, **convert**, that is part of the **ImageMagick** package (**s**ee
    the package website for more details at [http://www.imagemagick.org/script/index.php](http://www.imagemagick.org/script/index.php)).
    Inside the script, we save the SVG data from the `POST` parameter into a file
    and then run the convert tool to format it into a PNG image. The convert tool
    supports many other image formats and comes with a myriad of advanced features.
    Alternatively, we can use Batik to do a straightforward conversion by issuing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The given command also converts an SVG file and outputs `/tmp/chart.png` automatically.
    For the sake of implementing the e-mail feature quickly, we will launch an e-mail
    tool, **mutt** (see the package website for more details at [http://www.mutt.org](http://www.mutt.org)),
    instead of using the PHP mail extension. Once the PNG image file is created, we
    use mutt to send it as an attachment and use a heredoc to specify the message
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **heredoc** is a quick way of inputting strings in a Unix command line with
    new lines and white spaces. See [http://en.wikipedia.org/wiki/Here_document](http://en.wikipedia.org/wiki/Here_document).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of the e-mail that is sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting SVG data with Chart.getSVG](img/7451OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the screenshot of the attachment e-mail that arrived in my
    e-mail account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting SVG data with Chart.getSVG](img/7451OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting data points and adding plot lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next part is to implement the **Show** **Range** checkbox and the **Show
    Point Value** button. The **Show Range** option displays plot lines along the
    highest and lowest points in the chart, whereas **Show Point Value** displays
    a box with the value at the bottom left-hand side if a point is selected. The
    following screenshot demonstrates how both are enabled in the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting data points and adding plot lines](img/7451OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is more natural for the **Show Point Value** checkbox to show the
    selected point display, this will become a callback implementation to every point
    select event. Instead, we use a button here, so that we can directly call the
    `Chart.getSelectedPoints` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using Axis.getExtremes and Axis.addPlotLine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Axis.getExtremes` method not only returns the axis current minimum and
    maximum range in display, but also the highest and the lowest values for the data
    points. Here, we use the method to combine with the `Axis.addPlotLine` function
    to add a pair of plot lines along the *y* axis. The `addPointLine` routine expects
    a plot line configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we specify a data label as well as an `id` name, so that we
    can remove lines at both high and low ends when the **Show Range** option is unchecked
    or plot lines need to be redisplayed with a new value. The following is the code
    for the **Show Range** action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using the Chart.getSelectedPoints and Chart.renderer methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Show Point Value** button makes use of the `Chart.getSelectedPoints` method
    to retrieve the data point that is currently selected. Note that this method requires
    the series option `allowPointSelect` to be enabled in the first place. Once a
    data point is selected and the **Show Point Value** button is clicked, we use
    functions provided by the `Chart.renderer` method to draw a tooltip-like box showing
    the selected value. We can use the `Renderer.path` or `Renderer.rect` methods
    to draw the rounded box, then `Renderer.text` for the data value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Highcharts also supports multiple data point selection, which can be done by
    clicking on the left mouse button while holding down the *Ctrl* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we use the `Renderer.g` routine to group the SVG box and value
    string together and add the resulting group element into the chart. The reason
    for that is so that we can re-display the box with a new value by removing the
    old group object as a whole instead of each individual element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Highcharts'' `Renderer` class also comes with other methods to draw simple
    SVG shapes on the chart, such as `arc`, `circle`, `image`, `rect`, `text`, `g`,
    and `path`. For more advanced shapes, we can use the `path` method, which accepts
    the SVG path syntax and has limited support on VML paths. Moreover, the `Renderer`
    class can be used independently from a chart—that is, we can call methods of the
    `Renderer` class without creating a chart beforehand and add SVG contents to an
    HTML element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This creates a `Renderer` object that allows us to create SVG elements inside
    the `container` element, with an area 200 pixels wide and 100 pixels high.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring series update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The series update is one of the most frequent tasks performed in charts. In
    this section, we investigate it in high definition. In Highcharts, there are several
    approaches to updating a series. Generally, we can update a series from a series
    or data point level. Then, the update method itself can either be actually changing
    the value, or reinserting it. We will discuss each approach and create a comprehensive
    example to experiment with all the techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to compare each approach, we will continue to use stock market data
    but we will change the user interface this time to enable replaying the historical
    stock price. The following is the screenshot of the example in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring series update](img/7451OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, there are multiple selection boxes to choose from: how many
    years of historical stock price to replay, how many data points to update in each
    iteration, and how long the wait is in between each update. Most importantly,
    we can choose which series update method should be used; it is interesting to
    observe the behavioral difference between them, especially during the whole replay.
    This demo is also available on my website at [http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html](http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html).
    I strongly recommend readers give it a go. Before we look into each update approach,
    let''s find out how to construct this continuous series update process.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous series update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we enter a stock symbol and select the number of years of stock prices
    to replay, we can click on the **Load Data** button to retrieve the price data.
    Once the data arrives, a confirmation dialog pops up with a **Start** button to
    kick-start the process. The following is the action code for the **Start** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We first create a variable, `histStock`, under the jQuery namespace, that is
    accessed by various parts within the demo. The `histStock` variable holds the
    current user's inputs and the reference to the refresh task. Any changes from
    the user interface update `$.histStock`, so the series update responds accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, when the **Start** button is clicked, we initialize the `$.histStock`
    variable and start an Ajax query with the stock symbol and number-of-years parameters.
    Then, when the stock price data returns from the query, we store the result into
    the variable. We then call `refreshSeries`, which calls itself by the setting
    via a timer routine. The following code is the simplified version of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Inside `refreshSeries`, it inspects the settings inside the `$.histStock` variable
    and updates the series depending on the user's choice. Once the update is done,
    we increment the `offset` value, which is at the start position for copying the
    stock result data into the chart. If the counter variable `i` hits the end of
    the stock data, then it simply exits the method. Otherwise, it will call the JavaScript
    timer function to set up the next loop. The next goal is to review how each update
    method is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the performance of various Highcharts methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four techniques for updating the series data: `Series.setData`, `Series.remove`/`Chart.addSeries`,
    `Point.update`, and `Series.addPoint`. We measure the performance for all four
    techniques in terms of CPU and memory usage with the Resource Monitor tool. Each
    method is timed when replaying the stock prices for the past year along with 0.5
    seconds of waiting time between each update. We repeated the same run twice and
    recorded the average. The experiment is repeated on a selection of browsers: Firefox,
    Chrome, Internet Explorer 8 and 11, and Safari. Although IE 8 does not support
    SVG and only supports VML, it is important to use it in the experiment because
    Highcharts'' implementation is compatible with IE 8\. One thing that we instantly
    notice is the same chart on IE8 is not as appealing as in SVG.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The whole experiment is running on a PC with Windows 7 Ultimate installed, and
    the hardware is 4GB RAM Core 2 Duo 3.06 GHz with an Intel G41 Graphics chipset.
  prefs: []
  type: TYPE_NORMAL
- en: The browser versions are Firefox 31.0, Chrome 36.0.1985, IE11 11.0.9600, Safari
    5.1.7, and IE8 8.0.6001\. Safari may not be a true performance indicator as it
    is rather old for a PC platform.
  prefs: []
  type: TYPE_NORMAL
- en: It is no longer possible to install/run IE8 on Windows 7, as Microsoft has discontinued
    support. Although we can set the user agent on IE11 to IE8 and conduct the experiment,
    it doesn't offer a true reflection of IE8 performance. Therefore, we set up another
    system running Windows XP with IE8 on identical hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, each series update approach is explained and a performance
    comparison is presented between the browsers. Readers must not use the result
    as a guide to the browser's general performance, which is derived from running
    a myriad of tests in a number of areas. What we are experimenting with here is
    simply how Highcharts performs on each browser in terms of SVG animations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the results are different compared to what was presented in the previous
    edition. This is mainly due to using a more up-to-date version of Highcharts:
    we use 4.0.3 in this experiment, whereas 2.2.24 is documented in the previous
    edition.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying a new set of data with Series.setData
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can apply a new set of data to an existing series using the `Series.setData`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The data can be an array of one dimensional data, an array of x and y value
    pairs, or an array of data point objects. Note that this method is the simplest
    form of all the approaches, and doesn''t provide any animation effects at all.
    Here is how we use the `setData` function in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two sets of animations appearing in the chart: *x*-axis labels moving
    from the center of the chart and the data points in the series. Although the series
    scrolls smoothly, the movement of the *x*-axis labels appears too quickly and
    becomes choppy. The following graph shows the performance comparison when using
    the `setData` method across the browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a new set of data with Series.setData](img/7451OS_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are minor differences in terms of CPU usage, except for IE8 that runs
    on VML instead of SVG. IE8 consumed much higher CPU usage and took much longer
    to finish. The animation lagged throughout the experiment. Among the browsers,
    Safari is marginally the best. Out of all the browsers, Firefox has the highest
    memory footprint, whereas IE 11 had the smallest. Perhaps a slight surprise is
    that Safari has a better performance than Firefox and is also very close to Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Using Series.remove and Chart.addSeries to reinsert series with new data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively, we can remove the whole series with the `Series.remove` method,
    then rebuild the series options with the data and reinsert a new series using
    `Chart.addSeries`. The downside of this approach is that the internal index for
    the default colors and point symbols is incremented, as we found in the earlier
    example. We can compensate for that by specifying the color and the marker options.
    Here is the code for the `addSeries` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this experiment, we use the refresh rate for every half-second, which is
    shorter than the time span of the default animation. Therefore the series update
    appears erratic without much animation, as in `setData`. However, if we change
    the refresh rate to 3 seconds or more, then we can see the series being redrawn
    from the left-hand to the right-hand side in each update. Unlike other methods,
    the x-axis labels are updated without any animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Series.remove and Chart.addSeries to reinsert series with new data](img/7451OS_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following graph shows the performance comparison when using the `addSeries`
    method across the browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Series.remove and Chart.addSeries to reinsert series with new data](img/7451OS_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since this approach seems to have the least animation, the CPU usage levels
    are relatively low across all the browsers, as is the memory usage. As expected,
    IE8 consumes the most resources. Next is IE11, which is roughly on a par with
    Chrome. The most unusual result is that Firefox requires significantly less CPU
    usage than both Chrome and Safari when there is little animation. We will investigate
    this further in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data points with Point.update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can update individual data points with the `Point.update` method. The update
    method has a similar prototype to `setData`, which accepts a single value, an
    array of x and y values, or a data point object. Each update call can be redrawn
    into the chart with or without animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we use the `Point.update` method: we traverse through each point
    object and call its member function. In order to save CPU time, we set the `redraw`
    parameter to `false` and call `Chart.redraw` after the last data point is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`Point.update` animates each data point vertically. It gives a wavy effect
    overall as the graph is progressively updated. In the same way as the `setData`
    method, the labels approach the x-axis line diagonally. The following graph shows
    the performance comparison of the `Point.update` method across the browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating data points with Point.update](img/7451OS_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the animations are pretty much the same as the `setData` approach, the performance
    shown in the preceding chart is very close to the results of the `setData` performance
    experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Removing and adding data points with Point.remove and Series.addPoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of updating each individual data point, we can use `Point.remove` to
    remove data points within the `series.data` array and use `Series.addPoint` to
    add new data points back into the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the time series data, we can use `addPoint` along with the `shift` parameter
    set to `true`, which will automatically shift the series point array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph shows the performance comparison of the `addPoint` method
    across the browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing and adding data points with Point.remove and Series.addPoint](img/7451OS_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is hardly any difference between the `addPoint` method, `setData,` and
    `update` in terms of both CPU and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SVG animation performance on browsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have seen that the level of CPU usage increased with animations.
    However, the question left unanswered is why Safari had lower CPU consumption
    than Chrome and Firefox. A number of browser benchmark suites have been run on
    the test machine to confirm the general consensus that the Firefox and Chrome
    browsers have overall better performance than Safari.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All browsers were benchmarked with SunSpider [http://www.webkit.org/perf/sunspider/sunspider.html](http://www.webkit.org/perf/sunspider/sunspider.html),
    Google's V8 Benchmark suite [http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html),
    and Peacekeeper [http://peacekeeper.futuremark.com/](http://peacekeeper.futuremark.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, there is one particular area where Safari has better performance
    than the other browsers: SVG animations; this is reflected in our previous experiments.
    Here, we use a benchmark test, written by Cameron Adams, that is especially designed
    to measure SVG animations with bouncing particles in frames per second. The test
    (HTML5 versus Flash: Animation Benchmarking [http://www.themaninblue.com/writing/perspective/2010/03/22/](http://www.themaninblue.com/writing/perspective/2010/03/22/))
    was originally written to compare various HTML5 animation technologies against
    Flash. Here, we run the SVG test with the Chrome and Safari browsers. The following
    is a Safari screenshot running with a 500-particle test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring SVG animation performance on browsers](img/7451OS_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As for Chrome, the test is running at around 165 FPS. We repeat the assessment
    with various numbers of particles on both browsers. The following graph summarizes
    the performance difference with regard to SVG animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring SVG animation performance on browsers](img/7451OS_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, Safari manages a higher frame rate with particles fewer than
    3,000\. After that, the Safari performance starts to degrade in parallel with
    Chrome. Firefox has a consistently lower frame rate and the frame rate drops considerably
    compared to the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to another inevitable question: why is there such a difference,
    given that both browsers run with the same code base of webkit? It is difficult
    to pinpoint where the discrepancy lies. However, one of the few differences between
    both products is the JavaScript engines, which may affect that area, or possibly
    it is caused by the minor difference in the webkit version. In addition, other
    specific SVG performance tests in [http://jsperf.com](http://jsperf.com) have
    also been run, in which Safari again had a higher score than Chrome.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how Highcharts' performance corresponds to
    the data size.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Highcharts' performance on large datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final test is to observe how Highcharts performs with large data sets.
    In this experiment, we are going to plot scatter series across various data sizes
    and observe the time taken to display the data. We chose to use the scatter series
    because, when there is a very large data set with tens of thousands of samples,
    the user is likely to plot only data points on the chart. Here is the simplified
    code illustrating how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The page is loaded with URL parameters to specify the dataset size. We start
    timing before the chart object is created and stop at the callback handler in
    the constructor, `Chart`, method. We repeat the experiment with the same dataset
    size on each browser used in the previous benchmarking experiments. Once the page
    is loaded on a browser, the dataset is randomly generated. Then, timing begins
    just before the chart object is constructed and stops at the callback method in
    Highcharts. The chart function is executed when the chart is finally displayed
    onto the screen. The following screenshot shows the time taken to display 3,000
    data points on the Safari browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing Highcharts'' performance on large datasets](img/7451OS_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following graph illustrates Highcharts'' performance on different browsers
    with various dataset sizes. The lower the line, the less time it takes to display
    the number of data points, which indicates better performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing Highcharts'' performance on large datasets](img/7451OS_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: None of the browsers take particularly long to display large datasets. This
    shows the impressive scalable performance of Highcharts. Even IE 11, which is
    consistently slower in all tests, only takes 5.3 seconds to render 50,000 data
    points. As for smaller datasets, there is hardly any difference in timing. Both
    Firefox and Safari have very similar results, although Firefox is marginally better.
    This is due to the fact that there is no animation in scatter series and Firefox
    generally performs better without SVG animation. This also supports our findings
    in the least animated `addSeries` experiment, where Firefox required less CPU
    usage. As for Chrome, its performance is roughly equidistant between Safari/Firefox
    and IE 11.
  prefs: []
  type: TYPE_NORMAL
- en: From all these experiments, we can conclude that Safari performs the best with
    Highcharts (on a Windows PC), particularly when there are a lot of SVG animations
    in the chart. If a chart is static, then Firefox gives the best performance. IE
    11 has the best memory utilization among the browsers but runs slower. Chrome
    achieves a consistent mid-range performance. We must stress that SVG is only one
    of the many areas of performance testing and Chrome has outperformed other browsers
    in the benchmark score.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the Highcharts APIs, from the class model to applying
    them in applications. Then we performed a comprehensive study of the different
    techniques for updating a chart series in Highcharts, and carried out an experiment
    to analyze the difference in their performance. Finally, the chapter finished
    by analyzing the speed of different web browsers when rendering data points with
    regard to different sizes of large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into Highcharts events handling, which is
    closely related to Highcharts APIs.
  prefs: []
  type: TYPE_NORMAL
