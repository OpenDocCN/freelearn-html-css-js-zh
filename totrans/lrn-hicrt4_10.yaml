- en: Chapter 10. Highcharts APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. Highcharts API
- en: 'Highcharts offers a small set of APIs designed for plotting charts with dynamic
    interactions. In order to understand how the APIs work, we must first familiarize
    ourselves with the chart''s internal objects and how they are organized inside
    a chart. In this chapter, we will learn about the chart class model and how to
    call the APIs by referencing the objects. Then we build a simple stock price application
    with PHP, jQuery, and jQuery UI to demonstrate the use of Highcharts APIs. After
    that, we turn our attention to four different ways of updating a series. We experiment
    with all the series update methods with the purpose of building an application
    to illustrate variations in visual effects, and the difference in CPU performance
    between them. Finally, we investigate performance when updating a series with
    popular web browsers, in terms of different sizes of datasets. In this chapter,
    we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 提供了一组小型 API，专为动态交互式绘图而设计。为了理解 API 的工作原理，我们首先需要熟悉图表的内部对象以及它们在图表内部的组织方式。在本章中，我们将学习图表类模型以及如何通过引用对象调用
    API。然后，我们使用 PHP、jQuery 和 jQuery UI 构建一个简单的股价应用程序来演示 Highcharts API 的使用。之后，我们将关注四种不同的更新系列的方法。我们通过实验所有系列更新方法，目的是构建一个应用程序来展示视觉效果的差异，以及它们之间
    CPU 性能的差异。最后，我们调查使用流行的网络浏览器更新系列时的性能，从不同大小的数据集的角度来看。在本章中，我们将涵盖以下主题：
- en: Understanding the Highcharts class model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Highcharts 类模型
- en: Getting data in Ajax and displaying new series with `Chart.addSeries`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ajax 获取数据并通过 `Chart.addSeries` 显示新的系列
- en: Displaying multiple series with simultaneous Ajax calls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同时进行的 Ajax 调用显示多个系列
- en: Using `Chart.getSVG` to format SVG data into an image file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Chart.getSVG` 将 SVG 数据格式化为图像文件
- en: Using the `Chart.renderer` methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Chart.renderer` 方法
- en: Exploring different methods to update series and their performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索更新系列的不同方法及其性能
- en: Experimenting with Highcharts performance with large datasets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大数据集实验 Highcharts 性能
- en: Understanding the Highcharts class model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Highcharts 类模型
- en: 'The relationship between Highcharts classes is very simple and obvious. A chart
    is composed of five different classes—`Chart`, `Axis`, `Series`, `Point`, and
    `Renderer`. Some of these classes contain an array of lower-level components and
    an object property to back-reference to a higher level-owner component. For example,
    the `Point` class has the `series` property pointing back to the owner `Series`
    class. Each class also has a set of methods for managing and displaying its own
    layer. In this chapter, we will focus on the set of APIs for dynamically modifying
    charts. The following class diagram describes the association between these classes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 类之间的关系非常简单且明显。一个图表由五个不同的类组成——`Chart`、`Axis`、`Series`、`Point` 和 `Renderer`。其中一些类包含一组低级组件和一个对象属性，用于回引用到高级所有者组件。例如，`Point`
    类有一个 `series` 属性指向所有者 `Series` 类。每个类也有一组用于管理和显示其自身层的方法。在本章中，我们将重点关注动态修改图表的 API
    集合。以下类图描述了这些类之间的关系：
- en: '![Understanding the Highcharts class model](img/7451OS_10_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Highcharts 类模型](img/7451OS_10_01.jpg)'
- en: The `Chart` class is the top level class representing the whole chart object.
    It contains method calls to operate the chart as a whole—for example, exporting
    the chart into SVG or other image formats and setting the dimension of the chart.
    The `Chart` class has multiple arrays of `Axis` and `Series` objects; that is,
    a chart can have one or more *x* axes, *y* axes, and series. The `Renderer` class
    is a utility class that has a one-to-one relationship per chart and provides a
    common interface for drawing in SVG and VML-based browsers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart` 类是表示整个图表对象的顶层类。它包含操作整个图表的方法调用——例如，将图表导出为 SVG 或其他图像格式以及设置图表的维度。`Chart`
    类具有多个 `Axis` 和 `Series` 对象数组；也就是说，一个图表可以有一个或多个 *x* 轴、*y* 轴和系列。`Renderer` 类是一个实用类，每个图表都有一个一对一的关系，并为基于
    SVG 和 VML 的浏览器提供绘制的一个通用接口。'
- en: The `Series` class has an array of `Point` objects. The class has back-reference
    properties towards the `Chart` and `Axis` objects (see the dotted lines in the
    previous diagram) and provides functions for managing its list of `Point` objects.
    The `yAxis` and `xAxis` properties in the `Series` class are necessary, as a chart
    can have multiple axes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 类包含一个 `Point` 对象数组。该类具有指向 `Chart` 和 `Axis` 对象的回引用属性（参见前一个图中的虚线）并提供管理其
    `Point` 对象列表的函数。在 `Series` 类中，`yAxis` 和 `xAxis` 属性是必要的，因为图表可以拥有多个轴。'
- en: The `Point` class is just a simple object containing x and y values and a back-reference
    to its series object (see the dotted line). The APIs are for managing the data
    points in the chart.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 类只是一个包含 x 和 y 值以及对其序列对象的反向引用的简单对象（见虚线）。API 用于管理图表中的数据点。'
- en: Highcharts constructor – Highcharts.Chart
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Highcharts 构造函数 – Highcharts.Chart
- en: 'Needless to say, the most important method in the APIs is the `Highcharts.Chart`
    method, with which we have seen plenty of action so far. However, there is more
    to this constructor call. `Highcarts.Chart` creates and returns a chart object
    but it also has a second optional parameter known as `callback`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，API 中最重要的方法是 `Highcharts.Chart` 方法，我们之前已经看到了很多关于这个构造函数的用法。然而，这个构造函数调用还有更多内容。`Highcharts.Chart`
    创建并返回一个图表对象，但它还有一个名为 `callback` 的第二个可选参数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The callback function is called when a chart is created and rendered. Inside
    the function, we can either call the component methods or access the properties
    inside the chart object. The newly created chart object is passed via the only
    callback function parameter. We can also use the '`this`' keyword inside the callback
    function, which also refers to the chart object. Instead of using the `Highcharts.Chart`
    callback parameter, we can achieve the same result by declaring our code inside
    the `chart.events.load` handler, which will be explored in the next chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当图表创建并渲染时，会调用回调函数。在函数内部，我们可以调用组件方法或访问图表对象内的属性。新创建的图表对象通过唯一的回调函数参数传递。我们还可以在回调函数内部使用
    `this` 关键字，它也指向图表对象。我们可以在 `chart.events.load` 处理程序内部声明代码，而不是使用 `Highcharts.Chart`
    回调参数，这将在下一章中探讨。
- en: Navigating through Highcharts components
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Highcharts 组件中导航
- en: 'In order to use the Highcharts API, we must navigate to the right object inside
    the class hierarchy. There are several ways to traverse within the chart object:
    through the chart hierarchy model, retrieving the component directly with the
    `Chart.get` method, or a mixture of both.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Highcharts API，我们必须在类层次结构中导航到正确的对象。有几种方法可以在图表对象内部进行遍历：通过图表层次结构模型，直接使用 `Chart.get`
    方法检索组件，或者两者的组合。
- en: Using the object hierarchy
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象层次结构
- en: 'Suppose that the chart object is created, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设图表对象已创建，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then access the first position of the series'' object with the index
    0 from the chart. Inside the callback handler, we use the `this` keyword to refer
    to the chart object as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过索引 0 从图表中访问序列对象的第一个位置。在回调处理程序内部，我们使用 `this` 关键字如下引用图表对象：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Suppose there are two *y* axes in the configuration. To retrieve the second
    *y* axis, we can do as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设配置中有两个 *y* 轴。要检索第二个 *y* 轴，我们可以这样做：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To retrieve the third data point object from the second series of the chart,
    type the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要从第二个序列中检索第三个数据点对象，请输入以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Supposing multiple charts are created on the page, a chart object can be accessed
    via the Highcharts namespace:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设页面上创建了多个图表，可以通过 Highcharts 命名空间访问图表对象：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also retrieve the chart''s container element through the container option:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `container` 选项检索图表的容器元素：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To examine the options structure of a created chart, use the options property:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查创建的图表的选项结构，请使用 `options` 属性：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the Chart.get method
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Chart.get 方法
- en: Instead of cascading down the object hierarchy, we can directly retrieve the
    component using the `Chart.get` method (the `get` method is only available at
    the chart level, not in each component class). Assigning components with IDs will
    allow you to access them directly using the `get` method instead of traversing
    nodes in the object's hierarchical structure. The configuration uses the option
    key `id`, so this value must be unique.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用 `Chart.get` 方法检索组件，而不是沿着对象层次结构向下遍历（`get` 方法仅在图表级别可用，不在每个组件类中）。通过 ID
    分配组件将允许您使用 `get` 方法直接访问它们，而不是遍历对象的层次结构节点。配置使用选项键 `id`，因此此值必须是唯一的。
- en: 'Suppose we have created a chart with the following configuration code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已使用以下配置代码创建了一个图表：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can retrieve the components as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式检索组件：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the `id` option is not previously configured, we can use the JavaScript
    `filter` method to search for the item based on the property:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前没有配置 `id` 选项，我们可以使用 JavaScript `filter` 方法根据属性搜索项目：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using both the object hierarchy and the Chart.get method
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象层次结构和 Chart.get 方法
- en: 'It is cumbersome to define the `id` option for every component inside the chart.
    Alternatively, we can navigate through the components using both approaches, as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为图表中的每个组件定义`id`选项很麻烦。作为替代，我们可以使用两种方法中的任何一种来遍历组件，如下所示：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the Highcharts APIs
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Highcharts API
- en: In this section, we will build an example using jQuery, jQuery UI, and Highcharts
    to explore each component's APIs. All the example code from here on will be using
    the object hierarchy to access chart components, that is, `chart.series[0].data[0]`.
    The user interface used here has a very minimal look and is far from perfect,
    as the main purpose of this exercise is to examine the Highcharts APIs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用jQuery、jQuery UI和Highcharts构建一个示例，以探索每个组件的API。从现在开始的所有示例代码都将使用对象层次结构来访问图表组件，即`chart.series[0].data[0]`。这里使用的用户界面外观非常简洁，远非完美，因为这项练习的主要目的是检查Highcharts
    API。
- en: 'First, let''s see the usage of this user interface; then we will dissect the
    code to understand how the operations are performed. The following is the final
    UI screenshot that will be created in this section:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个用户界面的用法；然后我们将剖析代码以了解操作是如何执行的。以下是在本节中创建的最终UI截图：
- en: '![Using the Highcharts APIs](img/7451OS_10_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用Highcharts API](img/7451OS_10_02.jpg)'
- en: This is a simple web frontend for plotting the stock data chart for the past
    30 days. The top part is a group of buttons for setting the stock symbols, getting
    the stock price, and retrieving the chart image by downloading it or via e-mail.
    The **Add to the list** button is for adding a stock symbol straight to the list
    without getting the stock prices and plotting the data. The **Plot All** button
    is for launching multiple stock price queries from the symbol list simultaneously,
    and to plot the data when all the results arrive. Alternatively, **Add & Plot**
    is a quick option for plotting a single stock symbol.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Web前端，用于绘制过去30天的股票数据图表。顶部是一组按钮，用于设置股票符号、获取股票价格和通过下载或电子邮件检索图表图像。**添加到列表**按钮用于直接将股票符号添加到列表中，而无需获取股票价格和绘制数据。**绘制所有**按钮用于从符号列表中同时启动多个股票价格查询，并在所有结果到达时绘制数据。或者，**添加并绘制**是一个快速选项，用于绘制单个股票符号。
- en: The bottom half contains a chart that we have already created. The chart is
    displayed with empty data and axes with titles (setting the `showAxes` option
    to `true`). The whole idea is to reuse the existing chart rather than recreating
    a new chart object every time new results arrive. Therefore, there is no flickering
    effect when the chart is destroyed and created and it appears as a smooth update
    animation. This also provides better performance without running extra code to
    regenerate the chart object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下半部分包含一个我们已经创建的图表。图表以空数据和带有标题的轴（将`showAxes`选项设置为`true`）显示。整个想法是重用现有的图表，而不是每次新结果到来时都重新创建一个新的图表对象。因此，当图表被销毁和创建时没有闪烁效果，它看起来像是一个平滑的更新动画。这也提供了更好的性能，无需运行额外的代码来重新生成图表对象。
- en: This example is also available online at [http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html](http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在[http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html](http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html)在线获取。
- en: Chart configurations
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表配置
- en: 'The following is the chart configuration used for the example. Once a stock
    query is made, the server-side script will request the stock prices for the last
    30 days and format the results into days in units of milliseconds. Hence, the
    *x* axis is configured as a `datetime` type with intervals on a daily basis:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用作示例的图表配置。一旦执行股票查询，服务器端脚本将请求过去30天的股票价格，并将结果格式化为以毫秒为单位的日单位。因此，*x*轴被配置为以每日为基础的`datetime`类型：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting data in Ajax and displaying a new series with Chart.addSeries
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ajax获取数据并在Chart.addSeries中显示新的系列
- en: 'Let''s examine the action behind the **Add & Plot** button, defined as the
    following HTML syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查**添加并绘制**按钮背后的动作，如下所示HTML语法：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The jQuery code for the button action is listed, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮动作的jQuery代码如下：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous code defines the event handler for the **Add & Plot** button''s
    click event. First, it empties all the entries in the stock symbol list box that
    have IDs as `stocklist`. Then, it retrieves the stock symbol value from the input
    field `symbol` and appends the symbol to the list. The next step is to initiate
    a loading message screen on the chart by calling the `chart.showLoading` method.
    The following screenshot shows the loading message screen:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了**添加 & 绘制**按钮的点击事件的处理器。首先，它会清空股票符号列表框中所有ID为`stocklist`的条目。然后，它从输入字段`symbol`中检索股票符号值并将其添加到列表中。下一步是通过调用`chart.showLoading`方法在图表上启动一个加载信息屏幕。以下截图显示了加载信息屏幕：
- en: '![Getting data in Ajax and displaying a new series with Chart.addSeries](img/7451OS_10_13.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ajax获取数据并在Chart.addSeries中显示新系列](img/7451OS_10_13.jpg)'
- en: 'The next call is to launch a jQuery Ajax call, `$.getJSON`, to query the stock
    price. The `stockQuery.php` server script (of course, any other server-side language
    can be used) does two tasks: it resolves the symbol into the full name of the
    organization, launches the symbol query from another website ([http://ichart.finance.yahoo.com/table.csv?s=BATS.L](http://ichart.finance.yahoo.com/table.csv?s=BATS.L))
    for the past stock price data, then packs the data into rows and encodes them
    into JSON format. The following is the code in the `stockQuery.php` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用是启动一个jQuery Ajax调用，`$.getJSON`，以查询股票价格。`stockQuery.php`服务器脚本（当然，可以使用任何其他服务器端语言）执行两个任务：它将符号解析为组织的全名，从另一个网站（[http://ichart.finance.yahoo.com/table.csv?s=BATS.L](http://ichart.finance.yahoo.com/table.csv?s=BATS.L)）查询过去的股票价格数据，然后将数据打包成行并编码成JSON格式。以下是在`stockQuery.php`文件中的代码：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the result returned from the server side in the JSON format:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从服务器端以JSON格式返回的结果：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the JSON result arrives, the data is passed to the definition of the handler
    of `getJSON` and parsed into an array of rows. The following are the details of
    the handler code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JSON结果到达，数据就会被传递到`getJSON`处理器的定义中，并解析成一个行数组。以下是对处理器代码的详细说明：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First of all, we remove all the existing series displayed in the chart by calling
    `Series.remove`. We then construct a series option with a data array of date (in
    UTC time) and price. We then remove the loading screen with `Chart.hideLoading`
    and display a new series with the `Chart.addSeries` methods. The only minor issue
    is that the default color and point marker for the series change when the series
    is reinserted; the internal indices in `chart.options.colors` and `chart.options.symbols`
    are incremented when a series is removed and added back to the chart. We can explicitly
    set the series color and point symbol to resolve this issue.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`Series.remove`移除图表中显示的所有现有系列。然后，我们构建一个包含日期（UTC时间）和价格的数据数组的系列选项。然后，我们通过调用`Chart.hideLoading`移除加载屏幕，并使用`Chart.addSeries`方法显示一个新的系列。唯一的小问题是，当系列被重新插入时，系列的默认颜色和点标记会改变；当系列被移除并重新添加到图表中时，`chart.options.colors`和`chart.options.symbols`中的内部索引会增加。我们可以显式设置系列颜色和点符号来解决这个问题。
- en: Alternatively, we can call `Series.setData` to achieve the same result but,
    once the name (subject) of a series is assigned and the series is created, it
    is not allowed to change. Therefore, we stick to `Chart.addSeries` and `Series.remove`
    in this example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以调用`Series.setData`以实现相同的结果，但是一旦分配了系列（主题）的名称并创建了系列，就不允许更改。因此，我们在这个例子中坚持使用`Chart.addSeries`和`Series.remove`。
- en: 'The following is a screenshot of a single stock query:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单个股票查询的截图：
- en: '![Getting data in Ajax and displaying a new series with Chart.addSeries](img/7451OS_10_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ajax获取数据并在Chart.addSeries中显示新系列](img/7451OS_10_03.jpg)'
- en: Displaying multiple series with simultaneous Ajax calls
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用同时进行的Ajax调用显示多个系列
- en: 'The next part is to explore how to launch multiple Ajax queries simultaneously
    and plot series together when all the results have been returned. The implementation
    is pretty much the same as plotting a single stock query, except that we build
    up the series array option as we gather the results and plot them only when the
    last result arrives:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是探索如何同时启动多个Ajax查询，并在所有结果都返回后一起绘制系列。实现方式基本上与绘制单个股票查询相同，只是我们在收集结果的同时构建系列数组选项，并在最后一个结果到达时才绘制它们：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second Boolean parameter of `Chart.addSeries`, `redraw`, is passed as `false`.
    Instead, we finalize all the updates in one single call, `Chart.redraw`, to save
    CPU time. The following is the screenshot for the multiple stock queries:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart.addSeries`的第二个布尔参数`redraw`被传递为`false`。相反，我们通过一个单一的调用`Chart.redraw`来最终化所有更新，以节省CPU时间。以下是多个股票查询的截图：'
- en: '![Displaying multiple series with simultaneous Ajax calls](img/7451OS_10_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用同时进行的Ajax调用显示多个系列](img/7451OS_10_04.jpg)'
- en: Extracting SVG data with Chart.getSVG
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chart.getSVG提取SVG数据
- en: In this section, we will learn how to extract chart output and deliver it via
    e-mail or file download. Although we can rely on the exporting module and call
    the `exportChart` method to export the chart into the desired image format, it
    would be beneficial to see the whole process from formatting the original SVG
    content to creating an image file. After that, it is just a matter of calling
    different utilities to deliver the image file on the server side.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何提取图表输出并通过电子邮件或文件下载来交付。虽然我们可以依赖导出模块并调用`exportChart`方法将图表导出为所需的图像格式，但了解从格式化原始SVG内容到创建图像文件的全过程将更有益。之后，只需在服务器端调用不同的实用工具来交付图像文件即可。
- en: 'To extract the data underneath SVG from the displaying chart, the `getSVG`
    method is called, available when the exporting module is loaded. This method is
    similar to `exportChart`: it accepts the `chartOptions` parameter, which is used
    for applying configurations to the export chart output.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要从显示的图表中提取SVG下面的数据，需要调用`getSVG`方法，该方法在导出模块加载时可用。此方法类似于`exportChart`：它接受`chartOptions`参数，该参数用于将配置应用到导出图表输出。
- en: Here is the client-side jQuery code for handling both the **Download** and **Email**
    buttons.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理**下载**和**电子邮件**按钮的客户端jQuery代码。
- en: 'Here, we use the `protocol` variable to specify the action for the chart and
    both buttons call the defined common function, `deliverChart`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`protocol`变量来指定图表的动作，并且两个按钮都调用定义的通用函数`deliverChart`：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `deliverChart` method first calls the Highcharts API `getSVG` to extract
    the SVG content, then launches a `POST` call with both SVG data and action parameters.
    When `$.post` returns with a task status value, it shows a message dialog. As
    for the download chart, we create a hidden `<iframe>` to download the chart image
    file upon the successful return of the task status value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`deliverChart`方法首先调用Highcharts API的`getSVG`来提取SVG内容，然后使用SVG数据和动作参数启动一个`POST`调用。当`$.post`返回任务状态值时，它会显示一个消息对话框。至于下载图表，我们在任务状态值成功返回时创建一个隐藏的`<iframe>`来下载图表图像文件。'
- en: 'The following is a simple server-side script for converting the SVG content
    and delivering the exported file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将SVG内容转换为并交付导出文件的简单服务器端脚本：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The web server is running on a Linux platform (Ubuntu 12.04). As for the e-mail
    action, we use two command-line utilities to help us. The first is a fast image
    conversion tool, **convert**, that is part of the **ImageMagick** package (**s**ee
    the package website for more details at [http://www.imagemagick.org/script/index.php](http://www.imagemagick.org/script/index.php)).
    Inside the script, we save the SVG data from the `POST` parameter into a file
    and then run the convert tool to format it into a PNG image. The convert tool
    supports many other image formats and comes with a myriad of advanced features.
    Alternatively, we can use Batik to do a straightforward conversion by issuing
    the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器运行在Linux平台（Ubuntu 12.04）上。至于电子邮件操作，我们使用两个命令行工具来帮助我们。第一个是一个快速图像转换工具**convert**，它是**ImageMagick**包的一部分（更多详情请访问[http://www.imagemagick.org/script/index.php](http://www.imagemagick.org/script/index.php)）。在脚本中，我们将从`POST`参数中保存SVG数据到一个文件，然后运行convert工具将其格式化为PNG图像。convert工具支持许多其他图像格式，并附带了许多高级功能。或者，我们可以使用Batik通过以下命令进行直接的转换：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The given command also converts an SVG file and outputs `/tmp/chart.png` automatically.
    For the sake of implementing the e-mail feature quickly, we will launch an e-mail
    tool, **mutt** (see the package website for more details at [http://www.mutt.org](http://www.mutt.org)),
    instead of using the PHP mail extension. Once the PNG image file is created, we
    use mutt to send it as an attachment and use a heredoc to specify the message
    body.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的命令还可以将SVG文件转换为`/tmp/chart.png`并自动输出。为了快速实现电子邮件功能，我们将启动一个电子邮件工具**mutt**（更多详情请访问[http://www.mutt.org](http://www.mutt.org)），而不是使用PHP邮件扩展。一旦PNG图像文件创建完成，我们使用mutt将其作为附件发送，并使用heredoc指定消息正文。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A **heredoc** is a quick way of inputting strings in a Unix command line with
    new lines and white spaces. See [http://en.wikipedia.org/wiki/Here_document](http://en.wikipedia.org/wiki/Here_document).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**heredoc** 是在 Unix 命令行中快速输入带有换行和空格的字符串的一种方法。请参阅 [http://en.wikipedia.org/wiki/Here_document](http://en.wikipedia.org/wiki/Here_document)。'
- en: 'The following is the screenshot of the e-mail that is sent:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是被发送的电子邮件的截图：
- en: '![Extracting SVG data with Chart.getSVG](img/7451OS_10_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用Chart.getSVG提取SVG数据](img/7451OS_10_05.jpg)'
- en: 'The following is the screenshot of the attachment e-mail that arrived in my
    e-mail account:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我电子邮件账户中收到的附件电子邮件的截图：
- en: '![Extracting SVG data with Chart.getSVG](img/7451OS_10_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用Chart.getSVG提取SVG数据](img/7451OS_10_06.jpg)'
- en: Selecting data points and adding plot lines
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择数据点和添加绘图线
- en: 'The next part is to implement the **Show** **Range** checkbox and the **Show
    Point Value** button. The **Show Range** option displays plot lines along the
    highest and lowest points in the chart, whereas **Show Point Value** displays
    a box with the value at the bottom left-hand side if a point is selected. The
    following screenshot demonstrates how both are enabled in the chart:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实现 **显示范围** 复选框和 **显示点值** 按钮。**显示范围** 选项在图表的最高点和最低点显示绘图线，而 **显示点值** 选项在选中一个点时在左下角显示一个包含值的框。以下截图展示了如何在图表中同时启用这两个功能：
- en: '![Selecting data points and adding plot lines](img/7451OS_10_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![选择数据点和添加绘图线](img/7451OS_10_07.jpg)'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although it is more natural for the **Show Point Value** checkbox to show the
    selected point display, this will become a callback implementation to every point
    select event. Instead, we use a button here, so that we can directly call the
    `Chart.getSelectedPoints` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于 **显示点值** 复选框来说，显示选中的点显示更为自然，但这将成为每个点选择事件的回调实现。相反，我们在这里使用一个按钮，这样我们就可以直接调用
    `Chart.getSelectedPoints` 方法。
- en: Using Axis.getExtremes and Axis.addPlotLine
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Axis.getExtremes和Axis.addPlotLine
- en: The `Axis.getExtremes` method not only returns the axis current minimum and
    maximum range in display, but also the highest and the lowest values for the data
    points. Here, we use the method to combine with the `Axis.addPlotLine` function
    to add a pair of plot lines along the *y* axis. The `addPointLine` routine expects
    a plot line configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axis.getExtremes` 方法不仅返回轴当前显示的最小和最大范围，还包括数据点的最高和最低值。在这里，我们使用该方法与 `Axis.addPlotLine`
    函数结合，在 *y* 轴上添加一对绘图线。`addPlotLine` 例程期望一个绘图线配置。'
- en: 'In this example, we specify a data label as well as an `id` name, so that we
    can remove lines at both high and low ends when the **Show Range** option is unchecked
    or plot lines need to be redisplayed with a new value. The following is the code
    for the **Show Range** action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们指定了一个数据标签以及一个 `id` 名称，这样我们就可以在未勾选 **显示范围** 选项或需要用新值重新显示绘图线时，同时移除高点和低点的线条。以下是为
    **显示范围** 动作编写的代码：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using the Chart.getSelectedPoints and Chart.renderer methods
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Chart.getSelectedPoints和Chart.renderer方法
- en: The **Show Point Value** button makes use of the `Chart.getSelectedPoints` method
    to retrieve the data point that is currently selected. Note that this method requires
    the series option `allowPointSelect` to be enabled in the first place. Once a
    data point is selected and the **Show Point Value** button is clicked, we use
    functions provided by the `Chart.renderer` method to draw a tooltip-like box showing
    the selected value. We can use the `Renderer.path` or `Renderer.rect` methods
    to draw the rounded box, then `Renderer.text` for the data value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示点值** 按钮利用 `Chart.getSelectedPoints` 方法检索当前选中的数据点。请注意，此方法需要首先启用系列选项 `allowPointSelect`。一旦选中数据点并点击
    **显示点值** 按钮，我们使用 `Chart.renderer` 方法提供的函数来绘制一个类似工具提示的框，显示选中的值。我们可以使用 `Renderer.path`
    或 `Renderer.rect` 方法来绘制圆角框，然后使用 `Renderer.text` 方法来绘制数据值。'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Highcharts also supports multiple data point selection, which can be done by
    clicking on the left mouse button while holding down the *Ctrl* key.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 也支持多数据点选择，可以通过按住 *Ctrl* 键并单击鼠标左键来实现。
- en: 'Additionally, we use the `Renderer.g` routine to group the SVG box and value
    string together and add the resulting group element into the chart. The reason
    for that is so that we can re-display the box with a new value by removing the
    old group object as a whole instead of each individual element:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用 `Renderer.g` 例程将 SVG 框和值字符串组合在一起，并将生成的组元素添加到图表中。这样做的原因是，我们可以通过删除整个旧组对象而不是每个单独的元素来重新显示带有新值的框：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Highcharts'' `Renderer` class also comes with other methods to draw simple
    SVG shapes on the chart, such as `arc`, `circle`, `image`, `rect`, `text`, `g`,
    and `path`. For more advanced shapes, we can use the `path` method, which accepts
    the SVG path syntax and has limited support on VML paths. Moreover, the `Renderer`
    class can be used independently from a chart—that is, we can call methods of the
    `Renderer` class without creating a chart beforehand and add SVG contents to an
    HTML element:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts的`Renderer`类还提供了其他方法来在图表上绘制简单的SVG形状，例如`arc`、`circle`、`image`、`rect`、`text`、`g`和`path`。对于更复杂的形状，我们可以使用`path`方法，它接受SVG路径语法，并在VML路径上有有限的兼容性。此外，`Renderer`类可以独立于图表使用——也就是说，我们可以在创建图表之前调用`Renderer`类的各种方法，并将SVG内容添加到HTML元素中：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This creates a `Renderer` object that allows us to create SVG elements inside
    the `container` element, with an area 200 pixels wide and 100 pixels high.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个`Renderer`对象，它允许我们在`container`元素内部创建SVG元素，其面积为200像素宽和100像素高。
- en: Exploring series update
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索系列更新
- en: The series update is one of the most frequent tasks performed in charts. In
    this section, we investigate it in high definition. In Highcharts, there are several
    approaches to updating a series. Generally, we can update a series from a series
    or data point level. Then, the update method itself can either be actually changing
    the value, or reinserting it. We will discuss each approach and create a comprehensive
    example to experiment with all the techniques.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 系列更新是在图表中执行的最频繁的任务之一。在本节中，我们将以高清晰度研究它。在Highcharts中，有几种更新系列的方法。通常，我们可以从系列或数据点级别更新系列。然后，更新方法本身可以是实际更改值，也可以是重新插入它。我们将讨论每种方法，并创建一个综合示例来实验所有技术。
- en: 'In order to compare each approach, we will continue to use stock market data
    but we will change the user interface this time to enable replaying the historical
    stock price. The following is the screenshot of the example in action:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较每种方法，我们将继续使用股票市场数据，但这次我们将改变用户界面以启用回放历史股票价格。以下是示例操作的截图：
- en: '![Exploring series update](img/7451OS_10_08.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![探索系列更新](img/7451OS_10_08.jpg)'
- en: 'As we can see, there are multiple selection boxes to choose from: how many
    years of historical stock price to replay, how many data points to update in each
    iteration, and how long the wait is in between each update. Most importantly,
    we can choose which series update method should be used; it is interesting to
    observe the behavioral difference between them, especially during the whole replay.
    This demo is also available on my website at [http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html](http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html).
    I strongly recommend readers give it a go. Before we look into each update approach,
    let''s find out how to construct this continuous series update process.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有多个选择框可供选择：要回放多少年的历史股票价格，每次迭代中要更新多少个数据点，以及每次更新之间的等待时间有多长。最重要的是，我们可以选择应该使用哪种系列更新方法；观察它们在整个回放过程中的行为差异很有趣，特别是观察它们的行为差异。这个演示也发布在我的网站上，[http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html](http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html)。我强烈推荐读者尝试一下。在我们深入研究每种更新方法之前，让我们找出如何构建这个连续系列更新过程。
- en: Continuous series update
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续系列更新
- en: 'Once we enter a stock symbol and select the number of years of stock prices
    to replay, we can click on the **Load Data** button to retrieve the price data.
    Once the data arrives, a confirmation dialog pops up with a **Start** button to
    kick-start the process. The following is the action code for the **Start** button:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入股票代码并选择要回放多少年的股票价格，我们就可以点击**加载数据**按钮来检索价格数据。一旦数据到达，就会弹出一个带有**开始**按钮的确认对话框来启动过程。以下是为**开始**按钮的动作代码：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We first create a variable, `histStock`, under the jQuery namespace, that is
    accessed by various parts within the demo. The `histStock` variable holds the
    current user's inputs and the reference to the refresh task. Any changes from
    the user interface update `$.histStock`, so the series update responds accordingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在jQuery命名空间下创建一个变量`histStock`，该变量在演示的各个部分中被访问。`histStock`变量包含当前用户的输入和刷新任务的引用。任何来自用户界面的更改都会更新`$.histStock`，因此系列更新会相应地响应。
- en: 'Basically, when the **Start** button is clicked, we initialize the `$.histStock`
    variable and start an Ajax query with the stock symbol and number-of-years parameters.
    Then, when the stock price data returns from the query, we store the result into
    the variable. We then call `refreshSeries`, which calls itself by the setting
    via a timer routine. The following code is the simplified version of the method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当点击**开始**按钮时，我们初始化`$.histStock`变量，并使用股票符号和年数参数启动一个Ajax查询。然后，当查询返回股票价格数据时，我们将结果存储到变量中。我们随后调用`refreshSeries`，它通过定时器例程调用自身。以下代码是该方法的简化版本：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Inside `refreshSeries`, it inspects the settings inside the `$.histStock` variable
    and updates the series depending on the user's choice. Once the update is done,
    we increment the `offset` value, which is at the start position for copying the
    stock result data into the chart. If the counter variable `i` hits the end of
    the stock data, then it simply exits the method. Otherwise, it will call the JavaScript
    timer function to set up the next loop. The next goal is to review how each update
    method is performed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refreshSeries`内部，它检查`$.histStock`变量内的设置，并根据用户的选择更新系列。一旦更新完成，我们就增加`offset`值，这是将股票结果数据复制到图表的起始位置。如果计数器变量`i`达到股票数据的末尾，它将简单地退出方法。否则，它将调用JavaScript定时器函数来设置下一个循环。下一个目标是回顾每种更新方法是如何执行的。
- en: Testing the performance of various Highcharts methods
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试各种Highcharts方法的性能
- en: 'There are four techniques for updating the series data: `Series.setData`, `Series.remove`/`Chart.addSeries`,
    `Point.update`, and `Series.addPoint`. We measure the performance for all four
    techniques in terms of CPU and memory usage with the Resource Monitor tool. Each
    method is timed when replaying the stock prices for the past year along with 0.5
    seconds of waiting time between each update. We repeated the same run twice and
    recorded the average. The experiment is repeated on a selection of browsers: Firefox,
    Chrome, Internet Explorer 8 and 11, and Safari. Although IE 8 does not support
    SVG and only supports VML, it is important to use it in the experiment because
    Highcharts'' implementation is compatible with IE 8\. One thing that we instantly
    notice is the same chart on IE8 is not as appealing as in SVG.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更新系列数据有四种技术：`Series.setData`、`Series.remove`/`Chart.addSeries`、`Point.update`和`Series.addPoint`。我们使用资源监视器工具测量所有四种技术在CPU和内存使用方面的性能。每种方法在回放过去一年的股票价格时都会被计时，每次更新之间有0.5秒的等待时间。我们重复进行了两次相同的运行，并记录了平均值。实验在Firefox、Chrome、Internet
    Explorer 8和11以及Safari等浏览器上进行了重复。尽管IE 8不支持SVG，只支持VML，但在实验中使用它很重要，因为Highcharts的实现与IE
    8兼容。我们立刻注意到，在IE8上显示的相同图表不如SVG吸引人。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The whole experiment is running on a PC with Windows 7 Ultimate installed, and
    the hardware is 4GB RAM Core 2 Duo 3.06 GHz with an Intel G41 Graphics chipset.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 整个实验在一个安装了Windows 7 Ultimate的PC上运行，硬件配置为4GB RAM Core 2 Duo 3.06 GHz，并配备了Intel
    G41显卡芯片组。
- en: The browser versions are Firefox 31.0, Chrome 36.0.1985, IE11 11.0.9600, Safari
    5.1.7, and IE8 8.0.6001\. Safari may not be a true performance indicator as it
    is rather old for a PC platform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器版本包括Firefox 31.0、Chrome 36.0.1985、IE11 11.0.9600、Safari 5.1.7以及IE8 8.0.6001。Safari可能不是一个真正的性能指标，因为它对于一个PC平台来说相对较旧。
- en: It is no longer possible to install/run IE8 on Windows 7, as Microsoft has discontinued
    support. Although we can set the user agent on IE11 to IE8 and conduct the experiment,
    it doesn't offer a true reflection of IE8 performance. Therefore, we set up another
    system running Windows XP with IE8 on identical hardware.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微软已经停止支持，现在在Windows 7上安装/运行IE8不再可能。虽然我们可以在IE11上设置用户代理为IE8并执行实验，但这并不能真正反映IE8的性能。因此，我们设置了一个运行Windows
    XP且硬件相同的系统，上面安装了IE8。
- en: In the following sections, each series update approach is explained and a performance
    comparison is presented between the browsers. Readers must not use the result
    as a guide to the browser's general performance, which is derived from running
    a myriad of tests in a number of areas. What we are experimenting with here is
    simply how Highcharts performs on each browser in terms of SVG animations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将解释每个系列更新方法，并展示不同浏览器之间的性能比较。读者不应将结果作为浏览器一般性能的指南，因为浏览器的一般性能是通过在多个领域的众多测试中得出的。我们在这里实验的是Highcharts在各个浏览器上针对SVG动画的性能。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the results are different compared to what was presented in the previous
    edition. This is mainly due to using a more up-to-date version of Highcharts:
    we use 4.0.3 in this experiment, whereas 2.2.24 is documented in the previous
    edition.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与上一版中展示的结果相比，结果有所不同。这主要是因为使用了更新版本的Highcharts：我们在这次实验中使用的是4.0.3，而上一版中记录的是2.2.24。
- en: Applying a new set of data with Series.setData
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Series.setData应用新数据集
- en: 'We can apply a new set of data to an existing series using the `Series.setData`
    method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Series.setData`方法将一组新数据应用到现有的系列上：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The data can be an array of one dimensional data, an array of x and y value
    pairs, or an array of data point objects. Note that this method is the simplest
    form of all the approaches, and doesn''t provide any animation effects at all.
    Here is how we use the `setData` function in our example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是一维数据的数组，x和y值对的数组，或者数据点对象的数组。请注意，这种方法是所有方法中最简单的一种，并且根本不提供任何动画效果。以下是我们如何在示例中使用`setData`函数：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are two sets of animations appearing in the chart: *x*-axis labels moving
    from the center of the chart and the data points in the series. Although the series
    scrolls smoothly, the movement of the *x*-axis labels appears too quickly and
    becomes choppy. The following graph shows the performance comparison when using
    the `setData` method across the browsers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中出现了两组动画：*x*轴标签从图表中心移动，以及系列中的数据点。尽管系列滚动得很平滑，但*x*轴标签的移动看起来太快，变得断断续续。以下图表显示了使用`setData`方法在浏览器之间性能比较：
- en: '![Applying a new set of data with Series.setData](img/7451OS_10_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用Series.setData应用新数据集](img/7451OS_10_14.jpg)'
- en: There are minor differences in terms of CPU usage, except for IE8 that runs
    on VML instead of SVG. IE8 consumed much higher CPU usage and took much longer
    to finish. The animation lagged throughout the experiment. Among the browsers,
    Safari is marginally the best. Out of all the browsers, Firefox has the highest
    memory footprint, whereas IE 11 had the smallest. Perhaps a slight surprise is
    that Safari has a better performance than Firefox and is also very close to Chrome.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU使用方面，除了运行在VML而不是SVG上的IE8之外，存在一些细微的差异。IE8消耗了更高的CPU使用率，并且完成时间更长。在整个实验过程中，动画都出现了滞后。在所有浏览器中，Safari的表现略好。在所有浏览器中，Firefox的内存占用最大，而IE
    11的内存占用最小。也许一个轻微的惊喜是，Safari的性能优于Firefox，并且也非常接近Chrome。
- en: Using Series.remove and Chart.addSeries to reinsert series with new data
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Series.remove和Chart.addSeries重新插入带有新数据的系列
- en: 'Alternatively, we can remove the whole series with the `Series.remove` method,
    then rebuild the series options with the data and reinsert a new series using
    `Chart.addSeries`. The downside of this approach is that the internal index for
    the default colors and point symbols is incremented, as we found in the earlier
    example. We can compensate for that by specifying the color and the marker options.
    Here is the code for the `addSeries` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`Series.remove`方法删除整个系列，然后用数据和系列选项重建系列，最后使用`Chart.addSeries`重新插入一个新的系列。这种方法的一个缺点是，默认颜色和点符号的内部索引会增加，正如我们在早期示例中发现的那样。我们可以通过指定颜色和标记选项来补偿这一点。以下是`addSeries`方法的代码：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this experiment, we use the refresh rate for every half-second, which is
    shorter than the time span of the default animation. Therefore the series update
    appears erratic without much animation, as in `setData`. However, if we change
    the refresh rate to 3 seconds or more, then we can see the series being redrawn
    from the left-hand to the right-hand side in each update. Unlike other methods,
    the x-axis labels are updated without any animations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们使用每半秒的刷新率，这比默认动画的时间跨度要短。因此，系列更新看起来没有多少动画，就像在`setData`中一样，显得不规则。然而，如果我们把刷新率改为3秒或更长，那么我们就可以看到每次更新时系列从左侧到右侧的重绘。与其它方法不同，x轴标签的更新没有任何动画：
- en: '![Using Series.remove and Chart.addSeries to reinsert series with new data](img/7451OS_10_23.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用Series.remove和Chart.addSeries重新插入带有新数据的系列](img/7451OS_10_23.jpg)'
- en: 'The following graph shows the performance comparison when using the `addSeries`
    method across the browsers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用`addSeries`方法在浏览器之间性能比较：
- en: '![Using Series.remove and Chart.addSeries to reinsert series with new data](img/7451OS_10_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用Series.remove和Chart.addSeries重新插入带有新数据的系列](img/7451OS_10_15.jpg)'
- en: Since this approach seems to have the least animation, the CPU usage levels
    are relatively low across all the browsers, as is the memory usage. As expected,
    IE8 consumes the most resources. Next is IE11, which is roughly on a par with
    Chrome. The most unusual result is that Firefox requires significantly less CPU
    usage than both Chrome and Safari when there is little animation. We will investigate
    this further in a later section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法似乎动画最少，因此所有浏览器的 CPU 使用率水平相对较低，内存使用也是如此。正如预期的那样，IE8 消耗的资源最多。其次是 IE11，其性能与
    Chrome 大致相当。最不寻常的结果是，当动画较少时，Firefox 的 CPU 使用量比 Chrome 和 Safari 都要少得多。我们将在稍后的部分进一步调查这一点。
- en: Updating data points with Point.update
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Point.update 更新数据点
- en: 'We can update individual data points with the `Point.update` method. The update
    method has a similar prototype to `setData`, which accepts a single value, an
    array of x and y values, or a data point object. Each update call can be redrawn
    into the chart with or without animation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Point.update` 方法更新单个数据点。更新方法具有与 `setData` 相似的原型，它接受单个值、x 和 y 值的数组或数据点对象。每次更新调用都可以带动画或不带动画地重新绘制到图表中：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is how we use the `Point.update` method: we traverse through each point
    object and call its member function. In order to save CPU time, we set the `redraw`
    parameter to `false` and call `Chart.redraw` after the last data point is updated:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用 `Point.update` 方法的：我们遍历每个点对象并调用其成员函数。为了节省 CPU 时间，我们将 `redraw` 参数设置为
    `false`，并在最后一个数据点更新后调用 `Chart.redraw`：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Point.update` animates each data point vertically. It gives a wavy effect
    overall as the graph is progressively updated. In the same way as the `setData`
    method, the labels approach the x-axis line diagonally. The following graph shows
    the performance comparison of the `Point.update` method across the browsers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point.update` 方法垂直动画每个数据点。随着图表的逐步更新，整体上产生波浪效果。与 `setData` 方法类似，标签以对角线方式接近
    x 轴线。以下图表显示了 `Point.update` 方法在各个浏览器中的性能比较：'
- en: '![Updating data points with Point.update](img/7451OS_10_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Point.update 更新数据点](img/7451OS_10_16.jpg)'
- en: As the animations are pretty much the same as the `setData` approach, the performance
    shown in the preceding chart is very close to the results of the `setData` performance
    experiment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动画与 `setData` 方法几乎相同，因此前面图表中显示的性能与 `setData` 性能实验的结果非常接近。
- en: Removing and adding data points with Point.remove and Series.addPoint
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Point.remove 和 Series.addPoint 移除和添加数据点
- en: 'Instead of updating each individual data point, we can use `Point.remove` to
    remove data points within the `series.data` array and use `Series.addPoint` to
    add new data points back into the series:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要逐个更新每个数据点，可以使用 `Point.remove` 来从 `series.data` 数组中移除数据点，并使用 `Series.addPoint`
    将新的数据点重新添加到系列中：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As for the time series data, we can use `addPoint` along with the `shift` parameter
    set to `true`, which will automatically shift the series point array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间序列数据，我们可以使用 `addPoint` 并将 `shift` 参数设置为 `true`，这将自动移动系列点数组：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following graph shows the performance comparison of the `addPoint` method
    across the browsers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 `addPoint` 方法在各个浏览器中的性能比较：
- en: '![Removing and adding data points with Point.remove and Series.addPoint](img/7451OS_10_17.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Point.remove 和 Series.addPoint 移除和添加数据点](img/7451OS_10_17.jpg)'
- en: There is hardly any difference between the `addPoint` method, `setData,` and
    `update` in terms of both CPU and memory usage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CPU 和内存使用方面，`addPoint` 方法、`setData` 和 `update` 几乎没有区别。
- en: Exploring SVG animation performance on browsers
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索浏览器上的 SVG 动画性能
- en: So far, we have seen that the level of CPU usage increased with animations.
    However, the question left unanswered is why Safari had lower CPU consumption
    than Chrome and Firefox. A number of browser benchmark suites have been run on
    the test machine to confirm the general consensus that the Firefox and Chrome
    browsers have overall better performance than Safari.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到 CPU 使用率随着动画的增加而增加。然而，尚未回答的问题是为什么 Safari 的 CPU 消耗低于 Chrome 和 Firefox。在测试机器上运行了多个浏览器基准测试套件，以确认普遍共识，即
    Firefox 和 Chrome 浏览器在整体性能上优于 Safari。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All browsers were benchmarked with SunSpider [http://www.webkit.org/perf/sunspider/sunspider.html](http://www.webkit.org/perf/sunspider/sunspider.html),
    Google's V8 Benchmark suite [http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html),
    and Peacekeeper [http://peacekeeper.futuremark.com/](http://peacekeeper.futuremark.com/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有浏览器都使用 SunSpider [http://www.webkit.org/perf/sunspider/sunspider.html](http://www.webkit.org/perf/sunspider/sunspider.html)、谷歌的
    V8 基准测试套件 [http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html)
    和 Peacekeeper [http://peacekeeper.futuremark.com/](http://peacekeeper.futuremark.com/)
    进行基准测试。
- en: 'Nonetheless, there is one particular area where Safari has better performance
    than the other browsers: SVG animations; this is reflected in our previous experiments.
    Here, we use a benchmark test, written by Cameron Adams, that is especially designed
    to measure SVG animations with bouncing particles in frames per second. The test
    (HTML5 versus Flash: Animation Benchmarking [http://www.themaninblue.com/writing/perspective/2010/03/22/](http://www.themaninblue.com/writing/perspective/2010/03/22/))
    was originally written to compare various HTML5 animation technologies against
    Flash. Here, we run the SVG test with the Chrome and Safari browsers. The following
    is a Safari screenshot running with a 500-particle test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Safari 在一个特定领域比其他浏览器有更好的性能：SVG 动画；这一点在我们之前的实验中已经体现出来。在这里，我们使用由 Cameron
    Adams 编写的基准测试，专门用于测量每秒帧数中的弹跳粒子 SVG 动画。这个测试（HTML5 与 Flash：动画基准测试 [http://www.themaninblue.com/writing/perspective/2010/03/22/](http://www.themaninblue.com/writing/perspective/2010/03/22/））最初是为了比较各种
    HTML5 动画技术与 Flash 的。在这里，我们使用 Chrome 和 Safari 浏览器运行 SVG 测试。以下是在 500 个粒子测试下运行的 Safari
    截图：
- en: '![Exploring SVG animation performance on browsers](img/7451OS_10_18.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器上探索SVG动画性能](img/7451OS_10_18.jpg)'
- en: 'As for Chrome, the test is running at around 165 FPS. We repeat the assessment
    with various numbers of particles on both browsers. The following graph summarizes
    the performance difference with regard to SVG animations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Chrome，测试运行在大约 165 FPS。我们在两个浏览器上使用不同数量的粒子重复评估。以下图表总结了 SVG 动画方面的性能差异：
- en: '![Exploring SVG animation performance on browsers](img/7451OS_10_20.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器上探索SVG动画性能](img/7451OS_10_20.jpg)'
- en: As we can see, Safari manages a higher frame rate with particles fewer than
    3,000\. After that, the Safari performance starts to degrade in parallel with
    Chrome. Firefox has a consistently lower frame rate and the frame rate drops considerably
    compared to the others.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Safari 在粒子数少于 3,000 个时能够管理更高的帧率。之后，Safari 的性能开始与 Chrome 并行下降。Firefox 的帧率始终较低，并且与其他浏览器相比帧率下降得相当多。
- en: 'This leads to another inevitable question: why is there such a difference,
    given that both browsers run with the same code base of webkit? It is difficult
    to pinpoint where the discrepancy lies. However, one of the few differences between
    both products is the JavaScript engines, which may affect that area, or possibly
    it is caused by the minor difference in the webkit version. In addition, other
    specific SVG performance tests in [http://jsperf.com](http://jsperf.com) have
    also been run, in which Safari again had a higher score than Chrome.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个不可避免的问题：既然两个浏览器都运行在相同的 webkit 代码库上，为什么会有如此大的差异？很难确定差异所在。然而，这两个产品之间少数几个差异之一是
    JavaScript 引擎，这可能会影响该区域，或者可能是由于 webkit 版本之间的微小差异造成的。此外，[http://jsperf.com](http://jsperf.com)
    上也运行了其他特定的 SVG 性能测试，其中 Safari 再次比 Chrome 得分高。
- en: In the next section, we will see how Highcharts' performance corresponds to
    the data size.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到 Highcharts 的性能如何与数据大小相对应。
- en: Comparing Highcharts' performance on large datasets
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较Highcharts在大型数据集上的性能
- en: 'Our final test is to observe how Highcharts performs with large data sets.
    In this experiment, we are going to plot scatter series across various data sizes
    and observe the time taken to display the data. We chose to use the scatter series
    because, when there is a very large data set with tens of thousands of samples,
    the user is likely to plot only data points on the chart. Here is the simplified
    code illustrating how we do it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终测试是观察 Highcharts 在大型数据集上的表现。在这个实验中，我们将绘制不同数据大小的散点系列，并观察显示数据所需的时间。我们选择使用散点系列，因为当存在包含数万个样本的非常大的数据集时，用户很可能会在图表上仅绘制数据点。以下是说明我们如何操作的简化代码：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The page is loaded with URL parameters to specify the dataset size. We start
    timing before the chart object is created and stop at the callback handler in
    the constructor, `Chart`, method. We repeat the experiment with the same dataset
    size on each browser used in the previous benchmarking experiments. Once the page
    is loaded on a browser, the dataset is randomly generated. Then, timing begins
    just before the chart object is constructed and stops at the callback method in
    Highcharts. The chart function is executed when the chart is finally displayed
    onto the screen. The following screenshot shows the time taken to display 3,000
    data points on the Safari browser:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 页面通过 URL 参数加载，以指定数据集大小。我们在创建图表对象之前开始计时，并在构造函数中的 `Chart` 方法回调处理程序处停止。我们使用在之前的基准测试实验中使用的每个浏览器重复具有相同数据集大小的实验。一旦页面在浏览器上加载，数据集就会随机生成。然后，在图表对象构建之前开始计时，并在
    Highcharts 中的回调方法处停止。当图表最终显示在屏幕上时，执行图表函数。以下截图显示了在 Safari 浏览器上显示 3,000 个数据点所需的时间：
- en: '![Comparing Highcharts'' performance on large datasets](img/7451OS_10_21.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![比较 Highcharts 在大数据集上的性能](img/7451OS_10_21.jpg)'
- en: 'The following graph illustrates Highcharts'' performance on different browsers
    with various dataset sizes. The lower the line, the less time it takes to display
    the number of data points, which indicates better performance:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了不同数据集大小下 Highcharts 在不同浏览器上的性能。线条越低，显示数据点数量所需的时间越少，这表明性能越好：
- en: '![Comparing Highcharts'' performance on large datasets](img/7451OS_10_22.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![比较 Highcharts 在大数据集上的性能](img/7451OS_10_22.jpg)'
- en: None of the browsers take particularly long to display large datasets. This
    shows the impressive scalable performance of Highcharts. Even IE 11, which is
    consistently slower in all tests, only takes 5.3 seconds to render 50,000 data
    points. As for smaller datasets, there is hardly any difference in timing. Both
    Firefox and Safari have very similar results, although Firefox is marginally better.
    This is due to the fact that there is no animation in scatter series and Firefox
    generally performs better without SVG animation. This also supports our findings
    in the least animated `addSeries` experiment, where Firefox required less CPU
    usage. As for Chrome, its performance is roughly equidistant between Safari/Firefox
    and IE 11.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 没有浏览器在显示大数据集时特别耗时。这显示了 Highcharts 令人印象深刻的可扩展性能。即使是所有测试中始终较慢的 IE 11，也只需 5.3 秒就能渲染
    50,000 个数据点。至于较小的数据集，计时几乎没有差异。Firefox 和 Safari 的结果非常相似，尽管 Firefox 略好。这是因为散点系列中没有动画，Firefox
    通常在没有 SVG 动画的情况下表现更好。这也支持我们在最不活跃的 `addSeries` 实验中的发现，其中 Firefox 需要更少的 CPU 使用量。至于
    Chrome，其性能大致位于 Safari/Firefox 和 IE 11 之间。
- en: From all these experiments, we can conclude that Safari performs the best with
    Highcharts (on a Windows PC), particularly when there are a lot of SVG animations
    in the chart. If a chart is static, then Firefox gives the best performance. IE
    11 has the best memory utilization among the browsers but runs slower. Chrome
    achieves a consistent mid-range performance. We must stress that SVG is only one
    of the many areas of performance testing and Chrome has outperformed other browsers
    in the benchmark score.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些实验中，我们可以得出结论，Safari 在 Windows PC 上使用 Highcharts 时表现最佳，尤其是在图表中有大量 SVG 动画时。如果图表是静态的，那么
    Firefox 会提供最佳性能。IE 11 在浏览器中具有最佳的内存利用率，但运行速度较慢。Chrome 实现了稳定的中间性能。我们必须强调，SVG 只是性能测试的许多领域之一，Chrome
    在基准分数中优于其他浏览器。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied the Highcharts APIs, from the class model to applying
    them in applications. Then we performed a comprehensive study of the different
    techniques for updating a chart series in Highcharts, and carried out an experiment
    to analyze the difference in their performance. Finally, the chapter finished
    by analyzing the speed of different web browsers when rendering data points with
    regard to different sizes of large datasets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Highcharts API，从类模型到将其应用于应用程序。然后我们对 Highcharts 中更新图表系列的不同技术进行了全面研究，并进行了实验以分析它们的性能差异。最后，本章通过分析不同大小的大数据集在渲染数据点时的不同网页浏览器的速度来结束。
- en: In the next chapter, we will look into Highcharts events handling, which is
    closely related to Highcharts APIs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Highcharts 事件处理，这与 Highcharts API 密切相关。
