<html><head></head><body>
        

                            
                    <h1 class="header-title">Universal Web Components</h1>
                
            
            
                
<p>In the last chapter, we talked about the various life cycle callback methods of Web Components. In this chapter, we will look into the styling of Web Components, with a lot of examples. Styling plays a vital role in the look and feel of a Web Component. We will also be taking a look at what accessibility does to our Web Components and understand the meaning of the Gold Standard Checklist and how this Gold Standard Checklist makes a Web Component extremely usable.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Styling Web Components</li>
<li class="h1">Accessibility for Web Components</li>
<li class="h1">Gold Standard Checklist</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Styling Web Components</h1>
                
            
            
                
<p>In the previous chapters, we looked at custom elements that use a shadow DOM for encapsulation and custom elements that do not use a shadow DOM. We will be styling our Web Component for both of these types.</p>
<p>Let's say, we have a Web Component called <kbd>&lt;company-header&gt;</kbd>. For the sake of simplicity, this header component needs to have an icon on the left-hand side with a circular border and this icon needs to be a link; the name of the page should be right next to the icon, and then there should be two other links on the extreme right-hand side, say home and about us.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a0d805b8-26db-4d38-9caf-b4a4d2193a64.png" style="width:35.58em;height:4.58em;"/></p>
<p>This is how it should be used inside the <kbd>index.html</kbd> file:</p>
<pre>&lt;company-header <br/>   icon="icon.png"<br/>    page-name="My Page"&gt;<br/>&lt;/company-header&gt;</pre>
<p>If you are being a little bit adventurous, I would like you to stop reading for a while and write the completed code for this component based on the knowledge you have achieved in the previous chapters. Once you have done so, feel free to continue reading.</p>
<p>Now, based on the information provided as a requirement for the component, our <kbd>index.html</kbd> file would look something like this:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Custom header&lt;/title&gt;<br/><br/>    &lt;!--<br/>      Notice how we use type="module"<br/>    --&gt;<br/>    &lt;script type="module"&gt;<br/><br/>      import CompanyHeader from './CompanyHeader.js';<br/><br/>      // We are now defining the custom element<br/>      customElements.define('company-header', CompanyHeader);<br/>    &lt;/script&gt;<br/><br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/><br/>    &lt;company-header<br/>        icon="icon.png"<br/>        page-name="My Page"&gt;<br/>    &lt;/company-header&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>As you can see, we have done nothing different other than the way we are calling the <kbd>&lt;company-header&gt;</kbd> component. Let's take a look at the <kbd>CompanyHeader.js</kbd> file. Note that we are going to use the Web Component without a shadow DOM in this example:</p>
<pre>// CompanyHeader.js<br/><br/>export default class CompanyHeader extends HTMLElement {<br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    // Lets provide a default icon<br/>    this.icon = 'newicon.jpeg';<br/><br/>    // Then lets render the template<br/>    this.render();<br/>  }<br/><br/>  render() {<br/>    this.innerHTML = this.getTemplate();<br/>  }<br/><br/>  // Lets get icon and page-name from attributes<br/>  static get observedAttributes() {<br/>    return ['icon', 'page-name'];<br/>  }<br/><br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name == 'icon') {<br/>      this.icon = newValue;<br/>    }<br/><br/>    if (name == 'page-name') {<br/>      this.pageName = newValue;<br/>    }<br/><br/>    // Lets re-render after getting the new attributes<br/>    this.render();<br/>  }<br/><br/>  getTemplate() {<br/>    return `<br/>      &lt;a href="/"&gt;<br/>        &lt;img class="icon" src="img/${this.icon}" /&gt;<br/>      &lt;/a&gt;<br/>      &lt;h1 class="heading"&gt;${this.pageName}&lt;/h1&gt;<br/>      &lt;div&gt;<br/>        &lt;a class="header-links" href="/home.html"&gt;Home&lt;/a&gt;<br/>        &lt;a class="header-links" href="/aboutus.html"&gt;About Us&lt;/a&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>  }<br/>}<br/><br/></pre>
<p>The <kbd>constructor()</kbd> interface is responsible for making sure that <kbd>icon</kbd> is set to a default file and the component renders properly without any issue. We also learned in the previous section about <kbd>attributeChangedCallback()</kbd>, so <kbd>get observedAttributes()</kbd> is simply creating a list of attributes to listen to for changes.</p>
<p>Furthermore <kbd>attributeChangedCallback()</kbd> is making sure that the changed attribute values are being used properly. The <kbd>getTemplate()</kbd> method simply returns an ES6 template string, which can be set as <kbd>innerHTML</kbd> of the Web Component.</p>
<p>Now that our Web Component is working fine, let's add the style for this component. Inside the <kbd>index.html</kbd> file, we can create a <kbd>&lt;style&gt;</kbd> tag and add our styles inside it:</p>
<pre>&lt;style&gt;<br/>  company-header {<br/>    display: flex;<br/>    background: #44afdc;<br/>    align-items: center;<br/>    padding: 0 10px;<br/>  }<br/>  .icon {<br/>    width: 50px;<br/>    height: 50px;<br/>    border-radius: 50%;<br/>  }<br/>  .heading {<br/>    flex: 1;<br/>    color: white;<br/>    padding-left: 20px;<br/>  }<br/>  .header-links {<br/>    text-decoration: none;<br/>    padding: 20px;<br/>    color: white;<br/>  }<br/>&lt;/style&gt;</pre>
<p>This way, we can have the style attached directly to the <kbd>&lt;company-header&gt;</kbd> element. </p>
<p>However, now we may have a problem. There might be some other <kbd>div</kbd> with the class name <kbd>.heading</kbd>, and this CSS might bleed out to that other class. You may argue that we should namespace our CSS by adding <kbd>company-header</kbd> in front of the CSS used, making it look like the following:</p>
<pre>&lt;style&gt;<br/>  company-header {<br/>    display: flex;<br/>    background: #44afdc;<br/>    align-items: center;<br/>    padding: 0 10px;<br/>  }<br/>  company-header .icon {<br/>    width: 50px;<br/>    height: 50px;<br/>    border-radius: 50%;<br/>  }<br/>  company-header .heading {<br/>    flex: 1;<br/>    color: white;<br/>    padding-left: 20px;<br/>  }<br/>  company-header .header-links {<br/>    text-decoration: none;<br/>    padding: 20px;<br/>    color: white;<br/>  }<br/>&lt;/style&gt;</pre>
<p>This may fix the problem a little bit, but does not fix it completely. It still doesn't fix the part where the <kbd>.heading</kbd> class CSS bleeds out to the <kbd>.heading</kbd> class in <kbd>company-header</kbd> and then gets overwritten by the <kbd>company-header</kbd> namespaced heading class. Hence, comes our shadow DOM specification. </p>
<p>Let us try to write the Web Component with a shadow DOM:</p>
<pre>// CompanyHeader.js<br/><br/>export default class CompanyHeader extends HTMLElement {<br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    // Lets provide a default icon<br/>    this.icon = 'newicon.jpeg';<br/><br/>    // lets create our shadow root<br/>    this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>    // Then lets render the template<br/>    this.render();<br/>  }<br/><br/>  render() {<br/><br/>    this.shadowObj.innerHTML = this.getTemplate();<br/>  }<br/><br/>  // Lets get icon and page-name from attributes<br/>  static get observedAttributes() {<br/>    return ['icon', 'page-name'];<br/>  }<br/><br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name == 'icon') {<br/>      this.icon = newValue;<br/>    }<br/><br/>    if (name == 'page-name') {<br/>      this.pageName = newValue;<br/>    }<br/><br/>    // Lets re-render after getting the new attributes<br/>    this.render();<br/>  }<br/><br/>  getTemplate() {<br/>    return `<br/>      &lt;a href="/"&gt;<br/>        &lt;img class="icon" src="img/${this.icon}" /&gt;<br/>      &lt;/a&gt;<br/>      &lt;h1 class="heading"&gt;${this.pageName}&lt;/h1&gt;<br/>      &lt;div&gt;<br/>        &lt;a class="header-links" href="/home.html"&gt;Home&lt;/a&gt;<br/>        &lt;a class="header-links" href="/aboutus.html"&gt;About Us&lt;/a&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>  }<br/>}</pre>
<p>As you can see, most of the code is the same, other than the part where we create a shadow root and add our HTML inside this shadow root. </p>
<p>If you run the code now, you will see that our styles do not apply inside the Web Component. So, the CSS is not bleeding anymore. But, in order to get back our CSS, we will need to add it as the part of the template, making it look like this:</p>
<pre>getTemplate() {<br/>    return `<br/>      &lt;a href="/"&gt;<br/>        &lt;img class="icon" src="img/${this.icon}" /&gt;<br/>      &lt;/a&gt;<br/>      &lt;h1 class="heading"&gt;${this.pageName}&lt;/h1&gt;<br/>      &lt;div&gt;<br/>        &lt;a class="header-links" href="/home.html"&gt;Home&lt;/a&gt;<br/>        &lt;a class="header-links" href="/aboutus.html"&gt;About Us&lt;/a&gt;<br/>      &lt;/div&gt;<br/>      &lt;style&gt;<br/>        :host {<br/>          display: flex;<br/>          background: #44afdc;<br/>          align-items: center;<br/>          padding: 0 10px;<br/>        }<br/>        .icon {<br/>          width: 50px;<br/>          height: 50px;<br/>          border-radius: 50%;<br/>        }<br/>        .heading {<br/>          flex: 1;<br/>          color: white;<br/>          padding-left: 20px;<br/>        }<br/>        .header-links {<br/>          text-decoration: none;<br/>          padding: 20px;<br/>          color: white;<br/>        }<br/>      &lt;/style&gt;<br/>    `;<br/>  }</pre>
<p>Now, our component looks beautiful with all the CSS, but what is <kbd>:host</kbd> ?</p>
<p>While we can add CSS inside the shadow root with the help of selectors, we do not have a selector associated with the shadow root itself, which acts as a container for the HTML. So, we can have CSS attached to this shadow root with the help of the <kbd>:host</kbd> selector.</p>
<p>Let's try another example with styling. Let's say we have a requirement to design a Web Component that lets you log in with the help of a login form. It needs to have a bluish background, and when the login is successful, it should turn this background to a greenish shade. Also, for the sake of simplicity, the username-password check will simply perform a <kbd>Math.random()</kbd> operation and, if this value is greater than <em>0.5</em>, then the login is successful:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e8ff7e8f-0c31-40bb-9093-77fd8c121ce6.png"/></p>
<p>Let's jump into the code. There are no changes to our <kbd>index.html</kbd> other than us including this new component:</p>
<pre>&lt;script type="module"&gt;<br/><br/>  import CompanyLogin from './CompanyLogin.js';<br/><br/>  // We are now defining the custom element<br/>  customElements.define('company-login', CompanyLogin);<br/>&lt;/script&gt;</pre>
<p>The definition of this <kbd>CompanyLogin</kbd> class is shown in the preceding code.</p>
<p>Let's take a look at our HTML template. We want a username text field, a password text field, and a button that can be clicked:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;input type="text" name="username" placeholder="Username"/&gt;<br/>    &lt;input type="password" name="password" placeholder="Password"/&gt;<br/>    &lt;button type="submit" class="login-button"&gt;Login&lt;/button&gt;<br/>  `;<br/>}</pre>
<p>Then we need to add this template HTML to our shadow root:</p>
<pre>// lets create our shadow root<br/>this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>this.shadowObj.innerHTML = this.getTemplate();</pre>
<p>We also need a way to notify our Web Component as to when the button is being clicked:</p>
<pre>connectedCallback() {<br/>  this.shadowObj.querySelector('button')<br/>    .addEventListener('click', (e) =&gt; this.handleLogin(e));<br/>}</pre>
<p>We chose <kbd>connectedCallback()</kbd> for event handling here since we need to bind events only when HTML is on the page. We can handle our click event inside the <kbd>handleLogin()</kbd> method:</p>
<pre>handleLogin(e) {<br/>  this.username = this.shadowObj.querySelector('[name=username]').value;<br/>  this.password = this.shadowObj.querySelector('[name=password]').value;<br/><br/>  // Do what ever you want with these values<br/>  console.log(this.username, this.password);<br/><br/>  // We will do things as per our requirement<br/>  let loginSuccess = Math.random();<br/>  if(loginSuccess &gt; 0.5) {<br/>    this.classList.add('login-success');<br/>  } else {<br/>    this.classList.add('login-failure');<br/>  }<br/>}</pre>
<p>As you can see, we are simply printing the values of username and password. I chose to add a print example so that you have an idea about how it is very easy to read these values. We are also changing the class name of the actual Web Component based on the <kbd>Math.random()</kbd> function.</p>
<p>Now that we have a working component, we can start working on the CSS. We can add our CSS inside our template:</p>
<pre>&lt;style&gt;<br/>  :host {<br/>    background: #68afe8;<br/>    padding: 20px;<br/>    display: flex;<br/>    flex-direction: column;<br/>    width: 400px;<br/>    margin: 0 auto;<br/>  }<br/>  :host(.login-failure) {<br/>    background: #f35353;<br/>  }<br/>  :host(.login-success) {<br/>    background: #499c19;<br/>  }<br/>  input {<br/>    margin-top: 5px;<br/>    padding: 10px;<br/>    height: 30px;<br/>    font-size: 15px;<br/>    border: none;<br/>    border-radius: 5px;<br/>  }<br/>  button {<br/>    margin-top: 15px;<br/>    padding: 10px;<br/>    font-size: 15px;<br/>    border: none;<br/>    height: 50px;<br/>    border-radius: 5px;<br/>    cursor: pointer;<br/>  }<br/>&lt;/style&gt;</pre>
<p class="CDPAlignLeft CDPAlign">We are again using the <kbd>:host</kbd> selector as a way to add CSS to the shadow root of our Web Component. In the <kbd>handleLogin()</kbd> function, we are adding CSS classes to our Web Component. We can target those classes from inside our CSS by using <kbd>:host(&lt;selector&gt;)</kbd> just like we used it in the preceding code.</p>
<p>When we run our Web Component on a browser, it looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4e333b13-70f4-486a-b83d-b624038493ab.png" style="width:17.58em;height:11.83em;"/></p>
<p>Based on the <kbd>random()</kbd> function, we can get either a greenish background, indicating that it is a successful login, or the one with a red background.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessibility for Web Components</h1>
                
            
            
                
<p>Accessibility plays a vital role in web development. Our users can be limited to a keyboard, they might be using a screen reader, or could be color-blind. Making sure that our users are comfortable in all scenarios is the key to making a good site. Similarly, creating a good Web Component also includes making a Web Component accessible. </p>
<p>When you are creating a Web Component, you need to make sure that your Web Components are accessible at least up to a certain extent. For example, an image should always have <kbd>alt</kbd> text. A link should always have <kbd>alt</kbd> text. Input fields should have proper aria-labels. There should be sufficient color contrasts. Tab orders should be in the correct order, and so on. </p>
<p>Now that we know what can be done to make a component accessible, let's take a look at a small example. Let's say the requirement is to create a <kbd>&lt;header-image&gt;</kbd> component that shows a full-width image. In order to make sure that this component is accessible, the image used should have <kbd>alt</kbd> text. </p>
<p>Let's take a look at our <kbd>getTemplate()</kbd> function for this component:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;img src="img/${this.getAttribute('src')}" <br/>         alt="${this.getAttribute('alt')}"/&gt;<br/>    ${this.handleErrors()}<br/>    &lt;style&gt;<br/>      img {<br/>        width: 400px;;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>Here, we are adding an <kbd>alt</kbd> attribute to the image tag, and we are grabbing this <kbd>alt</kbd> text from the Web Component itself:</p>
<pre>&lt;header-image alt="Blue Clouds"<br/>      src="img/clouds-sky-header.jpg"&gt;<br/>&lt;/header-image&gt;  </pre>
<p>We also have an error handler function called <kbd>handleErrors()</kbd>, which makes sure to tell the user that the component is missing <kbd>alt</kbd> text:</p>
<pre>handleErrors() {<br/>  if(!this.getAttribute('alt')) {<br/>    return `<br/>      &lt;div class="error"&gt;Missing Alt Text&lt;/div&gt;<br/>      &lt;style&gt;<br/>        .error {<br/>          color: red;<br/>        }<br/>      &lt;/style&gt;<br/>    `;<br/>  }<br/><br/>  return ``;<br/>}</pre>
<p>This will show a Missing Alt Text error message in red, when the component is missing the alt text. We can solve other accessibility issues in the same way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gold Standard Checklist</h1>
                
            
            
                
<p class="mce-root">We have been creating Web Components in the previous sections, but, other than the accessibility, no other sections tell us what defines a good component. So, let's talk about it. The Gold Standard Checklist is a working draft (see <a href="https://github.com/webcomponents/gold-standard/wiki" target="_blank">https://github.com/webcomponents/gold-standard/wiki</a>) that tells the creators of a Web Component what things should be taken care of in order to create a good, reusable component. </p>
<p class="mce-root">Let's talk about some of the points that I personally feel are important:</p>
<ul>
<li>Web components should be accessible. In order to make the Web Components work on all screens, we need to make sure that the component covers all aspects of accessibility. </li>
<li>Binding of events should be done in <kbd>connectedCallback()</kbd>. This makes sure that the DOM to which events are bound will always be present, thus reducing the number of bugs.</li>
<li>Event bindings should be removed in <kbd>disconnectedCallback()</kbd>, thus freeing up the memory that is not required anymore.</li>
</ul>
<ul>
<li>Components should have default styling with good contrasting colors. This will make sure that components can be seen properly at all times.</li>
<li>Components should also follow responsive designs. In order to make our component work on all screen sizes without any layout issues, we should make sure that we have responsive CSS associated with the Web Component.</li>
<li>Components should be able to expose events. We will be talking about events in <a href="0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml">Chapter 5</a>, <em>Managing States and Props</em>, but the main takeaway from this point is that, if you are building a component that needs to tell other components the change in state, it should tell them by exposing an event callback.</li>
</ul>
<p>Even though the Gold Standard Checklist contains a lot of very good points, I feel that these six points should be able to make a component pretty good in terms of reusability. In case you are curious about the other points, here is the link to the full Gold Standard Checklist:<a href="https://github.com/webcomponents/gold-standard/wiki" target="_blank"> https://github.com/webcomponents/gold-standard/wiki</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked into different ways we can style a Web Component, learned about accessibility and how it can be used in creating a more complete Web Component, and then looked into the Gold Standard Checklist, which provides guidelines for creating a good Web Component.</p>
<p>In the next chapter, we will be looking into reusability and how it can used in Web Components, along with how these Web Components are published on the web for maximum reusability.</p>


            

            
        
    </body></html>