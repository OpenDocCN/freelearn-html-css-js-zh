- en: Chapter 10. Routing, Touch Support, and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will perform the last steps before we customize the theme
    and create the production build of our application. We will cover some different
    topics, such as enabling routing in our application, a quick overview about responsive
    design and Ext JS, touch support, debugging Ext JS apps, and a quick overview
    about testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS routing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive design and touch support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming Ext JS projects into mobile apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Ext JS applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for testing Ext JS applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to find extra and open source plugins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS routing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is a capability introduced in Ext JS 5 that makes the process of handling
    history using the `Ext.util.History` class in the application easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: On a normal website, a user navigates to and from different pages as they click
    links or fill out forms. However, in a single-page application, a user's interaction
    doesn't load a new page. Instead, it is handled within a single page and components
    react to that interaction. So how do we still allow users to use the browser's
    forward and back buttons? Using routes allows the user to use this capability
    by mapping hash tokens to controller methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have a screen to manage the Films information. Using routing,
    we can allow the user to access this screen (if the user has proper entitlements)
    and automatically selects a particular row of the Films grid by accessing `https://localhost/masteringextjs/#films/3`.
    When the user accesses this link, we can instruct the application to open the
    **Films** tab and select the row of the film that has the ID **3**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To enable routes in our application, we are going to use the `Root` Controller
    that was created by Sencha Cmd automatically when we created the application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Default token
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start by enabling a default token. When our application starts,
    it is going to redirect to the `#home` hash token. To do so, we are going to add
    the following code to the `Application.js` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, inside the `Root` Controller, we will listen to this hash and redirect
    to the `onHome` method, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `onHome` method, we want to activate the first tab (**Home**) of
    the `Main Panel`. Use the following code to do this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are using a `getMain` method (`#1`), which refers to a `ref` of the Controller.
    We need to declare it as well. We are going to declare `ref` configuration inside
    the `init` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Loading a Controller programmatically
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this book, you learned that the Controllers are loaded when
    the application is loaded (MVC). As our application has a **Login** screen, we
    do not want to enable the routes when the application is loaded. We only want
    to enable the routes after the user is logged in. The `Root` Controller is going
    to be loaded when the application loads, and we do not want that to happen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `Application.js` we are going to comment the `Root` Controller:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the `Main` View is loaded, we want to initialize the `Root` Controller.
    So we are going to `init` the `Root` Controller inside the `init` method of `main.MainController`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And this is how we create a Controller programmatically in Ext JS. The Router
    will be enabled only after the `Main` View is loaded. We could place all the routes
    inside `MainController`, but it would coexist with the existing code that we have
    in `MainController` already, and maintaining this code in the future could be
    a little difficult. This is also a design decision that we need to make: do we
    keep all the routes inside a single Controller or do we separate the code? Feel
    free to organize the code as you see fit. In big applications, it can be difficult
    to maintain many hash tokens organized in a single Controller.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: With the code we have so far, when we render `https://localhost/masteringextjs`
    application, it will be redirected automatically to `https://localhost/masteringextjs/#home`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Handling routes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the `routes` configuration of the `Root` Controller**,** we will handle
    the possible routes for our application. We will use the `xtypes` we created for
    our application. It is a good thing we kept track of them in the `menu` table
    in our database (`className` column)!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the possible hash tokens we have in our application: `user`,
    `actorsgrid`, `categoriesgrid`, `languagesgrid`, `citiesgrid`, `countriesgrid`,
    `films`, and `salesfilmcategory`. We can define a method for each one of them
    as we developed for the `home` token. But what should be done when the user accesses
    any of these tokens open in the respective tab. So what we want to do is handle
    multiple tokens in a single method. This is the code we will add inside the `routes`
    configuration in the `Root` Controller:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we want to handle several tokens in the same method, we can use `|` to
    separate them. Note that in the preceding code, we are declaring two methods:
    `onBeforeRoute` and `onRoute`. We might want to check whether the user has entitlements
    to access the screen (after all, what is stopping a smart user trying to access
    a screen that the user does not have permission via routing?). So we can handle
    it in the following code (however, this is not necessarily the best way to secure
    an application):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we are using generic code here and we want to send to the `className` parameter
    the user is trying to access to the server, we can retrieve it using the code
    in line `#1`. The `before` action method only receives one parameter, which is
    the `action` parameter. Depending on the result, we can resume it (`#2`), which
    means the user has access to the screen—and the `onRoute` method will be executed
    next. Or, we can stop the action (`#3` and `#4`), which means the `onRoute` method
    will not be executed next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the method `onRoute` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method will call the `locateMenuItem` (`#6`) method passing the `mainmenu`
    reference (`#5`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Refactoring the Menu code
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `locateMenuItem` code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previously mentioned method is searching for a node in each `menutree`
    we created for the menu of the application that matches the hash of the route.
    If we find the node, we call the `openTab` method (`#1`):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we take a look at the code of the `onTreePanelItemClick` method from the
    `Menu` Controller, we will note that it is exactly the same as the `openTab` method.
    Although we are handling routes at the end of this book, it is best if we start
    handling them when we start developing the application. So, if you are planning
    on using routes, make sure routes is part of the design, because it might require
    some code changes if you decide to implement it after the application is developed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onTreePanelItemClick` method will have the following code now:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the user clicks on the `Node` of the `Tree` of the menu we implemented,
    it is going to redirect to the hash of the `className` parameter of the `Node`,
    and the `Root` Controller will handle opening the tab.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Handling unmatched routes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the user tries to access a route that is not defined in the application,
    we can execute some code as well. In the `Root` Controller, we can add the following
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And we can display an error message to the user, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Handling parameters
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s develop more complex route handling. For the **Films** screen, let''s
    say we want the user to be able to select a row from the Films grid using a hash
    token, as demonstrated in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling parameters](img/0457OT_10_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'We can define the following route:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This means the user can try to access a URL with the format `https://localhost/masteringextjs/#films/2`.
    If the user tries to access `https://localhost/masteringextjs/#films/ace`, it
    is not valid because of the condition of the `id` parameter—it needs to be a numeric
    value. This means we can also define regular expressions to validate the parameters
    of hash tokens.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we execute `onFilmSelect`, we want to do a few things:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to open the **Films** screen (`#1`) and check whether the record the
    user wants to select exists in the Store. If the result is positive, continue
    the execution and if not, stop it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference for `filmsGrid` is given here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, the reference for the `onFilmSelect` method is given here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to fire the `selectfilm` event of `films-grid`, as shown in the
    following code; this requires some new code inside the `FilmsGrid` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are going to handle the listeners in the `FilmsController` class, as shown
    in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What we are doing in the preceding code is finding the record by `film_id` given
    and selecting it in `FilmsGrid`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on a row of the grid, the `onItemClick` method will be
    fired:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are simply going to redirect the request to the `Route` Controller so that
    it can handle the selection with the code we developed in this topic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned before, routing can become very complex in some applications, so
    the best thing is to start handling them from the very beginning of development.
    For more details, please check out Sencha guides and documentation about routing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Using the responsive design plugin
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another new capability introduced in Ext JS 5 is the option to develop responsive
    applications. Mobile devices are part of our lives. We basically have a computer
    in our pockets. It is very common nowadays to have tablet or mobile compatible
    as an item listed in a user requirements document. Fortunately, Ext JS 5 provides
    good support and allows us to achieve this requirement without too much effort.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 5 introduces the responsive plugin and mixin. The plugin can be used
    in any component, and the mixin can be used in any other class. This plugin responds
    dynamically to changes in screen size and orientation by controlling `responsiveConfig`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s do a quick example in our project. If the width of the
    screen is less than 768 pixels and the screen is in `tall` mode, we are going
    to hide the application menu and display a new button that is going to render
    the menu as displayed in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the responsive design plugin](img/0457OT_10_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'In the `Packt.view.main.Main` class, we are going to add the responsive plugin
    to the `west` region. The code is presented as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inside `responsiveConfig`, we can add some conditions and set the component's
    configuration accordingly. We can change the layout, render a different component,
    and do whatever is needed in the application. With only the preceding code, if
    we execute the application and decrease the browser's width, we will see the menu
    will be hidden automatically when the criteria are met. It is really nice!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Packt.view.main.Header`, we are going to add a new component as well, as
    follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code for this component is presented as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are reusing the menu we developed at the beginning of this book. Of course,
    we could develop a UX that is more user friendly, but we are just focusing on
    the functionality here for a quick test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Chrome has a really nice feature if we need to work with responsive
    design. It is the capability of emulating the project in different devices to
    see how they are going to look. In Google Developer Tools, click on the mobile
    device icon as shown in the following screenshot and start the adventure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the responsive design plugin](img/0457OT_10_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Ext JS 5 and responsive design, please read [http://www.sencha.com/blog/designing-responsive-applications-with-ext-js](http://www.sencha.com/blog/designing-responsive-applications-with-ext-js)
    and check the source code of this example [http://goo.gl/odce6j](http://goo.gl/odce6j).
    Firefox also has a mobile view in its developer toolbar. Go to **Tools** | **Web
    Developer** | **Responsive Design View**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Enabling touch support
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will quickly discuss responsive design. Since it is not
    the primary topic of this book, we will implement a very simple example that will
    give us an idea of what we need to do if we need to develop a responsive application
    with Ext JS. And speaking of responsive design, we know Ext JS is great to develop
    desktop applications (that will be executed from a desktop computer or a laptop),
    but mobiles have now become a very integral part of our lives. We will figure
    out the means to run the same application running on a desktop and also on a mobile
    device. We will also discuss how to enable touch support in our application as
    well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between running an application on a desktop and a mobile
    device is the events, among other details. On a desktop, when the user clicks
    on a button, we listen to the `click` event. On a touch mobile device, there is
    no `click` event; there is the `tap` event, because we are touching the screen
    and not working with a mouse.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Another detail is the size of the components. The Ext JS classic theme is really
    nice, but small for touch screens. Throughout this book, we have been using the
    `Neptune` theme, which is the default theme set to the application when we created
    it with Sencha Cmd. The `Neptune` theme has larger components than the `classic`
    theme but still is not good enough to be used on touch devices. Let's experiment!
    If you have a touch device, try executing the application we developed throughout
    this book on it. If you do not have a touch device, you need not worry; you can
    do this experiment using the Google Chrome emulator mentioned in the preceding
    topic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot exemplifies the application being executed on an iPad
    mini:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling touch support](img/0457OT_10_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: If we try to use the application as is, we will be able to use most of its capabilities.
    Because we are using a desktop theme, with small icons, it will not work 100%
    in a mobile device. For example, the `RowExpander` + button doesn't work very
    well because the + icon is very small for a mobile device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Ext JS 5 introduces new themes that were designed specially for touch devices.
    There is a special version of the `Neptune` theme and also a special version of
    the `Crisp` theme (also introduced in Ext JS 5). We can add the touch support
    to our application by changing the theme in the `app.js` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With `sencha app watch` being executed in a terminal, try changing the theme
    to one of the previously mentioned options. Don''t forget to clean the browser''s
    cache to make sure you will get the new version of the CSS file next time you
    refresh the application. Now let''s try the application again, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling touch support](img/0457OT_10_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Note how there is more space between the components now. This is to make sure
    we can tap (touch) the components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We don't have a touch-optimized application. To make it 100 percent, we can
    review any size that we set (for example, column width) and use some responsive
    design techniques to have the application looking great in mobile devices!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, please visit [http://goo.gl/VnT7bT](http://goo.gl/VnT7bT).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: From Ext JS to mobile
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if the product you are developing requires a special app implement, especially
    for touch devices? We are not talking about the techniques we implemented in the
    previous topic; we are talking about a mobile app for the same product. For example,
    Facebook has a version for desktop, but it also has an app for mobile devices.
    It might be what you need as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to introduce Sencha Touch, the cousin of Ext JS! Sencha Touch
    was the first HTML5 mobile framework on the market. And there''s more good news:
    you do not need to rewrite all of your code to have the same application also
    available to mobile devices.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Sencha Touch and Ext JS share the same API. The data package, such as models,
    stores and the core of the framework, is the same. Sencha Touch also uses MVC.
    The Controller and View (components) work in a way that is very similar to that
    of Ext JS Controller and View. Of course, the biggest difference is in the views
    since a web component is different from a mobile component. However, Sencha Touch
    also offers forms and lists, and we can find even grid components customized for
    mobile devices. The charts are also shared between the frameworks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the analysis of how much code we can reuse after
    using Sencha Touch:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![From Ext JS to mobile](img/0457OT_10_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'The amount of code we can reuse is huge! And we also have two ways of implementing
    it: the first one is to have a mobile app, where the user will access a URL pointing
    to a Sencha Touch deploy (Sencha Touch and server-side code at the same domain).
    And the second option is to have the Sencha Touch code running on the user''s
    device (Sencha Touch offers native packaging to iOS and Android, but we can also
    have native Blackberry 10 and Windows Phone 8 native apps with Sencha Touch) and
    the server-side code running on a server on the Web. In this case, we can use
    CORS ([http://enable-cors.org/](http://enable-cors.org/)) to make the Ajax communication
    between the app and the server-side code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about Sencha Touch, please go to [http://www.sencha.com/products/touch/](http://www.sencha.com/products/touch/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'On mobile, it is also possible to access the hardware features such as contacts,
    camera, geolocation, and more. We can use an open source framework called **Apache
    Cordova** (or **Phonegap**, which is a Apache Cordova implementation). Sencha
    Cmd also has commands that support the integration with Cordova. The following
    links provide more information about this topic:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html](http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://cordova.apache.org/](http://cordova.apache.org/)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://phonegap.com/](http://phonegap.com/)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://vimeo.com/76568053](http://vimeo.com/76568053)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Ext JS applications
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The art of debugging is as important as the art of programming. We usually write
    code that we think is going to work as soon as we execute it, but this is not
    true sometimes. We write the code, then we get an exception or JavaScript error,
    and then we need to dive into the code again to see where we went wrong. It's
    part of being a developer and it is also part of life!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you learned that debugging is important, especially when
    we were learning an easier way to figure out the correct **Component Query** selector.
    When developing applications with Ext JS, it is mandatory to use a debug tool.
    This is so because it is not only for debugging, but you will also be able to
    learn more about the framework, and it is a great learning exercise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things we always need to remind ourselves of while creating Ext JS applications:
    case-sensitive matters—the `LoginScreen` class is different from `Loginscreen`.
    Be careful with reserved words ([http://mattsnider.com/reserved-words-in-javascript/](http://mattsnider.com/reserved-words-in-javascript/))—you
    cannot use them as namespaces, names of classes and packages, or as variable names.
    Check the spelling; this is very important—sometimes when we are typing, we can
    type an extra character (*fat finger* syndrome).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: If you have programmed in JavaScript for almost 10 years now, you will know
    that before, our only friend was the dear `alert` prompt. We used to put several
    alerts on the code, execute it, and then see which alert was not executed so that
    we could find where the error was. Now we have our dear friend `console`. Abuse
    the use of console for `log`, `warn`, and `error`!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We also have great tools to debug! The two most important are Google Developer
    Tools and Firebug for Firefox! Learn to use at least one of them (they are very
    similar).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s use Google Developer Tools. It comes with a few tabs; on
    the **Network** tab, we can see the files that were loaded as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging Ext JS applications](img/0457OT_10_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: And speaking of files that are being loaded or not, this is a very huge deal!
    Simple mistakes, such as the name of the class (using MVC), path of CSS, and JS
    on the `index.html` file, can be verified using the **Console** or the **Network**
    tab. This tab is also very important as in some chapters we verified the parameters
    that were being sent to the server. Even though it might be the first time we
    are working with an Ext JS component, and we do not know how to handle the data
    that will be sent to the server, we can take a look at the parameters of the request
    in the **Network** tab, and then it is easier to read the correct parameters in
    the server. The same applies when we receive any information from the server,
    for example, check whether the JSON is coming as per Ext JS expectations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: On the **Elements** tab, we can see details; the HTML code that was generated
    by the Ext JS code and also the CSS that is being applied to the components. This
    is very useful when we want to apply some custom CSS and debug why the style was
    not applied.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging Ext JS applications](img/0457OT_10_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: When we move the mouse over, the portion related to that HTML is highlighted
    on the screen. We also have the **CSS** and **Script** tabs. We can change the
    CSS and script in real time and see the changes applied in real time! This is
    simply amazing! So, it is very important to learn how to use a debug tool.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Sources** tab, we can take the source code that was loaded in the
    form of the project''s structure. This tab is very important for us because it
    allows us to use the debugging capabilities of the browser to debug our code.
    The debugging technique is very similar to what is used with server-side languages;
    we add a breakpoint, execute the code, and then watch and inspect variable values
    and see what happens in every line of the source code, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging Ext JS applications](img/0457OT_10_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about Firebug, please visit [http://getfirebug.com/](http://getfirebug.com/).
    And to learn more about Google Developer Tools, please visit: [https://developers.google.com/chrome-developer-tools/](https://developers.google.com/chrome-developer-tools/)
    and [https://developer.chrome.com/extensions/tut_debugging](https://developer.chrome.com/extensions/tut_debugging).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, there are the special add-ons we talked about in [Chapter 7](ch07.html
    "Chapter 7. Static Data Management"), *Static Data Management*: Sencha add-on
    for Chrome and Illumination for developers for Firebug.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Mastering one debugging tool is important as mastering the art of programming
    in Ext JS. After all, we don't know if we will have the opportunity to work on
    a project from scratch or we will need to maintain other developers' code. In
    this case, knowing how to debug is a must-have skill! Choose your favorite weapon
    and have fun coding and debugging!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Testing Ext JS applications
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a very important part when developing applications or providing maintenance.
    When we do not write tests, we need to verify each use case manually, and if we
    change anything on the code, we will need to perform all the testing manually
    again. The same happens when we need to maintain the code; developers usually
    test only what has been changed, but the correct thing to do would be regression
    tests to see whether the change did not break anything else. So spending some
    time writing tests can be a win at the end. You will spend a little bit more time
    writing code, but then you will be able to run all the tests with a single click
    and then verify what is broken and what is still working.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We are also very used to performing unit tests on the server-side code. Java,
    PHP, Ruby, C# communities offer a lot of options to perform unit tests on the
    server-side code, and sometimes, we can forget to test the frontend code (in this
    case Ext JS). But do not worry; there are a few tools we can use to include Ext
    JS on the tests as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'One tool that is very popular for JavaScript testing in general is **Jasmine**
    ([http://jasmine.github.io/](http://jasmine.github.io/)). Jasmine is a testing
    tool that is used for **Behavior-Driven Development** (**BDD**)—([http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development)).
    In Ext JS documentation, you can find two guides explaining how to test Ext JS
    applications with Jasmine: [http://docs.sencha.com/extjs/4.2.0/#!/guide/testing](http://docs.sencha.com/extjs/4.2.0/#!/guide/testing)
    and [http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers](http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers).
    Although the guides were written for Ext JS 4.x, they can also be applied to Ext
    JS 5.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There is also a testing framework designed specially for a Sencha application
    called **Siesta** ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/)).
    Siesta can also be used to test JavaScript code in general, but the cool side
    of Siesta is that it provides a special API so that we can test Ext JS applications,
    including tests on user interface components. Siesta comes with some great examples
    that can be used to start writing our own test cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Helpful tools
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this topic, we will present some tools that can help developers a lot while
    implementing Ext JS applications. You can find all the links of the tools mentioned
    here at the end of this topic.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The first tool is **JSLint**. JSLint is a tool that can help you to find JavaScript
    errors and can also help you to clean your code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The second tool is **YSlow**. YSlow analyzes web pages and tells you why they're
    slow based on the rules for high performance websites. YSlow is a Firefox add-on
    integrated with the popular Firebug web development tool.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS is a JavaScript framework, and JavaScript performance is a topic that
    is a concern for a lot of companies. The minimum the user needs to load on the
    browser, the better. That is why it is very important to make a production build
    using Sencha Cmd and not simply deploy all the application files on production.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Sencha Cmd is also going to minify the Ext JS CSS file to a smaller CSS, and
    we can also include only the CSS for the components that we are going to really
    use (just in case we create a custom theme). It is also important to create any
    application custom CSS inside the `sass/etc` or `sass/var` folders so that the
    CSS can also be added to the main CSS file generated by Sencha Cmd.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**CSS Sprites** is another very important topic. Font icons such as Font Awesome
    are really nice, but sometimes that is a need to use image icons. In this case,
    we can create a CSS Sprite, which involves creating a single image with all the
    icons. And on the CSS, we simply have a single image and pass a `background-position`
    property of the icon we want to display, like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are a few tools that can also help us to create CSS Sprites, such as **SpritePad**,
    **SpriteMe**, and **Compass Sprite Generator**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all the links for the tools mentioned in this section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**JSLint**: [http://www.jslint.com/](http://www.jslint.com/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YSlow**: [http://developer.yahoo.com/yslow/](http://developer.yahoo.com/yslow/)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SpritePad**: [http://wearekiss.com/spritepad](http://wearekiss.com/spritepad)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SpriteMe**: [http://www.spriteme.org/](http://www.spriteme.org/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compass Sprite Generator**: [http://compass-style.org/help/tutorials/spriting/](http://compass-style.org/help/tutorials/spriting/)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always remember that Ext JS is JavaScript, so we need to care about performance
    as well. With all these little tips posted on this topic, an Ext JS application
    can improve its performance as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'And last but not least, there are two tools from Sencha: **Sencha** **Architect**
    and **Sencha** **Eclipse** **Plugin**. Sencha Architect is a visual designer tool
    that is very similar to Visual Studio: you drag and drop, and you can see how
    the application looks, and the entire configuration that you need to do is done
    using the **Config** panel. Only methods, functions, and templates are free to
    enter whatever code you like. The good thing about Sencha Architect is that it
    helps to follow all the best practices and the code is very well organized. You
    can also develop all the Ext JS code using Sencha Architect, and on the server
    side, you can continue using the IDE you like the most (Eclipse, Aptana, Visual
    Studio, and others).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: And Sencha Eclipse Plugin is a plugin for the Eclipse IDE that has the autocomplete
    feature enabled. Both Sencha Architect and Sencha Eclipse Plugin are paid tools.
    But you can download a trial version for testing at [http://www.sencha.com/products/complete/](http://www.sencha.com/products/complete/)
    or [http://www.sencha.com/products/architect/](http://www.sencha.com/products/architect/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Eclipse插件是Eclipse IDE的一个插件，它启用了自动完成功能。Sencha Architect和Sencha Eclipse插件都是付费工具。但你可以下载试用版进行测试，地址为[http://www.sencha.com/products/complete/](http://www.sencha.com/products/complete/)或[http://www.sencha.com/products/architect/](http://www.sencha.com/products/architect/)。
- en: Another great IDE to develop Sencha applications is **WebStorm** (or **IntelliJ
    IDEA**). WebStorm also has the autocomplete feature (if we set it up), support
    for Sass and Compass (used by Ext JS for theming), and JSLint to validate the
    JavaScript code, among other features. It is also a paid tool, but you can download
    a trial version for testing at [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/).
    The source of this book was written with IntelliJ IDEA.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于开发Sencha应用程序的出色IDE是**WebStorm**（或**IntelliJ IDEA**）。WebStorm还具备自动完成功能（如果设置正确），支持Sass和Compass（Ext
    JS用于主题的库），以及JSLint来验证JavaScript代码，以及其他功能。它也是一个付费工具，但你可以下载试用版进行测试，地址为[https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)。本书的源代码是用IntelliJ
    IDEA编写的。
- en: Third-party components and plugins
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方组件和插件
- en: 'Although Ext JS provides great components, we usually will also want to develop
    our own components or maybe use other developers'' components. The Ext JS community
    is great regarding this subject. A lot of developers share their own components,
    extensions, and plugins with the community. There are two main places you can
    find them:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ext JS提供了优秀的组件，但我们通常还希望开发自己的组件，或者可能使用其他开发者的组件。在这一点上，Ext JS社区做得很好。许多开发者与社区分享他们自己的组件、扩展和插件。你可以从以下两个主要地方找到它们：
- en: '**Sencha Market**: [https://market.sencha.com/](https://market.sencha.com/)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sencha市场**：[https://market.sencha.com/](https://market.sencha.com/)'
- en: '**Sencha Forum**: [http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins](http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sencha论坛**：[http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins](http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins)'
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to enable routing, and you also quickly overviewed
    responsible design and touch support for Ext JS applications. You learned about
    the importance of knowing how to debug an Ext JS application and about some tools
    that can help us with this task. You also learned that performance is really important
    and that we can do a lot more to improve the performance of our Ext JS application
    with the help of some free tools. We also listed where to find great plugins,
    extensions, and new components that we can use in our projects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何启用路由，并且也快速概述了Ext JS应用程序的责任设计和触摸支持。你了解了了解如何调试Ext JS应用程序的重要性，以及一些可以帮助我们完成这项任务的工具。你还了解到性能非常重要，并且我们可以借助一些免费工具做更多的事情来提高我们Ext
    JS应用程序的性能。我们还列出了在哪里可以找到优秀的插件、扩展和新组件，这些我们可以在项目中使用。
- en: In the next chapter, we will customize the theme for our application, and we
    will perform the production build.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的应用程序定制主题，并执行生产构建。
