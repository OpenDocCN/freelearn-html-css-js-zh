- en: 5\. Beyond the Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to identify the difference between
    JavaScript's mutable and immutable types; manipulate each of the built-in data
    types confidently; convert data from one type to another; format data types for
    presentation; and differentiate between an expression and a statement.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you were given a tour of JavaScript, its runtimes,
    and its history. Using a high-level topography, that chapter will have given you
    an idea as to what JavaScript is, what it can do, and its ubiquity within the
    internet software development industry.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code can be difficult for beginners. JavaScript is no exception.
    Its flexibility, extensive language syntax, and varying coding patterns can prove
    daunting to the uninitiated.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will take you a step closer to writing your own software applications
    in JavaScript. By explaining the fundamentals, you will be empowered to not only
    understand what scripts do, but how to reason about problems using JavaScript
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will take a close look at JavaScript''s type system. All
    programming languages have a type system. Types literally dictate the type of
    data stored in a variable or function parameter. Types are typically separated
    into two categories: **primitive** and **complex** types.'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, all primitive data types are immutable. This means that the value
    cannot be changed in memory. New values can be assigned to a variable, but the
    underlying data stored in memory cannot be modified directly. This differs from
    the case in languages such as C++, where values can be directly altered in memory
    using pointers and helper functions. In JavaScript, when passing a primitive value
    from one variable to another, the data is copied in memory to the new variable.
    Therefore, updating one variable does not affect the other.
  prefs: []
  type: TYPE_NORMAL
- en: Complex data types work differently. They are also known as reference types.
    Reference types include the **Object** type and all of its derivatives, such as
    **Array**, **Date**, and **Function**. All reference types are passed by reference,
    hence the name. Therefore, if an object is modified through one reference, all
    the other references that share the same object will see it as updated too, since
    all of the references point to the same data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: A complex type is simply a type that has more functionality than a primitive.
    For instance, a `Date` value provides additional means of representation, while
    objects can contain many nested values, such as primitives and other complex types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Function types will not be explained in detail in this chapter and will instead
    be covered in a later chapter when prototypes are introduced.
  prefs: []
  type: TYPE_NORMAL
- en: All primitives, and preexisting reference types are known as built-in data types.
    Each of these types has a corresponding object that provides functions for manipulating
    that type. These functions may be applied externally to data by passing the value
    as a parameter to a function, or they may be applied by calling the function as
    if it were a method of that type. The latter is also applicable to several primitives,
    despite them not existing as literal objects within the JavaScript type system.
    However, this is made possible through the syntactical context of the data. More
    will be explained about this feature throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variable creation is the means to assign a value to a symbol. In this circumstance,
    a symbol is a textual representation of the data, much like a container, which
    can be used to move data through your program. It also improves the legibility
    of your code. There are multiple ways to create variables, including assignment
    to the global scope or through the use of either the `var`, `let`, or `const`
    keywords.
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Referencing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even at this early stage, it must be highlighted that JavaScript's referencing
    functionality can get rather confusing. The presence of `closures`, `prototypes`,
    `global` and `local memory stacks`, `variable assignment variations`, and `function
    invocation options` can leave even seasoned programmers scratching their heads.
    Each of the aforementioned features supports JavaScript as a formidable and flexible
    programming language that's able to challenge most other platforms for almost
    any purpose. While it does deepen JavaScript's learning curve, mastering these
    concepts can be extremely rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter highlights the very basics of data referencing and attempts to
    not confuse matters any more than necessary. Only referencing with regard to data
    at the global level will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Global Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assigning a variable without the use of `var`, `let`, or `const` will place
    the variable into the global scope. This value will then be accessible anywhere
    in your application unless a variable of the same name exists within that scope.
    Redeclaring the same variable name without the use of a preceding keyword will
    overwrite the global reference, even if it's assigned within a different scope.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring globally in a browser environment is equivalent to declaring the value
    on the global window object as a field.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring with var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Preceding variable assignment with the `var` keyword places the variable into
    function scope. This means the variable only exists at the same function as the
    assignment, but not outside that function. Declaring with `var` in the global
    scope is equivalent to declaring without the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Redeclaring a variable with `var`, but in a nested scope, will not overwrite
    the variable of the same name in the outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `var` keyword, variables can be scoped (declared) even after they
    are used within the same scope. This is due to variable hoisting. Hoisting was
    explained in *Chapter 4*, JavaScript Libraries and Framework*s*.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring with let
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `let` keyword has a narrower scope. While `var` is considered to be functionally
    scoped, the `let` keyword is block scoped. This means that variables that are
    created with `var` exist throughout a function's scope level, while let-declared
    variables are created and used at the block level, such as in `if` conditional
    blocks or `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using `let`, a variable can be temporarily overwritten within
    a `for loop` while not changing a variable of the same name in the outer function.
    However, if `var` is used instead, the outer variable will be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the variable declared in the `for loop` matches the
    symbol declared outside of it. As such, the same variable reference is modified.
    However, in the following example, the result is different, as the let-declared
    variable only exists within the context of the for loop, meaning the outside variable
    of the same name is left untouched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to `var`, let-declared variables are not hoisted. If a scope declares
    a variable with `let`, accessing that variable before that let declaration statement
    (within the same scope or in any inner scope) will raise an error (this is regardless
    of whether a variable with the same name has been created in an outer scope):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Declaring with const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` keyword works with the same scoping and hoisting rules as the `let`
    keyword. The difference with `const` is that it is assumed the variable will not
    change throughout its lifetime. Using `const` allows the JavaScript engine to
    make certain optimizations at compile time since it expects the data to remain
    constant at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create a new variable assignment with the same name in a nested
    function scope, but it will not be possible to modify a variable of the same name
    using global scoping rules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a variable with var or let, but without assigning a value, will result
    in the variable containing `undefined`. The undefined value will be covered a
    little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Variables and Scope'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the browser''s JavaScript **Read-Eval-Print Loop**
    (**REPL**) to experiment with variable assignment and scope. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch your browser and open the developer tools console. In Chrome, you can
    do this by pressing the *F12* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure the `Console` tab is selected:![Figure 5.1: The Console tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_05_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.1: The Console tab'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the `prompt`, enter the following commands, pressing *Enter* at the end
    of each line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `console.log` command writes the value of `i` to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a function that also initializes a variable of the same name,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the function to print the variable that exists within the function scope.
    If you then print the global variable, you will see it has not been modified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, try the `let` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `let` assignment only exists for the lifetime of the block
    that follows the if statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Close the browser tab. Open a new tab and open the console again (otherwise,
    you won''t be able to re-assign `i` as a variable). Now, try the same with `var`.
    You will see that the variable declaration raises an error because it conflicts
    with the `i` variable outside of the conditional block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.2: Exercise 5.01 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Exercise 5.01 output'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the scope surrounding a variable is important for the correct
    execution of your application, as well as for minimizing bugs. Try to keep a mental
    note of the positioning and use of each variable as you work. Utilizing functional
    paradigms, as discussed in *Chapter 13*, *JavaScript Programming Paradigms*, will
    also help alleviate any discrepancies in variable scoping.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a Variable's Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have created variables and output their value to the browser's console.
    In order to get the most out of the content of this chapter, however, it would
    be helpful to be able to identify the content of a variable. JavaScript is known
    as a weakly typed language because a variable can hold a `string` one moment,
    but then an `integer` the
  prefs: []
  type: TYPE_NORMAL
- en: next. By being able to identify the type of value stored in a variable, you
    prevent errors occurring where you attempt to process a value you expected to
    be of a different type.
  prefs: []
  type: TYPE_NORMAL
- en: The `typeof` keyword exists to do just that. By preceding a variable with the
    `typeof` keyword, the returned value is the type of the variable represented as
    a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `typeof` keyword evaluates with the following type mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Types and responses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Types and responses'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `null` type evaluates as "`object`". This anomaly originates from the earliest
    incarnations of JavaScript where data types were tagged internally with an integer
    value. Object types were tagged with 0, while the `null` value existed as a `null
    pointer` (or `0x00` as a value). As the two expressions were identical, determining
    the type of `null` resulted in the same type as Object. This same anomaly still
    exists in JavaScript today. Therefore, when determining whether a type is an Object,
    we must also compare it with `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 5.02: Evaluating Types from Variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a function that outputs the type of whatever
    variable is passed to it. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt, enter the following line to declare the function signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function accepts a single variable, which will be the variable to analyze.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Due to the Null value caveat, you must check for this, first. Here, compare
    `val` to `Null` and output the appropriate message. If the value is indeed `Null`,
    then the function must be returned so that no further comparisons can be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you are comparing `val` to `Null` and outputting the appropriate message.
    If the value is indeed `Null`, then the function must be returned so that no further
    comparisons can be made.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the value is `not Null`, then you can safely return the type of the value
    itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`console.log(...)` will output however many values are passed into it and concatenate
    them onto the same line. Here, you output the generic message but then concatenate
    it with the type of the variable. Since no value is required to be passed from
    this function, and as there is no more logic to perform, no return statement is
    required to close out the function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test this function, execute it in the console with different values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will result in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.4: Exercise 5.02 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Exercise 5.02 output'
  prefs: []
  type: TYPE_NORMAL
- en: The function you have just created is rather light in terms of introspection.
    It essentially enables you to determine the general type of a passed in value,
    but it isn't powerful enough to differentiate object types, including JavaScript's
    built-in objects. Whether you pass in a `Date` or an `Array`, you will get the
    same output.
  prefs: []
  type: TYPE_NORMAL
- en: You will discover how to be more thorough in determining data types later in
    this module.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixed types are types that have no variation of value. Unlike numbers, which
    may have any combination of digits, an optional minus sign (for negative numbers),
    a decimal point, or a scientific notation, a fixed type is always one simple value
    or value group.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, the available fixed types include `null`, `undefined`, and `Booleans`
    (`true` and `false`). These values are `static` and cannot change. If a variable
    contains one of these values, it is then strictly equal to the value itself. Fixed
    types are more of a representation of a situation than actual data. For instance,
    `true` is a fixed representation of truthfulness and `false` is a fixed representation
    of falsehood. The values are not quantifiable in the real world but are representative
    of logic that software directly deals with.
  prefs: []
  type: TYPE_NORMAL
- en: The null Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`null`, in mathematical terms, denotes a value that is not present. In JavaScript,
    `null` is a static value that''s used to mean no value. In other languages, this
    would be equivalent to nil or void.'
  prefs: []
  type: TYPE_NORMAL
- en: '`null` is a useful value for dereferencing variables or for returning a value
    from a function when no value can be returned. For instance, a function may return
    an object from an array if the item is present but may return `null` if it is
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: The undefined Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`undefined` is similar to `null` in many ways and, due to this, the two values
    are often misused. `undefined` is the value contained in any variable that is
    declared first, but not assigned a value. It is also the value that''s been returned
    from a function that does not explicitly return a value using the `return` keyword
    and it is the value that''s returned from a statement (an action with no resulting
    value).'
  prefs: []
  type: TYPE_NORMAL
- en: When working with `undefined`, you should always anticipate it, but never assign
    it to a variable or return it explicitly from a function. In such circumstances,
    you should use `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Boolean` is a term named after George Boole, a nineteenth-century English
    mathematician and philosopher. It is used to denote the values `true` and `false`.
    These values may be assigned to variables and are strictly equivalent to their
    value, like null.'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are unique among the types supported by JavaScript because they are
    indirectly comparable to other types and expressions. The logical operators described
    in *Chapter 3*, *Programming Fundamentals*, of this book, for instance, all result
    in a `Boolean` value.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean operators are operators that, when combined into an expression, return
    a `Boolean` value. Most Boolean operators are "`binary`" operators that accept
    two values, each of which sit either side of the operator. Like other operators,
    each value can be an expression and can be of any value type. As `Boolean` operators
    themselves form expressions, they can be used as input to other `Boolean` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operators fit into two categories; namely, comparison operators and
    logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comparison operators are used for comparing one value, or the result of an expression,
    with another. The operator in this circumstance may be considered a rule. If the
    rule succeeds, then the response of the combined expression returns `true`. Otherwise,
    it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparison operators include the following symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Comparison operators and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Comparison operators and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators are often used as the condition parameters of if conditionals
    and while loop statements. If or while the condition expression returns true,
    the body block of the expression will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example expressions will all return the value true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the last example in the list, you may be a little surprised.
    The `==` operator is a "value comparison operator". In the example shown, the
    numeric value 1 and the string value "1" are considered the same value. As such,
    the equality operator, which is a "value comparison" operator, will compare them
    as equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to determine whether values are of the same type, as well as the same
    value, "strict comparison operators" should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Equality operators and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Equality operators and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logical operators are often used to concatenate `Boolean` expressions together.
    For instance, when comparing the qualities of a `string` value, you may wish to
    execute code if the `string` is longer than one value but shorter than another.
    In order to do this, you need to join two comparison expressions using the `&&`
    operator. In another condition, you may wish to execute the code if only one of
    the expressions is `true`, in which case, you would use the `||` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists each of the logical operators and what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Logical operators and their description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Logical operators and their description'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Odds and Evens'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will process a series of numbers and output messages describing
    whether a number is either odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll fulfill this exercise using a function so that you can experiment with
    different starting values. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt, create the `odd_or_even` function with a couple of parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `last` parameter will be the ceiling value of the numerical series, while
    the `counter` parameter is both the starting value and the current index variable
    for each loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create your loop using the `while` keyword. while will process a block
    of code as long as the conditional expression is truthy. As the conditional in
    this exercise, you will simply compare `counter` with the `last` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `counter` variable is ever larger than the `last` parameter, then the
    `while` loop will exit, which will also exit the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the `while` conditional in place, you can now begin describing the counter
    value with each iteration. To do this, you simply examine the value of `counter`
    and respond with an appropriate message, depending on its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, increment the `counter` variable by `1` before you close the `while` loop
    block. If you fail to increment, the condition of the `while` loop would always
    be `true`, and the loop will never exit. Also, each iteration of the loop would
    process identically, which is not the result you require:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close out both the `while` block and the function. There is no need to return
    anything from this function as we are not interested in any final values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, execute the function, passing a `counter` value and `last` value as required.
    The output should accurately describe all the numbers from `counter` to `last`,
    inclusively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.8: Exercise 5.03 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Exercise 5.03 output'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go at changing the passed parameters when calling the function. However,
    be sure to keep `counter` to a value less than or equal to the `last` parameter
    or the `while` loop will not execute.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Truth of Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing programs with JavaScript, you will often need to compare values,
    typically when working with conditionals. Often, values will be compared with
    other values, but it is just as likely that you will need to check the truthiness
    of a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing for truthiness can mean many things:'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a value present?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any items in an array?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the string have a length greater than 0?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the passed expression return `true`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript provides a means to pass in a solitary value to conditional statements
    to test for truthiness. However, this can sometimes be an area of confusion. For
    instance, examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement body executes if the conditional is truthy. In the first
    example in the preceding code, the numeric value zero is seen as falsey. As the
    second and third examples show, `false` is equal to numeric zero, but only non-strictly.
    However, in the third example, the numeric value zero is not strictly equivalent
    to `false`. The reason for this is that there is a difference between a `false`
    value and a falsey value. A `false` value is always false, but a falsey value
    may be one of several values, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -0, +0, or NaN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `empty` string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is not in the preceding list, then it is considered truthy.
  prefs: []
  type: TYPE_NORMAL
- en: The NOT Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `!` or `NOT` operator is rather unique. It is considered a "unary" operator
    because it only accepts one value to the right of it. By using the `NOT` operator,
    you essentially negate the value that precedes it. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `falseValue` variable will contain a value of
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: A very useful feature of the `NOT` operator is the "`double NOT`." This is when
    two `NOT` operators are combined to double negate an expression; a true expression
    is negated to `false`, then back to `true`, while a `false` expression is negated
    to `true`, then back to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with truthy or falsey expressions, using the `double NOT` operator
    alters the resulting value of these expressions to actual Boolean values. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Boolean Operator Precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All operators have an order of execution known as "**precedence**." This precedence
    is also apparent in mathematics and is a means to ensure that expressions are
    executed in a predictable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example could be read in two different ways. This is the first
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the second way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you follow the code from left to right, as in the first example of interpretation,
    it will return `false`, because the `&&` operator is executed last. There, the
    code will be reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second interpretation, however, will produce a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent such ambiguity, operator order precedence exists. Precedence is
    applicable to all the operators in the JavaScript language, but we''ll list just
    those that are applicable to `Boolean` expressions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Boolean operators and their associativity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Boolean operators and their associativity'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding table, the top row has the highest precedence and so is evaluated
    first, while the bottom row has the lowest precedence and is evaluated last.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operator Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous table, each operator is given an associativity description.
    Associativity relates to the execution direction of an expression. Most operators
    have "left-to-right" associativity, which means the left-hand side expression
    is executed before the right-hand side expression. The `NOT` operator, however,
    executes its right-hand expression first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Associativity can be very important, especially when side effects occur within
    an expression. In the following example, the expressions present on either side
    of a `||` operator log the parameter and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, if the `log_and_return` function returns a truthy value, then
    only the first execution will occur and so only that call logs a message with
    `log_and_return`: concatenated with the value passed in. Since the `||` operator
    is left-to-right associative, the entire expression is considered truthy if the
    left-hand side returns `true`. As such, the right-hand side is never executed.
    For this particular operator, the right-hand side only ever executes if the left-hand
    side is false. This behavior is also called a short circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the side effect of **logAndReturn** is only logging the value, this provides
    a useful tool for debugging. However, consider a function that receives an object
    as a parameter, modifies it, and then returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Both objects follow the same structure and the `make_happy` function could possibly
    work with either object. However, when the conditional is called, only `john`
    will be updated since the `||` condition in the conditional expression is satisfied
    on its left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side is never executed. Therefore, if the code is dependent on
    both objects being modified at a later date, it will fail.
  prefs: []
  type: TYPE_NORMAL
- en: This same caveat is true for the `&&` operator. Since an `&&` operator expression
    is considered `true` if both sides are truthy, then both sides will only execute
    if the left-hand side execution returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The associative execution rule for the `||` operator is particularly useful
    when working with variables. In some circumstances, it is preferable to assign
    a default value to a variable if, and only if, it does not already contain a value.
    In this instance, using the `||` operator can make light work of this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If the variable already contains a value, then it will keep that value. However,
    if its value is `null`, `undefined`, or some other falsey value, then it will
    be assigned the value 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, using the `&&` operator is great if you wish to execute a function
    if a preceding variable is truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 5.04: Free Home Delivery Eligibility Validation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a function that will determine whether the
    customers of a grocery store are eligible for free home delivery. The store only
    delivers to customers who are located within 5 miles of the store. To make this
    exercise more interesting, the store recently decided to provide free delivery
    for customers located within 10 miles of the store, but only if those customers
    have an active membership for their loyalty program. Moreover, if customers are
    within 1 mile of the store, they aren''t eligible for free home delivery, regardless
    of their membership status. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define your function signature. The function should accept the distance of
    the customer''s house from the store and their membership status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Based on the store's criteria, the function will return `true` if the customer
    is eligible for free delivery and `false` if they are not. Functions that describe
    something in a `Boolean` fashion are often labeled `is`, such as `isValid`, `isEnabled`,
    or `isGoingToReturnABoolean`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are two ways to build the body of this function; either break the problem
    up into small chunks and test the parameters bit by bit or create a single conditional
    that detects all the appropriate outcomes. We''ll work with the latter in order
    to appropriately demonstrate the content of this chapter thus far. The following
    if statement is a negative check – it checks whether a customer is not eligible
    for free home delivery:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the crux of the exercise. The `Boolean` operators are executed in the
    following order, but only those that are necessary to determine the overall result.
    First and always is the relative check for houses within `1` mile of the store.
    If the house is within `1` mile of the store, the overall result is `true`, and
    the rest of the expression is not evaluated at all. Only if the distance is `1`
    mile or more is the overall result not determined yet and the following goes ahead.
    Only if the membership status is active does the check for a distance greater
    than `10` miles come. Otherwise, if the membership status is inactive, there comes
    the check for a `distance` of greater than `5` miles. Then, those results are
    with the less-than-1-mile check. Due to operator precedence, no grouping using
    parentheses was required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the conditional evaluates as truthy, then we want to report that the person
    is not eligible for free delivery:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the function will simply halt here, if the conditional block is executed,
    simply return `true` for anything that slips past:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the function complete, try different parameter variations to test it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.10: Exercise 5.04 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Exercise 5.04 output'
  prefs: []
  type: TYPE_NORMAL
- en: Why You Shouldn't Compare Boolean and Non-Boolean Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While many non-Boolean values and objects are considered truthy, they may not
    be equal to `Boolean` `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A good rule of thumb is to convert the non-Boolean expression into a `Boolean`
    type with `!!` – the double negation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Why You Shouldn't Chain Comparison Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Repeated applications of the same operator to more than two expressions are
    called chaining. Usually, this is practical and clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It may also be tempting to use this process with comparison operators, but
    that would give a surprising, and incorrect, result. In such circumstances, the
    intermediary result of the first `Boolean` comparison would provide a `Boolean`
    outcome. Therefore, when it is compared with the next number in the chain, it
    will be converted by the JavaScript engine into a `1` (if it is `true`) or a `0`
    (if it is `false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar confusion arises when using comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, avoid chaining any comparison operators unless you're explicitly
    working with `Boolean` values.
  prefs: []
  type: TYPE_NORMAL
- en: The Ternary Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have looked at unary and binary operators, but another operator
    is also supported in JavaScript. Known simply as the ternary operator, it performs
    a similar role to `if...else`, but in a much more compact fashion. The `ternary`
    operator consists of a question mark (`?`) and a colon (`:`), which are used to
    denote a conditional expression `?`, a true expression with if `false` expression.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This, of course, is the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The primary difference here is that the `ternary` operator is an expression
    in itself. This differs from `if`, which is a statement (it does not return a
    value).
  prefs: []
  type: TYPE_NORMAL
- en: The conditional segment of the `ternary` operator does not need to be enclosed
    in parentheses but is often seen as such so that it closely resembles an `if`
    expression. The rules for each of the three expressions are simply that they must
    be expressions; you cannot use `if`, `while`, or another such statement, otherwise
    an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ternary operators are expressions, they can be nested. Each question mark
    segment of the operator expects a colon segment to follow, much like nesting groups
    of brackets. Therefore, it is possible, and acceptable, to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`Ternary` operators are very useful for keeping your code succinct. Sometimes,
    utilizing a complete `if...else` statement detracts from the purpose of the code
    and makes it harder to understand. Feel free to use the `ternary` operator where
    you see fit.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All numbers in JavaScript are 64-bit floating-point values. Unlike other languages,
    there is no internal differentiation between floating-point values and integers.
    JavaScript provides several objects containing functions that are orientated specifically
    around floating-point values and integers. However, these objects are semantic.
    Therefore, applying integer-specific functions to a number will still result in
    a floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are the simplest form of data represented by the JavaScript engine.
    Number values are immutable, which means their value cannot be modified in memory.
    If you assign a new number to a variable, you are simply overwriting the old value
    with the new. The existing value is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: Since `numbers` are passed to variables by value, it is not possible for two
    variables to point to the same `number` address space. Therefore, working with
    `number` values is considered pure, providing you do not reassign values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Floating-point values can pose something of a problem in JavaScript. Due to
    their `binary` encoding, which is how the `number` is represented in bits within
    the JavaScript engine, simply adding two floats together may not produce the result
    you are expecting. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, the response should be `0.3`, but it is not. The underlying runtime simply
    does not handle values in a way that allows them to be accurate, even with a single
    `decimal` place.
  prefs: []
  type: TYPE_NORMAL
- en: 'If accuracy is necessary for your application, there are a number of tricks
    that provide the correct output. With regards to the preceding example, simply
    converting the values into decimals before the addition will yield better accuracy.
    You can then convert the resulting value back into a floating-point number afterward,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is also true for multiplication and division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you convert into an `integer` first, then the result is more accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This limitation is not restricted to JavaScript. In fact, any language that
    works with 64-bit IEEE 754 floating-point numbers will have the same limitations.
    There are numerous libraries available on the internet that help with these issues,
    if you would prefer not to tackle them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The largest integer values that JavaScript can represent as numbers are `9,007,199,254,740,991`
    and -`9,007,199,254,740,991`.
  prefs: []
  type: TYPE_NORMAL
- en: The Number Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, numbers in JavaScript are primitives. As such,
    they have no properties or methods. Contrary to this, however, the JavaScript
    engine maintains an awareness of where numerical literals and variables are used
    within your application and provides syntactic support for methods via the `number`
    object. It is even possible to extend this object using prototypes, which will
    be explained in full in Part Four. Any extension imposed on the `Number` object
    will be usable against numeric values in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that while it may seem as though numerical values are objects, this is
    not actually the case. In memory, numbers are very simple values. The `Number`
    object, and its implementation by the JavaScript runtime, merely provides many
    of the benefits afforded with objects against these values.
  prefs: []
  type: TYPE_NORMAL
- en: Number Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Number` object contains an assortment of functions that work with numeric
    values. Like all objects, the `Number` object provides a constructor that, if
    invoked with the `new` keyword, creates a `Number` object instance. Numbers that
    are created with the `Number` constructor are actual objects, which is contrary
    to the previous statement, that is, that numbers are not objects, and is the cause
    of a lot of confusion. To make things even more interesting, the resulting object
    instance can be treated just like any other number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the constructor is the `Number` function. This is used in the
    same manner as the `Number` constructor but without the `new` keyword. Invoking
    this function returns a `number`, not an `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In all the instances detailed in the preceding code, the resulting values can
    be worked with in the same manner and with the same rules, except when dealing
    with truthy conditionals. Typically, conditionals see the value `0` (zero) as
    a falsey value, but the value returned from `new Number(0)` is truthy, even though
    it is also zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, when comparing by type, the value that's returned from `new Number(0)`
    is an object, not a number, so strict comparisons against numeric literals will
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `Number` function and constructor will accept any value type. If the
    value type cannot be converted into a number, then `NaN` (not a number) is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When working with JavaScript, it is advised not to use the `Number` constructor
    at all so that your code is more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the `Number` function and constructor, the global `Number` object
    also provides a variety of functions to help us identify or parse numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Number functions and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Number functions and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these functions is `static` and so must be preceded with the global
    `Number` object (which acts as a class in many languages), except when using `parseFloat`
    or `parseInt`. These functions are also global and therefore can be invoked without
    the preceding `Number`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Number Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the JavaScript parser semantically identifies numeric values, it is possible
    to invoke instance methods of the Number object against them, just like we can
    with actual objects. The majority of these methods are used to format `numeric`
    values as `string` representations, which is very useful for presentation in web
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Number methods and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Number methods and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a combination of the `Number` functions and methods, it is possible to
    convert to and from numeric values as necessary, though some precision may be
    lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'However, calling those functions on integer literals (rather than floats) fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When JavaScript sees the first dot right after one or more digits, it assumes
    you want to write a float literal. There are some workarounds to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Number Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The global `Number` object provides a variety of constant properties, which
    is useful when comparing your numeric values. The most important of these is `NaN`.
    Being able to identify numeric discrepancies outside of the JavaScript runtime''s
    ability to calculate provides you with a means to reduce bugs in your code. For
    instance, observe the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When executed, the result of `num` is the constant value known as Infinity.
    Since it is not possible to add, deduct, multiply, or divide other values from
    infinity, any further math against that value will also be Infinity. Therefore,
    being able to deduce this restriction within your code will provide an early warning
    that something may be amiss in your logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other properties of Number include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Number properties and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Number properties and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `MAX_SAFE_INTEGER` and `MIN_SAFE_INTEGER` are interesting values. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, the result of the preceding expression is `true`. This is simply
    because the numbers exceed safety boundaries and are therefore no longer accurately
    represented. The precision that's used in both sides of the preceding expression
    results in the same value and thus are considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Currency Formatter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a function that can take a numeric value parameter
    as a `number` or `string` and format it into a price value with two-decimal precision.
    In order to prepend a `currency` symbol, the function will accept it as a parameter.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define your function signature. This function will accept two parameters. The
    first of these will be the decimal value and the second will be the currency symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When executing, the first task that the function performs should be to validate
    the quality of the passed parameter values. The `value` parameter must be able
    to be converted into a numeric value, while the `currency` parameter should be
    a character `string`. If the `currency` is falsey, such as when no parameter has
    been passed, then we can default its value to the dollar symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When responding to errors, there are many ways we can notify the caller that
    something went wrong. In this instance, we''ll simply return `null`. This way,
    the caller will know that anything other than a `string` response means that something
    wasn''t quite right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we know the parameters are usable, combine them into the correct format
    and return the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you go ahead and execute this function, you will see the appropriate responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.14: Exercise 5.05 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Exercise 5.05 output'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the output once all four functions are run in the preceding figure.
    In this exercise, we created a function that took a numeric value parameter as
    a `number` or `string` and formatted it into a price value with two-decimal precision.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like `numbers`, `strings` are simple immutable data types that are managed within
    the JavaScript runtime as a list of binary values, which are representable as
    characters. Since they are immutable, they cannot be altered. If you modify a
    `string`, using one of the various methods provided, you are actually creating
    a new string with the changes applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal representation of strings is a list of characters surrounded by
    quotes. These quotes can be double quotes, single quotes (apostrophes), or backticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings can be thought of as a long list of single characters, much like arrays,
    which will be discussed later. As such, it is possible to query individual, or
    groups of, characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is not a literal representation, but simply an analogy of
    how strings may be perceived. Since strings are lists, it is possible to retrieve
    characters from them using the character index. This is performed by enclosing
    the index with square bracket symbols. The index of a character string starts
    at `0` (zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Since strings are immutable, you cannot assign a replacement character to an
    index, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to modify a `string`. Instead, you can only create a new
    one based on the original. You can either reconstruct it using operators or use
    one of the many `string` functions provided by the `String` object, which will
    be described shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Special Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since strings are contained in quotes, placing the same quotes within the string
    can be problematic. Simply typing the quote in the string is the same as terminating
    that string. This will then mean that any proceeding characters may be seen as
    malformed JavaScript code or, possibly worse, executable JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to avoid terminating the `string` is to use a different quote to the
    type used to contain the `string`. For instance, if the string is contained in
    double quotes, then single quotes can be used freely. Likewise, containing the
    `string` in single quotes will allow double quotes to be used freely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will work for simple text but is not as foolproof for strings that need
    to contain both quote types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript language provides a means to `escape` characters included within
    strings so that they are treated differently. This is performed by preceding the
    character to escape with a backslash (`\`) character. In the case of quotes, escaping
    ensures that the quote character is not seen as the string termination character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `escape character` can be used with several other characters for varying
    effects. It is even used to escape the escape character, for times when a backslash
    must exist within a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Other supported escape characters include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Escape Characters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Escape Characters'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concatenating is a means of combining elements, end to end, to form a new element.
    With regards to strings, this is simply combining strings together to form a larger
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'String concatenation is performed using the plus (`+`) symbol. This is known
    as method overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: When concatenating strings, it is important to pay attention to the presence
    of space characters. No additional characters are added at the point of concatenation.
    Therefore, if you require spaces between combined strings, you must add these
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Since strings are immutable, concatenating strings creates a new string, which
    you can assign to a variable or pass as a parameter to a function. The original
    strings remain unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: Template Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template literals are a more recent addition to the JavaScript language. Surrounding
    strings with backtick quotes (`` ` ``) alter the translation of the literal by
    the JavaScript engine and afford some additional new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first interesting feature, and the one that''s the most commonly used,
    is the ability to interpolate expressions within a `string`. This is performed
    by embedding blocks within the string preceded with the dollar (`$`) character.
    Combining strings in this fashion provides the benefit of making string literals
    easier to read, but can also greatly simplify more complex string concatenation
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful feature of template literals is the ability to use physical
    line breaks. By applying line breaks to the JavaScript code, those same breaks
    appear within the resolved string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Finally, a template expression can contain inner template literals within it
    too, thereby providing a nested template literal implementation. You'll see them
    in the next example. This caters to more complex expressions within the `string`
    itself, such as conditionals or loops.
  prefs: []
  type: TYPE_NORMAL
- en: The result of template literals is a feature within JavaScript that lends itself
    very nicely to processing pages, and other string data content, in a manner that
    is more manageable. Where JavaScript developers once looked toward third-party
    libraries to perform such feats, such libraries are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Email Templates'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a function that accepts the components of
    an email sending service and combines them into an email body template. To make
    things more interesting, only adults are eligible to post comments on the website.
    Accordingly, the message text will change. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off by creating a function signature. The parameters of the function
    determine the values that can be entered into the email body. As stated in the
    description, we will require an `age` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this in place, check the passed parameters now. If any are invalid, the
    function will simply return `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we're checking whether the number can be used as a valid numerical value
    and whether the `name` and `comments` are `strings`. We could also choose to check
    the length of the strings to ensure they have content, but that is not necessary
    for this exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have valid parameters, we''ll need to create our `body` text with
    the alluded-to nested template expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, a `ternary` operator expression is used to populate the content
    of the interpolation in the `status` line. It would also be possible to invoke
    a function here, but it would not have been acceptable to use an actual `if` condition.
    The reason for this is that an `if` condition is composed of one or more blocks,
    which is not accepted in template interpolation syntax.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can close the function by returning the variable. If you now execute
    the function and pass in some arbitrary parameters, you should see the complete
    interpolated string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Exercise 5.06 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: Exercise 5.06 output'
  prefs: []
  type: TYPE_NORMAL
- en: How and where you choose to concatenate or interpolate strings is up to you.
    When tackling a problem, consider whether the code is more readable using one
    form of quotation over another, especially if more than one developer will be
    working with the code.
  prefs: []
  type: TYPE_NORMAL
- en: The String Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like number values, character strings also come with a useful object called
    the String object. Similarly, the String object provides numerous functions, methods,
    and properties oriented around strings.
  prefs: []
  type: TYPE_NORMAL
- en: Also similar to the `Number` object is the `String` function, which converts
    any passed value into a `string`. The `String` function works by calling the value's
    `toString` function, which we'll discuss a little later.
  prefs: []
  type: TYPE_NORMAL
- en: The length Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `String` object, and thus strings themselves, have only one property: the
    `length` property. As the name suggests, the `length` property returns the `length`
    of the `string` as an `integer`. As the indexing of a `string` starts at zero,
    the length is always one more than the last character index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `length` property is particularly useful for iterating over the `string`,
    or when working with many of the `string` methods when its `length` is not already
    known.
  prefs: []
  type: TYPE_NORMAL
- en: String Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` object does not have any `static` functions, but it does support
    strings with numerous available methods – far more than those available in the
    `Number` object. This chapter will not attempt to cover them all but will look
    at the more useful methods.
  prefs: []
  type: TYPE_NORMAL
- en: Working with and manipulating strings is a common requirement in JavaScript;
    not just for displaying text, but for working with data in general. It is often
    necessary to clip, sort, modify, add, and remove segments of strings using varying
    criteria. As such, JavaScript provides just about every method you could think
    of to make these tasks simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the most commonly used methods that are provided
    by the String object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: String Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.17: String Methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.07: Sentence Reversal'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a function that accepts a string of any size,
    trims any whitespace characters, reverses its content, and then capitalizes the
    first character of the string or of those following a period character. The result
    should look like a normal sentence from a reversed dimension. The purpose of the
    exercise is to understand data transformation. Transforming data is ubiquitous
    in software development. The JavaScript runtime transforms data when it reads
    your code and converts it into a running application. Being able to transform
    data in a simple manner will prove to be a valuable skill. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off with the function signature. We only want to accept a single parameter,
    which we''ll call `str`; this is an abbreviation of "string":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, perform the simplest task first, that is, removing any trailing whitespace
    characters from the beginning and end of the string. While doing this, you should
    also ensure that you are actually working with a string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the parameter prepared, you should now start a loop. The loop will build
    a new string by walking the parameter string in reverse. Therefore, you will also
    need to declare four additional variables, namely, a temporary variable to hold
    the resulting value, a variable to keep track of the current string index, a variable
    to store the current character, and a variable to keep track of whether the next
    non-whitespace character is at the start of a sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we ensure that the counter starts at one less than the
    `length` of the string (the last index of the string) and that the loop iterates
    as long as the counter is greater than or equal to `0` (zero).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the loop in progress, store the character at the index into the `chr`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the character stored, check whether the previous iteration is found at
    the end of a sentence. If it was, then you will need to uppercase the next non-whitespace
    character. Otherwise, you will need to `lowercase` it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the character is the start of a sentence, then the `isStart` flag needs to
    be set back to `false` so that the next iteration doesn't repeat the uppercasing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since the uppercasing occurred for the previous iteration, check whether you
    should flag a new sentence in this iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You detect the start of a new sentence by checking for the period character.
    If it is the start of a new sentence, then you set the `isStart` flag, but you
    also need to determine whether this is the very end of the original string. The
    reason for this is that you do not want to copy the last period of the original
    string to the start of the new string, or the result will start with a period,
    which will not make sense. If it is, you simply skip the character altogether
    by decrementing the `index` and continuing the loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the period was not at the end of the original string, make some adjustments.
    You will not want the new sentences to end with a space and then a period – you
    will require the reversal of that. Since the space will have already been applied
    to the result, you need to backtrack by one character and re-add the required
    output. As the result string has now been modified, you will need to continue
    to the next iteration once more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the loop does not continue, then the current iteration results in a regular
    character, which should simply be appended to the result. Decrement the index
    for the next iteration and close out the loop. End the function by returning the
    result to the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, go ahead and execute the function. Try passing multiple sentences to it
    inside a single string to see the full result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.18 – Exercise 5.07 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.18: Exercise 5.07 output'
  prefs: []
  type: TYPE_NORMAL
- en: There you have it. You have just created a string manipulation function using
    methods from the `String` global object. Certainly, the function will not win
    any awards and may not work well if provided with strings containing consecutive
    whitespace characters, but it does work.
  prefs: []
  type: TYPE_NORMAL
- en: The toString Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every primitive type in JavaScript can be converted into a string using the
    `String` function. When working with more complex types, however, this is not
    always the case. For instance, with a typical object, converting it into a `string`
    will produce a set result, regardless of the object''s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that the JavaScript engine doesn't understand how you
    wish the data to be parsed. It could simply be that you require the output to
    form a table of keys and values, or you may simply want a list of the values themselves
    and to discard the keys. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: As such, JavaScript provides the concept of the `toString` value method.
  prefs: []
  type: TYPE_NORMAL
- en: '`toString` is a method that exists on all data types but is required to be
    overridden on some of the complex types, providing that you have your own parsing
    logic. When calling the `String` function and passing it a value, you are in fact
    invoking the `toString` method on that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Overriding the `toString` method is simply a case of supplying an alternative
    function of the same name to the data value. For instance, to override the `toString`
    method in a custom object, you could simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Working with complex objects and object functions will be described fully later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers with Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Numbers` and `strings` are both primitive data types and both overload the
    `+` (addition) operator. However, there is much more of a relationship between
    the two that can prove useful or catch you out if you are not careful.'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, numbers and strings in JavaScript can often be interchangeable,
    thanks to an intelligent context-based system. Depending on the circumstances,
    JavaScript will attempt to deduce the resulting type of an expression based on
    the available parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen that strings can be concatenated using the `+` operator,
    but numbers can also be concatenated into strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: When the JavaScript parser identifies a numeric value and a string value passed
    as expressions to the `+` operator, it will convert the number into a string so
    that the result is a simple string concatenation. This is otherwise known as context-based
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the string expression is also a representation of a numerical value and
    is used with other numerical associated operators, such as `/` or `*`, the reverse
    action will occur. At such times, JavaScript''s context-based casting will instead
    convert the string number into an actual number. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript will always convert the non-string value into a string when we use
    the `+` operator in order to produce an expected result. It would be too confusing
    if the `+` operator worked differently based on the content of the string expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbers can also be mathematically calculated when both expressions are a string,
    but again, this will only occur if you''re not utilizing the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is expected that you will need to add together two numbers represented
    as strings, such as values read from text input fields, always convert them into
    numbers first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Working with Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've already seen, JavaScript functions are blocks of code with signatures
    naming the variables that were passed to them when invoked. As with any block,
    functions have their own stacks that encapsulate and protect data declared within
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, functions are considered first-class types. This means that,
    much like any other type, they can be assigned to variables, passed as parameters
    to other functions, and returned from functions. They are also able to call themselves,
    which is known as recursive and is the quality that helps make JavaScript a functional
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many forms of function in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between them are mostly slight syntactical changes that affect
    how they are used. We will briefly cover each of the function types in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since functions in JavaScript are first class, they exist as a transferable
    resource, much like primitives and objects. Until now, functions have been declared
    and assigned, which means they have a callable name. However, a function is also
    an expression with two states: its `declared format` and its `invocation`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can exist without providing a name in the signature, whereby it
    has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, it is possible to code a function without providing a name at
    declaration time. Creating functions in this way allows them to be created in
    place, such as in a call to another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can also be assigned to variables and, of course, be received as
    parameters in a function call. Once an anonymous function has been assigned to
    a variable, it becomes a named `function`, since the variable constitutes its
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, up until now, you have been writing functions with a global scope.
    Declaring a named function simply means that a variable of the same name will
    be declared in the current scope and will point to that function. For instance,
    the following two syntaxes are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring a function without assigning a name can be considered a function
    literal. Since the function exists at the point of definition, it can also be
    executed in place. How could that be useful? It can encapsulate entire programs
    and avoid dirtying the global namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Namespace dirtying is a term to describe functions and variables declared globally.
    While doing so is not disallowed, it can be problematic. If two libraries within
    the same web page create global variables of the same name, there can be unexpected
    results. Creating applications that honor a clean global environment will be discussed
    in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important use case for anonymous functions has often been asynchronous execution
    callbacks. When calling code that does not immediately return a value, but also
    does not stop the execution of code that immediately proceeds it, that code is
    considered `asynchronous`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications that contain asynchronous code need a means to alert the rest
    of the application once the asynchronous code has finished running and a value
    must be returned. In JavaScript, callbacks have long been used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue with callbacks is that should numerous asynchronous calls need to
    occur sequentially, the resulting code file has a tendency to indent catastrophically.
    This issue is sometimes fondly known as the pyramid of doom or callback hell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each new request indents a further two characters. It is not
    uncommon for an application to possess callback chains of several tens of requests,
    thereby reaching the far side of the screen while coding. Developers can choose
    not to indent, as indentation is not a requirement, but not doing so results in
    harder-to-read code. To resolve this, generator functions were introduced. You
    will learn more about generator functions later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.08: Functional Parameters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a function that accepts two parameters: a
    primitive data type and a function. This function will then combine those parameters
    and return a function as a result. The returned function will work identically
    to the function that was passed as a parameter, with the exception that it will
    always receive the original primitive parameter as its argument. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off by creating the function signature. You know that it will accept
    two parameters and, since it will act as a kind of currying process (a term used
    in functional programming), that''s the name that will be used here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is nothing special here. The `curry` function is just like any named function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this circumstance, it's not important what value the first parameter contains.
    Even if it contained `null`, that would still be valid in this instance, so you
    can accept whatever comes through.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, check if the second parameter is a function. Otherwise, when it is invoked,
    an error may occur if it is some other value type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now for the fun part. The intention is to always populate the parameter list
    of the passed-in function with the first parameter of this function, however many
    times it is called. To do this, use a local function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the result here is a function that, whenever it is called, will
    simply call the `fun` function. The `prim` parameter will always remain the same
    here, so the invocation will always produce the same result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, return the new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s give this a spin. Try calling the function while trying different values
    as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Exercise 5.08 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.19: Exercise 5.08 output'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrow functions, sometimes called `fat arrow` functions, are a simplified syntax
    for function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, arrow functions don''t need to provide a
    block of code and can instead be replaced with an expression. If an expression
    is used, then no `return` keyword is required since expressions already return
    a value. However, the `return` keyword is required if a block is used, since blocks
    are not expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as functioning without a block, arrow functions can also be declared
    without the parentheses surrounding the parameter list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the preceding code only works if the parameters are a list of one.
    This is because a list of two or more parameters forms a rather ambiguous statement.
    For instance, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'When reading the preceding declaration, the compiler will not know which of
    the following declaration strings you are trying to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The first two examples will give an error since they attempt to define an arrow
    function in a `var` statement, but without being assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Function Caveats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While arrow functions appear much cleaner and more flexible than regular function
    declarations, there are disadvantages to their use. The first disadvantage is
    that arrow functions cannot be used as an object constructor and it's ill-advised
    to use them as object methods. The reason for this has to do with the second limitation;
    arrow functions have no access to their own this, arguments, or super objects
    (discussed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of arrow functions is simply to enable a cleaner syntax when working
    with anonymous functions. Arrow functions were the first syntactical weapon against
    callback hell, which we described previously. As such, arrow functions should
    be used wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Generator Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generators are a recent and rather complex addition to the JavaScript language.
    They are incredibly useful functions once you begin to understand them, though
    that may take some effort. Generators do not facilitate any means that cannot
    be carried out in some other fashion within the JavaScript language. As such,
    this section will merely touch upon the subject of generator functions in order
    to alert you to their usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators provide additional power to sequence iteration. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an iterator. The loop iterates three times, from `0` to
    `2`. Each time the iteration occurs, the `callback` function is called, and the
    iteration result is passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the problem with loops is that they are a closed stack. For any custom
    code to execute within the loop, the loop needs to have knowledge of what to do
    with the iterated data. This is a restriction that generators aim to overcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator functions are declared much like named and anonymous functions, but
    with a slight difference; an asterisk must be placed after the `function` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The arrow function format cannot be used for generator functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating the function body, the same rules for named and anonymous functions
    apply. However, there are some differences. Take a look at the following example,
    based on the preceding loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: In particular, note the `yield` keyword. `yield` is a keyword that's been borrowed
    from multithreaded languages such as C++. Its usage in those languages is similar
    to its usage here. Essentially, by calling `yield`, you are asking the runtime
    engine to pass control back to the caller. In JavaScript, "passing back of control"
    includes sending a value to the caller. In the preceding example, a value will
    be sent each time the function yields, which will be three times in total.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the function, you must create an instance of the generator by invoking
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a generator instance, you can acquire a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the `next` function many times, until the stream is exhausted.
    Once exhausted, the returned value will be undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of the `next()` function is an object with two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `object` is hidden from the previous examples and we simply return the
    value in order to keep things simple. The done value will return true as long
    as there are more yields to return from the generator. Once the generator is exhausted,
    it will return the following for all successive calls to `next()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'One point to keep in mind is that the `yield` keyword may be called as many
    times as necessary in the `generator` function. In the previous example, the `yield`
    keyword was used in a loop, but it may just as easily be called elsewhere, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Generator functions may also use the `return` keyword. If `return` is used,
    then the returned value will be retrieved with a call to `next()`, just like yielded
    values. However, calling return will end the generator, meaning that no more values
    will be returned from calls to `next()`, even if further `yield` keywords exist
    in the function.
  prefs: []
  type: TYPE_NORMAL
- en: The this Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All functions, apart from arrow functions, have access to additional objects
    related to the functions' stack. As we mentioned previously, functions provide
    a stack that ring-fences the memory that's used by variables that are declared
    within it, while allowing access to variables declared in the functions or blocks
    surrounding the function being called. This is otherwise known as encapsulation
    and protects the outer stacks from being inadvertently corrupted by function body-related
    processes, while also protecting the data within the function from outside processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` keyword exists as a means to be able to directly target the context
    present within the execution of the function. While the variables that are declared
    within a function are direct members of the functions stack, the context of the
    function body may specifically be that of another block or object and may even
    be changed at invocation time to be a specific context other than the one the
    function is defined within:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Global, object, and function diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.20: Global, object, and function diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another keyword that's available to functions is the `arguments` keyword. When
    defining a function signature, the parameters listed within the brackets of the
    signature are known as "named parameters" while the values that are passed to
    the function during invocation are considered the "functions arguments". Named
    parameters map to arguments, where possible, during the execution of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling a function, you may pass in as many or as few arguments as you
    like, but they do not need to total the number of parameters listed in the function
    signature. If you specify fewer parameters than are named in the function signature,
    those parameters that are not provided for will simply have a value of undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: If, on the other hand, you specify more parameters than are listed for that
    function, those parameters are still made available to the function, despite not
    having enough named parameters; they are simply not named. In such circumstances,
    you can access the additional parameters using the arguments keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` keyword is very much like an array. You can access it like an
    array, and you can use it in functions that expect an array. It even has built-in
    array-like functions. However, the `arguments` keyword is not an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access additional function parameters, you can target them specifically
    by index against the `arguments` keyword. For instance, if four arguments were
    passed to the function, you could access the `fourth` argument with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'As you''ll see later with arrays, you can find out just how many arguments
    were passed to the function invocation by calling the `length` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The `arguments` object can be extremely useful when working with functions of
    a more dynamic nature.
  prefs: []
  type: TYPE_NORMAL
- en: Call and Apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, JavaScript is an exceptionally flexible language.
    Since functions are first-class citizens in JavaScript, facilities are provided
    by the language to manipulate functions.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most commonly used tools for this endeavor are `call` and `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `call` and apply function in very much the same way: by enabling the invocation
    of functions while changing the function stack''s context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between `call` and `apply` are simply that `call` is solely
    used to manipulate the invoked functions context and `apply` is used for the same
    thing and also to supply an arbitrary number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to use `call`, you need to know the number of arguments at development
    time. The arguments that are used in `apply` can be of any `length` and do not
    have to be known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.09: Dynamic Currying'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will be a continuation of the previous exercise. Since you now
    know much more about how functions work in JavaScript, we will take the `curry`
    concept to a much higher level by supporting arbitrary numbers of arguments. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off with your `function` signature. However, since you would like to
    support an arbitrary number of arguments, the function parameter will need to
    come first. Also, as the remaining parameters are `arbitrary`, there is no need
    to define them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the first parameter is a `function` before continuing with the rest
    of the logic:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you may have guessed, you will use the arguments object to acquire the parameters.
    However, you will need to manipulate the arguments list since you will not want
    to pass the function parameter to itself. As we mentioned previously, the `arguments`
    object is not an array, so you''ll need to convert it into one first by manipulating
    it with an `array` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to convert `arguments` into an `array`, you need to call a native function
    of `array` instances that copies the array. The `slice` function creates a shallow
    copy of an array. In this case, it doesn't know that the `arguments` object is
    not an array, but still works fine, which is perfect for this use case. The `args.shift()`
    code removes the first item in the array using the newly created array's shift
    function. Since arrays are mutable, like objects, the `args` array value is permanently
    modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that you have your parameters list, create your function wrapper, like
    you did previously. This time, however, the `fun` parameter will be invoked using
    `apply`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since parameters will be supplied to the `curry` function and the returned function,
    the arguments of each must be joined into a single array. This is what `concat`
    does. The resulting array is then used as the arguments of the `fun` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, return the new function and close the `curry` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s give this a spin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.21: Exercise 5.09 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.21: Exercise 5.09 output'
  prefs: []
  type: TYPE_NORMAL
- en: What you have just achieved is no small feat. `Currying` is a powerful tool
    in functional programming, and you have achieved this task with very few lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Simple Number Comparison'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot has been covered so far, so it''s time for an activity. In this activity,
    you have been tasked with writing a function that will receive the grades for
    a student''s coursework for an entire year as percentages. The function must average
    the result of each grade in order to determine whether the student has passed
    the course for the entire year. The calculation will assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An average below 35% is an F grade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An average of 35 – 44% is a D grade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An average of 45% – 59% is a C grade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An average of 60% – 74% is a B grade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An average of 75% and over is an A grade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grades for each coursework assignment may be passed as a `Number` or a `String`.
    No other data type is expected, so error handling is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function. Argument labels aren't necessary as we won't know how many
    arguments there will be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the arguments for the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the number of arguments that were passed and store it as a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add all the arguments together and calculate the average. Store this in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final condition will always be true if the others have failed, so the condition
    itself can be skipped. Each condition will not be evaluated if the previous condition
    has been returned from the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Determine the `grade` from the student based on the `average` and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 724\.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This activity should highlight the flexibility and simplicity of common problem-solving
    using JavaScript functions and data types. There are, in fact, many ways to solve
    this problem, but attempting this in a logical, easy-to-read manner is always
    preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, objects are the primary configurable data structures from which
    all other complex data types extend, including `Array` and `Date`. Objects work
    like a `hash map`; they contain `key`/`value` properties that can contain any
    data type, including functions and other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object is defined using curly braces, much like a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The values that are added to an object are "members" of that object. Those
    members are accessible using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The key of a property may be specified with or without quotes. However, the
    result is exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript is known as a prototype language, which means its object-oriented
    capabilities are provided by prototyping values to objects prior to instantiation.
    As such, JavaScript objects support the `prototype` keyword. Prototypes are too
    advanced for this chapter and will be discussed at length in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Objects as Hashtables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects are very much like key/value `hashtables`: you assign a value to an
    object with a given `name` or `key`. These values are arbitrary, and they can
    be primitives, functions, objects, arrays, and so on. Once an object has been
    defined, you can further assign properties to them using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as assigning values via dot notation, they can also be assigned by
    named index, much like an `array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The result is exactly the same, but there are some differences between these
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using dot notation, the parameters of an object must use standard variable
    naming rules. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only use letters, digits, underscores, and dollar symbols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must start with a letter, dollar, or underscore symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names are case-sensitive (a and A are different variables).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must not match a reserved word, such as "`while`" or "`if`".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects keys, however, are not limited by this convention. By using square brackets
    and passing the name as a `string`, the scope for naming keys becomes much broader.
    In fact, you can seemingly use any `ASCII` character of your choice, including
    whitespace characters, with up to `227` characters in length. That's `134,217,728`
    characters!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Aside from strings, digits may also be used as keys. This results in objects
    appearing much like arrays. In fact, for the most part, arrays themselves are
    simply objects, albeit with some superpowers of their own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Just as strings can be used with square brackets, values can be written and
    read from objects dynamically simply by using variables (or expressions) between
    square brackets instead.
  prefs: []
  type: TYPE_NORMAL
- en: Object Keys and Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with objects as data stores, it can be tempting to add and retrieve
    all kinds of data. Objects are extremely versatile containers and their use is
    the foundation of many applications. However, as with any language platform, data
    consumes memory. Every time a new key is added to an object, more memory is used
    on the host computer.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript uses a rather intelligent `garbage collector`; whose job is to clean
    up discarded data. The issue is, however, that data may not be considered discarded
    if a reference to it exists in an object. If it isn't handled properly, then memory
    will continue to be consumed as you add more data, eventually resulting in your
    browser crashing. This is known as a memory leak!
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to remove a reference to data from an object is to simply replace it
    with something else. For instance, it is common in JavaScript applications to
    see `null` assigned to object parameters when they are no longer needed. The problem
    with this approach, though, is that while the original value has been detached
    from the object, the new `null` value has now taken its place. null is a value,
    after all. This may not be overly problematic as all `null` values point to the
    same data space, but the contained value is not the only part of the property
    occupying memory; the `key` is also an overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to fully delete the reference from the object, which includes `key`
    and `value`, the `delete` keyword should be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Object and Pass-By Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, primitive values are immutable
    and exist by value. When passing them to functions or modifying them, a new copy
    is made of the data, which occupies a different location in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Objects differ from primitive values in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects are `mutable` data. This means that instead of a copy of the object
    data being passed to functions or variable assignments within your applications,
    a reference to the original object data is always passed. When modifying an object,
    it is the actual original object being altered. No new object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The reason objects work so differently is that copying object data is slow and
    CPU-intensive. Since objects can be nested, attempting to copy an object that
    has a tree of descendants linked to it can be agonizingly laborious for the host
    machine and is therefore completely impractical.
  prefs: []
  type: TYPE_NORMAL
- en: Since objects are presented differently, care must be taken with their use.
    Modifying object data by passing the object to functions can be the cause of hard-to-find
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Object Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since objects work like `hash arrays`, it makes sense that functions exist to
    work with objects as `iterables`. The JavaScript language provides a number of
    functions for use when iterating over objects, but it also provides operators
    to this end, as seen with the in operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The in operator converts an object into an `iterable` by iterating over its
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The same feat can also be accomplished with the `Object.keys(myObj)` function.
    The difference here is that it returns the object''s keys as an array, so it also
    has other usefulness when working with objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as a means to get the object keys as an array, there is a function
    to retrieve the object''s values as an array, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, should you require both keys and values as associated pairs, JavaScript
    provides the entries function to do just that. The `key`/`value` pairs are provided
    as arrays, with the first item being the key and the second item being the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Object Accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have seen, writing to and reading from objects is allowed freely,
    but it may not be what you want. Let's suggest, for example, that you wish to
    create a `gameState` object that will keep track of the player's score and the
    remaining `enemies` in play. By allowing data to be read and written randomly,
    you provide an avenue for bugs to creep into your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, one solution to restricting access to these properties would be to incorporate
    functions. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Here, the member variables have been renamed to start with an underscore. This
    is a common practice as it is deemed that any values starting with an underscore
    are values that should not be accessed directly. In *Chapter 4*, *JavaScript Libraries
    and Frameworks*, you will find out how to protect object variables absolutely,
    such that direct access becomes impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Now, while the preceding implementation is perfectly reasonable, the properties
    of the objects are no longer assignable but invoked. If you needed to read back
    the values of those properties, you would need yet another set of functions, and
    those would also need to be invoked. In short, it's not very clean.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provides a solution to this conundrum through the use of accessors,
    also known as getters and setters. Accessors are a way to add functions that can
    be used like variables, whereby a getter allows for the retrieval of data and
    a setter enables the setting of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for accessors is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rework the previous example to utilize getters and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `get.score()` allows getting the score and `set.score(value)`
    allows to set a value to the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a bit of creative license has been utilized. The `score` can be read
    and written to, just like any other value, except when writing, instead of replacing
    the value, the value is added to the original value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enemies` value can be read as normal, but by calling `killEnemies`, passing
    a value will deduct it from the current value, but passing no total will deduct
    `1` from the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, reading the player''s lives property will return the current number
    of lives, but reading `killPlayer` will either deduct a life or it will reset
    it back to `3` lives should there be no enemies left. This may be useful, for
    instance, if you wanted to reset the player''s lives after they''ve completed
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you assign the value of a setter to another variable, that other
    variable will contain whatever was passed to the setter, not the value that was
    determined within the setter logic. If no value is passed, then the accessor is
    not a getter, and so `undefined` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.10: Converting Objects to toString'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a function within an object that provides
    a "pretty print" facility when using the object in circumstances that require
    a `string` value. The function will utilize the `toString` capability, which we
    detailed earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create an object with a bunch of different values. Add some nested
    objects to make things more interesting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you output this with `console.log`, then it should show up just fine
    as the console is designed to parse complex objects for debugging purposes. However,
    if you concatenate the object data into a string, you''ll get unwanted results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To rectify this, create a function that parses objects into a string representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing you do here is accept both the passing of an object and utilize
    the current object context. This way, the function can be called against the object
    it exists in it, but also as a passed parameter. You'll need to do this so that
    you can recursively `stringify` any child objects that exist within the parent.
    The `indent` parameter is used to keep track of the child object indentation.
    For each level of child, you meet, you will want to indent it further still. This
    helps you visualize your object structure when printed. Finally, you also need
    the `res` variable to store the resulting string representation as it's being
    built.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Iterate through all of the object''s keys and build the string representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, this is where things get a little tricky. If a value for the `k` key is
    also an object, you will want to pretty print that, too. Therefore, just pass
    it to the same function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To nest the child, the key for that child is prefixed with the value of the
    current indent parameter. An open curly brace is used to denote an object in the
    returned string. The indent is then increased in length and passed to the recursive
    call to the `objToString` function for the nested iteration. The child print is
    then closed with a closing curly brace, which is also indented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the value of the key is not an object, then it might be a function. You
    will want to skip those as you can''t cleanly print them. Everything else can
    be appended like a string, but will also need to be indented in case it''s the
    value of a field in a child object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, apply a delimiter so that each of the keys is separated. A newline character
    should suffice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, close the loop and return the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this work, append the `objToString` function to the starting object
    as a `toString` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to test this out, simply concatenate the object to a string, forcing
    the object to be cast to a string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.22: Exercise 5.10 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.22: Exercise 5.10 output'
  prefs: []
  type: TYPE_NORMAL
- en: You have created a useable object `stringifier` function that works with complex
    objects of any depth.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are another complex object type built on top of objects. Unlike objects,
    arrays are designed to work with lists of data. Arrays may be created in several
    ways. The first is known as an Array literal and, similarly to object literals,
    is simply a means of passing a defined Array value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of an array have no keys, and are instead accessed using integer
    indexes with the square bracket form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other types, the array type also has a constructor function that''s
    used to create array instances. The array constructor can be passed values to
    prepopulate the `Array`. Therefore, the following examples are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when using the constructor form, passing a single integer value will
    create an array with a set number of values set to undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `Array` constructor can lead to unintended results, should the
    developer intend to create an `Array` with one value as a single integer type.
    As such, it is considered a good practice to initialize all arrays using the literal
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and Mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like objects, arrays are mutable objects. If you update an array that is passed
    into a function, the original `Array` is also modified.
  prefs: []
  type: TYPE_NORMAL
- en: The `Array` object has a number of built-in functions that are useful in maintaining
    immutability when using arrays. They do not make the array immutable but provide
    a means to work with arrays while ensuring that they are copied rather than modified.
  prefs: []
  type: TYPE_NORMAL
- en: The Array's immutability functions will be discussed at length in *Chapter 4*,
    *JavaScript Libraries and Frameworks*, when functional programming methodologies
    are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Array Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays can be iterated in much the same way as objects. If you''re using the
    `for...in` syntax, the element of the `Array` is the index, which is the same
    result when working with objects that have numerical keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This format works well if you need to iterate an array from start to finish,
    but this isn't very flexible. To aid the traversal of an Array, JavaScript provides
    a number of additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since an array is a linear list, it has a `length`. The array object provides
    the length property, which returns the number of elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The starting index of an array is always `0`, while the `length` of an array
    is always one more than the last index of the `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as retrieving a value from an array by index, it is also possible to
    search an array for a value and return its index using the `indexOf` function.
    `indexOf` takes a single parameter, that is, the value to find within the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '`indexOf` will return the index of the value if it is found but will return
    `-1` if it does not. A match can be at `index 0` or above, up to but exclusive
    of `arr.length`. To use a result of `indexOf(...)` in a conditional statement,
    compare it and check whether it''s higher than `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `indexOf` looks for the matching value of an element. Therefore,
    complex types will only be found within the Array if they exist within the Array
    by reference. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Since complex types of identical structure are not considered the same by value,
    it is not possible to find occurrences of complex objects within an Array in this
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple occurrences of a value exist within an Array, `indexOf` will return
    the first discovered item index. All other instances of that value will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: A companion of the `indexOf` function is the `lastIndexOf` function. This function
    works identically to `indexOf`, with the exception that the index search starts
    at the end of the Array.
  prefs: []
  type: TYPE_NORMAL
- en: Built-In Array Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The array type provides many more functions that are useful in traversing,
    copying, concatenating, and presenting array structures. The following table lists
    some important and useful functions that are available as members of the array
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Built-in array functions and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.23: Built-in array functions and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Date object is an important type in JavaScript but is a complicated type
    in any language. Like the `Array` type, the `Date` type is built on top of a JavaScript
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates have no literal format. As such, they must be created using the `Date`
    constructor. There are four ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty constructor creates a date with the current date and time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor may be passed an integer representing the number of milliseconds
    to have passed since the beginning of `January 1st, 1970`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supplying multiple integer parameters will specify date segments, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (year, month, day, hour, minute, second, millisecond)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (year, month, day, hour, minute, second)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (year, month, day, hour, minute)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (year, month, day, hour)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (year, month, day)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (year, month)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be aware that the month is specified by the numbers `0` - `11`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Supplying a string representation of a date:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISO 8601 date format ("`2019-04-25`" or "`2019-04-25T12:00:00Z`", where months,
    days, and time are padded to two-digit lengths)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: US short date format ("`04/25/2019`" with padded day and month)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: US long date format ("`Apr 25 2019`" and so on)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You cannot create a `Date` instance by simply passing the year value as an integer
    since the JavaScript engine will not know whether you meant year or milliseconds.
    However, you can create a Date instance from simply passing a year string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once a `Date` object has been constructed, it can be queried. The `Date` object
    provides numerous functions for extracting the elements of the `date`. The following
    table lists the functions that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: The Date object methods and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.24: The Date object methods and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Each of the functions provided by Date returns a value starting from 0, with
    the exception of the `getDate` method. This often leads to confusion and bugs,
    so be sure to keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the functions detailed in the preceding table also has a set equivalent,
    with the exception of `getDay`. Therefore, to update the hour of the `Date` instance,
    you simply call `setHour` and pass it an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Parsing Date Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, the `Date` constructor can accept a date string
    and convert it into an instance of the `Date` object. Dates are represented internally
    within the Date type as integers. Thus, the `getDate` method returns the true
    interpretation of the date value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a valid date string, as detailed previously, you can convert it
    into a date by calling the `parse` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the return value of the `Date.parse` method does not return a `Date`
    instance. Instead, it returns the number of milliseconds since `January 1st, 1970`
    until that date. In order to create a `Date` instance, you must, therefore, pass
    that resulting value to the `Date` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Formatting Dates into Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Date` object provides its own `toString` function. If you attempt to use
    a `Date` instance as a `string`, you will receive a formatted string instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is often not the format you require. If you wish to provide your
    own date string format, you can override the `toString` function of the object,
    much like in the *Working with Object* section of this chapter. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Date Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript provides no functions for comparing, adding, or subtracting dates.
    However, working out date differences or combining dates is not hard in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, there are two tasks that need to be considered when comparing dates:'
  prefs: []
  type: TYPE_NORMAL
- en: What the difference is between two dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding or subtracting time to/from a date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first task is relatively simple. Since the date can be converted into a
    simple integer representing the number of milliseconds since `January 1st, 1970`,
    the dates you wish to difference can simply be represented as milliseconds and
    that value can be compared. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the number of milliseconds in each, you can convert that into a time
    unit. For example, if you wanted to find out the number of days that difference
    represents, you would simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: To get the unit, you simply start with milliseconds and work up. Therefore,
    a day is `1,000 milliseconds * 60 seconds * 60 minutes * 24 hours`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding or subtracting time from dates is also very simple. The set* methods
    provided by the `Date` object provide a means for us to roll over values that
    exceed the next largest unit. For instance, if the current date is `April 25,
    2019`, adding `10` days will change the date to `May 5, 2019`. This feature is
    applicable to all of the `set` functions. Thus, to add time, simply get the unit
    of time you wish to add to and add to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 5.02: Creating a To-Do Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's utilize all the information we have learned about in this chapter and
    see what we have retained. For this activity, imagine that you are working with
    a team of developers and your project is to create a stateful model that stores
    entries for a To-Do application. The model will be a primary function, though
    other functions can be created and used by it. The function will need to store
    one or more entries and will receive "actions" that tell the state to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'These actions will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new To-Do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a To-Do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify a To-Do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions will be passed to the state with a given action keyword of either `CREATE`,
    `REMOVE`, or `MODIFY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each To-Do item in the state will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Activity fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_05_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.25: Activity fields'
  prefs: []
  type: TYPE_NORMAL
- en: The data will be passed to the state function with the action type. If the action
    is a `CREATE` action, then all of the preceding fields will be passed, with the
    exception of the `id` field. If it is a `REMOVE` action, then only the `id` is
    passed. It will be passed as a string value. Finally, if the `MODIFY` action is
    passed, then all of the data is passed, with the exception of the `created_at`
    value. This is because the `created_at` value shouldn't change.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of this task is to ensure that the state data is treated as
    immutable since the project manager is a fan of functional programming and wants
    to ensure that as few bugs as possible are added to the application. No objects,
    including `Arrays` and `Dates`, should be changed in this activity. Instead, new
    objects, `Arrays`, and `Dates` must be created, replacing the old values. This
    must also be true of the Array containing the `TODO` entries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Array `concat` function returns a new Array, but any objects within it will
    still be references to the original values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when each action is received, the state function will need to pretty-print
    the data to the console. For `CREATE` actions, this will be the incoming data
    and for `REMOVE` actions, this will be the removed data. For `MODIFY` actions,
    both the removed and created data should be printed.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes to plan, you will be able to add, remove, and modify entries in
    your state function without worrying about corrupted data. You can prove this
    by modifying the values you send to the state function. If the entries in the
    state function are also modified, your model is not immutable.
  prefs: []
  type: TYPE_NORMAL
- en: This activity highlights a common means to handle application data effectively
    and in a way that will not introduce bugs to your application. By managing data
    in a pure manner, you will ensure that your development practices produce reliable
    results in a short period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the function signature to accept the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current state, which is the current list of To-Do items
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The action, which is simply a string value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The data to apply to the state change
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function signature will look as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here, `state` is the current Array of `ToDo` items in the model, `action` is
    either `CREATE`, `MODIFY`, or `REMOVE`, and `data` is either new `ToDo` data or
    simply the parameter to match a `ToDo` item to remove.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a conditional for each action type. Then, in the body of the condition,
    manipulate the state as needed. Remember to return the new state within the condition
    body. You may want to create a secondary function that does the lookup of a `ToDo`
    within the state as you'll need this functionality in the `MODIFY` and `REMOVE`
    actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, this function should always return a new state value. That way, it
    is possible to cleanly test the function predictably and ensure that it works
    as intended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An example of how this function may be called is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 726\.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot has been covered in this chapter. You should now have a deeper understanding
    of the types provided by JavaScript, but also the subtle ways in which each type
    is related. Understanding how data is represented in a language provides a solid
    foundation for building applications more quickly and with fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: As well as understanding the data types, you also saw how to manipulate them,
    both with methods and with helper functions provided by the JavaScript engine.
    You also saw how to convert data into different types, in order to enable data
    interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you saw how you can debug your data using the console and using string-based
    data formatting capabilities provided by the language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will start down the path of user interactivity and
    see how events can be triggered to force your code to do something. You will also
    be introduced to the relationship between the JavaScript language and the HTML
    DOM in the browser environment.
  prefs: []
  type: TYPE_NORMAL
