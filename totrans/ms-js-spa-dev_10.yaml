- en: Chapter 10. Displaying Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart and soul of most SPAs is a dynamic frontend. SPAs move a lot of the
    heavy lifting, related to display logic, onto the browser. Modern browsers have
    fast and powerful JavaScript engines that can handle a lot more computation than
    just a few years ago. In fact, Node.js is built on top of the VB engine, which
    is a standard part of the Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, however, the main idea of an SPA is to give the user an experience
    approaching that of a desktop application. Complete page loads are a thing of
    the past, replaced by snappy changes in state.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build out the heart of our own SPA. This will be a
    dashboard where users can build `giftlists` and share them with other users. We
    will have to build out a couple more routes and data structures on the backend,
    but we will focus on the frontend. We will build an Express view that will load
    AngularJS - a JavaScript toolkit designed specifically for rapid creation of SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: We will build AngularJS routes, views, services, and controllers that will implement
    the core functionality of the SPA. Using the AngularJS plugin, UI-router, we will
    manage the state of our application. We will also implement services to communicate
    to the end so that data can flow freely in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing the initial dashboard view in Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing AngularJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AngularJS `$resource` to access RESTful endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this is a SPA, we need to set up a single page to contain our application.
    In our case, we are going to build a user dashboard. That dashboard will allow
    a user to create `giftlists` (such as birthday wish lists), choose who they want
    to share them with, and see lists that have been shared with them. In the next
    chapter, we're going to build authentication so that individual users will only
    be able to see their own dashboards, but for now we need to mock things up without
    authentication a bit.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a couple of routes, and a view. We're also going to use `Bootstrap`
    to style our view a little.
  prefs: []
  type: TYPE_NORMAL
- en: Building the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create a view for our dashboard. Create a new folder in your views
    directory called `dash`. Inside that folder, create a file called `dashboard.ejs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So there's nothing too exciting here yet. We have set up some placeholders,
    and we are assuming that we'll have a `user` object to display. We can't see our
    view yet - for that we need a `route` which will render the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up the `route` to display our dashboard. In your `routes` directory,
    create a new file called `dashboard.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have done a couple of things here. First, we set up our middleware to respond
    to routes with an id parameter as we did with our users' routes. Next, we set
    up a route for displaying our dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you have the ID for a user memorized, it''s going to be hard to test
    our new view. Let''s make it a little easier by modifying the view that lists
    our users. Open up `views/users/show.ejs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a new column in our users table with a link to the dashboard for each
    user. We still can''t display our dashboard yet. We have to make a change to our
    `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The two key changes here are that we import the dashboard router, we then map
    any requests to `/dash` to that `router`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure your MongoDB daemon is still running, and restart it if it isn''t.
    Start or restart your server. Navigate to your list of users at `http://localhost:3000/users/show`
    and then click on one of the `view` links in the right of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/image_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The URL should look something like this: `http://localhost:3000/dash/566dd0cb1c09d090fd36ba83`.
    You should see a page that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/image_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a `view` template and routing set up to display the page. The next
    thing we need to do is to build out some data.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to initial data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application is going to allow users to build `giftlists` and share them
    with other users. We want to think a little bit about how we want to represent
    our data. A good data model will serve us, even as we add and change features.
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned, MongoDB is very flexible, and we could just embed documents
    inside documents. This might work; we could just have each user with an array
    of lists. The issue with that is that our individual user documents would be highly
    mutable, and could grow to an enormous size easily. It also doesn't offer a lot
    of flexibility down the road if we want to do something like having shared lists.
  prefs: []
  type: TYPE_NORMAL
- en: The type of relationship that we want to have for now is a one-to-many relationship.
    One user can have many lists. The way we'll accomplish this is to store a reference
    to the user who owns the list on the list itself. Later, if we want to have more
    than one user *own* a list, the change would be pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use our `giftapp` database, and we are going to be creating a new
    collection of `giftlists`. Start up the MongoDB command-line tool in a new terminal
    window. Note that you''ll want to copy the exact `ID` of one of your users since
    it will differ from mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The important part here is the format of the insert statement. Let's break it
    apart a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We insert this object into the `giftlist` collection, which will be created
    if it doesn't already exist. The object has a name property and a `gifts` property.
    The `gifts` property is an array of objects, each containing a name property.
  prefs: []
  type: TYPE_NORMAL
- en: We also have an `owner_id` property. This property is a reference to the user
    to whom the `giftlist` belongs. It's just the string of the user's `_id`. Since
    MongoDB is a non-relational database, we will just stash this in here to do lookups
    in the `users` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know we''re going to be looking things up by the owner, so let''s add an
    `index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what we have got by running a query on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just what we would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify our `dashboard.js` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have modified the call to `router.param()` to search the `giftlists` collection
    based on the user `id` passed in. If we get a `giftlist` back, we then search
    the `users` collection to get the user data.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there are two calls to the database here. This is a bit of a trade-off
    in performance for flexibility. Remember that we decided earlier not to embed
    `giftlists` in the user document. This trade-off is something you will want to
    think through in your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also modify our `dashboard.ejs` view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an unordered list that renders the name of each of our `giftlists`.
    When we start adding AngularJS, we''ll link each of these to a state that displays
    the lists. Navigating to the `user dashboard` page, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to initial data](img/image_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a list of our user's `giftlists` and a placeholder for lists that
    have been shared with them. In a little bit, when we add AngularJS, we will also
    add the code for adding, editing, and sharing lists.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, our dashboard is somewhat ugly. Let's fix that a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't heard of `Bootstrap` before, it is an extremely popular CSS framework.
    Plugging in `Bootstrap` helps frontend developers do things such as layout, painting
    buttons, and implementing controls without writing a lot of code by hand.
  prefs: []
  type: TYPE_NORMAL
- en: You can get `Bootstrap`, and see its documentation at [https://getbootstrap.com](https://getbootstrap.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sweeten up our `dashboard.ejs` template a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the head of our document, you'll see three new lines. The first is a `meta`
    tag, which sets the viewport for mobile devices. The next two load `Bootstrap`
    and a `Bootstrap` theme from a CDN.
  prefs: []
  type: TYPE_NORMAL
- en: We then place what we had inside an `H1` tag into a number of elements, which
    will paint a `nav` bar at the top of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is a `div` element with a class of container. This is necessary
    for the `Bootstrap` layout to work. `Bootstrap` uses a grid system for a layout
    with rows and columns. Basically, there are 12 columns of equal width in a row.
  prefs: []
  type: TYPE_NORMAL
- en: Classes such as `col-xs-12` tell `Bootstrap` that, when the view port is extra
    small (like on a phone), that particular element should take up the entire width
    of the container. The  `col-md-6` class, makes the element half the width (six
    columns) when the screen is medium width or greater. By combining these classes,
    we can have a variable layout that makes sense based upon screen width. This is
    a main component of what's referred to as responsive design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at our dashboard in full width, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Bootstrap](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In full size, our dashboard is divided into two equal width columns. You can
    also see our top `nav` bar is with **Mark Smith Dashboard** is rendering. Now,
    if you drag the side of your browser to make it narrow like a mobile phone screen,
    you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Bootstrap](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our columns are now stacked one on top of each other, which makes a lot more
    sense for a mobile form factor. Let''s add a button element to add new lists,
    which we''ll actually connect later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We added a button with a class of `btn-primary`. Inside that button we have
    a span with a couple of `glyphicon` classes. These classes actually use a font
    to paint different types of common symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing our page now, we''ll see a pretty blue button with a plus sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Bootstrap](img/image_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll be developing further visual components as AngularJS views.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to implement most of our view logic by implementing a more robust
    AngularJS application. The first thing we need to do is to add AngularJS code
    to our `dashboard.ejs` view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We linked to AngularJS version 1.4.8 on a CDN, as well as a plugin called UI-router.
    We'll be talking about UI-router in depth. We also added the AngularJS directive
    `ng-app` to the opening `html` tag. When AngularJS loads, it looks for this directive
    to see what part of the document it should manage. Most applications will have
    Angular manage from the top level by doing this, though one could `Bootstrap`
    AngularJS into any part of the document.
  prefs: []
  type: TYPE_NORMAL
- en: Our AngularJS module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS packages applications, parts of applications, and dependencies using
    modules. Everything we're going to do with AngularJS is going to be done by using
    modules or using code, such as controllers, which have been added to modules.
  prefs: []
  type: TYPE_NORMAL
- en: This is a core part of AngularJS architecture. Modules are containers for the
    parts of your application, and allow AngularJS to properly `Bootstrap` your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, our module is going to be simple, then we''ll add to it as we go on.
    Create a new file called `giftapp.js` inside `public/javascripts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We create our module by invoking the `angular.module()` function. The first
    argument is the name of the module. The second argument is an array containing
    a list of dependencies we want to inject into our module. In this case, the only
    one we're injecting at the moment is UI-router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add our module to our `dashboard.ejs` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We simply load our module using a normal `script` tag. Also, we change the `ng-app`
    directive so that it will use our new module as the main application entry point
    for the page.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling state with UI-router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State can mean a lot of things in applications, but in our SPA it refers to
    a given set of views, controllers, and data that can be invoked using a URL changer.
    By far the most popular way for developers to handle state in their AngularJS
    applications is with a plugin called UI-router.
  prefs: []
  type: TYPE_NORMAL
- en: The UI-router plugin allows us to control state rather elegantly, and is extremely
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement UI-router in our application. First, we will reference UI-router
    from a CDN in our `dashboard.ejs` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We linked to UI-router on a CDN and loaded it using a normal `script` tag. The
    other major change in our template is the addition of a `ui-view` directive implemented
    as an attribute on a `div` element. The `ui-view` directive tells UI-router where
    to load the views that it's going to be painting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to edit our `giftapp.js` application file to add routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we make sure to inject the `ui.router` module into our module. We chain
    a `config` function onto our module declaration. Using an array notation, we inject
    `$stateProvider` and `$urlRouteprovider` into the `config` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that function, the magic happens. First, we invoke `$urlRouterProvider.otherwise('/dash');`,
    which sets the default route. When we load our page, unless another route is triggered
    with a URL fragment, `#/dash` will be appended to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up two states on `$stateProvider`. For now, each is named and has
    a URL and `templateURL` property. The template URL points to a URL for a visual
    template to load.
  prefs: []
  type: TYPE_NORMAL
- en: Let's mock up our two templates. Create a new directory at `public/templates`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `dash-main.tpl.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is our `dash-add.tpl.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've mocked up a form that could be used to add a new list. We'll flesh
    it out later, and actually connect it to the backend to store data.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, our templates are basically just dumb HTML, the AngularJS method
    of linking our DOM to data and functionality. Controllers contain business logic,
    but should not be used to manipulate the DOM directly.
  prefs: []
  type: TYPE_NORMAL
- en: In using UI-router, we can easily attach controllers to states, making their
    `$scope` available to our views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new controllers folder inside `public/javascripts`. Create a new JavaScript
    file called `dashMainController.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We create a new module called `giftAppControllers` that takes no dependencies.
    Then, we build a controller called `DashMainController`. Using an array notation,
    we inject `$scope` and then declare a constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that function we attach a lists array to `$scope`, which will make it
    available to any view that references this controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to load that file into the `dashboard.ejs` view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You'll note that you can load the controller module after your main module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to edit our main `giftapp.js` module to use the new controller
    as part of a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is to inject our new controller module into our `giftapp`
    module. This makes the `DashMainController` available in the module. We then set
    its name, as a string, to the controller property on our `dash` state.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we should do is to modify our template to take advantage of our
    new controller. Any methods or properties added to `$scope` in a controller become
    available inside the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our new `dash-main.tpl.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instead of canned list items, we rely on the `ng-repeat` directive (provided
    by AngularJS itself). The `ng-repeat` directive iterates over things that are
    iterable - in this case an array called list. For each member of the array, the
    directive will paint a `li` element, assigning the instance to the variable list
    (essentially creating a new scope). Since our list objects all have name properties,
    we can access this in a markup expression with `{{list.name}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making sure our database and server are running, refreshing our dashboard should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AngularJS controllers](img/image_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Christmas List** and **Birthday List** are coming from `$scope` in our new
    controller. Clicking on the **Add List** button takes us to our add state and
    the page suddenly looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AngularJS controllers](img/image_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So now we have the essence of a single page web application working. We have
    a model, views, and a controller. We have a method of managing state.
  prefs: []
  type: TYPE_NORMAL
- en: In mocking up this functionality, we did remove the connection to the database.
    So let's add that back in the AngularJS way.
  prefs: []
  type: TYPE_NORMAL
- en: Talking to the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now we need to connect our frontend to our backend. Instead of rendering
    data in our page on load, we want to use AJAX to connect and do all of our CRUD.
    Fortunately for us, Angular has a pretty elegant way of handling this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AngularJS factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that different parts of our application may need access to some of
    the same data endpoints, or some other functionality. A great way to handle this
    is with an AngularJS provider. A provider is essentially an injectable singleton,
    and there are a number of options available - see [https://docs.angularjs.org/guide/providers](https://docs.angularjs.org/guide/providers).
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider type we are going to use is a factory. Let''s start by creating
    a `services` directory inside our `public/javascripts` directory. Create a new
    file called `giftlistFactory.js` inside that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've created another module for services, and then created a factory called
    `List` on that module. That factory doesn't do much yet, but we'll get to that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll load this file using a `script` tag in our `dashboard.ejs` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re loading this module, we can inject it into our controller.
    Open up `dashMainController.js` and edit the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We inject the `giftlistServices` module into our `giftappControllers` module.
    In our `DashMainController`, we inject the `List` factory. Currently, `List` only
    returns an empty object, but anything we place in there going forward becomes
    available to our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Using AngularJS $resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The smart people who develop AngularJS figured out that a lot of what people
    want to do in an SPA is to talk to RESTful services. They had the idea to build
    a factory on top of their `$http` service (which provides AJAX functionality),
    which would provide an easy way to interact with a RESTful interface. That's precisely
    what `$resource` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by loading the `ngResource` module, which exposes `$resource`.
    In our `dashboard.ejs` template, add a `script` tag to load the module from CDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the module loaded, let''s edit our factory to utilize `$resource`.
    Open `giftlistFactory` and make the following edits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we inject the `ngResource` module in our module. This allows
    us to inject `$resource` into our `List` factory. Lastly, we return the result
    of invoking `$resouce` with the path `/giftlist/:id`. This, combined with the
    second argument, sets up a number of functions that optionally include an `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the resourceful controller we built earlier? We''re going to make
    an edit with some hardcoded data, for now. `Opencontrollers/giftlist_controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For now, only edit the `index`. You can see that I've hardcoded the `owner_id`
    for the query to match the user in the database I've been working with. You should
    match your `user id` accordingly as it will differ from mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit your `dashMainController.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the value of `$scope.lists` to the result of running a query on our
    `List` resource. In this case, the result is an array of objects. If you restart
    your server and then reload the page, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using AngularJS $resource](img/image_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built out the major parts of the UI side of your SPA. You
    started by building a view in Express. You included `Bootstrap` for some easy
    styling, layout, and responsiveness. Then you refactored the page to utilize AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: You set up modules, routes, templates, and a controller using AngularJS. You
    then built a factory and injected `$resource` into it. You started to access data
    from a RESTful endpoint and then displayed that data in your application by mapping
    it to `$scope` in your controller.
  prefs: []
  type: TYPE_NORMAL
