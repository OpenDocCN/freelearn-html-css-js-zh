<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer312">
			</div>
		</div>
		<div class="Content" id="_idContainer313">
			<h1 id="_idParaDest-487"><a id="_idTextAnchor543"/>13. JavaScript Programming Paradigms</h1>
		</div>
		<div class="Content" id="_idContainer328">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to apply different JavaScript paradigms; use prototypes, inheritance, and anonymous functions; list different types of data scopes and closures; declare variables using hoisting; and explain JavaScript memory management.</p>
			<p class="callout">In this chapter, we will dig deep into the core features of JavaScript that make it a very diverse and multi-paradigm programming language.</p>
			<h1 id="_idParaDest-488"><a id="_idTextAnchor544"/>Introduction</h1>
			<p>So far, we know the importance of JavaScript at the browser level and its power at the server level. We have learned how to install Node.js on the system and how to write and execute code. Also, we have gained a huge amount of knowledge about the internal and external modules of Node.js. Moreover, web sockets and working with databases were also covered in the previous chapters. We learned all of this through interesting activities and exercises. Now it's time to strengthen this knowledge and learn about the root concepts of JavaScript.</p>
			<p>In this chapter, we will go through the different types of JavaScript programming paradigms. During the learning phase of any programming language, people usually code in a procedural way; instead of planning, they put most of their focus on execution and understanding the concepts of that particular programming language. But when it comes to working on real-life problems, the procedural way is not a scalable option. Luckily, we have a lot of different types of code implementation techniques that we can use to model real-life entities with a programming language, such as the <strong class="bold">object-oriented programming</strong> paradigm, or <strong class="bold">OOP</strong>. </p>
			<p>Let's take a real-world example in which we have to build a project for our college. There will be teachers, clerks, students, heads of departments, and so on. One way of implementing this project is to write the logic for each of these entities separately, which is not a scalable option, and it will not be a flexible solution either. Another way is to use the OOP approach, in which we will create one <strong class="source-inline">Person</strong> model that will hold a person's designations as keys in the object. This way, we are separating people from their designations. We can easily implement changes in either <strong class="source-inline">Person</strong> or entities, that is, heads, teachers, students, and so on. All the changes to <strong class="source-inline">Person</strong> will automatically be implemented on entities because they belong to the <strong class="source-inline">Person</strong> class. There are a lot of other approaches that we can use to solve the same types of problems. We will go through some of them in this chapter.</p>
			<p>After that, you will learn what prototypes are and how to use them to achieve inheritance. There are a lot of other basics as well. Let's start.</p>
			<h1 id="_idParaDest-489"><a id="_idTextAnchor545"/>JavaScript Paradigms</h1>
			<p>A programming paradigm is a way or method in which we write code to solve different types of problems. Since there are a lot of ways to code, there are a lot of programming paradigms that developers use to write code. </p>
			<p>JavaScript is a multi-paradigm scripting language, which means that it is very dynamic in nature and supports various types of programming styles, such as object-oriented, imperative, and functional programming. In this book, we will discuss the three main programming paradigms that are popular among developers. </p>
			<p>We can divide programming paradigms into two categories: </p>
			<ul>
				<li>Imperative, which includes <strong class="bold">Procedural Programming</strong> and <strong class="bold">OOP</strong></li>
				<li>Declarative, which includes <strong class="bold">Functional Programming</strong></li>
			</ul>
			<p>In this chapter, we will discuss procedural and object-oriented programming. Functional programming is quite popular, and there are a lot of concepts to learn, so we have dedicated one chapter, named Functional Programming, to cover that topic. </p>
			<h2 id="_idParaDest-490"><a id="_idTextAnchor546"/>The Procedural Paradigm</h2>
			<p>As the name suggests, this paradigm follows the procedural pattern. In this paradigm, we divide our whole program into routines and subroutines. The process flow is very linear and synchronous in this coding pattern. It follows a top-down approach to programming. It simply involves breaking down the desired result in some routines and smaller subroutines. These subroutines will be further divided into processes, which will then be executed to achieve the desired result.</p>
			<p>Procedural programming uses a top-down approach to write an application, while OOP follows a zigzag approach to the data flow. Reusability is one of the most important factors when developing large applications. There is less reusability in procedural programming compared with OOP, and that is the reason why the object-oriented approach is more popular in scalable applications. When developing programs using procedural programming, we might plan out a program without thinking about recycling code.</p>
			<p>The data flow is sequential in procedural programming, but that doesn't mean we do not have to plan the data flow. Planning is still involved in procedural programming. It takes a much more literal approach. Procedural programming applications are structured more like a story format. The procedural approach makes the development process much simpler, but it consumes more time.</p>
			<p>The pros of adapting to the procedural paradigm are as follows:</p>
			<ul>
				<li>A lot of learning resources can be found online.</li>
				<li>It has an easier way to track process flow.</li>
				<li>The implementation of programs is very easy.</li>
			</ul>
			<p>The cons of adapting to the procedural paradigm are as follows:</p>
			<ul>
				<li>It is difficult to relate to the real world.</li>
				<li>There is less data security.</li>
				<li>It is difficult to solve complex problems with this approach.</li>
			</ul>
			<p>The procedural approach is one of the basic approaches that most people use when they start learning code. So, to strengthen our concepts, it's always better to practice what we have just learned. Let's do an exercise in which we will implement a very basic and simple function using straightforward procedural programming.</p>
			<h2 id="_idParaDest-491"><a id="_idTextAnchor547"/>Exercise 13.01: Implementing Procedural Programming</h2>
			<p>In this exercise, we have a string and we have to capitalize every word in it. As per the procedural approach, we have to implement it in such a way that each statement executes in a top-down manner. This means that we will start with the first statement and by the last statement, we will have our result. In order to do that, we have to perform some operations. Let's look at them one by one:</p>
			<ol>
				<li>First, let's create an empty file and call it <strong class="source-inline">procedural.js</strong>. You can change the name if you want.</li>
				<li>Let's write a function called <strong class="source-inline">toCapitalize()</strong>, which will take one argument as an input. The input parameter will be of the string type only:<p class="source-code">functiontoCapitalize(input){</p><p class="source-code">   }</p></li>
				<li>Inside this function, let's first split the input string using spaces. This will divide the input string into words and will return an array of all those words:<p class="source-code">let arrayOfString = input.split(' ');</p><p>After this statement, <strong class="source-inline">arrayOfString</strong> will hold an array of words, that is [ '<strong class="source-inline">Once'</strong>, '<strong class="source-inline">upon'</strong>, '<strong class="source-inline">a'</strong>, '<strong class="source-inline">time'</strong>, '<strong class="source-inline">in'</strong>, '<strong class="source-inline">new'</strong>, '<strong class="source-inline">york'</strong>].</p></li>
				<li>Let's loop over the array:<p class="source-code">for(let i=0; i&lt;arrayOfString.length; i++) {</p><p class="source-code">   }</p></li>
				<li>Inside this <strong class="source-inline">for</strong> loop, extract the first letter of all the words and save the result in a variable:<p class="source-code">letfirstChar = arrayOfString[i].charAt(0);</p></li>
				<li>Let's make this letter uppercase using the <strong class="source-inline">toUpperCase()</strong> method:<p class="source-code">firstChar.toUpperCase();</p></li>
				<li>Now, remove the first letter of every word from the input string and replace it with the one we just made uppercase:<p class="source-code">arrayOfString[i] = firstChar.toUpperCase() + arrayOfString[i].slice(1);</p></li>
				<li>Finally, let's join all the words of the array, including the spaces, to make a sentence again and return it as the output of the function:<p class="source-code">arrayOfString.join(' ');</p></li>
				<li>Now we can pass any string to this function and it will return the string with all the words with the first letter in uppercase:<p class="source-code">let string = "Once upon a time in new york.";</p><p class="source-code">    console.log(toCapitalize(string));</p></li>
				<li>Let's execute this script with Node.js and look at the output:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer314">
					<img alt="Figure 13.1: Output of the procedural exercise&#13;&#10;" src="image/C14377_13_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1: Output of the procedural exercise</p>
			<p>As you can see, we now have our desired output: the first letter of each word is uppercase. In the code, we have called a lot of methods, such as <strong class="source-inline">split</strong>, <strong class="source-inline">toUpperCase</strong>, <strong class="source-inline">slice</strong>, and <strong class="source-inline">join</strong>. All these functions were called in a top-down manner. We started with the first statement of this function, where we had our input string, and then we processed the input. After the execution of the last statement of this function, we have our desired result. This is a simple example of the implementation of procedural programming. Next, we will learn how to implement the object-oriented approach in programming.</p>
			<h2 id="_idParaDest-492"><a id="_idTextAnchor548"/>The Object-Oriented Paradigm</h2>
			<p>The object-oriented paradigm is one of the most popular paradigms used by developers. A lot of programming languages are oriented to this paradigm. The reason for its popularity is its ability to model real-life things in code. In this paradigm, we can create objects that will represent entities in the real world.</p>
			<p>We use classes to imitate real-world categories, and then we can create objects from those classes, which will act like entities. All classes in JavaScript have one constructor function that will execute every time we initiate new instances of that object. We use the <strong class="source-inline">Class</strong> keyword to create a class, and <strong class="source-inline">constructor</strong> is a default function inside each class:</p>
			<p class="source-code">class Animal{</p>
			<p class="source-code">constructor(category){</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p>Whatever we are initializing in the <strong class="source-inline">constructor</strong> function will have a scope level of this whole class. We can use the <strong class="source-inline">new</strong> keyword to create instances of this object:</p>
			<p class="source-code">new Animal('Lion');</p>
			<p>Here, the parameter passed when creating the new instance will get passed straight to the <strong class="source-inline">constructor</strong> function.</p>
			<h2 id="_idParaDest-493"><a id="_idTextAnchor549"/>Exercise 13.02: Implementing OOP</h2>
			<p>The object-oriented paradigm is the best one to implement because we can relate the code to real life. We create classes of real-world entities, such as cars, furniture, and electronics, and create instances of those classes to represent real-world objects. For example, imagine you have a car from the manufacturer Audi. The car is an entity that we can represent as a class in OOP. We can create an instance of this <strong class="source-inline">car</strong> class, which will represent your car, and this instance will hold information about you, such as that the car's owner is you and the car's manufacturer is Audi. Each instance will act as the registration of that vehicle. That way, we can create relations between the code and the real world.</p>
			<p>The best way to understand this is by taking an example from the real world and implementing it. Let's consider a simple program that displays information about the living beings on Earth. To do this, we have to make a class of living beings and we can create multiple instances of that class, such as <strong class="source-inline">Humans</strong>, <strong class="source-inline">Animals</strong>, and <strong class="source-inline">Plants</strong>.</p>
			<p>To start this off, we have to first create a class of <strong class="source-inline">Humans</strong>. There are a lot of things that are common in humans, such as age, weight, height, and skin and hair color, but in this case, we are only interested in showing their age, name, and gender:</p>
			<ol>
				<li value="1">Let's create an empty file and call it <strong class="source-inline">humans.js</strong>.</li>
				<li>Now, let's create a class called <strong class="source-inline">Humans</strong> and a <strong class="source-inline">constructor</strong> function, which will take <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">gender</strong> as parameters:<p class="source-code">class Humans {</p><p class="source-code">constructor(name, age, gender) {</p><p class="source-code">        this.name = name;</p><p class="source-code">this.age = age;</p><p class="source-code">this.gender = gender;</p><p class="source-code">    }</p><p class="source-code"> }</p></li>
				<li>Let's create one more method inside this class, which will print the values of <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">gender</strong> because only the methods of this class have access to class variables:<p class="source-code">info() {</p><p class="source-code">return console.log(this);</p><p class="source-code">    }</p></li>
				<li>From our <strong class="source-inline">Humans</strong> class, we can now create some instances that represent actual humans: <p class="source-code">let Gaurav = new Humans('Gaurav', 24, 'Male');</p><p class="source-code">let Nishi = new Humans('Nishi', 23, 'Female');</p></li>
				<li>Now we will print both of these objects. They will contain all the information we passed to the constructor when we created them:<div class="IMG---Figure" id="_idContainer315"><img alt="Figure 13.2: Output for the object-oriented exercise&#13;&#10;" src="image/C14377_13_02.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.2: Output for the object-oriented exercise</p>
			<p>As you can see, we now have two instances of the <strong class="source-inline">Humans</strong> class, each of which holds information about a human. We can treat these two instances as real humans. They have their own <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">gender</strong>. This will help you a lot when writing code because you know the object you are writing the logic for. Similarly, we can implement any real-world entity as a class and can create multiple objects of that class, which can represent real-world objects.</p>
			<p>So far, we know there are a lot of benefits of using OOP, and some of them are very useful. Next, we'll look at two very important features that this paradigm provides – encapsulation and inheritance. Let's go through each of them and see how we can use these concepts with JavaScript. </p>
			<h3 id="_idParaDest-494"><a id="_idTextAnchor550"/>Encapsulation</h3>
			<p>One benefit of using OOP is that it protects the data in classes. We can add data to classes that will only be available for the class' methods. Other classes will not be able to access that data. It works as a protective shield for the class.</p>
			<p>As we saw in the previous example, the scope of the <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">gender</strong> variables was limited to the class. All the methods initialized in the class can have access to those variables. This is how we can protect data inside a class.</p>
			<h3 id="_idParaDest-495"><a id="_idTextAnchor551"/>Inheritance</h3>
			<p>Inheritance is a way in which one class can have access to the properties of another class. In the last example, humans can have a lot of different types of professions. So, we can inherit the <strong class="source-inline">Humans</strong> class by professions as well. Let's examine this concept by doing an exercise. In the last exercise, we created a <strong class="source-inline">Humans</strong> class that holds the name, gender, and age information. We will extend this class further by creating a new class called <strong class="source-inline">Teacher</strong>. This class will hold all the properties of the <strong class="source-inline">Humans</strong> class along with some additional properties describing the subject they teach, grades, and more. This will give you an idea of how classes are extended and how parent class properties are inherited by other classes. Let's jump into the code now.</p>
			<h2 id="_idParaDest-496"><a id="_idTextAnchor552"/>Exercise 13.03: Inheritance Implementation Using the extends Keyword</h2>
			<p>Let's create a class called <strong class="source-inline">Teacher</strong> that will inherit the properties of the <strong class="source-inline">Humans</strong> class. We will use the <strong class="source-inline">extends</strong> keyword to inherit from classes in this exercise: </p>
			<ol>
				<li value="1">Use the <strong class="source-inline">extends</strong> keyword to inherit from the class:<p class="source-code">class Teacher extends Humans {</p><p class="source-code">  }</p></li>
				<li>Inside this class, we have to pass all the necessary parameters to the <strong class="source-inline">constructor</strong> function. Inside the <strong class="source-inline">constructor</strong> function, we will call the<strong class="source-inline"> super</strong> function and pass the parameters required for the parent class:<p class="source-code">constructor( name, age, gender, subject, grade ) {</p><p class="source-code">        super(name, age, gender);</p><p class="source-code">this.subject = subject;</p><p class="source-code">this.grade = grade;</p><p class="source-code">    }</p></li>
				<li>Here, <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">gender</strong> are parameters of the <strong class="source-inline">Humans </strong>class. Using the <strong class="source-inline">super </strong>function, we passed these parameters to the <strong class="source-inline">Humans</strong> class and the rest of the variables, that is, <strong class="source-inline">subject</strong> and <strong class="source-inline">grade</strong>, are a part of the <strong class="source-inline">Teacher</strong> class. </li>
				<li>Let's have an <strong class="source-inline">info</strong> method in the <strong class="source-inline">Teacher</strong> class that will print all the variables of that class:<p class="source-code">info(){</p><p class="source-code">         return console.log(this);</p><p class="source-code">    }</p></li>
				<li>After we have finished creating the <strong class="source-inline">Teache</strong>r class, let's create an instance of it:<p class="source-code">let teacher = new Teacher('GauravMehla', 24, 'Male','Science', 'A');</p></li>
				<li>Finally, let's run this script with Node.js:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer316">
					<img alt="Figure 13.3: Teacher instance after inheritance&#13;&#10;" src="image/C14377_13_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: Teacher instance after inheritance</p>
			<p>As you can see in the output, there are some properties, such as <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">gender</strong>, that are not present in the <strong class="source-inline">Teacher</strong> class. These properties are inherited from the <strong class="source-inline">Humans</strong> class, which we implemented in <em class="italic">Exercise 13.02: Implementing OOP</em>. </p>
			<p>Now that we know how to achieve inheritance using JavaScript, we can now create multiple objects of the <strong class="source-inline">Teacher</strong> class that will inherit all the properties of their parent class, <strong class="source-inline">Humans</strong>. </p>
			<p>Let's look at some of the pros of adopting the object-oriented paradigm:</p>
			<ul>
				<li><strong class="bold">Reusability</strong>: We can use already-created classes again and again without creating new classes.</li>
				<li><strong class="bold">Real-Life modeling</strong>: We can model a real-world concept using OOP, such as a chair, person, or car. This makes understanding the implementation easy.</li>
				<li><strong class="bold">Parallel development</strong>: Classes can be independent, which means we can develop more than one class at a time. This results in quicker project development.</li>
				<li><strong class="bold">Team independency</strong>: As OOP supports parallel development, teams can work independently of each other.</li>
				<li><strong class="bold">Secured development</strong>: OOP features, such as inheritance and encapsulation, hide data from other classes, thereby improving security. The internal data of a class can't be accessed by external functions.</li>
			</ul>
			<p>The possible cons of using the object-oriented paradigm:</p>
			<ul>
				<li><strong class="bold">Unnecessary code:</strong> It can create an enormous amount of unnecessary and bloated code if it's not implemented with proper planning.</li>
				<li><strong class="bold">Duplication</strong>: As OOP can be implemented for each individual class, it can lead to code duplication.</li>
				<li><strong class="bold">Early planning</strong>: Programmers should have a proper plan before designing a program. </li>
				<li><strong class="bold">Project size</strong>: Projects developed with OOP are often larger than projects developed with other approaches, such as the procedural paradigm.</li>
			</ul>
			<p>In this section, we have learned about different types of programming paradigms we can use with JavaScript. We dug deep into two of the most popular paradigms – procedural and object-oriented. We went through different pros and cons of both paradigms. We also learned about two of the most important features of OOP, which are encapsulation and inheritance. </p>
			<h1 id="_idParaDest-497"><a id="_idTextAnchor553"/>Basic JavaScript Concepts</h1>
			<p>Programming paradigms are important, but to understand them in detail, we need a basic understanding of different JavaScript concepts. So, let's go through some of the core concepts of JavaScript, which will help you get a grasp of JavaScript and give you a better understanding of how we can use programming paradigms to build scalable solutions to problems.</p>
			<h2 id="_idParaDest-498"><a id="_idTextAnchor554"/>Prototypes and Prototypical Inheritance</h2>
			<p>Objects are very important because they help us manipulate JavaScript to achieve the functionality we want. There are a lot of ways to create objects in JavaScript. One of the ways is by using a <strong class="source-inline">constructor</strong> function, and whenever we create a function, the JavaScript engine adds a <strong class="source-inline">prototype</strong> property to the function. This <strong class="source-inline">prototype</strong> property is an object that has a <strong class="source-inline">constructor</strong> property by default. This constructor points back to the parent functions. You can see this function by calling <strong class="source-inline">functionName.prototype</strong>.</p>
			<p>Let's first create a function:</p>
			<p class="source-code">functionPersonName(first_name, last_name) {</p>
			<p class="source-code">this.first_name = first_name;</p>
			<p class="source-code">this.last_name = last_name;</p>
			<p class="source-code">this.fullName = function(){</p>
			<p class="source-code"> return [ this.first_name, this.last_name].join(" ");</p>
			<p class="source-code">     }</p>
			<p class="source-code"> }</p>
			<p>Now, let's check its <strong class="source-inline">prototype</strong> property by entering <strong class="source-inline">PersonName.prototype</strong>.The output will be as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer317">
					<img alt="Figure 13.4: Prototype property of objects&#13;&#10;" src="image/C14377_13_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Prototype property of objects</p>
			<p>As you can see, we have created a function named <strong class="source-inline">Person</strong> and JavaScript automatically binds a <strong class="source-inline">prototype</strong> property to it. You can print the <strong class="source-inline">prototype</strong> and you can see that there is a <strong class="source-inline">constructor</strong> property, which holds all the metadata of the parent function.</p>
			<h2 id="_idParaDest-499"><a id="_idTextAnchor555"/>What Is Prototypical Inheritance?</h2>
			<p>As we know, everything in JavaScript is an object. Every string, integer, array, object, and function that you define is an object of its respective parent class. Each object in JavaScript holds a <strong class="source-inline">proto</strong> property (<strong class="source-inline">__proto__</strong> keys inside child objects are usually referred to as <strong class="source-inline">proto</strong> properties) that holds all the properties of its parent class. We can use these <strong class="source-inline">proto</strong> properties to implement inheritance. These <strong class="source-inline">prototype</strong> objects act as template objects from which all the child objects will inherit methods and properties. We can also override the properties of a parent class using this <strong class="source-inline">prototype</strong> property. This linking of prototypes is referred to as a prototype chain. </p>
			<h2 id="_idParaDest-500"><a id="_idTextAnchor556"/>Exercise 13.04: Prototypical Inheritance Implementation</h2>
			<p>In this exercise, let's implement a very simple function that will take a first name and a last name as parameters and return the full name. After this exercise, you should be completely clear on how prototypical inheritance works and the differences between the two approaches to achieve this output:</p>
			<ol>
				<li value="1">We can implement <strong class="source-inline">firstName</strong> and <strong class="source-inline">lastName</strong> child functions inside the <strong class="source-inline">PersonName</strong> parent function that will have the scope to use the values of the parent function. We can bind the functions to their parent's prototype because the parent function can always access the scope of a child function. Let's implement and observe both approaches. Open the Google Chrome Developer Tools console using the <strong class="source-inline">F12</strong> key.</li>
				<li>Use this constructor function to create some objects and paste the code in the console:<p class="source-code">functionPersonName(firstName, lastName) {</p><p class="source-code">this.firstName = firstName;</p><p class="source-code">this.lastName = lastName;</p><p class="source-code">this.fullName = function(){</p><p class="source-code"> return [ this.firstName, this.lastName].join(" ");</p><p class="source-code">     }</p><p class="source-code"> }</p><p class="source-code">let pName1 = new PersonName("Gaurav", "Mehla");</p><p>Whenever we use a <strong class="source-inline">constructor</strong> function to create objects, JavaScript adds a property to its object, which is <strong class="source-inline">_proto_</strong>. This <strong class="source-inline">_proto_</strong> property holds the link to the prototype of the main function, which can be seen in the following output:</p><div class="IMG---Figure" id="_idContainer318"><img alt="Figure 13.5: Prototype property of instances created with the new keyword&#13;&#10;" src="image/C14377_13_05.jpg"/></div><p class="figure-caption">Figure 13.5: Prototype property of instances created with the new keyword</p><p>As you can see here, the <strong class="source-inline">pName1</strong> object has a <strong class="source-inline">__proto__</strong> property that directly points to the prototype of its parent, <strong class="source-inline">PersonName.prototype</strong>. In the next step, we can use this <strong class="source-inline">prototype</strong> property to achieve inheritance using JavaScript.</p></li>
				<li>Let's bind the <strong class="source-inline">fullName</strong> function with the <strong class="source-inline">prototype</strong> property of <strong class="source-inline">Person</strong> instead of defining it inside the function:<p class="source-code">PersonName.prototype.fullName = function(){</p><p class="source-code">    return [this.firstName, this.lastName].join(" ");</p><p class="source-code">}</p></li>
				<li>Now, create two objects of the <strong class="source-inline">PersonName </strong>method using the <strong class="source-inline">new</strong> keyword:<p class="source-code">let pName1 = new PersonName("Gaurav", "Mehla");</p><p class="source-code"> let pName2 = new PersonName("Sarthak", "Sharma");</p></li>
				<li>All the objects created here with the <strong class="source-inline">new</strong> keyword will now contain a <strong class="source-inline">proto</strong> property, which will point to its parent prototype, and all the functions and properties defined in the parent prototype will be accessible to all its child objects. In other words, if we create a function and bind it to the prototype of the parent function, that function will be accessible to all its objects using the prototype chain object. Now, call the <strong class="source-inline">fullName</strong> function, which is defined in the <strong class="source-inline">prototype</strong> property of the <strong class="source-inline">Person</strong> method, using its objects:<p class="source-code">pName1.fullName();</p><p class="source-code">pName2.fullName();</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer319">
					<img alt="Figure 13.6: Example of a prototype chain&#13;&#10;" src="image/C14377_13_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6: Example of a prototype chain</p>
			<p>In this exercise, we declare a constructor function (<strong class="source-inline">PersonName</strong>), then we create a function (<strong class="source-inline">fullName</strong>) and bind it to its prototype. Then, we create two child objects using the function's constructor. You can see that both of these objects have access to the <strong class="source-inline">fullName</strong> function, which is in their parent's prototype. This way, we have achieved inheritance using a prototype chain, as visualized in <em class="italic">Figure 13.7</em>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer320">
					<img alt="Figure 13.7: References of the __proto__ property&#13;&#10;" src="image/C14377_13_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7: References of the __proto__ property</p>
			<p>Now we can create as many instances of <strong class="source-inline">PersonName</strong> as we want, and all those instances will always have access to <strong class="source-inline">PersonName.fullName</strong>.</p>
			<p>We can even modify the prototypes and the changes will be reflected in all of its child objects instantaneously.</p>
			<h2 id="_idParaDest-501"><a id="_idTextAnchor557"/>Anonymous Functions</h2>
			<p>Objects in the JavaScript language are very tricky. Everything in JavaScript is an object. So, functions in JavaScript are considered functional objects and can be used in the same way as we use objects. Functions in JavaScript can be passed as arguments to other functions as well. Any function that also returns a function is called a function factory. Let's have a look at an example:</p>
			<p class="source-code">functioncalculateSum(a, b) {</p>
			<p class="source-code">    return () =&gt; {</p>
			<p class="source-code">        return a + b();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">let s<a id="_idTextAnchor558"/>um = calculateSum(10, () =&gt;20);</p>
			<p>In this example, we have called a function, <strong class="source-inline">calculateSum</strong>, and passed two parameters to it. One is a number and the other one is a function. This function will return a new function, which will display the passed function followed by the result, as can be seen in the following output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer321">
					<img alt="Figure 13.8: Examples of anonymous functions&#13;&#10;" src="image/C14377_13_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8: Examples of anonymous functions</p>
			<p>In the example, you can see we have used a lot of functions without naming them. These functions are very important in JavaScript. A function declared with no particular name is called an anonymous function. We use anonymous functions a lot when programming in JavaScript. These types of functions are declared dynamically at runtime and can be passed as parameters to other functions. For example, <strong class="source-inline">Function () {}</strong> is a typical example of an anonymous function. You can assign the return value of this function to any variable. Creating functions with this approach allows us to create functions on the go. Anonymous functions are mainly used in callbacks.</p>
			<h2 id="_idParaDest-502"><a id="_idTextAnchor559"/>The Differences between Named Functions and Anonymous Functions</h2>
			<p>The major difference between named and anonymous functions is that when you declare a named function, the compiler allocates a stored memory block to that function. So, if you have to call it, you can use the name to call it. But with anonymous functions, the memory block is assigned to them and the address is returned, which we can then store in a variable. This helps us initialize functions in places where we can't declare named functions. We can even change the name with which we can call this function by assigning the function to another variable. This can be visualized in the following diagram: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer322">
					<img alt="Figure 13.9: Named versus anonymous functions&#13;&#10;" src="image/C14377_13_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9: Named versus anonymous functions</p>
			<h1 id="_idParaDest-503"><a id="_idTextAnchor560"/>Data Scope</h1>
			<p>Data scoping determines the accessibility of variables, functions, and objects in your code during runtime. This means the scope of a variable is controlled by the location of the variable declaration.</p>
			<p>In JavaScript, there are two main types of scopes:</p>
			<ul>
				<li>Global scope</li>
				<li>Local scope, which includes <strong class="bold">function level</strong> and <strong class="bold">block level</strong></li>
			</ul>
			<h2 id="_idParaDest-504"><a id="_idTextAnchor561"/>Global Scope</h2>
			<p>Every JavaScript application has a global scope in which we can define anything that all the functions in our application can access. All the variables defined outside the functions, blocks, and modules have a global scope. Global variables are available for the lifetime of the application.</p>
			<p>Another way of creating global variables is to use predefined global variables such as <strong class="source-inline">process</strong> (in Node.js) and <strong class="source-inline">window</strong> (in browsers). You can bind any value to these already defined global variables, and you can access them from anywhere inside the application. For example, let's add the <strong class="source-inline">NODE_VERSION</strong> value to the <strong class="source-inline">env</strong> property of <strong class="source-inline">process</strong>:</p>
			<p class="source-code">$ process.env.NODE_VERSION=10.8</p>
			<p>The <strong class="source-inline">process</strong> variable has a global scope during the execution of the program. Now, we can access the value that we've set (<strong class="source-inline">NODE_VERSION = 10.08</strong>) anywhere in our program:</p>
			<p class="source-code">$ console.log(process.env.NODE_VERSION); // "10.08"</p>
			<h2 id="_idParaDest-505"><a id="_idTextAnchor562"/>Local Scope</h2>
			<p>Variables defined within a function or a block are in a local scope. Only those functions that are defined inside that function or block can have access to those variables.</p>
			<h3 id="_idParaDest-506"><a id="_idTextAnchor563"/>Function-Level Scope</h3>
			<p>In JavaScript, each function has its own scope. All the variables and functions defined inside that function will have access to only each other:</p>
			<p class="source-code">// Function A</p>
			<p class="source-code">function parent(arg1, arg2) {</p>
			<p class="source-code">let name = "gaurav";</p>
			<p class="source-code">let age = 24;</p>
			<p class="source-code">function print(){</p>
			<p class="source-code">console.log(name, age);</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p class="source-code">// Function B</p>
			<p class="source-code">function print(){</p>
			<p class="source-code">console.log(name, age); // Error : name, age variable not defined.</p>
			<p class="source-code">}</p>
			<p>Here, both functions have different levels of scope. <strong class="source-inline">Function B</strong> can't access the variables defined in <strong class="source-inline">Function A</strong>. The scope of both functions is highlighted in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer323">
					<img alt="Figure 13.10: Example of function-level scope&#13;&#10;" src="image/C14377_13_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10: Example of function-level scope</p>
			<h3 id="_idParaDest-507"><a id="_idTextAnchor564"/>Block-Level Scope</h3>
			<p>Block-level scope is similar to function-level scope, but in this type of scope we do not initialize any functions. We can separate the scope of variables by creating blocks in JavaScript:</p>
			<p class="source-code">// 1st block</p>
			<p class="source-code">{</p>
			<p class="source-code">let name = "gaurav";</p>
			<p class="source-code">let age = 24;</p>
			<p class="source-code">console.log(name, age);</p>
			<p class="source-code">}</p>
			<p class="source-code">// 2nd block</p>
			<p class="source-code">{</p>
			<p class="source-code">console.log(name, age);</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We use curly braces to create blocks in JavaScript. The second block can't access any variables created in the first block.</p>
			<h2 id="_idParaDest-508"><a id="_idTextAnchor565"/>Hoisting</h2>
			<p>We now know that the scope of variables and functions depends on where they are declared, but there is an interesting concept in JavaScript, which is called <strong class="bold">hoisting</strong>. Hoisting is a feature in which the interpreter moves the declarations of functions and variables to the top of their scope. This means that variable declarations are processed before any code is executed. When any scope is processed, first, the whole scope is searched for variable and function declarations. Then, the memory space is allocated for each of the variables and functions. After this, the body of the function or block is executed line by line.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Hoisting only moves the declaration of the variables and functions, not the assignment. The assignment stays in the same position.</p>
			<p>Functions are hoisted first followed by the variables. So, it is a good practice to always first declare functions and then work on the implementation part:</p>
			<p class="source-code">// 1st block</p>
			<p class="source-code">{</p>
			<p class="source-code">var name;</p>
			<p class="source-code">console.log(name);</p>
			<p class="source-code">name="gaurav"</p>
			<p class="source-code">}</p>
			<p class="source-code">// 2nd block</p>
			<p class="source-code">{</p>
			<p class="source-code">console.log(name);</p>
			<p class="source-code">var name = "gaurav";</p>
			<p class="source-code">}</p>
			<p>Here, both of the blocks will return <strong class="source-inline">undefined</strong>. The output of both blocks is the same. The position of the declaration doesn't matter inside a block. The first block will not throw any errors relating to variables not being defined.</p>
			<h2 id="_idParaDest-509"><a id="_idTextAnchor566"/>The Difference between var and let</h2>
			<p>In the case of <strong class="source-inline">var</strong>, after creating variable definitions, each of the variables is initialized with an undefined value, but in the case of <strong class="source-inline">let</strong>/<strong class="source-inline">const</strong>, the initialization to undefined does not happen until the line of the declaration. In the following code, the variable is in the Temporal Dead Zone and accessing it results in a reference error:</p>
			<p class="source-code">// 1st block</p>
			<p class="source-code">{</p>
			<p class="source-code">let name;</p>
			<p class="source-code">console.log(name);</p>
			<p class="source-code">name="gaurav";</p>
			<p class="source-code">}</p>
			<p class="source-code">// 2nd block</p>
			<p class="source-code">{</p>
			<p class="source-code">console.log(name);</p>
			<p class="source-code">let name="gaurav"</p>
			<p class="source-code">}</p>
			<p>Let's execute this and see the difference by observing the different outputs of <strong class="source-inline">var</strong> and <strong class="source-inline">let</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer324">
					<img alt="Figure 13.11: let keyword usage&#13;&#10;" src="image/C14377_13_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.11: let keyword usage</p>
			<p>In the preceding figure, you can see that if we use <strong class="source-inline">let</strong>, it throws a reference error. Let's look at the output using the <strong class="source-inline">var</strong> keyword:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer325">
					<img alt="Figure 13.12: var keyword usage&#13;&#10;" src="image/C14377_13_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.12: var keyword usage</p>
			<p>We see that using the <strong class="source-inline">var</strong> keyword gives the same undefined output for both blocks.</p>
			<h2 id="_idParaDest-510"><a id="_idTextAnchor567"/>Closures</h2>
			<p>A closure is a feature in JavaScript where a function defined inside another function has access to the parent function's variables. A closure has three scope chains:</p>
			<ul>
				<li>Own scope : Variables defined between its curly brackets</li>
				<li>Parent function: Properties defined in the parent function</li>
				<li>Global variables: Properties defined in the global scope</li>
			</ul>
			<p>Let's have a look at an example:</p>
			<p class="source-code">function outer(arg) {</p>
			<p class="source-code">let count = 1;</p>
			<p class="source-code">function inner() {</p>
			<p class="source-code">console.log(arg, '=', count++);</p>
			<p class="source-code">    }</p>
			<p class="source-code">return inner;</p>
			<p class="source-code">}</p>
			<p class="source-code">varfunA = outer('A');  // outer() invoked the first time</p>
			<p class="source-code">varfunB = outer('B');  // outer() invoked the second time</p>
			<p class="source-code">funA(); // function funA called for first time</p>
			<p class="source-code">funA(); // function funA called for second time</p>
			<p class="source-code">funA(); // function funA called for third time</p>
			<p class="source-code">funB(); // function funB called for first time</p>
			<p>We have one main function, which is <strong class="source-inline">outer</strong>. Then, we have declared a <strong class="source-inline">count</strong> variable with a value of <strong class="source-inline">1</strong>. We have one more function, <strong class="source-inline">inner</strong>, which is using and incrementing the value of <strong class="source-inline">count</strong>. Then, we return the <strong class="source-inline">inner</strong> function. The output of the preceding code is as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer326">
					<img alt="Figure 13.13: Example of closures&#13;&#10;" src="image/C14377_13_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.13: Example of closures</p>
			<p>When we first call the <strong class="source-inline">outer('A') function</strong>, we are creating a scope for the <strong class="source-inline">count</strong> variable and the <strong class="source-inline">inner</strong> function. Then, we return the <strong class="source-inline">inner</strong> function and save its address in <strong class="source-inline">funA()</strong>. We did the same with <strong class="source-inline">funB()</strong>.</p>
			<p>When we called <strong class="source-inline">funA()</strong> first, it had access to the <strong class="source-inline">count</strong> variable because it was in its parent function. So, it printed the value of <strong class="source-inline">count</strong> and updated it by adding <strong class="source-inline">1</strong>. When we called it again, it again accessed the parent scope and got the updated value of <strong class="source-inline">count</strong>. JavaScript is able to achieve this because of closures.</p>
			<p>In this section, we have learned about a lot of the basic features of JavaScript. We started with prototypes and used them to implement inheritance. Then, we learned about anonymous and named functions and how to use them. We also learned about different types of data scopes in JavaScript. Finally, we learned about hoisting and closures, which are among the most complicated and important features provided by JavaScript.</p>
			<h1 id="_idParaDest-511"><a id="_idTextAnchor568"/>JavaScript Memory Management</h1>
			<p>In other technical languages, such as C and C++, memory allocation and deallocation is an additional task. We have to use the <strong class="source-inline">malloc()</strong> and <strong class="source-inline">free()</strong> functions in C to allocate and deallocate memory for our variables. Thankfully, we do not have to take care of memory allocation in JavaScript anymore. JavaScript has a garbage collector built into it. JavaScript automatically allocates and frees up memory when objects are created and destroyed.</p>
			<h2 id="_idParaDest-512"><a id="_idTextAnchor569"/>Memory Life Cycle</h2>
			<p>The memory life cycle of most programming languages is the same. It doesn't matter which language you are using, whether JavaScript, Python, or Java, the allocation and deallocation of memory is almost the same. They all follow three steps:</p>
			<ol>
				<li value="1">Allocate the memory.</li>
				<li>Use the allocated memory.</li>
				<li>Free the allocated memory.</li>
			</ol>
			<p>The first and last parts are explicit in low-level languages, which means developers have to write code for the allocation and deallocation of memory, but it is mostly implicit in high-level languages such as JavaScript. During the compilation of your code, the compiler examines all primitive data types used in the code and calculates how much memory your program will take. It then allocates the required memory to the program in the call stack space. This process of the allocation of memory is called static memory allocation. During runtime, the memory allocation works in a LIFO (last-in, first-out) manner, which means as functions are called and terminated, their memory is added on top of the existing memory and is removed in a LIFO order.</p>
			<h2 id="_idParaDest-513"><a id="_idTextAnchor570"/>Static versus Dynamic Allocation</h2>
			<p>There are two types of memory allocation, static and dynamic. Static allocation is performed at compile time only. When we compile our code, the compiler figures out all the static variables and assigns them memory at that time. Here's an example:</p>
			<p class="source-code">let num = 786;    // allocates memory for a number</p>
			<p class="source-code">let str = 'Hello World';  // allocates memory for a string</p>
			<p>Dynamic allocation, as the name suggests, is done at runtime only because sometimes we do not know the exact size of the data, for example, when assigning the response of an API to a variable. In this case, we do not know exactly what the API will send us, so the memory will be allocated during runtime:</p>
			<p class="source-code">let res = response.json();  // allocates memory for json</p>
			<p>In this example, we can't predict the size of the JSON object in advance, so this variable will be allocated dynamically. Some of the main differences between static and dynamic memory allocation are detailed in the next section.</p>
			<p>The following are the features of static memory allocation:</p>
			<ul>
				<li>Allocates during compile time</li>
				<li>Uses stack storage</li>
				<li>Good to use when the required amount of memory is known</li>
				<li>Uses LIFO (Last In, First Out)</li>
				<li>Faster execution than a dynamic allocation</li>
				<li>More efficient</li>
				<li>Higher performance</li>
			</ul>
			<p>The following are the features of dynamic memory allocation:</p>
			<ul>
				<li>Allocates during runtime</li>
				<li>Uses heap storage</li>
				<li>Good to use when the required amount of memory is unknown</li>
				<li>No order of assignment</li>
				<li>Slower execution than a static allocation</li>
				<li>Less efficient than a static allocation</li>
				<li>Slower performance because of memory allocation at runtime</li>
			</ul>
			<h2 id="_idParaDest-514"><a id="_idTextAnchor571"/>Releasing Memory</h2>
			<p>The most difficult task is to discern situations when the allocated memory is no longer required. JavaScript's garbage collector comes in handy when it comes to finding and clearing out unused memory.</p>
			<h2 id="_idParaDest-515"><a id="_idTextAnchor572"/>Reference-Counting Garbage Collection</h2>
			<p>One way of finding usable variables is by finding their references. If any variable has more than one reference, it means that it is possible to use this variable. But if we remove all the references to any variable, it becomes useless and it will be garbage collected by JavaScript in the next cycle.</p>
			<p>Let's say we have a nested object, <strong class="source-inline">obj</strong>. It has a property called <strong class="source-inline">a</strong>, and another property, <strong class="source-inline">b</strong>. Now, <strong class="source-inline">obj</strong> is referencing <strong class="source-inline">a</strong> and <strong class="source-inline">a</strong> is referencing <strong class="source-inline">b</strong>. The only way to access <strong class="source-inline">b</strong> is through <strong class="source-inline">a</strong>:</p>
			<p class="source-code">let obj = {</p>
			<p class="source-code">a : {</p>
			<p class="source-code"> b : 2</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If we change the reference of <strong class="source-inline">a</strong> to <strong class="source-inline">b</strong>, then <strong class="source-inline">b</strong> will be garbage collected:</p>
			<p class="source-code">obj.a = null;</p>
			<p>Now, as there is no reference to <strong class="source-inline">b</strong>, the garbage collector will delete it and free the memory.</p>
			<p>In this section, we learned about how JavaScript automatically manages memory and does memory management for us. We learned about static and heap storage devices and had an overview of how the garbage collector in JavaScript works. We went through reference garbage collection as one of the many ways a garbage collector uses to find and clear unused memory in JavaScript programs.</p>
			<h2 id="_idParaDest-516"><a id="_idTextAnchor573"/>Activity 13.01: Creating a Calculator App</h2>
			<p>In this chapter, we have learned about different types of paradigms that we can use when programming with JavaScript. Now it's time to sharpen our knowledge of these paradigms and make sure we know the difference between them when implementing paradigms in the real world. </p>
			<p>Let's build a simple calculator application using both a procedural and object-oriented approach, which will give us a clear example of implementing the solution to a problem with different paradigms.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create an empty file and call it <strong class="source-inline">procedural.js</strong>.</li>
				<li>Initialize an array that will maintain the history of function calls. </li>
				<li>Create simple <strong class="source-inline">addition</strong>, <strong class="source-inline">subtraction</strong>, <strong class="source-inline">multiplication</strong>, <strong class="source-inline">division</strong>, and <strong class="source-inline">power</strong> functions.</li>
				<li>Create a <strong class="source-inline">history</strong> function that will maintain the history of function calls.</li>
				<li>Call all the functions one by one with some random numbers as parameters.</li>
				<li>Now print the history to check the output.</li>
				<li>Now, build the app using OOP. Create a class and call it <strong class="source-inline">calculator</strong>.</li>
				<li>Initialize a <strong class="source-inline">historyList</strong> array, which will maintain the history of all function calls.</li>
				<li>Create simple <strong class="source-inline">add</strong>, <strong class="source-inline">subtract</strong>, <strong class="source-inline">multiply</strong>, <strong class="source-inline">divide</strong>, and <strong class="source-inline">pow</strong> methods.</li>
				<li>Add one more method, which will show the history of the operations.</li>
				<li>Create an instance of this class and call its method with simple numbers to perform mathematical operations.</li>
				<li>Call the <strong class="source-inline">history</strong> method of the <strong class="source-inline">calculator</strong> class to check the history.</li>
			</ol>
			<p>Using both a procedural and an object-oriented approach, the output of this code will be as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer327">
					<img alt="Figure 13.14: The same output using the procedural and the object-oriented approach&#13;&#10;" src="image/C14377_13_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.14: The same output using the procedural and the object-oriented approach</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 754.</p>
			<p>You will see that, the outputs of both scripts are exactly the same, but the way we implemented them is completely different. This implementation tells us that there is more than one way to solve a problem. The best way depends on a lot of factors, such as team size, project plans, expectations of the project, and others. So, finally, we have achieved the same solution to the same problem.</p>
			<h1 id="_idParaDest-517"><a id="_idTextAnchor574"/>Summary</h1>
			<p>So far in this book, we have covered client-side and server-side JavaScript execution. You learned about the importance of scope in JavaScript, along with the basics necessary for a solid foundation in JavaScript. </p>
			<p>In this chapter, we learned about different programming paradigms. We discussed two of the popular approaches used by developers, namely procedural and object-oriented. Then, we explored the uses of prototypes, data scopes, hoisting, and closures. </p>
			<p>Now, let's dig deep into the final and most important programming paradigm, which is used by a lot of developers: functional programming. In the next chapter, we will learn a lot about functional programming, including how and when to use it.</p>
		</div>
		<div>
			<div class="Content" id="_idContainer329">
			</div>
		</div>
	</body></html>