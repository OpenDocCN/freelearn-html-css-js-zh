<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Build Automation</h1></div></div></div><p>We saw how to create an application from the ground up using tests with Jasmine. However, as the application grows and the number of files starts to increase, managing the dependencies between them can become a little difficult.</p><p>For instance, we have a dependency between the Investment and Stock models, and they must be loaded in a proper order to work. So, we do what we can; we order the loading of the scripts so that Stock is available once Investment is loaded. Here's how we do it:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/Stock.js"&gt;&lt;/"script&gt;
&lt;script type="text/javascript" src="img/Investment.js"&gt;&lt;/"script&gt;</pre></div><p>However, that can soon become cumbersome and unmanageable.</p><p>Another problem is the number of requests the application uses to load all of its files; it can get up to hundreds once the application starts to grow.</p><p>So, we have a paradox here; although it is good to break it up into small modules for code maintainability, it is bad for the client performance, where a single file is much more desirable.</p><p>A perfect world would be to match the following two requirements at the same time:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In development, we have a bunch of small files containing different modules</li><li class="listitem" style="list-style-type: disc">In production, we have a single file with the content of all those modules</li></ul></div><p>Clearly, what we need is some sort of build process. There are many different ways to achieve these goals with JavaScript, but we are going to focus on <strong>webpack</strong>.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Module bundler – webpack</h1></div></div></div><p>Webpack <a id="id252" class="indexterm"/>is a module <a id="id253" class="indexterm"/>bundler created by Tobias Koppers to help create big and modular frontend JavaScript applications.</p><p>Its main difference from other solutions is its support for any type of module system (AMD and CommonJS), languages (CoffeeScript, TypeScript, and JSX) and even assets (images and templates) through loaders.</p><p>You read it right, even <a id="id254" class="indexterm"/>images; if in a React application, everything is a component, in a<a id="id255" class="indexterm"/> webpack project, everything is a module.</p><p>It builds a dependency graph of all your assets, serving them in a development environment and optimizing them for production.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec29"/>Module definition</h2></div></div></div><p>JavaScript<a id="id256" class="indexterm"/> is a language <a id="id257" class="indexterm"/>based on the ECMA Script specification that, until version 6, still didn't have a standard definition of a module. This lack of formal standards led to a number of competing community standards (AMD and CommonJS) and implementations (RequireJS and browserify).</p><p>Now, there is a standard to follow, but unfortunately there is no support for it in modern browsers, so which style should we use to write our modules?</p><p>The good news is that it is possible to use ES6 today through transpilers, which gives us a future-proof advantage.</p><p>A popular transpiler is <a id="id258" class="indexterm"/>
<strong>Babel</strong> (<a class="ulink" href="http://babeljs.io/">http://babeljs.io/</a>), which we are going to use with webpack through a loader.</p><p>We'll see how to use it with webpack in a moment, but first it is important to understand what makes an ES6 module. Here is a simple definition without any dependency:</p><div><pre class="programlisting">function MyModule () {};
export default MyModule;</pre></div><p>Let's compare it to the way we've been declaring modules until now. The next example shows how that code would be if written using the conventions presented in <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <em>Testing Frontend Code</em>:</p><div><pre class="programlisting">(function () {
  function MyModule() {};
  this.MyModule = MyModule;
}());</pre></div><p>The biggest difference is the lack of an IIFE. An ES6 module, by default, has a scope of its own, so it is impossible to pollute the global namespace by accident.</p><p>The second difference is that the module value is no longer being attached to the global object, but instead being exported as the default module value:</p><div><pre class="programlisting">function MyModule () {};
<strong>export default MyModule;</strong>
</pre></div><p>Regarding a module's dependencies, up until now, everything was globally available, so we passed the dependencies to the module as parameters to the IIFE, as shown here:</p><div><pre class="programlisting">(function (<strong>$</strong>) {
  function MyModule() {};
  this.MyModule = MyModule;
}(<strong>jQuery</strong>));</pre></div><p>However, as you start using ES6 <a id="id259" class="indexterm"/>modules on the project, there will be no more global variables. So, how do you get those dependencies into the module?</p><p>If you remember from before, the ES6 example was exporting the module value through the <code class="literal">export default</code> syntax. So, given a module has a value, all we have to do is ask for it as a dependency. Let's add the jQuery dependency to our ES6 module:</p><div><pre class="programlisting">
<strong>import $ from 'jQuery';</strong>
function MyModule () {};
export default MyModule;</pre></div><p>Here, <code class="literal">$</code> represents the name of the variable the dependency will be loaded into, and <code class="literal">jQuery</code> is the filename.</p><p>It is also possible to export multiple values as the result of a module and import these values into different variables, but for the scope of this book, default values will suffice.</p><p>The ES6 standard introduces a number of different constructs to the JavaScript language that are also beyond the scope of this book. For more information, check Babel's excellent <a id="id260" class="indexterm"/>documentation at <a class="ulink" href="http://babeljs.io/docs/learn-es6/">http://babeljs.io/docs/learn-es6/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec30"/>Webpack project setup</h2></div></div></div><p>Webpack is available as an <a id="id261" class="indexterm"/>NPM package, and its setup is very simple as it is going to be demonstrated in the next sections.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>It is important to understand the difference between NPM and Node.js. NPM is both a package manager and a package format, while Node.js is a platform that NPM modules usually run.</p></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec03"/>Managing dependencies with NPM</h3></div></div></div><p>We already got an<a id="id262" class="indexterm"/> embryo of a Node.js project, but as we are going to start using more dependencies throughout this chapter, we are going to need a formal definition of all the NPM packages that the project depends on.</p><p>To define the project as an NPM package, and at the same time all of its dependencies, we need to create a special file called <code class="literal">package.json</code> at the root folder of the application. It can be easily created through a single command:</p><div><pre class="programlisting">
<strong>npm init</strong>
</pre></div><p>It will prompt for a<a id="id263" class="indexterm"/> number of questions about the project that can all be left with their default values. In the end, you should have a file with content similar to the following output depending on your folder name:</p><div><pre class="programlisting">{
  "name": "jasmine-testing-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts":" {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC"
}
  Is this ok? (Yes)</pre></div><p>The next step is to install all of our dependencies, which, at the moment, is only express.</p><div><pre class="programlisting">
<strong>npm install --save express</strong>
</pre></div><p>The previous command will not only install express as described in <a class="link" href="ch04.html" title="Chapter 4. Asynchronous Testing – AJAX">Chapter 4</a>, <em>Asynchronous Testing – AJAX</em>, but will also add it as a dependency to the <code class="literal">package.json</code> file. On running the <code class="literal">npm init</code> command as done previously, we get the following output showing the <code class="literal">dependencies</code> attribute:</p><div><pre class="programlisting">{
  "name": "jasmine-testing-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC",
  <strong>"dependencies": {</strong>
<strong>    "express": "^4.12.0"</strong>
<strong>  }</strong>
}</pre></div><p>Now that we understand how to manage the dependencies of our project, we can install <strong>webpack</strong><a id="id264" class="indexterm"/> and <strong>Babel</strong><a id="id265" class="indexterm"/> as development dependencies to start bundling our modules, as follows:</p><div><pre class="programlisting">
<strong>npm install --save-dev babel-loader webpack webpack-dev-server</strong>
</pre></div><p>The final step is to add a script in <code class="literal">package.json</code> to start the development server:</p><div><pre class="programlisting">"scripts": {
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
  <strong>"dev": "webpack-dev-server"</strong>
}</pre></div><p>This allows us to <a id="id266" class="indexterm"/>start the development server with a simple command:</p><div><pre class="programlisting">
<strong>npm run dev</strong>
</pre></div><p>The actual location of the <code class="literal">webpack-dev-server</code> executable is in the <code class="literal">./node_modules/.bin</code> folder. So, <code class="literal">npm run dev</code> is the same as:</p><div><pre class="programlisting">
<strong>./node_modules/.bin/webpack-dev-server</strong>
</pre></div><p>It works because when you run <code class="literal">npm run &lt;scriptName&gt;</code>, NPM adds the <code class="literal">./node_modules/.bin</code> folder to the path.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec04"/>Webpack configuration</h3></div></div></div><p>Next, we need to configure webpack<a id="id267" class="indexterm"/> so that it knows what files to bundle. This can be achieved by creating a <code class="literal">webpack.config.js</code> file at the root folder of the project. Its content should be:</p><div><pre class="programlisting">module.exports = {
  context: __dirname,
  entry: {
    spec: [
      './spec/StockSpec.js',
      './spec/InvestmentSpec.js',
      './spec/components/NewInvestmentSpec.jsx',
      './spec/components/InvestmentListItemSpec.jsx',
      './spec/components/InvestmentListSpec.jsx'
    ]
  },

  output: {
    filename: '[name].js'
  },

  module: {
    loaders: [
      {
        test: /(\.js)|(\.jsx)$/,
        exclude: /node_modules/,
        loader: 'babel-loader'
      }
    ]
  }
};</pre></div><p>There are a few<a id="id268" class="indexterm"/> key points about this configuration file:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">context</code> directive tells webpack to look for modules in <code class="literal">__dirname</code>, meaning the project's root folder.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">entry</code> directive specifies the application's entry points. Since we are only doing testing at the moment, there is a single entry point named <code class="literal">spec</code> that refers to all of our spec files.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">output.filename</code> directive is here to inform the filename of each of the entry points. The <code class="literal">[name]</code> pattern will be replaced by an entry point name on compilation. So <code class="literal">spec.js</code> will actually contain all of our spec code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">module.loaders</code> final directive tells webpack how to deal with different file types. We are using the <code class="literal">babel-loader</code> parameter here to add support for ES6 modules and the JSX syntax on our source files. The <code class="literal">exclude</code> directive is important so as not to waste compiling any dependency from the <code class="literal">node_modules</code> folder.</li></ul></div><p>With this setup completed, you can start the development server and check what the transpiled bundle looks like at <code class="literal">http://localhost:8080/spec.js</code> (the filename defined in the configuration file).</p><p>At this point, the webpack configuration is complete, and we can move to adapt the Jasmine runner to run the specs.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec31"/>The spec runner</h2></div></div></div><p>As stated previously, we are<a id="id269" class="indexterm"/> using webpack to compile and bundle the source files, so the <a id="id270" class="indexterm"/>Jasmine spec is about to become a lot simpler:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Jasmine Spec Runner v2.1.3&lt;/title&gt;

  &lt;link rel="shortcut icon" type="image/png" href="lib/jasmine-2.1.3/jasmine_favicon.png"&gt;
  &lt;link rel="stylesheet" href="lib/jasmine-2.1.3/jasmine.css"&gt;

  &lt;script src="img/jasmine.js"&gt;&lt;/script&gt;
  &lt;script src="img/jasmine-html.js"&gt;&lt;/script&gt;
  &lt;script src="img/boot.js"&gt;&lt;/script&gt;

  &lt;script src="img/jquery.js"&gt;&lt;/script&gt;
  &lt;script src="img/jasmine-jquery.js"&gt;&lt;/script&gt;

  &lt;script src="img/mock-ajax.js"&gt;&lt;/script&gt;

  &lt;script src="img/SpecHelper.js"&gt;&lt;/script&gt;

 <strong> &lt;script src="img/spec.js"&gt;&lt;/script&gt;</strong>
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>There are a few takeaways:</p><p>First, we no <a id="id271" class="indexterm"/>longer need the JSX transformer hack explained in the <a id="id272" class="indexterm"/>previous chapter; the transformation is now done by webpack and the babel-loader. As a result, we can use the default Jasmine boot just fine.</p><p>Second, we've chosen to leave the test runner dependencies as global (Jasmine, Mock Ajax, Jasmine JQuery, and the Spec helper). Leaving them global makes things a lot simpler for our test runner, and we don't hurt our code as far as modularity is concerned.</p><p>At this moment, trying to run the tests at <code class="literal">http://localhost:8080/SpecRunner.html</code> should produce a lot of fails due to missing references. That is because we still need to convert our specs and sources into ES6 modules.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec32"/>Testing a module</h2></div></div></div><p>To be able to run all the<a id="id273" class="indexterm"/> tests requires that all the source and spec files be converted into ES6 modules. At the specs, it means adding, as dependencies all the source modules:</p><div><pre class="programlisting">
<strong>import Stock from '../src/Stock';</strong>
describe("Stock", function() {
  // the original spec code
});</pre></div><p>At the source files, it means declaring all the dependencies as well as exporting its default value, as follows:</p><div><pre class="programlisting">
<strong>import React from 'react';</strong>
var InvestmentListItem = React.createClass({
  // original code
});
<strong>export default InvestmentListItem;</strong>
</pre></div><p>Once all the <a id="id274" class="indexterm"/>code is converted, the tests should work upon starting the development server and pointing the browser once again to the runner URL.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Test runner: Karma</h1></div></div></div><p>Remember we said back in the <a id="id275" class="indexterm"/>introduction that we could execute Jasmine without the need of a browser window? To do so, we are going to use <a id="id276" class="indexterm"/>
<strong>PhantomJS</strong>, a scriptable<a id="id277" class="indexterm"/> headless WebKit browser (the same rendering engine that powers the Safari browser) and <strong>Karma</strong>, a test runner.</p><p>The setup is very simple; using NPM, we once again install some dependencies:</p><div><pre class="programlisting">
<strong>npm install –save-dev karma karma-jasmine karma-webpack karma-phantomjs-launcher es5-shim</strong>
</pre></div><p>The only strange dependency here is the <code class="literal">es5-shim</code>, which is used to give PhantomJS support for some ES5 features that it still is missing, and React requires.</p><p>The next step is creating a configuration file, named <code class="literal">karma.conf.js</code>, for Karma at the project's' root folder:</p><div><pre class="programlisting">module.exports = function(config) {
  config.set({
    basePath: '.',

    frameworks: ['jasmine'],
    browsers: ['PhantomJS'],

    files: [
      // shim to workaroud PhantomJS 1.x lack of 'bind' support
      // see: https://github.com/ariya/phantomjs/issues/10522
      'node_modules/es5-shim/es5-shim.js',
      'lib/jquery.js',
      'lib/jasmine-jquery.js',
      'lib/mock-ajax.js',
      'spec/SpecHelper.js',
      'spec/**/*Spec.*'
    ],

    preprocessors: {
      'spec/**/*Spec.*': ['webpack']
    },

    webpack: require('./webpack.config.js'),
    webpackServer: { noInfo: true },
    singleRun: true
  });
};</pre></div><p>In it, we set up the <a id="id278" class="indexterm"/>Jasmine <a id="id279" class="indexterm"/>framework and the PhantomJS browser:</p><div><pre class="programlisting">frameworks: [<strong>'jasmine'</strong>],
browsers: [<strong>'PhantomJS'</strong>],</pre></div><p>Fix the browser compatibility issues on PhantomJS by loading <code class="literal">es5-shim</code>, as shown in the following code:</p><div><pre class="programlisting">// shim to workaroud PhantomJS 1.x lack of 'bind' support
// see: https://github.com/ariya/phantomjs/issues/10522
<strong>'node_modules/es5-shim/es5-shim.js'</strong>,</pre></div><p>Load the test runner dependencies, which were previously global in the <code class="literal">SpecRunner.html</code> file, as shown in the following code:</p><div><pre class="programlisting">'lib/jquery.js',
'lib/jasmine-jquery.js',
'lib/mock-ajax.js',
'spec/SpecHelper.js',</pre></div><p>Finally, load all the specs, as follows:</p><div><pre class="programlisting">'spec/**/*Spec.*',</pre></div><p>By now, you can remove the <code class="literal">SpecRunner.html</code> file, the spec entry in the <code class="literal">webpack.config.js</code> file, and the <code class="literal">lib/jasmine-2.1.3</code> folder.</p><p>Run the tests by invoking Karma, which will print the test results in the console, as follows:</p><div><pre class="programlisting">
<strong>./node_modules/karma/bin/karma start karma.conf.js</strong>
<strong>&gt; investment-tracker@0.0.1 test /Users/paulo/Dropbox/jasmine_book/second_edition/book/chapter_8/code/webpack-karma</strong>
<strong>&gt; ./node_modules/karma/bin/karma start karma.conf.js</strong>
<strong>INFO [karma]: Karma v0.12.31 server started at http://localhost:9876/</strong>
<strong>INFO [launcher]: Starting browser PhantomJS</strong>
<strong>INFO [PhantomJS 1.9.8 (Mac OS X)]: Connected on socket cGbcpcpaDgX14wdyzLZh with id 37309028</strong>
<strong>PhantomJS 1.9.8 (Mac OS X): Executed 36 of 36 SUCCESS (0.21 secs / 0.247 secs)</strong>
</pre></div><p>To make it simpler to run the tests, it is possible to change the <code class="literal">package.json</code> project file and describe its test script:</p><div><pre class="programlisting">"scripts": {
  <strong>"test": "./node_modules/karma/bin/karma start karma.conf.js",</strong>
  "dev": "webpack-dev-server"
},</pre></div><p>You can then run the <a id="id280" class="indexterm"/>tests by <a id="id281" class="indexterm"/>simply invoking the following:</p><div><pre class="programlisting">
<strong>npm test</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Quick feedback loop</h1></div></div></div><p>Automated testing is all about the<a id="id282" class="indexterm"/> quick feedback loop, so imagine being able to have the tests running in the console and the application refreshing on the browser after any file change. Would that be possible? The answer is yes!</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec33"/>Watch and run the tests</h2></div></div></div><p>Via a simple parameter <a id="id283" class="indexterm"/>while starting Karma, we can achieve <a id="id284" class="indexterm"/>testing nirvana, as follows:</p><div><pre class="programlisting">
<strong>./node_modules/karma/bin/karma start karma.conf.js --auto-watch --no-single-run</strong>
</pre></div><p>Try it by yourself; run this command, change a file, and see the tests running automatically—like magic.</p><p>Once again, we don't want to remember these complicated commands, so let's add another script to the <code class="literal">package.json</code> file:</p><div><pre class="programlisting">"scripts": {
  "test": "./node_modules/karma/bin/karma start karma.conf.js",
  <strong>"watch-test": "./node_modules/karma/bin/karma start karma.conf.js --auto-watch --no-single-run",</strong>
  "dev": "webpack-dev-server"
},</pre></div><p>We can run it through the following command:</p><div><pre class="programlisting">
<strong>npm run watch-test</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec34"/>Watch and update the browser</h2></div></div></div><p>To achieve <a id="id285" class="indexterm"/>development <a id="id286" class="indexterm"/>nirvana, we are also just a parameter away.</p><p>While starting the development server, add the following to the <code class="literal">package.json</code> file:</p><div><pre class="programlisting">./node_modules/.bin/webpack-dev-server <strong>--inline –hot</strong>
</pre></div><p>Once again, try it on your browser; change a file in the text editor and the browser should refresh.</p><p>You are also encouraged to update the <code class="literal">package.json</code> file with these new parameters so that running <code class="literal">npm run dev</code> gets you the goodness of "live reload".</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Optimizing for production</h1></div></div></div><p>The final step of our module<a id="id287" class="indexterm"/> bundler goal is to generate a minified and ready-for-production file.</p><p>Most of the configuration is complete, missing just a few more steps.</p><p>The first step is to set up an entry point for the application, then an index file that will start it all, <code class="literal">index.js</code>, is to be placed inside the <code class="literal">src</code> folder with the contents as follows:</p><div><pre class="programlisting">import React from 'react';
import Application from './Application.jsx';

var mountNode = document.getElementById('application-container''');
React.render(React.createElement(Application, {}), mountNode);</pre></div><p>We haven't covered in detail the implementation of this file in the book, so be sure to check the attached source files to understand better how it works.</p><p>In the webpack configuration file, we need to add both an output path to indicate where the bundled files will be placed and the new entry file we just created, as follows:</p><div><pre class="programlisting">module.exports = {
  context: __dirname,
  <strong>entry: {</strong>
<strong>    index: './src/index.js'</strong>
<strong>  },</strong>

  output: {
    <strong>path: 'dist',</strong>
    filename: '[name]-[hash].js'
  },

  module: {
    loaders: [
      {
        test: /(\.js)|(\.jsx)$/,
        exclude: /node_modules/,
        loader: 'babel-loader'
      }
    ]
  }
};</pre></div><p>Then, all that it is left is to create a build task in our <code class="literal">package.json</code> file:</p><div><pre class="programlisting">"scripts": {
    "test": "./node_modules/karma/bin/karma start karma.conf.js",
    "watch-test": "./node_modules/karma/bin/karma start karma.conf.js --auto-watch --no-single-run",
    <strong>"build": "webpack -p",</strong>
    "dev": "webpack-dev-server --inline --hot"
  },</pre></div><p>Run it and check the <a id="id288" class="indexterm"/>built files into the <code class="literal">dist</code> folder, as follows:</p><div><pre class="programlisting">
<strong>npm run build</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Static code analysis: JSHint</h1></div></div></div><p>As stated in the first chapter, JavaScript is not a compiled language, but running the code (as in the case of automated testing) is not the only way to check for errors.</p><p>A whole class of <a id="id289" class="indexterm"/>tools is able to read source files, interpret them, and look for common errors or bad practices without needing to actually run the source files.</p><p>A very popular tool is <a id="id290" class="indexterm"/>
<strong>JSHint</strong>—a simple binary that can also be installed through NPM, as follows:</p><div><pre class="programlisting">npm install --save-dev <strong>jshint jsxhint</strong>
</pre></div><p>You can see that we are also installing<a id="id291" class="indexterm"/> <strong>JSXHint</strong>, another tool to perform static analysis of JSX files. It is basically a wrapper around the original JSHint while performing the JSX transformations.</p><p>If you remember from the previous chapter, JSXTransformer doesn't change the line numbers, so a warning in a given line number on a JavaScript file will be in the same line number in the original JSX file.</p><p>To execute them is very simple, as follows:</p><div><pre class="programlisting">./node_modules/.bin/jshint .
./node_modules/.bin/jsxhint .</pre></div><p>However, it is also a good idea to have them running whenever we run the tests:</p><div><pre class="programlisting">"scripts": {
    "start": "node bin/server.js",
    "test": <strong>"./node_modules/.bin/jshint . &amp;&amp; ./node_modules/.bin/jsxhint . &amp;&amp;</strong> ./node_modules/karma/bin/karma start karma.conf.js",
    "watch-test": "./node_modules/karma/bin/karma start karma.conf.js --auto-watch --no-single-run",
    "build": "webpack -p",
    "dev": "webpack-dev-server --inline --hot"
  },</pre></div><p>The final step is<a id="id292" class="indexterm"/> configuring what errors we want JSHint and JSXHint to<a id="id293" class="indexterm"/> catch. Once again, we create another configuration file at the root folder of our project, this time called <code class="literal">.jshintrc</code>:</p><div><pre class="programlisting">{
  "esnext": true,
  "undef": true,
  "unused": true,
  "indent": 2,
  "noempty": true,
  "browser": true,
  "node": true,
  "globals": {
    "jasmine": false,
    "spyOn": false,
    "describe": false,
    "beforeEach": false,
    "afterEach": false,
    "expect": false,
    "it": false,
    "xit": false,
    "setFixtures": false
  }
}</pre></div><p>This is a list of option flags either being enabled or disabled, where the most important are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">esnext</code>: This flag tells us we are using the ES6 version</li><li class="listitem" style="list-style-type: disc"><code class="literal">unused</code>: This flag breaks on any unused declared variable</li><li class="listitem" style="list-style-type: disc"><code class="literal">undef</code>: This option flag breaks on any variable being used without being declared</li></ul></div><p>There is also a list of <code class="literal">globals</code> variables used by the tests to prevent errors due to the <code class="literal">undef</code> flag.</p><p>Head over to the JSHint<a id="id294" class="indexterm"/> website at <a class="ulink" href="http://jshint.com/docs/options/">http://jshint.com/docs/options/</a> for a complete list of options.</p><p>The only <a id="id295" class="indexterm"/>missing step is preventing the linter from running in other people's code (Jasmine, React, and so on). This is possible by simply creating a file with the folders it should ignore. This file called <code class="literal">.jshintignore</code> should contain:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">node_modules</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">lib</code></li></ul></div><p>To run the static analysis and all the tests is now as simple as this:</p><div><pre class="programlisting">
<strong>npm test</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Continuous integration – Travis-CI</h1></div></div></div><p>We have created a great deal of <a id="id296" class="indexterm"/>automation around the project, which is great for onboarding a new developer on the team; running the test is just two commands away:</p><div><pre class="programlisting">
<strong>npm install</strong>
<strong>npm test</strong>
</pre></div><p>However, that is not the only advantage; we can have the tests running via these same two commands while on a continuous integration environment.</p><p>To demonstrate a possible setup, we are going to use <a id="id297" class="indexterm"/>Travis-CI (<a class="ulink" href="https://travis-ci.org">https://travis-ci.org</a>), a free solution for open source projects.</p><p>Before we can start, it is required that you have a <a id="id298" class="indexterm"/>GitHub (<a class="ulink" href="https://github.com/">https://github.com/</a>) account and that the project is already hosted there. I expect that you are already familiar with git<a id="id299" class="indexterm"/> (<a class="ulink" href="http://www.git-scm.com/">http://www.git-scm.com/</a>) and GitHub.</p><p>Once you are ready, we can start the Travis-CI setup.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec35"/>Adding a project to Travis-CI</h2></div></div></div><p>Before we can add <a id="id300" class="indexterm"/>Travis-CI support to the project, first we need to add the project to <a id="id301" class="indexterm"/>Travis-CI.</p><p>Go to the Travis-CI <a id="id302" class="indexterm"/>website at <a class="ulink" href="https://travis-ci.org">https://travis-ci.org</a> and click on <strong>Sign in with GitHub</strong> in the top-right corner.</p><p>Enter your GitHub credentials and once you have signed in, it should show you the list with all your repositories:</p><p>If your repository doesn't show up, you can click on the <strong>Sync Now</strong> button to make Travis-CI update the list.</p><p>Once your <a id="id303" class="indexterm"/>repository appears, enable it by clicking on the switch. This will <a id="id304" class="indexterm"/>set up hooks on your GitHub project, so Travis-CI gets notified on any change pushed to the repository.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec36"/>Project setup</h2></div></div></div><p>Setting up a Travis-CI project <a id="id305" class="indexterm"/>couldn't be simpler. Since we have our build process and tests all scripted, all we have to do is tell Travis-CI what runtime it should use.</p><p>Travis-CI knows that Node.js project dependencies are installed through <code class="literal">npm install</code> and that tests are run through <code class="literal">npm test</code>, so there is no extra step to get our tests running.</p><p>Create a new file at the project root directory called <code class="literal">.travis.yml</code> and configure the language for Travis as Node.js:</p><div><pre class="programlisting">language: node_js</pre></div><p>And that is all there is to it.</p><p>The steps taken to use Travis-CI were pretty straightforward, and it should be pretty simple to apply these same concepts to other continuous integration environments, such as <a id="id306" class="indexterm"/>Jenkins (<a class="ulink" href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, I hope to have showed you the power of automation and how we can use scripts to make our life easier. You learned about webpack and how it can be used to manage the dependencies between your modules and help you generate the production code (packed and minified).</p><p>The power of static code analysis in helping us find bugs even before the code runs.</p><p>You have also seen how to run your specs headlessly, and even automatically, letting you focus on the code editor all the time.</p><p>Finally, we have seen how simple it is to use a continuous integration environment and how we can use this powerful concept to keep our projectsalways tested.</p></div></body></html>