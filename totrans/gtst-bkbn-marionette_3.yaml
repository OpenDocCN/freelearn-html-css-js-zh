- en: Chapter 3. Marionette View Types and Their Use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned about components that help us provide a
    structure to our application; however, none of these components interacted with
    the DOM. This responsibility belongs to the views in Backbone development; however,
    the interaction and manipulation of the DOM can quickly become complicated inside
    our views. With the intention of having cleaner and meaningful objects to manipulate,
    the DOM Marionette introduces a powerful set of views. The following is a description
    of each one of those views provided in the official documentation at [https://github.com/marionettejs/backbone.marionette](https://github.com/marionettejs/backbone.marionette):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Marionette.ItemView`: This is the view that renders a single model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.CollectionView`: This is the view that iterates over a collection
    and renders the individual `ItemView` instances for each model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.CompositeView`: This is the collection view and item view for rendering
    leaf-branch/composite model hierarchies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.Layout`: This is the view that renders a layout and creates region
    managers to manage areas within it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.View`: This is the base view type that other Marionette views extend
    from (not intended to be used directly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn the intention behind each one of them and how
    to start using them.
  prefs: []
  type: TYPE_NORMAL
- en: Marionette.View and Marionette.ItemView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Marionette.View` extends the `Backbone.View`, and it's important to remember
    this, because all the knowledge that we already have on creating a view will be
    useful while working with these new set of views of Marionette.
  prefs: []
  type: TYPE_NORMAL
- en: Each of them aims to provide a specific out of the box functionality so that
    you spend less time focusing on the glue code needed to make things work, and
    more time on things that are related to the needs of your application. This allows
    you to focus all your attention on the specific logic of your application.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by describing the `Marionette.View` part of Marionette, as all
    of the other views extend from it; the reason we do this is because this view
    provides a very useful functionality. But it's important to notice that this view
    is not intended to be used directly. As it is the base view from which all the
    other views inherit from, it is an excellent place to contain some of the glue
    code that we just talked about.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of that functionality is the `close` method, which will be responsible
    for removing `.el` from DOM. This method will also take care of calling unbind
    to all your events, thus avoiding the problem called Zombie views. This an issue
    that you can have if you don't do this carefully in a regular Backbone view, where
    new instantiations of previously closed fire events are present. These events
    remain bound to the HTML elements used in the view. These are now present again
    in the DOM now that the view has been re-rendered, and during the recreation of
    the view, new event listeners are attached to these HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: From the documentation of the `Marionette.View`, we exactly know what the `close`
    method does.
  prefs: []
  type: TYPE_NORMAL
- en: It calls an `onBeforeClose` event on the view, if one is provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls an `onClose` event on the view, if one is provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It unbinds all custom view events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It unbinds all DOM events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It removes `this.el` from the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It unbinds all `listenTo` events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link to the official documentation of the `Marionette.View` object is [https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to mention that the third point, *unbind all custom view events*,
    will unbind events created using the `modelEvents` hash, those created on the
    events hash, and events created via `this.listenTo`.
  prefs: []
  type: TYPE_NORMAL
- en: As the `close` method is already provided and implemented, you don't need to
    perform the unbind and remove previously listed tasks. While most of the time
    this would be enough, at times, one of your views will need you to perform extra
    work in order to properly close it; in this case, two events will be fired at
    the same time to close a view.
  prefs: []
  type: TYPE_NORMAL
- en: The event `onBeforeClose`, as the name indicates, will be fired just before
    the `close` method. It will call a function of the same name, `onBeforeClose`,
    where we can add the code that needs to be executed at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second event will be `onClose`, which will be fired after the `close` method
    so that the `.el` of the view won't be present anymore and all the unbind tasks
    will have been performed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One of the core ideas behind Marionette is to reduce the boilerplate code that
    you have to write when building apps with Backbone. A perfect example of which
    is the `render` method that you have to implement in every Backbone view, and
    the code there is pretty much the same in each of your views. Load the template
    with the underscore `_.template` function and then pass the model converted to
    JSON to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of repetitive code needed to render a view in Backbone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As Marionette defining a `render` function is no longer required, just like
    the `close` method, the preceding code will be called for you behind the scenes.
    In order to render a view, we just need to declare it with a template property
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we just create a Backbone model, and we pass it to the `ItemView` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And then the only thing left is to call the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to see it running, please go through this JSFiddle that illustrates
    the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jsfiddle.net/rayweb_on/VS9hA/](http://jsfiddle.net/rayweb_on/VS9hA/)'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that we just needed one line to specify the template, and
    Marionette did the rest by rendering our view with the specified template. Notice
    that in this example, we used the `ItemView` constructor; we should not use `Marionette.View`
    directly, as it does not have many functionalities of its own. It just serves
    as the base for other views.
  prefs: []
  type: TYPE_NORMAL
- en: So some of the following examples of the functionalities provided by `Marionette.View`
    will be demonstrated using `ItemView`, as this view inherits all of these functionalities
    through extension.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous example, `ItemView` works perfectly for rendering
    a single model using a template, but what about rendering a collection of models?
  prefs: []
  type: TYPE_NORMAL
- en: If you just need to render, for example, a list of books or categories, you
    still can use `ItemView`. To accomplish this, the template that you would assign
    to `ItemView` must know how to handle the creation of the DOM to properly display
    that list of items.
  prefs: []
  type: TYPE_NORMAL
- en: Let's render a list of books.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Backbone model will have two properties: the book name and the book ID.
    We just want to create a list of links using the book name as the value to be
    displayed; the ID of the book will be used to create a link to see the specific
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the book Backbone model for this example and its collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s instantiate the collection and add three models to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In our HTML, let''s create the template to be used in this view; the template
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we could render the book list using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to see it in action, go to the working code in JSFiddle at [http://jsfiddle.net/rayweb_on/8QAgQ/](http://jsfiddle.net/rayweb_on/8QAgQ/).
  prefs: []
  type: TYPE_NORMAL
- en: The previous code would produce an unordered list of books with links to the
    specific book. Again, we gained the benefit of writing very little code once again,
    as we didn't need to specify the `Render` function, which could be misleading,
    because the `ItemView` is perfectly capable of rendering a model or a collection.
    Whether to use `CollectionView` or `ItemView` will depend on what we are trying
    to accomplish. If we need a set of individual views with its own functionality,
    `CollectionView` is the right choice, as we will see when we get to the point
    of reviewing it. But if we just need to render the values of a collection, `ItemView`
    would be the perfect choice.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events in the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep track of model events or collection events, we must write the following
    code snippet on a regular Backbone view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To start these events, we use the following handler functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This still works fine in Marionette, but we can accomplish the same thing by
    declaring these events using the following configuration hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will give us exactly the same result, but the configuration hash is very
    convenient as we can keep adding events to our model or collection, and the code
    is cleaner and very easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The `modelEvents` and `collectionEvents` are not the only configuration hash
    sets that we have available in each one of the Marionette views; the UI configuration
    hash is also available. It may be the case that one of the DOM elements on your
    view will be used many times to read its value, and doing this using jQuery can
    not be optimal in terms of performance. Also, we would have the jQuery reference
    in several places, repeating ourselves and making our code less DRY.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a Backbone view, we can define a set of events that will be fired once
    an action is taken in the DOM; for instance, we pass the function that we want
    to handle in this event at the click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke the `updateValue` function once we click on `button2`. This
    works fine, but what about calling a method that is not inside the view?
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, Marionette provides the `triggers` functionality that will
    fire events which can be listened to outside of your view. To declare a `trigger`,
    we can use the same syntax used in the `events` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we can listen to that event somewhere else using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we used the model to alert and display the value of the
    property, `value2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `args` parameter received by the function will contain objects that you
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: The view that fired the trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Backbone model or collection of that view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working with a view, you will need a reference to a particular HTML element
    through jQuery in more than one place in your view. This means you will make a
    reference to a button during initialization and in few other methods of the view.
    To avoid having the jQuery selector duplicated on each of these methods, you can
    map that UI element in a hash so that the selector is preserved. If you need to
    change it, the change will be done in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this mapping of UI elements, we need to add the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And to make use of these mapper UI elements, we just need to refer them inside
    any function by the name given in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There will be times when you need to pass a different template to your view.
    To do this in Marionette, we remove the template declaration and instead add a
    function called `getTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet would illustrate the use of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we check the existence of the property `foo`; if it's not present,
    we use a different template and that will be it. You don't need to specify the
    `render` function because it will work the same way as declaring a template variable
    as seen in one of the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about all the concepts that we have discussed so far,
    please refer to the JSFiddle link [http://jsfiddle.net/rayweb_on/NaHQS/](http://jsfiddle.net/rayweb_on/NaHQS/).
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing to make calculations involving a complicated process
    while rendering a value, you can make use of `templeteHelpers` that are functions
    contained in an object called `templateHelpers`. Let's look at an example that
    will illustrate its use better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we need to show the value of a book but are offering a discount that
    we need to calculate, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the in the previous code, we declared an object `literal` that
    will contain functions that can be called from the templates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Marionette.CollectionView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rendering a list of things like books inside one view is possible, but we want
    to be able to interact with each item. The solution for this will be to create
    a view one-by-one with the help of a loop. But Marionette solves this in a very
    elegant way by introducing the concept of `CollectionView` that will render a
    child view for each of the elements that we have in the collection we want to
    display.
  prefs: []
  type: TYPE_NORMAL
- en: A good example to put into practice could be to list the books by category and
    create a Collection view. This is incredible easy.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to define how each of your items should be displayed; this means
    how each item will be transformed in a view.
  prefs: []
  type: TYPE_NORMAL
- en: For our categories example, we want each item to be a list `<li>` element and
    part of our collection; the `<ul>` list will contain each category view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare `ItemView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then we declare `CollectionView`, which specifies the view item to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A good thing to notice is that even when we are using Marionette views, we are
    still able to use the standard properties that Backbone views offer, such as `tagName`
    and `ClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a collection and we instantiate `CollectionView` by passing
    the collection as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. Simple huh?
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using this view is that it will render a view for each item,
    and it can have a lot of functionality; we can control all those views in the
    `CollectionView` that serves as a container.
  prefs: []
  type: TYPE_NORMAL
- en: You can see it in action at [http://jsfiddle.net/rayweb_on/7usdJ/](http://jsfiddle.net/rayweb_on/7usdJ/).
  prefs: []
  type: TYPE_NORMAL
- en: Marionette.CompositeView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Marionette.Composite` view offers the possibility of not only rendering
    a model or collection models, but also the possibility of rendering both a model
    and a collection. That's why this view fits perfectly in our BookStore website.
    We will be adding single items to the shopping cart, books in this case, and we
    will be storing these books in a collection. But we need to calculate the subtotal
    of the order, show the calculated tax, and an order total; all of these properties
    will be part of our `totals` model that we will be displaying along with the ordered
    books.
  prefs: []
  type: TYPE_NORMAL
- en: But there is a problem. What should we display in the order region when there
    are no items added? Well, in the `CompositeView` and the `CollectionView`, we
    can set an `emptyView` property, which will be a view to show in case there are
    no models in the collection. Once we add a model, we can then render the item
    and the `totals` model.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps at this point, you may think that you lost control over your render
    functionality, and there will be cases where you need to do things to modify your
    HTML. Well, in that scenario, you should use the `onRender()` function, which
    is a very helpful method that will allow you to manipulate the DOM just after
    your `render` method was called.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we would like to set a template with some headers. These headers are
    not part of an `ItemView`, so how can we display it?
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at part of the code snippet that explains how each part solves
    our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So far we defined the view and set the template; the `Itemview` and `EmptyView`
    properties will be used to render our view.
  prefs: []
  type: TYPE_NORMAL
- en: The `onBeforeRender` is a function that will be called, as the name indicates,
    before the `render` method; this function will allow us to calculate the totals
    that will be displayed in the `total` model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `onRender` method is used here to check whether there are no models in the
    collection (that is, the user hasn't added a book to the shopping cart). If not,
    we should not display the header and footer regions of the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Marionette does a great job offering functions that can remove
    a lot of boilerplate code and also give us full control over what is being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Building the layout of our application with Marionette.Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final view that we need to review is the `Marionette.Layout` view. This
    view is the combination of `Itemview` and `Region`; we haven't reviewed the `Marionette.Region`
    component, but for now, it's enough to say that it's a component that will be
    in charge of rendering a view on its `el`.
  prefs: []
  type: TYPE_NORMAL
- en: So the layout works as an `ItemView` because it requires a template to render
    itself. This template can be your initial HTML divided by logical regions, such
    as the navigation region that will contain a view which will display the navigation
    section of your site, the footer view that should be displayed at the footer region,
    and so on. You can start by rendering your layout and then rendering the view
    properly on each of the regions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the `Marionette.Layout` view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the HTML that you copied in [Chapter 2](ch02.html "Chapter 2. Our First Application"),
    *Our First Application*, you will find the corresponding `<div>` tags with the
    IDs of the regions.
  prefs: []
  type: TYPE_NORMAL
- en: In this view, we specified the script/template that the view will use to render.
    This specified template was added to the initial HTML, and inside it were `<div>`
    tags that will serve as regions. Each of the regions is given a name that makes
    sense with the view that it will be displaying, and we used an object `literal`
    to define the regions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Layout` view inherits the same functionality as for all the other views,
    so in case you want to listen to events, you can do it just like in any other
    view.
  prefs: []
  type: TYPE_NORMAL
- en: To render this initial layout, we just need to instantiate it and render it
    as any other view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can still add and remove regions to your layout at runtime by calling the
    `addRegion` and `removeRegion` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To add multiple regions, the `Layout` view provides an `addRegions` method that
    receives an object `literal` with the regions to be added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of the `Close` function on this view will be a little different
    as it will call `close` on all of the regions. These regions will then call close
    on the views that they contain, making sure all of the views contained are closed
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to start your application is to define a `Body` region; this region
    will then contain the application `Layout` that will contain all of the logical
    regions of the application. Maybe you need to display a sublayout in one of these
    regions, which is perfectly fine. There is no limit of nested layouts; use them
    as your application requires.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Marionette views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common need while working with Backbone and Marionette and in pretty much
    every language is to re-use code as much as possible. If you want all your views
    to behave in a certain way, you can achieve it by extending your Marionette views.
    In the following example, we will add a `log` method to all the item views by
    extending the `Marionette.ItemView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now you just need to start using your `HandyView` in order to get the benefit
    of the `logMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The idea here is to let you know that you can extend Marionette views just like
    you can extend Backbone views, and take advantage of the benefits of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got to learn about all the kinds of views that Marionette
    offers, when to use them, how to advantageously make use of its handy methods
    that will allow us to manage the DOM creation and interaction better, and finally
    how to extend them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about how to manage a set of views with the
    help of the `Regions`, `RegionManager`, and `BabySitter` objects of Marionette.
  prefs: []
  type: TYPE_NORMAL
