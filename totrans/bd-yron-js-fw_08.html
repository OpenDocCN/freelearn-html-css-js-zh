<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor138"/>8</h1>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Architecting Frontend Frameworks</h1>
<p>In this chapter, we now switch focus to the frontend components of the full stack framework that we began building in <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>. This is the final part of adding new features and architecting the technical design for the purposes of our <strong class="bold">Componium</strong> framework<a id="_idIndexMarker542"/> example. The frontend features are the most complex to design because they require a lot of domain knowledge of browsers, in-depth JavaScript, the ability to handle complex edge cases, and so on. We will cover a series of frontend topics that focus on enabling a full stack framework development environment. Here are some of the topics that we will cover:</p>
<ul>
<li><strong class="bold">Frontend features</strong>: We will determine the features and goals of the frontend components for our framework. In addition, this new frontend infrastructure needs to interact with the existing components of the full stack framework, such as the backend API routes and the testing interfaces.</li>
<li><strong class="bold">Architectural design</strong>: After learning more about the low-level interfaces of established frameworks, we will create a framework design that can offer similar features with low-level interfaces of its own. This includes developing a component, view, and routing architecture to server content to the web browser.</li>
<li><strong class="bold">Frontend patterns</strong>: Learning about common frontend patterns and optimizations will help us become more accustomed to working with existing frameworks and building new ones in the future.</li>
</ul>
<p>It is crucial to keep in mind that we can only scratch the surface of the feature set that other frameworks offer out of the box. For example, we can include a client-side router with a component-based architecture, including reactivity in those components. Frameworks such as Vue.js, Angular, and Svelte, plus libraries such as React, required years of development to cover all edge cases and significantly expand the feature set. For the purposes of this chapter, we will focus on keeping things closer to the basics and build several technical parts from scratch. This should give you a good understanding of the underlying components of other full stack frameworks with frontend features, such as Next.js. For example, we will use some of the web components APIs that are built right into modern web browsers to enable a rich feature set in our own framework.</p>
<p>Toward the end of the chapter, we shall also examine the intended workflow to understand the series of steps taken by a developer to utilize the framework interfaces to achieve specific application development goals, using our newly architected features.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Technical requirements</h1>
<p>The technical requirements for this chapter are very similar to those for <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>. This chapter reuses the framework files that we saw in <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a> with frontend components and interfaces. The sample application in the <code>tests</code> directory is also changed to showcase some of the frontend features. Locate the book’s repository at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>, and continue to use the code in the <code>chapter7</code> directory.</p>
<p>Follow the <code>README.md</code> instructions in the directory for available scripts. The sample app can be found in the <code>tests/sample</code> directory of the framework. When you start that application, it will be available on port <code>9000</code>. You can open it with a browser using the <code>http://localhost:9000/</code> URL. While you are jumping into exploring the chapter code base, it is recommended to use the debugging tools to trace how the elements come together. Refer to the <em class="italic">Debugging</em> section of <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a> to configure a debuggable environment.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Defining the frontend framework</h1>
<p>We<a id="_idIndexMarker543"/> will continue from the previous chapter by reusing the example <strong class="bold">Componium</strong> framework project. In <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, we created several features that <a id="_idIndexMarker544"/>allow us to interact with server-side routes, define APIs, and query a database. Currently, there is no way to develop frontend components to either consume those APIs or add visual interfaces using our framework. Without the frontend part of our framework, a developer needing to build an interactive interface, hosted using a Componium server, would need to include an external library and statically serve additional application files from the server.</p>
<p>Therefore, we will change the lack of frontend features by creating several frontend features that will allow framework users to create client interfaces. These frontend features will mimic some of the complex features of the existing established frontend frameworks. For instance, our approach to reactivity features inside the components will include the basics, utilizing the built-in APIs from the browsers.</p>
<p>To begin this <a id="_idIndexMarker545"/>process, we will identify the goals of the features we want to support. After that, we will follow with a sample architecture design that will make those features a reality and make our framework genuinely full stack.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Goals</h2>
<p>The frontend framework<a id="_idIndexMarker546"/> sets three goals that will be later supported by the features that we create. Overall, it is a good idea to define these goals in a general manner and use them as you progress with your framework project:</p>
<ul>
<li><strong class="bold">Web-based interfaces</strong>: Goal <a id="_idIndexMarker547"/>number one is to empower developers to <em class="italic">create web-based interfaces</em> while maintaining cohesion with the backend/server components of the framework. With the frontend capabilities of the framework, developers will have the ability to write, host, and deploy interactive client interfaces. These interfaces will be made possible by providing a frontend framework API to create components and attach those to client-based views. These client-based features should also be testable and debuggable, either by the built-in Componium test interfaces or external testing tools.</li>
<li><strong class="bold">Enable interactivity</strong>: A comprehensive set of APIs, both on the server-side and frontend side, will help <em class="italic">enable the interactivity</em> required by many of the framework-backed projects. The interactivity features need to enable developers to use familiar technologies such as HTML, CSS, and frontend JavaScript to craft components. The framework should also have the affordances to be able to include potential external libraries. For example, if someone wants to create a visualization within their Componium frontend application, then they should easily be able to include external libraries such as Three.js and D3.js.</li>
<li><strong class="bold">Promote reusability</strong>: We want to include a set of framework affordances to build complex applications. These could be applications with many frontend differentiated views that include a large number of nested components. These could also include a set of optimizations for production environments and the ability to manage large application code bases. Primarily, we also want to <em class="italic">promote the reusability</em> of code and guide developers to make intelligent decisions when building their applications. An easily extensible feature set can be beneficial to cover a lot of the potential use cases. If we get the architecture right, it will allow for high degrees of customizability.</li>
</ul>
<p>Learning from<a id="_idIndexMarker548"/> already existing frameworks such as Next.js, we also want to make sure to include some of the more modern features and offer pleasing developer experiences alongside those features. These could include code generation affordances, similar to the ones we saw in <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>. To set the framework apart from some of the other solutions, we will also set a goal to use some of the newly shipped Web APIs. Taking advantage of starting from scratch in our project gives us a good opportunity to evaluate the latest developments in the browser platforms, choosing the newly available APIs. As part of our learning goals, we will also try to contrast the difference between our newly developed framework and the established mature frameworks, such as Vue.js and Next.js.</p>
<p>With these goals in mind, let’s dive into the set of features that can back these goals up.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Features</h2>
<p>The<a id="_idIndexMarker549"/> frontend goals defined in the previous section will help us guide the thought process behind our feature development. To support the established goals, let us plan out some of the technical features that developers will find useful and expect from the framework. Here are some substantial features that we will discuss in detail in this chapter:</p>
<ul>
<li><strong class="bold">Serve HTML files and content</strong>: To support the features of the interactive interfaces, we will need to add the ability to serve the generated HTML output to browser requests. We need to ensure that we have the capabilities to serve static content to sustain additional JavaScript code, images, media, and other types of files. This feature is vital to render content on the client side in a web browser.</li>
<li><strong class="bold">Structured application code</strong>: We need to grant the ability to define reusable interactive JavaScript components with CSS/HTML templating and styling features. We will do this using a component-based architectural approach. The component architecture feature itself will enable the development of user interfaces. The structured application code that it can help produce will consist of independent and reusable bits of code that serve as the building blocks of the whole web application. This will support our goals of reusability and providing good application primitives, as it takes advantage of component paradigms, such as reactivity, composability, and modularity. The approach to this feature aims to have each component control its own state and render the interfaces based on the state.<p class="list-inset">Supporting <a id="_idIndexMarker550"/>the maintenance goals, the component-based approach ensures isolated testing and debuggability of the application code. Here, we channel some of the previous design decisions from other frameworks. For example, in Vue.js, components are structured with JavaScript logic, HTML templates, and the ability to style them with CSS.</p></li>
<li><strong class="bold">Composability</strong>: Expanding on the previous point, it is important to highlight the composability of application code as an important feature of the framework we want to create. Defining a nested structure based on how the web browser internal DOM structure, components can then be composed together to create complex user interfaces. Refer to the <em class="italic">Components</em> section of <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a> for a recap of the importance of this feature.</li>
<li><strong class="bold">Client-side router</strong>: One of the core pieces of frontend framework organization that we have seen in <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a> was the router. The routing feature set is crucial to include in our feature set because it is responsible for navigating between complex views of our application. From <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, we already have an API for server-side routes, and the frontend router will help provide the functionality to enable a fast and smooth transition between different application states.</li>
<li>The router<a id="_idIndexMarker551"/> will adhere to the existing concepts of web application navigation and utilize the relevant Web APIs to modify the browser’s URL and history features. The inclusion of the router will also be beneficial in creating a more logically organized code.</li>
<li><code>HttpClient</code> helper module (<a href="http://angular.io/guide/understanding-communicating-with-http">angular.io/guide/understanding-communicating-with-http</a>) to communicate with suitable backend services. This would be an <a id="_idIndexMarker553"/>excellent reinforcing feature for our sample project, especially if combined with some of the specific <em class="italic">Componium server</em>-defined routes. For example, to help enhance the developer experience, we can pre-generate some of the data fetching calls for the known endpoints and create dynamic interfaces around those, thus saving time for developers building with our framework.</li>
<li><strong class="bold">Server-side rendering (SSR)</strong>: We mentioned SSR features in other framework examples throughout the book. We will include these features in our example framework as well. The SSR methods will render the components on the server side to help improve the rendering performance of the applications. Given our full control over the developer experience of the full stack framework in this particular case, developing this type of functionality is easier for us. Besides the performance improvements, SSR is beneficial for search engine optimization purposes and general page loading time.<p class="list-inset">The internals of SSR include close collaboration between components pre-rendered on the backend and later hydrated by the frontend code. The backend routes should also be able to inject the state of components into the pre-rendered elements. The state can be static data or information fetched from external sources, such as a database.</p></li>
<li><strong class="bold">Production optimizations</strong>: As part of the commitment to empowering developers, the framework will also feature some optimization steps for applications running in production environments. This means including additional <a id="_idIndexMarker554"/>internal tooling that performs optimizations, such as minification, behind the scenes. These kinds of optimizations are also much easier to integrate within our framework because we have control of the server tooling.<p class="list-inset">Besides code minification, we can also look into advanced JavaScript optimization techniques such as tree-shaking and code-splitting. Supporting static file handling, we can potentially optimize other media such as images. Generally, as the framework continues, we want to consistently work on such optimization improvements because it benefits all the framework’s users.</p></li>
</ul>
<p>The preceding list is a selected set of functionalities that should make the frontend feature-rich, give us a good learning opportunity, and also cover realistic use cases.</p>
<p>The following <em class="italic">Figure 8</em><em class="italic">.1</em> provides a summary of how the listed features interact with each other:</p>
<div><div><img alt="Figure 8.1: The features summarized" src="img/Figure_8.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: The features summarized</p>
<p>The<a id="_idIndexMarker555"/> existing server-side code will be able to serve static files that can be consumed by the frontend. At the same time, the server process is capable of importing and accessing some of the components to render them on the server side. Finally, the backend has a definition of client routes; these are the frontend endpoints that are classified as accessible by a browser to be rendered in the client.</p>
<p>On the frontend side, we have the <em class="italic">API interaction</em> features that communicate with the server or make requests to external APIs that are hosted on external services. Simultaneously, a client-side router tightly works with the component architecture to enable the user interface experience in the browser. Finally, we have a set of frontend optimizations that cover all of the frontend surfaces, ensuring the most optimized experience when deploying and running applications in production environments.</p>
<p>With these features in mind, let us proceed to the architecture step, where we can explore the technical and organizational concepts that make these features possible.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Architecture</h1>
<p>With the<a id="_idIndexMarker556"/> required features outlined and documented, let us extend the existing architecture from <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>. The changes will be adding new functionality to the framework architecture, concentrating on enabling the <code>ClientView</code> abstractions and functionality, which will drive the feature experience behind the frontend changes.</p>
<p>We already have the capability to create server API endpoints. The general implementation of the architecture of the features will consist of introducing several new interfaces to the server part of the framework. The newly added frontend features will be situated in the <code>frontend</code> directory of the framework project.</p>
<div><div><img alt="Figure 8.2: Componium frontend components" src="img/Figure_8.2_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Componium frontend components</p>
<p>In <em class="italic">Figure 8</em><em class="italic">.2</em>, we <a id="_idIndexMarker557"/>outline an incoming request to the server powered by the Componium server framework. Specifically, this request is expected to respond with an HTML page to provide interactivity features. This is unlike the API requests from <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, where we would receive JSON or GraphQL responses with data. The request handler can still process incoming request objects, such that it can access properties of the request, such as the query parameters. It can also tweak any properties of the response object. In <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, we used <code>server.addRoute(...)</code> to add new routes. To add route handlers that provide the functionality, we will use a similarly structured <code>server.addClientView(...)</code> method that will have a similar API, but a totally different behavior. This new method is where the <strong class="bold">client view</strong> functionality from <em class="italic">Figure 8</em><em class="italic">.2</em> will take place.</p>
<p>In the Componium frontend component design, a client view can have a singular view and many components used within it. The concept of the client view is a server-side definition, while<a id="_idIndexMarker558"/> the concept of views is shared across both the server and the client side. Once the client view is defined, it assembles all the imported components and the View together and sends a response back to the browser.</p>
<p>Besides the <a id="_idIndexMarker559"/>client view interaction, the server can now also define and access static file directories. These static files can be directly accessed by the browser, and the whole directory is exposed to the web server. These static files are also usable by the Client Views to import additional resources into the Client Views, such as any media files (images, fonts, styles, etc.) or additional JavaScript components. The ease of access to static files simplifies how a frontend framework can include external media and other useful entities that can be included within the web application.</p>
<p>In the next section, we will get a detailed look into how Client Views become the gateway for the frontend features and files, allowing us to create multiple endpoints serving HTML, CSS, and JavaScript code.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Entry points</h2>
<p>To <a id="_idIndexMarker560"/>allow flexibility when creating multiple frontend Client Views, our framework provides a way to define multiple client endpoints:</p>
<pre class="source-code">
server.addClientView("/", "frameworks", {
  title: "Frameworks",
  // …
});</pre>
<p>The preceding code is an example of routing the root path of our server to the <code>frameworks</code> view. Developers can create a <code>frameworks.js</code> file inside the <code>views</code> directory to map this view by the defined name. <code>.addClientView(...)</code> can be configured multiple times, with as many views attached to different route handlers. The contents of <code>frameworks.js</code> have a familiar structure to the route handlers from <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>:</p>
<pre class="source-code">
export default function frameworks(request, response) {
  return `&lt;p&gt;Welcome!&lt;/p&gt; `;
}</pre>
<p>The preceding <a id="_idIndexMarker561"/>code can be as simple as returning a paragraph tag. You can find other examples of more involved views in the <code>tests/sample/views/</code> directory. The view handler has access to the <code>Request</code> and <code>Response</code> objects of the route to tweak the behavior of the route or fetch additional data. We also have access to the <code>componium</code> variable here to access the interfaces of the framework. For simplicity, we will use JavaScript template literals in more complex templates. The framework takes care of rendering the desired HTML structures, and it also wraps the <code>&lt;p&gt;</code> tag in the preceding code in a valid HTML document.</p>
<p>The other important entry point for our frontend files is static file configuration. To be able to resolve other types of media, the framework provides a way to mark certain directories of the application project as an endpoint that serves static files:</p>
<pre class="source-code">
server.addStaticDirectory("/images", "img"));</pre>
<p>The <code>.addStaticDirectory(...)</code> method maps the server route for <code>/images</code> to the <code>img</code> directory in the application project. This relies on the similar properties of the backend express server that we worked with in <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>. This new static directory also works in custom routers, which are created with <code>server.createRouter(...)</code>.</p>
<p>We now have a way to process and render basic views and create as many of them as we want. We now need to enable the component-based architecture. This is what will allow us to produce more complex interactive components.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Reactivity</h2>
<p>To achieve <a id="_idIndexMarker562"/>the dynamic interface features of our frontend framework, we need to learn more about the concepts of reactivity and reactive components. The reactivity concepts in application programming direct the user interface to update and respond to underlying data or state changes dynamically. In the context of JavaScript, especially in the frontend systems, we use custom-developed primitives in combination with browser APIs to achieve performant user interface reactivity. The reactivity features enable a seamless experience for web application consumers by automatically updating the interface whenever relevant underlying data changes. Similar to other programming environments, in the JavaScript world, developers rely on frameworks and helper libraries to enable reactivity for components in their applications. In fact, this reliance on external tooling in JavaScript is much stronger than in other languages. This is mainly due to the cross-browser and cross-engine nature of web page and web application development.</p>
<p>The<a id="_idIndexMarker563"/> reactive programming paradigm has become very fitting in the web development environment, due to the asynchronous nature of JavaScript. Other contributing factors for the reactive paradigm fit included application requirements for real-time updates, complex interactivity, and making it easier to manage the state of applications. The user interfaces have become much more complex. These days, the expectations of web applications require frontend systems to be dynamic, consume real-time data, and be instantly responsive to user actions. Also, the existing structure and <a id="_idIndexMarker564"/>abstractions around a web browser’s <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) have compelled solutions to be based on manipulating a nested node tree of page elements. The reactive changes in the interface utilize the diffing algorithms to update the changed nodes of a component tree.</p>
<p>Reactivity requires data binding, which is a connection between data and the elements of applications. In the web development world, the data would be provided by JavaScript interfaces, most likely dynamically loaded from some API endpoint. The elements would be the <em class="italic">HTML/DOM</em> structures in the browser client. The corresponding browser elements are automatically updated to reflect the changes when the underlying data updates. In <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, in the <em class="italic">Framework building blocks</em> section, we highlighted the possible ways in which data binding can occur within these reactive components. We also saw examples of frameworks using one-way or two-way binding. The flow largely depends on architectural decisions, either allowing the elements to update when data changes or also allowing the elements to update the underlying data. Popular frameworks such as Vue.js and anything that includes React use an implementation of a <em class="italic">virtual DOM</em> tree to render an application’s state as the data changes. However, there are also examples where projects, such as those involving Svelte and Angular, use the real DOM or <em class="italic">shadow DOM</em> features to achieve similar functionality.</p>
<p>Similar to other frontend projects, we will introduce the concept of reactive components into our framework. These components will allow us to encapsulate HTML elements and application logic alongside them. The frontend <em class="italic">Componium</em> components will maintain their internal state and respond to data and interactions. To keep things simpler and without diving deeper into the internals of the existing frontend frameworks, we can build an example of basic reactivity concepts using a combination of Web Components and other more modern Web APIs. A practical overview of the component architecture <a id="_idIndexMarker565"/>will provide a good learning opportunity to understand the built-in browser primitives. It will also offer a good comparison and understanding of the complex problems that the existing frameworks solve for us:</p>
<pre class="source-code">
class ReactiveComponent extends HTMLElement {
  constructor() {
    super();
    this.state = this.reactive(this.data());
    this.attachShadow({ mode: "open" });
  }
  reactive(data) {
    return new Proxy(data, {
      set: (target, key, value) =&gt; {
        target[key] = value;
        this.update();
        return true;
      },
    });
  }
  callback() { this.render(); this.update(); }
  render() { this.shadowRoot.innerHTML = this.template(); }
  // methods that child components will override
  update() {}
  data() { return {}; }
  template() { return ""; }
}</pre>
<p>The<a id="_idIndexMarker566"/> preceding code is our newly defined <code>ReactiveComponent</code>; it has been compacted to fit in better in this chapter. The class starts off extending <code>HTMLElement</code>. This interface will help us represent HTML elements and create our own web components. In the <code>constructor</code> method, we have a declaration for the <code>state</code> property, which will keep track of the state of the component. Another important constructor call is <code>.attachShadow()</code>. This call attaches a Shadow DOM to the custom element and provides a scoped environment for the encapsulated CSS and JavaScript instructions.</p>
<p class="callout-heading">Additional reading</p>
<p class="callout">For a detailed low-level explanation of how<a id="_idIndexMarker567"/> Shadow DOM is structured, check out the MDN page at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM">developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM</a>.</p>
<p>In the <code>reactive</code> method, we configure a new <code>Proxy</code> object, which is another built-in Web API with properties that can help us make reactive changes to the state of our components. The <code>Proxy</code> methods take an object and return a new object that serves as a proxy for the original definition. The proxy behavior helps trigger updates and re-renders of a component when the object is updated.</p>
<p class="callout-heading">Additional reading</p>
<p class="callout">For details <a id="_idIndexMarker568"/>on the <code>Proxy</code> interface, check out the detailed article at MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy ">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
<p>The setter operation and the update methods will be invoked when the state changes. The <code>update()</code> method is overridden in the components that inherit this <code>ReactiveComponent</code> class. With <code>ReactiveComponent</code>, we can build a simple set of example components. This structure will bind the data from the component state into the rendered templates.</p>
<div><div><img alt="Figure 8.3: A basic components example" src="img/Figure_8.3_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: A basic components example</p>
<p><em class="italic">Figure 8</em><em class="italic">.3</em> presents an example view of two components in action; one is the year tracker and the <a id="_idIndexMarker569"/>other is the month tracker. Both components have the option to increment the values of the appropriate dates. You can find the code for this working example in the <code>tests/basic-components/index.html</code> file:</p>
<pre class="source-code">
&lt;body&gt;
  &lt;h1&gt;Basic Components&lt;/h1&gt;
  &lt;year-component&gt;&lt;/year-component&gt;
&lt;/body&gt;</pre>
<p>The source of the view follows; it just includes a newly defined component by its name, <code>year-component</code>, wrapped in regular HTML tags. This was achieved by registering the custom element using the built-in Web Components interface – <code>customElements.define("year-component", YearComponent);</code>. The <code>year-component</code> component extends the preceding <code>ReactiveComponent</code> class and overrides the empty <code>update</code> and <code>template</code> methods, as follows:</p>
<pre class="source-code">
template() {
    return `
      &lt;button id="addYears"&gt;Add Years&lt;/button&gt;
      &lt;div id="yearCount"&gt;Year: 0&lt;/div&gt;
      &lt;month-component&gt;&lt;/month-component&gt;
    `;
  }
  connectedCallback() {
    super.connectedCallback();
    this.shadowRoot.querySelector
      ("#addYears").addEventListener("click", () =&gt; {
      this.state.yearCount++;
    });
  }
  update() {
    this.shadowRoot.querySelector(
      "#yearCount"
    ).textContent = `Year: ${this.state.yearCount}`;</pre>
<p>The <a id="_idIndexMarker570"/>methods listed in the preceding code, such as <code>update()</code> and <code>template()</code>, render the data relevant to the component and define the template returned by the <code>year-component</code> component. We also have event handlers that change and update the year, using access to <code>this.state</code>. Also, note that to access the Shadow DOM properties of this <code>Year</code> component, we use <code>this.shadowRoot.querySelector</code>. The template defined in the component includes <code>month-component</code>, which is a nested component. It has a similar setup to the extended class of <code>ReactiveComponent</code>.</p>
<p>This component configuration, using the Web Components APIs and other affordances from the browser APIs, is a good starting point for the framework. We can use these patterns to achieve similar functionality in other frameworks, such as Vue.js, and frameworks that use React as their underlying library to structure their components. The interface we have has reactivity properties, the ability to compose components simultaneously, and the basics of templating.</p>
<p>In the following section, we will take this a bit further and utilize an external Web Component helper library to build upon this pattern.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Improving components</h2>
<p>In the <a id="_idIndexMarker571"/>reactivity part of the architecture, we have described a pattern of using Web Components comprised of other techniques to achieve the desired feature set. To enhance this further, we will bring in <a id="_idIndexMarker572"/>the <code>lit.dev</code>), which will help make our job of managing the components much more straightforward, and our framework can be dependent on it. We shall use the same approach of abstractions and utilize the interfaces of this library to create the component features of our framework.</p>
<p class="callout-heading">About the Lit library</p>
<p class="callout">The Lit open source library has been around for more than six years, and its goal is to simplify and abstract away some of the verbose tasks that deal with Web Components. At its core, it provides reactive state features, scoped CSS styling, templating, and a variety of advanced features to compose and work with frontend components. It works with both JavaScript and TypeScript languages and comes with a large variety of packages that extend its functionality. For example, Lit has additional tools to enable localization, animate frontend elements, and also integrate with React components.</p>
<p class="callout">The library uses <a id="_idIndexMarker573"/>the standard component life cycle, in addition to its own component life cycle methods to simplify certain operations, such as DOM reactivity. You can find the source of the project at <a href="https://github.com/lit/lit">github.com/lit/lit</a> and <a href="https://lit.dev/docs">lit.dev/docs</a>.</p>
<p>To draw a comparison with the preceding <code>ReactiveComponent</code> interfaces, let’s take a look at how similar the code would be to the basic components if we used the Lit library:</p>
<pre class="source-code">
import {html, css, LitElement} from 'lit';
export class YearComponent extends LitElement {
    static styles = css`p { color: green }`;
    static properties = {
        year: {type: Number},
    };
    constructor() {
        super();
        this.year = 2024;
    }
    render() {
        return html`&lt;button id="addYears"&gt;Add Years
          &lt;/button&gt;
      &lt;div id="yearCount"&gt;Year: ${this.year}&lt;/div&gt;`;
}</pre>
<p>The <a id="_idIndexMarker574"/>preceding code imports the <code>LitElement</code> class that we can extend. This new code block result looks very familiar to the code of <code>year-component</code> that we saw in the <em class="italic">Reactivity</em> section. However, there are some additional improvements we have in this component definition.</p>
<p>Let’s explore a few of them:</p>
<ul>
<li>First of all, we have a CSS helper interface, which allows us to declare the style of our component using the <code>static </code><code>styles</code> variable.</li>
<li>Second, the way we declare the state of the component has also changed – we define a <code>static properties</code> object with some extra definitions of the properties. These properties are used in a similar way in the template.</li>
<li>This brings us to the third point – the templating is also a bit different. It uses the <code>lit-html</code> helpers to enable more advanced templating features and help us work with HTML. This helper allows us to create templating directives, tweak the rendering methods, and so on.</li>
</ul>
<p class="callout-heading">Additional reading</p>
<p class="callout">Detailed documentation of all the templating features can be found at <a href="https://lit.dev/docs/v3/templates/expressions">lit.dev/docs/v3/templates/expressions</a>.</p>
<p>For the purposes of our sample framework, we will define our own <code>ComponiumComponent</code> class. This class will be available to the developers to create rich components, combining what we have learned from the <em class="italic">Reactivity</em> section and the Lit library. We<a id="_idIndexMarker575"/> can also rely on the rich functionalities of Lit templating to render the results. To enable this, we will load the Lit library alongside the <code>componium.js</code> framework file in <code>ClientViews</code>. This will expose the component interface to developer-defined components. To start using those interfaces, developers can import them using the ES6 syntax:</p>
<pre class="source-code">
import { css, html, ComponiumComponent } from "componium";</pre>
<p>The class to extend is provided, alongside the CSS and HTML helpers to help construct the components. For example, if our component has interactive buttons, it can use the following Lit syntax to declare event handlers:</p>
<pre class="source-code">
html`&lt;button @click="${this._click}"&gt;click&lt;/button&gt;`;</pre>
<p>The <code>_click</code> event handler is a method defined on the class that extends from <code>ComponiumComponent</code>. If these components require any static files, they can request them directly by fetching them from the static routes declared by the Componium server. However, we can still take this one step further and use Lit and the mix of our framework’s interfaces to enable the complex features of SSR. There will be more on the concept of utilizing the existing components from a server in the next section.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>SSR</h2>
<p>We<a id="_idIndexMarker576"/> learned about the features and benefits of SSR when we planned the frontend interfaces of Componium. On a technical level, SSR requires several parts of our framework to work really well. Here are some of them:</p>
<ul>
<li>The component architecture needs to support different rendering capabilities. This includes the ability to pre-render the components as HTML that can be transmitted over the wire to the frontend.</li>
<li>Components need to be able to run consistently on both the server and the browser.</li>
<li>The server-rendered components should have the ability to fetch data in both the client and server environments. Depending on the environment, components should have a similar approach to how data is requested and processed.</li>
<li>We need a server that can structure and render the components, including attaching a state and data to these components.</li>
<li>The frontend side should be able to take the server-side state of the components and later hydrate them. It should be able to attach the required events.</li>
</ul>
<p>Luckily, with <a id="_idIndexMarker577"/>our framework and the Lib library, we have a lot of these requirements covered and can develop the SSR support in our framework. Using the <code>@lit-labs/ssr</code> package, we can define a server-side render in conjunction with our Client View abstractions. The modules for these features can be found in <code>packages/frontend/client-view.js</code>. To have a flexible feature set in our framework, we want developers to use both client-side-only components and a combination of server-rendered components.</p>
<p>To enable the SSR capabilities, the framework has a new <code>Renderer</code> class, which has the job of consolidating all the required framework code and developer-defined components. It does so by responding to client-side requests with a unified template of a valid HTML document and by injecting code from the application directory. To render these structures, we can use the <code>html</code> helpers from the <code>ssr</code> library. To understand the capabilities of the <code>ssr</code> package, check out the comprehensive documentation at <code>lit.dev/docs/ssr/overview</code>.</p>
<p>These capabilities work in tandem with the Componium server rendering methods to output the resulting HTML to the client. Once the HTML document has been fully loaded in the browser, then the hydration process begins. The framework files load the required supporting files that will help attach the event handlers to our components and make them interactive.</p>
<p>We shall examine the detailed usage of the server-side rendering features in the upcoming <em class="italic">Using the framework</em> section. Meanwhile, there are a few more architectural features left to cover before we can start using all of them together.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Client router</h2>
<p>At the<a id="_idIndexMarker578"/> framework planning stage, the router was highlighted as an essential piece of frontend infrastructure that allows an interface to transition between significant sections of an application. The routing implementations are very similar across many frontend frameworks. However, if you<a id="_idIndexMarker579"/> are really passionate about the routing features, the <em class="italic">React Router</em> project (<a href="https://reactrouter.com">reactrouter.com</a>) is a great project to learn from in terms of educating yourself about good routing abstractions, the potential pitfalls, and routing edge cases.</p>
<div><div><img alt="Figure 8.4: A transition between the initial page (left) and the newly routed page (right)" src="img/Figure_8.4_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: A transition between the initial page (left) and the newly routed page (right)</p>
<p>To enable the routing functionality in our framework, we will introduce a <code>ComponiumRouter</code> class. In <em class="italic">Figure 8</em><em class="italic">.4</em>, we can see the routing transition between the initial <code>/client-render</code> page (<em class="italic">left</em>) and the newly routed page, <code>/page</code> (<em class="italic">right</em>). The routing happens when you click on the <code>this.router = new ComponiumRouter("client-render", </code><code>routes, this.shadowRoot);</code>.</p>
<p>The router gets an identifier (<code>client-render</code>), a series of routes with the <code>routes</code> object, and a root element (in this case, the <code>this.shadowRoot</code> object) that will be used to render the routed templates. The <code>routes</code> object is defined as an array of objects. For example, a simple route example for <em class="italic">Figure 8</em><em class="italic">.4</em> would look as follows:</p>
<pre class="source-code">
const routes = [{
    path: "/client-render",
    template: "&lt;nested-component&gt;&lt;/nested-component&gt;",
  },
  {
    path: "/page",
    template: "&lt;navigated-component&gt;
      &lt;/navigated-component&gt;",
  },];</pre>
<p>The <code>/client-render</code> route is one of our entry points that has Client View type and the <code>/page</code> route<a id="_idIndexMarker580"/> is a view we can navigate to. The router can support a richer feature set by accepting more complex templating structures in the <code>template</code> property. For example, we can use the <code>html</code> helper from the <code>Componium/Lit</code> modules to produce more extensive template objects in the routing definition.</p>
<p>To navigate between routes, we will rely on more built-in Web APIs in browsers. For instance, the components call out to <code>history.pushState(...)</code> when views need to be changed. Inside the <code>ComponiumRouter</code> class, the framework handles those <code>pushState</code> events and renders the appropriate template.</p>
<p class="callout-heading">Additional reading</p>
<p class="callout">The MDN documentation outlines all possible History API methods we can use in our frontend routing components. It is <a id="_idIndexMarker581"/>available here: <a href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState">developer.mozilla.org/en-US/docs/Web/API/History/pushState</a>.</p>
<p class="callout">In the Lit Labs open source code base, there <a id="_idIndexMarker582"/>is another example of a component router. The source for it can be found at <a href="https://github.com/lit/lit/tree/main/packages/labs/router">github.com/lit/lit/tree/main/packages/labs/router</a>. It can be an excellent exercise to implement the router in the <em class="italic">Componium</em> framework.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Optimizations</h2>
<p>Part of our goals for<a id="_idIndexMarker583"/> frontend functionality was a set of optimizations to make the applications that our framework produces more efficient, scalable, and performant. We shall take a step toward that by introducing some features to optimize the output of our frontend components in production environments.</p>
<p>We will introduce a new <code>Optimize</code> class, which has some functions to perform optimizations on the code base. The class can be found in the framework directory at <code>packages/frontend/optimize.js</code>. These optimizations can affect both the included/injected framework files and the application code. The functions of this class will activate when applications deploy within an envrionment that has the <code>NODE_ENV=production</code> variables defined, which is the common pattern for Node.js-based projects.</p>
<p>We will utilize some existing JavaScript tooling – in this particular case, <code>esbuild</code> – to <code>minify</code> the framework and component code files. The <code>esbuild</code> tooling provides the following minification command-line API:</p>
<pre class="console">
 esbuild ${filePath} --minify --outfile=${newFilePath}.</pre>
<p>We can use the power of <code>esbuild</code> tooling to optimize applications built with our framework. For example, all the components used in an application will be minified by the server process when required. Under the hood, the framework parses through the component files and runs the minification step, outputting the optimized files into a separate directory. We use a hidden directory called <code>.componium</code> as storage to save the optimized files. The framework later knows to access the optimized files instead of the originals.</p>
<p>To expand further improvements in the future, we can focus optimizations on other application files, such as images, media, and more. The introduction of more complex build tools is also possible. For example, we can add <code>rollup.js</code> to enhance the resulting output of the client-side code. We have seen example usages of rollup tooling in <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>. <code>Esbuild</code> also <a id="_idIndexMarker584"/>provides additional functionality besides the minification that can be found at <a href="https://esbuild.github.io/api">esbuild.github.io/api</a>.</p>
<p>Now, the final part to cover is the improvements in the developer experience for these frontend components, which we will do in the following section.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Developer experience</h2>
<p>The finishing<a id="_idIndexMarker585"/> touches for our features are to include some improvements to the developer experience. We will do this through thorough documentation of the component system and by providing enhancements to the framework’s executable file.</p>
<p>The documentation should provide clear instructions on the frontend capabilities, such as the definition of multiple Client Views and static file directories. The component structure, composability, and reactivity features also need to be described. For example, this could include a straightforward API to add new client routes and how the framework uses the Lit library to achieve the component-related features.</p>
<p>The improvements of the framework executable include the ability to generate the Client View routes, Views, and Components using a scaffolding operation. In <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, we saw an example of generating new API routes; this is a very similar addition. Just as before, with the executable, developers will be able to quickly generate some code and start composing frontend user interfaces. These pre-generated components include the default property configurations for styles and data properties of objects.</p>
<p>Overall, we will demystify as many of the frontend features as possible, focusing on helping developers navigate the complicated intricacies of all the technologies that are in play while building client-side web applications.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Dependencies</h2>
<p>We will use <a id="_idIndexMarker586"/>several dependencies fetched from the <code>npm</code> package registry to achieve the level of functionality described in this chapter. Here are some notable ones:</p>
<ul>
<li><code>Esbuild</code>: The <a id="_idIndexMarker587"/>bundler and minifier tool used for optimization steps when the framework server runs in production environments. With <code>esbuild</code>, we can quickly optimize scripts. It includes a lot of advanced features that we can use to extend the end-result scripts of our framework further.</li>
<li><code>Lit</code>: The library<a id="_idIndexMarker588"/> that helps us extend the existing Web Component techniques and provides much more advanced component features, such as enabling easier data-binding and simplified state management.</li>
<li><code>lit-html</code>: Another <a id="_idIndexMarker589"/>module that is related to the Lit library, which provides templating features for the frontend features of our framework.</li>
<li><code>@lit-labs/srr</code> and <code>@lit-labs/ssr-client</code>: These two modules enable the <a id="_idIndexMarker590"/>SSR features<a id="_idIndexMarker591"/> of our framework. They can render the components in the Componium server and are later hydrated on the frontend.</li>
</ul>
<p>Mainly, these <a id="_idIndexMarker592"/>libraries and tools help us enrich our framework features. Our framework can rely on these dependencies to enable efficient project building, component-based architecture, dynamic content rendering, and SSR, resulting in a performant, maintainable, and user-friendly application. With the detailed architecture in place, in the following section, we will explore the developer workflow to create a simple client-side application with Componium’s frontend features.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Using the framework</h1>
<p>Now that <a id="_idIndexMarker593"/>we have the architecture in place, we can go through a <a id="_idIndexMarker594"/>scenario where a developer uses our frontend framework parts to build a simple frontend example application. In <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, we performed the same task to get a good outline of all the features working together to achieve a certain task. To follow along, ensure that you have installed the dependencies, and then you can start the sample app in the following directory:</p>
<pre class="console">
&gt; cd chapter7/componium/tests/sample
&gt; componium dev
Executing (default): SELECT 1+1 AS result
Componium Server (PID: 59938) started on port: 9000</pre>
<p>You will be able to open the browser at <code>http://localhost:9000</code> to view the application.</p>
<div><div><img alt="Figure 8.5: A sample client-side app" src="img/Figure_8.5_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5: A sample client-side app</p>
<p>Based on <em class="italic">Figure 8</em><em class="italic">.4</em>, we want to create a page with a header called <strong class="bold">List of frameworks</strong>. We also want to list some frameworks on this page. Every framework entry should attach to the client-side view and show a number of star points to every framework. Besides the static functionality, we have buttons under each framework component that are <a id="_idIndexMarker595"/>able to increment a counter, in this case we label the counter as the number of stars for every project. The developer use case also includes using the SSR features to render the page from the server for performance and SEO purposes.</p>
<p>To begin, our<a id="_idIndexMarker596"/> Componium framework allows us to create <code>ClientViews</code> from the server. We can create a client view at the root of the application in the <code>app.js</code> file. We can also utilize the <code>componium</code> executable here to scaffold the components:</p>
<pre class="source-code">
server.addClientView("/", "frameworks", {
  title: "Frameworks",
});</pre>
<p>The following code from the root of our application will establish a hosted route at the endpoint designated with a <code>/</code> on the Componium server. Besides providing the path, we also specify the name of the view and additional options for that view. The name of the view maps to the <code>views</code> directory in our applications. The <code>views/frameworks.js</code> file defines our server-side component handler:</p>
<pre class="source-code">
export default function frameworks(request, response) {
  const hitsComponium = 1000;
  // code omitted
  return `
    &lt;div class="framework-list"&gt;
      &lt;framework-item name="Componium" count=
        "${hitsComponium}"&gt;&lt;/framework-item&gt;
     &lt;!-- extra code omitted --&gt;`;
}</pre>
<p>To see the full version of this component, check out the <code>tests/sample/views/frameworks.js</code> file. The preceding code only lists one of the frameworks in the list, but the sample has all of the required items. Looking deeper into the code, we have <a id="_idIndexMarker597"/>access to the <code>request</code> and <code>response</code> objects in this exported <code>frameworks</code> function. This is where developers can also access the database ORM methods in this file to fetch the data and pre-populate the component state.</p>
<p>With the<a id="_idIndexMarker598"/> defined <code>framework-item</code> components in place, we can start the application server and navigate to the root of the application. If we view the source of the file, we can see the SSR components. Partially, the source would look like this:</p>
<pre class="source-code">
&lt;h1 style="font-family: sans-serif; text-align:
  sscenter;"&gt;List of frameworks&lt;/h1&gt;
    &lt;div class="framework-list"&gt;
      &lt;framework-item
        name="Componium"
        count="1000"
      &gt;&lt;/framework-item&gt;</pre>
<p>The state of the component, including the number of stars is hydrated from the rendered component. If we use the following <code>button</code> element in the <code>framework-item</code> component, then we increase the number of starts based on the state that originated from the server:</p>
<pre class="source-code">
&lt;button @click=${() =&gt; this.count++}&gt;Add stars&lt;/button&gt;</pre>
<p>Finally, with <a id="_idIndexMarker599"/>the <code>frameworks.js</code> application view created, we can now deploy our application to give it a test run. Here, developers should configure the <code>app.js</code> process to run with the <code>NODE_ENV=production</code> environment variable turned on. This will enable the <code>esbuild</code> optimization features, allowing the server process to minify our newly created components.</p>
<p>This example use of the <a id="_idIndexMarker600"/>framework included creating components, rendering them on the server side, and interacting with their state by clicking on their UI elements. This practical example and the routing examples from the <em class="italic">Client router</em> section showcase most of the features that we have developed for this initial version of the framework features. The following steps from here could involve finding ways to improve the component-based architecture, as well as finding more ways to add potential optimizations to the applications built with our framework.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Summary</h1>
<p>In this chapter, we focused on building a frontend architecture and adding frontend features to our existing project. Similar to the definition of server-side architecture in <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, in this chapter, we had to define the goals behind the frontend features, focusing on what developers would like to do with our full stack framework. We have covered the topics of defining entry points for client routes, concepts of reactivity, complex component structures, SSR, routing, optimizations, and so on. The frontend feature set can be overwhelming, with a lot of terminology, and there is much more to learn beyond this chapter.</p>
<p>If we combine all the components that we have architected in the past several chapters, we now end up with a framework consisting of three use cases that combine into a larger full stack narrative. So far, we have seen a JavaScript testing framework, a backend framework, and finally, a frontend framework under the same logical namespace.</p>
<p>In the next chapter, we will focus on essential topics of framework maintenance by shedding light on various situations that can occur as frameworks evolve.</p>
</div>


<div><h1 id="_idParaDest-156" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor155"/>Part 3: Maintaining Your Project</h1>
<p>In conclusion, the last two chapters give an in-depth look at the maintenance aspects and future of framework projects in the JavaScript programming space. The driving factor behind these chapters is to ensure the longevity and usability of the projects that developers build to guarantee the creations’ reliability and effectiveness. Looking over the best practices of such systems, the final chapter presents current and future ideas that are relevant to established and new projects.</p>
<p>In this part, we cover the following chapters:</p>
<ul>
<li><a href="B19014_09.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, <em class="italic">Framework Maintenance</em></li>
<li><a href="B19014_10.xhtml#_idTextAnchor173"><em class="italic">Chapter 10</em></a>, <em class="italic">Best Practices</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>