<html><head></head><body>
<div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.2.1">Architecting Frontend Frameworks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we now switch focus to the frontend components of the full stack framework that we began building in </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">This is the final part of adding new features and architecting the technical design for the purposes of our </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Componium</span></strong><span class="koboSpan" id="kobo.7.1"> framework</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.8.1"> example. </span><span class="koboSpan" id="kobo.8.2">The frontend features are the most complex to design because they require a lot of domain knowledge of browsers, in-depth JavaScript, the ability to handle complex edge cases, and so on. </span><span class="koboSpan" id="kobo.8.3">We will cover a series of frontend topics that focus on enabling a full stack framework development environment. </span><span class="koboSpan" id="kobo.8.4">Here are some of the topics that we </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">will cover:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.10.1">Frontend features</span></strong><span class="koboSpan" id="kobo.11.1">: We will determine the features and goals of the frontend components for our framework. </span><span class="koboSpan" id="kobo.11.2">In addition, this new frontend infrastructure needs to interact with the existing components of the full stack framework, such as the backend API routes and the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">testing interfaces.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.13.1">Architectural design</span></strong><span class="koboSpan" id="kobo.14.1">: After learning more about the low-level interfaces of established frameworks, we will create a framework design that can offer similar features with low-level interfaces of its own. </span><span class="koboSpan" id="kobo.14.2">This includes developing a component, view, and routing architecture to server content to the </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">web browser.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.16.1">Frontend patterns</span></strong><span class="koboSpan" id="kobo.17.1">: Learning about common frontend patterns and optimizations will help us become more accustomed to working with existing frameworks and building new ones in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the future.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">It is crucial to keep in mind that we can only scratch the surface of the feature set that other frameworks offer out of the box. </span><span class="koboSpan" id="kobo.19.2">For example, we can include a client-side router with a component-based architecture, including reactivity in those components. </span><span class="koboSpan" id="kobo.19.3">Frameworks such as Vue.js, Angular, and Svelte, plus libraries such as React, required years of development to cover all edge cases and significantly expand the feature set. </span><span class="koboSpan" id="kobo.19.4">For the purposes of this chapter, we will focus on keeping things closer to the basics and build several technical parts from scratch. </span><span class="koboSpan" id="kobo.19.5">This should give you a good understanding of the underlying components of other full stack frameworks with frontend features, such as Next.js. </span><span class="koboSpan" id="kobo.19.6">For example, we will use some of the web components APIs that are built right into modern web browsers to enable a rich feature set in our </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">own framework.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Toward the end of the chapter, we shall also examine the intended workflow to understand the series of steps taken by a developer to utilize the framework interfaces to achieve specific application development goals, using our newly </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">architected features.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">The technical requirements for this chapter are very similar to those for </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.25.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">This chapter reuses the framework files that we saw in </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.28.1"> with frontend components and interfaces. </span><span class="koboSpan" id="kobo.28.2">The sample application in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">tests</span></strong><span class="koboSpan" id="kobo.30.1"> directory is also changed to showcase some of the frontend features. </span><span class="koboSpan" id="kobo.30.2">Locate the bookâ€™s repository at </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.31.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.32.1">, and continue to use the code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">chapter7</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">README.md</span></strong><span class="koboSpan" id="kobo.37.1"> instructions in the directory for available scripts. </span><span class="koboSpan" id="kobo.37.2">The sample app can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">tests/sample</span></strong><span class="koboSpan" id="kobo.39.1"> directory of the framework. </span><span class="koboSpan" id="kobo.39.2">When you start that application, it will be available on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">9000</span></strong><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">You can open it with a browser using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">http://localhost:9000/</span></strong><span class="koboSpan" id="kobo.43.1"> URL. </span><span class="koboSpan" id="kobo.43.2">While you are jumping into exploring the chapter code base, it is recommended to use the debugging tools to trace how the elements come together. </span><span class="koboSpan" id="kobo.43.3">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.44.1">Debugging</span></em><span class="koboSpan" id="kobo.45.1"> section of </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.47.1"> to configure a </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">debuggable environment.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.49.1">Defining the frontend framework</span></h1>
<p><span class="koboSpan" id="kobo.50.1">We</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.51.1"> will continue from the previous chapter by reusing the example </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Componium</span></strong><span class="koboSpan" id="kobo.53.1"> framework project. </span><span class="koboSpan" id="kobo.53.2">In </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.54.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.55.1">, we created several features that </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.56.1">allow us to interact with server-side routes, define APIs, and query a database. </span><span class="koboSpan" id="kobo.56.2">Currently, there is no way to develop frontend components to either consume those APIs or add visual interfaces using our framework. </span><span class="koboSpan" id="kobo.56.3">Without the frontend part of our framework, a developer needing to build an interactive interface, hosted using a Componium server, would need to include an external library and statically serve additional application files from </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Therefore, we will change the lack of frontend features by creating several frontend features that will allow framework users to create client interfaces. </span><span class="koboSpan" id="kobo.58.2">These frontend features will mimic some of the complex features of the existing established frontend frameworks. </span><span class="koboSpan" id="kobo.58.3">For instance, our approach to reactivity features inside the components will include the basics, utilizing the built-in APIs from </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the browsers.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">To begin this </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.61.1">process, we will identify the goals of the features we want to support. </span><span class="koboSpan" id="kobo.61.2">After that, we will follow with a sample architecture design that will make those features a reality and make our framework genuinely </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">full stack.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.63.1">Goals</span></h2>
<p><span class="koboSpan" id="kobo.64.1">The frontend framework</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.65.1"> sets three goals that will be later supported by the features that we create. </span><span class="koboSpan" id="kobo.65.2">Overall, it is a good idea to define these goals in a general manner and use them as you progress with your </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">framework project:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.67.1">Web-based interfaces</span></strong><span class="koboSpan" id="kobo.68.1">: Goal </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.69.1">number one is to empower developers to </span><em class="italic"><span class="koboSpan" id="kobo.70.1">create web-based interfaces</span></em><span class="koboSpan" id="kobo.71.1"> while maintaining cohesion with the backend/server components of the framework. </span><span class="koboSpan" id="kobo.71.2">With the frontend capabilities of the framework, developers will have the ability to write, host, and deploy interactive client interfaces. </span><span class="koboSpan" id="kobo.71.3">These interfaces will be made possible by providing a frontend framework API to create components and attach those to client-based views. </span><span class="koboSpan" id="kobo.71.4">These client-based features should also be testable and debuggable, either by the built-in Componium test interfaces or external </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">testing tools.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Enable interactivity</span></strong><span class="koboSpan" id="kobo.74.1">: A comprehensive set of APIs, both on the server-side and frontend side, will help </span><em class="italic"><span class="koboSpan" id="kobo.75.1">enable the interactivity</span></em><span class="koboSpan" id="kobo.76.1"> required by many of the framework-backed projects. </span><span class="koboSpan" id="kobo.76.2">The interactivity features need to enable developers to use familiar technologies such as HTML, CSS, and frontend JavaScript to craft components. </span><span class="koboSpan" id="kobo.76.3">The framework should also have the affordances to be able to include potential external libraries. </span><span class="koboSpan" id="kobo.76.4">For example, if someone wants to create a visualization within their Componium frontend application, then they should easily be able to include external libraries such as Three.js </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">and D3.js.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.78.1">Promote reusability</span></strong><span class="koboSpan" id="kobo.79.1">: We want to include a set of framework affordances to build complex applications. </span><span class="koboSpan" id="kobo.79.2">These could be applications with many frontend differentiated views that include a large number of nested components. </span><span class="koboSpan" id="kobo.79.3">These could also include a set of optimizations for production environments and the ability to manage large application code bases. </span><span class="koboSpan" id="kobo.79.4">Primarily, we also want to </span><em class="italic"><span class="koboSpan" id="kobo.80.1">promote the reusability</span></em><span class="koboSpan" id="kobo.81.1"> of code and guide developers to make intelligent decisions when building their applications. </span><span class="koboSpan" id="kobo.81.2">An easily extensible feature set can be beneficial to cover a lot of the potential use cases. </span><span class="koboSpan" id="kobo.81.3">If we get the architecture right, it will allow for high degrees </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">of customizability.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.83.1">Learning from</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.84.1"> already existing frameworks such as Next.js, we also want to make sure to include some of the more modern features and offer pleasing developer experiences alongside those features. </span><span class="koboSpan" id="kobo.84.2">These could include code generation affordances, similar to the ones we saw in </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.85.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">To set the framework apart from some of the other solutions, we will also set a goal to use some of the newly shipped Web APIs. </span><span class="koboSpan" id="kobo.86.3">Taking advantage of starting from scratch in our project gives us a good opportunity to evaluate the latest developments in the browser platforms, choosing the newly available APIs. </span><span class="koboSpan" id="kobo.86.4">As part of our learning goals, we will also try to contrast the difference between our newly developed framework and the established mature frameworks, such as Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">and Next.js.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">With these goals in mind, letâ€™s dive into the set of features that can back these </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">goals up.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.90.1">Features</span></h2>
<p><span class="koboSpan" id="kobo.91.1">The</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.92.1"> frontend goals defined in the previous section will help us guide the thought process behind our feature development. </span><span class="koboSpan" id="kobo.92.2">To support the established goals, let us plan out some of the technical features that developers will find useful and expect from the framework. </span><span class="koboSpan" id="kobo.92.3">Here are some substantial features that we will discuss in detail in </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">this chapter:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Serve HTML files and content</span></strong><span class="koboSpan" id="kobo.95.1">: To support the features of the interactive interfaces, we will need to add the ability to serve the generated HTML output to browser requests. </span><span class="koboSpan" id="kobo.95.2">We need to ensure that we have the capabilities to serve static content to sustain additional JavaScript code, images, media, and other types of files. </span><span class="koboSpan" id="kobo.95.3">This feature is vital to render content on the client side in a </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">web browser.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Structured application code</span></strong><span class="koboSpan" id="kobo.98.1">: We need to grant the ability to define reusable interactive JavaScript components with CSS/HTML templating and styling features. </span><span class="koboSpan" id="kobo.98.2">We will do this using a component-based architectural approach. </span><span class="koboSpan" id="kobo.98.3">The component architecture feature itself will enable the development of user interfaces. </span><span class="koboSpan" id="kobo.98.4">The structured application code that it can help produce will consist of independent and reusable bits of code that serve as the building blocks of the whole web application. </span><span class="koboSpan" id="kobo.98.5">This will support our goals of reusability and providing good application primitives, as it takes advantage of component paradigms, such as reactivity, composability, and modularity. </span><span class="koboSpan" id="kobo.98.6">The approach to this feature aims to have each component control its own state and render the interfaces based on </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the state.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.100.1">Supporting </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.101.1">the maintenance goals, the component-based approach ensures isolated testing and debuggability of the application code. </span><span class="koboSpan" id="kobo.101.2">Here, we channel some of the previous design decisions from other frameworks. </span><span class="koboSpan" id="kobo.101.3">For example, in Vue.js, components are structured with JavaScript logic, HTML templates, and the ability to style them </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">with CSS.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Composability</span></strong><span class="koboSpan" id="kobo.104.1">: Expanding on the previous point, it is important to highlight the composability of application code as an important feature of the framework we want to create. </span><span class="koboSpan" id="kobo.104.2">Defining a nested structure based on how the web browser internal DOM structure, components can then be composed together to create complex user interfaces. </span><span class="koboSpan" id="kobo.104.3">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.105.1">Components</span></em><span class="koboSpan" id="kobo.106.1"> section of </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.107.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.108.1"> for a recap of the importance of </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">this feature.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">Client-side router</span></strong><span class="koboSpan" id="kobo.111.1">: One of the core pieces of frontend framework organization that we have seen in </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.112.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.113.1"> was the router. </span><span class="koboSpan" id="kobo.113.2">The routing feature set is crucial to include in our feature set because it is responsible for navigating between complex views of our application. </span><span class="koboSpan" id="kobo.113.3">From </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.114.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.115.1">, we already have an API for server-side routes, and the frontend router will help provide the functionality to enable a fast and smooth transition between different </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">application states.</span></span></li>
<li><span class="koboSpan" id="kobo.117.1">The router</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.118.1"> will adhere to the existing concepts of web application navigation and utilize the relevant Web APIs to modify the browserâ€™s URL and history features. </span><span class="koboSpan" id="kobo.118.2">The inclusion of the router will also be beneficial in creating a more logically </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">organized code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.120.1">Interaction with APIs</span></strong><span class="koboSpan" id="kobo.121.1">: The ability to interact with backend APIs is another key feature. </span><span class="koboSpan" id="kobo.121.2">The server-side part of Componium has different ways to define endpoints, including </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.122.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">GraphQL</span></strong><span class="koboSpan" id="kobo.124.1"> endpoints. </span><span class="koboSpan" id="kobo.124.2">The frontend code should make it easier to make requests to these endpoints and handle the data. </span><span class="koboSpan" id="kobo.124.3">In the case of frameworks such as Angular, the project provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">HttpClient</span></strong><span class="koboSpan" id="kobo.126.1"> helper module (</span><a href="http://angular.io/guide/understanding-communicating-with-http"><span class="koboSpan" id="kobo.127.1">angular.io/guide/understanding-communicating-with-http</span></a><span class="koboSpan" id="kobo.128.1">) to communicate with suitable backend services. </span><span class="koboSpan" id="kobo.128.2">This would be an </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.129.1">excellent reinforcing feature for our sample project, especially if combined with some of the specific </span><em class="italic"><span class="koboSpan" id="kobo.130.1">Componium server</span></em><span class="koboSpan" id="kobo.131.1">-defined routes. </span><span class="koboSpan" id="kobo.131.2">For example, to help enhance the developer experience, we can pre-generate some of the data fetching calls for the known endpoints and create dynamic interfaces around those, thus saving time for developers building with </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">our framework.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.133.1">Server-side rendering (SSR)</span></strong><span class="koboSpan" id="kobo.134.1">: We mentioned SSR features in other framework examples throughout the book. </span><span class="koboSpan" id="kobo.134.2">We will include these features in our example framework as well. </span><span class="koboSpan" id="kobo.134.3">The SSR methods will render the components on the server side to help improve the rendering performance of the applications. </span><span class="koboSpan" id="kobo.134.4">Given our full control over the developer experience of the full stack framework in this particular case, developing this type of functionality is easier for us. </span><span class="koboSpan" id="kobo.134.5">Besides the performance improvements, SSR is beneficial for search engine optimization purposes and general page </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">loading time.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.136.1">The internals of SSR include close collaboration between components pre-rendered on the backend and later hydrated by the frontend code. </span><span class="koboSpan" id="kobo.136.2">The backend routes should also be able to inject the state of components into the pre-rendered elements. </span><span class="koboSpan" id="kobo.136.3">The state can be static data or information fetched from external sources, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">a database.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Production optimizations</span></strong><span class="koboSpan" id="kobo.139.1">: As part of the commitment to empowering developers, the framework will also feature some optimization steps for applications running in production environments. </span><span class="koboSpan" id="kobo.139.2">This means including additional </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.140.1">internal tooling that performs optimizations, such as minification, behind the scenes. </span><span class="koboSpan" id="kobo.140.2">These kinds of optimizations are also much easier to integrate within our framework because we have control of the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">server tooling.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.142.1">Besides code minification, we can also look into advanced JavaScript optimization techniques such as tree-shaking and code-splitting. </span><span class="koboSpan" id="kobo.142.2">Supporting static file handling, we can potentially optimize other media such as images. </span><span class="koboSpan" id="kobo.142.3">Generally, as the framework continues, we want to consistently work on such optimization improvements because it benefits all the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">frameworkâ€™s users.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.144.1">The preceding list is a selected set of functionalities that should make the frontend feature-rich, give us a good learning opportunity, and also cover realistic </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">The following </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.147.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.148.1">.1</span></em><span class="koboSpan" id="kobo.149.1"> provides a summary of how the listed features interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">each other:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.151.1"><img alt="Figure 8.1: The features summarized" src="image/Figure_8.1_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.152.1">Figure 8.1: The features summarized</span></p>
<p><span class="koboSpan" id="kobo.153.1">The</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.154.1"> existing server-side code will be able to serve static files that can be consumed by the frontend. </span><span class="koboSpan" id="kobo.154.2">At the same time, the server process is capable of importing and accessing some of the components to render them on the server side. </span><span class="koboSpan" id="kobo.154.3">Finally, the backend has a definition of client routes; these are the frontend endpoints that are classified as accessible by a browser to be rendered in </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">On the frontend side, we have the </span><em class="italic"><span class="koboSpan" id="kobo.157.1">API interaction</span></em><span class="koboSpan" id="kobo.158.1"> features that communicate with the server or make requests to external APIs that are hosted on external services. </span><span class="koboSpan" id="kobo.158.2">Simultaneously, a client-side router tightly works with the component architecture to enable the user interface experience in the browser. </span><span class="koboSpan" id="kobo.158.3">Finally, we have a set of frontend optimizations that cover all of the frontend surfaces, ensuring the most optimized experience when deploying and running applications in </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">production environments.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">With these features in mind, let us proceed to the architecture step, where we can explore the technical and organizational concepts that make these </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">features possible.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.162.1">Architecture</span></h1>
<p><span class="koboSpan" id="kobo.163.1">With the</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.164.1"> required features outlined and documented, let us extend the existing architecture from </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.165.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.166.1">. </span><span class="koboSpan" id="kobo.166.2">The changes will be adding new functionality to the framework architecture, concentrating on enabling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">ClientView</span></strong><span class="koboSpan" id="kobo.168.1"> abstractions and functionality, which will drive the feature experience behind the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">frontend changes.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">We already have the capability to create server API endpoints. </span><span class="koboSpan" id="kobo.170.2">The general implementation of the architecture of the features will consist of introducing several new interfaces to the server part of the framework. </span><span class="koboSpan" id="kobo.170.3">The newly added frontend features will be situated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">frontend</span></strong><span class="koboSpan" id="kobo.172.1"> directory of the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">framework project.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.174.1"><img alt="Figure 8.2: Componium frontend components" src="image/Figure_8.2_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.175.1">Figure 8.2: Componium frontend components</span></p>
<p><span class="koboSpan" id="kobo.176.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.177.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.178.1">.2</span></em><span class="koboSpan" id="kobo.179.1">, we </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.180.1">outline an incoming request to the server powered by the Componium server framework. </span><span class="koboSpan" id="kobo.180.2">Specifically, this request is expected to respond with an HTML page to provide interactivity features. </span><span class="koboSpan" id="kobo.180.3">This is unlike the API requests from </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.181.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.182.1">, where we would receive JSON or GraphQL responses with data. </span><span class="koboSpan" id="kobo.182.2">The request handler can still process incoming request objects, such that it can access properties of the request, such as the query parameters. </span><span class="koboSpan" id="kobo.182.3">It can also tweak any properties of the response object. </span><span class="koboSpan" id="kobo.182.4">In </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.184.1">, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">server.addRoute(...)</span></strong><span class="koboSpan" id="kobo.186.1"> to add new routes. </span><span class="koboSpan" id="kobo.186.2">To add route handlers that provide the functionality, we will use a similarly structured </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">server.addClientView(...)</span></strong><span class="koboSpan" id="kobo.188.1"> method that will have a similar API, but a totally different behavior. </span><span class="koboSpan" id="kobo.188.2">This new method is where the </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">client view</span></strong><span class="koboSpan" id="kobo.190.1"> functionality from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.191.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.192.1">.2</span></em><span class="koboSpan" id="kobo.193.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">take place.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">In the Componium frontend component design, a client view can have a singular view and many components used within it. </span><span class="koboSpan" id="kobo.195.2">The concept of the client view is a server-side definition, while</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.196.1"> the concept of views is shared across both the server and the client side. </span><span class="koboSpan" id="kobo.196.2">Once the client view is defined, it assembles all the imported components and the View together and sends a response back to </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Besides the </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.199.1">client view interaction, the server can now also define and access static file directories. </span><span class="koboSpan" id="kobo.199.2">These static files can be directly accessed by the browser, and the whole directory is exposed to the web server. </span><span class="koboSpan" id="kobo.199.3">These static files are also usable by the Client Views to import additional resources into the Client Views, such as any media files (images, fonts, styles, etc.) or additional JavaScript components. </span><span class="koboSpan" id="kobo.199.4">The ease of access to static files simplifies how a frontend framework can include external media and other useful entities that can be included within the </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">In the next section, we will get a detailed look into how Client Views become the gateway for the frontend features and files, allowing us to create multiple endpoints serving HTML, CSS, and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">JavaScript code.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.203.1">Entry points</span></h2>
<p><span class="koboSpan" id="kobo.204.1">To </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.205.1">allow flexibility when creating multiple frontend Client Views, our framework provides a way to define multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">client endpoints:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
server.addClientView("/", "frameworks", {
Â Â title: "Frameworks",
Â Â // â€¦
});</span></pre>
<p><span class="koboSpan" id="kobo.208.1">The preceding code is an example of routing the root path of our server to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">frameworks</span></strong><span class="koboSpan" id="kobo.210.1"> view. </span><span class="koboSpan" id="kobo.210.2">Developers can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">frameworks.js</span></strong><span class="koboSpan" id="kobo.212.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">views</span></strong><span class="koboSpan" id="kobo.214.1"> directory to map this view by the defined name. </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">.addClientView(...)</span></strong><span class="koboSpan" id="kobo.216.1"> can be configured multiple times, with as many views attached to different route handlers. </span><span class="koboSpan" id="kobo.216.2">The contents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">frameworks.js</span></strong><span class="koboSpan" id="kobo.218.1"> have a familiar structure to the route handlers from </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.219.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.220.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
export default function frameworks(request, response) {
Â Â return `&lt;p&gt;Welcome!&lt;/p&gt; `;
}</span></pre>
<p><span class="koboSpan" id="kobo.222.1">The preceding </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.223.1">code can be as simple as returning a paragraph tag. </span><span class="koboSpan" id="kobo.223.2">You can find other examples of more involved views in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">tests/sample/views/</span></strong><span class="koboSpan" id="kobo.225.1"> directory. </span><span class="koboSpan" id="kobo.225.2">The view handler has access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Request</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">Response</span></strong><span class="koboSpan" id="kobo.229.1"> objects of the route to tweak the behavior of the route or fetch additional data. </span><span class="koboSpan" id="kobo.229.2">We also have access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">componium</span></strong><span class="koboSpan" id="kobo.231.1"> variable here to access the interfaces of the framework. </span><span class="koboSpan" id="kobo.231.2">For simplicity, we will use JavaScript template literals in more complex templates. </span><span class="koboSpan" id="kobo.231.3">The framework takes care of rendering the desired HTML structures, and it also wraps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">&lt;p&gt;</span></strong><span class="koboSpan" id="kobo.233.1"> tag in the preceding code in a valid </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">HTML document.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">The other important entry point for our frontend files is static file configuration. </span><span class="koboSpan" id="kobo.235.2">To be able to resolve other types of media, the framework provides a way to mark certain directories of the application project as an endpoint that serves </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">static files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
server.addStaticDirectory("/images", "img"));</span></pre>
<p><span class="koboSpan" id="kobo.238.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">.addStaticDirectory(...)</span></strong><span class="koboSpan" id="kobo.240.1"> method maps the server route for </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">/images</span></strong><span class="koboSpan" id="kobo.242.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">img</span></strong><span class="koboSpan" id="kobo.244.1"> directory in the application project. </span><span class="koboSpan" id="kobo.244.2">This relies on the similar properties of the backend express server that we worked with in </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.245.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">This new static directory also works in custom routers, which are created </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">server.createRouter(...)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">We now have a way to process and render basic views and create as many of them as we want. </span><span class="koboSpan" id="kobo.250.2">We now need to enable the component-based architecture. </span><span class="koboSpan" id="kobo.250.3">This is what will allow us to produce more complex </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">interactive components.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.252.1">Reactivity</span></h2>
<p><span class="koboSpan" id="kobo.253.1">To achieve </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.254.1">the dynamic interface features of our frontend framework, we need to learn more about the concepts of reactivity and reactive components. </span><span class="koboSpan" id="kobo.254.2">The reactivity concepts in application programming direct the user interface to update and respond to underlying data or state changes dynamically. </span><span class="koboSpan" id="kobo.254.3">In the context of JavaScript, especially in the frontend systems, we use custom-developed primitives in combination with browser APIs to achieve performant user interface reactivity. </span><span class="koboSpan" id="kobo.254.4">The reactivity features enable a seamless experience for web application consumers by automatically updating the interface whenever relevant underlying data changes. </span><span class="koboSpan" id="kobo.254.5">Similar to other programming environments, in the JavaScript world, developers rely on frameworks and helper libraries to enable reactivity for components in their applications. </span><span class="koboSpan" id="kobo.254.6">In fact, this reliance on external tooling in JavaScript is much stronger than in other languages. </span><span class="koboSpan" id="kobo.254.7">This is mainly due to the cross-browser and cross-engine nature of web page and web </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">application development.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">The</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.257.1"> reactive programming paradigm has become very fitting in the web development environment, due to the asynchronous nature of JavaScript. </span><span class="koboSpan" id="kobo.257.2">Other contributing factors for the reactive paradigm fit included application requirements for real-time updates, complex interactivity, and making it easier to manage the state of applications. </span><span class="koboSpan" id="kobo.257.3">The user interfaces have become much more complex. </span><span class="koboSpan" id="kobo.257.4">These days, the expectations of web applications require frontend systems to be dynamic, consume real-time data, and be instantly responsive to user actions. </span><span class="koboSpan" id="kobo.257.5">Also, the existing structure and </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.258.1">abstractions around a web browserâ€™s </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.260.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.261.1">DOM</span></strong><span class="koboSpan" id="kobo.262.1">) have compelled solutions to be based on manipulating a nested node tree of page elements. </span><span class="koboSpan" id="kobo.262.2">The reactive changes in the interface utilize the diffing algorithms to update the changed nodes of a </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">component tree.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Reactivity requires data binding, which is a connection between data and the elements of applications. </span><span class="koboSpan" id="kobo.264.2">In the web development world, the data would be provided by JavaScript interfaces, most likely dynamically loaded from some API endpoint. </span><span class="koboSpan" id="kobo.264.3">The elements would be the </span><em class="italic"><span class="koboSpan" id="kobo.265.1">HTML/DOM</span></em><span class="koboSpan" id="kobo.266.1"> structures in the browser client. </span><span class="koboSpan" id="kobo.266.2">The corresponding browser elements are automatically updated to reflect the changes when the underlying data updates. </span><span class="koboSpan" id="kobo.266.3">In </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.267.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.268.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.269.1">Framework building blocks</span></em><span class="koboSpan" id="kobo.270.1"> section, we highlighted the possible ways in which data binding can occur within these reactive components. </span><span class="koboSpan" id="kobo.270.2">We also saw examples of frameworks using one-way or two-way binding. </span><span class="koboSpan" id="kobo.270.3">The flow largely depends on architectural decisions, either allowing the elements to update when data changes or also allowing the elements to update the underlying data. </span><span class="koboSpan" id="kobo.270.4">Popular frameworks such as Vue.js and anything that includes React use an implementation of a </span><em class="italic"><span class="koboSpan" id="kobo.271.1">virtual DOM</span></em><span class="koboSpan" id="kobo.272.1"> tree to render an applicationâ€™s state as the data changes. </span><span class="koboSpan" id="kobo.272.2">However, there are also examples where projects, such as those involving Svelte and Angular, use the real DOM or </span><em class="italic"><span class="koboSpan" id="kobo.273.1">shadow DOM</span></em><span class="koboSpan" id="kobo.274.1"> features to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">similar functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Similar to other frontend projects, we will introduce the concept of reactive components into our framework. </span><span class="koboSpan" id="kobo.276.2">These components will allow us to encapsulate HTML elements and application logic alongside them. </span><span class="koboSpan" id="kobo.276.3">The frontend </span><em class="italic"><span class="koboSpan" id="kobo.277.1">Componium</span></em><span class="koboSpan" id="kobo.278.1"> components will maintain their internal state and respond to data and interactions. </span><span class="koboSpan" id="kobo.278.2">To keep things simpler and without diving deeper into the internals of the existing frontend frameworks, we can build an example of basic reactivity concepts using a combination of Web Components and other more modern Web APIs. </span><span class="koboSpan" id="kobo.278.3">A practical overview of the component architecture </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.279.1">will provide a good learning opportunity to understand the built-in browser primitives. </span><span class="koboSpan" id="kobo.279.2">It will also offer a good comparison and understanding of the complex problems that the existing frameworks solve </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">for us:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
class ReactiveComponent extends HTMLElement {
Â Â constructor() {
Â Â Â Â super();
Â Â Â Â this.state = this.reactive(this.data());
Â Â Â Â this.attachShadow({ mode: "open" });
Â Â }
Â Â reactive(data) {
Â Â Â Â return new Proxy(data, {
Â Â Â Â Â Â set: (target, key, value) =&gt; {
Â Â Â Â Â Â Â Â target[key] = value;
Â Â Â Â Â Â Â Â this.update();
Â Â Â Â Â Â Â Â return true;
Â Â Â Â Â Â },
Â Â Â Â });
Â Â }
Â Â callback() { this.render(); this.update(); }
Â Â render() { this.shadowRoot.innerHTML = this.template(); }
Â Â // methods that child components will override
Â Â update() {}
Â Â data() { return {}; }
Â Â template() { return ""; }
}</span></pre>
<p><span class="koboSpan" id="kobo.282.1">The</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.283.1"> preceding code is our newly defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">ReactiveComponent</span></strong><span class="koboSpan" id="kobo.285.1">; it has been compacted to fit in better in this chapter. </span><span class="koboSpan" id="kobo.285.2">The class starts off extending </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.287.1">. </span><span class="koboSpan" id="kobo.287.2">This interface will help us represent HTML elements and create our own web components. </span><span class="koboSpan" id="kobo.287.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">constructor</span></strong><span class="koboSpan" id="kobo.289.1"> method, we have a declaration for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">state</span></strong><span class="koboSpan" id="kobo.291.1"> property, which will keep track of the state of the component. </span><span class="koboSpan" id="kobo.291.2">Another important constructor call is </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">.attachShadow()</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">This call attaches a Shadow DOM to the custom element and provides a scoped environment for the encapsulated CSS and </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">JavaScript instructions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.295.1">Additional reading</span></p>
<p class="callout"><span class="koboSpan" id="kobo.296.1">For a detailed low-level explanation of how</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.297.1"> Shadow DOM is structured, check out the MDN page </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">at </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM"><span class="No-Break"><span class="koboSpan" id="kobo.299.1">developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.300.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">reactive</span></strong><span class="koboSpan" id="kobo.303.1"> method, we configure a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">Proxy</span></strong><span class="koboSpan" id="kobo.305.1"> object, which is another built-in Web API with properties that can help us make reactive changes to the state of our components. </span><span class="koboSpan" id="kobo.305.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Proxy</span></strong><span class="koboSpan" id="kobo.307.1"> methods take an object and return a new object that serves as a proxy for the original definition. </span><span class="koboSpan" id="kobo.307.2">The proxy behavior helps trigger updates and re-renders of a component when the object </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">is updated.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.309.1">Additional reading</span></p>
<p class="callout"><span class="koboSpan" id="kobo.310.1">For details </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.311.1">on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">Proxy</span></strong><span class="koboSpan" id="kobo.313.1"> interface, check out the detailed article at </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">MDN: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy "><span class="No-Break"><span class="koboSpan" id="kobo.315.1">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span></span></a></p>
<p><span class="koboSpan" id="kobo.316.1">The setter operation and the update methods will be invoked when the state changes. </span><span class="koboSpan" id="kobo.316.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">update()</span></strong><span class="koboSpan" id="kobo.318.1"> method is overridden in the components that inherit this </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">ReactiveComponent</span></strong><span class="koboSpan" id="kobo.320.1"> class. </span><span class="koboSpan" id="kobo.320.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">ReactiveComponent</span></strong><span class="koboSpan" id="kobo.322.1">, we can build a simple set of example components. </span><span class="koboSpan" id="kobo.322.2">This structure will bind the data from the component state into the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">rendered templates.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 8.3: A basic components example" src="image/Figure_8.3_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 8.3: A basic components example</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.326.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.327.1">.3</span></em><span class="koboSpan" id="kobo.328.1"> presents an example view of two components in action; one is the year tracker and the </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.329.1">other is the month tracker. </span><span class="koboSpan" id="kobo.329.2">Both components have the option to increment the values of the appropriate dates. </span><span class="koboSpan" id="kobo.329.3">You can find the code for this working example in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">tests/basic-components/index.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
&lt;body&gt;
Â Â &lt;h1&gt;Basic Components&lt;/h1&gt;
Â Â &lt;year-component&gt;&lt;/year-component&gt;
&lt;/body&gt;</span></pre>
<p><span class="koboSpan" id="kobo.333.1">The source of the view follows; it just includes a newly defined component by its name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">year-component</span></strong><span class="koboSpan" id="kobo.335.1">, wrapped in regular HTML tags. </span><span class="koboSpan" id="kobo.335.2">This was achieved by registering the custom element using the built-in Web Components interface â€“ </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">customElements.define("year-component", YearComponent);</span></strong><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">year-component</span></strong><span class="koboSpan" id="kobo.339.1"> component extends the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ReactiveComponent</span></strong><span class="koboSpan" id="kobo.341.1"> class and overrides the empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">update</span></strong><span class="koboSpan" id="kobo.343.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">template</span></strong><span class="koboSpan" id="kobo.345.1"> methods, </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
template() {
Â Â Â Â return `
Â Â Â Â Â Â &lt;button id="addYears"&gt;Add Years&lt;/button&gt;
Â Â Â Â Â Â &lt;div id="yearCount"&gt;Year: 0&lt;/div&gt;
Â Â Â Â Â Â &lt;month-component&gt;&lt;/month-component&gt;
Â Â Â Â `;
Â Â }
Â Â connectedCallback() {
Â Â Â Â super.connectedCallback();
Â Â Â Â this.shadowRoot.querySelector
Â Â Â Â Â Â ("#addYears").addEventListener("click", () =&gt; {
Â Â Â Â Â Â this.state.yearCount++;
Â Â Â Â });
Â Â }
Â Â update() {
Â Â Â Â this.shadowRoot.querySelector(
Â Â Â Â Â Â "#yearCount"
Â Â Â Â ).textContent = `Year: ${this.state.yearCount}`;</span></pre>
<p><span class="koboSpan" id="kobo.348.1">The </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.349.1">methods listed in the preceding code, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">update()</span></strong><span class="koboSpan" id="kobo.351.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">template()</span></strong><span class="koboSpan" id="kobo.353.1">, render the data relevant to the component and define the template returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">year-component</span></strong><span class="koboSpan" id="kobo.355.1"> component. </span><span class="koboSpan" id="kobo.355.2">We also have event handlers that change and update the year, using access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">this.state</span></strong><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">Also, note that to access the Shadow DOM properties of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Year</span></strong><span class="koboSpan" id="kobo.359.1"> component, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">this.shadowRoot.querySelector</span></strong><span class="koboSpan" id="kobo.361.1">. </span><span class="koboSpan" id="kobo.361.2">The template defined in the component includes </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">month-component</span></strong><span class="koboSpan" id="kobo.363.1">, which is a nested component. </span><span class="koboSpan" id="kobo.363.2">It has a similar setup to the extended class </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">ReactiveComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">This component configuration, using the Web Components APIs and other affordances from the browser APIs, is a good starting point for the framework. </span><span class="koboSpan" id="kobo.367.2">We can use these patterns to achieve similar functionality in other frameworks, such as Vue.js, and frameworks that use React as their underlying library to structure their components. </span><span class="koboSpan" id="kobo.367.3">The interface we have has reactivity properties, the ability to compose components simultaneously, and the basics </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">of templating.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">In the following section, we will take this a bit further and utilize an external Web Component helper library to build upon </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">this pattern.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.371.1">Improving components</span></h2>
<p><span class="koboSpan" id="kobo.372.1">In the </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.373.1">reactivity part of the architecture, we have described a pattern of using Web Components comprised of other techniques to achieve the desired feature set. </span><span class="koboSpan" id="kobo.373.2">To enhance this further, we will bring in </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.374.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">Lit library</span></strong><span class="koboSpan" id="kobo.376.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">lit.dev</span></strong><span class="koboSpan" id="kobo.378.1">), which will help make our job of managing the components much more straightforward, and our framework can be dependent on it. </span><span class="koboSpan" id="kobo.378.2">We shall use the same approach of abstractions and utilize the interfaces of this library to create the component features of </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">our framework.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.380.1">About the Lit library</span></p>
<p class="callout"><span class="koboSpan" id="kobo.381.1">The Lit open source library has been around for more than six years, and its goal is to simplify and abstract away some of the verbose tasks that deal with Web Components. </span><span class="koboSpan" id="kobo.381.2">At its core, it provides reactive state features, scoped CSS styling, templating, and a variety of advanced features to compose and work with frontend components. </span><span class="koboSpan" id="kobo.381.3">It works with both JavaScript and TypeScript languages and comes with a large variety of packages that extend its functionality. </span><span class="koboSpan" id="kobo.381.4">For example, Lit has additional tools to enable localization, animate frontend elements, and also integrate with </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">React components.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.383.1">The library uses </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.384.1">the standard component life cycle, in addition to its own component life cycle methods to simplify certain operations, such as DOM reactivity. </span><span class="koboSpan" id="kobo.384.2">You can find the source of the project at </span><a href="https://github.com/lit/lit"><span class="koboSpan" id="kobo.385.1">github.com/lit/lit</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.386.1">and </span></span><a href="https://lit.dev/docs"><span class="No-Break"><span class="koboSpan" id="kobo.387.1">lit.dev/docs</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.388.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">To draw a comparison with the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">ReactiveComponent</span></strong><span class="koboSpan" id="kobo.391.1"> interfaces, letâ€™s take a look at how similar the code would be to the basic components if we used the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">Lit library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
import {html, css, LitElement} from 'lit';
export class YearComponent extends LitElement {
Â Â Â Â static styles = css`p { color: green }`;
Â Â Â Â static properties = {
Â Â Â Â Â Â Â Â year: {type: Number},
Â Â Â Â };
Â Â Â Â constructor() {
Â Â Â Â Â Â Â Â super();
Â Â Â Â Â Â Â Â this.year = 2024;
Â Â Â Â }
Â Â Â Â render() {
Â Â Â Â Â Â Â Â return html`&lt;button id="addYears"&gt;Add Years
Â Â Â Â Â Â Â Â Â Â &lt;/button&gt;
Â Â Â Â Â Â &lt;div id="yearCount"&gt;Year: ${this.year}&lt;/div&gt;`;
}</span></pre>
<p><span class="koboSpan" id="kobo.394.1">The </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.395.1">preceding code imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">LitElement</span></strong><span class="koboSpan" id="kobo.397.1"> class that we can extend. </span><span class="koboSpan" id="kobo.397.2">This new code block result looks very familiar to the code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">year-component</span></strong><span class="koboSpan" id="kobo.399.1"> that we saw in the </span><em class="italic"><span class="koboSpan" id="kobo.400.1">Reactivity</span></em><span class="koboSpan" id="kobo.401.1"> section. </span><span class="koboSpan" id="kobo.401.2">However, there are some additional improvements we have in this </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">component definition.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Letâ€™s explore a few </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">of them:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.405.1">First of all, we have a CSS helper interface, which allows us to declare the style of our component using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">static </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">styles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> variable.</span></span></li>
<li><span class="koboSpan" id="kobo.409.1">Second, the way we declare the state of the component has also changed â€“ we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">static properties</span></strong><span class="koboSpan" id="kobo.411.1"> object with some extra definitions of the properties. </span><span class="koboSpan" id="kobo.411.2">These properties are used in a similar way in </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">the template.</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">This brings us to the third point â€“ the templating is also a bit different. </span><span class="koboSpan" id="kobo.413.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">lit-html</span></strong><span class="koboSpan" id="kobo.415.1"> helpers to enable more advanced templating features and help us work with HTML. </span><span class="koboSpan" id="kobo.415.2">This helper allows us to create templating directives, tweak the rendering methods, and </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">so on.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.417.1">Additional reading</span></p>
<p class="callout"><span class="koboSpan" id="kobo.418.1">Detailed documentation of all the templating features can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">at </span></span><a href="https://lit.dev/docs/v3/templates/expressions"><span class="No-Break"><span class="koboSpan" id="kobo.420.1">lit.dev/docs/v3/templates/expressions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.421.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">For the purposes of our sample framework, we will define our own </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">ComponiumComponent</span></strong><span class="koboSpan" id="kobo.424.1"> class. </span><span class="koboSpan" id="kobo.424.2">This class will be available to the developers to create rich components, combining what we have learned from the </span><em class="italic"><span class="koboSpan" id="kobo.425.1">Reactivity</span></em><span class="koboSpan" id="kobo.426.1"> section and the Lit library. </span><span class="koboSpan" id="kobo.426.2">We</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.427.1"> can also rely on the rich functionalities of Lit templating to render the results. </span><span class="koboSpan" id="kobo.427.2">To enable this, we will load the Lit library alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">componium.js</span></strong><span class="koboSpan" id="kobo.429.1"> framework file in </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">ClientViews</span></strong><span class="koboSpan" id="kobo.431.1">. </span><span class="koboSpan" id="kobo.431.2">This will expose the component interface to developer-defined components. </span><span class="koboSpan" id="kobo.431.3">To start using those interfaces, developers can import them using the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">ES6 syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
import { css, html, ComponiumComponent } from "componium";</span></pre>
<p><span class="koboSpan" id="kobo.434.1">The class to extend is provided, alongside the CSS and HTML helpers to help construct the components. </span><span class="koboSpan" id="kobo.434.2">For example, if our component has interactive buttons, it can use the following Lit syntax to declare </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">event handlers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
html`&lt;button @click="${this._click}"&gt;click&lt;/button&gt;`;</span></pre>
<p><span class="koboSpan" id="kobo.437.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">_click</span></strong><span class="koboSpan" id="kobo.439.1"> event handler is a method defined on the class that extends from </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">ComponiumComponent</span></strong><span class="koboSpan" id="kobo.441.1">. </span><span class="koboSpan" id="kobo.441.2">If these components require any static files, they can request them directly by fetching them from the static routes declared by the Componium server. </span><span class="koboSpan" id="kobo.441.3">However, we can still take this one step further and use Lit and the mix of our frameworkâ€™s interfaces to enable the complex features of SSR. </span><span class="koboSpan" id="kobo.441.4">There will be more on the concept of utilizing the existing components from a server in the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">next section.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.443.1">SSR</span></h2>
<p><span class="koboSpan" id="kobo.444.1">We</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.445.1"> learned about the features and benefits of SSR when we planned the frontend interfaces of Componium. </span><span class="koboSpan" id="kobo.445.2">On a technical level, SSR requires several parts of our framework to work really well. </span><span class="koboSpan" id="kobo.445.3">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">of them:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.447.1">The component architecture needs to support different rendering capabilities. </span><span class="koboSpan" id="kobo.447.2">This includes the ability to pre-render the components as HTML that can be transmitted over the wire to </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">the frontend.</span></span></li>
<li><span class="koboSpan" id="kobo.449.1">Components need to be able to run consistently on both the server and </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the browser.</span></span></li>
<li><span class="koboSpan" id="kobo.451.1">The server-rendered components should have the ability to fetch data in both the client and server environments. </span><span class="koboSpan" id="kobo.451.2">Depending on the environment, components should have a similar approach to how data is requested </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">and processed.</span></span></li>
<li><span class="koboSpan" id="kobo.453.1">We need a server that can structure and render the components, including attaching a state and data to </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">these components.</span></span></li>
<li><span class="koboSpan" id="kobo.455.1">The frontend side should be able to take the server-side state of the components and later hydrate them. </span><span class="koboSpan" id="kobo.455.2">It should be able to attach the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">required events.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.457.1">Luckily, with </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.458.1">our framework and the Lib library, we have a lot of these requirements covered and can develop the SSR support in our framework. </span><span class="koboSpan" id="kobo.458.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">@lit-labs/ssr</span></strong><span class="koboSpan" id="kobo.460.1"> package, we can define a server-side render in conjunction with our Client View abstractions. </span><span class="koboSpan" id="kobo.460.2">The modules for these features can be found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">packages/frontend/client-view.js</span></strong><span class="koboSpan" id="kobo.462.1">. </span><span class="koboSpan" id="kobo.462.2">To have a flexible feature set in our framework, we want developers to use both client-side-only components and a combination of </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">server-rendered components.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">To enable the SSR capabilities, the framework has a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Renderer</span></strong><span class="koboSpan" id="kobo.466.1"> class, which has the job of consolidating all the required framework code and developer-defined components. </span><span class="koboSpan" id="kobo.466.2">It does so by responding to client-side requests with a unified template of a valid HTML document and by injecting code from the application directory. </span><span class="koboSpan" id="kobo.466.3">To render these structures, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">html</span></strong><span class="koboSpan" id="kobo.468.1"> helpers from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">ssr</span></strong><span class="koboSpan" id="kobo.470.1"> library. </span><span class="koboSpan" id="kobo.470.2">To understand the capabilities of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">ssr</span></strong><span class="koboSpan" id="kobo.472.1"> package, check out the comprehensive documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">lit.dev/docs/ssr/overview</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">These capabilities work in tandem with the Componium server rendering methods to output the resulting HTML to the client. </span><span class="koboSpan" id="kobo.476.2">Once the HTML document has been fully loaded in the browser, then the hydration process begins. </span><span class="koboSpan" id="kobo.476.3">The framework files load the required supporting files that will help attach the event handlers to our components and make </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">them interactive.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">We shall examine the detailed usage of the server-side rendering features in the upcoming </span><em class="italic"><span class="koboSpan" id="kobo.479.1">Using the framework</span></em><span class="koboSpan" id="kobo.480.1"> section. </span><span class="koboSpan" id="kobo.480.2">Meanwhile, there are a few more architectural features left to cover before we can start using all of </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">them together.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.482.1">Client router</span></h2>
<p><span class="koboSpan" id="kobo.483.1">At the</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.484.1"> framework planning stage, the router was highlighted as an essential piece of frontend infrastructure that allows an interface to transition between significant sections of an application. </span><span class="koboSpan" id="kobo.484.2">The routing implementations are very similar across many frontend frameworks. </span><span class="koboSpan" id="kobo.484.3">However, if you</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.485.1"> are really passionate about the routing features, the </span><em class="italic"><span class="koboSpan" id="kobo.486.1">React Router</span></em><span class="koboSpan" id="kobo.487.1"> project (</span><a href="https://reactrouter.com"><span class="koboSpan" id="kobo.488.1">reactrouter.com</span></a><span class="koboSpan" id="kobo.489.1">) is a great project to learn from in terms of educating yourself about good routing abstractions, the potential pitfalls, and routing </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">edge cases.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.491.1"><img alt="Figure 8.4: A transition between the initial page (left) and the newly routed page (right)" src="image/Figure_8.4_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">Figure 8.4: A transition between the initial page (left) and the newly routed page (right)</span></p>
<p><span class="koboSpan" id="kobo.493.1">To enable the routing functionality in our framework, we will introduce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ComponiumRouter</span></strong><span class="koboSpan" id="kobo.495.1"> class. </span><span class="koboSpan" id="kobo.495.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.496.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.497.1">.4</span></em><span class="koboSpan" id="kobo.498.1">, we can see the routing transition between the initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">/client-render</span></strong><span class="koboSpan" id="kobo.500.1"> page (</span><em class="italic"><span class="koboSpan" id="kobo.501.1">left</span></em><span class="koboSpan" id="kobo.502.1">) and the newly routed page, </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">/page</span></strong><span class="koboSpan" id="kobo.504.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.505.1">right</span></em><span class="koboSpan" id="kobo.506.1">). </span><span class="koboSpan" id="kobo.506.2">The routing happens when you click on the </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">Navigate &gt;&gt;</span></strong><span class="koboSpan" id="kobo.508.1"> button in the component. </span><span class="koboSpan" id="kobo.508.2">The routing interface can be initialized within our components and allow an application to navigate between the nested component templates. </span><span class="koboSpan" id="kobo.508.3">The public developer API for the router is </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">this.router = new ComponiumRouter("client-render", </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">routes, this.shadowRoot);</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">The router gets an identifier (</span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">client-render</span></strong><span class="koboSpan" id="kobo.514.1">), a series of routes with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">routes</span></strong><span class="koboSpan" id="kobo.516.1"> object, and a root element (in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">this.shadowRoot</span></strong><span class="koboSpan" id="kobo.518.1"> object) that will be used to render the routed templates. </span><span class="koboSpan" id="kobo.518.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">routes</span></strong><span class="koboSpan" id="kobo.520.1"> object is defined as an array of objects. </span><span class="koboSpan" id="kobo.520.2">For example, a simple route example for </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.521.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.522.1">.4</span></em><span class="koboSpan" id="kobo.523.1"> would look </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
const routes = [{
Â Â Â Â path: "/client-render",
Â Â Â Â template: "&lt;nested-component&gt;&lt;/nested-component&gt;",
Â Â },
Â Â {
Â Â Â Â path: "/page",
Â Â Â Â template: "&lt;navigated-component&gt;
Â Â Â Â Â Â &lt;/navigated-component&gt;",
Â Â },];</span></pre>
<p><span class="koboSpan" id="kobo.526.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">/client-render</span></strong><span class="koboSpan" id="kobo.528.1"> route is one of our entry points that has Client View type and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">/page</span></strong><span class="koboSpan" id="kobo.530.1"> route</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.531.1"> is a view we can navigate to. </span><span class="koboSpan" id="kobo.531.2">The router can support a richer feature set by accepting more complex templating structures in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">template</span></strong><span class="koboSpan" id="kobo.533.1"> property. </span><span class="koboSpan" id="kobo.533.2">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">html</span></strong><span class="koboSpan" id="kobo.535.1"> helper from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">Componium/Lit</span></strong><span class="koboSpan" id="kobo.537.1"> modules to produce more extensive template objects in the </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">routing definition.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">To navigate between routes, we will rely on more built-in Web APIs in browsers. </span><span class="koboSpan" id="kobo.539.2">For instance, the components call out to </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">history.pushState(...)</span></strong><span class="koboSpan" id="kobo.541.1"> when views need to be changed. </span><span class="koboSpan" id="kobo.541.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">ComponiumRouter</span></strong><span class="koboSpan" id="kobo.543.1"> class, the framework handles those </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">pushState</span></strong><span class="koboSpan" id="kobo.545.1"> events and renders the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">appropriate template.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.547.1">Additional reading</span></p>
<p class="callout"><span class="koboSpan" id="kobo.548.1">The MDN documentation outlines all possible History API methods we can use in our frontend routing components. </span><span class="koboSpan" id="kobo.548.2">It is </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.549.1">available </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">here: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState"><span class="No-Break"><span class="koboSpan" id="kobo.551.1">developer.mozilla.org/en-US/docs/Web/API/History/pushState</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.552.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.553.1">In the Lit Labs open source code base, there </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.554.1">is another example of a component router. </span><span class="koboSpan" id="kobo.554.2">The source for it can be found at </span><a href="https://github.com/lit/lit/tree/main/packages/labs/router"><span class="koboSpan" id="kobo.555.1">github.com/lit/lit/tree/main/packages/labs/router</span></a><span class="koboSpan" id="kobo.556.1">. </span><span class="koboSpan" id="kobo.556.2">It can be an excellent exercise to implement the router in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.557.1">Componium</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1"> framework.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.559.1">Optimizations</span></h2>
<p><span class="koboSpan" id="kobo.560.1">Part of our goals for</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.561.1"> frontend functionality was a set of optimizations to make the applications that our framework produces more efficient, scalable, and performant. </span><span class="koboSpan" id="kobo.561.2">We shall take a step toward that by introducing some features to optimize the output of our frontend components in </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">production environments.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">We will introduce a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Optimize</span></strong><span class="koboSpan" id="kobo.565.1"> class, which has some functions to perform optimizations on the code base. </span><span class="koboSpan" id="kobo.565.2">The class can be found in the framework directory at </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">packages/frontend/optimize.js</span></strong><span class="koboSpan" id="kobo.567.1">. </span><span class="koboSpan" id="kobo.567.2">These optimizations can affect both the included/injected framework files and the application code. </span><span class="koboSpan" id="kobo.567.3">The functions of this class will activate when applications deploy within an envrionment that has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">NODE_ENV=production</span></strong><span class="koboSpan" id="kobo.569.1"> variables defined, which is the common pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">Node.js-based projects.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">We will utilize some existing JavaScript tooling â€“ in this particular case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">esbuild</span></strong><span class="koboSpan" id="kobo.573.1"> â€“ to </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">minify</span></strong><span class="koboSpan" id="kobo.575.1"> the framework and component code files. </span><span class="koboSpan" id="kobo.575.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">esbuild</span></strong><span class="koboSpan" id="kobo.577.1"> tooling provides the following minification </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">command-line API:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.579.1">
 esbuild ${filePath} --minify --outfile=${newFilePath}.</span></pre>
<p><span class="koboSpan" id="kobo.580.1">We can use the power of </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">esbuild</span></strong><span class="koboSpan" id="kobo.582.1"> tooling to optimize applications built with our framework. </span><span class="koboSpan" id="kobo.582.2">For example, all the components used in an application will be minified by the server process when required. </span><span class="koboSpan" id="kobo.582.3">Under the hood, the framework parses through the component files and runs the minification step, outputting the optimized files into a separate directory. </span><span class="koboSpan" id="kobo.582.4">We use a hidden directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">.componium</span></strong><span class="koboSpan" id="kobo.584.1"> as storage to save the optimized files. </span><span class="koboSpan" id="kobo.584.2">The framework later knows to access the optimized files instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">the originals.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">To expand further improvements in the future, we can focus optimizations on other application files, such as images, media, and more. </span><span class="koboSpan" id="kobo.586.2">The introduction of more complex build tools is also possible. </span><span class="koboSpan" id="kobo.586.3">For example, we can add </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">rollup.js</span></strong><span class="koboSpan" id="kobo.588.1"> to enhance the resulting output of the client-side code. </span><span class="koboSpan" id="kobo.588.2">We have seen example usages of rollup tooling in </span><a href="B19014_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.589.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.590.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">Esbuild</span></strong><span class="koboSpan" id="kobo.592.1"> also </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.593.1">provides additional functionality besides the minification that can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">at </span></span><a href="https://esbuild.github.io/api"><span class="No-Break"><span class="koboSpan" id="kobo.595.1">esbuild.github.io/api</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.596.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">Now, the final part to cover is the improvements in the developer experience for these frontend components, which we will do in the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">following section.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.599.1">Developer experience</span></h2>
<p><span class="koboSpan" id="kobo.600.1">The finishing</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.601.1"> touches for our features are to include some improvements to the developer experience. </span><span class="koboSpan" id="kobo.601.2">We will do this through thorough documentation of the component system and by providing enhancements to the frameworkâ€™s </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">executable file.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">The documentation should provide clear instructions on the frontend capabilities, such as the definition of multiple Client Views and static file directories. </span><span class="koboSpan" id="kobo.603.2">The component structure, composability, and reactivity features also need to be described. </span><span class="koboSpan" id="kobo.603.3">For example, this could include a straightforward API to add new client routes and how the framework uses the Lit library to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">component-related features.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">The improvements of the framework executable include the ability to generate the Client View routes, Views, and Components using a scaffolding operation. </span><span class="koboSpan" id="kobo.605.2">In </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.606.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.607.1">, we saw an example of generating new API routes; this is a very similar addition. </span><span class="koboSpan" id="kobo.607.2">Just as before, with the executable, developers will be able to quickly generate some code and start composing frontend user interfaces. </span><span class="koboSpan" id="kobo.607.3">These pre-generated components include the default property configurations for styles and data properties </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">of objects.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">Overall, we will demystify as many of the frontend features as possible, focusing on helping developers navigate the complicated intricacies of all the technologies that are in play while building client-side </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">web applications.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.611.1">Dependencies</span></h2>
<p><span class="koboSpan" id="kobo.612.1">We will use </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.613.1">several dependencies fetched from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">npm</span></strong><span class="koboSpan" id="kobo.615.1"> package registry to achieve the level of functionality described in this chapter. </span><span class="koboSpan" id="kobo.615.2">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">notable ones:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">Esbuild</span></strong><span class="koboSpan" id="kobo.618.1">: The </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.619.1">bundler and minifier tool used for optimization steps when the framework server runs in production environments. </span><span class="koboSpan" id="kobo.619.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">esbuild</span></strong><span class="koboSpan" id="kobo.621.1">, we can quickly optimize scripts. </span><span class="koboSpan" id="kobo.621.2">It includes a lot of advanced features that we can use to extend the end-result scripts of our </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">framework further.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Lit</span></strong><span class="koboSpan" id="kobo.624.1">: The library</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.625.1"> that helps us extend the existing Web Component techniques and provides much more advanced component features, such as enabling easier data-binding and simplified </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">state management.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">lit-html</span></strong><span class="koboSpan" id="kobo.628.1">: Another </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.629.1">module that is related to the Lit library, which provides templating features for the frontend features of </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">our framework.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">@lit-labs/srr</span></strong><span class="koboSpan" id="kobo.632.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">@lit-labs/ssr-client</span></strong><span class="koboSpan" id="kobo.634.1">: These two modules enable the </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.635.1">SSR features</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.636.1"> of our framework. </span><span class="koboSpan" id="kobo.636.2">They can render the components in the Componium server and are later hydrated on </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the frontend.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.638.1">Mainly, these </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.639.1">libraries and tools help us enrich our framework features. </span><span class="koboSpan" id="kobo.639.2">Our framework can rely on these dependencies to enable efficient project building, component-based architecture, dynamic content rendering, and SSR, resulting in a performant, maintainable, and user-friendly application. </span><span class="koboSpan" id="kobo.639.3">With the detailed architecture in place, in the following section, we will explore the developer workflow to create a simple client-side application with Componiumâ€™s </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">frontend features.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.641.1">Using the framework</span></h1>
<p><span class="koboSpan" id="kobo.642.1">Now that </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.643.1">we have the architecture in place, we can go through a </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.644.1">scenario where a developer uses our frontend framework parts to build a simple frontend example application. </span><span class="koboSpan" id="kobo.644.2">In </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.645.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.646.1">, we performed the same task to get a good outline of all the features working together to achieve a certain task. </span><span class="koboSpan" id="kobo.646.2">To follow along, ensure that you have installed the dependencies, and then you can start the sample app in the </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">following directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.648.1">
&gt; cd chapter7/componium/tests/sample
&gt; componium dev
Executing (default): SELECT 1+1 AS result
Componium Server (PID: 59938) started on port: 9000</span></pre>
<p><span class="koboSpan" id="kobo.649.1">You will be able to open the browser at </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">http://localhost:9000</span></strong><span class="koboSpan" id="kobo.651.1"> to view </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">the application.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.653.1"><img alt="Figure 8.5: A sample client-side app" src="image/Figure_8.5_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.654.1">Figure 8.5: A sample client-side app</span></p>
<p><span class="koboSpan" id="kobo.655.1">Based on </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.656.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.657.1">.4</span></em><span class="koboSpan" id="kobo.658.1">, we want to create a page with a header called </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">List of frameworks</span></strong><span class="koboSpan" id="kobo.660.1">. </span><span class="koboSpan" id="kobo.660.2">We also want to list some frameworks on this page. </span><span class="koboSpan" id="kobo.660.3">Every framework entry should attach to the client-side view and show a number of star points to every framework. </span><span class="koboSpan" id="kobo.660.4">Besides the static functionality, we have buttons under each framework component that are </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.661.1">able to increment a counter, in this case we label the counter as the number of stars for every project. </span><span class="koboSpan" id="kobo.661.2">The developer use case also includes using the SSR features to render the page from the server for performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">SEO purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">To begin, our</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.664.1"> Componium framework allows us to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">ClientViews</span></strong><span class="koboSpan" id="kobo.666.1"> from the server. </span><span class="koboSpan" id="kobo.666.2">We can create a client view at the root of the application in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">app.js</span></strong><span class="koboSpan" id="kobo.668.1"> file. </span><span class="koboSpan" id="kobo.668.2">We can also utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">componium</span></strong><span class="koboSpan" id="kobo.670.1"> executable here to scaffold </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">the components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.672.1">
server.addClientView("/", "frameworks", {
Â Â title: "Frameworks",
});</span></pre>
<p><span class="koboSpan" id="kobo.673.1">The following code from the root of our application will establish a hosted route at the endpoint designated with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">/</span></strong><span class="koboSpan" id="kobo.675.1"> on the Componium server. </span><span class="koboSpan" id="kobo.675.2">Besides providing the path, we also specify the name of the view and additional options for that view. </span><span class="koboSpan" id="kobo.675.3">The name of the view maps to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">views</span></strong><span class="koboSpan" id="kobo.677.1"> directory in our applications. </span><span class="koboSpan" id="kobo.677.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">views/frameworks.js</span></strong><span class="koboSpan" id="kobo.679.1"> file defines our server-side </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">component handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
export default function frameworks(request, response) {
Â Â const hitsComponium = 1000;
Â Â // code omitted
Â Â return `
Â Â Â Â &lt;div class="framework-list"&gt;
Â Â Â Â Â Â &lt;framework-item name="Componium" count=
Â Â Â Â Â Â Â Â "${hitsComponium}"&gt;&lt;/framework-item&gt;
Â Â Â Â Â &lt;!-- extra code omitted --&gt;`;
}</span></pre>
<p><span class="koboSpan" id="kobo.682.1">To see the full version of this component, check out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">tests/sample/views/frameworks.js</span></strong><span class="koboSpan" id="kobo.684.1"> file. </span><span class="koboSpan" id="kobo.684.2">The preceding code only lists one of the frameworks in the list, but the sample has all of the required items. </span><span class="koboSpan" id="kobo.684.3">Looking deeper into the code, we have </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.685.1">access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">request</span></strong><span class="koboSpan" id="kobo.687.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">response</span></strong><span class="koboSpan" id="kobo.689.1"> objects in this exported </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">frameworks</span></strong><span class="koboSpan" id="kobo.691.1"> function. </span><span class="koboSpan" id="kobo.691.2">This is where developers can also access the database ORM methods in this file to fetch the data and pre-populate the </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">component state.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">With the</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.694.1"> defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">framework-item</span></strong><span class="koboSpan" id="kobo.696.1"> components in place, we can start the application server and navigate to the root of the application. </span><span class="koboSpan" id="kobo.696.2">If we view the source of the file, we can see the SSR components. </span><span class="koboSpan" id="kobo.696.3">Partially, the source would look </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
&lt;h1 style="font-family: sans-serif; text-align:
Â Â sscenter;"&gt;List of frameworks&lt;/h1&gt;
Â Â Â Â &lt;div class="framework-list"&gt;
Â Â Â Â Â Â &lt;framework-item
Â Â Â Â Â Â Â Â name="Componium"
Â Â Â Â Â Â Â Â count="1000"
Â Â Â Â Â Â &gt;&lt;/framework-item&gt;</span></pre>
<p><span class="koboSpan" id="kobo.699.1">The state of the component, including the number of stars is hydrated from the rendered component. </span><span class="koboSpan" id="kobo.699.2">If we use the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">button</span></strong><span class="koboSpan" id="kobo.701.1"> element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">framework-item</span></strong><span class="koboSpan" id="kobo.703.1"> component, then we increase the number of starts based on the state that originated from </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">the server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
&lt;button @click=${() =&gt; this.count++}&gt;Add stars&lt;/button&gt;</span></pre>
<p><span class="koboSpan" id="kobo.706.1">Finally, with </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.707.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">frameworks.js</span></strong><span class="koboSpan" id="kobo.709.1"> application view created, we can now deploy our application to give it a test run. </span><span class="koboSpan" id="kobo.709.2">Here, developers should configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">app.js</span></strong><span class="koboSpan" id="kobo.711.1"> process to run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">NODE_ENV=production</span></strong><span class="koboSpan" id="kobo.713.1"> environment variable turned on. </span><span class="koboSpan" id="kobo.713.2">This will enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">esbuild</span></strong><span class="koboSpan" id="kobo.715.1"> optimization features, allowing the server process to minify our newly </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">created components.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">This example use of the </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.718.1">framework included creating components, rendering them on the server side, and interacting with their state by clicking on their UI elements. </span><span class="koboSpan" id="kobo.718.2">This practical example and the routing examples from the </span><em class="italic"><span class="koboSpan" id="kobo.719.1">Client router</span></em><span class="koboSpan" id="kobo.720.1"> section showcase most of the features that we have developed for this initial version of the framework features. </span><span class="koboSpan" id="kobo.720.2">The following steps from here could involve finding ways to improve the component-based architecture, as well as finding more ways to add potential optimizations to the applications built with </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">our framework.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.722.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.723.1">In this chapter, we focused on building a frontend architecture and adding frontend features to our existing project. </span><span class="koboSpan" id="kobo.723.2">Similar to the definition of server-side architecture in </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.724.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.725.1">, in this chapter, we had to define the goals behind the frontend features, focusing on what developers would like to do with our full stack framework. </span><span class="koboSpan" id="kobo.725.2">We have covered the topics of defining entry points for client routes, concepts of reactivity, complex component structures, SSR, routing, optimizations, and so on. </span><span class="koboSpan" id="kobo.725.3">The frontend feature set can be overwhelming, with a lot of terminology, and there is much more to learn beyond </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">If we combine all the components that we have architected in the past several chapters, we now end up with a framework consisting of three use cases that combine into a larger full stack narrative. </span><span class="koboSpan" id="kobo.727.2">So far, we have seen a JavaScript testing framework, a backend framework, and finally, a frontend framework under the same </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">logical namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">In the next chapter, we will focus on essential topics of framework maintenance by shedding light on various situations that can occur as </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">frameworks evolve.</span></span></p>
</div>


<div class="Content" id="_idContainer073">
<h1 id="_idParaDest-156" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.1.1">Part 3: Maintaining Your Project</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In conclusion, the last two chapters give an in-depth look at the maintenance aspects and future of framework projects in the JavaScript programming space. </span><span class="koboSpan" id="kobo.2.2">The driving factor behind these chapters is to ensure the longevity and usability of the projects that developers build to guarantee the creationsâ€™ reliability and effectiveness. </span><span class="koboSpan" id="kobo.2.3">Looking over the best practices of such systems, the final chapter presents current and future ideas that are relevant to established and </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">new projects.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">In this part, we cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19014_09.xhtml#_idTextAnchor156"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Framework Maintenance</span></em></li>
<li><a href="B19014_10.xhtml#_idTextAnchor173"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Best Practices</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer074">
</div>
</div>
<div>
<div id="_idContainer075">
</div>
</div>
<div>
<div id="_idContainer076">
</div>
</div>
<div>
<div id="_idContainer077">
</div>
</div>
<div>
<div id="_idContainer078">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer079">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer080">
</div>
</div>
<div>
<div id="_idContainer081">
</div>
</div>
<div>
<div id="_idContainer082">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer083">
</div>
</div>
</body></html>