<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Setting up for Testing</h1>
<p>Back when you were a young schoolchild, you probably learned to write by using a pencil on paper. Now that you’re older, it’s likely you prefer pens. For learners, pencils have a distinct advantage over pens in that mistakes are easy to correct, and when you first start writing out letters and words, you will be making a lot of mistakes. Pencils are also safer for small children – no caps or messy ink to <span class="No-Break">worry about.</span></p>
<p>But pencils remain a valid writing instrument, and you might still have a personal preference for pencils over pens. The pencil is a perfectly good tool for <span class="No-Break">the job.</span></p>
<p><strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) is a tool that can serve you in a similar way. It’s a great way to learn and grow as a developer. Many experienced developers prefer it for their day-to-day work over <span class="No-Break">any alternative.</span></p>
<p>In this chapter, you’ll configure a work environment that’s designed to help you get the most out of TDD techniques. Since TDD asks you to do a bunch of small repetitive tasks – writing tests, running tests, committing early and often, and switching between test code and application code – it’s important that each of those tasks can be done easily <span class="No-Break">and quickly.</span></p>
<p>It follows that an important personal discipline to cultivate is that of objectively critiquing your development tools. For every tool that you use, ask yourself this: is this tool serving me well? Is it easy and quick <span class="No-Break">to use?</span></p>
<p>This could be your <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>), your operating system, your source code repository, your note-taking program, your time management utilities, and so on. Anything and everything you use in your day job. Scrutinize your tools. Throw away whatever isn’t working <span class="No-Break">for you.</span></p>
<p>This is a very personal thing and depends a lot on experience and individuality. And your preferences are likely to change over <span class="No-Break">time, too.</span></p>
<p>I often reach for very plain, simple, keyboard-driven tools that work for me consistently, regardless of the programming language I’m working in, such as the text editor Vim. It doesn’t offer any knowledge about the JavaScript programming language or the Svelte framework, but it makes me extremely effective at <span class="No-Break">editing text.</span></p>
<p>But if you care about learning JavaScript or program design, then you might prefer an IDE that gives you JavaScript auto-complete suggestions and helpful <span class="No-Break">project assistance.</span></p>
<p>This chapter walks through the setup of a new SvelteKit project and highlights all the individual choices you’ll need to make, and the additional extras you’ll need in order to practice <span class="No-Break">effective TDD.</span></p>
<p>It covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Creating a new <span class="No-Break">SvelteKit project</span></li>
<li>Preparing your development environment for frequent <span class="No-Break">test runs</span></li>
<li>Configuring support for Svelte <span class="No-Break">component tests</span></li>
<li>Optional configuration you may want <span class="No-Break">to try</span></li>
</ul>
<p>By the end of the chapter, you’ll know how to create a new Svelte project that is ready for test-driven <span class="No-Break">feature building.</span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter01/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter01/Start</span></a><span class="No-Break">.</span></p>
<p>You will need to have a recent version of Node.js installed. See <a href="https://nodejs.org">https://nodejs.org</a> for instructions on how to install and update Node.js for <span class="No-Break">your platform.</span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Creating a new SvelteKit project</h1>
<p>In this section, you’ll use<a id="_idIndexMarker000"/> the default method for creating a new SvelteKit project, which uses the <strong class="source-inline">npm create</strong> command. (For reference, you can also check the official documentation <span class="No-Break">at </span><a href="https://kit.svelte.dev/docs/creating-a-project"><span class="No-Break">https://kit.svelte.dev/docs/creating-a-project</span></a><span class="No-Break">.)</span></p>
<p>The project we are building is called <em class="italic">Birthdays</em> and the npm package name is <strong class="source-inline">birthdays</strong>. It will be introduced properly in <a href="B19611_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Introducing the </em><span class="No-Break"><em class="italic">Red-Green-Refactor Workflow</em></span><span class="No-Break">.</span></p>
<p class="callout-heading">SvelteKit 1.0</p>
<p class="callout">These instructions were valid at the time of <a id="_idIndexMarker001"/>writing, for SvelteKit 1.0. It’s likely things will improve in time, so you may find some of the later instructions will become unnecessary or may no longer work. Check the book’s GitHub repository for the most <span class="No-Break">up-to-date instructions.</span></p>
<p>For now, we’ll concentrate <a id="_idIndexMarker002"/>on the mechanics of building a <span class="No-Break">new project:</span></p>
<ol>
<li>Start by opening a Terminal window in your usual work location (for me, this is <strong class="source-inline">~/work</strong> on my Mac). Then type the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">mkdir birthdays</strong>
<strong class="bold">cd birthdays</strong>
<strong class="bold">npm create svelte@latest</strong></pre></li>
</ol>
<p>If this is the first Svelte project you’ve created, you’ll be presented with the following message <span class="No-Break">from npm:</span></p>
<pre class="source-code">
<strong class="bold">Need to install the following packages:</strong>
<strong class="bold">  create-svelte@2.1.0</strong>
<strong class="bold">Ok to proceed? (y)</strong></pre>
<ol>
<li value="2">Answer <strong class="source-inline">y</strong> to that. You’ll see a bunch more questions, which we’ll go <span class="No-Break">through individually:</span><pre class="source-code">
<strong class="bold">create-svelte version 2.1.0</strong>
<strong class="bold">Welcome to SvelteKit!</strong>
<strong class="bold">? Where should we create your project?</strong>
<strong class="bold">  (leave blank to use current directory) ›</strong></pre></li>
<li>Since you’re already in the <strong class="source-inline">birthdays</strong> directory, just leave this blank, and hit <em class="italic">Enter</em>. Next, you’ll be asked about which app template you’d like <span class="No-Break">to use:</span><pre class="source-code">
<strong class="bold">? Which Svelte app template? › - Use arrow-keys. Return to submit.</strong>
<strong class="bold">    </strong><strong class="bold">SvelteKit demo app</strong>
<strong class="bold">❯</strong><strong class="bold">   Skeleton project - Barebones scaffolding for your new SvelteKit app</strong>
<strong class="bold">    Library skeleton project</strong></pre></li>
<li>Choose <strong class="source-inline">Skeleton project</strong>. Next, you’ll be<a id="_idIndexMarker003"/> asked <span class="No-Break">about TypeScript:</span><pre class="source-code">
<strong class="bold">? Add type checking with TypeScript? › - Use arrow-keys. Return to submit.</strong>
<strong class="bold">    Yes, using JavaScript with JSDoc comments</strong>
<strong class="bold">    Yes, using TypeScript syntax</strong>
<strong class="bold">❯</strong><strong class="bold">   No</strong></pre></li>
<li>For this question, I’ve chosen <strong class="source-inline">No</strong>. That’s because this book is about testing techniques, not typing techniques. That’s not to say that this book doesn’t apply to TypeScript projects – it most certainly does – just that typing is not the topic <span class="No-Break">at hand.</span></li>
</ol>
<p class="callout-heading">If you want to use TypeScript</p>
<p class="callout">If you’re a seasoned TypeScript developer, please feel free to choose that option instead. The code samples in the book won’t need too much modification except for the additional type definitions, which you’ll need <span class="No-Break">to provide.</span></p>
<ol>
<li value="6">Finally, you’ll be asked <a id="_idIndexMarker004"/>about extra <span class="No-Break">package dependencies:</span><pre class="source-code">
<strong class="bold">? Add ESLint for code linting? › No / Yes</strong>
<strong class="bold">? Add Prettier for code formatting? › No / Yes</strong>
<strong class="bold">? Add Playwright for browser testing? › No / Yes</strong>
<strong class="bold">    </strong><strong class="bold">✔</strong><strong class="bold"> Add Vitest for unit testing? … No / Yes</strong></pre></li>
<li>Choose <strong class="source-inline">Yes</strong> as the answer to all these questions. Although we won’t mention ESLint in this book, it’s always good to have. And we’ll need Playwright <span class="No-Break">and Vitest.</span></li>
</ol>
<p>You’ll then see a summary of all your choices, followed by a <strong class="source-inline">Next </strong><span class="No-Break"><strong class="source-inline">steps</strong></span><span class="No-Break"> list:</span></p>
<pre class="source-code">
<strong class="bold">Your project is ready!</strong>
<strong class="bold">✔</strong><strong class="bold"> ESLint</strong>
<strong class="bold">  </strong><strong class="bold">https://github.com/sveltejs/eslint-plugin-svelte3</strong>
<strong class="bold">✔</strong><strong class="bold"> Prettier</strong>
<strong class="bold">  https://prettier.io/docs/en/options.xhtml</strong>
<strong class="bold">  https://github.com/sveltejs/prettier-plugin-svelte#options</strong>
<strong class="bold">✔</strong><strong class="bold"> Playwright</strong>
<strong class="bold">  https://playwright.dev</strong>
<strong class="bold">✔</strong><strong class="bold"> Vitest</strong>
<strong class="bold">  https://vitest.dev</strong>
<strong class="bold">Install community-maintained integrations:</strong>
<strong class="bold">  https://github.com/svelte-add/svelte-adders</strong>
<strong class="bold">Next steps:</strong>
<strong class="bold">  1: npm install (or pnpm install, etc)</strong>
<strong class="bold">  2: git init &amp;&amp; git add -A &amp;&amp; git commit -m "Initial commit" (optional)</strong>
<strong class="bold">  3: npm run dev -- --open</strong></pre>
<p>We’ll perform <a id="_idIndexMarker005"/>these next steps but before we do that, we’ll run some extra verification steps. It’s always good to check <span class="No-Break">your work.</span></p>
<p>Type <strong class="source-inline">npm install</strong> into the Terminal and confirm that everything is installed correctly. Then, go ahead and commit your changes. (If you’ve forked the GitHub repository, you won’t need to use the <strong class="source-inline">git </strong><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> command.)</span></p>
<p class="callout-heading">Committing early and often</p>
<p class="callout">It’s a good idea to be checking in your work very often. While you’re learning the TDD approach to testing, it can be helpful to check in after every single test. This might seem like a lot but it will help you backtrack in case you <span class="No-Break">get stuck.</span></p>
<p>Then, run <strong class="source-inline">npm run dev – –open</strong>. It should open your web browser and show you a <strong class="source-inline">"Welcome to </strong><span class="No-Break"><strong class="source-inline">SvelteKit"</strong></span><span class="No-Break"> message.</span></p>
<p>You can then close the browser and hit <em class="italic">Ctrl</em> + <em class="italic">C</em> in the Terminal to stop the <span class="No-Break">web server.</span></p>
<p>Next, let’s verify the Playwright and <span class="No-Break">Vitest dependencies.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Installing and running Playwright</h2>
<p>Although we won’t use<a id="_idIndexMarker006"/> Playwright in this chapter, it’s a good idea to get it installed <a id="_idIndexMarker007"/>and verify that <span class="No-Break">it’s working.</span></p>
<p>Start by running <strong class="source-inline">npm test</strong> at the <span class="No-Break">command line:</span></p>
<pre class="source-code">
work/birthdays % npm test
&gt; birthdays@0.0.1 test
&gt; playwright test
Running 1 test using 1 worker
[WebServer]
[WebServer]
[WebServer] Generated an empty chunk: "hooks".
[WebServer]
  ✘  1 test.js:3:1 › index page has expected h1 (7ms)
  1) test.js:3:1 › index page has expected h1 =============================================
    browserType.launch: Executable doesn't exist at /Users/daniel/Library/Caches/ms-playwright/chromium-1041/chrome-mac/Chromium.app/Contents/MacOS/Chromium
    ...
  1 failed
    test.js:3:1 › index page has expected h1 ============================================</pre>
<p>If you’ve never installed <a id="_idIndexMarker008"/>Playwright before, you’ll see a message like the<a id="_idIndexMarker009"/> <span class="No-Break">preceding one.</span></p>
<p>Playwright has its own environment <a id="_idIndexMarker010"/>setup to do, such as installing Chromium onto <a id="_idIndexMarker011"/>your machine. You can install it with the <span class="No-Break">following command:</span></p>
<pre class="source-code">
npx playwright install</pre>
<p>Then, trying <strong class="source-inline">npm test</strong> again should give you the following output, showing that the one example test that’s included <span class="No-Break">is passing:</span></p>
<pre class="source-code">
&gt; birthdays@0.0.1 test
&gt; playwright test
Running 1 test using 1 worker
[WebServer]
[WebServer]
[WebServer] Generated an empty chunk: "hooks".
[WebServer]
  ✓  1 test.js:3:1 › index page has expected h1 (307ms)
  1 passed (4s)</pre>
<p>This test, <strong class="source-inline">index page has expected h1</strong>, is a test for the <strong class="source-inline">"Welcome to SvelteKit"</strong> message<a id="_idIndexMarker012"/> you saw earlier when you launched the<a id="_idIndexMarker013"/> application in <span class="No-Break">the browser.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Running Vitest</h2>
<p>Running <strong class="source-inline">npm run test:unit</strong> is the<a id="_idIndexMarker014"/> default<a id="_idIndexMarker015"/> way to run Vitest tests. Try <span class="No-Break">it now:</span></p>
<pre class="source-code">
work/birthdays % npm run test:unit
&gt; birthdays@0.0.1 test:unit
&gt; vitest
 DEV  v0.25.8 /Users/daniel/work/birthdays
 ✓ src/index.test.js (1)
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  15:56:18
   Duration  737ms (transform 321ms, setup 0ms, collect 16ms, tests 2ms)
 PASS  Waiting for file changes...
       press h to show help, press q to quit</pre>
<p>This automatically puts you in watch mode, which means any changes to the filesystem will cause tests to re-run. Press <em class="italic">q</em> to quit this mode. I personally don’t use watch mode and we won’t be <a id="_idIndexMarker016"/>using it in this book. See the <em class="italic">Creating a shell alias</em> section for<a id="_idIndexMarker017"/> a little discussion on why <span class="No-Break">this is.</span></p>
<p>In the next section, we’ll make the ergonomics of the project a little easier <span class="No-Break">for us.</span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Preparing your development environment for frequent unit testing</h1>
<p>In this section, we’ll take some configuration actions that will make our test-driven lives <span class="No-Break">much simpler.</span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Choosing your editor</h2>
<p>Let’s start with your choice of <a id="_idIndexMarker018"/>code editor. More than likely, this means a choice between an IDE, such as Visual Studio Code, or a plain text editor, such as Vim <span class="No-Break">or Emacs.</span></p>
<p>IDEs tend to have lots of bells and whistles and one of those is the built-in test runner, which runs tests for you and integrates test output into the editor itself. On the other hand, plain text editors will require you to have a separate Terminal window for you to enter test commands directly, as you did in the <span class="No-Break">previous section.</span></p>
<p><span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em> shows how my own setup looks, using Vim and tmux to split windows. The top half of the screen is where I edit my source files, and when I’m ready to run tests, I can switch to the bottom half and enter the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> command.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<img alt="Figure 1.1 – Using tmux and Vim" height="1156" src="image/Figure_1.1_B19611.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Using tmux and Vim</p>
<p><span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> shows the same <a id="_idIndexMarker019"/>project in Visual Studio Code with the Vitest extension installed. Notice the test runner has a bunch of neat features, such as the ability to filter the test output, and green ticks next to the line numbers of <span class="No-Break">passing tests.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 1.2 – Using Visual Studio Code to run tests" height="1141" src="image/Figure_1.2_B19611.jpg" width="1642"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Using Visual Studio Code to run tests</p>
<p>I think there is a lot to<a id="_idIndexMarker020"/> learn from using a plain editor and Terminal setup, but if you don’t feel comfortable with that, then it’s best to stick to your favorite IDE <span class="No-Break">for now.</span></p>
<p>The one thing you want to make sure of is that it’s easy and quick to run tests. So, if you’re writing a new test, you want to immediately run it and see it fail. And if you’re making a test pass or refactoring tests, make sure you can quickly re-run tests to check <span class="No-Break">your progress.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Creating a shell alias</h2>
<p>If you’re choosing to<a id="_idIndexMarker021"/> use the Terminal to run tests, then you will almost certainly want to set up an alias to make it simpler to run Vitest unit tests. You’ll recall that there are two commands that you use for running tests: <strong class="source-inline">npm test</strong> for Playwright tests and the <strong class="source-inline">npm run test:unit</strong> command for Vitest <span class="No-Break">unit tests.</span></p>
<p>The style of testing shown in this book follows the classic <em class="italic">test pyramid</em> approach to testing, which states that we should have lots of little unit tests (in Vitest) and far fewer system tests (<span class="No-Break">in Playwright).</span></p>
<p>So, given that we’ll be working much more frequently with Vitest, doesn’t it make sense to have the <em class="italic">shorter</em> <strong class="source-inline">test</strong> command be the one that runs <span class="No-Break">unit tests?</span></p>
<p>The solution that I use is a shell<a id="_idIndexMarker022"/> alias, <strong class="source-inline">v</strong>, that invokes Vitest. If you wanted to use the standard watch mode, you’d set up the shell alias to run <span class="No-Break">this command:</span></p>
<pre class="source-code">
npx vitest</pre>
<p>However, because I don’t want to use watch mode, I set it up to use <span class="No-Break">this command:</span></p>
<pre class="source-code">
npx vitest run</pre>
<p>I‘d suggest you use this version, at least while you read through this book. I find that watch mode tends to break silently, especially when you’re in the first stages of setting up a project. To avoid confusion, better to just invoke the test command when <span class="No-Break">you’re ready.</span></p>
<p>On my Mac, my default shell is <strong class="source-inline">zsh</strong>, which configures its shell aliases in the <strong class="source-inline">~/.zshrc</strong> file. You can add that alias to the file using the <span class="No-Break">following commands:</span></p>
<pre class="source-code">
echo 'alias v="npx vitest run"' &gt;&gt; ~/.zshrc
source ~/.zshrc</pre>
<p>Now, you can simply type the <strong class="source-inline">v</strong> command to run your Vitest unit tests. You can also use this to run a single test file, <span class="No-Break">like this:</span></p>
<pre class="source-code">
v src/index.tests.js</pre>
<p>This is a handy way to run just a small part of your <span class="No-Break">test suite.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Changing the test runner to report each test name</h2>
<p>Recall that when we ran our <a id="_idIndexMarker023"/>Vitest unit tests, the test report told us the filename of the test suite that was run, together with some <span class="No-Break">summary information:</span></p>
<pre class="source-code">
 DEV  v0.25.8 /Users/daniel/work/birthdays
 ✓ src/index.test.js (1)
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  15:56:18
   Duration  737ms (transform 321ms, setup 0ms, collect 16ms, tests 2ms)</pre>
<p>It turns out this isn’t enough – we want to see test names too, just like how the Playwright test told us the description<a id="_idIndexMarker024"/> of the test that <span class="No-Break">was passing.</span></p>
<p>Open the <strong class="source-inline">vite.config.js</strong> file and add a new <strong class="source-inline">reporter</strong> property that is set to <strong class="source-inline">verbose</strong>, as shown in the following <span class="No-Break">code block:</span></p>
<pre class="source-code">
 const config = {
   plugins: [sveltekit()],
   test: {
     ...,
     <strong class="bold">reporter: 'verbose'</strong>
   }
 };</pre>
<p class="callout-heading">Be careful</p>
<p class="callout">If you had left your test runner running in watch mode, you’ll need to restart it at this point, and at any other point in which you modify <span class="No-Break">the configuration.</span></p>
<p>Now, running tests at the command line using the <strong class="source-inline">v</strong> command will <span class="No-Break">give this:</span></p>
<pre class="source-code">
 RUN  v0.25.8 /Users/daniel/work/birthdays
 ✓ src/index.test.js (1)
   ✓ sum test (1)
     ✓ adds 1 + 2 to equal 3
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  11:02:05
   Duration  905ms (transform 320ms, setup 1ms, collect 16ms, tests 2ms)</pre>
<p><span class="No-Break">Much better!</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Watching the test fail</h2>
<p>We’re almost done with<a id="_idIndexMarker025"/> configuring Vitest, but before continuing, let’s check that the test actually tests what we want it to test. This is an important concept with TDD: if you’ve never seen a test fail, how do you know it tests the <span class="No-Break">right thing?</span></p>
<p>Open <strong class="source-inline">src/index.test.js</strong> and take <span class="No-Break">a look:</span></p>
<pre class="source-code">
import { describe, it, expect } from 'vitest';
describe('sum test', () =&gt; {
  it('adds 1 + 2 to equal 3', () =&gt; {
    expect(1 + 2).toBe(3);
  });
});</pre>
<p>Make a change to the <strong class="source-inline">expect</strong> statement, like the one <span class="No-Break">shown here:</span></p>
<pre class="source-code">
expect(2 + 2).toBe(3);</pre>
<p>Now if you run the test, you should see <span class="No-Break">a failure:</span></p>
<pre class="source-code">
<strong class="bold">❯</strong> src/index.test.js:5:17
      3| describe('sum test', () =&gt; {
      4|  it('adds 1 + 2 to equal 3', () =&gt; {
      5|   expect(2 + 2).toBe(3);
       |                 ^
      6|  });
      7| });
  - Expected   "3"
  + Received   "4"</pre>
<p>Brilliant – our test runner seems to be in working order. You can go ahead and undo the change to the test, and watch it go green again. That’s it for the basic <span class="No-Break">editor configuration.</span></p>
<h3>Test file location – src or test?</h3>
<p>In many other programming environments, test files are kept apart from application source files. A separate directory named something like <strong class="source-inline">tests</strong> or <strong class="source-inline">specs</strong> is used to house all <a id="_idIndexMarker026"/>executable <span class="No-Break">test scripts.</span></p>
<p>There can be a couple of advantages to that. First, it can avoid packaging tests with application code when it comes to building deployable units. However, Svelte (and JavaScript in general) doesn’t suffer from this problem because only modules referenced by the application entry point will <span class="No-Break">be bundled.</span></p>
<p>Second, having a separate directory avoids the mindset of <em class="italic">one test file per module</em>. Not all modules need unit tests: if a unit exists as a part of a larger unit, we’ll often just write tests for the top-level unit and those tests will also provide coverage for the lower-level unit. Conversely, sometimes it’s helpful to have two (or more!) test files for a <span class="No-Break">single module.</span></p>
<p>That’s especially true when using component mocks that wipe out a component mock for an entire module. You might want a test file that mocks a component, and another test file where the component isn’t mocked. We’ll look at component mocks in <a href="B19611_12.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Using Component Mocks to </em><span class="No-Break"><em class="italic">Clarify Tests</em></span><span class="No-Break">.</span></p>
<p>The current SvelteKit approach is to keep Vitest test files housed within the <strong class="source-inline">src</strong> directory. Partly, this is<a id="_idIndexMarker027"/> to avoid confusion with Playwright tests, which <em class="italic">do</em> live in a separate directory, named <strong class="source-inline">tests</strong>. (We’ll see Playwright tests starting from <a href="B19611_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Loading Data into </em><span class="No-Break"><em class="italic">a Route</em></span><span class="No-Break">).</span></p>
<p>This book continues with that style, but I would encourage you to explore and adopt whichever style you feel most <span class="No-Break">comfortable with.</span></p>
<p>In the next section, we’ll add support for the kinds of tests we’ll be writing throughout <span class="No-Break">the book.</span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Configuring support for Svelte component tests</h1>
<p>A Svelte <em class="italic">component test</em> is one that, perhaps <a id="_idIndexMarker028"/>unsurprisingly, tests a Svelte component. For this, we need access to a <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), which isn’t part of the standard Node.js<a id="_idIndexMarker029"/> environment. We’ll also need some additional packages for writing unit test expectations against <span class="No-Break">the DOM.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Installing jsdom and testing library helpers</h2>
<p>At the Terminal, run the following<a id="_idIndexMarker030"/> command to install the <strong class="source-inline">jsdom</strong> package and <strong class="source-inline">@testing-library</strong> packages that we’ll use in<a id="_idIndexMarker031"/> our <span class="No-Break">unit tests:</span></p>
<pre class="source-code">
npm install --save-dev \
  jsdom \
  @testing-library/svelte \
  @testing-library/jest-dom \
  @testing-library/user-event</pre>
<p>If you’re using TypeScript, at this point, you may wish to add packages containing <span class="No-Break">type definitions.</span></p>
<p>Next, create a new file named <strong class="source-inline">src/vitest/registerMatchers.js</strong> with the following content. It ensures that <a id="_idIndexMarker032"/>the matchers we’ll be using are available for use via the <span class="No-Break"><strong class="source-inline">expect</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
import matchers from '@testing-library/jest-dom/matchers';
import { expect } from 'vitest';
expect.extend(matchers);</pre>
<p>Then, update <strong class="source-inline">vite.config.js</strong> to add a new <strong class="source-inline">environment</strong> property, which installs <strong class="source-inline">jsdom</strong> correctly, and<a id="_idIndexMarker033"/> also a <strong class="source-inline">setupFiles</strong> property, which ensures the file defined previously is loaded (and invoked) just before the test suites <span class="No-Break">are loaded:</span></p>
<pre class="source-code">
 const config = {
   plugins: [sveltekit()],
   test: {
     ...,
     reporter: 'verbose',
<strong class="bold">     environment: 'jsdom',</strong>
<strong class="bold">     setupFiles: ['./src/vitest/registerMatchers.js']</strong>
   }
 };</pre>
<p>That’s it for the basic setup. Now let’s test <span class="No-Break">it out.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Writing a test for the DOM</h2>
<p>Open the <strong class="source-inline">src/index.test.js</strong> file and<a id="_idIndexMarker034"/> add the following<a id="_idIndexMarker035"/> test definition, inside the <strong class="source-inline">describe</strong> block. This test makes use of the <strong class="source-inline">document</strong> object that is created for us by the <strong class="source-inline">jsdom</strong> package, and the <strong class="source-inline">toHaveTextContent</strong> matcher that is provided by the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">testing-library/jest-dom</strong></span><span class="No-Break"> package:</span></p>
<pre class="source-code">
it('renders hello into the document', () =&gt; {
  document.body.innerHTML =
    '&lt;h1&gt;Hello, world!&lt;/h1&gt;';
  expect(document.body).toHaveTextContent(
    'Hello, world!'
  );
});</pre>
<p>Now, if you run the test, you<a id="_idIndexMarker036"/> should see it pass. But, just as you did with the first test, it’s important to confirm the test actually tests what it says it does. Change the test by commenting out or deleting the first line of the test, and then re-running the <span class="No-Break">test runner.</span></p>
<p>You should see an output <span class="No-Break">as follows:</span></p>
<pre class="source-code">
 FAIL  src/index.test.js &gt; sum test &gt; renders hello into the document
Error: expect(element).toHaveTextContent()
Expected element to have text content:
  Hello, world!
Received:
 <strong class="bold">❯</strong> src/index.test.js:9:25
      7|
      8|  it('renders hello into the document', () =&gt; {
      9|   expect(document.body).toHaveTextContent(
       |                         ^
     10|    'Hello, world!'
     11|   );</pre>
<p>That proves the test is working. You can <a id="_idIndexMarker037"/>go ahead and undo the breaking change <span class="No-Break">you made.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Writing a first Svelte component test</h2>
<p>Next, let’s write an actual Svelte<a id="_idIndexMarker038"/> component and test that out. Create a new file named <strong class="source-inline">src/Hello.svelte</strong> with the <span class="No-Break">following content:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let name;
&lt;/script&gt;
&lt;p&gt;Hello, {name}!&lt;/p&gt;</pre>
<p>Then, go back to the <strong class="source-inline">src/index.test.js</strong> file and refactor your test to use this new component. To do that, replace the call to <strong class="source-inline">document.outerHTML</strong> with a call to the <strong class="source-inline">render</strong> function, <span class="No-Break">like this:</span></p>
<pre class="source-code">
it('renders hello into the document', () =&gt; {
  <strong class="bold">render(Hello, { name: 'world' });</strong>
  expect(document.body).toHaveTextContent(
    'Hello, world!'
  );
});</pre>
<p>This <strong class="source-inline">render</strong> function comes from the <strong class="source-inline">@testing-library/svelte</strong> package. Import that now, along with an import for the <strong class="source-inline">Hello</strong> component, placed at the top of <span class="No-Break">the file:</span></p>
<pre class="source-code">
import { render } from '@testing-library/svelte';
import Hello from './Hello.svelte';</pre>
<p>Check that the test still passes with <span class="No-Break">the refactor.</span></p>
<p>Then, add this third test, which <a id="_idIndexMarker039"/>verifies that the <strong class="source-inline">name</strong> prop in the component is being used to verify <span class="No-Break">the output:</span></p>
<pre class="source-code">
it('renders hello, svelte', () =&gt; {
  render(Hello, { name: 'Svelte' });
  expect(document.body).toHaveTextContent(
    'Hello, Svelte!'
  );
});</pre>
<p>Run the test and make sure <span class="No-Break">it passes.</span></p>
<p>Now, go ahead and comment out the <strong class="source-inline">render</strong> call in the last test. You might think that the test fails with an error saying nothing was rendered on-screen. But let’s see <span class="No-Break">what happens:</span></p>
<pre class="source-code">
Error: expect(element).toHaveTextContent()
Expected element to have text content:
  Hello, Svelte!
Received:
  Hello, world!</pre>
<p>Hold on a second; is this what we expected? This test didn’t ever print out a <strong class="source-inline">Hello, world!</strong> message so why is the test expectation picking <span class="No-Break">it up?</span></p>
<p>It turns out that our tests share the same <strong class="source-inline">document</strong> object, which is clearly not good for test independence. Imagine if the second test also expected to see <strong class="source-inline">Hello, world!</strong> rather than <strong class="source-inline">Hello, Svelte!</strong>. It would have passed by virtue of the first test running. We need to do something <span class="No-Break">about this.</span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Ensuring the DOM is cleared after each test run</h2>
<p>We want to make sure that every<a id="_idIndexMarker040"/> test gets its own clean version of the DOM. We can do this by using the <span class="No-Break"><strong class="source-inline">cleanup</strong></span><span class="No-Break"> function.</span></p>
<p>Create a new file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">src/vitest/cleanupDom.js</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/svelte';
afterEach(cleanup);</pre>
<p>Then, insert that into the <strong class="source-inline">setupFiles</strong> property <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">vite.config.js</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const config = {
  ...,
  test: {
    ...,
    setupFiles: [
<strong class="bold">      </strong><strong class="bold">'./src/vitest/cleanupDom.js',</strong>
      './src/vitest/registerMatchers.js'
    ]
  }
};</pre>
<p>Now, if you run your failing test again, you should see that the <strong class="source-inline">Hello, world!</strong> message no <span class="No-Break">longer appears.</span></p>
<p>Before continuing, uncomment the <strong class="source-inline">render</strong> call and check your tests are back in an <span class="No-Break">all-green state.</span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Restoring mocks automatically</h2>
<p>There’s one final piece of configuration<a id="_idIndexMarker041"/> we need in <strong class="source-inline">vite.config.js</strong>. Add the <strong class="source-inline">restoreMocks</strong> property, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
const config = {
  ...,
  test: {
    ...,
<strong class="bold">    restoreMocks: true</strong>
  }
};</pre>
<p>This is also important for test independence and will be important in <a href="B19611_11.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Replacing Behavior with a Side-By-Side Implementation</em>, when we begin using the <strong class="source-inline">vi.fn</strong> function for building <span class="No-Break">test doubles.</span></p>
<p>That covers all the configuration you need for the rest of the book. The next section touches briefly on some optional configurations you might want <span class="No-Break">to consider.</span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Optional configuration</h1>
<p>In this section, we’ll look at configuring Prettier and setting up more appropriate tab widths on the Terminal. These settings mirror the print settings that are used in <span class="No-Break">this book.</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Configuring Prettier’s print width</h2>
<p>Due to the constraint of the <a id="_idIndexMarker042"/>physical pages in this book, I have set the <strong class="source-inline">printWidth</strong> setting of Prettier to 54 characters, and all code samples are formatted with <span class="No-Break">that setting.</span></p>
<p>I also think the default value, <strong class="source-inline">100</strong>, is too high. I like short columns of text as I find them easier to share and read in all sorts of environments – such as on mobile devices, where it’s much easier to scroll vertically than it <span class="No-Break">is horizontally.</span></p>
<p>Also, having extra vertical space comes in handy when you are pairing with other developers and you want to refer to particular line numbers (assuming you have line numbers <span class="No-Break">turned on).</span></p>
<p>In <strong class="source-inline">.prettierrc</strong>, you can set the print width with the <span class="No-Break">following addition:</span></p>
<pre class="source-code">
{
  "printWidth": 54,
  ...
}</pre>
<p>You might be more<a id="_idIndexMarker043"/> comfortable with something in the <strong class="source-inline">60</strong> to <span class="No-Break"><strong class="source-inline">80</strong></span><span class="No-Break"> range.</span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Reducing the tab width in the Terminal</h2>
<p>The Svelte community has a<a id="_idIndexMarker044"/> preference for tabs over spaces because tabs are better for screen readers. Unfortunately, a lot of Terminals and shell programs are set up for a default tab width of eight characters, which is way too many for <span class="No-Break">my liking.</span></p>
<p>Although every Terminal is different, the one solid piece of advice I have is to set <strong class="source-inline">git config</strong> to use <strong class="source-inline">less</strong> as its pager, with tab stops at positions <strong class="source-inline">1</strong>, <strong class="source-inline">3</strong>, <strong class="source-inline">5</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">7</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
git config --global core.pager 'less -x1,3,5,7'</pre>
<p>This makes <strong class="source-inline">git diff</strong> and <strong class="source-inline">git show</strong> much more bearable, and these are two commands I use <span class="No-Break">extremely frequently.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
<p>This chapter has taken a detailed look at the various parts of a base SvelteKit project, showing how Playwright and Vitest are added, together with the additional dependencies you’ll need to write Svelte <span class="No-Break">component tests.</span></p>
<p>We’ve also looked at some of the ways you can set up your development environment to help you <span class="No-Break">be productive.</span></p>
<p>You’re now ready to start exploring TDD practices, starting with the <em class="italic">Red-Green-Refactor Cycle -&gt; Workflow</em> in the <span class="No-Break">next chapter.</span></p>
</div>
</div></body></html>