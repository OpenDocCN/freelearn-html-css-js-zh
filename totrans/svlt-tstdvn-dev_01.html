<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Setting up for Testing</h1>
<p>Back when you were a young schoolchild, you probably learned to write by using a pencil on paper. Now that you’re older, it’s likely you prefer pens. For learners, pencils have a distinct advantage over pens in that mistakes are easy to correct, and when you first start writing out letters and words, you will be making a lot of mistakes. Pencils are also safer for small children – no caps or messy ink to worry about.</p>
<p>But pencils remain a valid writing instrument, and you might still have a personal preference for pencils over pens. The pencil is a perfectly good tool for the job.</p>
<p><strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) is a tool that can serve you in a similar way. It’s a great way to learn and grow as a developer. Many experienced developers prefer it for their day-to-day work over any alternative.</p>
<p>In this chapter, you’ll configure a work environment that’s designed to help you get the most out of TDD techniques. Since TDD asks you to do a bunch of small repetitive tasks – writing tests, running tests, committing early and often, and switching between test code and application code – it’s important that each of those tasks can be done easily and quickly.</p>
<p>It follows that an important personal discipline to cultivate is that of objectively critiquing your development tools. For every tool that you use, ask yourself this: is this tool serving me well? Is it easy and quick to use?</p>
<p>This could be your <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>), your operating system, your source code repository, your note-taking program, your time management utilities, and so on. Anything and everything you use in your day job. Scrutinize your tools. Throw away whatever isn’t working for you.</p>
<p>This is a very personal thing and depends a lot on experience and individuality. And your preferences are likely to change over time, too.</p>
<p>I often reach for very plain, simple, keyboard-driven tools that work for me consistently, regardless of the programming language I’m working in, such as the text editor Vim. It doesn’t offer any knowledge about the JavaScript programming language or the Svelte framework, but it makes me extremely effective at editing text.</p>
<p>But if you care about learning JavaScript or program design, then you might prefer an IDE that gives you JavaScript auto-complete suggestions and helpful project assistance.</p>
<p>This chapter walks through the setup of a new SvelteKit project and highlights all the individual choices you’ll need to make, and the additional extras you’ll need in order to practice effective TDD.</p>
<p>It covers the following topics:</p>
<ul>
<li>Creating a new SvelteKit project</li>
<li>Preparing your development environment for frequent test runs</li>
<li>Configuring support for Svelte component tests</li>
<li>Optional configuration you may want to try</li>
</ul>
<p>By the end of the chapter, you’ll know how to create a new Svelte project that is ready for test-driven feature building.</p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter01/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter01/Start</a>.</p>
<p>You will need to have a recent version of Node.js installed. See <a href="https://nodejs.org">https://nodejs.org</a> for instructions on how to install and update Node.js for your platform.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Creating a new SvelteKit project</h1>
<p>In this section, you’ll use<a id="_idIndexMarker000"/> the default method for creating a new SvelteKit project, which uses the <code>npm create</code> command. (For reference, you can also check the official documentation at <a href="https://kit.svelte.dev/docs/creating-a-project">https://kit.svelte.dev/docs/creating-a-project</a>.)</p>
<p>The project we are building is called <em class="italic">Birthdays</em> and the npm package name is <code>birthdays</code>. It will be introduced properly in <a href="B19611_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing the </em><em class="italic">Red-Green-Refactor Workflow</em>.</p>
<p class="callout-heading">SvelteKit 1.0</p>
<p class="callout">These instructions were valid at the time of <a id="_idIndexMarker001"/>writing, for SvelteKit 1.0. It’s likely things will improve in time, so you may find some of the later instructions will become unnecessary or may no longer work. Check the book’s GitHub repository for the most up-to-date instructions.</p>
<p>For now, we’ll concentrate <a id="_idIndexMarker002"/>on the mechanics of building a new project:</p>
<ol>
<li>Start by opening a Terminal window in your usual work location (for me, this is <code>~/work</code> on my Mac). Then type the following commands:<pre class="source-code">
<strong class="bold">mkdir birthdays</strong>
<strong class="bold">cd birthdays</strong>
<strong class="bold">npm create svelte@latest</strong></pre></li>
</ol>
<p>If this is the first Svelte project you’ve created, you’ll be presented with the following message from npm:</p>
<pre class="source-code">
<strong class="bold">Need to install the following packages:</strong>
<strong class="bold">  create-svelte@2.1.0</strong>
<strong class="bold">Ok to proceed? (y)</strong></pre>
<ol>
<li value="2">Answer <code>y</code> to that. You’ll see a bunch more questions, which we’ll go through individually:<pre class="source-code">
<strong class="bold">create-svelte version 2.1.0</strong>
<strong class="bold">Welcome to SvelteKit!</strong>
<strong class="bold">? Where should we create your project?</strong>
<strong class="bold">  (leave blank to use current directory) ›</strong></pre></li>
<li>Since you’re already in the <code>birthdays</code> directory, just leave this blank, and hit <em class="italic">Enter</em>. Next, you’ll be asked about which app template you’d like to use:<pre class="source-code">
<strong class="bold">? Which Svelte app template? › - Use arrow-keys. Return to submit.</strong>
<strong class="bold">    </strong><strong class="bold">SvelteKit demo app</strong>
<strong class="bold">❯</strong><strong class="bold">   Skeleton project - Barebones scaffolding for your new SvelteKit app</strong>
<strong class="bold">    Library skeleton project</strong></pre></li>
<li>Choose <code>Skeleton project</code>. Next, you’ll be<a id="_idIndexMarker003"/> asked about TypeScript:<pre class="source-code">
<strong class="bold">? Add type checking with TypeScript? › - Use arrow-keys. Return to submit.</strong>
<strong class="bold">    Yes, using JavaScript with JSDoc comments</strong>
<strong class="bold">    Yes, using TypeScript syntax</strong>
<strong class="bold">❯</strong><strong class="bold">   No</strong></pre></li>
<li>For this question, I’ve chosen <code>No</code>. That’s because this book is about testing techniques, not typing techniques. That’s not to say that this book doesn’t apply to TypeScript projects – it most certainly does – just that typing is not the topic at hand.</li>
</ol>
<p class="callout-heading">If you want to use TypeScript</p>
<p class="callout">If you’re a seasoned TypeScript developer, please feel free to choose that option instead. The code samples in the book won’t need too much modification except for the additional type definitions, which you’ll need to provide.</p>
<ol>
<li value="6">Finally, you’ll be asked <a id="_idIndexMarker004"/>about extra package dependencies:<pre class="source-code">
<strong class="bold">? Add ESLint for code linting? › No / Yes</strong>
<strong class="bold">? Add Prettier for code formatting? › No / Yes</strong>
<strong class="bold">? Add Playwright for browser testing? › No / Yes</strong>
<strong class="bold">    </strong><strong class="bold">✔</strong><strong class="bold"> Add Vitest for unit testing? … No / Yes</strong></pre></li>
<li>Choose <code>Yes</code> as the answer to all these questions. Although we won’t mention ESLint in this book, it’s always good to have. And we’ll need Playwright and Vitest.</li>
</ol>
<p>You’ll then see a summary of all your choices, followed by a <code>Next </code><code>steps</code> list:</p>
<pre class="source-code">
<strong class="bold">Your project is ready!</strong>
<strong class="bold">✔</strong><strong class="bold"> ESLint</strong>
<strong class="bold">  </strong><strong class="bold">https://github.com/sveltejs/eslint-plugin-svelte3</strong>
<strong class="bold">✔</strong><strong class="bold"> Prettier</strong>
<strong class="bold">  https://prettier.io/docs/en/options.xhtml</strong>
<strong class="bold">  https://github.com/sveltejs/prettier-plugin-svelte#options</strong>
<strong class="bold">✔</strong><strong class="bold"> Playwright</strong>
<strong class="bold">  https://playwright.dev</strong>
<strong class="bold">✔</strong><strong class="bold"> Vitest</strong>
<strong class="bold">  https://vitest.dev</strong>
<strong class="bold">Install community-maintained integrations:</strong>
<strong class="bold">  https://github.com/svelte-add/svelte-adders</strong>
<strong class="bold">Next steps:</strong>
<strong class="bold">  1: npm install (or pnpm install, etc)</strong>
<strong class="bold">  2: git init &amp;&amp; git add -A &amp;&amp; git commit -m "Initial commit" (optional)</strong>
<strong class="bold">  3: npm run dev -- --open</strong></pre>
<p>We’ll perform <a id="_idIndexMarker005"/>these next steps but before we do that, we’ll run some extra verification steps. It’s always good to check your work.</p>
<p>Type <code>npm install</code> into the Terminal and confirm that everything is installed correctly. Then, go ahead and commit your changes. (If you’ve forked the GitHub repository, you won’t need to use the <code>git </code><code>init</code> command.)</p>
<p class="callout-heading">Committing early and often</p>
<p class="callout">It’s a good idea to be checking in your work very often. While you’re learning the TDD approach to testing, it can be helpful to check in after every single test. This might seem like a lot but it will help you backtrack in case you get stuck.</p>
<p>Then, run <code>npm run dev – –open</code>. It should open your web browser and show you a <code>"Welcome to </code><code>SvelteKit"</code> message.</p>
<p>You can then close the browser and hit <em class="italic">Ctrl</em> + <em class="italic">C</em> in the Terminal to stop the web server.</p>
<p>Next, let’s verify the Playwright and Vitest dependencies.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Installing and running Playwright</h2>
<p>Although we won’t use<a id="_idIndexMarker006"/> Playwright in this chapter, it’s a good idea to get it installed <a id="_idIndexMarker007"/>and verify that it’s working.</p>
<p>Start by running <code>npm test</code> at the command line:</p>
<pre class="source-code">
work/birthdays % npm test
&gt; birthdays@0.0.1 test
&gt; playwright test
Running 1 test using 1 worker
[WebServer]
[WebServer]
[WebServer] Generated an empty chunk: "hooks".
[WebServer]
  ✘  1 test.js:3:1 › index page has expected h1 (7ms)
  1) test.js:3:1 › index page has expected h1 =============================================
    browserType.launch: Executable doesn't exist at /Users/daniel/Library/Caches/ms-playwright/chromium-1041/chrome-mac/Chromium.app/Contents/MacOS/Chromium
    ...
  1 failed
    test.js:3:1 › index page has expected h1 ============================================</pre>
<p>If you’ve never installed <a id="_idIndexMarker008"/>Playwright before, you’ll see a message like the<a id="_idIndexMarker009"/> preceding one.</p>
<p>Playwright has its own environment <a id="_idIndexMarker010"/>setup to do, such as installing Chromium onto <a id="_idIndexMarker011"/>your machine. You can install it with the following command:</p>
<pre class="source-code">
npx playwright install</pre>
<p>Then, trying <code>npm test</code> again should give you the following output, showing that the one example test that’s included is passing:</p>
<pre class="source-code">
&gt; birthdays@0.0.1 test
&gt; playwright test
Running 1 test using 1 worker
[WebServer]
[WebServer]
[WebServer] Generated an empty chunk: "hooks".
[WebServer]
  ✓  1 test.js:3:1 › index page has expected h1 (307ms)
  1 passed (4s)</pre>
<p>This test, <code>index page has expected h1</code>, is a test for the <code>"Welcome to SvelteKit"</code> message<a id="_idIndexMarker012"/> you saw earlier when you launched the<a id="_idIndexMarker013"/> application in the browser.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Running Vitest</h2>
<p>Running <code>npm run test:unit</code> is the<a id="_idIndexMarker014"/> default<a id="_idIndexMarker015"/> way to run Vitest tests. Try it now:</p>
<pre class="source-code">
work/birthdays % npm run test:unit
&gt; birthdays@0.0.1 test:unit
&gt; vitest
 DEV  v0.25.8 /Users/daniel/work/birthdays
 ✓ src/index.test.js (1)
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  15:56:18
   Duration  737ms (transform 321ms, setup 0ms, collect 16ms, tests 2ms)
 PASS  Waiting for file changes...
       press h to show help, press q to quit</pre>
<p>This automatically puts you in watch mode, which means any changes to the filesystem will cause tests to re-run. Press <em class="italic">q</em> to quit this mode. I personally don’t use watch mode and we won’t be <a id="_idIndexMarker016"/>using it in this book. See the <em class="italic">Creating a shell alias</em> section for<a id="_idIndexMarker017"/> a little discussion on why this is.</p>
<p>In the next section, we’ll make the ergonomics of the project a little easier for us.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Preparing your development environment for frequent unit testing</h1>
<p>In this section, we’ll take some configuration actions that will make our test-driven lives much simpler.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Choosing your editor</h2>
<p>Let’s start with your choice of <a id="_idIndexMarker018"/>code editor. More than likely, this means a choice between an IDE, such as Visual Studio Code, or a plain text editor, such as Vim or Emacs.</p>
<p>IDEs tend to have lots of bells and whistles and one of those is the built-in test runner, which runs tests for you and integrates test output into the editor itself. On the other hand, plain text editors will require you to have a separate Terminal window for you to enter test commands directly, as you did in the previous section.</p>
<p><em class="italic">Figure 1</em><em class="italic">.1</em> shows how my own setup looks, using Vim and tmux to split windows. The top half of the screen is where I edit my source files, and when I’m ready to run tests, I can switch to the bottom half and enter the <code>test</code> command.</p>
<div><div><img alt="Figure 1.1 – Using tmux and Vim" height="1156" src="img/Figure_1.1_B19611.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Using tmux and Vim</p>
<p><em class="italic">Figure 1</em><em class="italic">.2</em> shows the same <a id="_idIndexMarker019"/>project in Visual Studio Code with the Vitest extension installed. Notice the test runner has a bunch of neat features, such as the ability to filter the test output, and green ticks next to the line numbers of passing tests.</p>
<div><div><img alt="Figure 1.2 – Using Visual Studio Code to run tests" height="1141" src="img/Figure_1.2_B19611.jpg" width="1642"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Using Visual Studio Code to run tests</p>
<p>I think there is a lot to<a id="_idIndexMarker020"/> learn from using a plain editor and Terminal setup, but if you don’t feel comfortable with that, then it’s best to stick to your favorite IDE for now.</p>
<p>The one thing you want to make sure of is that it’s easy and quick to run tests. So, if you’re writing a new test, you want to immediately run it and see it fail. And if you’re making a test pass or refactoring tests, make sure you can quickly re-run tests to check your progress.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Creating a shell alias</h2>
<p>If you’re choosing to<a id="_idIndexMarker021"/> use the Terminal to run tests, then you will almost certainly want to set up an alias to make it simpler to run Vitest unit tests. You’ll recall that there are two commands that you use for running tests: <code>npm test</code> for Playwright tests and the <code>npm run test:unit</code> command for Vitest unit tests.</p>
<p>The style of testing shown in this book follows the classic <em class="italic">test pyramid</em> approach to testing, which states that we should have lots of little unit tests (in Vitest) and far fewer system tests (in Playwright).</p>
<p>So, given that we’ll be working much more frequently with Vitest, doesn’t it make sense to have the <em class="italic">shorter</em> <code>test</code> command be the one that runs unit tests?</p>
<p>The solution that I use is a shell<a id="_idIndexMarker022"/> alias, <code>v</code>, that invokes Vitest. If you wanted to use the standard watch mode, you’d set up the shell alias to run this command:</p>
<pre class="source-code">
npx vitest</pre>
<p>However, because I don’t want to use watch mode, I set it up to use this command:</p>
<pre class="source-code">
npx vitest run</pre>
<p>I‘d suggest you use this version, at least while you read through this book. I find that watch mode tends to break silently, especially when you’re in the first stages of setting up a project. To avoid confusion, better to just invoke the test command when you’re ready.</p>
<p>On my Mac, my default shell is <code>zsh</code>, which configures its shell aliases in the <code>~/.zshrc</code> file. You can add that alias to the file using the following commands:</p>
<pre class="source-code">
echo 'alias v="npx vitest run"' &gt;&gt; ~/.zshrc
source ~/.zshrc</pre>
<p>Now, you can simply type the <code>v</code> command to run your Vitest unit tests. You can also use this to run a single test file, like this:</p>
<pre class="source-code">
v src/index.tests.js</pre>
<p>This is a handy way to run just a small part of your test suite.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Changing the test runner to report each test name</h2>
<p>Recall that when we ran our <a id="_idIndexMarker023"/>Vitest unit tests, the test report told us the filename of the test suite that was run, together with some summary information:</p>
<pre class="source-code">
 DEV  v0.25.8 /Users/daniel/work/birthdays
 ✓ src/index.test.js (1)
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  15:56:18
   Duration  737ms (transform 321ms, setup 0ms, collect 16ms, tests 2ms)</pre>
<p>It turns out this isn’t enough – we want to see test names too, just like how the Playwright test told us the description<a id="_idIndexMarker024"/> of the test that was passing.</p>
<p>Open the <code>vite.config.js</code> file and add a new <code>reporter</code> property that is set to <code>verbose</code>, as shown in the following code block:</p>
<pre class="source-code">
 const config = {
   plugins: [sveltekit()],
   test: {
     ...,
     <strong class="bold">reporter: 'verbose'</strong>
   }
 };</pre>
<p class="callout-heading">Be careful</p>
<p class="callout">If you had left your test runner running in watch mode, you’ll need to restart it at this point, and at any other point in which you modify the configuration.</p>
<p>Now, running tests at the command line using the <code>v</code> command will give this:</p>
<pre class="source-code">
 RUN  v0.25.8 /Users/daniel/work/birthdays
 ✓ src/index.test.js (1)
   ✓ sum test (1)
     ✓ adds 1 + 2 to equal 3
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  11:02:05
   Duration  905ms (transform 320ms, setup 1ms, collect 16ms, tests 2ms)</pre>
<p>Much better!</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Watching the test fail</h2>
<p>We’re almost done with<a id="_idIndexMarker025"/> configuring Vitest, but before continuing, let’s check that the test actually tests what we want it to test. This is an important concept with TDD: if you’ve never seen a test fail, how do you know it tests the right thing?</p>
<p>Open <code>src/index.test.js</code> and take a look:</p>
<pre class="source-code">
import { describe, it, expect } from 'vitest';
describe('sum test', () =&gt; {
  it('adds 1 + 2 to equal 3', () =&gt; {
    expect(1 + 2).toBe(3);
  });
});</pre>
<p>Make a change to the <code>expect</code> statement, like the one shown here:</p>
<pre class="source-code">
expect(2 + 2).toBe(3);</pre>
<p>Now if you run the test, you should see a failure:</p>
<pre class="source-code">
<strong class="bold">❯</strong> src/index.test.js:5:17
      3| describe('sum test', () =&gt; {
      4|  it('adds 1 + 2 to equal 3', () =&gt; {
      5|   expect(2 + 2).toBe(3);
       |                 ^
      6|  });
      7| });
  - Expected   "3"
  + Received   "4"</pre>
<p>Brilliant – our test runner seems to be in working order. You can go ahead and undo the change to the test, and watch it go green again. That’s it for the basic editor configuration.</p>
<h3>Test file location – src or test?</h3>
<p>In many other programming environments, test files are kept apart from application source files. A separate directory named something like <code>tests</code> or <code>specs</code> is used to house all <a id="_idIndexMarker026"/>executable test scripts.</p>
<p>There can be a couple of advantages to that. First, it can avoid packaging tests with application code when it comes to building deployable units. However, Svelte (and JavaScript in general) doesn’t suffer from this problem because only modules referenced by the application entry point will be bundled.</p>
<p>Second, having a separate directory avoids the mindset of <em class="italic">one test file per module</em>. Not all modules need unit tests: if a unit exists as a part of a larger unit, we’ll often just write tests for the top-level unit and those tests will also provide coverage for the lower-level unit. Conversely, sometimes it’s helpful to have two (or more!) test files for a single module.</p>
<p>That’s especially true when using component mocks that wipe out a component mock for an entire module. You might want a test file that mocks a component, and another test file where the component isn’t mocked. We’ll look at component mocks in <a href="B19611_12.xhtml#_idTextAnchor134"><em class="italic">Chapter 12</em></a>, <em class="italic">Using Component Mocks to </em><em class="italic">Clarify Tests</em>.</p>
<p>The current SvelteKit approach is to keep Vitest test files housed within the <code>src</code> directory. Partly, this is<a id="_idIndexMarker027"/> to avoid confusion with Playwright tests, which <em class="italic">do</em> live in a separate directory, named <code>tests</code>. (We’ll see Playwright tests starting from <a href="B19611_03.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Loading Data into </em><em class="italic">a Route</em>).</p>
<p>This book continues with that style, but I would encourage you to explore and adopt whichever style you feel most comfortable with.</p>
<p>In the next section, we’ll add support for the kinds of tests we’ll be writing throughout the book.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Configuring support for Svelte component tests</h1>
<p>A Svelte <em class="italic">component test</em> is one that, perhaps <a id="_idIndexMarker028"/>unsurprisingly, tests a Svelte component. For this, we need access to a <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), which isn’t part of the standard Node.js<a id="_idIndexMarker029"/> environment. We’ll also need some additional packages for writing unit test expectations against the DOM.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Installing jsdom and testing library helpers</h2>
<p>At the Terminal, run the following<a id="_idIndexMarker030"/> command to install the <code>jsdom</code> package and <code>@testing-library</code> packages that we’ll use in<a id="_idIndexMarker031"/> our unit tests:</p>
<pre class="source-code">
npm install --save-dev \
  jsdom \
  @testing-library/svelte \
  @testing-library/jest-dom \
  @testing-library/user-event</pre>
<p>If you’re using TypeScript, at this point, you may wish to add packages containing type definitions.</p>
<p>Next, create a new file named <code>src/vitest/registerMatchers.js</code> with the following content. It ensures that <a id="_idIndexMarker032"/>the matchers we’ll be using are available for use via the <code>expect</code> function:</p>
<pre class="source-code">
import matchers from '@testing-library/jest-dom/matchers';
import { expect } from 'vitest';
expect.extend(matchers);</pre>
<p>Then, update <code>vite.config.js</code> to add a new <code>environment</code> property, which installs <code>jsdom</code> correctly, and<a id="_idIndexMarker033"/> also a <code>setupFiles</code> property, which ensures the file defined previously is loaded (and invoked) just before the test suites are loaded:</p>
<pre class="source-code">
 const config = {
   plugins: [sveltekit()],
   test: {
     ...,
     reporter: 'verbose',
<strong class="bold">     environment: 'jsdom',</strong>
<strong class="bold">     setupFiles: ['./src/vitest/registerMatchers.js']</strong>
   }
 };</pre>
<p>That’s it for the basic setup. Now let’s test it out.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Writing a test for the DOM</h2>
<p>Open the <code>src/index.test.js</code> file and<a id="_idIndexMarker034"/> add the following<a id="_idIndexMarker035"/> test definition, inside the <code>describe</code> block. This test makes use of the <code>document</code> object that is created for us by the <code>jsdom</code> package, and the <code>toHaveTextContent</code> matcher that is provided by the <code>@</code><code>testing-library/jest-dom</code> package:</p>
<pre class="source-code">
it('renders hello into the document', () =&gt; {
  document.body.innerHTML =
    '&lt;h1&gt;Hello, world!&lt;/h1&gt;';
  expect(document.body).toHaveTextContent(
    'Hello, world!'
  );
});</pre>
<p>Now, if you run the test, you<a id="_idIndexMarker036"/> should see it pass. But, just as you did with the first test, it’s important to confirm the test actually tests what it says it does. Change the test by commenting out or deleting the first line of the test, and then re-running the test runner.</p>
<p>You should see an output as follows:</p>
<pre class="source-code">
 FAIL  src/index.test.js &gt; sum test &gt; renders hello into the document
Error: expect(element).toHaveTextContent()
Expected element to have text content:
  Hello, world!
Received:
 <strong class="bold">❯</strong> src/index.test.js:9:25
      7|
      8|  it('renders hello into the document', () =&gt; {
      9|   expect(document.body).toHaveTextContent(
       |                         ^
     10|    'Hello, world!'
     11|   );</pre>
<p>That proves the test is working. You can <a id="_idIndexMarker037"/>go ahead and undo the breaking change you made.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Writing a first Svelte component test</h2>
<p>Next, let’s write an actual Svelte<a id="_idIndexMarker038"/> component and test that out. Create a new file named <code>src/Hello.svelte</code> with the following content:</p>
<pre class="source-code">
&lt;script&gt;
  export let name;
&lt;/script&gt;
&lt;p&gt;Hello, {name}!&lt;/p&gt;</pre>
<p>Then, go back to the <code>src/index.test.js</code> file and refactor your test to use this new component. To do that, replace the call to <code>document.outerHTML</code> with a call to the <code>render</code> function, like this:</p>
<pre class="source-code">
it('renders hello into the document', () =&gt; {
  <strong class="bold">render(Hello, { name: 'world' });</strong>
  expect(document.body).toHaveTextContent(
    'Hello, world!'
  );
});</pre>
<p>This <code>render</code> function comes from the <code>@testing-library/svelte</code> package. Import that now, along with an import for the <code>Hello</code> component, placed at the top of the file:</p>
<pre class="source-code">
import { render } from '@testing-library/svelte';
import Hello from './Hello.svelte';</pre>
<p>Check that the test still passes with the refactor.</p>
<p>Then, add this third test, which <a id="_idIndexMarker039"/>verifies that the <code>name</code> prop in the component is being used to verify the output:</p>
<pre class="source-code">
it('renders hello, svelte', () =&gt; {
  render(Hello, { name: 'Svelte' });
  expect(document.body).toHaveTextContent(
    'Hello, Svelte!'
  );
});</pre>
<p>Run the test and make sure it passes.</p>
<p>Now, go ahead and comment out the <code>render</code> call in the last test. You might think that the test fails with an error saying nothing was rendered on-screen. But let’s see what happens:</p>
<pre class="source-code">
Error: expect(element).toHaveTextContent()
Expected element to have text content:
  Hello, Svelte!
Received:
  Hello, world!</pre>
<p>Hold on a second; is this what we expected? This test didn’t ever print out a <code>Hello, world!</code> message so why is the test expectation picking it up?</p>
<p>It turns out that our tests share the same <code>document</code> object, which is clearly not good for test independence. Imagine if the second test also expected to see <code>Hello, world!</code> rather than <code>Hello, Svelte!</code>. It would have passed by virtue of the first test running. We need to do something about this.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Ensuring the DOM is cleared after each test run</h2>
<p>We want to make sure that every<a id="_idIndexMarker040"/> test gets its own clean version of the DOM. We can do this by using the <code>cleanup</code> function.</p>
<p>Create a new file named <code>src/vitest/cleanupDom.js</code>:</p>
<pre class="source-code">
import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/svelte';
afterEach(cleanup);</pre>
<p>Then, insert that into the <code>setupFiles</code> property in <code>vite.config.js</code>:</p>
<pre class="source-code">
const config = {
  ...,
  test: {
    ...,
    setupFiles: [
<strong class="bold">      </strong><strong class="bold">'./src/vitest/cleanupDom.js',</strong>
      './src/vitest/registerMatchers.js'
    ]
  }
};</pre>
<p>Now, if you run your failing test again, you should see that the <code>Hello, world!</code> message no longer appears.</p>
<p>Before continuing, uncomment the <code>render</code> call and check your tests are back in an all-green state.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Restoring mocks automatically</h2>
<p>There’s one final piece of configuration<a id="_idIndexMarker041"/> we need in <code>vite.config.js</code>. Add the <code>restoreMocks</code> property, as shown here:</p>
<pre class="source-code">
const config = {
  ...,
  test: {
    ...,
<strong class="bold">    restoreMocks: true</strong>
  }
};</pre>
<p>This is also important for test independence and will be important in <a href="B19611_11.xhtml#_idTextAnchor127"><em class="italic">Chapter 11</em></a>, <em class="italic">Replacing Behavior with a Side-By-Side Implementation</em>, when we begin using the <code>vi.fn</code> function for building test doubles.</p>
<p>That covers all the configuration you need for the rest of the book. The next section touches briefly on some optional configurations you might want to consider.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Optional configuration</h1>
<p>In this section, we’ll look at configuring Prettier and setting up more appropriate tab widths on the Terminal. These settings mirror the print settings that are used in this book.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Configuring Prettier’s print width</h2>
<p>Due to the constraint of the <a id="_idIndexMarker042"/>physical pages in this book, I have set the <code>printWidth</code> setting of Prettier to 54 characters, and all code samples are formatted with that setting.</p>
<p>I also think the default value, <code>100</code>, is too high. I like short columns of text as I find them easier to share and read in all sorts of environments – such as on mobile devices, where it’s much easier to scroll vertically than it is horizontally.</p>
<p>Also, having extra vertical space comes in handy when you are pairing with other developers and you want to refer to particular line numbers (assuming you have line numbers turned on).</p>
<p>In <code>.prettierrc</code>, you can set the print width with the following addition:</p>
<pre class="source-code">
{
  "printWidth": 54,
  ...
}</pre>
<p>You might be more<a id="_idIndexMarker043"/> comfortable with something in the <code>60</code> to <code>80</code> range.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Reducing the tab width in the Terminal</h2>
<p>The Svelte community has a<a id="_idIndexMarker044"/> preference for tabs over spaces because tabs are better for screen readers. Unfortunately, a lot of Terminals and shell programs are set up for a default tab width of eight characters, which is way too many for my liking.</p>
<p>Although every Terminal is different, the one solid piece of advice I have is to set <code>git config</code> to use <code>less</code> as its pager, with tab stops at positions <code>1</code>, <code>3</code>, <code>5</code>, and <code>7</code>:</p>
<pre class="source-code">
git config --global core.pager 'less -x1,3,5,7'</pre>
<p>This makes <code>git diff</code> and <code>git show</code> much more bearable, and these are two commands I use extremely frequently.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
<p>This chapter has taken a detailed look at the various parts of a base SvelteKit project, showing how Playwright and Vitest are added, together with the additional dependencies you’ll need to write Svelte component tests.</p>
<p>We’ve also looked at some of the ways you can set up your development environment to help you be productive.</p>
<p>You’re now ready to start exploring TDD practices, starting with the <em class="italic">Red-Green-Refactor Cycle -&gt; Workflow</em> in the next chapter.</p>
</div>
</div></body></html>