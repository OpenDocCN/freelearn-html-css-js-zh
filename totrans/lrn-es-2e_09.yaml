- en: JavaScript on the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello there! So far, we've learned and created a solid understanding of JavaScript,
    how it works under the hood, and what it contains. But how do we actually use
    it today? How do we start building something? This is the chapter that deals with
    this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 and the rise of modern JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is **Document Object Model **(**DOM**)?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM methods/properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern JavaScript browser APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Visibility API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigator API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipboard API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas API - the web's drawing board
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 and the rise of modern JavaScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5 specification arrived in 2008\. HTML5, however, was so technologically
    advanced in 2008 that it was predicted that it would not be ready till at least
    2022! However, that turned out to be incorrect, and here we are, with fully supported
    HTML5 and ES6/ES7/ES8-supported browsers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of APIs used by HTML5 go hand in hand with JavaScript. Before looking
    at those APIs, let us understand a little about how JavaScript sees the web. This''ll
    eventually put us in a strong position to understand various interesting, JavaScript-related
    things such as the Web Workers API, which deserves its own chapter (spoiler alert:
    It is included in this book!)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The HTML DOM
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTML DOM is a tree version of how the document looks. Here is a very simple
    example of an HTML document:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s how its tree version will look:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44939779-ea75-4738-8a37-afa1e574cefc.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: The previous diagram is just a rough representation of the DOM tree. HTML tags
    consist of **head** and **body**; furthermore, the `<body>` tag consists of a
    `<p>` tag, whereas the `<head>` tag consists of the `<title>` tag. Simple!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has access to the DOM directly, and can modify the connections between
    these nodes, add nodes, remove nodes, change contents, attach event listeners,
    and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: What is the Document Object Model (DOM)?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, the DOM is a way to represent HTML or XML documents as nodes. This
    makes it easier for other programming languages to connect to a DOM-following
    page and modify it accordingly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, DOM is not a programming language. DOM provides JavaScript with
    a way to interact with web pages. You can think of it as a standard. Every element
    is part of the DOM tree, which can be accessed and modified with APIs exposed
    to JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: DOM is not restricted to being accessed only by JavaScript. It is language-independent
    and there are several modules available in various languages to parse DOM (just
    like JavaScript) including PHP, Python, Java, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'As said previously, DOM provides JavaScript with a way to interact with it.
    How? Well, accessing DOM is as easy as accessing predefined objects in JavaScript:
    `document`. The DOM API specifies what you''ll find inside the `document` object.
    The `document` object essentially gives JavaScript access to the DOM tree formed
    by your HTML document. If you notice, you cannot access any element at all without
    actually accessing the `document` object first.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: DOM methods/properties
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All HTML elements are objects in JavaScript. The most commonly used object
    is the `document` object. It has the whole DOM tree attached to it. You can query
    for elements on that. Let''s look at some very common examples of these methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`getElementById` method'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByTagName` method'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByClassName` method'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querySelector` method'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querySelectorAll` method'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By no means is this an exhaustive list of all methods available. However, this
    list should at least get you started with DOM manipulation. Use MDN as your reference
    for various other methods. Here's the link: [https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods](https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Using the getElementById method
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In HTML, you can assign an element an `ID` and then retrieve it back in JavaScript
    for manipulation. Here''s how:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have that, you can access the properties of this object, which in turn
    actually modifies the element on the screen accordingly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Using the getElementsByTagName method
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `ID` method, `getElementsByTagName(<Name Of Tag>)` gets us elements
    with a couple of differences:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: It gives you a collection of elements instead of a single element (array)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It queries for elements on the basis of their tag names and not `ID` values
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the word `getElements`.It returns us a bunch of elements. Therefore,
    we pick up the first element from the `NodeList` and set its contents to `Cool`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`innerHTML` is used to change the HTML content inside the element you''re working
    on.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Using the getElementsByClassName method
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getElementsByClassName` method will return elements of the same class
    as a `NodeList` and not an `Array`! `NodeList` is not exactly an `Array`; however,
    it is iterable, and easily convertible into `Array` as well:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As said previously, `tags` is actually a `NodeList`. First, we use a destructuring operator
    and surround it with square brackets to actually convert it into an `Array`. Then
    we use `map` (which we can on `Array`, but cannot on `NodeList`) to iterate over
    every tag, that is, the `<span>` element, and we just console-log the element.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from this code is how we used a destructuring operator in it. You'll
    often find yourself regularly using those important concepts we learned earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Using the querySelector method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `querySelector` method returns an element in the same way as when selecting
    an element through its CSS selector. However, `document.querySelector` returns
    only one element. Therefore, we can operate on it directly once we query for that
    element:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is equivalent to doing `document.querySelector('div').style.color = 'red';`
    if we have only one `<div>` tag in the body.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Using the querySelectorAll method
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like you can get any element with `querySelector`, you can get a bunch
    of elements matching the criteria with `querySelectorAll`. You''ve seen how to
    work with `NodeList` in the `getElementsByClass` method. Try to understand the
    code as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we're converting `NodeList` to `Array` using destructuring. Then we're
    mapping over the array and changing the style of each `<div>` according to the
    value of its data-attr.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Modern JavaScript browser APIs
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 brought a lot of support for some awesome and cool APIs in JavaScript,
    right from the start. Although some APIs were released with HTML5 itself (such
    as the Canvas API), some were added later (such as the Fetch API).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some of these APIs and how to use them with some code examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Page Visibility API - is the user still on the page?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Page Visibility API** allows developers to run specific code whenever
    the page user is on goes in focus or out of foucs. Imagine you run a game-hosting
    site and want to pause the game whenever the user loses focus on your tab. This
    is the way to go!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're adding an event listener to the document; it fires whenever the page is
    changed. Sure, the `pageChanged` function gets an event object as well in the
    argument, but we can simply use the `document.hidden` property, which returns
    a Boolean value depending on the page's visibility at the time the code was called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll add your *pause game* code at `line #1` and your *resume game* code
    at `line #2`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: navigator.onLine API – the user's network status
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `navigator.onLine` API tells you if the user is online or not. Imagine building
    a multiplayer game and you want the game to automatically pause if the user loses
    their internet connection. This is the way to go here!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we're attaching two event listeners to window global. We want to call
    the `state` function whenever the user goes `offline` or `online`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The browser will call the `state` function every time the user goes `offline`
    or `online`. We can access it if the user is `offline` or `online` with `navigator.onLine`,
    which returns a Boolean value of `true` if there's an internet connection, and
    `false` if there's not.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Clipboard API - programmatically manipulating the clipboard
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Clipboard API** finally allows developers to copy to a user''s clipboard
    without those nasty Adobe Flash plugin hacks that were not cross-browser/cross-device-friendly.
    Here''s how you''ll copy a selection to a user''s clipboard:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First of all, we need the user to actually click the button. Once the user clicks
    the button, we call a function that creates a `textarea` in the background using
    the `document.createElement` method. The script then sets the value of the `textarea`
    to the passed text (this is pretty good!) We then focus on that `textarea` and
    select all the contents inside it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Once the contents are selected, we execute a copy with `document.execCommand('copy')`;
    this copies the current selection in the document to the clipboard. Since, right
    now, the value inside the `textarea` is selected, it gets copied to the clipboard.
    Finally, we remove the `textarea` from the document so that it doesn't disrupt
    the document layout.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: You cannot trigger `copy2Clipboard` without user interaction. I mean, obviously
    you can, but `document.execCommand('copy')` will not work if the event does not
    come from the user (click, double-click, and so on). This is a security implementation
    so that a user's clipboard is not messed around with by every website that they
    visit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas API - the web's drawing board
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 finally brought in support for `<canvas>`, a standard way to draw graphics
    on the web! Canvas can be used pretty much for everything related to graphics
    you can think of; from digitally signing with a pen, to creating 3D games on the
    web (3D games require WebGL knowledge, interested? - visit [http://bit.ly/webgl-101](http://bit.ly/webgl-101)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the basics of the Canvas API with a simple example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This renders the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/460f0d05-4c59-49c0-b610-4edf05c27ec2.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: How does it do this?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, `document.getElementById('canvas')` gives us the reference to the canvas
    on the document.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we get the **context **of the canvas. This is a way to say what I want
    to do with the canvas. You could put a 3D value there, of course! That is indeed
    the case when you're doing 3D rendering with WebGL and canvas.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a reference to our context, we can do a bunch of things and add
    methods provided by the API out-of-the-box. Here we moved the cursor to the (0,
    0) coordinates.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we drew a line till (100,100) (which is basically a diagonal on the square
    canvas).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we called stroke to actually draw that on our canvas. Easy!
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Canvas is a wide topic and deserves a book of its own! If you're interested
    in developing awesome games and apps with Canvas, I recommend you start off with
    MDN docs: [http://bit.ly/canvas-html5.](http://bit.ly/canvas-html5)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch API - promise-based HTTP requests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the coolest async APIs introduced in browsers is the Fetch API, which
    is the modern replacement for the `XMLHttpRequest` API. Have you ever found yourself
    using jQuery just for simplifying AJAX requests with $.ajax? If you have, then
    this is surely a golden API for you, as it is **natively** easier to code and
    read!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, we created a promised version of `XMLHttpRequest` ourselves
    in [Chapter 4](d37a4519-f5c0-4f5b-a3b4-df5e0091949e.xhtml), *Asynchronous Programming*.
    However, `fetch` comes natively, hence, there are performance benefits. Let''s
    see how it works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Awesome! So `fetch` uses promises! If that's the case, we can combine it with
    async/await to make it look completely synchronous and easy to read!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The line `console.log(image1)` will print the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f355a7bf-0469-4cf0-a82b-578d2138be98.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: You can see the `image1` response provides tons of information about the request.
    It has an interesting field body, which is actually a `ReadableStream`, and a
    byte stream of data that can be cast to a  **Binary Large Object** (**BLOB**)
    in our case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: A `blob` object represents a file-like object of immutable and raw data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: After getting the `Response`, we convert it into a `blob` object so that we
    can actually use it as an image. Here, fetch is actually fetching us the image
    directly so we can serve it to the user as a `blob` (without hot-linking it to
    the main website).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Thus, this could be done on the server side, and `blob` data could be passed
    down a WebSocket or something similar.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Fetch API customization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Fetch API is highly customizable. You can even include your own headers
    in the request. Suppose you''ve got a site where only authenticated users with
    a valid token can access an image. Here''s how you''ll add a custom header to
    your request:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we added a custom header to our `Request` and then created something
    called a `Request` object (an object that has information about our `Request`).
    The first parameter, that is, `http://myawesomewebsite.awesometld/secretimage.jpg`,
    is the URL and the second is the configuration. Here are some other configuration
    options:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Credentials**: Used to pass cookies in a **Cross-Origin Resource Sharing**
    (**CORS**)-enabled server on cross-domain requests.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: Specifies request methods (GET, POST, HEAD, and so on).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Headers**:Headers associated with the request.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: A security feature that consists of a (possibly) SHA-256 representation
    of the file you''re requesting, in order to verify whether the request has been
    tampered with (data is modified) or not. Probably not a lot to worry about unless
    you''re building something on a very large scale and not on HTTPS.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirect**: Redirect can have three values:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow: Will follow the URL redirects'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Error: Will throw an error if the URL redirects
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual: Doesn't follow redirect but returns a filtered response that wraps the
    redirect response
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Referrer**: the URL that appears as a referrer header in the HTTP request.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and modifying history with the history API
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access a user''s history to some level and modify it according to your
    needs using the `history` API. It consists of the length and state properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In your case, the `length` could obviously be different depending on how many
    pages you've visited from that particular tab.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`history.state` can contain anything you like (we''ll come to its use case
    soon). Before looking at some handy history methods, let us take a look at the `window.onpopstate`
    event.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Handling window.onpopstate events
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The`window.onpopstate` event is fired automatically by the browser when a user
    navigates between history states that a developer has set. This event is important
    to handle when you push to history object and then later retrieve information whenever
    the user presses the back/forward button of the browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''ll program a simple `popstate` event:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we'll discuss some methods associated with the `history` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Modifying history - the history.go(distance) method
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`history.go(x)` is equivalent to the user clicking his forward button `x` times
    in the browser. However, you can specify the distance to move, that is `history.go(5);`
    . This equivalent to the user hitting the forward button in the browser five times.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can specify negative values as well to make it move backward.
    Specifying 0 or no value will simply refresh the page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Jumping ahead - the history.forward() method
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is simply the equivalent of `history.go(1)`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'This is handy when you want to just push the user to the page he/she is coming
    from. One use case of this is when you can create a full-screen immersive web
    application and on your screen there are some minimal controls that play with
    the history behind the scenes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Going back - the history.back() method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is simply the equivalent of `history.go(-1)`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: A negative number, makes the history go backwards. Again, this is just a simple
    (and numberless) way to go back to a page the user came from. Its application
    could be similar to a forward button, that is, creating a full-screen web app
    and providing the user with an interface to navigate by.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Pushing on the history - history.pushState()
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is really fun. You can change the browser URL without hitting the server
    with an HTTP request. If you run the following JS in your browser, your browser
    will change the path from whatever it is (`domain.com/abc/egh`) to  `/i_am_awesome`
    (`domain.com/i_am_awesome`) without actually navigating to any page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The History API doesn't care whether the page actually exists on the server
    or not. It'll just replace the URL as it is instructed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `popstate` event when triggered with the browser''s back/forward button,
    will fire the function below and we can program it like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To run this code, run the `onpopstate` event first, then the two lines of `history.pushState` previously.
    Then press your browser''s back button. You should see something like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: which is the information related to the parent state. Press back button one
    more time and you'll see the message `Root State`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`pushState` does not fire `onpopstate` event. Only browsers'' back/forward
    buttons do.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Pushing on the history stack - history.replaceState()
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在历史记录栈上推进 - history.replaceState()
- en: The `history.replaceState()` method is exactly like `history.pushState()`, the
    only difference is that it replaces the current page with another, that is, if
    you use `history.pushState()` and press the back button, you'll be directed to
    the page you came from.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`history.replaceState()` 方法与 `history.pushState()` 方法完全相同，唯一的区别是它会用另一个页面替换当前页面，也就是说，如果您使用
    `history.pushState()` 并按下后退按钮，您将被导向您之前所在的页面。'
- en: 'However, when you use `history.replaceState()` and you press the back button,
    you are not directed to the page you came from because it is replaced with the
    new one on the stack. Here''s an example of working with the `replaceState` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您使用 `history.replaceState()` 并按下后退按钮时，您不会被导向您之前所在的页面，因为它是用栈上的新页面替换的。以下是一个使用
    `replaceState` 方法的示例：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This replaces (instead of pushing) the current state with the new state.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将（而不是推送）当前状态替换为新状态。
- en: Although using the History API directly in your code may not be beneficial to
    you right now, many frameworks and libraries such as React, under the hood, use
    the History API to create a seamless, reload-less, smooth experience for the end
    user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接在您的代码中使用 History API 可能目前对您没有好处，但许多框架和库，如 React，在底层使用 History API 来为最终用户提供无缝、无需重新加载、流畅的体验。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the best APIs introduced by HTML5 and modern
    JavaScript together, and how they are shaping the way people browse and interact
    with websites.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些由 HTML5 和现代 JavaScript 一起引入的最佳 API，以及它们如何塑造人们浏览和与网站交互的方式。
- en: In the next chapter, we'll take a brief overview of the HTTP protocol and some
    storage APIs available in JavaScript that can be used to store data locally and
    communicate with the server. Let's go!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要概述 HTTP 协议以及 JavaScript 中可用的某些存储 API，这些 API 可以用于本地存储数据和与服务器通信。让我们开始吧！
