- en: JavaScript on the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello there! So far, we've learned and created a solid understanding of JavaScript,
    how it works under the hood, and what it contains. But how do we actually use
    it today? How do we start building something? This is the chapter that deals with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 and the rise of modern JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is **Document Object Model **(**DOM**)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM methods/properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern JavaScript browser APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Visibility API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigator API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipboard API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas API - the web's drawing board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 and the rise of modern JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5 specification arrived in 2008\. HTML5, however, was so technologically
    advanced in 2008 that it was predicted that it would not be ready till at least
    2022! However, that turned out to be incorrect, and here we are, with fully supported
    HTML5 and ES6/ES7/ES8-supported browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of APIs used by HTML5 go hand in hand with JavaScript. Before looking
    at those APIs, let us understand a little about how JavaScript sees the web. This''ll
    eventually put us in a strong position to understand various interesting, JavaScript-related
    things such as the Web Workers API, which deserves its own chapter (spoiler alert:
    It is included in this book!)'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTML DOM is a tree version of how the document looks. Here is a very simple
    example of an HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how its tree version will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44939779-ea75-4738-8a37-afa1e574cefc.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous diagram is just a rough representation of the DOM tree. HTML tags
    consist of **head** and **body**; furthermore, the `<body>` tag consists of a
    `<p>` tag, whereas the `<head>` tag consists of the `<title>` tag. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has access to the DOM directly, and can modify the connections between
    these nodes, add nodes, remove nodes, change contents, attach event listeners,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Document Object Model (DOM)?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, the DOM is a way to represent HTML or XML documents as nodes. This
    makes it easier for other programming languages to connect to a DOM-following
    page and modify it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, DOM is not a programming language. DOM provides JavaScript with
    a way to interact with web pages. You can think of it as a standard. Every element
    is part of the DOM tree, which can be accessed and modified with APIs exposed
    to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: DOM is not restricted to being accessed only by JavaScript. It is language-independent
    and there are several modules available in various languages to parse DOM (just
    like JavaScript) including PHP, Python, Java, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As said previously, DOM provides JavaScript with a way to interact with it.
    How? Well, accessing DOM is as easy as accessing predefined objects in JavaScript:
    `document`. The DOM API specifies what you''ll find inside the `document` object.
    The `document` object essentially gives JavaScript access to the DOM tree formed
    by your HTML document. If you notice, you cannot access any element at all without
    actually accessing the `document` object first.'
  prefs: []
  type: TYPE_NORMAL
- en: DOM methods/properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All HTML elements are objects in JavaScript. The most commonly used object
    is the `document` object. It has the whole DOM tree attached to it. You can query
    for elements on that. Let''s look at some very common examples of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getElementById` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByTagName` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByClassName` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querySelector` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querySelectorAll` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By no means is this an exhaustive list of all methods available. However, this
    list should at least get you started with DOM manipulation. Use MDN as your reference
    for various other methods. Here's the link: [https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods](https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods).
  prefs: []
  type: TYPE_NORMAL
- en: Using the getElementById method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In HTML, you can assign an element an `ID` and then retrieve it back in JavaScript
    for manipulation. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you have that, you can access the properties of this object, which in turn
    actually modifies the element on the screen accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Using the getElementsByTagName method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `ID` method, `getElementsByTagName(<Name Of Tag>)` gets us elements
    with a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It gives you a collection of elements instead of a single element (array)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It queries for elements on the basis of their tag names and not `ID` values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice the word `getElements`.It returns us a bunch of elements. Therefore,
    we pick up the first element from the `NodeList` and set its contents to `Cool`.
  prefs: []
  type: TYPE_NORMAL
- en: '`innerHTML` is used to change the HTML content inside the element you''re working
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the getElementsByClassName method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getElementsByClassName` method will return elements of the same class
    as a `NodeList` and not an `Array`! `NodeList` is not exactly an `Array`; however,
    it is iterable, and easily convertible into `Array` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As said previously, `tags` is actually a `NodeList`. First, we use a destructuring operator
    and surround it with square brackets to actually convert it into an `Array`. Then
    we use `map` (which we can on `Array`, but cannot on `NodeList`) to iterate over
    every tag, that is, the `<span>` element, and we just console-log the element.
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from this code is how we used a destructuring operator in it. You'll
    often find yourself regularly using those important concepts we learned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Using the querySelector method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `querySelector` method returns an element in the same way as when selecting
    an element through its CSS selector. However, `document.querySelector` returns
    only one element. Therefore, we can operate on it directly once we query for that
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is equivalent to doing `document.querySelector('div').style.color = 'red';`
    if we have only one `<div>` tag in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Using the querySelectorAll method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like you can get any element with `querySelector`, you can get a bunch
    of elements matching the criteria with `querySelectorAll`. You''ve seen how to
    work with `NodeList` in the `getElementsByClass` method. Try to understand the
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we're converting `NodeList` to `Array` using destructuring. Then we're
    mapping over the array and changing the style of each `<div>` according to the
    value of its data-attr.
  prefs: []
  type: TYPE_NORMAL
- en: Modern JavaScript browser APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 brought a lot of support for some awesome and cool APIs in JavaScript,
    right from the start. Although some APIs were released with HTML5 itself (such
    as the Canvas API), some were added later (such as the Fetch API).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some of these APIs and how to use them with some code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Page Visibility API - is the user still on the page?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Page Visibility API** allows developers to run specific code whenever
    the page user is on goes in focus or out of foucs. Imagine you run a game-hosting
    site and want to pause the game whenever the user loses focus on your tab. This
    is the way to go!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We're adding an event listener to the document; it fires whenever the page is
    changed. Sure, the `pageChanged` function gets an event object as well in the
    argument, but we can simply use the `document.hidden` property, which returns
    a Boolean value depending on the page's visibility at the time the code was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll add your *pause game* code at `line #1` and your *resume game* code
    at `line #2`.'
  prefs: []
  type: TYPE_NORMAL
- en: navigator.onLine API – the user's network status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `navigator.onLine` API tells you if the user is online or not. Imagine building
    a multiplayer game and you want the game to automatically pause if the user loses
    their internet connection. This is the way to go here!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're attaching two event listeners to window global. We want to call
    the `state` function whenever the user goes `offline` or `online`.
  prefs: []
  type: TYPE_NORMAL
- en: The browser will call the `state` function every time the user goes `offline`
    or `online`. We can access it if the user is `offline` or `online` with `navigator.onLine`,
    which returns a Boolean value of `true` if there's an internet connection, and
    `false` if there's not.
  prefs: []
  type: TYPE_NORMAL
- en: Clipboard API - programmatically manipulating the clipboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Clipboard API** finally allows developers to copy to a user''s clipboard
    without those nasty Adobe Flash plugin hacks that were not cross-browser/cross-device-friendly.
    Here''s how you''ll copy a selection to a user''s clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need the user to actually click the button. Once the user clicks
    the button, we call a function that creates a `textarea` in the background using
    the `document.createElement` method. The script then sets the value of the `textarea`
    to the passed text (this is pretty good!) We then focus on that `textarea` and
    select all the contents inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the contents are selected, we execute a copy with `document.execCommand('copy')`;
    this copies the current selection in the document to the clipboard. Since, right
    now, the value inside the `textarea` is selected, it gets copied to the clipboard.
    Finally, we remove the `textarea` from the document so that it doesn't disrupt
    the document layout.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot trigger `copy2Clipboard` without user interaction. I mean, obviously
    you can, but `document.execCommand('copy')` will not work if the event does not
    come from the user (click, double-click, and so on). This is a security implementation
    so that a user's clipboard is not messed around with by every website that they
    visit.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas API - the web's drawing board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 finally brought in support for `<canvas>`, a standard way to draw graphics
    on the web! Canvas can be used pretty much for everything related to graphics
    you can think of; from digitally signing with a pen, to creating 3D games on the
    web (3D games require WebGL knowledge, interested? - visit [http://bit.ly/webgl-101](http://bit.ly/webgl-101)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the basics of the Canvas API with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/460f0d05-4c59-49c0-b610-4edf05c27ec2.png)'
  prefs: []
  type: TYPE_IMG
- en: How does it do this?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, `document.getElementById('canvas')` gives us the reference to the canvas
    on the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we get the **context **of the canvas. This is a way to say what I want
    to do with the canvas. You could put a 3D value there, of course! That is indeed
    the case when you're doing 3D rendering with WebGL and canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a reference to our context, we can do a bunch of things and add
    methods provided by the API out-of-the-box. Here we moved the cursor to the (0,
    0) coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we drew a line till (100,100) (which is basically a diagonal on the square
    canvas).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we called stroke to actually draw that on our canvas. Easy!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Canvas is a wide topic and deserves a book of its own! If you're interested
    in developing awesome games and apps with Canvas, I recommend you start off with
    MDN docs: [http://bit.ly/canvas-html5.](http://bit.ly/canvas-html5)
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch API - promise-based HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the coolest async APIs introduced in browsers is the Fetch API, which
    is the modern replacement for the `XMLHttpRequest` API. Have you ever found yourself
    using jQuery just for simplifying AJAX requests with $.ajax? If you have, then
    this is surely a golden API for you, as it is **natively** easier to code and
    read!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, we created a promised version of `XMLHttpRequest` ourselves
    in [Chapter 4](d37a4519-f5c0-4f5b-a3b4-df5e0091949e.xhtml), *Asynchronous Programming*.
    However, `fetch` comes natively, hence, there are performance benefits. Let''s
    see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! So `fetch` uses promises! If that's the case, we can combine it with
    async/await to make it look completely synchronous and easy to read!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The line `console.log(image1)` will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f355a7bf-0469-4cf0-a82b-578d2138be98.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the `image1` response provides tons of information about the request.
    It has an interesting field body, which is actually a `ReadableStream`, and a
    byte stream of data that can be cast to a  **Binary Large Object** (**BLOB**)
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: A `blob` object represents a file-like object of immutable and raw data.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the `Response`, we convert it into a `blob` object so that we
    can actually use it as an image. Here, fetch is actually fetching us the image
    directly so we can serve it to the user as a `blob` (without hot-linking it to
    the main website).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, this could be done on the server side, and `blob` data could be passed
    down a WebSocket or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch API customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Fetch API is highly customizable. You can even include your own headers
    in the request. Suppose you''ve got a site where only authenticated users with
    a valid token can access an image. Here''s how you''ll add a custom header to
    your request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we added a custom header to our `Request` and then created something
    called a `Request` object (an object that has information about our `Request`).
    The first parameter, that is, `http://myawesomewebsite.awesometld/secretimage.jpg`,
    is the URL and the second is the configuration. Here are some other configuration
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Credentials**: Used to pass cookies in a **Cross-Origin Resource Sharing**
    (**CORS**)-enabled server on cross-domain requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: Specifies request methods (GET, POST, HEAD, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Headers**:Headers associated with the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: A security feature that consists of a (possibly) SHA-256 representation
    of the file you''re requesting, in order to verify whether the request has been
    tampered with (data is modified) or not. Probably not a lot to worry about unless
    you''re building something on a very large scale and not on HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirect**: Redirect can have three values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow: Will follow the URL redirects'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Error: Will throw an error if the URL redirects
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual: Doesn't follow redirect but returns a filtered response that wraps the
    redirect response
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Referrer**: the URL that appears as a referrer header in the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and modifying history with the history API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access a user''s history to some level and modify it according to your
    needs using the `history` API. It consists of the length and state properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In your case, the `length` could obviously be different depending on how many
    pages you've visited from that particular tab.
  prefs: []
  type: TYPE_NORMAL
- en: '`history.state` can contain anything you like (we''ll come to its use case
    soon). Before looking at some handy history methods, let us take a look at the `window.onpopstate`
    event.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling window.onpopstate events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The`window.onpopstate` event is fired automatically by the browser when a user
    navigates between history states that a developer has set. This event is important
    to handle when you push to history object and then later retrieve information whenever
    the user presses the back/forward button of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''ll program a simple `popstate` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll discuss some methods associated with the `history` object.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying history - the history.go(distance) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`history.go(x)` is equivalent to the user clicking his forward button `x` times
    in the browser. However, you can specify the distance to move, that is `history.go(5);`
    . This equivalent to the user hitting the forward button in the browser five times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can specify negative values as well to make it move backward.
    Specifying 0 or no value will simply refresh the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Jumping ahead - the history.forward() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is simply the equivalent of `history.go(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is handy when you want to just push the user to the page he/she is coming
    from. One use case of this is when you can create a full-screen immersive web
    application and on your screen there are some minimal controls that play with
    the history behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Going back - the history.back() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is simply the equivalent of `history.go(-1)`.
  prefs: []
  type: TYPE_NORMAL
- en: A negative number, makes the history go backwards. Again, this is just a simple
    (and numberless) way to go back to a page the user came from. Its application
    could be similar to a forward button, that is, creating a full-screen web app
    and providing the user with an interface to navigate by.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing on the history - history.pushState()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is really fun. You can change the browser URL without hitting the server
    with an HTTP request. If you run the following JS in your browser, your browser
    will change the path from whatever it is (`domain.com/abc/egh`) to  `/i_am_awesome`
    (`domain.com/i_am_awesome`) without actually navigating to any page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The History API doesn't care whether the page actually exists on the server
    or not. It'll just replace the URL as it is instructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `popstate` event when triggered with the browser''s back/forward button,
    will fire the function below and we can program it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this code, run the `onpopstate` event first, then the two lines of `history.pushState` previously.
    Then press your browser''s back button. You should see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: which is the information related to the parent state. Press back button one
    more time and you'll see the message `Root State`.
  prefs: []
  type: TYPE_NORMAL
- en: '`pushState` does not fire `onpopstate` event. Only browsers'' back/forward
    buttons do.'
  prefs: []
  type: TYPE_NORMAL
- en: Pushing on the history stack - history.replaceState()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `history.replaceState()` method is exactly like `history.pushState()`, the
    only difference is that it replaces the current page with another, that is, if
    you use `history.pushState()` and press the back button, you'll be directed to
    the page you came from.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you use `history.replaceState()` and you press the back button,
    you are not directed to the page you came from because it is replaced with the
    new one on the stack. Here''s an example of working with the `replaceState` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This replaces (instead of pushing) the current state with the new state.
  prefs: []
  type: TYPE_NORMAL
- en: Although using the History API directly in your code may not be beneficial to
    you right now, many frameworks and libraries such as React, under the hood, use
    the History API to create a seamless, reload-less, smooth experience for the end
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the best APIs introduced by HTML5 and modern
    JavaScript together, and how they are shaping the way people browse and interact
    with websites.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a brief overview of the HTTP protocol and some
    storage APIs available in JavaScript that can be used to store data locally and
    communicate with the server. Let's go!
  prefs: []
  type: TYPE_NORMAL
