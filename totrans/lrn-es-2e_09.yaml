- en: JavaScript on the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页上的 JavaScript
- en: Hello there! So far, we've learned and created a solid understanding of JavaScript,
    how it works under the hood, and what it contains. But how do we actually use
    it today? How do we start building something? This is the chapter that deals with
    this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你好！到目前为止，我们已经学习和创建了对 JavaScript 的坚实基础理解，包括它在底层是如何工作的以及它包含的内容。但我们实际上是如何使用它的呢？我们如何开始构建一些东西？这就是本章要处理的内容。
- en: 'In this chapter, we''ll learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: HTML5 and the rise of modern JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 和现代 JavaScript 的兴起
- en: What is **Document Object Model **(**DOM**)?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型 (DOM**) 是什么？'
- en: DOM methods/properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 方法/属性
- en: Modern JavaScript browser APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代JavaScript浏览器API
- en: Page Visibility API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面可见性 API
- en: Navigator API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航器 API
- en: Clipboard API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板 API
- en: Canvas API - the web's drawing board
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas API - 网络的画板
- en: Fetch API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch API
- en: HTML5 and the rise of modern JavaScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 和现代 JavaScript 的兴起
- en: The HTML5 specification arrived in 2008\. HTML5, however, was so technologically
    advanced in 2008 that it was predicted that it would not be ready till at least
    2022! However, that turned out to be incorrect, and here we are, with fully supported
    HTML5 and ES6/ES7/ES8-supported browsers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 规范于 2008 年发布。然而，HTML5 在 2008 年的技术如此先进，以至于预测它至少要到 2022 年才准备好！然而，结果证明这是不正确的，现在我们有了完全支持的
    HTML5 和支持 ES6/ES7/ES8 的浏览器。
- en: 'A lot of APIs used by HTML5 go hand in hand with JavaScript. Before looking
    at those APIs, let us understand a little about how JavaScript sees the web. This''ll
    eventually put us in a strong position to understand various interesting, JavaScript-related
    things such as the Web Workers API, which deserves its own chapter (spoiler alert:
    It is included in this book!)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 HTML5 使用的 API 都与 JavaScript 密不可分。在查看这些 API 之前，让我们了解一下 JavaScript 如何看待网络。这将最终使我们处于强大的位置，以理解各种有趣的
    JavaScript 相关事物，例如 Web Workers API，它值得拥有自己的章节（剧透警告：它包含在这本书中！）
- en: The HTML DOM
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML DOM
- en: 'The HTML DOM is a tree version of how the document looks. Here is a very simple
    example of an HTML document:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTML DOM 是文档外观的树形版本。以下是一个非常简单的 HTML 文档示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s how its tree version will look:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它的树形版本将看起来如下：
- en: '![](img/44939779-ea75-4738-8a37-afa1e574cefc.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44939779-ea75-4738-8a37-afa1e574cefc.png)'
- en: The previous diagram is just a rough representation of the DOM tree. HTML tags
    consist of **head** and **body**; furthermore, the `<body>` tag consists of a
    `<p>` tag, whereas the `<head>` tag consists of the `<title>` tag. Simple!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图只是一个 DOM 树的大致表示。HTML 标签由 **head** 和 **body** 组成；此外，`<body>` 标签包含一个 `<p>`
    标签，而 `<head>` 标签包含 `<title>` 标签。简单！
- en: JavaScript has access to the DOM directly, and can modify the connections between
    these nodes, add nodes, remove nodes, change contents, attach event listeners,
    and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可以直接访问 DOM，并可以修改这些节点之间的连接，添加节点，删除节点，更改内容，附加事件监听器等。
- en: What is the Document Object Model (DOM)?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档对象模型 (DOM) 是什么？
- en: Simply put, the DOM is a way to represent HTML or XML documents as nodes. This
    makes it easier for other programming languages to connect to a DOM-following
    page and modify it accordingly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，DOM 是一种将 HTML 或 XML 文档表示为节点的方式。这使得其他编程语言更容易连接到遵循 DOM 的页面并相应地修改它。
- en: To be clear, DOM is not a programming language. DOM provides JavaScript with
    a way to interact with web pages. You can think of it as a standard. Every element
    is part of the DOM tree, which can be accessed and modified with APIs exposed
    to JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚起见，DOM 不是一个编程语言。DOM 为 JavaScript 提供了一种与网页交互的方式。你可以将其视为一个标准。每个元素都是 DOM 树的一部分，可以通过暴露给
    JavaScript 的 API 进行访问和修改。
- en: DOM is not restricted to being accessed only by JavaScript. It is language-independent
    and there are several modules available in various languages to parse DOM (just
    like JavaScript) including PHP, Python, Java, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 不限于只能由 JavaScript 访问。它是语言无关的，并且有各种语言模块可用于解析 DOM（就像 JavaScript 一样），包括 PHP、Python、Java
    等。
- en: 'As said previously, DOM provides JavaScript with a way to interact with it.
    How? Well, accessing DOM is as easy as accessing predefined objects in JavaScript:
    `document`. The DOM API specifies what you''ll find inside the `document` object.
    The `document` object essentially gives JavaScript access to the DOM tree formed
    by your HTML document. If you notice, you cannot access any element at all without
    actually accessing the `document` object first.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，DOM 为 JavaScript 提供了一种与之交互的方式。如何？嗯，访问 DOM 就像访问 JavaScript 中的预定义对象一样简单：`document`。DOM
    API 指定了你将在 `document` 对象中找到的内容。`document` 对象实际上为 JavaScript 提供了对由你的 HTML 文档形成的
    DOM 树的访问。如果你注意到，不首先访问 `document` 对象，你根本无法访问任何元素。
- en: DOM methods/properties
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM 方法/属性
- en: 'All HTML elements are objects in JavaScript. The most commonly used object
    is the `document` object. It has the whole DOM tree attached to it. You can query
    for elements on that. Let''s look at some very common examples of these methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 HTML 元素在 JavaScript 中都是对象。最常用的对象是 `document` 对象。它将整个 DOM 树附加到它上面。你可以在那里查询元素。让我们看看这些方法的几个非常常见的例子：
- en: '`getElementById` method'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementById` 方法'
- en: '`getElementsByTagName` method'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementsByTagName` 方法'
- en: '`getElementsByClassName` method'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementsByClassName` 方法'
- en: '`querySelector` method'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelector` 方法'
- en: '`querySelectorAll` method'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelectorAll` 方法'
- en: By no means is this an exhaustive list of all methods available. However, this
    list should at least get you started with DOM manipulation. Use MDN as your reference
    for various other methods. Here's the link: [https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods](https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是所有可用方法的详尽列表。然而，这个列表至少应该能让你开始 DOM 操作。使用 MDN 作为你参考各种其他方法的依据。以下是链接：[https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods](https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods)。
- en: Using the getElementById method
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `getElementById` 方法
- en: 'In HTML, you can assign an element an `ID` and then retrieve it back in JavaScript
    for manipulation. Here''s how:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，你可以给一个元素分配一个 `ID`，然后在 JavaScript 中检索它以进行操作。下面是如何做的：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have that, you can access the properties of this object, which in turn
    actually modifies the element on the screen accordingly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这个，你就可以访问这个对象的属性，这实际上会根据需要修改屏幕上的元素。
- en: Using the getElementsByTagName method
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `getElementsByTagName` 方法
- en: 'Similar to the `ID` method, `getElementsByTagName(<Name Of Tag>)` gets us elements
    with a couple of differences:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ID` 方法类似，`getElementsByTagName(<标签名>)` 获取元素有一些区别：
- en: It gives you a collection of elements instead of a single element (array)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它给你一组元素而不是单个元素（数组）
- en: It queries for elements on the basis of their tag names and not `ID` values
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于元素的标签名查询元素，而不是 `ID` 值
- en: 'Here''s an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the word `getElements`.It returns us a bunch of elements. Therefore,
    we pick up the first element from the `NodeList` and set its contents to `Cool`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到单词 `getElements`。它返回给我们一堆元素。因此，我们从 `NodeList` 中选择第一个元素并将其内容设置为 `Cool`。
- en: '`innerHTML` is used to change the HTML content inside the element you''re working
    on.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerHTML` 用于更改你正在工作的元素内部的 HTML 内容。'
- en: Using the getElementsByClassName method
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `getElementsByClassName` 方法
- en: 'The `getElementsByClassName` method will return elements of the same class
    as a `NodeList` and not an `Array`! `NodeList` is not exactly an `Array`; however,
    it is iterable, and easily convertible into `Array` as well:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByClassName` 方法将返回具有相同类的元素作为一个 `NodeList`，而不是一个 `Array`！`NodeList`
    并不完全是一个 `Array`；然而，它是可迭代的，并且很容易转换成 `Array`：'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As said previously, `tags` is actually a `NodeList`. First, we use a destructuring operator
    and surround it with square brackets to actually convert it into an `Array`. Then
    we use `map` (which we can on `Array`, but cannot on `NodeList`) to iterate over
    every tag, that is, the `<span>` element, and we just console-log the element.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`tags` 实际上是一个 `NodeList`。首先，我们使用一个解构操作符并用方括号包围它，实际上将其转换为一个 `Array`。然后我们使用
    `map`（我们可以在 `Array` 上使用它，但不能在 `NodeList` 上使用）来遍历每个标签，即 `<span>` 元素，我们只是控制台输出这个元素。
- en: The takeaway from this code is how we used a destructuring operator in it. You'll
    often find yourself regularly using those important concepts we learned earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中我们可以学到的是我们如何在其中使用解构操作符。你经常会发现自己经常使用我们之前学过的重要概念。
- en: Using the querySelector method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `querySelector` 方法
- en: 'The `querySelector` method returns an element in the same way as when selecting
    an element through its CSS selector. However, `document.querySelector` returns
    only one element. Therefore, we can operate on it directly once we query for that
    element:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelector`方法以与通过CSS选择器选择元素相同的方式返回一个元素。然而，`document.querySelector`只返回一个元素。因此，一旦我们查询到该元素，我们就可以直接操作它：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is equivalent to doing `document.querySelector('div').style.color = 'red';`
    if we have only one `<div>` tag in the body.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在文档中只有一个`<div>`标签，这相当于执行`document.querySelector('div').style.color = 'red';`。
- en: Using the querySelectorAll method
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用querySelectorAll方法
- en: 'Just like you can get any element with `querySelector`, you can get a bunch
    of elements matching the criteria with `querySelectorAll`. You''ve seen how to
    work with `NodeList` in the `getElementsByClass` method. Try to understand the
    code as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以使用`querySelector`获取任何元素一样，您也可以使用`querySelectorAll`获取符合特定标准的多个元素。您已经在`getElementsByClass`方法中看到了如何使用`NodeList`。试着理解以下代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we're converting `NodeList` to `Array` using destructuring. Then we're
    mapping over the array and changing the style of each `<div>` according to the
    value of its data-attr.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用解构将`NodeList`转换为`Array`。然后我们映射数组，并根据每个`<div>`的data-attr值更改其样式。
- en: Modern JavaScript browser APIs
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代JavaScript浏览器API
- en: HTML5 brought a lot of support for some awesome and cool APIs in JavaScript,
    right from the start. Although some APIs were released with HTML5 itself (such
    as the Canvas API), some were added later (such as the Fetch API).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5从一开始就为JavaScript中一些很棒和酷的API提供了大量支持。尽管一些API是与HTML5本身一起发布的（例如Canvas API），但也有一些是在之后添加的（例如Fetch
    API）。
- en: Let's see some of these APIs and how to use them with some code examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些这些API以及如何使用它们的代码示例。
- en: Page Visibility API - is the user still on the page?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面可见性API - 用户是否仍然在页面上？
- en: The **Page Visibility API** allows developers to run specific code whenever
    the page user is on goes in focus or out of foucs. Imagine you run a game-hosting
    site and want to pause the game whenever the user loses focus on your tab. This
    is the way to go!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Page Visibility API**允许开发者在其页面的用户获得或失去焦点时运行特定的代码。想象一下，如果你运营一个游戏托管网站，并且希望在用户失去对您的标签的焦点时暂停游戏。这就是你该采取的方法！'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're adding an event listener to the document; it fires whenever the page is
    changed. Sure, the `pageChanged` function gets an event object as well in the
    argument, but we can simply use the `document.hidden` property, which returns
    a Boolean value depending on the page's visibility at the time the code was called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向文档添加了一个事件监听器；它会在页面更改时触发。当然，`pageChanged`函数也会在参数中接收到一个事件对象，但我们可以简单地使用`document.hidden`属性，该属性返回一个布尔值，取决于代码调用时的页面可见性。
- en: 'You''ll add your *pause game* code at `line #1` and your *resume game* code
    at `line #2`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '你将在`line #1`处添加你的`*pause game*`代码，并在`line #2`处添加你的`*resume game*`代码。'
- en: navigator.onLine API – the user's network status
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: navigator.onLine API – 用户网络状态
- en: The `navigator.onLine` API tells you if the user is online or not. Imagine building
    a multiplayer game and you want the game to automatically pause if the user loses
    their internet connection. This is the way to go here!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator.onLine` API会告诉你用户是否在线。想象一下，如果你正在开发一个多人游戏，并且希望当用户断开互联网连接时游戏自动暂停。这就是你该采取的方法！'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we're attaching two event listeners to window global. We want to call
    the `state` function whenever the user goes `offline` or `online`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向window全局对象附加了两个事件监听器。我们希望在用户离线或在线时调用`state`函数。
- en: The browser will call the `state` function every time the user goes `offline`
    or `online`. We can access it if the user is `offline` or `online` with `navigator.onLine`,
    which returns a Boolean value of `true` if there's an internet connection, and
    `false` if there's not.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会在用户离线或在线时调用`state`函数。我们可以通过`navigator.onLine`访问它，如果存在互联网连接，则返回一个布尔值`true`，如果没有，则返回`false`。
- en: Clipboard API - programmatically manipulating the clipboard
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clipboard API - 以编程方式操作剪贴板
- en: 'The **Clipboard API** finally allows developers to copy to a user''s clipboard
    without those nasty Adobe Flash plugin hacks that were not cross-browser/cross-device-friendly.
    Here''s how you''ll copy a selection to a user''s clipboard:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clipboard API**最终允许开发者在不使用那些令人讨厌的Adobe Flash插件黑客手段的情况下将内容复制到用户的剪贴板。以下是您将如何将选择复制到用户剪贴板的方法：'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First of all, we need the user to actually click the button. Once the user clicks
    the button, we call a function that creates a `textarea` in the background using
    the `document.createElement` method. The script then sets the value of the `textarea`
    to the passed text (this is pretty good!) We then focus on that `textarea` and
    select all the contents inside it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要用户实际点击按钮。一旦用户点击按钮，我们就调用一个函数，在后台使用`document.createElement`方法创建一个`textarea`。然后脚本将`textarea`的值设置为传入的文本（这很好！）我们接着聚焦到那个`textarea`并选择其中的所有内容。
- en: Once the contents are selected, we execute a copy with `document.execCommand('copy')`;
    this copies the current selection in the document to the clipboard. Since, right
    now, the value inside the `textarea` is selected, it gets copied to the clipboard.
    Finally, we remove the `textarea` from the document so that it doesn't disrupt
    the document layout.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内容被选中，我们就使用`document.execCommand('copy')`执行复制；这会将文档中的当前选择复制到剪贴板。由于现在`textarea`中的值被选中，它就被复制到剪贴板。最后，我们从文档中移除`textarea`，以免它破坏文档布局。
- en: You cannot trigger `copy2Clipboard` without user interaction. I mean, obviously
    you can, but `document.execCommand('copy')` will not work if the event does not
    come from the user (click, double-click, and so on). This is a security implementation
    so that a user's clipboard is not messed around with by every website that they
    visit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在没有用户交互的情况下触发`copy2Clipboard`。我的意思是，显然你可以，但如果事件不是来自用户（点击、双击等），`document.execCommand('copy')`将不会工作。这是一个安全实现，以确保用户的剪贴板不会被他们访问的每个网站所干扰。
- en: The Canvas API - the web's drawing board
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas API - 网页的绘图板
- en: HTML5 finally brought in support for `<canvas>`, a standard way to draw graphics
    on the web! Canvas can be used pretty much for everything related to graphics
    you can think of; from digitally signing with a pen, to creating 3D games on the
    web (3D games require WebGL knowledge, interested? - visit [http://bit.ly/webgl-101](http://bit.ly/webgl-101)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5终于引入了对`<canvas>`的支持，这是一种在网页上绘制图形的标准方式！Canvas几乎可以用于你所能想到的与图形相关的任何事情；从用笔数字化签名，到在网页上创建3D游戏（3D游戏需要WebGL知识，感兴趣吗？-
    访问[http://bit.ly/webgl-101](http://bit.ly/webgl-101))。
- en: 'Let''s look at the basics of the Canvas API with a simple example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看Canvas API的基础：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This renders the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/460f0d05-4c59-49c0-b610-4edf05c27ec2.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/460f0d05-4c59-49c0-b610-4edf05c27ec2.png)'
- en: How does it do this?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何做到这一点的？
- en: Firstly, `document.getElementById('canvas')` gives us the reference to the canvas
    on the document.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`document.getElementById('canvas')`给我们提供了文档中画布的引用。
- en: Then we get the **context **of the canvas. This is a way to say what I want
    to do with the canvas. You could put a 3D value there, of course! That is indeed
    the case when you're doing 3D rendering with WebGL and canvas.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取画布的**上下文**。这是指明我想对画布做什么的一种方式。当然，你可以在那里放一个3D值！当你使用WebGL和canvas进行3D渲染时，情况确实如此。
- en: Once we have a reference to our context, we can do a bunch of things and add
    methods provided by the API out-of-the-box. Here we moved the cursor to the (0,
    0) coordinates.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了对上下文的引用，我们就可以做很多事情，并直接添加API提供的方法。在这里，我们将光标移动到了(0, 0)坐标。
- en: Then we drew a line till (100,100) (which is basically a diagonal on the square
    canvas).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们画了一条线到(100,100)（这在正方形画布上基本上是斜线）。
- en: Then we called stroke to actually draw that on our canvas. Easy!
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用stroke来实际上在我们的画布上绘制。很简单！
- en: Canvas is a wide topic and deserves a book of its own! If you're interested
    in developing awesome games and apps with Canvas, I recommend you start off with
    MDN docs: [http://bit.ly/canvas-html5.](http://bit.ly/canvas-html5)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas是一个广泛的话题，值得有一本自己的书！如果你对使用Canvas开发酷炫的游戏和应用程序感兴趣，我建议你从MDN文档开始：[http://bit.ly/canvas-html5](http://bit.ly/canvas-html5)。
- en: The Fetch API - promise-based HTTP requests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fetch API - 基于Promise的HTTP请求
- en: One of the coolest async APIs introduced in browsers is the Fetch API, which
    is the modern replacement for the `XMLHttpRequest` API. Have you ever found yourself
    using jQuery just for simplifying AJAX requests with $.ajax? If you have, then
    this is surely a golden API for you, as it is **natively** easier to code and
    read!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中引入的最酷的异步API之一是Fetch API，它是`XMLHttpRequest` API的现代替代品。你有没有发现自己只是为了简化AJAX请求而使用jQuery的$.ajax？如果你有，那么这个API对你来说肯定是一块金子，因为它**本地**更容易编写和阅读！
- en: 'If you remember, we created a promised version of `XMLHttpRequest` ourselves
    in [Chapter 4](d37a4519-f5c0-4f5b-a3b4-df5e0091949e.xhtml), *Asynchronous Programming*.
    However, `fetch` comes natively, hence, there are performance benefits. Let''s
    see how it works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们在[第4章](d37a4519-f5c0-4f5b-a3b4-df5e0091949e.xhtml)“异步编程”中自己创建了一个`XMLHttpRequest`的承诺版本。然而，`fetch`是原生的，因此，它有性能优势。让我们看看它是如何工作的：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Awesome! So `fetch` uses promises! If that's the case, we can combine it with
    async/await to make it look completely synchronous and easy to read!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以`fetch`使用承诺！如果是这样，我们可以将其与async/await结合使用，使其看起来完全同步且易于阅读！
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The line `console.log(image1)` will print the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(image1)`这一行将打印以下内容：'
- en: '![](img/f355a7bf-0469-4cf0-a82b-578d2138be98.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f355a7bf-0469-4cf0-a82b-578d2138be98.png)'
- en: You can see the `image1` response provides tons of information about the request.
    It has an interesting field body, which is actually a `ReadableStream`, and a
    byte stream of data that can be cast to a  **Binary Large Object** (**BLOB**)
    in our case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`image1`响应提供了关于请求的大量信息。它有一个有趣的字段body，实际上是一个`ReadableStream`，以及可以转换为我们的**二进制大对象（BLOB**）的数据字节流。
- en: A `blob` object represents a file-like object of immutable and raw data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`blob`对象代表一个不可变和原始数据的文件样对象。
- en: After getting the `Response`, we convert it into a `blob` object so that we
    can actually use it as an image. Here, fetch is actually fetching us the image
    directly so we can serve it to the user as a `blob` (without hot-linking it to
    the main website).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到`Response`之后，我们将其转换为`blob`对象，这样我们就可以将其用作图像。在这里，`fetch`实际上直接获取图像，因此我们可以将其作为`blob`（而不是将其链接到主网站）提供给用户。
- en: Thus, this could be done on the server side, and `blob` data could be passed
    down a WebSocket or something similar.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这可以在服务器端完成，`blob`数据可以通过WebSocket或其他类似方式传递下来。
- en: Fetch API customization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fetch API自定义
- en: 'The Fetch API is highly customizable. You can even include your own headers
    in the request. Suppose you''ve got a site where only authenticated users with
    a valid token can access an image. Here''s how you''ll add a custom header to
    your request:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API非常可定制。您甚至可以在请求中包含自己的头信息。假设您有一个网站，只有拥有有效令牌的认证用户才能访问图像。以下是您如何向请求添加自定义头信息的方法：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we added a custom header to our `Request` and then created something
    called a `Request` object (an object that has information about our `Request`).
    The first parameter, that is, `http://myawesomewebsite.awesometld/secretimage.jpg`,
    is the URL and the second is the configuration. Here are some other configuration
    options:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的`Request`添加了一个自定义头，然后创建了一个名为`Request`的对象（一个包含我们`Request`信息的对象）。第一个参数，即`http://myawesomewebsite.awesometld/secretimage.jpg`，是URL，第二个是配置。以下是一些其他配置选项：
- en: '**Credentials**: Used to pass cookies in a **Cross-Origin Resource Sharing**
    (**CORS**)-enabled server on cross-domain requests.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Credentials**：用于在启用**跨源资源共享（CORS**）的服务器上跨域请求中传递cookie。'
- en: '**Method**: Specifies request methods (GET, POST, HEAD, and so on).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Method**：指定请求方法（GET、POST、HEAD等）。'
- en: '**Headers**:Headers associated with the request.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Headers**：与请求相关的头信息。'
- en: '**Integrity**: A security feature that consists of a (possibly) SHA-256 representation
    of the file you''re requesting, in order to verify whether the request has been
    tampered with (data is modified) or not. Probably not a lot to worry about unless
    you''re building something on a very large scale and not on HTTPS.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：一个安全特性，由你请求的文件的（可能）SHA-256表示组成，用于验证请求是否被篡改（数据被修改）或未被篡改。除非你在非常大规模且不在HTTPS上构建东西，否则可能无需过多担心。'
- en: '**Redirect**: Redirect can have three values:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redirect**：重定向可以有三个值：'
- en: 'Follow: Will follow the URL redirects'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Follow：将跟随URL重定向
- en: Error: Will throw an error if the URL redirects
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：如果URL重定向，将抛出错误
- en: Manual: Doesn't follow redirect but returns a filtered response that wraps the
    redirect response
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动：不跟随重定向，但返回一个包装重定向响应的过滤响应
- en: '**Referrer**: the URL that appears as a referrer header in the HTTP request.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Referrer**：HTTP请求中作为引用头出现的URL。'
- en: Accessing and modifying history with the history API
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用history API访问和修改历史记录
- en: 'You can access a user''s history to some level and modify it according to your
    needs using the `history` API. It consists of the length and state properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`history` API在一定程度上访问用户的历史记录，并根据您的需求进行修改。它包括长度和状态属性：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In your case, the `length` could obviously be different depending on how many
    pages you've visited from that particular tab.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，`length`显然会根据你从该特定标签页访问的页面数量而有所不同。
- en: '`history.state` can contain anything you like (we''ll come to its use case
    soon). Before looking at some handy history methods, let us take a look at the `window.onpopstate`
    event.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`history.state`可以包含任何你想要的内容（我们很快就会看到其用例）。在查看一些有用的历史方法之前，让我们看看`window.onpopstate`事件。'
- en: Handling window.onpopstate events
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理window.onpopstate事件
- en: The`window.onpopstate` event is fired automatically by the browser when a user
    navigates between history states that a developer has set. This event is important
    to handle when you push to history object and then later retrieve information whenever
    the user presses the back/forward button of the browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在开发者设置的历史状态之间导航时，浏览器会自动触发`window.onpopstate`事件。当你向历史对象推送信息，并在稍后用户按下浏览器的后退/前进按钮时检索信息时，处理此事件非常重要。
- en: 'Here''s how we''ll program a simple `popstate` event:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何编程一个简单的`popstate`事件：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we'll discuss some methods associated with the `history` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论一些与`history`对象相关的方法。
- en: Modifying history - the history.go(distance) method
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改历史记录 - `history.go(distance)`方法
- en: '`history.go(x)` is equivalent to the user clicking his forward button `x` times
    in the browser. However, you can specify the distance to move, that is `history.go(5);`
    . This equivalent to the user hitting the forward button in the browser five times.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`history.go(x)`等同于用户在浏览器中点击前进按钮`x`次。然而，你可以指定移动的距离，即`history.go(5);`。这相当于用户在浏览器中点击前进按钮五次。'
- en: 'Similarly, you can specify negative values as well to make it move backward.
    Specifying 0 or no value will simply refresh the page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以指定负值来使其向后移动。指定0或无值将简单地刷新页面：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Jumping ahead - the history.forward() method
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向前跳跃 - `history.forward()`方法
- en: This method is simply the equivalent of `history.go(1)`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地等同于`history.go(1)`。
- en: 'This is handy when you want to just push the user to the page he/she is coming
    from. One use case of this is when you can create a full-screen immersive web
    application and on your screen there are some minimal controls that play with
    the history behind the scenes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将用户推回到他们之前所在的页面时，这很有用。一个用例是当你可以创建一个全屏沉浸式Web应用，并且在你的屏幕上有一些在幕后操作历史的最小控件：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Going back - the history.back() method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向后移动 - `history.back()`方法
- en: This method is simply the equivalent of `history.go(-1)`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地等同于`history.go(-1)`。
- en: A negative number, makes the history go backwards. Again, this is just a simple
    (and numberless) way to go back to a page the user came from. Its application
    could be similar to a forward button, that is, creating a full-screen web app
    and providing the user with an interface to navigate by.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 负数会使历史记录向后移动。再次强调，这仅仅是一种简单（且无数字）的方式回到用户之前访问的页面。其应用可能类似于前进按钮，即创建一个全屏Web应用，并为用户提供一个界面来导航。
- en: Pushing on the history - history.pushState()
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向历史记录中推送 - `history.pushState()`
- en: 'This is really fun. You can change the browser URL without hitting the server
    with an HTTP request. If you run the following JS in your browser, your browser
    will change the path from whatever it is (`domain.com/abc/egh`) to  `/i_am_awesome`
    (`domain.com/i_am_awesome`) without actually navigating to any page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很有趣。你可以不通过HTTP请求击中服务器来更改浏览器URL。如果你在浏览器中运行以下JS，你的浏览器将从当前路径（`domain.com/abc/egh`）更改为`/i_am_awesome`（`domain.com/i_am_awesome`），而实际上并没有导航到任何页面：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The History API doesn't care whether the page actually exists on the server
    or not. It'll just replace the URL as it is instructed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 历史API并不关心页面是否真的存在于服务器上。它只会按照指示替换URL。
- en: 'The  `popstate` event when triggered with the browser''s back/forward button,
    will fire the function below and we can program it like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用浏览器的后退/前进按钮触发`popstate`事件时，将触发下面的函数，我们可以这样编程：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To run this code, run the `onpopstate` event first, then the two lines of `history.pushState` previously.
    Then press your browser''s back button. You should see something like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，首先运行`onpopstate`事件，然后运行之前的两行`history.pushState`。然后按下浏览器的后退按钮。你应该会看到类似以下的内容：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: which is the information related to the parent state. Press back button one
    more time and you'll see the message `Root State`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这与父状态相关的信息。再按一次后退按钮，你会看到消息`根状态`。
- en: '`pushState` does not fire `onpopstate` event. Only browsers'' back/forward
    buttons do.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushState`不会触发`onpopstate`事件。只有浏览器的后退/前进按钮会。'
- en: Pushing on the history stack - history.replaceState()
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在历史记录栈上推进 - history.replaceState()
- en: The `history.replaceState()` method is exactly like `history.pushState()`, the
    only difference is that it replaces the current page with another, that is, if
    you use `history.pushState()` and press the back button, you'll be directed to
    the page you came from.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`history.replaceState()` 方法与 `history.pushState()` 方法完全相同，唯一的区别是它会用另一个页面替换当前页面，也就是说，如果您使用
    `history.pushState()` 并按下后退按钮，您将被导向您之前所在的页面。'
- en: 'However, when you use `history.replaceState()` and you press the back button,
    you are not directed to the page you came from because it is replaced with the
    new one on the stack. Here''s an example of working with the `replaceState` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您使用 `history.replaceState()` 并按下后退按钮时，您不会被导向您之前所在的页面，因为它是用栈上的新页面替换的。以下是一个使用
    `replaceState` 方法的示例：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This replaces (instead of pushing) the current state with the new state.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将（而不是推送）当前状态替换为新状态。
- en: Although using the History API directly in your code may not be beneficial to
    you right now, many frameworks and libraries such as React, under the hood, use
    the History API to create a seamless, reload-less, smooth experience for the end
    user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接在您的代码中使用 History API 可能目前对您没有好处，但许多框架和库，如 React，在底层使用 History API 来为最终用户提供无缝、无需重新加载、流畅的体验。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the best APIs introduced by HTML5 and modern
    JavaScript together, and how they are shaping the way people browse and interact
    with websites.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些由 HTML5 和现代 JavaScript 一起引入的最佳 API，以及它们如何塑造人们浏览和与网站交互的方式。
- en: In the next chapter, we'll take a brief overview of the HTTP protocol and some
    storage APIs available in JavaScript that can be used to store data locally and
    communicate with the server. Let's go!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要概述 HTTP 协议以及 JavaScript 中可用的某些存储 API，这些 API 可以用于本地存储数据和与服务器通信。让我们开始吧！
