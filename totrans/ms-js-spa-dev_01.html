<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Organized with NPM, Bower, and Grunt"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Organized with NPM, Bower, and Grunt</h1></div></div></div><p>JavaScript was the bane of the web development industry during the early days of the browser-rendered Internet. It now powers hugely impactful libraries such as jQuery, and JavaScript-rendered (as opposed to server-side-rendered) content is even indexed by many search engines. What was once largely considered an annoying language used primarily to generate pop-up windows and alert boxes, has now become arguably the most popular programming language in the world.</p><p>Not only is JavaScript now more prevalent than ever in frontend architecture, but it has become a server-side language as well, thanks to the <span class="emphasis"><em>Node.js</em></span> runtime. We have also seen the proliferation of document-oriented databases, such as MongoDB, which store and return JSON data. With JavaScript present throughout the development stack, the door is now open for JavaScript developers to become full-stack developers without the need to learn a traditional server-side language. Given the right tools and know-how, any JavaScript developer can create <span class="emphasis"><em>single page applications</em></span> comprised entirely of the language they know best, and they can do so using an architecture like <span class="emphasis"><em>MEAN</em></span> (MongoDB, Express, AngularJS, and Node.js).</p><p>Organization is key to the development of any complex <span class="strong"><strong>Single Page Application</strong></span> (<span class="strong"><strong>SPA</strong></span>). If you don't get organized from the beginning, you are sure to introduce an inordinate number of regressions to your app. The Node.js ecosystem will help you to do this with a full suite of indispensable and open-source tools, three of which we will discuss here.</p><p>In this chapter, you will learn about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Node Package Manager</strong></span> (<span class="strong"><strong>NPM</strong></span>)</li><li class="listitem" style="list-style-type: disc">Bower frontend package manager</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Grunt</strong></span> JavaScript task runner</li><li class="listitem" style="list-style-type: disc">How these three tools can be used together to create an organized development environment that is ideal for creating an SPA and is essential to the MEAN stack architecture.</li></ul></div><div class="section" title="What is Node Package Manager?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"/>What is Node Package Manager?</h1></div></div></div><p>Within any full-stack JavaScript environment, <span class="strong"><strong>Node Package Manager</strong></span> will be your <span class="emphasis"><em>go-to</em></span> tool for setting up your development environment and for managing server-side libraries. NPM can be used within both global and isolated environment contexts. We will first explore the use of NPM globally.</p><div class="section" title="Installing Node.js and NPM"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec5"/>Installing Node.js and NPM</h2></div></div></div><p>NPM is a component of <span class="emphasis"><em>Node.js</em></span>, so before you can use it you must first install Node.js. You can find installers for both Mac and Windows at nodejs.org. Once you have Node.js installed, using NPM is incredibly easy and is done from the <span class="strong"><strong>Command Line Interface</strong></span> (<span class="strong"><strong>CLI</strong></span>). Start by ensuring you have the latest version of NPM installed, as it is updated more often than Node.js itself:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g npm</strong></span>
</pre><p>When using NPM, the <code class="literal">-g</code> option will apply your changes to your global environment. In this case, you want your version of NPM to apply globally. As stated previously, NPM can be used to manage packages both globally and within isolated environments. In the following, we want essential development tools to be applied globally so that you can use them in multiple projects on the same system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip3"/>Tip</h3><p>With Mac and some Unix-based systems, you may have to run the <code class="literal">npm</code> command as the superuser (prefix the command with <code class="literal">sudo</code>) in order to install packages globally, depending on how NPM was installed. If you run into this issue and wish to remove the need to prefix <code class="literal">npm</code> with <code class="literal">sudo</code>, see <a class="ulink" href="http://docs.npmjs.com/getting-started/fixing-npm-permissions">docs.npmjs.com/getting-started/fixing-npm-permissions</a>.</p></div></div></div><div class="section" title="Configuring your package.json file"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec6"/>Configuring your package.json file</h2></div></div></div><p>For any project you develop, you will keep a local <code class="literal">package.json</code> file to manage your Node.js dependencies. This file should be stored at the root of your project directory and it will only pertain to that isolated environment. This allows you to have multiple Node.js projects with different dependency chains on the same system.</p><p>When beginning a new project, you can automate the creation of the <code class="literal">package.json</code> file from the command line:</p><pre class="programlisting">
<span class="strong"><strong>$ npm init</strong></span>
</pre><p>Running <code class="literal">npm init</code> will take you through a series of JSON property names to define through command line prompts, including your app's <code class="literal">name</code>, <code class="literal">version</code> number, <code class="literal">description</code>, and more. The <code class="literal">name</code> and <code class="literal">version</code> properties are required, and your Node.js package will not install without them defined. Several of the properties will have a default value given within parentheses in the prompt so that you may simply hit <span class="emphasis"><em>Enter</em></span> to continue. Other properties will simply allow you to hit <span class="emphasis"><em>Enter</em></span> with a blank entry and will not be saved to the <code class="literal">package.json</code> file, or will be saved with a blank value:</p><pre class="programlisting">
<span class="strong"><strong>name: (my-app)</strong></span>
<span class="strong"><strong>version: (1.0.0)</strong></span>
<span class="strong"><strong>description:</strong></span>
<span class="strong"><strong>entry point: (index.js)</strong></span>
</pre><p>The <code class="literal">entry point</code> prompt will be defined as the <code class="literal">main</code> property in <code class="literal">package.json</code> and is not necessary unless you are developing a Node.js application. In our case, we can forgo this field. The <code class="literal">npm init</code> command may in fact force you to save the <code class="literal">main</code> property, so you will have to edit <code class="literal">package.json</code> afterward to remove it; however, that field will have no effect on your web app.</p><p>You may also choose to create the <code class="literal">package.json</code> file manually using a text editor, if you know the appropriate structure to employ. Whichever method you choose, your initial version of the <code class="literal">package.json</code> file should look similar to the following example:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "version": "1.0.0", &#13;
  "author": "Philip Klauzinski", &#13;
  "license": "MIT", &#13;
  "description": "My JavaScript single page application." &#13;
} &#13;
</pre><p>If you want your project to be private and want to ensure that it does not accidently get published to the NPM registry, you may want to add the <code class="literal">private</code> property to your <code class="literal">package.json</code> file, and set it to <code class="literal">true</code>. Additionally, you may remove some properties that only apply to a registered package:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "author": "Philip Klauzinski", &#13;
  "description": "My JavaScript single page application.", &#13;
  "private": true &#13;
} &#13;
</pre><p>Once you have your <code class="literal">package.json</code> file set up the way you like it, you can begin installing Node.js packages locally for your app. This is where the importance of dependencies begins to surface.</p><div class="section" title="NPM dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec0"/>NPM dependencies</h3></div></div></div><p>There are three types of dependencies that can be defined for any Node.js project in your <code class="literal">package.json</code> file: <code class="literal">dependencies</code>, <code class="literal">devDependencies</code>, and <code class="literal">peerDependencies</code>. For the purpose of building a web-based SPA, you will only need to use the <code class="literal">devDependencies</code> declaration.</p><p>
<code class="literal">devDependencies</code> are those which are required for developing your application, but not required for its production environment or for simply running it. If other developers want to contribute to your Node.js application, they will need to run <code class="literal">npm install</code> from the command line to set up the proper development environment. For information on the other types of dependencies, see docs.npmjs.com.</p><p>When adding <code class="literal">devDependencies</code> to your <code class="literal">package.json file</code>, the command line again comes to the rescue. Let's use the installation of Browserify as an example:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install browserify --save-dev</strong></span>
</pre><p>This will install Browserify locally and save it along with its version range to the <code class="literal">devDependencies</code> object in your <code class="literal">package.json</code> file. Once installed, your <code class="literal">package.json</code> file should look similar to the following example:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "version": "1.0.0", &#13;
  "author": "Philip Klauzinski", &#13;
  "license": "MIT", &#13;
  "devDependencies": { &#13;
    "browserify": "^12.0.1" &#13;
  } &#13;
} &#13;
 &#13;
</pre><p>The <code class="literal">devDependencies</code> object will store each package as a key-value pair in which the key is the <span class="emphasis"><em>package name</em></span> and the value is the <span class="emphasis"><em>version number</em></span> or <span class="emphasis"><em>version range</em></span>. Node.js uses semantic versioning, where the three digits of the version number represent <code class="literal">MAJOR.MINOR.PATCH</code>. For more information on semantic version formatting, see <a class="ulink" href="http://semver.org">semver.org</a>.</p><div class="section" title="Updating your development dependencies"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec0"/>Updating your development dependencies</h4></div></div></div><p>You will notice that the version number of the installed package is preceded by a <span class="strong"><strong>caret</strong></span> (<code class="literal">^</code>) symbol by default. This means that package updates will only allow <span class="emphasis"><em>patch</em></span> and <span class="emphasis"><em>minor</em></span> updates for versions above 1.0.0. This is meant to prevent major version changes from breaking your dependency chain when updating your packages to the latest versions.</p><p>To update your <code class="literal">devDependencies</code> and save the new version numbers, you can enter the following from the command line:</p><pre class="programlisting">
<span class="strong"><strong>$ npm update --save-dev</strong></span>
</pre><p>Alternatively, you can use the <code class="literal">-D</code> option as a shortcut for <code class="literal">--save-dev</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ npm update -D</strong></span>
</pre><p>To update all globally installed NPM packages to their latest versions, run <code class="literal">npm update</code> with the <code class="literal">-g</code> option:</p><pre class="programlisting">
<span class="strong"><strong>$ npm update -g</strong></span>
</pre><p>For more information on semantic versioning within NPM, see <a class="ulink" href="http://docs.npmjs.com/misc/semver">docs.npmjs.com/misc/semver</a>.</p><p>Now that you have NPM set up and you know how to install your development dependencies, you can move on to installing Bower.</p></div></div></div></div></div>
<div class="section" title="Bower"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"/>Bower</h1></div></div></div><p>Bower is a package manager for frontend web assets and libraries. You will use it to maintain your frontend stack and control version chains for libraries such as jQuery, AngularJS, and any other components necessary to your app's web interface.</p><div class="section" title="Installing Bower"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec7"/>Installing Bower</h2></div></div></div><p>Bower is also a Node.js package, so you will install it using NPM, much like you did with the Browserify example installation in the previous section, but this time you will be installing the package globally. This will allow you to run <code class="literal">bower</code> from the command line anywhere on your system without having to install it locally for each project:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g bower</strong></span>
</pre><p>You can alternatively install Bower locally as a development dependency so that you may maintain different versions of it for different projects on the same system, but this is generally not necessary:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install bower --save-dev</strong></span>
</pre><p>Next, check that Bower is properly installed by querying the version from the command line:</p><pre class="programlisting">
<span class="strong"><strong>$ bower -v</strong></span>
</pre><p>Bower also requires a <span class="emphasis"><em>Git</em></span> version control system, or <span class="emphasis"><em>VCS</em></span>, to be installed on your system in order to work with packages. This is because Bower communicates directly with GitHub for package management data. If you do not have Git installed on your system, you can find instructions for Linux, Mac, and Windows at <a class="ulink" href="http://git-scm.com">git-scm.com</a>.</p></div><div class="section" title="Configuring your bower.json file"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec8"/>Configuring your bower.json file</h2></div></div></div><p>The process of setting up your <code class="literal">bower.json</code> file is comparable to that of the <code class="literal">package.json</code> file for NPM. It uses the same JSON format, has both <code class="literal">dependencies</code> and <code class="literal">devDependencies</code>, and can also be automatically created:</p><pre class="programlisting">
<span class="strong"><strong>$ bower init</strong></span>
</pre><p>Once you type <code class="literal">bower init</code> from the command line, you will be prompted to define several properties with some defaults given within parentheses:</p><pre class="programlisting">? name: my-app &#13;
? version: 0.0.0 &#13;
? description: My app description. &#13;
? main file: index.html &#13;
? what types of modules does this package expose? (Press &lt;space&gt; to? what types of modules does this package expose? globals &#13;
? keywords: my, app, keywords &#13;
? authors: Philip Klauzinski &#13;
? license: MIT &#13;
? homepage: http://gui.ninja &#13;
? set currently installed components as dependencies? No &#13;
? add commonly ignored files to ignore list? Yes &#13;
? would you like to mark this package as private which prevents it from being accidentally published to the registry? Yes &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip4"/>Tip</h3><p>These questions may vary, depending on the version of Bower you install.</p></div></div><p>Most properties in the <code class="literal">bower.json</code> file are not necessary unless you are publishing your project to the Bower registry, indicated in the final prompt. You will most likely want to mark your package as private, unless you plan to register it and allow others to download it as a Bower package.</p><p>Once you have created the <code class="literal">bower.json</code> file, you can open it in a text editor and change or remove any properties you wish. It should look something like the following example:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "version": "0.0.0", &#13;
  "authors": [ &#13;
    "Philip Klauzinski" &#13;
  ], &#13;
  "description": "My app description.", &#13;
  "main": "index.html", &#13;
  "moduleType": [ &#13;
    "globals" &#13;
  ], &#13;
  "keywords": [ &#13;
    "my", &#13;
    "app", &#13;
    "keywords" &#13;
  ], &#13;
  "license": "MIT", &#13;
  "homepage": "http://gui.ninja", &#13;
  "ignore": [ &#13;
    "**/.*", &#13;
    "node_modules", &#13;
    "bower_components", &#13;
    "test", &#13;
    "tests" &#13;
  ], &#13;
  "private": true &#13;
} &#13;
</pre><p>If you wish to keep your project private, you can reduce your <code class="literal">bower.json</code> file to two properties before continuing:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "private": true &#13;
} &#13;
</pre><p>Once you have the initial version of your <code class="literal">bower.json</code> file set up the way you like it, you can begin installing components for your app.</p><div class="section" title="Bower components location and the .bowerrc file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec1"/>Bower components location and the .bowerrc file</h3></div></div></div><p>Bower will install components into a directory named <code class="literal">bower_components</code> by default. This directory will be located directly under the root of your project. If you wish to install your Bower components under a different directory name, you must create a local system file named <code class="literal">.bowerrc</code> and define the custom directory name there:</p><pre class="programlisting">{ &#13;
  "directory": "path/to/my_components" &#13;
} &#13;
</pre><p>An object with only a single <code class="literal">directory</code> property name is all that is necessary to define a custom location for your Bower components. There are many other properties that can be configured within a <code class="literal">.bowerrc</code> file. For more information on configuring Bower, see bower.io/docs/config/.</p></div><div class="section" title="Bower dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec2"/>Bower dependencies</h3></div></div></div><p>Bower also allows you to define both the <code class="literal">dependencies</code> and <code class="literal">devDependencies</code> objects like NPM. The distinction with Bower, however, is that the <code class="literal">dependencies</code> object will contain the components necessary for running your app, while the <code class="literal">devDependencies</code> object is reserved for components that you might use for testing, transpiling, or anything that does not need to be included in your frontend stack.</p><p>Bower packages are managed using the <code class="literal">bower </code>command from the CLI. This is a user command, so it does not require super user (sudo) permissions. Let's begin by installing jQuery as a frontend dependency for your app:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install jquery --save</strong></span>
</pre><p>The <code class="literal">--save</code> option on the command line will save the package and version number to the <code class="literal">dependencies</code> object in <code class="literal">bower.json</code>. Alternatively, you can use the <code class="literal">-S</code> option as a shortcut for <code class="literal">--save</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install jquery -S</strong></span>
</pre><p>Next, let's install the Mocha JavaScript testing framework as a development dependency:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install mocha --save-dev</strong></span>
</pre><p>In this case, we will use <code class="literal">--save-dev</code> on the command line to save the package to the <code class="literal">devDependencies</code> object instead. Your <code class="literal">bower.json</code> file should now look similar to the following example:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "private": true, &#13;
  "dependencies": { &#13;
    "jquery": "~2.1.4" &#13;
  }, &#13;
  "devDependencies": { &#13;
    "mocha": "~2.3.4" &#13;
  } &#13;
} &#13;
</pre><p>Alternatively, you can use the <code class="literal">-D</code> option as a shortcut for <code class="literal">--save-dev</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install mocha -D</strong></span>
</pre><p>You will notice that the package version numbers are preceded by the <span class="strong"><strong>tilde</strong></span> (<code class="literal">~</code>) symbol by default, in contrast to the caret (<code class="literal">^</code>) symbol as is the case with NPM. The tilde serves as a more stringent guard against package version updates. With a <code class="literal">MAJOR.MINOR.PATCH</code> version number, running <code class="literal">bower update</code> will only update to the latest patch version. If a version number is composed of only the major and minor versions, <code class="literal">bower update</code> will update the package to the latest minor version.</p></div></div><div class="section" title="Searching the Bower registry"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec9"/>Searching the Bower registry</h2></div></div></div><p>All registered Bower components are indexed and searchable through the command line. If you don't know the exact package name of a component you wish to install, you can perform a search to retrieve a list of matching names.</p><p>Most components will have a list of keywords in their <code class="literal">bower.json</code> file so that you can more easily find the package without knowing the exact name. For example, you may want to install PhantomJS for headless browser testing:</p><pre class="programlisting">
<span class="strong"><strong>$ bower search phantomjs</strong></span>
</pre><p>The list returned will include any package with <code class="literal">phantomjs</code> in the package name or within its keywords list:</p><pre class="programlisting">
<span class="strong"><strong>    phantom git://github.com/ariya/phantomjs.git</strong></span>
<span class="strong"><strong>    dt-phantomjs git://github.com/keesey/dt-phantomjs</strong></span>
<span class="strong"><strong>    qunit-phantomjs-runner git://github.com/jonkemp/...</strong></span>
<span class="strong"><strong>    parse-cookie-phantomjs git://github.com/sindresorhus/...</strong></span>
<span class="strong"><strong>    highcharts-phantomjs git://github.com/pesla/highcharts-phantomjs.git</strong></span>
<span class="strong"><strong>    mocha-phantomjs git://github.com/metaskills/mocha-phantomjs.git</strong></span>
<span class="strong"><strong>    purescript-phantomjs git://github.com/cxfreeio/purescript-phantomjs.git</strong></span>
</pre><p>You can see from the returned list that the correct package name for PhantomJS is in fact <code class="literal">phantom</code> and not <code class="literal">phantomjs</code>. You can then proceed to install the package now that you know the correct name:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install phantom --save-dev</strong></span>
</pre><p>Now you have Bower installed and know how to manage your frontend web components and development tools, but how do you integrate them into your SPA? This is where Grunt comes in.</p></div></div>
<div class="section" title="Grunt"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Grunt</h1></div></div></div><p>Grunt is a <span class="emphasis"><em>JavaScript task runner</em></span> for Node.js, and if you haven't used it before, it is perhaps the best tool you never knew you needed. You will find it useful for a myriad of tasks including CSS and JavaScript linting and minification, JavaScript template pre-compilation, LESS and SASS pre-processing, and so much more. There are indeed alternatives to Grunt, but none with as large an ecosystem of plugins (at the time of writing).</p><p>There are two components to Grunt: the <span class="emphasis"><em>Grunt CLI</em></span>, and the <span class="emphasis"><em>Grunt task runner</em></span> itself. The Grunt CLI allows you to run the Grunt task runner command from the command line within a directory that has Grunt installed. This allows you to have a different version of Grunt running for each project on your machine, making each app more maintainable. For more information, see <a class="ulink" href="http://gruntjs.com">gruntjs.com</a>.</p><div class="section" title="Installing the Grunt CLI"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Installing the Grunt CLI</h2></div></div></div><p>You will want to install the Grunt CLI globally, just as you did with Bower:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g grunt-cli</strong></span>
</pre><p>Remember that the Grunt CLI is not the Grunt task runner. It simply makes the <code class="literal">grunt</code> command available to you from the command line. This distinction is important, because while the <code class="literal">grunt</code> command will be globally available from the command line, it will always look for a local installation in the directory from which you run it.</p></div><div class="section" title="Installing the Grunt task runner"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Installing the Grunt task runner</h2></div></div></div><p>You will install the Grunt task runner locally from the root of your app where your <code class="literal">package.json</code> file is located. Grunt is installed as a Node.js package:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install grunt --save-dev</strong></span>
</pre><p>Once you have Grunt installed locally, your <code class="literal">package.json</code> file should look like the following example:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "version": "1.0.0", &#13;
  "author": "Philip Klauzinski", &#13;
  "license": "MIT", &#13;
  "devDependencies": { &#13;
    "grunt": "^0.4.5" &#13;
  } &#13;
} &#13;
</pre><p>You will notice a <code class="literal">devDependencies</code> object has been added to your <code class="literal">package.json</code> file, if it was not already there from a previous install.</p><p>Now that you have Grunt installed locally, let's begin installing some plugins to work with.</p></div><div class="section" title="Installing Grunt plugins"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Installing Grunt plugins</h2></div></div></div><p>All Grunt task plugins are Node.js packages, so they will be installed using NPM as well. There are thousands of Grunt plugins written by a multitude of authors, as Grunt is an open-source project. Every Node.js package for Grunt is prefixed with <code class="literal">grunt</code> in the name. The Grunt team, however, does maintain many plugins themselves. The officially maintained Grunt plugins are all prefixed with <code class="literal">grunt-contrib</code>, so this is how you can differentiate them if you wish to stick with only officially maintained Grunt plugins. To view and search all registered Grunt plugins, see gruntjs.com/plugins.</p><p>Since you will be writing a JavaScript SPA, let's begin by installing a JavaScript <span class="emphasis"><em>linting</em></span> plugin for Grunt. Linting refers to running a program against your code to analyze it for errors and, in some cases, proper formatting. It is always a good idea to have a linting utility running to test your JavaScript code for valid syntax and formatting:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install grunt-contrib-jshint --save-dev</strong></span>
</pre><p>This will install the officially maintained Grunt plugin for <code class="literal">JSHint</code> and add it to the <code class="literal">devDependencies</code> object in your <code class="literal">package.json</code> file as shown in the following example:</p><pre class="programlisting">{ &#13;
  "name": "my-app", &#13;
  "version": "1.0.0", &#13;
  "author": "Philip Klauzinski", &#13;
  "license": "MIT", &#13;
  "devDependencies": { &#13;
    "grunt": "^0.4.5", &#13;
    "grunt-contrib-jshint": "^0.11.3" &#13;
  } &#13;
} &#13;
</pre><p>
<code class="literal">JSHint</code> is a popular tool for detecting errors and potential problems in your JavaScript code. The Grunt plugin itself will allow you to automate that process so that you can easily check your code as you develop.</p><p>Another invaluable Grunt plugin is <code class="literal">grunt-contrib-watch</code>. This plugin allows you to run a task which will automatically run other Grunt tasks when you add, delete, or edit files in your project that match a predefined set of rules.</p><pre class="programlisting">
<span class="strong"><strong>$ npm install grunt-contrib-watch --save-dev</strong></span>
</pre><p>After installing the <code class="literal">grunt-contrib-watch plugin</code>, the <code class="literal">devDependencies</code> object in your <code class="literal">package.json</code> file should look like this:</p><pre class="programlisting">  "devDependencies": { &#13;
    "grunt": "^0.4.5", &#13;
    "grunt-contrib-jshint": "^0.11.3", &#13;
    "grunt-contrib-watch": "^0.6.1" &#13;
  } &#13;
</pre><p>Now that you have a couple of Grunt plugins installed, let's begin writing some tasks for them. In order to do that, you will first need to create a local configuration file for Grunt.</p></div><div class="section" title="Configuring Grunt"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Configuring Grunt</h2></div></div></div><p>Unlike NPM and Bower, Grunt does not provide an <code class="literal">init</code> command for initializing its configuration file. Instead, <span class="emphasis"><em>scaffolding</em></span> tools can be used for this. Project scaffolding tools are designed to set up some basic directory structure and configuration files for a development project. Grunt maintains an official scaffolding tool called <code class="literal">grunt-init</code>, which is referenced on their website. The <code class="literal">grunt-init</code> tool must be installed separately from the <code class="literal">grunt-cli</code> global package and the local <code class="literal">grunt</code> package for any particular project. It is most useful if installed globally, so it can be used with any project.</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g grunt-init</strong></span>
</pre><p>We will not go into further detail on <code class="literal">grunt-init</code> here, but if you would like to learn more, you can visit <a class="ulink" href="http://gruntjs.com/project-scaffolding">gruntjs.com/project-scaffolding</a>.</p><p>The best way to learn about configuring Grunt is to write its configuration file by hand. The configuration for Grunt is maintained in a file called <code class="literal">Gruntfile.js</code>, referred to as a <code class="literal">Gruntfile</code>, located in the root directory of your project, along with <code class="literal">package.json</code> and <code class="literal">bower.json</code>. If you are not familiar with Node.js and its concept of modules and exports, the syntax for a <code class="literal">Gruntfile</code> may be a bit confusing at first. Since Node.js files run on the server and not in a browser, they do not interact in the same way that files loaded in a browser do, with respect to browser <code class="literal">globals</code>.</p><div class="section" title="Understanding Node.js modules"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec3"/>Understanding Node.js modules</h3></div></div></div><p>In Node.js, a module is a JavaScript object defined within a file. The module name is the name of the file. For instance, if you want to declare a module named <code class="literal">foo</code>, you will create a file named <code class="literal">foo.js</code>. In order for the <code class="literal">foo</code> module to be accessible to another module, it must be exported. In its most basic form, a module looks something like the following example:</p><pre class="programlisting">module.exports = { &#13;
    // Object properties here &#13;
};</pre><p>Every module has a local <code class="literal">exports</code> variable that allows you to make the module accessible to others. In other words, the object <code class="literal">module</code> within a file refers to the current module itself, and the <code class="literal">exports</code> property of <code class="literal">module</code> makes that module available to any other module (or file).</p><p>Another way of defining a module is by exporting a function, which is of course a JavaScript object itself:</p><pre class="programlisting">module.exports = function() { &#13;
    // Code for the module here &#13;
};</pre><p>When you call for a Node.js module from within a file, it will first look for a core module, all of which are compiled into Node.js itself. If the name does not match a core module, it will then look for a directory named <code class="literal">node_modules</code> beginning from the current or root directory of your project. This directory is where all of your local NPM packages, including Grunt plugins, will be stored. If you performed the installs of <code class="literal">grunt-contrib-jshint</code> and <code class="literal">grunt-contrib-watch</code> from earlier, you will see that this directory now exists within your project.</p><p>Now that you understand a bit more about how Node.js modules work, let's create a <code class="literal">Gruntfile</code>.</p></div><div class="section" title="Creating a Gruntfile"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec4"/>Creating a Gruntfile</h3></div></div></div><p>A <code class="literal">Gruntfile</code> uses the function form of <code class="literal">module.exports</code> as shown previously. This is referred to as a <span class="emphasis"><em>wrapper function</em></span>. The <code class="literal">grunt</code> module itself is passed to the wrapper function. The <code class="literal">grunt</code> module will be available to your <code class="literal">Gruntfile</code> because you installed the <code class="literal">grunt</code> NPM package locally:</p><pre class="programlisting">module.exports = function(grunt) { &#13;
    // Grunt code here &#13;
};</pre><p>This example shows what your initial <code class="literal">Gruntfile</code> should look like. Now let's flesh it out some more. In order to configure Grunt and run tasks with it, you will need to access the <code class="literal">grunt</code> module that is passed in to your <code class="literal">Gruntfile</code>.</p><pre class="programlisting">module.exports = function(grunt) { &#13;
    'use strict'; &#13;
    grunt.initConfig({ &#13;
        pkg: grunt.file.readJSON('package.json') &#13;
});&#13;
};</pre><p>This basic format is what you will be working with the rest of the way. You can see here that the <code class="literal">grunt.initConfig</code> method is called and passed a single configuration object as a parameter. This configuration object is where all of your Grunt task code will go. The <code class="literal">pkg</code> property shown in this example, which is assigned the value of <code class="literal">grunt.file.readJSON('package.json')</code>, allows you to pass in information about your project directly from your <code class="literal">package.json</code> file. The use of this property will be shown in later examples.</p><div class="section" title="Defining Grunt task configuration"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec1"/>Defining Grunt task configuration</h4></div></div></div><p>Most Grunt tasks expect their configuration to be defined within a property of the same name as the task, which is the suffix of the package name. For example, <code class="literal">jshint</code> is the Grunt task name for the <code class="literal">grunt-contrib-jshint</code> package we previously installed:</p><pre class="programlisting">module.exports = function(grunt) { &#13;
    'use strict'; &#13;
    grunt.initConfig({ &#13;
        pkg: grunt.file.readJSON('package.json'), &#13;
        jshint: { &#13;
            options: { &#13;
                curly: true, &#13;
                eqeqeq: true, &#13;
                eqnull: true, &#13;
                browser: true, &#13;
                newcap: false, &#13;
                es3: true, &#13;
                forin: true, &#13;
                indent: 4, &#13;
                unused: 'vars', &#13;
                strict: true, &#13;
                trailing: true, &#13;
                quotmark: 'single', &#13;
                latedef: true, &#13;
                globals: { &#13;
                    jQuery: true &#13;
                } &#13;
            }, &#13;
            files: { &#13;
                src: ['Gruntfile.js', 'js/src/*.js'] &#13;
            } &#13;
        } &#13;
    }); &#13;
}; &#13;
</pre><p>Here you can see that the <code class="literal">jshint</code> property of the configuration object is defined and is assigned its own properties which apply to the <code class="literal">jshint</code> Grunt task itself. The <code class="literal">options</code> property defined within <code class="literal">jshint</code> holds the settings you wish to validate against when linting your JavaScript files. The <code class="literal">files</code> property defines a list of the files you wish to validate. For more information on the supported options for <code class="literal">JSHint</code> and what they mean, see jshint.com/docs/.</p><p>Let's now add an additional configuration for the <code class="literal">grunt-contrib-watch</code> plugin <code class="literal">watch</code> task below the <code class="literal">jshint</code> task configuration:</p><pre class="programlisting">watch: { &#13;
    jshint: { &#13;
        files: ['js/src/*.js'], &#13;
        tasks: ['jshint'] &#13;
    } &#13;
} &#13;
</pre><p>Here we add an additional namespace of <code class="literal">jshint</code> underneath the <code class="literal">watch</code> task, which allows for other <span class="emphasis"><em>targets</em></span> to be defined within the same configuration property and run separately if needs be. This is what is known as a <span class="emphasis"><em>multitask</em></span>. Targets within a multitask can be named arbitrarily and will simply be run in the order which they are defined if the multitask is called alone. A target can be called directly as well, and doing so will ignore any of the other targets defined within the multitask's configuration:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt watch:jshint</strong></span>
</pre><p>This particular configuration for the target <code class="literal">jshint</code> tells the <code class="literal">watch</code> task that if any files matching <code class="literal">js/src/*.js</code> are changed, then to run the <code class="literal">jshint</code> task.</p><p>Now you have your first two Grunt task configurations defined within your <code class="literal">Gruntfile</code>, but in order to use them, we must load the Grunt tasks themselves.</p></div><div class="section" title="Loading Grunt plugins"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec2"/>Loading Grunt plugins</h4></div></div></div><p>You have already installed the <code class="literal">grunt-contrib-jshint</code> plugin as a Node.js module, but in order to execute the <code class="literal">jshint</code> task, you must load the plugin within your <code class="literal">Gruntfile</code>. This is done after the <code class="literal">grunt.initConfig</code> call:</p><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-jshint'); &#13;
</pre><p>This is the same method call you will use to load all Grunt tasks within your <code class="literal">Gruntfile</code>, and any Grunt task will not be accessible without doing so. Let's do the same for <code class="literal">grunt-contrib-watch</code>:</p><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-watch'); &#13;
</pre><p>Your full <code class="literal">Gruntfile</code> should now look like this:</p><pre class="programlisting">module.exports = function(grunt) { &#13;
    'use strict'; &#13;
    grunt.initConfig({ &#13;
        pkg: grunt.file.readJSON('package.json'), &#13;
        jshint: { &#13;
            options: { &#13;
                curly: true, &#13;
                eqeqeq: true, &#13;
                eqnull: true, &#13;
                browser: true, &#13;
                newcap: false, &#13;
                es3: true, &#13;
                forin: true, &#13;
                indent: 4, &#13;
                unused: 'vars', &#13;
                strict: true, &#13;
                trailing: true, &#13;
                quotmark: 'single', &#13;
                latedef: true, &#13;
                globals: { &#13;
                    jQuery: true &#13;
                } &#13;
            }, &#13;
            files: { &#13;
                src: ['Gruntfile.js', 'js/src/*.js'] &#13;
            } &#13;
        }, &#13;
        watch: { &#13;
            jshint: { &#13;
                files: ['js/src/*.js'], &#13;
                tasks: ['jshint'] &#13;
            } &#13;
        } &#13;
    }); &#13;
    grunt.loadNpmTasks('grunt-contrib-jshint'); &#13;
    grunt.loadNpmTasks('grunt-contrib-watch'); &#13;
}; &#13;
</pre></div><div class="section" title="Running the jshint Grunt task"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec3"/>Running the jshint Grunt task</h4></div></div></div><p>Now that you have the plugin loaded, you can simply run <code class="literal">grunt jshint</code> from the command line to execute the task with its defined configuration. You should see the following output:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt jshint</strong></span>
<span class="strong"><strong>Running "jshint:files" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 1 file lint free.</strong></span>
<span class="strong"><strong>Done, without errors</strong></span>
</pre><p>This will run your <code class="literal">JSHint</code> linting options against the defined files, which as of now consist of only <code class="literal">Gruntfile.js</code>. If it looks like the example file shown and includes the call to <code class="literal">grunt.loadNpmTasks('grunt-contrib-jshint')</code>, then it should pass without errors.</p><p>Now let's create a new JavaScript file and intentionally include some code which will not pass the JSHint configuration so we can see how the errors are reported. First, create the <code class="literal">js/src</code> directory, which is defined in the <code class="literal">files</code> property of the <code class="literal">jshint</code> task:</p><pre class="programlisting">
<span class="strong"><strong>$ mkdir -p js/src</strong></span>
</pre><p>Then create a file named <code class="literal">app.js</code> within this directory and place the following code in it:</p><pre class="programlisting">var test = function() { &#13;
    console.log('test'); &#13;
}; &#13;
</pre><p>Now run <code class="literal">grunt jshint</code> again from the command line. You should see the following output:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt jshint</strong></span>
<span class="strong"><strong>Running "jshint:files" (jshint) task</strong></span>
<span class="strong"><strong>   js/src/app.js</strong></span>
<span class="strong"><strong>      2 |    console.log('test');</strong></span>
<span class="strong"><strong>             ^ Missing "use strict" statement.</strong></span>
<span class="strong"><strong>      1 |var test = function() {</strong></span>
<span class="strong"><strong>             ^ 'test' is defined but never used.</strong></span>
<span class="strong"><strong>&gt;&gt; 2 errors in 2 files</strong></span>
<span class="strong"><strong>Warning: Task "jshint:files" failed. Use --force to continue.</strong></span>
<span class="strong"><strong>Aborted due to warnings.</strong></span>
</pre><p>You will notice that two errors are reported for <code class="literal">js/src/app.js</code> based on the <code class="literal">jshint</code> task configuration options. Let's fix the errors by changing the code in <code class="literal">app.js</code> to the following:</p><pre class="programlisting">var test = function() { &#13;
    'use strict'; &#13;
    console.log('test'); &#13;
}; &#13;
test(); &#13;
 &#13;
</pre><p>Now if you run <code class="literal">grunt jshint</code> from the command line again, it will report that the files are lint free and have no errors:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt jshint</strong></span>
<span class="strong"><strong>Running "jshint:files" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 2 files lint free.</strong></span>
<span class="strong"><strong>Done, without errors.</strong></span>
</pre></div><div class="section" title="Running the watch Grunt task"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec4"/>Running the watch Grunt task</h4></div></div></div><p>As mentioned earlier, when the <code class="literal">watch</code> task is run it will wait for changes that match the file patterns defined in its configuration and run any corresponding tasks. In this case, we configured it to run <code class="literal">jshint</code> when any files matching <code class="literal">js/src/*.js</code> are changed. Since we defined a target within the <code class="literal">watch</code> task called <code class="literal">jshint</code>, the <code class="literal">watch</code> task can be run in two different ways:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt watch</strong></span>
</pre><p>Running <code class="literal">grunt watch</code> will watch for changes matching all target configurations defined within the <code class="literal">watch</code> task:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt watch:jshint</strong></span>
</pre><p>Running <code class="literal">grunt watch:jshint</code> with the colon (<code class="literal">:</code>) syntax runs <code class="literal">watch</code> for just the file patterns matching that target configuration. In our case, only one target is defined, so let's just run <code class="literal">grunt watch</code> and see what happens in the console:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt watch</strong></span>
<span class="strong"><strong>Running "watch" task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
</pre><p>You will see that the task now shows a status of <code class="literal">Waiting...</code> on the command line. This indicates that the task is running to watch for matching changes within its configuration, and if any of those changes are made, it will automatically run the corresponding tasks. In our example with the <code class="literal">jshint</code> task, it will allow your code to automatically be linted every time you make changes to your JavaScript files and save them. If a <code class="literal">JSHint</code> error occurs, the console will alert you and display the error.</p><p>Let's test this by opening a text editor and changing <code class="literal">js/src/app.js</code> again:</p><pre class="programlisting">var test = function() { &#13;
    console.log('test'); &#13;
}; &#13;
test() &#13;
</pre><p>Here, we removed the opening <code class="literal">use strict</code> statement and the semicolon after the call to <code class="literal">test()</code> at the end of the file. This should raise two <code class="literal">JSHint</code> errors:</p><pre class="programlisting">
<span class="strong"><strong>&gt;&gt; File "js/src/app.js" changed.</strong></span>
<span class="strong"><strong>Running "jshint:files" (jshint) task&#13;
</strong></span>
<span class="strong"><strong>   js/src/app.js</strong></span>
<span class="strong"><strong>      2 |    console.log('test');</strong></span>
<span class="strong"><strong>             ^ Missing "use strict" statement.</strong></span>
<span class="strong"><strong>      4 |test()</strong></span>
<span class="strong"><strong>               ^ Missing semicolon.</strong></span>
<span class="strong"><strong>&gt;&gt; 2 errors in 2 files</strong></span>
<span class="strong"><strong>Warning: Task "jshint:files" failed. Use --force to continue.</strong></span>
<span class="strong"><strong>Aborted due to warnings.</strong></span>
</pre><p>Now let's correct these errors and return the file to the way it was before:</p><pre class="programlisting">var test = function() { &#13;
    'use strict'; &#13;
    console.log('test'); &#13;
}; &#13;
test(); &#13;
</pre><p>Press <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>C</em></span> from the command line at any time to abort the <code class="literal">watch</code> task, or any Grunt task, while it is running.</p></div><div class="section" title="Defining the default Grunt task"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec5"/>Defining the default Grunt task</h4></div></div></div><p>Grunt allows you to define a <code class="literal">default</code> task which will run when you simply type <code class="literal">grunt</code> on the command line with no parameters. To do this, you will use the <code class="literal">grunt.registerTask()</code> method:</p><pre class="programlisting">
<span class="strong"><strong>grunt.registerTask('default', ['jshint', 'watch:jshint']);</strong></span>
</pre><p>This example sets the default Grunt task to run the defined <code class="literal">jshint</code> task first and then the <code class="literal">watch:jshint</code> multitask target. You can see that the tasks passed to the <code class="literal">default</code> task are in an array, so you can set the <code class="literal">default</code> task for Grunt to run any number of tasks by simply typing <code class="literal">grunt</code> on the command line:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt</strong></span>
<span class="strong"><strong>Running "jshint:files" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 2 files lint free.</strong></span>
<span class="strong"><strong>Running "watch:jshint" (watch) task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
</pre><p>From looking at the output, you can see that the <code class="literal">jshint</code> task was run once initially, and then <code class="literal">watch:jshint</code> was run to wait for additional changes to the configured file patterns.</p></div><div class="section" title="Defining custom tasks"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec6"/>Defining custom tasks</h4></div></div></div><p>Grunt allows you to define your own custom tasks, in the same way that you defined the default task. In this way, you can actually write your own custom tasks directly within the <code class="literal">Gruntfile</code>, or you can load them from an external file, just as you did with <code class="literal">grunt-contrib-jshint</code> and <code class="literal">grunt-contrib-watch</code>.</p><p>
<span class="strong"><strong>Alias tasks</strong></span>
</p><p>One way of defining a custom task is to simply call one or more existing tasks in the order you want them to be run:</p><pre class="programlisting">grunt.registerTask('my-task', 'My custom task.', ['jshint']); &#13;
 &#13;
</pre><p>In this example, we have simply defined a task named <code class="literal">my-task</code> to serve as a proxy for <code class="literal">jshint</code>. The second parameter is an optional description of the task, which must be a string. The third parameter, which passes an array, including only <code class="literal">jshint</code> in this example, must always be an array. You can also forgo the second parameter with the description and pass in your array of tasks there instead. This way of defining a task is known as an <span class="emphasis"><em>alias task</em></span>.</p><p>
<span class="strong"><strong>Basic tasks</strong></span>
</p><p>When you define custom Grunt tasks, you are not limited to only calling other tasks that exist within your configuration, but you can write JavaScript code to be called directly as a function. This is called a <span class="emphasis"><em>basic task</em></span>:</p><pre class="programlisting">grunt.registerTask('my-task', 'My custom task.', function() { &#13;
    grunt.log.writeln('This is my custom task.'); &#13;
}); &#13;
</pre><p>In this example, we simply write a string to the command line output for the task. The output should look like this:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt my-task</strong></span>
<span class="strong"><strong>Running "my-task" task</strong></span>
<span class="strong"><strong>This is my custom task.</strong></span>
</pre><p>Let's expand upon this example and pass in some arguments to our basic task function, as well as access the arguments from within the function:</p><pre class="programlisting">grunt.registerTask('my-task', 'My custom task.', function(arg1, arg2) { &#13;
    grunt.log.writeln(this.name + ' output...'); &#13;
    grunt.log.writeln('arg1: ' + arg1 + ', arg2: ' + arg2); &#13;
}); &#13;
</pre><p>You will notice that there is a property available to the basic task, <code class="literal">this.name</code>, which is simply a reference to the name of the task. In order to call a basic task from the command line and pass arguments in, you will use a colon after the task name to define each argument in succession. This syntax is just like the syntax for running a multitask target; however, in this case you are passing in arbitrary arguments:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt my-task:1:2</strong></span>
</pre><p>Running this will output the following:</p><pre class="programlisting">
<span class="strong"><strong>Running "my-task:1:2" (my-task) task</strong></span>
<span class="strong"><strong>my-task output...</strong></span>
<span class="strong"><strong>arg1: 1, arg2: 2</strong></span>
</pre><p>If you do not pass in the arguments to a task that is expecting them, it will simply resolve them as <code class="literal">undefined</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt my-task</strong></span>
<span class="strong"><strong>Running "my-task" task</strong></span>
<span class="strong"><strong>my-task output...</strong></span>
<span class="strong"><strong>arg1: undefined, arg2: undefined</strong></span>
<span class="strong"><strong>Done, without errors.</strong></span>
</pre><p>You can also call other tasks from within a custom task:</p><pre class="programlisting">grunt.registerTask('foo', 'My custom task.', function() { &#13;
    grunt.log.writeln('Now calling the jshint and watch tasks...'); &#13;
    grunt.task.run('jshint', 'watch'); &#13;
}); &#13;
</pre><p>In this example, we have created a task, <code class="literal">foo</code>, that defines a custom function that calls the existing <code class="literal">jshint</code> and <code class="literal">watch</code> tasks:</p><pre class="programlisting">
<span class="strong"><strong>$ grunt foo</strong></span>
<span class="strong"><strong>Running "foo" task</strong></span>
<span class="strong"><strong>Now calling the jshint and watch tasks...</strong></span>
<span class="strong"><strong>Running "jshint:files" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 2 files lint free.</strong></span>
<span class="strong"><strong>Running "watch" task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
</pre><p>For more information on creating custom tasks with Grunt, see gruntjs.com/creating-tasks.</p><p>These examples of tasks only scratch the surface of what is capable with Grunt, but you should be able to glean from them the power of it and begin to think about what might be possible with Grunt tasks when building your own SPA.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>Now that you have learned to set up an optimal development environment with NPM, supply it with frontend dependencies using Bower, and automate development tasks using Grunt, it's time to start learning more about building a real app. In the next chapter, we will dive into common SPA architecture design patterns, what they mean, and what is the best design pattern to choose based on the type of SPA you are building.</p></div></body></html>