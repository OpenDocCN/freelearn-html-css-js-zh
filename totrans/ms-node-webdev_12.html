<html><head></head><body>
<div><h1 class="chapternumber">11</h1>
<h1 class="chaptertitle" id="_idParaDest-190">Handling Form Data</h1>
<p class="normal1">In this chapter, I demonstrate the ways that Node.js applications can receive form data and explain the differences, including supporting uploading files. This chapter also explains how to sanitize form data so that it can be safely included in HTML documents, and how to validate data before it is used. <em class="italic">Table 11.1</em> puts this chapter in context.</p>
<p class="packt_figref">Table 11.1: Putting HTML forms in context</p>
<table class="table-container" id="table001-8">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">HTML forms allow users to provide data by entering values into form fields.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Forms are the only ways in which data values can be collected from users in a structured way.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">HTML documents contain a <code class="inlinecode">form</code> element that contains one or more elements that allow data to be entered, such as an <code class="inlinecode">input</code> element.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">The data that’s entered into a form must be sanitized before inclusion in HTML output and validated before it is used by the applications.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Forms are the only way to efficiently solicit data from users. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 11.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 11.2: Chapter summary</p>
<table class="table-container" id="table002-8">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Receive data from the user.</p>
</td>
<td class="table-cell">
<p class="normal">Use an HTML form configured to send data to the server.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">1-10</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Receive data used for non-idempotent operations.</p>
</td>
<td class="table-cell">
<p class="normal">Configure the form to use HTTP <code class="inlinecode">POST</code> requests.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">11, 12</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Receive complex data, including the contents of files.</p>
</td>
<td class="table-cell">
<p class="normal">Use multipart form encoding.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">13-16</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Prevent user data from being interpreted as HTML elements.</p>
</td>
<td class="table-cell">
<p class="normal">Sanitize the data received from the user.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">17-21</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Ensure the application receives useful data.</p>
</td>
<td class="table-cell">
<p class="normal">Validate the data received from the user.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">22-27, 30-32</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Provide immediate validation feedback to the user.</p>
</td>
<td class="table-cell">
<p class="normal">Validate the data in the browser before the form is submitted. </p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">28-29</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-191">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">part2app</code> project from <em class="italic">Chapter 10</em>. Run the commands shown in <em class="italic">Listing 11.1</em> in the <code class="inlinecode">part2app</code> folder to remove files that are no longer required.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 11.1: Removing files</p>
<pre class="programlisting1"><code class="hljs-con">rm ./templates/**/*.handlebars
rm ./templates/**/*.custom
rm ./src/client/*_custom.js
rm ./src/server/*custom*.ts
</code></pre>
<p class="normal">Next, replace the contents of the <code class="inlinecode">client.js</code> file in the <code class="inlinecode">src/client</code> folder with the contents shown in <em class="italic">Listing 11.2</em>.</p>
<p class="packt_figref">Listing 11.2: The contents of the client.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', () =&gt; {
    // do nothing
});
</code></pre>
<p class="normal">This is a placeholder until later in the chapter when client-side code will be needed again. Replace the contents of the <code class="inlinecode">index.html</code> file in the <code class="inlinecode">static</code> folder with the elements shown in <em class="italic">Listing 11.3</em>.</p>
<p class="packt_figref">Listing 11.3: The contents of the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;div class="m-2"&gt;
                &lt;label class="form-label"&gt;Name&lt;/label&gt;
                &lt;input name="name" class="form-control" /&gt;
            &lt;/div&gt;
            &lt;div class="m-2"&gt;
                &lt;label class="form-label"&gt;City&lt;/label&gt;
                &lt;input name="city" class="form-control" /&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The HTML document contains a simple HTML form that asks the user for their name and city. To keep the code that handles forms separate from the rest of the application, add a file named <code class="inlinecode">forms.ts</code> to the <code class="inlinecode">src/server</code> folder with the content shown in <em class="italic">Listing 11.4</em>. You don’t need to keep the forms code separate; I have only done so to make the examples easier to follow.</p>
<p class="packt_figref">Listing 11.4: The contents of the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const registerFormMiddleware = (app: Express) =&gt; {
    // no middleware yet
}
export const registerFormRoutes = (app: Express) =&gt; {
    // no routes yet
}
</code></pre>
<p class="normal"><em class="italic">Listing 11.5</em> updates the server to use the functions defined in <em class="italic">Listing 11.4</em>.</p>
<p class="packt_figref">Listing 11.5: Configuring the server in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { testHandler } from "./testHandler";
import httpProxy from "http-proxy";
import helmet from "helmet";
import { engine } from "express-handlebars";
import * as helpers from "./template_helpers";
<strong class="screentext">import { registerFormMiddleware, registerFormRoutes } from "./forms";</strong>
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
expressApp.set("views", "templates/server");
expressApp.engine("handlebars", engine());
expressApp.set("view engine", "handlebars");
expressApp.use(helmet());
expressApp.use(express.json());
<strong class="screentext">registerFormMiddleware(expressApp);</strong>
<strong class="screentext">registerFormRoutes(expressApp);</strong>
expressApp.get("/dynamic/:file", (req, resp) =&gt; {
    resp.render(`${req.params.file}.handlebars`,
        { message: "Hello template", req, helpers: { ...helpers } });
});
expressApp.post("/test", testHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal"><em class="italic">Listing 11.6</em> removes a helper from the layout used by the server-side templates and adds a <code class="inlinecode">script</code> element for the JavaScript bundle created by webpack. Some examples in this chapter rely on templates, and removing the helper simplifies the template rendering, while adding the <code class="inlinecode">script</code> element will allow client-side code to be used in content generated from templates.</p>
<p class="packt_figref">Listing 11.6: Changing elements in the main.handlebars file in the templates/server/layouts folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        <strong class="screentext">&lt;script src="img/strong><strong class="screentext">/bundle.js"&gt;&lt;/script&gt;       </strong>
<strong class="screentext">        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;</strong>
    &lt;/head&gt;
    &lt;body&gt;
        {{{ body }}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Finally, create a file named <code class="inlinecode">data.json</code> in the <code class="inlinecode">part2app</code> folder with the content shown in <em class="italic">Listing 11.7</em>. This file will be used to demonstrate how forms can be used to send files to the server.</p>
<p class="packt_figref">Listing 11.7: The contents of the data.json file in the part2app folder</p>
<pre class="programlisting1"><code class="hljs-con">[
    { "city": "London", "population": 8982000 },
    { "city": "Paris", "population": 2161000 },
    { "city": "Beijing", "population": 21540000 }
]
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 11.8</em> in the <code class="inlinecode">part2app</code> folder to start the development tools and begin listening for HTTP requests.</p>
<p class="packt_figref">Listing 11.8: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a web browser and request <code class="inlinecode">http://localhost:5000</code>. You will see the form elements defined in <em class="italic">Listing 11.3</em>, whose appearance has been styled using the Bootstrap CSS package, as shown in <em class="italic">Figure 11.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-192">Receiving form data</h1>
<p class="normal1">Form data<a id="_idIndexMarker520" class="calibre3"/> can be sent using HTTP <code class="inlinecode">GET</code> or <code class="inlinecode">POST</code> requests and the choice of method determines how the data contained in the form is presented. <em class="italic">Listing 11.9</em> completes the form to specify the URL to which the form data will be sent and adds buttons that submit the form data with different HTTP methods. </p>
<p class="packt_figref">Listing 11.9: Completing the form in the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
       <strong class="screentext"> &lt;form action="/form"&gt;</strong>
            &lt;div class="m-2"&gt;
                &lt;label class="form-label"&gt;Name&lt;/label&gt;
                &lt;input name="name" class="form-control" /&gt;
            &lt;/div&gt;
            &lt;div class="m-2"&gt;
                &lt;label class="form-label"&gt;City&lt;/label&gt;
                &lt;input name="city" class="form-control" /&gt;
            &lt;/div&gt;                                    
            <strong class="screentext">&lt;div class="m-2"&gt;</strong>
<strong class="screentext">                &lt;button class="</strong><strong class="screentext">btn btn-primary" formmethod="get"&gt;</strong>
<strong class="screentext">                    Submit (GET)</strong>
<strong class="screentext">                &lt;/button&gt;</strong>
<strong class="screentext">                &lt;button class="btn btn-primary" </strong><strong class="screentext">formmethod="post"&gt;</strong>
<strong class="screentext">                    Submit (POST)</strong>
<strong class="screentext">                &lt;/button&gt;</strong>
<strong class="screentext">            &lt;/div&gt;</strong>
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">action</code> attribute element on the <code class="inlinecode">form</code> element tells the browser to send the form data to the <code class="inlinecode">/form</code> URL. The <code class="inlinecode">button</code> elements are configured with the <code class="inlinecode">formmethod</code> attribute, which <a id="_idIndexMarker521" class="calibre3"/>specifies which HTTP method the browser should use.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">I am using attributes applied to <code class="inlinecode">button</code> elements so that the same form data will be processed in different ways. In later examples, I take a more conventional approach and use attributes applied to the <code class="inlinecode">form</code> element instead.</p>
</div>
<h2 class="heading1" id="_idParaDest-193">Receiving form data from GET requests</h2>
<p class="normal1"><code class="inlinecode">GET</code> requests<a id="_idIndexMarker522" class="calibre3"/> are the simplest way to receive form data because the browser includes the form field names and values in the URL query string. <em class="italic">Listing 11.10</em> defines a handler for form <code class="inlinecode">GET</code> requests. </p>
<p class="packt_figref">Listing 11.10: Handling <code class="inlinecode2">GET</code> requests in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const registerFormMiddleware = (app: Express) =&gt; {
    // no middleware yet
}
export const registerFormRoutes = (app: Express) =&gt; {
  <strong class="screentext">  app.get("</strong><strong class="screentext">/form", (req, resp) =&gt; {</strong>
<strong class="screentext">        for (const key in req.query) {</strong>
<strong class="screentext">            resp.write(`${key}</strong><strong class="screentext">: ${req.query[key]}\n`);           </strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The route uses the <code class="inlinecode">get</code> method to match <code class="inlinecode">GET</code> requests sent to the <code class="inlinecode">/form</code> URL. Express decodes URL query strings and presents them through the <code class="inlinecode">Request.query</code> property. In <em class="italic">Listing 11.10</em>, the query string parameters and values are used to generate<a id="_idIndexMarker523" class="calibre3"/> the response. Use a browser to request <code class="inlinecode">http://localhost:5000</code>, fill out the form using <code class="inlinecode">Alice Smith</code> as the name and <code class="inlinecode">London</code> as the city, and click the <strong class="screentext">Submit </strong>(<strong class="screentext">GET</strong>) button.</p>
<p class="normal">The browser will send a <code class="inlinecode">GET</code> request to the <code class="inlinecode">/form</code> URL and include the values that were entered into the form, like this: </p>
<pre class="programlisting1"><code class="hljs-con">http://localhost:5000/form?name=Alice+Smith&amp;city=London
</code></pre>
<p class="normal">The data will be received by the server, the query string will be parsed, and the form data will be used in the response, as shown in <em class="italic">Figure 11.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.2: Handling form data from a <code class="inlinecode2">GET</code> request</p>
<p class="normal">The limitation of <code class="inlinecode">GET</code> requests is they must be <em class="italic">idempotent</em>, meaning that every request for a given URL should always have the same effect and always return the same result. Put another way, form data sent with a <code class="inlinecode">GET</code> request is effectively a request to read data that isn’t expected to change with every request.</p>
<p class="normal">This is important because HTTP caches are allowed to store the responses to <code class="inlinecode">GET</code> requests and use them to respond to requests for the same URL, which means that some requests may not be received by the backend server. For this reason, most form data is sent using <code class="inlinecode">POST</code> requests, which won’t be cached but which can be more complex to process.</p>
<h2 class="heading1" id="_idParaDest-194">Receiving form data from POST requests</h2>
<p class="normal1">HTTP <code class="inlinecode">POST</code> requests<a id="_idIndexMarker524" class="calibre3"/> include the form data in the request body, which must be read and decoded before it can be used. <em class="italic">Listing 11.11</em> adds a route that handles <code class="inlinecode">POST</code> requests, reads the body, and uses it as the response. </p>
<p class="packt_figref">Listing 11.11: Adding a handler to the form.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const registerFormMiddleware = (app: Express) =&gt; {
    // no middleware yet
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
            resp.write(`${key}: ${req.query[key]}\n`);           
        }
        resp.end();
    });
   <strong class="screentext"> app.post("/form", (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.write</strong><strong class="screentext">(`Content-Type: ${req.headers["content-type"]}\n`)</strong>
<strong class="screentext">        req.pipe(resp);</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">Node.js and Express read the headers from the HTTP request and leave the body so that it can be read as a stream. The new route in <em class="italic">Listing 11.11</em> matches <code class="inlinecode">POST</code> requests sent to <code class="inlinecode">/form</code> and creates a response containing the request’s <code class="inlinecode">Content-Type</code> header and the request body.</p>
<p class="normal">Use a<a id="_idIndexMarker525" class="calibre3"/> browser to request <code class="inlinecode">http://localhost:5000</code>, fill out the form with the same details as in the previous section, and click the <strong class="screentext">Submit</strong> (<strong class="screentext">POST</strong>) button. The browser will send a <code class="inlinecode">POST</code> request to the server with the form data in the request body, producing the response shown in <em class="italic">Figure 11.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.3: Handling form data from a POST request</p>
<p class="normal">The browser has set the <code class="inlinecode">Content-Type</code> header to <code class="inlinecode">application/x-www-form-urlencoded</code>, which indicates that the form data values are encoded in the same way as when the data is included in the query string, with name-value pairs separated by <code class="inlinecode">=</code> characters and combined with <code class="inlinecode">&amp;</code> characters, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
name=Alice+Smith&amp;city=London
...
</code></pre>
<p class="normal">You can decode the form data yourself, but Express includes middleware that detects the <code class="inlinecode">Content-Type</code> header and decodes the form data into a key/value map. <em class="italic">Listing 11.12</em> enables the middleware and uses the data it produces in the response.</p>
<p class="packt_figref">Listing 11.12: Using Express middleware in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
export const registerFormMiddleware = (app: Express) =&gt; {
    <strong class="screentext">app.use(express.urlencoded({extended: true}))</strong>
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
            resp.write(`${key}: ${req.query[key]}\n`);           
        }
        resp.end();
    });
    app.post("/form", (req, resp) =&gt; {
        resp.write(`Content-Type: ${req.headers["content-type"]}\n`)
        <strong class="screentext">for (const key in req.body) {</strong>
<strong class="screentext">            resp.write(`</strong><strong class="screentext">${key}: ${req.body[key]}\n`);           </strong>
<strong class="screentext">        }       </strong>
<strong class="screentext">        resp.end();</strong>
    });
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker526" class="calibre3"/>middleware component is created using the <code class="inlinecode">Express.urlencoded</code> method and the required <code class="inlinecode">extended</code> configuration option is used to specify whether request bodies are processed using the same library that parses query strings or, as here, a more sophisticated option that allows more complex data types to be processed.</p>
<p class="normal">To see the decoded data, request <code class="inlinecode">http://localhost:5000</code>, fill in the form, and click the <strong class="screentext">Submit</strong> (<strong class="screentext">POST</strong>) button. The individual form element names and values will be displayed in the response, instead of the URL-encoded string, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
Content-Type: application/x-www-form-urlencoded
<strong class="screentext">name: Alice Smith</strong>
<strong class="screentext">city: London</strong>
...
</code></pre>
<h3 class="heading2" id="_idParaDest-195">Receiving multipart data</h3>
<p class="normal1">The <code class="inlinecode">application/x-www-form-urlencoded</code> format is the default and works well for gathering<a id="_idIndexMarker527" class="calibre3"/> basic data values from a user. For forms where the user submits files, the <code class="inlinecode">multipart/form-data</code> format is used, which is more complex but allows for a mix of data types to be sent in the HTTP request body. <em class="italic">Listing 11.13</em> adds an <code class="inlinecode">input</code> element that allows the user to select a file and a button to the HTML form that submits the data using the <code class="inlinecode">multipart/form-data</code> format. </p>
<p class="packt_figref">Listing 11.13: Adding elements in the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action="/form"&gt;
            &lt;div class="m-2"&gt;
                &lt;label class="form-label"&gt;Name&lt;/label&gt;
                &lt;input name="name" class="form-control" /&gt;
            &lt;/div&gt;
           <strong class="screentext"> &lt;div class="m-2"&gt;</strong>
<strong class="screentext">                &lt;label class</strong><strong class="screentext">="form-label"&gt;City&lt;/label&gt;</strong>
<strong class="screentext">                &lt;input name="city" class="form-control" /&gt;</strong>
<strong class="screentext"> </strong><strong class="screentext">&lt;/div&gt; </strong>                 
            &lt;div class="m-2"&gt;
                &lt;label class="form-label"&gt;File&lt;/label&gt;
                &lt;input name="datafile" type="file" class="form-control" /&gt;
            &lt;/div&gt;
            &lt;div class="m-2"&gt;
                &lt;button class="btn btn-primary" formmethod="get"&gt;
                    Submit (GET)
                &lt;/button&gt;
                &lt;button class="btn btn-primary" formmethod="post"&gt;
                    Submit (POST)
                &lt;/button&gt;
                <strong class="screentext">&lt;button class="btn btn-primary" formmethod="post"</strong>
<strong class="screentext">                        formenctype="multipart/form-data"</strong><strong class="screentext">&gt;</strong>
<strong class="screentext">                    Submit (POST/MIME)</strong>
<strong class="screentext">                &lt;/button&gt;</strong>
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The <a id="_idIndexMarker528" class="calibre3"/>new <code class="inlinecode">input</code> element has a <code class="inlinecode">type</code> attribute set to <code class="inlinecode">file</code>, which tells the browser that it should present the user with an element to choose a file.</p>
<p class="normal"><em class="italic">Listing 11.14</em> updates the form handler so that <code class="inlinecode">application/x-www-form-urlencoded</code> and <code class="inlinecode">multipart/form-data</code> requests are handled differently, which is important because it affects the way that browsers deal with files.</p>
<p class="packt_figref">Listing 11.14: Selecting content type in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
            resp.write(`${key}: ${req.query[key]}\n`);           
        }
        resp.end();
    });
    app.post("/form", (req, resp) =&gt; {
        resp.write(`Content-Type: ${req.headers["content-type"]}\n`)
        <strong class="screentext">if (req.headers["content-type"]?.startsWith("multipart/form-data"</strong><strong class="screentext">)) {</strong>
<strong class="screentext">            req.pipe(resp);</strong>
<strong class="screentext">        } else {</strong>
            for (const key in req.body) {
                resp.write(`${key}: ${req.body[key]}\n`);           
            }       
            resp.end();
        }
    });
}
</code></pre>
<p class="normal">Use a <a id="_idIndexMarker529" class="calibre3"/>browser to request <code class="inlinecode">http://localhost:5000</code> and fill out the form, choosing the <code class="inlinecode">data.json</code> file created at the start of the chapter for the <code class="inlinecode">File</code> field. The form encoding determines how the browser deals with files. Click <strong class="screentext">Submit</strong> (<strong class="screentext">POST</strong>) to send the form with a <code class="inlinecode">POST</code> request in the <code class="inlinecode">application/x-www-form-urlencoded</code> encoding, and the <strong class="screentext">Submit (POST/MIME)</strong> button to send the form with a <code class="inlinecode">POST</code> request using the <code class="inlinecode">multipart/form-data</code> encoding. Both outcomes are shown in <em class="italic">Figure 11.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.4: Sending form data in different encodings</p>
<p class="normal">For the <code class="inlinecode">application/x-www-form-urlencoded</code> encoding, the browser includes just the name of the file, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
Content-Type: application/x-www-form-urlencoded
name: Alice
city: London
<strong class="screentext">datafile: data.json</strong>
...
</code></pre>
<p class="normal">The <code class="inlinecode">multipart/form-data</code> encoding does include the file contents, but to do so, the structure<a id="_idIndexMarker530" class="calibre3"/> of the request body becomes more complex, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary41AOY4gvNpCTJzUy
------WebKitFormBoundary41AOY4gvNpCTJzUy
Content-Disposition: form-data; name="name"
Alice
------WebKitFormBoundary41AOY4gvNpCTJzUy
Content-Disposition: form-data; name="city"
London
------WebKitFormBoundary41AOY4gvNpCTJzUy
Content-Disposition: form-data; name="datafile"; filename="data.json"
Content-Type: application/json
[
    { "city": "London", "population": 8982000 },
    { "city": "Paris", "population": 2161000 },
    { "city": "Beijing", "population": 21540000 }
]
------WebKitFormBoundary41AOY4gvNpCTJzUy--
...
</code></pre>
<p class="normal">The request body contains multiple parts, each of which is separated by a boundary string, which is included in the <code class="inlinecode">Content-Type</code> header:</p>
<pre class="programlisting"><code class="hljs-code">...
Content-Type: multipart/form-data; b<strong class="screentext">oundary=----WebKitFormBoundary41AOY4gvNpCTJzUy</strong>
...
</code></pre>
<p class="normal">Each body part can contain a different type of data and comes complete with headers that describe the contents. In the case of the body part for the file, the headers provide the name given to the form field, the name of the file that has been chosen, and the type of content in the file:</p>
<pre class="programlisting"><code class="hljs-code">...
Content-Disposition: form-data; name="datafile"; filename="data.json"
Content-Type: application/json
...
</code></pre>
<p class="normal">The <code class="inlinecode">multipart/form-data</code> encoding can be decoded manually, but it isn’t a good idea <a id="_idIndexMarker531" class="calibre3"/>because there have been so many non-compliant implementations over the years that require special handling or workarounds. Express doesn’t include built-in support for processing <code class="inlinecode">multipart/form-data</code> requests but several JavaScript packages can do so. One option is Multer (<a href="https://github.com/expressjs/multer" class="calibre3">https://github.com/expressjs/multer</a> which works well with Express. Run the commands shown in <em class="italic">Listing 11.15</em> to install the Multer package and the type definitions that describe the API it provides to TypeScript.</p>
<p class="packt_figref">Listing 11.15: Installing a package</p>
<pre class="programlisting1"><code class="hljs-con">npm install multer@1.4.5-lts.1
npm install --save-dev @types/multer@1.4.11
</code></pre>
<p class="normal"><em class="italic">Listing 11.16</em> configures the Multer package and applies it to the form handler.</p>
<p class="packt_figref">Listing 11.16: Processing multipart requests in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
<strong class="screentext">import multer from "multer";</strong>
<strong class="screentext">const fileMiddleware = multer({storage: multer.memoryStorage()});</strong>
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
            resp.write(`${key}: ${req.query[key]}\n`);
        }
        resp.end();
    });
 <strong class="screentext">   app.post("/form", fileMiddleware.single("datafile"), (req, resp) =&gt; {</strong>
        resp.write(`Content-Type: ${req.headers["content-type"]}\n`)
        for (const key in req.body) {
            resp.write(`${key}: ${req.body[key]}\n`);
        }
       <strong class="screentext"> if (req.file) {</strong>
<strong class="screentext">            resp.write(`---\nFile: ${req.file.originalname}\n`);</strong>
<strong class="screentext">            resp.write(req.file.</strong><strong class="screentext">buffer.toString());           </strong>
<strong class="screentext">        }</strong>
       
        resp.end();
    });
}
</code></pre>
<p class="normal">Before Multer<a id="_idIndexMarker532" class="calibre3"/> can be used, it has to be told where it can store the files it receives. The package comes with two storage options, which are to write the files to a disk folder or to store the file data in memory. As mentioned in <em class="italic">Part 1</em>, care must be taken when writing to the file system and it should be avoided as much as possible. If you do need to store data from users, then my advice is to use a database, as described in <em class="italic">Chapter 12</em>.</p>
<p class="normal"><em class="italic">Listing 11.16</em> uses the memory-based storage option to create a middleware component that will process <code class="inlinecode">multipart/form-data</code> requests. Unlike most other middleware, the Multer package is applied to specific routes to prevent malicious users from uploading files on routes where they are not expected:</p>
<pre class="programlisting"><code class="hljs-code">...
app.post("/form", <strong class="screentext">fileMiddleware.single("datafile")</strong>, (req, resp) =&gt; {
...
</code></pre>
<p class="normal">This statement applies the Multer middleware to just one route and looks for files in a field named <code class="inlinecode">datafile</code>, matching the name attribute of the file <code class="inlinecode">input</code> element in the HTML form.</p>
<p class="normal">The<a id="_idIndexMarker533" class="calibre3"/> middleware reads the request body and creates a <code class="inlinecode">file</code> property through which details of the uploaded file can be read, with the most useful properties described in <em class="italic">Table 11.3</em>. Body parts that are not files will be presented through the <code class="inlinecode">body</code> property.</p>
<p class="packt_figref">Table 11.3: Useful file description properties </p>
<table class="table-container" id="table003-8">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">originalname</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns the name of the file on the user’s system.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">size</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns the size of the file in bytes.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">mimetype</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns the MIME type of the file.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">buffer</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns a Buffer that contains the entire file. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">To see the effect of the middleware, request <code class="inlinecode">http://localhost:5000</code>, fill out the <code class="inlinecode">name</code> and <code class="inlinecode">city</code> form fields, select the <code class="inlinecode">data.json</code> file, and click the <strong class="screentext">Submit</strong> (<strong class="screentext">POST/MIME</strong>) button. The response includes the values from the body and file properties, as shown in <em class="italic">Figure 11.5</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.5: Uploading files</p>
<h1 class="heading" id="_idParaDest-196">Sanitizing form data</h1>
<p class="normal1">It isn’t <a id="_idIndexMarker534" class="calibre3"/>just files that you should be cautious about receiving from users: any data has the potential to cause problems. The most common problem is a <strong class="screentext">cross-site scripting</strong> (<strong class="screentext">XSS</strong>) attack where a data value is crafted so that it is interpreted by the browser as HTML elements or JavaScript code. In <em class="italic">Chapter 7</em>, I demonstrated how a content security policy can be used to help prevent XSS by telling the browser how the application is expected to behave, but another good measure is to sanitize data that is received from one user so that it doesn’t contain characters that browsers will interpret unexpectedly when it is displayed to another user. To prepare, <em class="italic">Listing 11.17</em> changes the form handler so it returns an HTML response. </p>
<p class="packt_figref">Listing 11.17: Returning an HTML response in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import multer from "multer";
const fileMiddleware = multer({storage: multer.memoryStorage()});
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
            resp.write(`${key}: ${req.query[key]}\n`);           
        }
        resp.end();
    });
    app.post("/form", fileMiddleware.single("datafile"), (req, resp) =&gt; {
    <strong class="screentext">    resp.setHeader("Content-Type", "text/html");</strong>
<strong class="screentext"> </strong><strong class="screentext">for (const key in req.body) {</strong>
<strong class="screentext">            resp.write(`&lt;div&gt;${key}: ${req.body[key]}&lt;/div&gt;`);           </strong>
<strong class="screentext">        }       </strong>
<strong class="screentext">        if (req.file) {</strong>
<strong class="screentext">            resp.</strong><strong class="screentext">write(`&lt;div&gt;File: ${req.file.originalname}&lt;/div&gt;`);</strong>
<strong class="screentext">            resp.write(`&lt;div&gt;${req.file.buffer.toString()}&lt;/div&gt;`);           </strong>
<strong class="screentext">        }</strong>
<strong class="screentext"> </strong>
<strong class="screentext">        resp.end();</strong>
    });
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker535" class="calibre3"/>HTML output is simple and unstyled, which you can see by requesting <code class="inlinecode">http://localhost:5000</code>, filling out the form with the same details as for previous examples, and clicking the <strong class="screentext">Submit (POST/MIME)</strong> button, as shown in <em class="italic">Figure 11.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.6: Producing an HTML response</p>
<p class="normal">To see the effect of unsafe content, go back to <code class="inlinecode">http://localhost:5000</code> and fill out the form using the values in <em class="italic">Table 11.4</em></p>
<p class="packt_figref">Table 11.4: Unsafe content values</p>
<table class="table-container" id="table004-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Field</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Name</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">City</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&lt;a class="btn btn-primary" href="http://packt.com"&gt;Click Me!&lt;/a&gt;</code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal">Click <strong class="screentext">Submit (POST/MIME)</strong> and the values that were entered into the form will be<a id="_idIndexMarker536" class="calibre3"/> included in the response, which the browser interprets as a <code class="inlinecode">link</code> element for the Bootstrap CSS stylesheet and an anchor element that is styled to look like a button, and which will request a URL that is not part of the application, as shown in <em class="italic">Figure 11.7</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_07.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.7: The effect of displaying unsafe content</p>
<p class="normal">The sanitization process involves replacing characters that denote HTML content with escape sequences that display the same character. <em class="italic">Table 11.5</em> lists the characters that are usually sanitized and the escape sequences that replace them.</p>
<p class="packt_figref">Table 11.5: Unsafe characters and escape sequences</p>
<table class="table-container" id="table005-4">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Unsafe Character</p>
</td>
<td class="table-cell">
<p class="normal">Escape Sequence</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;amp;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&lt;</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;lt;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&gt;</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;gt;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">=</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;#x3D;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">" (double quotes)</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;quot;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">' (single quote)</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;#x27;</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">` (back tick)</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">&amp;#x60;</code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal">Add a <a id="_idIndexMarker537" class="calibre3"/>file named <code class="inlinecode">sanitize.ts</code> to the <code class="inlinecode">src/server</code> folder with the content shown in <em class="italic">Listing 11.18</em>. </p>
<p class="packt_figref">Listing 11.18: The contents of the sanitize.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">const matchPattern = /[&amp;&lt;&gt;="'`]/g;
const characterMappings: Record&lt;string, string&gt; = {
    "&amp;": "&amp;amp;",
    "&lt;": "&amp;lt;",
    "&gt;": "&amp;gt;",
    "\"": "&amp;quot;",
    "=": "&amp;#x3D;",   
    "'": "&amp;#x27;",
    "`": "&amp;#x60;"
};
export const santizeValue = (value: string) =&gt;
    value?.replace(matchPattern, match =&gt; characterMappings[match]);
</code></pre>
<p class="normal">The <code class="inlinecode">sanitizeValue</code> function applies a pattern to a string to find dangerous characters and replace them with safe escape sequences. Data values are sanitized as<a id="_idIndexMarker538" class="calibre3"/> they are included in an HTML response. This is usually done as part of the template process – as I demonstrate shortly – but <em class="italic">Listing 11.19</em> applies the <code class="inlinecode">santizeValue</code> function to the values included in the HTML response.</p>
<p class="packt_figref">Listing 11.19: Sanitizing output values in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import multer from "multer";
<strong class="screentext">import { santizeValue } from "./sanitize";</strong>
const fileMiddleware = multer({storage: multer.memoryStorage()});
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
           <strong class="screentext"> resp.write(`${key}: ${req.query[key]}\n`); </strong>          
        }
        resp.end();
    });
    app.post("/form", fileMiddleware.single("datafile"), (req, resp) =&gt; {
        resp.setHeader("Content-Type", "text/html");
        for (const key in req.body) {
            <strong class="screentext">resp.write</strong><strong class="screentext">(`&lt;div&gt;${key}: ${ santizeValue( req.body[key])}&lt;/div&gt;`);</strong>
        }       
        if (req.file) {
            resp.write(`&lt;div&gt;File: ${req.file.originalname}&lt;/div&gt;`);
            <strong class="screentext">resp.write</strong><strong class="screentext">(`&lt;div&gt;${santizeValue(req.file.buffer.toString())}&lt;/div&gt;`);</strong>
        }
   
        resp.end();
    });
}
</code></pre>
<p class="normal">Use a <a id="_idIndexMarker539" class="calibre3"/>browser to request <code class="inlinecode">http://localhost:5000</code>, fill out the form with the details in <em class="italic">Table 11.5</em>, and click the <strong class="screentext">Submit (POST/MIME)</strong> button. The values received from the user are sanitized as they are included in the HTML response so that the browser can display the strings without interpreting them as valid elements, as shown in <em class="italic">Figure 11.8</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_08.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.8: Sanitizing data values</p>
<div><p class="normal"><strong class="screentext">Repeatedly Sanitizing data</strong></p>
<p class="normal">You must ensure that data is sanitized, but you should only sanitize it once. If data is repeatedly sanitized, then the <code class="inlinecode">&amp;</code> character will be escaped repeatedly. If you start with this unsafe string, for example:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">&lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;</code>
</code></pre>
<p class="normal">and sanitize it, the result will be as follows:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">&amp;lt;link href&amp;#x3D;&amp;quot;css/bootstrap.min.css&amp;quot; rel&amp;#x3D;&amp;quot;stylesheet&amp;quot; /&amp;gt;</code>
</code></pre>
<p class="normal">The dangerous characters are escaped but the browser will interpret the escape sequences so that the string looks like the original but won’t be interpreted as an HTML element. If the string is sanitized again, the <code class="inlinecode">&amp;</code> characters, which are already part of escape sequences, will be replaced with <code class="inlinecode">&amp;amp;</code>, producing this result:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">&amp;amp;lt;link href&amp;amp;#x3D;&amp;amp;quot;css/bootstrap.min.css&amp;amp;quot; rel&amp;amp;#x3D;&amp;amp;quot;stylesheet&amp;amp;quot; /&amp;amp;gt;</code>
</code></pre>
<p class="normal">The browser won’t be able to interpret the escape sequences properly and will display a mangled string.</p>
</div>
<p class="normal">Most<a id="_idIndexMarker540" class="calibre3"/> template packages will automatically sanitize data values when a template is rendered, and this includes the Handlebars package added to the project in <em class="italic">Chapter 10</em>. Add a file named <code class="inlinecode">formData.handlebars</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 11.20</em>.</p>
<p class="packt_figref">Listing 11.20: The contents of the formData.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;table class="table table-sm table-striped"&gt;
    &lt;thead&gt;
        &lt;tr&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;&lt;td&gt;Name:&lt;/td&gt;&lt;td&gt;{{ name }} &lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;City:&lt;/td&gt;&lt;td&gt;{{ city }} &lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;File:&lt;/td&gt;&lt;td&gt;{{ fileData }} &lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">Handlebars automatically sanitizes data values in <code class="inlinecode">{{</code> and <code class="inlinecode">}}</code> expressions, making it safe to include in HTML responses. <em class="italic">Listing 11.21</em> updates the form request handler to use the new template.</p>
<p class="packt_figref">Listing 11.21: Using a template in the forms.ts file in the server/src folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import multer from "multer";
import { santizeValue } from "./sanitize";
const fileMiddleware = multer({storage: multer.memoryStorage()});
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        for (const key in req.query) {
            resp.write(`${key}: ${req.query[key]}\n`);           
        }
        resp.end();
    });
    app.post("/form", fileMiddleware.single("datafile"), (req, resp) =&gt; {
        <strong class="screentext">resp.render</strong><strong class="screentext">("formData", {</strong>
<strong class="screentext">            ...req.body, file: req.file,</strong>
<strong class="screentext">            fileData: req.file?.buffer.toString()</strong>
<strong class="screentext">        });</strong>
    });
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker541" class="calibre3"/>context object passed to the template contains the properties from the <code class="inlinecode">body</code> and <code class="inlinecode">file</code> objects and a <code class="inlinecode">fileData</code> property that provides direct access to the file data, since Handlebars won’t evaluate code fragments in templates. Request <code class="inlinecode">http://localhost:5000</code>, fill out the form using the details in <em class="italic">Table 11.21</em>, and click the <strong class="screentext">Submit (POST/MIME)</strong> button and you will see that the template contains safe values, as shown in <em class="italic">Figure 11.9</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">Handlebars will always sanitize data values in <code class="inlinecode">{{ }}</code> expressions. If you want to include data without sanitization, use the <code class="inlinecode">{{{</code> and <code class="inlinecode">}}}</code> character sequences instead, as demonstrated in <em class="italic">Chapter 10</em>.</p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_11_09.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.9: Using a template to sanitize data values</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">When combined with a content security policy, sanitizing data in HTML templates is a good basic defense against XSS attacks. But it isn’t comprehensive and potential problems can remain, such as when inserting user data values into JavaScript code that will be executed by the browser. A good checklist for avoiding such problems can be found at <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" class="calibre3">https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html</a>.</p>
</div>
<h1 class="heading" id="_idParaDest-197">Validating form data</h1>
<p class="normal1">Sanitizing<a id="_idIndexMarker542" class="calibre3"/> data can help prevent malicious values from being displayed to users, but that doesn’t mean that the data you receive will be useful. Users will enter just about anything into a form, sometimes through genuine error, but mostly because forms are an unwelcome obstacle between the user and their goal, whatever that might be.</p>
<p class="normal">The result <a id="_idIndexMarker543" class="calibre3"/>is that the data received from forms must be <em class="italic">validated</em>, which is the process of ensuring that data can be used by the application and telling the user when invalid data is received. Form validation is most easily done with a template because it makes it easy to give the user feedback when a problem arises. To prepare for validation, add a file named <code class="inlinecode">age.handlebars</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 11.22</em>. </p>
<p class="packt_figref">Listing 11.22: The contents of the age.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="m-2"&gt;
    {{#if nextage }}
        &lt;h4&gt;Hello {{name}}. You will be {{nextage}} next year.&lt;/h4&gt;
    {{/if }}
&lt;/div&gt;
&lt;div&gt;
    &lt;form action="/form" method="post"&gt;
        &lt;div class="m-2"&gt;
            &lt;label class="form-label"&gt;Name&lt;/label&gt;
            &lt;input name="name" class="form-control" value="{{name}}"/&gt;
        &lt;/div&gt;
        &lt;div class="m-2"&gt;
            &lt;label class="form-label"&gt;Current Age&lt;/label&gt;
            &lt;input name="age" class="form-control" value="{{age}}" /&gt;
        &lt;/div&gt;                  
        &lt;div class="m-2"&gt;
            &lt;button class="btn btn-primary"&gt;Submit&lt;/button&gt;                               
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">This template contains a form that asks the user for their name and age so that the server can calculate their age next year. This is a trivially simple application, but it contains just enough functionality to require validation. <em class="italic">Listing 11.23</em> updates the routes for the <code class="inlinecode">/form</code> URL to use the new template.</p>
<p class="packt_figref">Listing 11.23: Updating routes in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
<strong class="screentext">// import multer from "multer";</strong>
<strong class="screentext">// import { santizeValue } from "./sanitize";</strong>
<strong class="screentext">//const fileMiddleware = multer({storage: multer.memoryStorage()});</strong>
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
<strong class="screentext">    app.get("/form", (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.render("age");</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    app.post("</strong><strong class="screentext">/form", (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.render("age", {</strong>
<strong class="screentext">            ...req.body,</strong>
<strong class="screentext">            nextage: Number.parseInt(req.body.</strong><strong class="screentext">age) + 1</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">get</code> route<a id="_idIndexMarker544" class="calibre3"/> renders the age template with no context data. The <code class="inlinecode">post</code> route renders the template with the form data received in the body and a <code class="inlinecode">nextage</code> property, which is created by parsing the <code class="inlinecode">age</code> value received from the form into a <code class="inlinecode">Number</code> and adding one. Use a browser to request <code class="inlinecode">http://localhost:5000/form</code>, enter a name and age into the form, and click the <strong class="screentext">Submit</strong> button. If you repeat the process but provide a non-numerical age, the application won’t be able to parse the form data and won’t produce a result. Both outcomes are shown in <em class="italic">Figure 11.10</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_10.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.10: An application that uses form data to produce a result</p>
<p class="normal">The application<a id="_idIndexMarker545" class="calibre3"/> has expectations for the data that it receives, and validation is the process of ensuring those expectations are met.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Validation is a way of making the user fill out the form, but you should take a moment to ask whether the form should exist at all. If you want increased user satisfaction with your application, then keep forms simple and clear, and ask for only the bare minimum needed to get the job done. Be flexible about the formats you will accept for complex data values, like credit card numbers or dates, and make validation error messages as clear as you can.</p>
</div>
<h2 class="heading1" id="_idParaDest-198">Creating a custom validator</h2>
<p class="normal1">Validation<a id="_idIndexMarker546" class="calibre3"/> requires a set of tests that can be applied to form data as it is received. Add a file named <code class="inlinecode">validation.ts</code> to the <code class="inlinecode">src/server</code> folder, with the contents shown in <em class="italic">Listing 11.24</em>.</p>
<p class="packt_figref">Listing 11.24: The contents of the validation.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { NextFunction, Request, Response } from "express";
type ValidatedRequest = Request &amp; {
    validation: {
        results:  { [key: string]: {
            [key: string]: boolean, valid: boolean
        } },
        valid: boolean
    }
}
export const validate = (propName: string) =&gt; {
    const tests: Record&lt;string, (val: string) =&gt; boolean&gt; = {};
    const handler = (req: Request, resp: Response, next: NextFunction ) =&gt; {
        // TODO - perform validation checks
        next();
    }
    handler.required = () =&gt; {
        tests.required = (val: string) =&gt; val?.trim().length &gt; 0;
        return handler;
    };
    handler.minLength = (min: number) =&gt; {
        tests.minLength = (val:string) =&gt; val?.trim().length &gt;= min;
        return handler;
    };
    handler.isInteger = () =&gt; {
        tests.isInteger = (val: string) =&gt; /^[0-9]+$/.test(val);
        return handler;
    }
    return handler;
}
export const getValidationResults = (req: Request) =&gt; {
    return (req as ValidatedRequest).validation || { valid : true }
}
</code></pre>
<p class="normal">There are lots of<a id="_idIndexMarker547" class="calibre3"/> ways to implement a validation system, but the approach taken in <em class="italic">Listing 11.24</em> is to follow the pattern introduced by other packages used in this part of the book and create Express middleware that adds a property to the <code class="inlinecode">Request</code> object. The code isn’t yet complete because it doesn’t apply validation checks. But it does allow validation requirements to be defined, and that’s a good place to start because the code required to easily perform validation can be convoluted. </p>
<p class="normal">The initial <a id="_idIndexMarker548" class="calibre3"/>code defines three validation rules: <code class="inlinecode">required</code>, <code class="inlinecode">minLength</code>, and <code class="inlinecode">isInteger</code>. Real validation packages, such as the one I introduce later in this chapter, have dozens of different rules, but three is enough to demonstrate how form data validation works. The <code class="inlinecode">required</code> rule ensures the user has supplied a value, the <code class="inlinecode">minLength</code> rule enforces a minimum number of characters, and the <code class="inlinecode">isInteger</code> rule ensures that the value is an integer.</p>
<p class="normal">The starting point is to give TypeScript a description of the property that will be added to the <code class="inlinecode">Request</code> object, which is how the validation results will be presented to the request handler function:</p>
<pre class="programlisting"><code class="hljs-code">...
type ValidatedRequest = Request &amp; {
    validation: {
        results:  { [key: string]: {
            [key: string]: boolean, valid: boolean
        } },
        valid: boolean
    }
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">ValidatedRequest</code> type has all of the features defined by <code class="inlinecode">Request</code>, plus a property named <code class="inlinecode">validation</code> that returns an object with <code class="inlinecode">results</code> and <code class="inlinecode">valid</code> properties. The <code class="inlinecode">valid</code> property returns a <code class="inlinecode">boolean</code> value that gives an overall indication of the form data validation outcome. The <code class="inlinecode">results</code> property provides detailed information about the form data fields that have been validated. The goal is to produce an object that looks like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{
  results: {
    name: { valid: false, required: true, minLength: false },
    age: { valid: true, isNumber: true }
  },
  valid: false
}
...
</code></pre>
<p class="normal">This object represents validation checks performed on <code class="inlinecode">name</code> and <code class="inlinecode">age</code> properties. Overall, the form data is invalid, and inspecting the detail, you can see that this is because the <code class="inlinecode">name</code> property has failed its validation checks, specifically because the name value hasn’t passed the <code class="inlinecode">minLength</code> rule.</p>
<p class="normal">The <code class="inlinecode">validate</code> function<a id="_idIndexMarker549" class="calibre3"/> returns an Express middleware function that also has methods, allowing validation to be defined by chaining together the validation rules for a property. The <code class="inlinecode">getValidationResults</code> reads the <code class="inlinecode">validation</code> property added to the request, making it easy to access the validation data in the request handler.</p>
<h2 class="heading1" id="_idParaDest-199">Applying validation rules</h2>
<p class="normal1">Creating a <a id="_idIndexMarker550" class="calibre3"/>function that also has methods takes advantage of JavaScript’s flexibility, so that validation rules can be specified by calling the <code class="inlinecode">validate</code> method to select a form field and then methods can be called on the result to specify validation rules. This isn’t essential, but it does allow validation requirements to be expressed concisely, as shown in <em class="italic">Listing 11.25</em>.</p>
<p class="packt_figref">Listing 11.25: Defining validation rules in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
<strong class="screentext">import { getValidationResults, validate } from "</strong><strong class="screentext">./validation";</strong>
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
       <strong class="screentext"> resp.render("age", { </strong><strong class="screentext">helpers: { pass }});</strong>
    });
    app.post("/form",
           <strong class="screentext"> validate("name").required().minLength(5),</strong>
<strong class="screentext">            validate("age").</strong><strong class="screentext">isInteger(),</strong>
        (req, resp) =&gt; {
            <strong class="screentext">const validation = getValidationResults(req);</strong>
<strong class="screentext">            const context = { ...req.body, validation,</strong>
<strong class="screentext">                helpers: { pass }</strong>
<strong class="screentext">            };</strong>
<strong class="screentext">            if (validation.</strong><strong class="screentext">valid) {</strong>
<strong class="screentext">                context.nextage = Number.parseInt(req.body.age) + 1;</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">            resp.render("age", context);  </strong>
        });
}
<strong class="screentext">const </strong><strong class="screentext">pass = (valid: any, propname: string, test: string ) =&gt; {</strong>
<strong class="screentext">    let propResult = valid?.results?.[propname];</strong>
<strong class="screentext">    return `display:${!propResult || propResult[test] ? "none" : "block" }`;</strong>
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker551" class="calibre3"/>result of calling a rule method is the handler function that defines it, which means that multiple rules can be selected by chaining together method calls. <em class="italic">Listing 11.25</em> applies the <code class="inlinecode">required</code> and <code class="inlinecode">minLength</code> rules to the <code class="inlinecode">name</code> field and the <code class="inlinecode">isInteger</code> rule to the <code class="inlinecode">age</code> field.</p>
<p class="normal">The <code class="inlinecode">getValidationResults</code> function is called within the handler function to get the validation results, which are used to alter the context object used to render the view so that the (simple) calculation is only performed when valid data has been received from the user.</p>
<p class="normal">The validation results are included in the template context object, which allows a template helper to inspect the results and control the visibility of validation error elements. The elements that display errors to the users will always be present in the template, and <em class="italic">Listing 11.25</em> defines a template helper named <code class="inlinecode">pass</code> that will be used to<a id="_idIndexMarker552" class="calibre3"/> control visibility.</p>
<p class="normal"><em class="italic">Listing 11.26</em> updates the template to include the error message elements.</p>
<p class="packt_figref">Listing 11.26: Adding validation messages in the age.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="m-2"&gt;
   <strong class="screentext"> {{#if validation.valid }}</strong>
        &lt;h4&gt;Hello {{name}}. You will be {{nextage}} next year.&lt;/h4&gt;
    {{/if }}
&lt;/div&gt;
&lt;div&gt;
   <strong class="screentext"> &lt;form id="age_form" action="/form" method="post"&gt;</strong>
        &lt;div class="m-2"&gt;
            &lt;label class="form-label"&gt;Name&lt;/label&gt;
            &lt;input name="name" class="form-control" value="{{name}}"/&gt;
            <strong class="screentext">&lt;div class="</strong><strong class="screentext">text-danger" id="err_name_required"</strong>
<strong class="screentext">                    style="{{ pass validation 'name' 'required' }}"&gt;</strong>
<strong class="screentext">                Please enter your name</strong>
<strong class="screentext">            &lt;/div&gt;</strong>
<strong class="screentext">            &lt;div class="</strong><strong class="screentext">text-danger" id="err_name_minLength"</strong>
<strong class="screentext">                    style="{{ pass validation 'name' 'minLength' }}"&gt;</strong>
<strong class="screentext">                Enter at least 5 characters</strong>
<strong class="screentext">            &lt;/div&gt;</strong>
        &lt;/div&gt;
        &lt;div class="m-2"&gt;
            &lt;label class="form-label"&gt;Current Age&lt;/label&gt;
            &lt;input name="age" class="form-control" value="{{age}}" /&gt;
            <strong class="screentext">&lt;div class</strong><strong class="screentext">="text-danger" id="err_age_isInteger"</strong>
<strong class="screentext">                    style="{{ pass validation 'age' 'isInteger' }}"&gt;</strong>
<strong class="screentext">                Please enter your age in whole years</strong>
<strong class="screentext">            &lt;/div&gt;</strong>
        &lt;/div&gt;
        &lt;div class="m-2"&gt;
            &lt;button class="btn btn-primary"&gt;Submit&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">The new additions ensure that the results are only displayed if the form data is valid, and <a id="_idIndexMarker553" class="calibre3"/>display validation errors when there is a problem. Including the error elements in the template will be helpful for client-side validation, which is demonstrated later in this chapter.</p>
<h2 class="heading1" id="_idParaDest-200">Validating data</h2>
<p class="normal1">The<a id="_idIndexMarker554" class="calibre3"/> final step is to complete the custom validator by applying the tests to a value, as shown in <em class="italic">Listing 11.27</em>.</p>
<p class="packt_figref">Listing 11.27: Completing the validator in the validation.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">...
export const validate = (propName: string) =&gt; {
    const tests: Record&lt;string, (val: string) =&gt; boolean&gt; = {};
    const handler = (req: Request, resp: Response, next: NextFunction ) =&gt; {
        <strong class="screentext">const vreq = req as ValidatedRequest;</strong>
<strong class="screentext">        if (!vreq.validation) {</strong>
<strong class="screentext">            vreq.validation = { results: {}, valid: true };</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        vreq.</strong><strong class="screentext">validation.results[propName] = { valid: true };</strong>
<strong class="screentext">        Object.keys(tests).forEach(k =&gt; {</strong>
<strong class="screentext">            let valid = vreq.validation</strong><strong class="screentext">.results[propName][k]</strong>
<strong class="screentext">                = tests[k](req.body?.[propName]);</strong>
<strong class="screentext">            if (!valid) {</strong>
<strong class="screentext">                vreq.validation.results[propName].valid = false;</strong>
<strong class="screentext">                vreq.validation.valid = false</strong><strong class="screentext">;</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        });</strong>
        next();
    }
    handler.required = () =&gt; {
        tests.required = (val: string) =&gt; val?.trim().length &gt; 0;
        return handler;
    };
...
</code></pre>
<p class="normal">I left this step until the end to make the other parts of the validation system easier to understand. Each time one of the validation rule methods is called, such as <code class="inlinecode">required</code>, a new property is added to the object assigned to the constant named <code class="inlinecode">tests</code>. To perform validation, the <code class="inlinecode">tests</code> properties are enumerated, each test is performed, and the outcome is used to build up the validation results. If any validation test fails, then the overall validation outcome and the outcome for the current field value are set to <code class="inlinecode">false</code>.</p>
<p class="normal">Use a <a id="_idIndexMarker555" class="calibre3"/>browser to request <code class="inlinecode">http://localhost:5000</code> and click the <code class="inlinecode">Submit</code> button without entering values into the form fields. Validation will fail and error messages will be displayed to the user, as shown in <em class="italic">Figure 11.11</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_11.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.11: Displaying validation errors</p>
<p class="normal">An error message is displayed for each validation rule that fails, and the backend server won’t generate a normal response until validation succeeds.</p>
<h1 class="heading" id="_idParaDest-201">Performing client-side validation</h1>
<p class="normal1">Client-side validation <a id="_idIndexMarker556" class="calibre3"/>checks form values before the form is submitted, which can provide <a id="_idIndexMarker557" class="calibre3"/>immediate feedback to the user. Client-side validation is used in addition to server-side validation, which is still required because users may disable the client-side JavaScript code or manually submit form data. </p>
<div><p class="normal"><strong class="screentext">Understanding the Built-in HTML Client validation features</strong></p>
<p class="normal">HTML supports validation attributes on input elements, along with a JavaScript API that allows validation events to be received, both of which are described at <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" class="calibre3">https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation</a>. These features can be useful, but they are not always implemented consistently and provide only basic validation checks. It requires only a little more work to create a more comprehensive validation system, which is why they are not used in this chapter.</p>
</div>
<p class="normal">The key to client-side development is consistency. This can be achieved by using the same package for both client- and server-side validation, which is the approach I take in the next section. Otherwise, it is important to ensure that fields are validated in the same way and produce the same error messages. Add a file named <code class="inlinecode">client_validation.js</code> to the <code class="inlinecode">src/client</code> folder with the code shown in <em class="italic">Listing 11.28</em>.</p>
<p class="packt_figref">Listing 11.28: The contents of the client_validation.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">export const validate = (propName, formdata) =&gt; {
    const val = formdata.get(propName);
    const results = { };
   
    const validationChain = {
        get propertyName() { return propName},
        get results () { return results }
    };
    validationChain.required = () =&gt; {
        results.required = val?.trim().length &gt; 0;
        return validationChain;
    }
    validationChain.minLength = (min) =&gt; {
        results.minLength = val?.trim().length &gt;= min;
        return validationChain;
    };
    validationChain.isInteger = () =&gt; {
        results.isInteger = /^[0-9]+$/.test(val);
        return validationChain;
    }
    return validationChain;
}
</code></pre>
<p class="normal">This<a id="_idIndexMarker558" class="calibre3"/> JavaScript code follows a similar pattern to the TypeScript code used to set up chains of validation tests in <em class="italic">Listing 11.24</em>, albeit without integration into Express. <em class="italic">Listing 11.29</em> updates the client-side code to<a id="_idIndexMarker559" class="calibre3"/> validate the form data.</p>
<p class="packt_figref">Listing 11.29: Validating form data in the client.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">import { validate } from "./client_validation";
document.addEventListener('DOMContentLoaded', () =&gt; {
    document.getElementById("age_form").onsubmit = (ev =&gt; {
        const data = new FormData(ev.target);
        const nameValid = validate("name", data)
            .required()
            .minLength(5);
        const ageValid = validate("age", data)
            .isInteger();
        const allValid = [nameValid, ageValid].flatMap(v_result =&gt;
            Object.entries(v_result.results).map(([test, valid]) =&gt; {
                const e = document.getElementById(
                        `err_${v_result.propertyName}_${test}`);
                e.classList.add("bg-dark-subtle");
                e.style.display = valid ? "none" : "block";                      
                return valid
            })).every(v =&gt; v === true);
        if (!allValid) {
            ev.preventDefault();
        }
    });
});
</code></pre>
<p class="normal">This code locates the form element in the HTML document and registers a handler for the <code class="inlinecode">submit</code> event, which is emitted when the user clicks the <strong class="screentext">Submit</strong> button. The browser’s <code class="inlinecode">FormData</code> API is used to obtain the data in the form, which is tested using <a id="_idIndexMarker560" class="calibre3"/>the validation functions defined in <em class="italic">Listing 11.28</em>. The validation results are used to change the visibility of the error message elements in the template. If there are any validation errors, the <code class="inlinecode">preventDefault</code> method is called on the submit event, which tells the browser not to send the data to the server. <em class="italic">Listing 11.29</em> preserves the same style for expressing validation requirements, which leads to some dense code for processing the results, finding the elements that correspond to each test that has been performed, and setting the element visibility.</p>
<p class="normal">For this <a id="_idIndexMarker561" class="calibre3"/>example, error message elements are added to a Bootstrap CSS class when they are processed by the client-side JavaScript code, just to emphasize when an error has been displayed by the client and not the server.</p>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/form</code> and click the <strong class="screentext">Submit</strong> button without filling out the form. The error message elements will be displayed, but with a solid background color that indicates they were shown by the client-side code, as shown in <em class="italic">Figure 11.12</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_11_12.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.12: Using client-side validation</p>
<h1 class="heading" id="_idParaDest-202">Using a package for validation</h1>
<p class="normal1">Having<a id="_idIndexMarker562" class="calibre3"/> demonstrated how server-side and client-side form validation works, it is time to replace the custom checks with those provided by a well-tested and comprehensive validation library. </p>
<p class="normal">As with most areas of JavaScript functionality, there are many libraries available, and the one I have chosen for this chapter, <code class="inlinecode">validator.js</code>, is simple and effective and can be used for both client- and server-side validation. Run the commands shown in <em class="italic">Listing 11.30</em> in the <code class="inlinecode">part2app</code> folder to install the packages.</p>
<p class="packt_figref">Listing 11.30: Installing a validation package</p>
<pre class="programlisting1"><code class="hljs-con">npm install validator@13.11.0
npm install --save-dev @types/validator@13.11.5
</code></pre>
<p class="normal"><em class="italic">Listing 11.31</em> updates the client-side validation code to use the tests provided by the <code class="inlinecode">validator.js</code> package.</p>
<p class="packt_figref">Listing 11.31: Using a validation package in the client_validation.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import validator from "validator";</strong>
export const validate = (propName, formdata) =&gt; {
    const val = formdata.get(propName);
    const results = { };
   
    const validationChain = {
        get propertyName() { return propName},
        get results () { return results }
    };
    validationChain.required = () =&gt; {
        <strong class="screentext">results.required = !validator.isEmpty(val, { ignore_whitespace: true});</strong>
        return validationChain;
    }
    validationChain.minLength = (min) =&gt; {
        <strong class="screentext">results.minLength = validator.isLength(val, { min});</strong>
        return validationChain;
    };
    validationChain.isInteger = () =&gt; {
        <strong class="screentext">results.isInteger = validator.isInt(val);</strong>
<strong class="screentext"> </strong> return validationChain;
    }
    return validationChain;
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker563" class="calibre3"/>full set of tests provided by the <code class="inlinecode">validator.js</code> package can be found at <a href="https://github.com/validatorjs/validator.js" class="calibre3">https://github.com/validatorjs/validator.js</a> and <em class="italic">Listing 11.31</em> uses three of these tests to replace the custom logic while the rest of the code remains the same.</p>
<p class="normal">The same set of changes can be applied to the server, as shown in <em class="italic">Listing 11.32</em>, ensuring consistent validation.</p>
<p class="packt_figref">Listing 11.32: Using a validation package in the validation.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { NextFunction, Request, Response } from "express";
<strong class="screentext">import validator from "validator";</strong>
type ValidatedRequest = Request &amp; {
    validation: {
        results:  { [key: string]: {
            [key: string]: boolean, valid: boolean
        } },
        valid: boolean
    }
}
export const validate = (propName: string) =&gt; {
    const tests: Record&lt;string, (val: string) =&gt; boolean&gt; = {};
    const handler = (req: Request, resp: Response, next: NextFunction ) =&gt; {
        const vreq = req as ValidatedRequest;
        if (!vreq.validation) {
            vreq.validation = { results: {}, valid: true };
        }
        vreq.validation.results[propName] = { valid: true };
        Object.keys(tests).forEach(k =&gt; {
            let valid = vreq.validation.results[propName][k]
                = tests[k](req.body?.[propName]);
            if (!valid) {
                vreq.validation.results[propName].valid = false;
                vreq.validation.valid = false;
            }
        });
        next();
    }
    handler.required = () =&gt; {
        <strong class="screentext">tests.required = (val: string) =&gt;</strong>
<strong class="screentext">            !validator.</strong><strong class="screentext">isEmpty(val, { ignore_whitespace: true});</strong>
        return handler;
    };
    handler.minLength = (min: number) =&gt; {
        <strong class="screentext">tests.minLength = (val:string) =&gt; validator.</strong><strong class="screentext">isLength(val, { min});</strong>
        return handler;
    };
    handler.isInteger = () =&gt; {
       <strong class="screentext"> tests.isInteger = (val: string) =&gt; validator.isInt(val);</strong>
        return handler;
    }
    return handler;
}
export const getValidationResults = (req: Request) =&gt; {
    return (req as ValidatedRequest).validation || { valid : true }
}
</code></pre>
<p class="normal">Request <code class="inlinecode">http://localhost:5000/form</code> and submit the form and you will see the validation <a id="_idIndexMarker564" class="calibre3"/>messages shown in <em class="italic">Figure 11.13</em>. Disable JavaScript in the browser and repeat the process, and you will see the same validation messages, but this time displayed by the server, also shown in <em class="italic">Figure 11.13</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">For Google Chrome, you can disable JavaScript in the <em class="italic">F12</em> developer windows by selecting <strong class="screentext">Run Command</strong> from the menu with three vertical dots and entering <code class="inlinecode">java</code> into the text box. The browser will present the <strong class="screentext">Disable JavaScript</strong> or <strong class="screentext">Enable JavaScript</strong> commands.</p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_11_13.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 11.13: Using a validation package</p>
<p class="normal">There is no change in the way validation appears to the user, but the use of a validation<a id="_idIndexMarker565" class="calibre3"/> package increases confidence that validation will be performed accurately and provides access to a much wider range of validation tests.</p>
<h1 class="heading" id="_idParaDest-203">Summary</h1>
<p class="normal1">In this chapter, I described the different ways that applications can receive form data, make it safe to handle, and check that it is the data that the application requires:</p>
<ul class="calibre4">
<li class="bulletlist">Form data can be sent using <code class="inlinecode">GET</code> and <code class="inlinecode">POST</code> requests, which affects how the data is encoded.</li>
<li class="bulletlist1">Caution is required when sending data with <code class="inlinecode">GET</code> requests because the results may be cached.</li>
<li class="bulletlist1">Different encodings are available for forms sent over <code class="inlinecode">POST</code> requests, including an encoding that allows file data to be sent.</li>
<li class="bulletlist1">Form data should be sanitized before it is included in HTML output or used in any operation where the values may be evaluated as trusted content.</li>
<li class="bulletlist1">Form data should be validated before it is used to ensure the values sent by the user can be safely used by the application.</li>
<li class="bulletlist1">Validation can be done by the server or the client. Client-side validation does not replace server-side validation.</li>
</ul>
<p class="normal">In the next chapter, I will explain how databases are used in Node.js applications, and how data can be included in the HTML content sent to the client.</p>
</div>
</body></html>