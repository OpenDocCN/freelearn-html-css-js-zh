<html><head></head><body>
<div class="calibre1" id="_idContainer209">
<h1 class="chapternumber"><span class="kobospan" id="kobo.1.1">15</span></h1>
<h1 class="chaptertitle" id="_idParaDest-258"><span class="kobospan" id="kobo.2.1">Authenticating and Authorizing Requests</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.3.1">Most projects need to restrict access to features; otherwise, anyone who knows an application’s URL can execute any operation. </span><span class="kobospan" id="kobo.3.2">This is currently how the example application is set up: anyone who can request </span><code class="inlinecode"><span class="kobospan" id="kobo.4.1">http://localhost:5000</span></code><span class="kobospan" id="kobo.5.1"> will be able to store and delete data, regardless of who they are.</span></p>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.6.1">Authorization</span></em><span class="kobospan" id="kobo.7.1">, often </span><a id="_idIndexMarker773" class="calibre3"/><span class="kobospan" id="kobo.8.1">referred to as </span><em class="italic"><span class="kobospan" id="kobo.9.1">AuthZ</span></em><span class="kobospan" id="kobo.10.1">, is the process of restricting access so that operations can only be performed by some users – known, naturally enough, as </span><em class="italic"><span class="kobospan" id="kobo.11.1">authorized users</span></em><span class="kobospan" id="kobo.12.1">. </span><em class="italic"><span class="kobospan" id="kobo.13.1">Authentication</span></em><span class="kobospan" id="kobo.14.1">, often referred to as </span><em class="italic"><span class="kobospan" id="kobo.15.1">AuthN</span></em><span class="kobospan" id="kobo.16.1">, is the process of a user </span><a id="_idIndexMarker774" class="calibre3"/><span class="kobospan" id="kobo.17.1">identifying themselves so that the application can determine whether the user is authorized for the operations they request. </span><span class="kobospan" id="kobo.17.2">This chapter explains how Node.js applications can apply authentication and authorization, building on the features described in earlier chapters. </span><em class="italic"><span class="kobospan" id="kobo.18.1">Table 15.1</span></em><span class="kobospan" id="kobo.19.1"> puts this chapter in context.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.20.1">Table 15.1: Putting authorization and authentication in context</span></p>
<table class="table-container" id="table001-12">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.21.1">Question</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.22.1">Answer</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.23.1">What are they?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.24.1">Authentication</span><a id="_idIndexMarker775" class="calibre3"/><span class="kobospan" id="kobo.25.1"> is the process of identifying a user. </span><span class="kobospan" id="kobo.25.2">Authorization</span><a id="_idIndexMarker776" class="calibre3"/><span class="kobospan4" id="kobo.26.1"> is the process of restricting access to application features to a subset of users.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.27.1">Why are they useful?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.28.1">Identifying users allows an application to alter its behavior by using data or preferences that are specific to one account. </span><span class="kobospan4" id="kobo.28.2">Restricting access to features means that applications can support operations that would otherwise be dangerous or prejudicial to effective service provision.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.29.1">How is it used?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.30.1">Users identify themselves by presenting credentials to the application, which produces a temporary token that is included in subsequent requests. </span><span class="kobospan4" id="kobo.30.2">The token is used to associate an identity with each request, which can be inspected to authorize access to restricted features.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.31.1">Are there any pitfalls or limitations?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.32.1">Thorough testing is required to ensure that authentication and authorization</span><a id="_idIndexMarker777" class="calibre3"/><span class="kobospan" id="kobo.33.1"> work as expected. </span><span class="kobospan4" id="kobo.33.2">Many applications will require additional work to support user enrolment and account maintenance.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.34.1">Are there any alternatives?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.35.1">Not all applications require authentication</span><a id="_idIndexMarker778" class="calibre3"/><span class="kobospan" id="kobo.36.1"> and authorization, but most do. </span><span class="kobospan4" id="kobo.36.2">Some of the surrounding features can be delegated to third-party authentication providers, but integration is still required.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.37.1">Table 15.2</span></em><span class="kobospan" id="kobo.38.1"> summarizes the chapter.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.39.1">Table 15.2: Chapter summary</span></p>
<table class="table-container" id="table002-12">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.40.1">Problem</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.41.1">Solution</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.42.1">Listing</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.43.1">Authenticate users</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.44.1">Provide a mechanism that allows the user to provide credentials, which can be validated against stored data.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.45.1">4-9, 26-28</span></em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.46.1">Create an authentication token for HTML clients</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.47.1">Include the user’s identity in the session so that the session cookie becomes the authentication token.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.48.1">10-12</span></em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.49.1">Create an authentication token for API clients</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.50.1">Create a bearer token.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.51.1">13-16</span></em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.52.1">Authorize requests </span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.53.1">Use the identity associated with a request to determine if the user is entitled to perform the target operation.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.54.1">17-25, 29</span></em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-259"><span class="kobospan" id="kobo.55.1">Preparing for this chapter</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.56.1">This chapter uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.57.1">part2app</span></code><span class="kobospan" id="kobo.58.1"> project from </span><em class="italic"><span class="kobospan" id="kobo.59.1">Chapter 14</span></em><span class="kobospan" id="kobo.60.1">. </span><span class="kobospan" id="kobo.60.2">The first set of examples in this chapter is for a round-trip application. </span><span class="kobospan" id="kobo.60.3">To prepare, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.61.1">data.handlebars</span></code><span class="kobospan" id="kobo.62.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.63.1">templates/server</span></code><span class="kobospan" id="kobo.64.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.65.1">Listing 15.1</span></em><span class="kobospan" id="kobo.66.1">:</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.67.1">Tip</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.68.1">You can download the example project for this chapter – and for all the other chapters in this book – from </span><a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.69.1">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</span></span></a><span class="kobospan" id="kobo.70.1">. </span><span class="kobospan" id="kobo.70.2">See </span><em class="italic"><span class="kobospan" id="kobo.71.1">Chapter 1</span></em><span class="kobospan" id="kobo.72.1"> for how to get help if you have problems running the examples.</span></p>
</div>
<p class="packt_figref"><span class="kobospan" id="kobo.73.1">Listing 15.1: The contents of the data.handlebars file in the templates/server folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.74.1">&lt;form class="m-2"&gt;
    &lt;table class="table table-sm table-striped"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;th&gt;Years&lt;/th&gt;
                &lt;th&gt;Next Age&lt;/th&gt;&lt;th&gt;&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            {{#unless data }}&lt;tr&gt;&lt;td colspan="5"&gt;No Data&lt;/td&gt;&lt;/tr&gt;{{/unless }}
            {{#each data }}
                &lt;tr&gt;
                    &lt;td&gt;{{ this.id }} &lt;/td&gt;
                    &lt;td&gt;{{ this.name }} &lt;/td&gt;
                    &lt;td&gt;{{ this.age }} &lt;/td&gt;
                    &lt;td&gt;{{ this.years }} &lt;/td&gt;
                    &lt;td&gt;{{ this.nextage }} &lt;/td&gt;
                    &lt;td&gt;
                        &lt;button class="btn btn-danger btn-sm"
                            formmethod="post"
                            formaction="/form/delete/{{this.id}}"&gt;
                                Delete
                        &lt;/button&gt; 
                    &lt;/td&gt;
                &lt;/tr&gt;               
            {{/each }}
        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;button class="btn btn-primary"
        formmethod="post"
        formaction="/form/add"&gt;
            Add
    &lt;/button&gt;                    
    &lt;input type="hidden" name="name" value="Alice" /&gt;
    &lt;input type="hidden" name="age" value="40" /&gt;
    &lt;input type="hidden" name="years" value="10" /&gt;
&lt;/form&gt;           
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.75.1">This template contains a table that displays data, with a form that sends HTTP requests to the server. </span><span class="kobospan" id="kobo.75.2">To handle the HTTP requests, replace the contents of the </span><code class="inlinecode"><span class="kobospan" id="kobo.76.1">forms.ts</span></code><span class="kobospan" id="kobo.77.1"> file in the </span><code class="inlinecode"><span class="kobospan" id="kobo.78.1">src/server</span></code><span class="kobospan" id="kobo.79.1"> folder with the code shown in </span><em class="italic"><span class="kobospan" id="kobo.80.1">Listing 15.2</span></em><span class="kobospan" id="kobo.81.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.82.1">Listing 15.2: The contents of the forms.ts file in the src/server folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.83.1">import express, { Express } from "express";
import repository  from "./data";
import cookieMiddleware from "cookie-parser";
import { sessionMiddleware } from "./sessions/session_helpers";
import { Result } from "./data/repository";
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
    app.use(cookieMiddleware("mysecret"));
    app.use(sessionMiddleware());
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("data", {data: await repository.getAllResults(rowLimit)});
    });
    app.post("/form/delete/:id", async (req, resp) =&gt; {
        const id = Number.parseInt(req.params["id"]);
        await repository.delete(id);
        resp.redirect("/form");
        resp.end();
    });
       
    app.post("/form/add", async (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body["age"])
            + Number.parseInt(req.body["years"]);
        await repository.saveResult({...req.body, nextage } as Result);
        resp.redirect("/form");
        resp.end();
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.84.1">The routes defined in </span><em class="italic"><span class="kobospan" id="kobo.85.1">Listing 15.2</span></em><span class="kobospan" id="kobo.86.1"> render the data template, delete an item from the database, and store an item. </span><span class="kobospan" id="kobo.86.2">After data is stored or deleted, the browser is sent a redirection to the </span><code class="inlinecode"><span class="kobospan" id="kobo.87.1">/form</span></code><span class="kobospan" id="kobo.88.1"> URL that will show the user the results of their actions. </span><span class="kobospan" id="kobo.88.2">Run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.89.1">Listing 15.3</span></em><span class="kobospan" id="kobo.90.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.91.1">part2app</span></code><span class="kobospan" id="kobo.92.1"> folder to start the development tools:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.93.1">Listing 15.3: Starting the development tools</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.94.1">npm start
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.95.1">Use a browser to request </span><code class="inlinecode"><span class="kobospan" id="kobo.96.1">http://localhost:5000/form</span></code><span class="kobospan" id="kobo.97.1">, and you will see the content generated by the new template, as shown in </span><em class="italic"><span class="kobospan" id="kobo.98.1">Figure 15.1</span></em><span class="kobospan" id="kobo.99.1">. </span><span class="kobospan" id="kobo.99.2">Clicking one of the </span><strong class="screentext"><span class="kobospan" id="kobo.100.1">Delete</span></strong><span class="kobospan" id="kobo.101.1"> buttons will remove an item from the database, and clicking the </span><strong class="screentext"><span class="kobospan" id="kobo.102.1">Add</span></strong><span class="kobospan" id="kobo.103.1"> button will store a new item using fixed data values.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.104.1"><img alt="" src="../Images/B21959_15_01.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.105.1">Figure 15.1: Running the example application</span></p>
<h1 class="heading" id="_idParaDest-260"><span class="kobospan" id="kobo.106.1">Understanding the end-to-end process</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.107.1">The topics covered in this chapter are part of a larger process through which a user gains access to the features provided by an application. </span><span class="kobospan" id="kobo.107.2">The process is as follows: </span></p>
<ol class="calibre6">
<li class="bulletlist1" value="1"><span class="kobospan" id="kobo.108.1">Enrolment. </span><span class="kobospan" id="kobo.108.2">The enrolment process</span><a id="_idIndexMarker779" class="calibre3"/><span class="kobospan" id="kobo.109.1"> creates an account for the user, who is given credentials to identify themselves. </span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.110.1">User Authentication. </span><span class="kobospan" id="kobo.110.2">The user </span><a id="_idIndexMarker780" class="calibre3"/><span class="kobospan" id="kobo.111.1">presents their credentials when they want to use the application. </span><span class="kobospan" id="kobo.111.2">The authentication process, often called signing in, produces a token that temporarily identifies the user. </span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.112.1">Request Authentication. </span><span class="kobospan" id="kobo.112.2">When making </span><a id="_idIndexMarker781" class="calibre3"/><span class="kobospan" id="kobo.113.1">HTTP requests, the client includes the temporary token to identify the user without needing to provide the credentials again. </span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.114.1">Authorization. </span><span class="kobospan" id="kobo.114.2">The</span><a id="_idIndexMarker782" class="calibre3"/><span class="kobospan" id="kobo.115.1"> token included in the request is used to determine whether the user can access the feature specified by the request. </span></li>
</ol>
<p class="normal"><span class="kobospan" id="kobo.116.1">This chapter covers the authentication and authorization parts of the process. </span><span class="kobospan" id="kobo.116.2">The details of the enrolment process are not described because they depend on the type of application. </span><span class="kobospan" id="kobo.116.3">For corporate applications, enrolment will usually happen when a new employee joins the company and, for larger companies, will be done by the HR department through a central employee directory. </span><span class="kobospan" id="kobo.116.4">For consumer-facing applications, enrolment is often linked to payment and is done before the user receives access to the application (for services, such as Spotify) or after they have made a product selection (for goods, such as Amazon). </span><span class="kobospan" id="kobo.116.5">In both cases, the user enrolls themselves.</span></p>
<p class="normal"><span class="kobospan" id="kobo.117.1">Applications that require users to enroll themselves usually provide account maintenance tools, which allow users to change their credentials, update personal information, and close their accounts. </span><span class="kobospan" id="kobo.117.2">In some parts of the world, users are legally entitled to receive a copy of all of the data held about them, and this is often part of the account management process.</span></p>
<h1 class="heading" id="_idParaDest-261"><span class="kobospan" id="kobo.118.1">Authenticating users</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.119.1">The authentication process </span><a id="_idIndexMarker783" class="calibre3"/><span class="kobospan" id="kobo.120.1">requires the user to present their credentials to identify themselves to the application. </span><span class="kobospan" id="kobo.120.2">The standard credentials are a username and password. </span><span class="kobospan" id="kobo.120.3">The password is known only to the user, which means they can prove they are the user who owns the account by submitting the correct password.</span></p>
<p class="normal"><span class="kobospan" id="kobo.121.1">Of course, passwords can be stolen or shared, and so a common approach is to require additional proof of identity. </span><span class="kobospan" id="kobo.121.2">The conventional approach is to combine a password with a physical token, which can be a dedicated hardware device or an authenticator app running on a phone. </span><span class="kobospan" id="kobo.121.3">The device provides a time-limited code that proves the user has the device.</span></p>
<p class="normal"><span class="kobospan" id="kobo.122.1">To work through the details of how users are authenticated, I am going to add support for usernames and passwords to the example application. </span><span class="kobospan" id="kobo.122.2">Later in the chapter, I’ll introduce an open-source package that supports a wider range of credentials, but simple passwords are enough to explain how the overall authentication and authorization processes work. </span><em class="italic"><span class="kobospan" id="kobo.123.1">Part 3</span></em><span class="kobospan" id="kobo.124.1"> of this book demonstrates the use of a </span><a id="_idIndexMarker784" class="calibre3"/><span class="kobospan" id="kobo.125.1">third-party authentication service.</span></p>
<h2 class="heading1" id="_idParaDest-262"><span class="kobospan" id="kobo.126.1">Creating a credential store</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.127.1">To authenticate </span><a id="_idIndexMarker785" class="calibre3"/><span class="kobospan" id="kobo.128.1">users, an application needs to have a store of credentials against which requests can be validated. </span><span class="kobospan" id="kobo.128.2">Create the </span><code class="inlinecode"><span class="kobospan" id="kobo.129.1">src/server/auth</span></code><span class="kobospan" id="kobo.130.1"> folder and add to it a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.131.1">auth_types.ts</span></code><span class="kobospan" id="kobo.132.1">, with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.133.1">Listing 15.4</span></em><span class="kobospan" id="kobo.134.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.135.1">Listing 15.4: The contents of the auth_types.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.136.1">export interface Credentials {
    username: string;
    hashedPassword: Buffer;
    salt: Buffer;
}
export interface AuthStore {
    getUser(name: string) : Promise&lt;Credentials | null&gt;;
    storeOrUpdateUser(username: string, password: string):
        Promise&lt;Credentials&gt;;
    validateCredentials(username: string, password: string): Promise&lt;boolean&gt;
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.137.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.138.1">Credentials</span></code><span class="kobospan" id="kobo.139.1"> interface describes a user’s credentials as they are stored for validation. </span><span class="kobospan" id="kobo.139.2">It is poor practice to store passwords in plain text, and the conventional approach is to create a one-way hash code and store that instead. </span><span class="kobospan" id="kobo.139.3">To validate credentials, the password provided by the user is put through the same hashing algorithm and compared with the stored value. </span><span class="kobospan" id="kobo.139.4">Hash algorithms always produce the same result, which means the credential store will contain the same hash code for all users who pick the same password. </span><span class="kobospan" id="kobo.139.5">If the password for one of those accounts is obtained, then anyone who can see the credential store will be able to figure out which other accounts can be accessed. </span></p>
<p class="normal"><span class="kobospan" id="kobo.140.1">To avoid this problem, a random </span><em class="italic"><span class="kobospan" id="kobo.141.1">salt</span></em><span class="kobospan" id="kobo.142.1"> value is added to the password so that users can have the same password without causing duplicate hash codes in the credential store. </span><span class="kobospan" id="kobo.142.2">The salt value must be stored alongside the password so that credentials can be validated. </span><span class="kobospan" id="kobo.142.3">The hash code and the salt are </span><code class="inlinecode"><span class="kobospan" id="kobo.143.1">Buffer</span></code><span class="kobospan" id="kobo.144.1"> values, which is the type that Node.js uses to represent byte arrays. </span><span class="kobospan" id="kobo.144.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.145.1">AuthStore</span></code><span class="kobospan" id="kobo.146.1"> interface defines the methods that will be used to retrieve and store credentials. </span></p>
<p class="normal"><span class="kobospan" id="kobo.147.1">Add a file</span><a id="_idIndexMarker786" class="calibre3"/><span class="kobospan" id="kobo.148.1"> named </span><code class="inlinecode"><span class="kobospan" id="kobo.149.1">orm_auth_models.ts</span></code><span class="kobospan" id="kobo.150.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.151.1">src/server/auth</span></code><span class="kobospan" id="kobo.152.1"> folder with the contents shown in </span><em class="italic"><span class="kobospan" id="kobo.153.1">Listing 15.5</span></em><span class="kobospan" id="kobo.154.1">, which defines the data model for credentials using the </span><em class="italic"><span class="kobospan" id="kobo.155.1">Sequelize ORM package</span></em><span class="kobospan" id="kobo.156.1"> introduced in </span><em class="italic"><span class="kobospan" id="kobo.157.1">Chapter 12</span></em><span class="kobospan" id="kobo.158.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.159.1">Listing 15.5: The contents of the orm_auth_models.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.160.1">import { DataTypes, InferAttributes, InferCreationAttributes, Model,
    Sequelize } from "sequelize";
import { Credentials } from "./auth_types";
export class CredentialsModel
        extends Model&lt;InferAttributes&lt;CredentialsModel&gt;,
            InferCreationAttributes&lt;CredentialsModel&gt;&gt;
        implements Credentials {
    declare username: string;
    declare hashedPassword: Buffer;
    declare salt: Buffer;
}
export const initializeAuthModels = (sequelize: Sequelize) =&gt; {
    CredentialsModel.init({
        username: { type: DataTypes.STRING, primaryKey: true },
        hashedPassword: { type: DataTypes.BLOB },
        salt: { type: DataTypes.BLOB }
    }, { sequelize });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.161.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.162.1">CredentialsModel</span></code><span class="kobospan" id="kobo.163.1"> class extends the Sequelize </span><code class="inlinecode"><span class="kobospan" id="kobo.164.1">Model</span></code><span class="kobospan" id="kobo.165.1"> class and implements the </span><code class="inlinecode"><span class="kobospan" id="kobo.166.1">Credentials</span></code><span class="kobospan" id="kobo.167.1"> interface, which allows </span><code class="inlinecode"><span class="kobospan" id="kobo.168.1">CredentialsModel</span></code><span class="kobospan" id="kobo.169.1"> objects to be stored in the database and used as a method result with the </span><code class="inlinecode"><span class="kobospan" id="kobo.170.1">AuthStore</span></code><span class="kobospan" id="kobo.171.1"> interface. </span><span class="kobospan" id="kobo.171.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.172.1">initializeAuthModels</span></code><span class="kobospan" id="kobo.173.1"> function receives a </span><code class="inlinecode"><span class="kobospan" id="kobo.174.1">Sequelize</span></code><span class="kobospan" id="kobo.175.1"> object and initializes the </span><code class="inlinecode"><span class="kobospan" id="kobo.176.1">CredentialsModel</span></code><span class="kobospan" id="kobo.177.1"> for database storage, identifying the </span><code class="inlinecode"><span class="kobospan" id="kobo.178.1">username</span></code><span class="kobospan" id="kobo.179.1"> property as the primary key and telling </span><code class="inlinecode"><span class="kobospan" id="kobo.180.1">Sequelize</span></code><span class="kobospan" id="kobo.181.1"> to represent values, using the SQL </span><code class="inlinecode"><span class="kobospan" id="kobo.182.1">STRING</span></code><span class="kobospan" id="kobo.183.1"> data type for the username property and the </span><code class="inlinecode"><span class="kobospan" id="kobo.184.1">BLOB</span></code><span class="kobospan" id="kobo.185.1"> type for the hash code and salt values (the </span><code class="inlinecode"><span class="kobospan" id="kobo.186.1">BLOB</span></code><span class="kobospan" id="kobo.187.1"> type allows data to be stored as strings or buffers). </span></p>
<p class="normal"><span class="kobospan" id="kobo.188.1">To create a</span><a id="_idIndexMarker787" class="calibre3"/><span class="kobospan" id="kobo.189.1"> Sequelize implementation of the </span><code class="inlinecode"><span class="kobospan" id="kobo.190.1">AuthStore</span></code><span class="kobospan" id="kobo.191.1"> interface, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.192.1">orm_authstore.ts</span></code><span class="kobospan" id="kobo.193.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.194.1">src/server/auth</span></code><span class="kobospan" id="kobo.195.1"> folder with the contents shown in </span><em class="italic"><span class="kobospan" id="kobo.196.1">Listing 15.6</span></em><span class="kobospan" id="kobo.197.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.198.1">Listing 15.6: The contents of the orm_authstore.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.199.1">import { Sequelize } from "sequelize";
import { CredentialsModel, initializeAuthModels }
    from "./orm_auth_models";
import { AuthStore } from "./auth_types"
import { pbkdf2, randomBytes, timingSafeEqual } from "crypto";
export class OrmAuthStore implements AuthStore {
    sequelize: Sequelize;
    constructor() {
        this.sequelize = new Sequelize({
            dialect: "sqlite",
            storage: "orm_auth.db",
            logging: console.log,
            logQueryParameters: true
        });
        this.initModelAndDatabase();
    }
    async initModelAndDatabase() : Promise&lt;void&gt; {
        initializeAuthModels(this.sequelize);
        await this.sequelize.drop();       
        await this.sequelize.sync();       
        await this.storeOrUpdateUser("alice", "mysecret");
        await this.storeOrUpdateUser("bob", "mysecret");       
    }
    async getUser(name: string) {
        return await CredentialsModel.findByPk(name);
    }
    async storeOrUpdateUser(username: string, password: string) {
        const salt = randomBytes(16);
        const hashedPassword = await this.createHashCode(password, salt);
        const [model] = await CredentialsModel.upsert({
            username, hashedPassword, salt
        });
        return model;
    }
    async validateCredentials(username: string, password: string):
            Promise&lt;boolean&gt; {
        const storedCreds = await this.getUser(username);
        if (storedCreds) {
            const candidateHash =
                await this.createHashCode(password, storedCreds.salt);
            return timingSafeEqual(candidateHash, storedCreds.hashedPassword);
        }
        return false;
    }
    private createHashCode(password: string, salt: Buffer) : Promise&lt;Buffer&gt; {
        return new Promise((resolve, reject) =&gt; {
            pbkdf2(password, salt, 100000, 64, "sha512", (err, hash) =&gt; {
                if (err) {
                    reject(err)
                };
                resolve(hash);
            })      
        })
    }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.200.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.201.1">OrmAuthStore</span></code><span class="kobospan" id="kobo.202.1"> class implements the </span><code class="inlinecode"><span class="kobospan" id="kobo.203.1">AuthStore</span></code><span class="kobospan" id="kobo.204.1"> interface using the Sequelize features</span><a id="_idIndexMarker788" class="calibre3"/><span class="kobospan" id="kobo.205.1"> presented by the </span><code class="inlinecode"><span class="kobospan" id="kobo.206.1">CredentialsModel</span></code><span class="kobospan" id="kobo.207.1"> class. </span><span class="kobospan" id="kobo.207.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.208.1">getUser</span></code><span class="kobospan" id="kobo.209.1"> method is implemented using the </span><code class="inlinecode"><span class="kobospan" id="kobo.210.1">findByPk</span></code><span class="kobospan" id="kobo.211.1"> method, which queries the database using a primary key value. </span><span class="kobospan" id="kobo.211.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.212.1">storeOrUpdateUser</span></code><span class="kobospan" id="kobo.213.1"> method is implemented using the </span><code class="inlinecode"><span class="kobospan" id="kobo.214.1">upsert</span></code><span class="kobospan" id="kobo.215.1"> method, which updates an existing value if there is one and otherwise creates a new value. </span><span class="kobospan" id="kobo.215.2">The data will be stored in an SQLite database file named </span><code class="inlinecode"><span class="kobospan" id="kobo.216.1">orm_auth.db</span></code><span class="kobospan" id="kobo.217.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.218.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.219.1">createHashCode</span></code><span class="kobospan" id="kobo.220.1"> method accepts a password and a salt value and creates a new hash code, using the </span><code class="inlinecode"><span class="kobospan" id="kobo.221.1">pbkdf2</span></code><span class="kobospan" id="kobo.222.1"> function from the Node.js </span><code class="inlinecode"><span class="kobospan" id="kobo.223.1">crypto</span></code><span class="kobospan" id="kobo.224.1"> module. </span><span class="kobospan" id="kobo.224.2">This function is an implementation of a </span><strong class="screentext"><span class="kobospan" id="kobo.225.1">Password-Based Key Derivation Function</span></strong><span class="kobospan" id="kobo.226.1"> (</span><strong class="screentext"><span class="kobospan" id="kobo.227.1">PBKDF</span></strong><span class="kobospan" id="kobo.228.1">), which is a</span><a id="_idIndexMarker789" class="calibre3"/><span class="kobospan" id="kobo.229.1"> function that is well-suited to</span><a id="_idIndexMarker790" class="calibre3"/><span class="kobospan" id="kobo.230.1"> create hash codes from passwords (see </span><a href="https://en.wikipedia.org/wiki/PBKDF2" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.231.1">https://en.wikipedia.org/wiki/PBKDF2</span></span></a><span class="kobospan" id="kobo.232.1"> for details). </span><span class="kobospan" id="kobo.232.2">The arguments to the </span><code class="inlinecode"><span class="kobospan" id="kobo.233.1">pbkdf2</span></code><span class="kobospan" id="kobo.234.1"> function are the password to be hashed, the salt value, the number of iterations used to generate the hash code, the length of the hash code, and the algorithm that will be used to generate the hash code. </span></p>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.235.1">Listing 15.6</span></em><span class="kobospan" id="kobo.236.1"> uses the values described in the Node.js API (</span><a href="https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.237.1">https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback</span></span></a><span class="kobospan" id="kobo.238.1">). </span><span class="kobospan" id="kobo.238.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.239.1">pbkdf2</span></code><span class="kobospan" id="kobo.240.1"> function uses a callback, which is wrapped in a Promise to make it easier to work with the </span><code class="inlinecode"><span class="kobospan" id="kobo.241.1">Sequelize</span></code><span class="kobospan" id="kobo.242.1"> API.</span></p>
<p class="normal"><span class="kobospan" id="kobo.243.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.244.1">validateCredentials</span></code><span class="kobospan" id="kobo.245.1"> method uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.246.1">getUser</span></code><span class="kobospan" id="kobo.247.1"> method to retrieve the stored credentials and uses the stored salt value to compute a new hash code with the candidate password, which is then compared to the stored hash code, using the </span><code class="inlinecode"><span class="kobospan" id="kobo.248.1">timingSafeEqual</span></code><span class="kobospan" id="kobo.249.1"> function in the Node.js </span><code class="inlinecode"><span class="kobospan" id="kobo.250.1">crypto</span></code><span class="kobospan" id="kobo.251.1"> module. </span><span class="kobospan" id="kobo.251.2">This function is used to compare hash codes securely, as described in the API documentation </span><code class="inlinecode"><span class="kobospan" id="kobo.252.1">(</span></code><a href="https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.253.1">https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b</span></span></a><span class="kobospan" id="kobo.254.1">). </span></p>
<p class="normal"><span class="kobospan" id="kobo.255.1">The </span><a id="_idIndexMarker791" class="calibre3"/><span class="kobospan" id="kobo.256.1">database is seeded with two sets of credentials, matching those described in </span><em class="italic"><span class="kobospan" id="kobo.257.1">Table 15.3</span></em><span class="kobospan" id="kobo.258.1">. </span><span class="kobospan" id="kobo.258.2">Credentials are usually created as part of an enrolment process, as described earlier in the chapter, but test credentials are enough for this chapter. </span><span class="kobospan" id="kobo.258.3">See </span><em class="italic"><span class="kobospan" id="kobo.259.1">Part 3</span></em><span class="kobospan" id="kobo.260.1"> for an example of an enrolment process typical of an online store. </span><span class="kobospan" id="kobo.260.2">As with examples in earlier chapters, the database is reset each time the application is started.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.261.1">Table 15.3: The test credentials added to the database</span></p>
<table class="table-container" id="table003-12">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.262.1">Name</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.263.1">Password</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.264.1">alice</span></code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.265.1">mysecret</span></code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.266.1">bob</span></code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.267.1">mysecret</span></code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2 class="heading1" id="_idParaDest-263"><span class="kobospan" id="kobo.268.1">Creating the authentication workflow</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.269.1">The next</span><a id="_idIndexMarker792" class="calibre3"/><span class="kobospan" id="kobo.270.1"> step is to create a workflow that allows a user to sign in and out of the application. </span><span class="kobospan" id="kobo.270.2">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.271.1">signin.handlebars</span></code><span class="kobospan" id="kobo.272.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.273.1">templates/server</span></code><span class="kobospan" id="kobo.274.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.275.1">Listing 15.7</span></em><span class="kobospan" id="kobo.276.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.277.1">Listing 15.7: The contents of the signin.handlebars file in the templates/server folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.278.1">{{#if failed }}
    &lt;h4 class="bg-danger text-white p-2 text-center"&gt;
        Authentication failed. </span><span class="kobospan" id="kobo.278.2">Please try again.
    </span><span class="kobospan" id="kobo.278.3">&lt;/h4&gt;
{{/if}}
&lt;form method="post"&gt;
    &lt;div class="m-2"&gt;
        &lt;label class="form-label"&gt;Name&lt;/label&gt;
        &lt;input name="username" class="form-control" value="{{ username }}"/&gt;
    &lt;/div&gt;
    &lt;div class="m-2"&gt;
        &lt;label class="form-label"&gt;Password&lt;/label&gt;
        &lt;input name="password" type="password" class="form-control"
            value="{{ password }}"/&gt;
    &lt;/div&gt;   
    &lt;button type="submit" class="btn btn-primary mx-2"&gt;Sign In&lt;/button&gt;
&lt;/form&gt;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.279.1">The </span><a id="_idIndexMarker793" class="calibre3"/><span class="kobospan" id="kobo.280.1">template contains a form to send a username and password to the application, along with an error message that is hidden by default but which will be displayed if the user provides invalid credentials.</span></p>
<p class="normal"><span class="kobospan" id="kobo.281.1">The next step is to create the Express routes that will present the user with the contents of the </span><code class="inlinecode"><span class="kobospan" id="kobo.282.1">signin</span></code><span class="kobospan" id="kobo.283.1"> template and validate credentials when they are submitted. </span><span class="kobospan" id="kobo.283.2">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.284.1">index.ts</span></code><span class="kobospan" id="kobo.285.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.286.1">src/server/auth</span></code><span class="kobospan" id="kobo.287.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.288.1">Listing 15.8</span></em><span class="kobospan" id="kobo.289.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.290.1">Listing 15.8: The contents of the index.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.291.1">import { Express } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
const store: AuthStore = new OrmAuthStore();
export const createAuth = (app: Express) =&gt; {
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            username: req.query["username"],
            password: req.query["password"],
            failed: req.query["failed"] ? </span><span class="kobospan" id="kobo.291.2">true : false
        }
        resp.render("signin", data);
    });
    app.post("/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const valid = await store.validateCredentials(username, password);
        if (valid) {
            resp.redirect("/");
        } else {
            resp.redirect(
                `/signin?username=${username}&amp;password=${password}&amp;failed=1`);
        }
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.292.1">This file</span><a id="_idIndexMarker794" class="calibre3"/><span class="kobospan" id="kobo.293.1"> exports a function named </span><code class="inlinecode"><span class="kobospan" id="kobo.294.1">createAuth</span></code><span class="kobospan" id="kobo.295.1">, which sets up authentication for the application. </span><span class="kobospan" id="kobo.295.2">The contents of the </span><code class="inlinecode"><span class="kobospan" id="kobo.296.1">signin</span></code><span class="kobospan" id="kobo.297.1"> template are rendered when a GET request is sent to </span><code class="inlinecode"><span class="kobospan" id="kobo.298.1">/signin</span></code><span class="kobospan" id="kobo.299.1">. </span><span class="kobospan" id="kobo.299.2">When a POST request is sent to </span><code class="inlinecode"><span class="kobospan" id="kobo.300.1">/signin</span></code><span class="kobospan" id="kobo.301.1">, the credentials it contains are validated. </span><span class="kobospan" id="kobo.301.2">A redirection is used to send the user back to the application if the credentials are valid.</span></p>
<p class="normal"><span class="kobospan" id="kobo.302.1">A redirection is also sent when credentials fail validation but, this time, to the same URL. </span><span class="kobospan" id="kobo.302.2">This is a pattern known as </span><code class="inlinecode"><span class="kobospan" id="kobo.303.1">Post/Redirect/Get</span></code><span class="kobospan" id="kobo.304.1">, and it ensures that the user can reload the browser without triggering another sign-in attempt. </span><span class="kobospan" id="kobo.304.2">This pattern can be used in any form, but it is particularly useful for authentication, where repeated failed attempts are often counted and can lead to an account being logged out. </span><span class="kobospan" id="kobo.304.3">The URL query string is used to include the credentials provided by the user so they will be displayed by the result of the GET request. </span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.305.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.306.1">Authentication should always be performed over an encrypted HTTP connection; otherwise, the credentials provided by the user can be exposed to network sniffing. </span><span class="kobospan" id="kobo.306.2">See </span><em class="italic"><span class="kobospan" id="kobo.307.1">Chapter 5</span></em><span class="kobospan" id="kobo.308.1"> for details of setting up HTTPS for a stand-alone Node.js server and see </span><em class="italic"><span class="kobospan" id="kobo.309.1">Part 3</span></em><span class="kobospan" id="kobo.310.1"> for an example that demonstrates how HTTPS is typically set up for more complex Node.js applications. </span></p>
</div>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.311.1">Listing 15.9</span></em><span class="kobospan" id="kobo.312.1"> calls the </span><code class="inlinecode"><span class="kobospan" id="kobo.313.1">createAuth</span></code><span class="kobospan" id="kobo.314.1"> function as part of the server startup so that the authentication features are part of the request-handling process:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.315.1">Listing 15.9: Enabling authentication in the server.ts file in the src/server folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.316.1">import { createServer } from "http";
import express, {Express } from "express";
import httpProxy from "http-proxy";
import helmet from "helmet";
import { engine } from "express-handlebars";
import { registerFormMiddleware, registerFormRoutes } from "./forms";
import { createApi } from "./api";
</span><strong class="screentext"><span class="kobospan" id="kobo.317.1">import { createAuth } from "./auth";</span></strong><span class="kobospan" id="kobo.318.1">
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
expressApp.set("views", "templates/server");
expressApp.engine("handlebars", engine());
expressApp.set("view engine", "handlebars");
expressApp.use(helmet());
expressApp.use(express.json({
    type: ["application/json", "application/json-patch+json"]
}));
registerFormMiddleware(expressApp);
</span><strong class="screentext"><span class="kobospan" id="kobo.319.1">createAuth(expressApp);</span></strong><span class="kobospan" id="kobo.320.1">
registerFormRoutes(expressApp);
createApi(expressApp);
expressApp.use("^/$", (req, resp) =&gt; resp.redirect("/form"));
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.321.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.322.1">createAuth</span></code><span class="kobospan" id="kobo.323.1"> method is called after the middleware components required by forms are set up, but before the rest of the application. </span><span class="kobospan" id="kobo.323.2">This allows the authentication request handlers to rely on the features previously described for forms, such as decoding form data and using sessions.</span></p>
<p class="normal"><span class="kobospan" id="kobo.324.1">To test the </span><a id="_idIndexMarker795" class="calibre3"/><span class="kobospan" id="kobo.325.1">authentication workflow, use a web browser to request </span><code class="inlinecode"><span class="kobospan" id="kobo.326.1">http://localhost:5000/signin</span></code><span class="kobospan" id="kobo.327.1">, enter </span><code class="inlinecode"><span class="kobospan" id="kobo.328.1">alice</span></code><span class="kobospan" id="kobo.329.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.330.1">badpass</span></code><span class="kobospan" id="kobo.331.1"> into the form, and click the </span><strong class="screentext"><span class="kobospan" id="kobo.332.1">Sign In</span></strong><span class="kobospan" id="kobo.333.1"> button. </span><span class="kobospan" id="kobo.333.2">Validation will fail because the wrong password has been provided. </span><span class="kobospan" id="kobo.333.3">Change the password to </span><code class="inlinecode"><span class="kobospan" id="kobo.334.1">mysecret</span></code><span class="kobospan" id="kobo.335.1"> and click the button again. </span><span class="kobospan" id="kobo.335.2">This time, the credentials are validated, and the browser is redirected to the root URL. </span><span class="kobospan" id="kobo.335.3">This sequence is shown in </span><em class="italic"><span class="kobospan" id="kobo.336.1">Figure 15.2</span></em><span class="kobospan" id="kobo.337.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.338.1"><img alt="" src="../Images/B21959_15_02.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.339.1">Figure 15.2: The signing-in workflow</span></p>
<h1 class="heading" id="_idParaDest-264"><span class="kobospan" id="kobo.340.1">Authenticating requests</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.341.1">The </span><a id="_idIndexMarker796" class="calibre3"/><span class="kobospan" id="kobo.342.1">application can validate credentials, but that isn’t much use because there is currently no association between credentials sent to the </span><code class="inlinecode"><span class="kobospan" id="kobo.343.1">/signin</span></code><span class="kobospan" id="kobo.344.1"> URL and any subsequent HTTP requests made by the browser. </span></p>
<p class="normal"><span class="kobospan" id="kobo.345.1">This</span><a id="_idIndexMarker797" class="calibre3"/><span class="kobospan" id="kobo.346.1"> is the purpose of the temporary token that can be presented to the application to prove that the user has been through the credential validation process. </span><span class="kobospan" id="kobo.346.2">Cookies are the most common way to solve this problem, either by creating a separate cookie or by associating authentication data with an existing session cookie, which is the approach I am going to take in this chapter because it is the simplest approach and takes advantage of session features, such as automatic inactivity expiration. </span><em class="italic"><span class="kobospan" id="kobo.347.1">Listing 15.10</span></em><span class="kobospan" id="kobo.348.1"> uses a session to record successful authentication, and it defines middleware that detects the new session data and adds a </span><code class="inlinecode"><span class="kobospan" id="kobo.349.1">user</span></code><span class="kobospan" id="kobo.350.1"> property to the request object:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.351.1">Listing 15.10: Completing authentication in the index.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.352.1">import { Express } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
const store: AuthStore = new OrmAuthStore();
</span><strong class="screentext"><span class="kobospan" id="kobo.353.1">type </span></strong><strong class="screentext"><span class="kobospan" id="kobo.354.1">User = { username: string }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.355.1">declare module "express-session" {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.356.1">    interface SessionData { username: string; }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.357.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.358.1">declare global {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.359.1">    module </span></strong><strong class="screentext"><span class="kobospan" id="kobo.360.1">Express {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.361.1">        interface Request { user: User, authenticated: boolean }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.362.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.363.1">}</span></strong><span class="kobospan" id="kobo.364.1">
export const createAuth = (app: Express) =&gt; {
    </span><strong class="screentext"><span class="kobospan" id="kobo.365.1">app.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.366.1">use((req, resp, next) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.367.1">        const username = req.session.username;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.368.1">        if (username) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.369.1">            req.authenticated = true;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.370.1">            req.user = { username };</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.371.1">        } </span></strong><strong class="screentext"><span class="kobospan" id="kobo.372.1">else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.373.1">            req.authenticated = false;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.374.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.375.1">        next();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.376.1">    });</span></strong><span class="kobospan" id="kobo.377.1">
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            username: req.query["username"],
            password: req.query["password"],
            failed: req.query["failed"] ? </span><span class="kobospan" id="kobo.377.2">true : false
        }
        resp.render("signin", data);
    });
    app.post("/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const valid = await store.validateCredentials(username, password);
        if (valid) {
           </span><strong class="screentext"><span class="kobospan" id="kobo.378.1"> req.session.username = username;</span></strong><span class="kobospan" id="kobo.379.1">
            resp.redirect("/");
        } else {
            resp.redirect(
                `/signin?username=${username}&amp;password=${password}&amp;failed=1`);
        }
    });
    </span><strong class="screentext"><span class="kobospan" id="kobo.380.1">app.post("/signout", async (req, resp) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.381.1">        req.session.destroy(() =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.382.1">            resp.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.383.1">redirect("/");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.384.1">        })</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.385.1">    });</span></strong><span class="kobospan" id="kobo.386.1">
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.387.1">The</span><a id="_idIndexMarker798" class="calibre3"/><span class="kobospan" id="kobo.388.1"> first </span><code class="inlinecode"><span class="kobospan" id="kobo.389.1">declare</span></code><span class="kobospan" id="kobo.390.1"> statement extends the </span><code class="inlinecode"><span class="kobospan" id="kobo.391.1">SessionData</span></code><span class="kobospan" id="kobo.392.1"> interface to define a </span><code class="inlinecode"><span class="kobospan" id="kobo.393.1">username</span></code><span class="kobospan" id="kobo.394.1"> property so that a user’s identity can be associated with a session. </span><span class="kobospan" id="kobo.394.2">It can be tempting to put more complex data in the session, but the purpose of this new property is just to identify the user, which can be done by just adding one </span><code class="inlinecode"><span class="kobospan" id="kobo.395.1">string</span></code><span class="kobospan" id="kobo.396.1"> property to the </span><code class="inlinecode"><span class="kobospan" id="kobo.397.1">SessionData</span></code><span class="kobospan" id="kobo.398.1"> interface. </span><span class="kobospan" id="kobo.398.2">The second </span><code class="inlinecode"><span class="kobospan" id="kobo.399.1">declare</span></code><span class="kobospan" id="kobo.400.1"> statement adds </span><code class="inlinecode"><span class="kobospan" id="kobo.401.1">user</span></code><span class="kobospan" id="kobo.402.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.403.1">authenticated</span></code><span class="kobospan" id="kobo.404.1"> properties to the Express </span><code class="inlinecode"><span class="kobospan" id="kobo.405.1">Request</span></code><span class="kobospan" id="kobo.406.1"> interface, which will allow more complex user data to be provided to the rest of the application.</span></p>
<p class="normal"><span class="kobospan" id="kobo.407.1">When </span><a id="_idIndexMarker799" class="calibre3"/><span class="kobospan" id="kobo.408.1">the user’s credentials are validated, the </span><code class="inlinecode"><span class="kobospan" id="kobo.409.1">username</span></code><span class="kobospan" id="kobo.410.1"> property added to the </span><code class="inlinecode"><span class="kobospan" id="kobo.411.1">SessionData</span></code><span class="kobospan" id="kobo.412.1"> interface is used to store the username:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.413.1">...
</span><span class="kobospan" id="kobo.413.2">req.session.</span><strong class="screentext"><span class="kobospan" id="kobo.414.1">username</span></strong><span class="kobospan" id="kobo.415.1"> = username;
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.416.1">The new middleware component inspects the session data for requests to check to see if this property has been set. </span><span class="kobospan" id="kobo.416.2">If it has, then the </span><code class="inlinecode"><span class="kobospan" id="kobo.417.1">username</span></code><span class="kobospan" id="kobo.418.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.419.1">authenticated</span></code><span class="kobospan" id="kobo.420.1"> properties of the </span><code class="inlinecode"><span class="kobospan" id="kobo.421.1">Request</span></code><span class="kobospan" id="kobo.422.1"> object are set, which is how the rest of the application will be able to identify the authenticated user.</span></p>
<p class="normal"><span class="kobospan" id="kobo.423.1">The final addition is a new route for the </span><code class="inlinecode"><span class="kobospan" id="kobo.424.1">/signout</span></code><span class="kobospan" id="kobo.425.1"> URL, which lets a user sign out of the application by destroying the session, by calling the </span><code class="inlinecode"><span class="kobospan" id="kobo.426.1">destroy</span></code><span class="kobospan" id="kobo.427.1"> method, which is a feature provided by the </span><code class="inlinecode"><span class="kobospan" id="kobo.428.1">express-session</span></code><span class="kobospan" id="kobo.429.1"> package added to the project in </span><em class="italic"><span class="kobospan" id="kobo.430.1">Chapter 13</span></em><span class="kobospan" id="kobo.431.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.432.1">This means that the session cookie has been transformed into the temporary token that authenticates the user’s requests. </span><span class="kobospan" id="kobo.432.2">When the browser includes the session cookie in a request, the application knows that the request has been sent on behalf of the user because the session cookie represents the successful validation of the user’s credentials.</span></p>
<h2 class="heading1" id="_idParaDest-265"><span class="kobospan" id="kobo.433.1">Using the authentication data</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.434.1">To </span><a id="_idIndexMarker800" class="calibre3"/><span class="kobospan" id="kobo.435.1">complete the authentication feature, the user has to be able to see that they have successfully signed in and allowed to sign out again. </span><span class="kobospan" id="kobo.435.2">Express has a useful feature for working with templates, called </span><em class="italic"><span class="kobospan" id="kobo.436.1">local data</span></em><span class="kobospan" id="kobo.437.1"> or </span><em class="italic"><span class="kobospan" id="kobo.438.1">locals</span></em><span class="kobospan" id="kobo.439.1">, that allows data to be provided to a template outside of the call to the render method. </span><span class="kobospan" id="kobo.439.2">Local data is specific to a single request/response pair, and any value that is assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.440.1">Response.locals</span></code><span class="kobospan" id="kobo.441.1"> property is available for use within any template. </span><span class="kobospan" id="kobo.441.2">This is perfect for </span><a id="_idIndexMarker801" class="calibre3"/><span class="kobospan" id="kobo.442.1">providing authentication information to templates, which would otherwise have to be added to the context data for every call to the </span><code class="inlinecode"><span class="kobospan" id="kobo.443.1">render</span></code><span class="kobospan" id="kobo.444.1"> method. </span><em class="italic"><span class="kobospan" id="kobo.445.1">Listing 15.11</span></em><span class="kobospan" id="kobo.446.1"> uses this feature to provide templates with authentication information:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.447.1">Listing 15.11: Providing authentication details in the index.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.448.1">...
</span><span class="kobospan" id="kobo.448.2">app.use((req, resp, next) =&gt; {
    const username = req.session.username;
    if (username) {
        req.authenticated = true;
        req.user = { username };
    } else {
        req.authenticated = false;
    }
    </span><strong class="screentext"><span class="kobospan" id="kobo.449.1">resp.locals.user = req.user;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.450.1">    resp.locals.authenticated = req.authenticated;   </span></strong><span class="kobospan" id="kobo.451.1">
    next();
});
app.get("/signin", (req, resp) =&gt; {
    const data = {
        username: req.query["username"],
        password: req.query["password"],
        failed: req.query["failed"] ? </span><span class="kobospan" id="kobo.451.2">true : false,
       </span><strong class="screentext"><span class="kobospan" id="kobo.452.1"> signinpage: true</span></strong><span class="kobospan" id="kobo.453.1">
    }
    resp.render("signin", data);
});
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.454.1">The new statements added to the middleware component create local data values named </span><code class="inlinecode"><span class="kobospan" id="kobo.455.1">user</span></code><span class="kobospan" id="kobo.456.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.457.1">authenticated</span></code><span class="kobospan" id="kobo.458.1">, which means that this information will be available to any template that is executed by a request/response that has been processed by this middleware. </span><span class="kobospan" id="kobo.458.2">There is also a regular context data property named </span><code class="inlinecode"><span class="kobospan" id="kobo.459.1">signinpage</span></code><span class="kobospan" id="kobo.460.1">, which is passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.461.1">render</span></code><span class="kobospan" id="kobo.462.1"> method when the sign-in form is presented to the user.</span></p>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.463.1">Listing 15.12</span></em><span class="kobospan" id="kobo.464.1"> updates</span><a id="_idIndexMarker802" class="calibre3"/><span class="kobospan" id="kobo.465.1"> the layout that is used with all templates, which allows the authentication information to be displayed throughout the application:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.466.1">Listing 15.12: Using authentication data in the main.handlebars file in the templates/server/layouts folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.467.1">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="/bundle.js"&gt;&lt;/script&gt;       
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
      </span><strong class="screentext"><span class="kobospan" id="kobo.468.1">  {{#if authenticated }}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.469.1">            &lt;div class="bg-primary text-white p-1 clearfix"&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.470.1">                &lt;form method="post" action="/signout"&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.471.1">                    &lt;span class="h5"&gt;</span></strong><strong class="screentext"><span class="kobospan" id="kobo.472.1">User: {{ user.username }}&lt;/span&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.473.1">                    &lt;button class="btn btn-secondary btn-sm float-end"</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.474.1">                        type="submit"&gt;Sign Out&lt;/button&gt;</span></strong><strong class="screentext"> </strong>
<strong class="screentext"><span class="kobospan" id="kobo.475.1">                &lt;/form&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.476.1">            &lt;/div&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.477.1">        {{else }}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.478.1">            {{#unless signinpage }}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.479.1">                &lt;div class="bg-primary text-white p-1 clearfix"&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.480.1">                    &lt;a </span></strong><strong class="screentext"><span class="kobospan" id="kobo.481.1">href="/signin"</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.482.1">                        class="btn btn-secondary btn-sm float-end"&gt;Sign In&lt;/a&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.483.1">                &lt;/div&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.484.1">            {{/unless }}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.485.1">        {{/if}}</span></strong><span class="kobospan" id="kobo.486.1">
        {{{ body }}}
    &lt;/body&gt;
&lt;/html&gt;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.487.1">Local data values are used in the same way as regular template context data, and the additions to the template display the user’s name and a sign-out button if the request has been authenticated. </span><span class="kobospan" id="kobo.487.2">If the request isn’t authenticated, then the template displays a sign-in button, unless the </span><code class="inlinecode"><span class="kobospan" id="kobo.488.1">signinpage</span></code><span class="kobospan" id="kobo.489.1"> property is set, in which case no new content is shown.</span></p>
<p class="normal"><span class="kobospan" id="kobo.490.1">To see the</span><a id="_idIndexMarker803" class="calibre3"/><span class="kobospan" id="kobo.491.1"> effect of the changes, use a browser to navigate to </span><code class="inlinecode"><span class="kobospan" id="kobo.492.1">http://localhost:5000/signin</span></code><span class="kobospan" id="kobo.493.1">, enter </span><code class="inlinecode"><span class="kobospan" id="kobo.494.1">alice</span></code><span class="kobospan" id="kobo.495.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.496.1">mysecret</span></code><span class="kobospan" id="kobo.497.1"> into the </span><code class="inlinecode"><span class="kobospan" id="kobo.498.1">Name</span></code><span class="kobospan" id="kobo.499.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.500.1">Password</span></code><span class="kobospan" id="kobo.501.1"> fields, respectively, and click the </span><strong class="screentext"><span class="kobospan" id="kobo.502.1">Sign In</span></strong><span class="kobospan" id="kobo.503.1"> button. </span><span class="kobospan" id="kobo.503.2">The credentials will be validated, and the browser will display the username and a </span><strong class="screentext"><span class="kobospan" id="kobo.504.1">Sign Out</span></strong><span class="kobospan" id="kobo.505.1"> button. </span><span class="kobospan" id="kobo.505.2">Click the </span><strong class="screentext"><span class="kobospan" id="kobo.506.1">Sign Out</span></strong><span class="kobospan" id="kobo.507.1"> button, and a </span><strong class="screentext"><span class="kobospan" id="kobo.508.1">Sign In</span></strong><span class="kobospan" id="kobo.509.1"> button will be displayed. </span><span class="kobospan" id="kobo.509.2">This sequence is shown in </span><em class="italic"><span class="kobospan" id="kobo.510.1">Figure 15.3</span></em><span class="kobospan" id="kobo.511.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.512.1"><img alt="" src="../Images/B21959_15_03.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.513.1">Figure 15.3: Using authentication data</span></p>
<h1 class="heading" id="_idParaDest-266"><span class="kobospan" id="kobo.514.1">Authenticating web service requests</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.515.1">Applications can’t rely </span><a id="_idIndexMarker804" class="calibre3"/><span class="kobospan" id="kobo.516.1">on forms to authenticate web services because clients may not be browsers and cannot be relied on to render HTML.</span></p>
<p class="normal"><span class="kobospan" id="kobo.517.1">Web service clients can use cookies – because they are a standard part of HTTP – but session cookies can often cause problems because the session expiry is often set to suit round-trip clients, where every user interaction refreshes the cookie. </span><span class="kobospan" id="kobo.517.2">Web service clients only send requests when they need data, and the frequency of requests can be so low that sessions expire too quickly to be useful. </span></p>
<p class="normal"><span class="kobospan" id="kobo.518.1">Applications can address the lack of HTML support by providing an API to present credentials as JSON data. </span><span class="kobospan" id="kobo.518.2">Instead of a cookie, the authentication API produces a </span><em class="italic"><span class="kobospan" id="kobo.519.1">bearer token</span></em><span class="kobospan" id="kobo.520.1">, which is a string that can be included in requests, much like a cookie, but with its own lifecycle and without the dependency on sessions. </span></p>
<p class="normal"><span class="kobospan" id="kobo.521.1">The most common form of bearer token is </span><a id="_idIndexMarker805" class="calibre3"/><span class="kobospan" id="kobo.522.1">the </span><strong class="screentext"><span class="kobospan" id="kobo.523.1">JSON Web Token</span></strong><span class="kobospan" id="kobo.524.1"> (</span><strong class="screentext"><span class="kobospan" id="kobo.525.1">JWT</span></strong><span class="kobospan" id="kobo.526.1">) standard, which is a self-contained authentication token that doesn’t depend on server-side data. </span><span class="kobospan" id="kobo.526.2">(There is a good overview of JWT at </span><a href="https://jwt.io" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.527.1">https://jwt.io</span></span></a><span class="kobospan" id="kobo.528.1">, along </span><a id="_idIndexMarker806" class="calibre3"/><span class="kobospan" id="kobo.529.1">with tools to validate tokens, which can be useful during development).</span></p>
<p class="normal"><span class="kobospan" id="kobo.530.1">As with just </span><a id="_idIndexMarker807" class="calibre3"/><span class="kobospan" id="kobo.531.1">about every aspect of web services, there are no hard-and-fast standards for how a client performs authentication, but I am going to follow widely used conventions. </span><span class="kobospan" id="kobo.531.2">To sign in, the client will send an </span><code class="inlinecode"><span class="kobospan" id="kobo.532.1">HTTP POST</span></code><span class="kobospan" id="kobo.533.1"> request to the </span><code class="inlinecode"><span class="kobospan" id="kobo.534.1">/api/signin</span></code><span class="kobospan" id="kobo.535.1"> URL, with a JSON payload that includes the user’s credentials, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.536.1">...
</span><span class="kobospan" id="kobo.536.2">{
    "username": "alice",
    "password": "mysecret"
}
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.537.1">The result will contain a JSON object that contains a success property that indicates whether the credentials were accepted and, if they were, a </span><code class="inlinecode"><span class="kobospan" id="kobo.538.1">token</span></code><span class="kobospan" id="kobo.539.1"> property that contains the bearer token, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.540.1">...
</span><span class="kobospan" id="kobo.540.2">{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
}
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.541.1">Real JWT</span><a id="_idIndexMarker808" class="calibre3"/><span class="kobospan" id="kobo.542.1"> tokens are longer sequences of characters, but I have shorted this one for brevity. </span><span class="kobospan" id="kobo.542.2">The client doesn’t have to parse or process the token in any way, and they just have to include the token in HTTP requests using the </span><code class="inlinecode"><span class="kobospan" id="kobo.543.1">Authorization</span></code><span class="kobospan" id="kobo.544.1"> header, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.545.1">...
</span><span class="kobospan" id="kobo.545.2">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.546.1">The value of the </span><code class="inlinecode"><span class="kobospan" id="kobo.547.1">Authorization</span></code><span class="kobospan" id="kobo.548.1"> header is a scheme, which is </span><code class="inlinecode"><span class="kobospan" id="kobo.549.1">Bearer</span></code><span class="kobospan" id="kobo.550.1">, followed by the token generated during authentication. </span><span class="kobospan" id="kobo.550.2">The server decodes the token and uses it to determine the identity of the authenticated user. </span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.551.1">Understanding API keys</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.552.1">The examples in this chapter focus on user authentication. </span><span class="kobospan" id="kobo.552.2">Web services can also use API keys, which identify the client making the request on behalf of the user, which can be useful when a third-party creates clients that consume your project’s APIs. </span><span class="kobospan" id="kobo.552.3">API keys usually have a long life and are used to control access to API features, track request volumes, and so on. </span><span class="kobospan" id="kobo.552.4">I don’t describe API keys in this book, but there is a good </span><a id="_idIndexMarker809" class="calibre3"/><span class="kobospan" id="kobo.553.1">overview available at </span><a href="https://cloud.google.com/endpoints/docs/openapi/when-why-api-key" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.554.1">https://cloud.google.com/endpoints/docs/openapi/when-why-api-key</span></span></a><span class="kobospan" id="kobo.555.1">. </span></p>
</div>
<h2 class="heading1" id="_idParaDest-267"><span class="kobospan" id="kobo.556.1">Creating the authentication API</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.557.1">Run the command</span><a id="_idIndexMarker810" class="calibre3"/><span class="kobospan" id="kobo.558.1"> shown in </span><em class="italic"><span class="kobospan" id="kobo.559.1">Listing 15.13</span></em><span class="kobospan" id="kobo.560.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.561.1">part2app</span></code><span class="kobospan" id="kobo.562.1"> folder to add a JWT package and its type descriptions to the example project:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.563.1">Listing 15.13: Installing a package</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.564.1">npm install jsonwebtoken@9.0.2
npm install --save-dev @types/jsonwebtoken@9.0.5
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.565.1">It is possible to </span><a id="_idIndexMarker811" class="calibre3"/><span class="kobospan" id="kobo.566.1">generate and validate JWT values using custom code, but it is simpler and easier to use a good package. </span><em class="italic"><span class="kobospan" id="kobo.567.1">Listing 15.14</span></em><span class="kobospan" id="kobo.568.1"> adds support to sign in API clients:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.569.1">Listing 15.14: Signing in API clients in the index.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.570.1">import { Express } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
</span><strong class="screentext"><span class="kobospan" id="kobo.571.1">import jwt from "jsonwebtoken";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.572.1">const jwt_secret = "mytokensecret";</span></strong><span class="kobospan" id="kobo.573.1">
const store: AuthStore = new OrmAuthStore();
type User = { username: string }
declare module "express-session" {
    interface SessionData { username: string; }
}
declare global {
    module Express {
        interface Request { user: User, authenticated: boolean }
    }
}
export const createAuth = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        const username = req.session.username;
        if (username) {
            req.authenticated = true;
            req.user = { username };
     </span><strong class="screentext"><span class="kobospan" id="kobo.574.1">   } else if (req.headers.authorization) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.575.1">            let token = req.headers.authorization;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.576.1">            if (token.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.577.1">startsWith("Bearer ")) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.578.1">                token = token.substring(7);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.579.1">            }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.580.1">            try {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.581.1">                const decoded = jwt.verify(token, jwt_secret) as User;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.582.1">                req.authenticated = </span></strong><strong class="screentext"><span class="kobospan" id="kobo.583.1">true;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.584.1">                req.user = { username: decoded.username };</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.585.1">            } catch {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.586.1">                // do nothing - cannot verify token</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.587.1">            }</span></strong><span class="kobospan" id="kobo.588.1">
        } else {
            req.authenticated = false;
        }
        resp.locals.user = req.user;
        resp.locals.authenticated = req.authenticated;   
        next();
    });
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            username: req.query["username"],
            password: req.query["password"],
            failed: req.query["failed"] ? </span><span class="kobospan" id="kobo.588.2">true : false,
            signinpage: true
        }
        resp.render("signin", data);
    });
    app.post("/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const valid = await store.validateCredentials(username, password);
        if (valid) {
            req.session.username = username;
            resp.redirect("/");
        } else {
            resp.redirect(
                `/signin?username=${username}&amp;password=${password}&amp;failed=1`);
        }
    });
</span><strong class="screentext"><span class="kobospan" id="kobo.589.1">    app.post("/api/signin", </span></strong><strong class="screentext"><span class="kobospan" id="kobo.590.1">async (req, resp) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.591.1">        const username = req.body.username;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.592.1">        const password = req.body.password;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.593.1">        const result: any = {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.594.1">            success: </span></strong><strong class="screentext"><span class="kobospan" id="kobo.595.1">await store.validateCredentials(username, password)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.596.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.597.1">        if (result.success) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.598.1">            result.token = jwt.sign({username} , jwt_secret,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.599.1">                { expiresIn: "1hr"});</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.600.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.601.1">        resp.json(result);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.602.1">        resp.end();   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.603.1">    });</span></strong><span class="kobospan" id="kobo.604.1">
    app.post("/signout", async (req, resp) =&gt; {
        req.session.destroy(() =&gt; {
            resp.redirect("/");
        })
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.605.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.606.1">/api/signin</span></code><span class="kobospan" id="kobo.607.1"> route relies on the Express JSON middleware to parse the data sent by the client and validates the user’s credentials. </span><span class="kobospan" id="kobo.607.2">If the credentials are valid, then a token is created, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.608.1">...
</span><span class="kobospan" id="kobo.608.2">result.token = jwt.sign({username} , jwt_secret, { expiresIn: "1hr"});
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.609.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.610.1">sign</span></code><span class="kobospan" id="kobo.611.1"> function</span><a id="_idIndexMarker812" class="calibre3"/><span class="kobospan" id="kobo.612.1"> creates a token, which is signed to prevent tampering. </span><span class="kobospan" id="kobo.612.2">The arguments are the data to use as the token payload, a secret used to sign the token (which must be used again during validation), and a configuration object that is used to specify the token expiry.</span></p>
<p class="normal"><span class="kobospan" id="kobo.613.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.614.1">jsonwebtoken</span></code><span class="kobospan" id="kobo.615.1"> package supports setting expiry times using the syntax defined by the </span><code class="inlinecode"><span class="kobospan" id="kobo.616.1">ms</span></code><span class="kobospan" id="kobo.617.1"> package (</span><a href="https://github.com/vercel/ms" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.618.1">https://github.com/vercel/ms</span></span></a><span class="kobospan" id="kobo.619.1">). </span><span class="kobospan" id="kobo.619.2">This allows the </span><code class="inlinecode"><span class="kobospan" id="kobo.620.1">expiresIn</span></code><span class="kobospan" id="kobo.621.1"> property to be set to </span><code class="inlinecode"><span class="kobospan" id="kobo.622.1">1h</span></code><span class="kobospan" id="kobo.623.1">, which creates a token that’svalid for 60 mins.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.624.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.625.1">You can put any data in a token that is consumed by the same application that generates it. </span><span class="kobospan" id="kobo.625.2">If you are generating tokens that will be validated by third parties, then there are well-defined payload properties that are used to describe authentication and authorization data, which can be found at </span><a href="https://jwt.io/introduction" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.626.1">https://jwt.io/introduction</span></span></a><span class="kobospan" id="kobo.627.1">. </span><span class="kobospan" id="kobo.627.2">Tokens are signed but not encrypted, which means that sensitive data should not be included in a token.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.628.1">The authentication </span><a id="_idIndexMarker813" class="calibre3"/><span class="kobospan" id="kobo.629.1">middleware checks to see if the request includes the </span><code class="inlinecode"><span class="kobospan" id="kobo.630.1">Authorization</span></code><span class="kobospan" id="kobo.631.1"> header and, if it does, verifies its value as a token. </span><span class="kobospan" id="kobo.631.2">The verification checks the signature to ensure that the payload hasn’t been altered and ensures the token has not expired. </span><span class="kobospan" id="kobo.631.3">The username is read from the token’s payload and used to authenticate the request.</span></p>
<h2 class="heading1" id="_idParaDest-268"><span class="kobospan" id="kobo.632.1">Authenticating the web service client</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.633.1">To complete the </span><a id="_idIndexMarker814" class="calibre3"/><span class="kobospan" id="kobo.634.1">authentication implementation, </span><em class="italic"><span class="kobospan" id="kobo.635.1">Listing 15.15</span></em><span class="kobospan" id="kobo.636.1"> updates the command-line client to add operations to sign in and out of the application:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.637.1">Listing 15.15: Adding authentication in the operations.mjs file in the src/cmdline folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.638.1">import { input } from "@inquirer/prompts";
const baseUrl = "http://localhost:5000";
</span><strong class="screentext"><span class="kobospan" id="kobo.639.1">let bearer_token;</span></strong><span class="kobospan" id="kobo.640.1">
export const ops = {
  </span><strong class="screentext"><span class="kobospan" id="kobo.641.1">  "Sign In": async () =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.642.1">        const creds = {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.643.1">            username: await</span></strong><strong class="screentext"><span class="kobospan" id="kobo.644.1"> input({message: "Username?"}),</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.645.1">            password: await input({message: "Password?"}),</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.646.1">        };</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.647.1">        const response = await</span></strong><strong class="screentext"><span class="kobospan" id="kobo.648.1"> sendRequest("POST", "/api/signin", creds);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.649.1">        if (response.success == true) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.650.1">            bearer_token = response.token;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.651.1">        };</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.652.1">    },</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.653.1">    "Sign Out": () =&gt; { bearer_token = undefined</span></strong><strong class="screentext"><span class="kobospan" id="kobo.654.1"> },</span></strong><span class="kobospan" id="kobo.655.1">
    "Get All": () =&gt; sendRequest("GET", "/api/results"),
    // ... </span><span class="kobospan" id="kobo.655.2">other operations omitted for brevity...
</span><span class="kobospan" id="kobo.655.3">}
const sendRequest = async (method, url, body, contentType) =&gt; {
   </span><strong class="screentext"><span class="kobospan" id="kobo.656.1"> const headers = { "Content-Type": contentType ?? </span><span class="kobospan" id="kobo.656.2">"application/json"};</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.657.1">    if (bearer_token) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.658.1">        headers["Authorization"] = "Bearer " + bearer_token;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.659.1">    }</span></strong><span class="kobospan" id="kobo.660.1">
    const response = await fetch(baseUrl + url, {
       </span><strong class="screentext"><span class="kobospan" id="kobo.661.1"> method, headers, body</span></strong><strong class="screentext"><span class="kobospan" id="kobo.662.1">: JSON.stringify(body)</span></strong><span class="kobospan" id="kobo.663.1">
    });
    if (response.status == 200) {
        const data = await response.json();
        (Array.isArray(data) ? </span><span class="kobospan" id="kobo.663.2">data : [data])
            .forEach(elem =&gt; console.log(JSON.stringify(elem)));
        </span><strong class="screentext"><span class="kobospan" id="kobo.664.1">return data;</span></strong><span class="kobospan" id="kobo.665.1">
    } else {
        console.log(response.status + " " + response.statusText);
    }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.666.1">The token </span><a id="_idIndexMarker815" class="calibre3"/><span class="kobospan" id="kobo.667.1">received from successfully signing in is assigned to the variable named </span><code class="inlinecode"><span class="kobospan" id="kobo.668.1">bearer_token</span></code><span class="kobospan" id="kobo.669.1">, which is included in subsequent requests using the </span><code class="inlinecode"><span class="kobospan" id="kobo.670.1">Authorization</span></code><span class="kobospan" id="kobo.671.1"> header. </span><span class="kobospan" id="kobo.671.2">Note that the client doesn’t explicitly sign out of the application but simply discards the token. </span><span class="kobospan" id="kobo.671.3">That’s because the server doesn’t keep track of the tokens it has issued, and there is no way to invalidate them. </span><span class="kobospan" id="kobo.671.4">Once a token has been issued, it is valid until it has expired, and so web service clients simply stop using the token.</span></p>
<p class="normal"><span class="kobospan" id="kobo.672.1">Open a second command prompt, and run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.673.1">Listing 15.16</span></em><span class="kobospan" id="kobo.674.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.675.1">part2app</span></code><span class="kobospan" id="kobo.676.1"> folder to start the command-line client:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.677.1">Listing 15.16: Starting the client</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.678.1">npm run cmdline
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.679.1">Select the </span><strong class="screentext"><span class="kobospan" id="kobo.680.1">Sign In</span></strong><span class="kobospan" id="kobo.681.1"> option, and enter </span><code class="inlinecode"><span class="kobospan" id="kobo.682.1">alice</span></code><span class="kobospan" id="kobo.683.1"> as the username and </span><code class="inlinecode"><span class="kobospan" id="kobo.684.1">mysecret</span></code><span class="kobospan" id="kobo.685.1"> as the password. </span><span class="kobospan" id="kobo.685.2">The response from the server shows the outcome of the authentication</span><a id="_idIndexMarker816" class="calibre3"/><span class="kobospan" id="kobo.686.1"> and the token, like this:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.687.1">...
</span><span class="kobospan" id="kobo.687.2">? </span><span class="kobospan" id="kobo.687.3">Select an operation Sign In
? </span><span class="kobospan" id="kobo.687.4">Username? </span><span class="kobospan" id="kobo.687.5">alice
? </span><span class="kobospan" id="kobo.687.6">Password? </span><span class="kobospan" id="kobo.687.7">mysecret
{"success":true,"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFsaWNlIiwiaWF0IjoxNzA2MzQ2NDgyLCJleHAiOjE3MDYzNTAwODJ9.YjWggUNH1aP9CSGSnQGIQqZc36aQE7RG_Cb0ovEOj1k"}
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.688.1">You will see a different token value, but the structure of the data will be the same.</span></p>
<h1 class="heading" id="_idParaDest-269"><span class="kobospan" id="kobo.689.1">Authorizing requests</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.690.1">Now that the user</span><a id="_idIndexMarker817" class="calibre3"/><span class="kobospan" id="kobo.691.1"> can authenticate themselves, the next step is to restrict access to operations based on the user’s identity so that actions can only be performed by authorized users. </span></p>
<p class="normal"><span class="kobospan" id="kobo.692.1">The foundation for authorization is</span><a id="_idIndexMarker818" class="calibre3"/><span class="kobospan" id="kobo.693.1"> the </span><em class="italic"><span class="kobospan" id="kobo.694.1">authorization policy</span></em><span class="kobospan" id="kobo.695.1">, which is a mapping between the operations the application provides and the users that are allowed to perform them. </span><span class="kobospan" id="kobo.695.2">At its simplest, the mapping can be expressed as a simple list, as shown in </span><em class="italic"><span class="kobospan" id="kobo.696.1">Table 15.4</span></em><span class="kobospan" id="kobo.697.1"> for the example application, which provides </span><code class="inlinecode"><span class="kobospan" id="kobo.698.1">Add</span></code><span class="kobospan" id="kobo.699.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.700.1">Delete</span></code><span class="kobospan" id="kobo.701.1"> operations.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.702.1">Table 15.4: A simple authorization policy</span></p>
<table class="table-container" id="table004-8">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.703.1">Operation</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.704.1">Authorized Users</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3"><span class="kobospan2" id="kobo.705.1">Add</span></code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.706.1">alice, bob</span></code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3"><span class="kobospan2" id="kobo.707.1">Delete</span></code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.708.1">alice</span></code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.709.1">The problem with </span><a id="_idIndexMarker819" class="calibre3"/><span class="kobospan" id="kobo.710.1">this approach is that the authorization policy is an integral part of the application, which means that adding a new user or changing the operations that a user can perform requires a code change and a new release to be tested and deployed.</span></p>
<p class="normal"><span class="kobospan" id="kobo.711.1">For this reason, most applications introduce </span><em class="italic"><span class="kobospan" id="kobo.712.1">roles</span></em><span class="kobospan" id="kobo.713.1"> and rely on </span><em class="italic"><span class="kobospan" id="kobo.714.1">role</span></em> <em class="italic"><span class="kobospan" id="kobo.715.1">assignment </span></em><span class="kobospan" id="kobo.716.1">to authorize requests. </span><span class="kobospan" id="kobo.716.2">Rather than checking to see if the user is on the list, the application checks to see if the user has been assigned to one of the roles that are authorized to perform an operation. </span><span class="kobospan" id="kobo.716.3">The details of which users are assigned to each role can be stored in a database so that changes can be made without altering the application’s code. </span></p>
<p class="normal"><span class="kobospan" id="kobo.717.1">Applications are free to assign users to roles in whatever way makes the most sense, but a common approach is to focus on the different ways in which they engage with an application. </span><span class="kobospan" id="kobo.717.2">For this chapter, I am going to create two roles, as described in </span><em class="italic"><span class="kobospan" id="kobo.718.1">Table 15.5</span></em><span class="kobospan" id="kobo.719.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.720.1">Table 15.5: The example application roles</span></p>
<table class="table-container" id="table005-7">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.721.1">Roles</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.722.1">Members</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3"><span class="kobospan2" id="kobo.723.1">Users</span></code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.724.1">alice, bob</span></code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3"><span class="kobospan2" id="kobo.725.1">Admins</span></code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.726.1">alice</span></code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.727.1">The authorization policy can now be expressed in terms of authorized roles, rather than individual users, as described in </span><em class="italic"><span class="kobospan" id="kobo.728.1">Table 15.6</span></em><span class="kobospan" id="kobo.729.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.730.1">Table 15.6: A role-based authorization policy</span></p>
<table class="table-container" id="table006-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.731.1">Operation</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.732.1">Authorized Roles</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3"><span class="kobospan2" id="kobo.733.1">Add</span></code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.734.1">Users</span></code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3"><span class="kobospan2" id="kobo.735.1">Delete</span></code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.736.1">Admins</span></code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.737.1">The user </span><code class="inlinecode"><span class="kobospan" id="kobo.738.1">alice</span></code><span class="kobospan" id="kobo.739.1"> has been assigned to both roles and will be able to perform the </span><code class="inlinecode"><span class="kobospan" id="kobo.740.1">Add</span></code><span class="kobospan" id="kobo.741.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.742.1">Delete</span></code><span class="kobospan" id="kobo.743.1"> operations. </span><span class="kobospan" id="kobo.743.2">The user </span><code class="inlinecode"><span class="kobospan" id="kobo.744.1">bob</span></code><span class="kobospan" id="kobo.745.1"> has been assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.746.1">Users</span></code><span class="kobospan" id="kobo.747.1"> role and will be able to</span><a id="_idIndexMarker820" class="calibre3"/><span class="kobospan" id="kobo.748.1"> perform the </span><code class="inlinecode"><span class="kobospan" id="kobo.749.1">Add</span></code><span class="kobospan" id="kobo.750.1"> operation, but not the </span><code class="inlinecode"><span class="kobospan" id="kobo.751.1">Delete</span></code><span class="kobospan" id="kobo.752.1"> operation.</span></p>
<h2 class="heading1" id="_idParaDest-270"><span class="kobospan" id="kobo.753.1">Adding support for roles</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.754.1">The first step is to expand the </span><a id="_idIndexMarker821" class="calibre3"/><span class="kobospan" id="kobo.755.1">database to add support for describing roles, as shown in </span><em class="italic"><span class="kobospan" id="kobo.756.1">Listing 15.17</span></em><span class="kobospan" id="kobo.757.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.758.1">Listing 15.17: Adding types in the auth_types.ts in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.759.1">export interface Credentials {
    username: string;
    hashedPassword: Buffer;
    salt: Buffer;
}
</span><strong class="screentext"><span class="kobospan" id="kobo.760.1">export interface Role {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.761.1">    name: string;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.762.1">    members</span></strong><strong class="screentext"><span class="kobospan" id="kobo.763.1">: string[];</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.764.1">}</span></strong><span class="kobospan" id="kobo.765.1">
export interface AuthStore {
    getUser(name: string) : Promise&lt;Credentials | null&gt;;
    storeOrUpdateUser(username: string, password: string):
        Promise&lt;Credentials&gt;;
    validateCredentials(username: string, password: string): Promise&lt;boolean&gt;
    </span><strong class="screentext"><span class="kobospan" id="kobo.766.1">getRole(name: string) : Promise</span></strong><strong class="screentext"><span class="kobospan" id="kobo.767.1">&lt;Role | null&gt;;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.768.1">    getRolesForUser(username: string): Promise&lt;string[]&gt;;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.769.1">    storeOrUpdateRole(role: Role</span></strong><strong class="screentext"><span class="kobospan" id="kobo.770.1">) : Promise&lt;Role&gt;;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.771.1">    validateMembership(username: string, role: string): Promise&lt;boolean&gt;;</span></strong><span class="kobospan" id="kobo.772.1">
}
</span></code></pre>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.773.1">Listing 15.18</span></em><span class="kobospan" id="kobo.774.1"> defines the model class that Sequelize will use to represent roles in the database </span><a id="_idIndexMarker822" class="calibre3"/><span class="kobospan" id="kobo.775.1">and modifies the existing model class:</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.776.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.777.1">For consistency, it is easier to store credentials and role assignments in the same database so that the primary key for a user account can be used as a foreign key for role membership. </span><span class="kobospan" id="kobo.777.2">You can use separate databases, if you prefer, just as long as you ensure that changes are applied consistently, such as updating role memberships when a user account is deleted.</span></p>
</div>
<p class="packt_figref"><span class="kobospan" id="kobo.778.1">Listing 15.18: Adding a model in the orm_auth_models.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.779.1">import { DataTypes, InferAttributes, InferCreationAttributes, Model,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.780.1">    Sequelize, HasManySetAssociationsMixin }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.781.1">        from "sequelize";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.782.1">import</span></strong><strong class="screentext"><span class="kobospan" id="kobo.783.1"> { Credentials, Role } from "./auth_types";</span></strong><span class="kobospan" id="kobo.784.1">
export class CredentialsModel
        extends Model&lt;InferAttributes&lt;CredentialsModel&gt;,
            InferCreationAttributes&lt;CredentialsModel&gt;&gt;
        implements Credentials {
    declare username: string;
    declare hashedPassword: Buffer;
    declare salt: Buffer;
 </span><strong class="screentext"><span class="kobospan" id="kobo.785.1">   declare RoleModels?: InferAttributes&lt;RoleModel&gt;[];</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.786.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.787.1">export class RoleModel extends Model&lt;InferAttributes&lt;</span></strong><strong class="screentext"><span class="kobospan" id="kobo.788.1">RoleModel&gt;,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.789.1">        InferCreationAttributes&lt;RoleModel&gt;&gt;  {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.790.1">    declare name: string;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.791.1">    declare CredentialsModels?: InferAttributes&lt;CredentialsModel&gt;[];</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.792.1">    declare setCredentialsModels:</span></strong>
<strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.793.1">HasManySetAssociationsMixin&lt;CredentialsModel, string&gt;;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.794.1">}</span></strong><span class="kobospan" id="kobo.795.1">
export const initializeAuthModels = (sequelize: Sequelize) =&gt; {
    CredentialsModel.init({
        username: { type: DataTypes.STRING, primaryKey: true },
        hashedPassword: { type: DataTypes.BLOB },
        salt: { type: DataTypes.BLOB }
    }, { sequelize });
  </span><strong class="screentext"><span class="kobospan" id="kobo.796.1">  RoleModel.init({</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.797.1">        name: { type: DataTypes.STRING, primaryKey: </span></strong><strong class="screentext"><span class="kobospan" id="kobo.798.1">true },</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.799.1">    }, {  sequelize });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.800.1">    RoleModel.belongsToMany(CredentialsModel,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.801.1">        { through: "RoleMembershipJunction", foreignKey: "name" });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.802.1">    CredentialsModel.belongsToMany(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.803.1">RoleModel,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.804.1">        { through: "RoleMembershipJunction", foreignKey: "username" });  </span></strong><span class="kobospan" id="kobo.805.1">
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.806.1">Storing role</span><a id="_idIndexMarker823" class="calibre3"/><span class="kobospan" id="kobo.807.1"> memberships requires a </span><em class="italic"><span class="kobospan" id="kobo.808.1">many-to-many relationship</span></em><span class="kobospan" id="kobo.809.1">, where each role can be associated with many user credentials, and each user credential can be associated with many roles. </span><span class="kobospan" id="kobo.809.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.810.1">RoleModel</span></code><span class="kobospan" id="kobo.811.1"> class represents a role, with properties that provide the role name and an array of </span><code class="inlinecode"><span class="kobospan" id="kobo.812.1">CredentialsModels</span></code><span class="kobospan" id="kobo.813.1"> objects. </span></p>
<p class="normal"><span class="kobospan" id="kobo.814.1">Many-to-many relationships are represented in SQL using a junction table, where each row represents the relationship between one user and one role. </span><span class="kobospan" id="kobo.814.2">Many-to-many relationships are always awkwardly represented by ORM packages, and some trial and error is usually required to get the objects created by the ORM to match up to the SQL tables that are created. </span><span class="kobospan" id="kobo.814.3">Sequelize has a better-than-average approach, and the relationship between the model classes is created using the </span><code class="inlinecode"><span class="kobospan" id="kobo.815.1">belongsToMany</span></code><span class="kobospan" id="kobo.816.1"> method, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.817.1">...
</span><span class="kobospan" id="kobo.817.2">RoleModel.belongsToMany(CredentialsModel,
    { through: "RoleMembershipJunction", foreignKey: "name" });
CredentialsModel.belongsToMany(RoleModel,
{ through: "RoleMembershipJunction", foreignKey: "username" });
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.818.1">The</span><a id="_idIndexMarker824" class="calibre3"/><span class="kobospan" id="kobo.819.1"> arguments define the many-to-many relationship using a table named after the </span><code class="inlinecode"><span class="kobospan" id="kobo.820.1">RoleMembershipJunction</span></code><span class="kobospan" id="kobo.821.1"> class to create the junction. </span><span class="kobospan" id="kobo.821.2">Sequelize will create the table and figure out the column data types automatically and will include associated data in results when the </span><code class="inlinecode"><span class="kobospan" id="kobo.822.1">include</span></code><span class="kobospan" id="kobo.823.1"> query configuration setting is used, as you will see in </span><em class="italic"><span class="kobospan" id="kobo.824.1">Listing 15.18</span></em><span class="kobospan" id="kobo.825.1">. </span><span class="kobospan" id="kobo.825.2">The associated data can be read using properties that are added to the model class, which are described to TypeScript like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.826.1">...
</span><span class="kobospan" id="kobo.826.2">declare RoleModels?: InferAttributes&lt;RoleModel&gt;[];
...
</span><span class="kobospan" id="kobo.826.3">declare CredentialsModels?: InferAttributes&lt;CredentialsModel&gt;[];
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.827.1">The properties are optional, as denoted by the </span><code class="inlinecode"><span class="kobospan" id="kobo.828.1">?</span></code><span class="kobospan" id="kobo.829.1"> character, because they will only be populated when the query includes related data. </span><span class="kobospan" id="kobo.829.2">Sequelize adds methods to model objects to allow their relationships to other models to be used for more than reading data. </span><span class="kobospan" id="kobo.829.3">For the benefit of TypeScript, the </span><code class="inlinecode"><span class="kobospan" id="kobo.830.1">declare</span></code><span class="kobospan" id="kobo.831.1"> keyword has to be used to describe the properties, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.832.1">...
</span><span class="kobospan" id="kobo.832.2">declare </span><strong class="screentext"><span class="kobospan" id="kobo.833.1">setCredentialsModels</span></strong><span class="kobospan" id="kobo.834.1">: HasManySetAssociationsMixin&lt;CredentialsModel, string&gt;;
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.835.1">The names given to the methods combine the operation and the model class, such that </span><code class="inlinecode"><span class="kobospan" id="kobo.836.1">setCredentialsModels</span></code><span class="kobospan" id="kobo.837.1"> is a method that allows the </span><code class="inlinecode"><span class="kobospan" id="kobo.838.1">CredentialModels</span></code><span class="kobospan" id="kobo.839.1"> objects associated with a </span><code class="inlinecode"><span class="kobospan" id="kobo.840.1">RoleModel</span></code><span class="kobospan" id="kobo.841.1"> to be set in a single operation.</span></p>
<p class="normal"><span class="kobospan" id="kobo.842.1">For each of these methods, Sequelize provides types that can be used with the </span><code class="inlinecode"><span class="kobospan" id="kobo.843.1">declare</span></code><span class="kobospan" id="kobo.844.1"> statement. </span><span class="kobospan" id="kobo.844.2">In the case of the set operation, the type is named </span><code class="inlinecode"><span class="kobospan" id="kobo.845.1">HasManySetAssociationsMixin</span></code><span class="kobospan" id="kobo.846.1">, and the generic type parameters are used to specify the</span><a id="_idIndexMarker825" class="calibre3"/><span class="kobospan" id="kobo.847.1"> associated model class as the type of the primary key.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.848.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.849.1">This is the only method I need for this example because roles are updated by replacing all of the members, but Sequelize adds methods to read, add, and remove associated data, along with type descriptions for each of them, as described at </span><a href="https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.850.1">https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances</span></span></a><span class="kobospan" id="kobo.851.1">.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.852.1">The next step is to extend the store to add support to query, store, and check roles, as shown in </span><em class="italic"><span class="kobospan" id="kobo.853.1">Listing 15.19</span></em><span class="kobospan" id="kobo.854.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.855.1">Listing 15.19: Supporting roles in the orm_authstore.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.856.1">import</span></strong><strong class="screentext"><span class="kobospan" id="kobo.857.1"> { Sequelize, Op } from "sequelize";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.858.1">import { CredentialsModel, initializeAuthModels, RoleModel }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.859.1">    from "./orm_auth_models";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.860.1">import</span></strong><strong class="screentext"><span class="kobospan" id="kobo.861.1"> { AuthStore, Role } from "./auth_types";</span></strong><span class="kobospan" id="kobo.862.1">
import { pbkdf2, randomBytes, timingSafeEqual } from "crypto";
export class OrmAuthStore implements AuthStore {
    sequelize: Sequelize;
    constructor() {
        this.sequelize = new Sequelize({
            dialect: "sqlite",
            storage: "orm_auth.db",
            logging: console.log,
            logQueryParameters: true
        });
        this.initModelAndDatabase();
    }
    async initModelAndDatabase() : Promise&lt;void&gt; {
        initializeAuthModels(this.sequelize);
        await this.sequelize.drop();       
        await this.sequelize.sync();       
        await this.storeOrUpdateUser("alice", "mysecret");
        await this.storeOrUpdateUser("bob", "mysecret");       
        </span><strong class="screentext"><span class="kobospan" id="kobo.863.1">await this.storeOrUpdateRole({</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.864.1">            name: "Users", </span></strong><strong class="screentext"><span class="kobospan" id="kobo.865.1">members: ["alice", "bob"]</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.866.1">        });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.867.1">        await this.storeOrUpdateRole({</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.868.1">            name: "Admins", members: ["alice"]</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.869.1">        });</span></strong><span class="kobospan" id="kobo.870.1">
    }
    // ...methods omitted for brevity...
   </span><strong class="screentext"><span class="kobospan" id="kobo.871.1"> async getRole(name: string) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.872.1">        const stored = await RoleModel.findByPk(name, {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.873.1">            include: [{ </span></strong><strong class="screentext"><span class="kobospan" id="kobo.874.1">model: CredentialsModel, attributes: ["username"]}]</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.875.1">        });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.876.1">        if (stored) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.877.1">            return {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.878.1">                name: stored.name,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.879.1">                members: stored.CredentialsModels?.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.880.1">map(m =&gt; m.username) ?? </span><span class="kobospan" id="kobo.880.2">[]</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.881.1">            }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.882.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.883.1">        return null;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.884.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.885.1">    async getRolesForUser(username: string): Promise&lt;string[]&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.886.1">        return</span></strong><strong class="screentext"><span class="kobospan" id="kobo.887.1"> (await RoleModel.findAll({</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.888.1">            include: [{</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.889.1">                model: CredentialsModel,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.890.1">                where: { username },</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.891.1">                attributes: []</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.892.1">            }]</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.893.1">        })).map(rm</span></strong><strong class="screentext"><span class="kobospan" id="kobo.894.1"> =&gt; rm.name);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.895.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.896.1">    async storeOrUpdateRole(role: Role) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.897.1">        return await this.sequelize.transaction(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.898.1">async (transaction) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.899.1">            const users = await CredentialsModel.findAll({</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.900.1">                where: { username: { [Op.in]: role.members } },</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.901.1">                transaction</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.902.1">            });           </span></strong>
<strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.903.1">const [rm] = await RoleModel.findOrCreate({</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.904.1">                where: { name: role.name}, transaction });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.905.1">            await rm.setCredentialsModels(users, { transaction });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.906.1">            return role;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.907.1">        });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.908.1">    }</span></strong>
<strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.909.1">async validateMembership(username: string, rolename: string) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.910.1">        return (await this.getRolesForUser(username)).includes(rolename);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.911.1">    }   </span></strong><span class="kobospan" id="kobo.912.1">
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.913.1">The new</span><a id="_idIndexMarker826" class="calibre3"/><span class="kobospan" id="kobo.914.1"> statements in the constructor initialize the database models and add the </span><code class="inlinecode"><span class="kobospan" id="kobo.915.1">Admins</span></code><span class="kobospan" id="kobo.916.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.917.1">Users</span></code><span class="kobospan" id="kobo.918.1"> roles, which will be used to demonstrate the authorization process. </span></p>
<p class="normal"><span class="kobospan" id="kobo.919.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.920.1">getRole</span></code><span class="kobospan" id="kobo.921.1"> method queries the database for </span><code class="inlinecode"><span class="kobospan" id="kobo.922.1">RoleModel</span></code><span class="kobospan" id="kobo.923.1"> objects and uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.924.1">include</span></code><span class="kobospan" id="kobo.925.1"> option to include the associated </span><code class="inlinecode"><span class="kobospan" id="kobo.926.1">CredentialsModel</span></code><span class="kobospan" id="kobo.927.1"> objects in the results, which is transformed into the </span><code class="inlinecode"><span class="kobospan" id="kobo.928.1">Role</span></code><span class="kobospan" id="kobo.929.1"> result required by the </span><code class="inlinecode"><span class="kobospan" id="kobo.930.1">RoleStore</span></code><span class="kobospan" id="kobo.931.1"> interface. </span><span class="kobospan" id="kobo.931.2">I only need the </span><code class="inlinecode"><span class="kobospan" id="kobo.932.1">username</span></code><span class="kobospan" id="kobo.933.1"> value to create a role, and I have specified the column I want </span><code class="inlinecode"><span class="kobospan" id="kobo.934.1">Sequelize</span></code><span class="kobospan" id="kobo.935.1"> to include in the query using the </span><code class="inlinecode"><span class="kobospan" id="kobo.936.1">attributes</span></code><span class="kobospan" id="kobo.937.1"> property:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.938.1">...
</span><span class="kobospan" id="kobo.938.2">const stored = await RoleModel.findByPk(name, {
    include: [{</span><strong class="screentext"><span class="kobospan" id="kobo.939.1"> model: CredentialsModel, attributes: ["username"]</span></strong><span class="kobospan" id="kobo.940.1">}]
});
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.941.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.942.1">include</span></code><span class="kobospan" id="kobo.943.1"> property is configured with an object whose </span><code class="inlinecode"><span class="kobospan" id="kobo.944.1">model</span></code><span class="kobospan" id="kobo.945.1"> property specifies the associated data and </span><code class="inlinecode"><span class="kobospan" id="kobo.946.1">attributes</span></code><span class="kobospan" id="kobo.947.1"> property specifies the model properties to populate in the result.</span></p>
<p class="normal"><span class="kobospan" id="kobo.948.1">A similar technique is used to implement the </span><code class="inlinecode"><span class="kobospan" id="kobo.949.1">getRolesForUser</span></code><span class="kobospan" id="kobo.950.1"> method. </span><span class="kobospan" id="kobo.950.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.951.1">findAll</span></code><span class="kobospan" id="kobo.952.1"> method is used to query for all </span><code class="inlinecode"><span class="kobospan" id="kobo.953.1">RoleModel</span></code><span class="kobospan" id="kobo.954.1"> objects, but the </span><code class="inlinecode"><span class="kobospan" id="kobo.955.1">where</span></code><span class="kobospan" id="kobo.956.1"> clause is used to make a selection based on the associated data so that only </span><code class="inlinecode"><span class="kobospan" id="kobo.957.1">RoleModel</span></code><span class="kobospan" id="kobo.958.1"> objects that have associations with </span><code class="inlinecode"><span class="kobospan" id="kobo.959.1">CredentialsModel</span></code><span class="kobospan" id="kobo.960.1"> objects whose </span><code class="inlinecode"><span class="kobospan" id="kobo.961.1">username</span></code><span class="kobospan" id="kobo.962.1"> property </span><a id="_idIndexMarker827" class="calibre3"/><span class="kobospan" id="kobo.963.1">matches a given value. </span><span class="kobospan" id="kobo.963.2">An empty </span><code class="inlinecode"><span class="kobospan" id="kobo.964.1">attributes</span></code><span class="kobospan" id="kobo.965.1"> array is used to exclude all of the </span><code class="inlinecode"><span class="kobospan" id="kobo.966.1">CredentialModel</span></code><span class="kobospan" id="kobo.967.1"> data from the result:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.968.1">...
</span><span class="kobospan" id="kobo.968.2">return (await RoleModel.findAll({
    include: [{
        model: CredentialsModel,
        where: { username },
       </span><strong class="screentext"><span class="kobospan" id="kobo.969.1"> attributes: []</span></strong><span class="kobospan" id="kobo.970.1">
    }]
})).map(rm =&gt; rm.name);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.971.1">There can be several different ways to approach queries when there are relationships between models, and the same data can be obtained by starting with the </span><code class="inlinecode"><span class="kobospan" id="kobo.972.1">CredentialModel</span></code><span class="kobospan" id="kobo.973.1"> class and including the </span><code class="inlinecode"><span class="kobospan" id="kobo.974.1">RoleModel</span></code><span class="kobospan" id="kobo.975.1"> class. </span><span class="kobospan" id="kobo.975.2">My advice is to pick whichever approach feels the most natural to you, which will be a matter of personal preference.</span></p>
<p class="normal"><span class="kobospan" id="kobo.976.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.977.1">storeOrUpdateRole</span></code><span class="kobospan" id="kobo.978.1"> method accepts a </span><code class="inlinecode"><span class="kobospan" id="kobo.979.1">Role</span></code><span class="kobospan" id="kobo.980.1"> object and queries the database for all of the matching </span><code class="inlinecode"><span class="kobospan" id="kobo.981.1">CredentialsModel</span></code><span class="kobospan" id="kobo.982.1"> objects, which ensures that any name for which there are no user credentials is ignored. </span><span class="kobospan" id="kobo.982.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.983.1">findOrCreate</span></code><span class="kobospan" id="kobo.984.1"> method ensures that a </span><code class="inlinecode"><span class="kobospan" id="kobo.985.1">RoleModel</span></code><span class="kobospan" id="kobo.986.1"> object exists in the database, and the </span><code class="inlinecode"><span class="kobospan" id="kobo.987.1">setCredentialsModels</span></code><span class="kobospan" id="kobo.988.1"> method is used to set the role membership. </span><span class="kobospan" id="kobo.988.2">A transaction is used to ensure that the update is performed atomically.</span></p>
<p class="normal"><span class="kobospan" id="kobo.989.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.990.1">validateMembership</span></code><span class="kobospan" id="kobo.991.1"> method gets the roles to which a user has been assigned and checks that one of them matches the required role.</span></p>
<h2 class="heading1" id="_idParaDest-271"><span class="kobospan" id="kobo.992.1">Checking authorization</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.993.1">The next step </span><a id="_idIndexMarker828" class="calibre3"/><span class="kobospan" id="kobo.994.1">is to guard routes so that only users who are assigned to authorized roles can perform operations. </span><span class="kobospan" id="kobo.994.2">There are lots of ways to implement authorization, but one of the simplest is to use the Express feature that allows middleware components to be added to individual routes, which means that requests can be inspected and rejected before they are passed to the route’s request handler. </span><em class="italic"><span class="kobospan" id="kobo.995.1">Listing 15.20</span></em><span class="kobospan" id="kobo.996.1"> adds a function that creates a middleware component that restricts access to one or more roles:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.997.1">Listing 15.20: Defining a guard handler in the index.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.998.1">import { Express</span></strong><strong class="screentext"><span class="kobospan" id="kobo.999.1">, NextFunction, RequestHandler } from "express";</span></strong><span class="kobospan" id="kobo.1000.1">
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
import jwt from "jsonwebtoken";
const jwt_secret = "mytokensecret";
const store: AuthStore = new OrmAuthStore();
type User = { username: string }
declare module "express-session" {
    interface SessionData { username: string; }
}
declare global {
    module Express {
        interface Request { user: User, authenticated: boolean }
    }
}
export const createAuth = (app: Express) =&gt; {
    // ...other routes omitted for brevity...
</span><strong class="screentext"><span class="kobospan" id="kobo.1001.1">    app.get("/unauthorized", async (req, resp) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1002.1">        resp.render("unauthorized");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1003.1">    });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1004.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1005.1">export const roleGuard = (role: string)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1006.1">        : RequestHandler</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1007.1">&lt;Request, Response, NextFunction&gt; =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1008.1">    return async (req, resp, next) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1009.1">        if (req.authenticated) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1010.1">            const username = req.user.username</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1011.1">;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1012.1">            if (await store.validateMembership(username, role)) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1013.1">                next();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1014.1">                return;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1015.1">            }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1016.1">            resp.redirect("/unauthorized");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1017.1">        } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1018.1">            resp.redirect("/signin"</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1019.1">);           </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1020.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1021.1">    }</span></strong><span class="kobospan" id="kobo.1022.1">
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1023.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1024.1">roleGuard</span></code><span class="kobospan" id="kobo.1025.1"> function </span><a id="_idIndexMarker829" class="calibre3"/><span class="kobospan" id="kobo.1026.1">accepts a role and returns a middleware component that will only pass on the request to the handler if the user has been assigned to that role, which is checked using the </span><code class="inlinecode"><span class="kobospan" id="kobo.1027.1">validateMembership</span></code><span class="kobospan" id="kobo.1028.1"> method provided by the store. </span></p>
<p class="normal"><span class="kobospan" id="kobo.1029.1">There are two outcomes for unauthorized requests. </span><span class="kobospan" id="kobo.1029.2">If the user has not been authenticated, then the user is redirected to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1030.1">/signin</span></code><span class="kobospan" id="kobo.1031.1"> URL, so they can authenticate themselves and try again. </span></p>
<p class="normal"><span class="kobospan" id="kobo.1032.1">For authenticated requests, the user is redirected to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1033.1">/unauthorized</span></code><span class="kobospan" id="kobo.1034.1"> URL. </span><em class="italic"><span class="kobospan" id="kobo.1035.1">Listing 15.20</span></em><span class="kobospan" id="kobo.1036.1"> adds a route for </span><code class="inlinecode"><span class="kobospan" id="kobo.1037.1">/unauthorized</span></code><span class="kobospan" id="kobo.1038.1"> that renders a template. </span><span class="kobospan" id="kobo.1038.2">To create the template, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.1039.1">unauthorized.handlebars</span></code><span class="kobospan" id="kobo.1040.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1041.1">templates/server</span></code><span class="kobospan" id="kobo.1042.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.1043.1">Listing 15.21</span></em><span class="kobospan" id="kobo.1044.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1045.1">Listing 15.21: The contents of the unauthorized.handlebars file in the templates/server folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1046.1">&lt;div class="bg-danger text-white  m-1 p-2"&gt;
    &lt;div class="h2"&gt;Unauthorized&lt;/div&gt;
    &lt;div class="h4"&gt;
        You do not have permission to perform this operation
    &lt;/div&gt;
&lt;/div&gt;
&lt;a href="/" class="btn btn-secondary mx-1"&gt;Back&lt;/a&gt;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1047.1">The final step is </span><a id="_idIndexMarker830" class="calibre3"/><span class="kobospan" id="kobo.1048.1">to apply the guard to restrict access to operations, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1049.1">Listing 15.22</span></em><span class="kobospan" id="kobo.1050.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1051.1">Listing 15.22: Authorizing requests in the forms.ts file in the src/server folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1052.1">import express, { Express } from "express";
import repository  from "./data";
import cookieMiddleware from "cookie-parser";
import { sessionMiddleware } from "./sessions/session_helpers";
</span><strong class="screentext"><span class="kobospan" id="kobo.1053.1">import { roleGuard } </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1054.1">from "./auth";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1055.1">import { Result } from "./data/repository";</span></strong><span class="kobospan" id="kobo.1056.1">
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
    app.use(cookieMiddleware("mysecret"));
    app.use(sessionMiddleware());
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("data", {data: await repository.getAllResults(rowLimit)});
    });
  </span><strong class="screentext"><span class="kobospan" id="kobo.1057.1">  app.post("/form/delete/:id", roleGuard("Admins"), async (req, resp) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1058.1">        const id = </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1059.1">Number.parseInt(req.params["id"]);</span></strong><span class="kobospan" id="kobo.1060.1">
        await repository.delete(id);
        resp.redirect("/form");
        resp.end();
    });
       
   </span><strong class="screentext"><span class="kobospan" id="kobo.1061.1"> app.post("</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1062.1">/form/add", roleGuard("Users"), async (req, resp) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1063.1">        const nextage = Number.parseInt(req.body["age"])</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1064.1">            + Number.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1065.1">parseInt(req.body["years"]);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1066.1">        await repository.saveResult({...req.body, nextage } as Result);</span></strong><span class="kobospan" id="kobo.1067.1">
        resp.redirect("/form");
        resp.end();
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1068.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1069.1">/form/add</span></code><span class="kobospan" id="kobo.1070.1"> route</span><a id="_idIndexMarker831" class="calibre3"/><span class="kobospan" id="kobo.1071.1"> is restricted to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1072.1">Users</span></code><span class="kobospan" id="kobo.1073.1"> role, and the </span><code class="inlinecode"><span class="kobospan" id="kobo.1074.1">/form/delete/:id</span></code><span class="kobospan" id="kobo.1075.1"> route is restricted to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1076.1">Admins</span></code><span class="kobospan" id="kobo.1077.1"> role.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1078.1">Applying the role guard reveals an inconsistency in the type descriptions for the Express API, which causes the TypeScript compiler to complain about statements like this: </span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1079.1">...
</span><span class="kobospan" id="kobo.1079.2">const id = Number.parseInt(req.params.id);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1080.1">The type that the compiler uses for the </span><code class="inlinecode"><span class="kobospan" id="kobo.1081.1">Request.params</span></code><span class="kobospan" id="kobo.1082.1"> property has changed, and the compiler will complain about the </span><code class="inlinecode"><span class="kobospan" id="kobo.1083.1">id</span></code><span class="kobospan" id="kobo.1084.1"> property. </span><span class="kobospan" id="kobo.1084.2">It is possible to correct this by adding a type annotation to the request handler, but a quick fix is to access the property like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1085.1">...
</span><span class="kobospan" id="kobo.1085.2">const id = Number.parseInt(req.params["id"]);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1086.1">Use a browser to request </span><code class="inlinecode"><span class="kobospan" id="kobo.1087.1">http://localhost:5000</span></code><span class="kobospan" id="kobo.1088.1">, and make sure that no user is signed in. </span><span class="kobospan" id="kobo.1088.2">Click the </span><strong class="screentext"><span class="kobospan" id="kobo.1089.1">Add</span></strong><span class="kobospan" id="kobo.1090.1"> button. </span><span class="kobospan" id="kobo.1090.2">The browser will send a request to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1091.1">/form/add</span></code><span class="kobospan" id="kobo.1092.1"> route, but since the request is unauthenticated, the browser will be redirected to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1093.1">/signin</span></code><span class="kobospan" id="kobo.1094.1"> page. </span><span class="kobospan" id="kobo.1094.2">Sign in with the username </span><code class="inlinecode"><span class="kobospan" id="kobo.1095.1">bob</span></code><span class="kobospan" id="kobo.1096.1"> and the password </span><code class="inlinecode"><span class="kobospan" id="kobo.1097.1">mysecret</span></code><span class="kobospan" id="kobo.1098.1">, and click the </span><strong class="screentext"><span class="kobospan" id="kobo.1099.1">Add</span></strong><span class="kobospan" id="kobo.1100.1"> button again. </span><span class="kobospan" id="kobo.1100.2">This time, the request is authenticated, and the user has been assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1101.1">Users</span></code><span class="kobospan" id="kobo.1102.1"> role, so the request is authorized and passed onto the request handler, which adds a new value to the database.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1103.1">Click the </span><strong class="screentext"><span class="kobospan" id="kobo.1104.1">Delete</span></strong><span class="kobospan" id="kobo.1105.1"> button, and the browser will send a request to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1106.1">/form/delete/:id</span></code><span class="kobospan" id="kobo.1107.1"> route. </span><span class="kobospan" id="kobo.1107.2">The request is authenticated but the user has not been assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1108.1">Admins</span></code><span class="kobospan" id="kobo.1109.1"> role, so the browser is redirected to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1110.1">/unauthorized</span></code><span class="kobospan" id="kobo.1111.1"> URL. </span><span class="kobospan" id="kobo.1111.2">The complete sequence is shown in </span><em class="italic"><span class="kobospan" id="kobo.1112.1">Figure 15.4</span></em><span class="kobospan" id="kobo.1113.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.1114.1"><img alt="" src="../Images/B21959_15_04.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.1115.1">Figure 15.4: Testing authorization</span></p>
<h2 class="heading1" id="_idParaDest-272"><span class="kobospan" id="kobo.1116.1">Authorizing API requests</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1117.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1118.1">Feathers</span></code><span class="kobospan" id="kobo.1119.1"> package that I </span><a id="_idIndexMarker832" class="calibre3"/><span class="kobospan" id="kobo.1120.1">introduced in </span><em class="italic"><span class="kobospan" id="kobo.1121.1">Chapter 14</span></em><span class="kobospan" id="kobo.1122.1"> provides support for hooks, which allow requests to be intercepted, and which I used to alter the status code when a specific error was thrown. </span><span class="kobospan" id="kobo.1122.2">In this chapter, I am going to use the same feature to manage authorization. </span><span class="kobospan" id="kobo.1122.3">The first step is to create a function that will create a hook that checks the user’s membership of a role, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1123.1">Listing 15.23</span></em><span class="kobospan" id="kobo.1124.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1125.1">Listing 15.23: Adding a hook function in the index.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1126.1">import { Express, NextFunction, RequestHandler } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
import jwt from "jsonwebtoken";
</span><strong class="screentext"><span class="kobospan" id="kobo.1127.1">import { HookContext } from "@feathersjs/feathers";</span></strong><span class="kobospan" id="kobo.1128.1">
const jwt_secret = "mytokensecret";
// ...statements omitted for brevity...
</span><span class="kobospan" id="kobo.1128.2">export const roleGuard = (role: string)
        : RequestHandler&lt;Request, Response, NextFunction&gt; =&gt; {
    return async (req, resp, next) =&gt; {
        if (req.authenticated) {
            const username = req.user.username;
            if (await store.validateMembership(username, role)) {
                next();
                return;
            }
            resp.redirect("/unauthorized");
        } else {
            resp.redirect("/signin");           
        }
    }
}
</span><strong class="screentext"><span class="kobospan" id="kobo.1129.1">export const roleHook = (</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1130.1">role: string) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1131.1">    return async (ctx: HookContext) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1132.1">        if (!ctx.params.authenticated) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1133.1">            ctx.http = { status: </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1134.1">401 };</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1135.1">            ctx.result = {};</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1136.1">        } else if (!(await store.validateMembership(</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1137.1">                ctx.params.user.username, role))) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1138.1">            ctx.http = { </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1139.1">status: 403 };</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1140.1">            ctx.result = {};</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1141.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1142.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1143.1">}</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1144.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1145.1">roleHook</span></code><span class="kobospan" id="kobo.1146.1"> function </span><a id="_idIndexMarker833" class="calibre3"/><span class="kobospan" id="kobo.1147.1">creates a hook that will authorize access if a user has been assigned to a specified role. </span><span class="kobospan" id="kobo.1147.2">The user’s identity is accessed through the </span><code class="inlinecode"><span class="kobospan" id="kobo.1148.1">HookContext</span></code><span class="kobospan" id="kobo.1149.1"> parameter, which Feathers provides when a hook is invoked. </span><span class="kobospan" id="kobo.1149.2">The key difference from the route guard used for non-API requests is that the responses are HTTP status codes and not HTML documents. </span><span class="kobospan" id="kobo.1149.3">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1150.1">401</span></code><span class="kobospan" id="kobo.1151.1"> status code indicates a request that does not include authentication data, and a </span><code class="inlinecode"><span class="kobospan" id="kobo.1152.1">403</span></code><span class="kobospan" id="kobo.1153.1"> status code is sent when the user is authenticated but not authorized. </span><span class="kobospan" id="kobo.1153.2">The status code is set using the </span><code class="inlinecode"><span class="kobospan" id="kobo.1154.1">HookContext.http</span></code><span class="kobospan" id="kobo.1155.1"> property, and setting the </span><code class="inlinecode"><span class="kobospan" id="kobo.1156.1">result</span></code><span class="kobospan" id="kobo.1157.1"> property has the effect of terminating request handling. </span></p>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.1158.1">Listing 15.24</span></em><span class="kobospan" id="kobo.1159.1"> applies the hook and configures Feathers so that the hook receives the request’s authentication data:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1160.1">Listing 15.24: Applying authorization in the index.ts file in the src/server/api folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1161.1">import { Express } from "express";
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
import { Validator } from "./validation_adapter";
import { ResultWebServiceValidation } from "./results_api_validation";
import { FeathersWrapper } from "./feathers_adapter";
import { feathers } from "@feathersjs/feathers";
import feathersExpress, { rest } from "@feathersjs/express";
import { ValidationError } from "./validation_types";
</span><strong class="screentext"><span class="kobospan" id="kobo.1162.1">import { roleHook } from "../auth";</span></strong><span class="kobospan" id="kobo.1163.1">
export const createApi = (app: Express) =&gt; {
    const feathersApp = feathersExpress(feathers(), app).configure(rest());
    const service = new Validator(new ResultWebService(),
        ResultWebServiceValidation);
    </span><strong class="screentext"><span class="kobospan" id="kobo.1164.1">feathersApp.use('/api/results',</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1165.1">        (req, resp, next) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1166.1">            req.feathers.user = req.user;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1167.1">            req.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1168.1">feathers.authenticated = req.authenticated;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1169.1">            next();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1170.1">        },</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1171.1">        new FeathersWrapper(service));</span></strong><span class="kobospan" id="kobo.1172.1">
    feathersApp.hooks({
        error: {
            all: [(ctx) =&gt; {                       
                    if (ctx.error instanceof ValidationError) {
                        ctx.http = { status: 400};
                        ctx.error = undefined;
                    }
                }]
        },
       </span><strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.1173.1">before: {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1174.1">            create: [roleHook("Users")],</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1175.1">            remove: [roleHook("Admins")],</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1176.1">            update: [roleHook("Admins")],</span></strong>
<strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.1177.1">patch: [roleHook("Admins")]</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1178.1">        }       </span></strong><span class="kobospan" id="kobo.1179.1">
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1180.1">The first step is to get the </span><a id="_idIndexMarker834" class="calibre3"/><span class="kobospan" id="kobo.1181.1">authentication data from the request and add it to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1182.1">feathers</span></code><span class="kobospan" id="kobo.1183.1"> property, which is added to requests when Feathers is used and presented through the </span><code class="inlinecode"><span class="kobospan" id="kobo.1184.1">HookContext</span></code><span class="kobospan" id="kobo.1185.1"> object provided to hooks.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1186.1">The second step is to create hooks to protect the web service. </span><span class="kobospan" id="kobo.1186.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1187.1">before</span></code><span class="kobospan" id="kobo.1188.1"> property is used to register hooks that are invoked before a web service method is invoked, and the </span><code class="inlinecode"><span class="kobospan" id="kobo.1189.1">create</span></code><span class="kobospan" id="kobo.1190.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1191.1">remove</span></code><span class="kobospan" id="kobo.1192.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1193.1">update</span></code><span class="kobospan" id="kobo.1194.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.1195.1">patch</span></code><span class="kobospan" id="kobo.1196.1"> methods are protected by hooks that require either the </span><code class="inlinecode"><span class="kobospan" id="kobo.1197.1">Users</span></code><span class="kobospan" id="kobo.1198.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.1199.1">Admins</span></code><span class="kobospan" id="kobo.1200.1"> role.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1201.1">If you closed the command-line client from earlier in the chapter, then open a new command prompt, navigate to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1202.1">part2app</span></code><span class="kobospan" id="kobo.1203.1"> folder, and run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.1204.1">Listing 15.25</span></em><span class="kobospan" id="kobo.1205.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1206.1">Listing 15.25: Starting the command-line client</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1207.1">npm run cmdline
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1208.1">Select the </span><strong class="screentext"><span class="kobospan" id="kobo.1209.1">Store</span></strong><span class="kobospan" id="kobo.1210.1"> option, enter the data values, and when the request is sent, the server will response with a </span><code class="inlinecode"><span class="kobospan" id="kobo.1211.1">401</span></code><span class="kobospan" id="kobo.1212.1"> status code, which indicates that an operation requires authorization but the request contained no authentication data, like this:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1213.1">? </span><span class="kobospan" id="kobo.1213.2">Select an operation Store
? </span><span class="kobospan" id="kobo.1213.3">Name? </span><span class="kobospan" id="kobo.1213.4">Joe
? </span><span class="kobospan" id="kobo.1213.5">Age? </span><span class="kobospan" id="kobo.1213.6">30
? </span><span class="kobospan" id="kobo.1213.7">Years? </span><span class="kobospan" id="kobo.1213.8">10
401 Unauthorized
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1214.1">Sign in as </span><code class="inlinecode"><span class="kobospan" id="kobo.1215.1">bob</span></code><span class="kobospan" id="kobo.1216.1"> with the password </span><code class="inlinecode"><span class="kobospan" id="kobo.1217.1">mysecret</span></code><span class="kobospan" id="kobo.1218.1"> and repeat the process. </span><span class="kobospan" id="kobo.1218.2">This time, the request will contain the bearer token, and the user </span><code class="inlinecode"><span class="kobospan" id="kobo.1219.1">bob</span></code><span class="kobospan" id="kobo.1220.1"> has been assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1221.1">Users</span></code><span class="kobospan" id="kobo.1222.1"> role, so the operation will be authorized, like this:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1223.1">...
</span><span class="kobospan" id="kobo.1223.2">? </span><span class="kobospan" id="kobo.1223.3">Select an operation Sign In
? </span><span class="kobospan" id="kobo.1223.4">Username? </span><span class="kobospan" id="kobo.1223.5">bob
? </span><span class="kobospan" id="kobo.1223.6">Password? </span><span class="kobospan" id="kobo.1223.7">mysecret
{"success":true,"token":"eyJhbGciOi...&lt;...data omitted...&gt;"}
? </span><span class="kobospan" id="kobo.1223.8">Select an operation Store
? </span><span class="kobospan" id="kobo.1223.9">Name? </span><span class="kobospan" id="kobo.1223.10">Joe
? </span><span class="kobospan" id="kobo.1223.11">Age? </span><span class="kobospan" id="kobo.1223.12">30
? </span><span class="kobospan" id="kobo.1223.13">Years? </span><span class="kobospan" id="kobo.1223.14">10
201 Created
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1224.1">Select </span><strong class="screentext"><span class="kobospan" id="kobo.1225.1">Delete</span></strong><span class="kobospan" id="kobo.1226.1"> and enter an </span><code class="inlinecode"><span class="kobospan" id="kobo.1227.1">ID</span></code><span class="kobospan" id="kobo.1228.1">. </span><span class="kobospan" id="kobo.1228.2">The request will contain a token, but </span><code class="inlinecode"><span class="kobospan" id="kobo.1229.1">bob</span></code><span class="kobospan" id="kobo.1230.1"> hasn’t been assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1231.1">Admins</span></code><span class="kobospan" id="kobo.1232.1"> role, so the server will respond with a </span><code class="inlinecode"><span class="kobospan" id="kobo.1233.1">403</span></code><span class="kobospan" id="kobo.1234.1"> status code:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1235.1">...
</span><span class="kobospan" id="kobo.1235.2">? </span><span class="kobospan" id="kobo.1235.3">Select an operation Delete
? </span><span class="kobospan" id="kobo.1235.4">ID? </span><span class="kobospan" id="kobo.1235.5">1
403 Forbidden
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1236.1">Sign in as </span><code class="inlinecode"><span class="kobospan" id="kobo.1237.1">alice</span></code><span class="kobospan" id="kobo.1238.1"> and </span><a id="_idIndexMarker835" class="calibre3"/><span class="kobospan" id="kobo.1239.1">repeat the </span><code class="inlinecode"><span class="kobospan" id="kobo.1240.1">Delete</span></code><span class="kobospan" id="kobo.1241.1"> request, which will succeed because </span><code class="inlinecode"><span class="kobospan" id="kobo.1242.1">alice</span></code><span class="kobospan" id="kobo.1243.1"> has been assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1244.1">Admins</span></code><span class="kobospan" id="kobo.1245.1"> role:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1246.1">...
</span><span class="kobospan" id="kobo.1246.2">? </span><span class="kobospan" id="kobo.1246.3">Username? </span><span class="kobospan" id="kobo.1246.4">alice
? </span><span class="kobospan" id="kobo.1246.5">Password? </span><span class="kobospan" id="kobo.1246.6">mysecret
{"success":true,"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFsaWNlIiwiaWF0IjoxNzA2NDY1NzM2LCJleHAiOjE3MDY0NjkzMzZ9.GWEZl6qypJpdX-csNifgIRjZksZTxc-Nf35uVnTq4Ss"}
? </span><span class="kobospan" id="kobo.1246.7">Select an operation Delete
? </span><span class="kobospan" id="kobo.1246.8">ID? </span><span class="kobospan" id="kobo.1246.9">1
true
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1247.1">The authorization process for the web service is based on the same user data as for HTML clients, but returning a status code gives API clients a response that can be handled programmatically.</span></p>
<h1 class="heading" id="_idParaDest-273"><span class="kobospan" id="kobo.1248.1">Using packages for authentication and authorization</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1249.1">Now that you understand how authentication and authorization work together in a web application, it is time to replace some of the custom code with open-source packages.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1250.1">There are two good reasons to use open-source packages for authentication in particular. </span><span class="kobospan" id="kobo.1250.2">The first reason is that it is easy to make a mistake when writing custom code that creates a security vulnerability. </span><span class="kobospan" id="kobo.1250.3">The second reason is that a good authentication package will support a range of different authentication strategies, including authentication with third-party services, such as Google and Facebook. </span></p>
<p class="normal"><span class="kobospan" id="kobo.1251.1">In </span><em class="italic"><span class="kobospan" id="kobo.1252.1">Part 3</span></em><span class="kobospan" id="kobo.1253.1"> of this book, I demonstrate a different authentication strategy, but for this chapter, I am going to use open-source packages but still use usernames and passwords for authentication.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1254.1">Not all features can be replaced with custom code. </span><span class="kobospan" id="kobo.1254.2">The focus tends to be on authentication, while authorization is left to individual applications to implement.</span></p>
<h2 class="heading1" id="_idParaDest-274"><span class="kobospan" id="kobo.1255.1">Authenticating HTML clients</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1256.1">I am going to use the </span><a id="_idIndexMarker836" class="calibre3"/><span class="kobospan" id="kobo.1257.1">Passport package (</span><a href="https://www.passportjs.org" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.1258.1">https://www.passportjs.org</span></span></a><span class="kobospan" id="kobo.1259.1">) to provide authentication. </span><span class="kobospan" id="kobo.1259.2">Passport supports a wide range of authentication </span><a id="_idIndexMarker837" class="calibre3"/><span class="kobospan" id="kobo.1260.1">strategies, including support for using third-party authentication services, and provides an API to implement custom strategies. </span><span class="kobospan" id="kobo.1260.2">In this chapter, I use the </span><code class="inlinecode"><span class="kobospan" id="kobo.1261.1">Local</span></code><span class="kobospan" id="kobo.1262.1"> strategy, which provides support to authenticate users with locally stored username and password data and uses sessions to authenticate subsequent requests. </span><span class="kobospan" id="kobo.1262.2">I also use the </span><strong class="screentext"><span class="kobospan" id="kobo.1263.1">JWT</span></strong><span class="kobospan" id="kobo.1264.1"> strategy, which uses bearer tokens to authenticate requests. </span><span class="kobospan" id="kobo.1264.2">Run the commands shown in </span><em class="italic"><span class="kobospan" id="kobo.1265.1">Listing 15.26</span></em><span class="kobospan" id="kobo.1266.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1267.1">part2app</span></code><span class="kobospan" id="kobo.1268.1"> folder to install the main passport package, the packages that contain the strategies, and type descriptions for all of them:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1269.1">Listing 15.26: Installing packages</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1270.1">npm install passport@0.7.0
npm install passport-local@1.0.0
npm install passport-jwt@4.0.1
npm install --save-dev @types/passport@1.0.16
npm install --save-dev @types/passport-local@1.0.38
npm install --save-dev @types/passport-jwt@4.0.1
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1271.1">Passport</span><a id="_idIndexMarker838" class="calibre3"/><span class="kobospan" id="kobo.1272.1"> requires configuration so that it can be integrated into the </span><a id="_idIndexMarker839" class="calibre3"/><span class="kobospan" id="kobo.1273.1">application. </span><span class="kobospan" id="kobo.1273.2">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.1274.1">passport_config.ts</span></code><span class="kobospan" id="kobo.1275.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1276.1">src/server/auth</span></code><span class="kobospan" id="kobo.1277.1"> folder, with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.1278.1">Listing 15.27</span></em><span class="kobospan" id="kobo.1279.1">:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1280.1">Listing 15.27: The contents of the passport_config.ts file in the src/server/auth folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1281.1">import passport from "passport";
import { Strategy as LocalStrategy }  from "passport-local";
import { Strategy as JwtStrategy, ExtractJwt  } from "passport-jwt";
import { AuthStore } from "./auth_types";
type Config = {
    jwt_secret: string,
    store: AuthStore
}
export const configurePassport = (config: Config) =&gt; {
    passport.use(new LocalStrategy(async (username, password, callback) =&gt; {
        if (await config.store.validateCredentials(username, password)) {
            return callback(null, { username });
        }
        return callback(null, false);
    }));
    passport.use(new JwtStrategy({
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
        secretOrKey: config.jwt_secret
    }, (payload, callback) =&gt; {
        return callback(null, { username: payload.username });
    }));
    passport.serializeUser((user, callback) =&gt; {
        callback(null, user);
    });
    passport.deserializeUser((user, callback) =&gt; {
        callback(null, user as Express.User );
    });   
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1282.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1283.1">passport.use</span></code><span class="kobospan" id="kobo.1284.1"> function is used to set up strategies, and in </span><em class="italic"><span class="kobospan" id="kobo.1285.1">Listing 15.27</span></em><span class="kobospan" id="kobo.1286.1">, the local and JWT strategies are applied. </span><span class="kobospan" id="kobo.1286.2">These strategies require a verification function, which receives the request data and returns an object representing the user.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1287.1">The verification </span><a id="_idIndexMarker840" class="calibre3"/><span class="kobospan" id="kobo.1288.1">function for the local strategy receives the username and password sent by the user, which is validated using the stored credentials. </span><span class="kobospan" id="kobo.1288.2">The outcome is </span><a id="_idIndexMarker841" class="calibre3"/><span class="kobospan" id="kobo.1289.1">provided to Passport with a callback, which either provides an object that represents the user or </span><code class="inlinecode"><span class="kobospan" id="kobo.1290.1">false</span></code><span class="kobospan" id="kobo.1291.1"> if verification fails:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1292.1">...
</span><span class="kobospan" id="kobo.1292.2">if (await config.store.validateCredentials(username, password)) {
   </span><strong class="screentext"><span class="kobospan" id="kobo.1293.1"> return callback(null, { username });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1294.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1295.1">return callback(null, false);</span></strong><span class="kobospan" id="kobo.1296.1">
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1297.1">The verification function will only be called when the user signs in, after which Passport uses a temporary token to authenticate subsequent requests. </span><span class="kobospan" id="kobo.1297.2">One option is to use session cookies to store the user data, which is the same approach used by the custom code.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1298.1">The verification for the JWT strategy is different. </span><span class="kobospan" id="kobo.1298.2">Passport doesn’t generate JWT tokens, and the verification function is called when a bearer token is received. </span><span class="kobospan" id="kobo.1298.3">The strategy is configured with an object that tells Passport how to locate the bearer token in the request and provides the key to check the token signature. </span><span class="kobospan" id="kobo.1298.4">The verification function receives the payload from the token and is responsible for providing an object that represents the authenticated user.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1299.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1300.1">serializeUser</span></code><span class="kobospan" id="kobo.1301.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1302.1">deserializeUser</span></code><span class="kobospan" id="kobo.1303.1"> functions are used by Passport to include user information in the session. </span><span class="kobospan" id="kobo.1303.2">These functions must be defined even when, as in this case, user</span><a id="_idIndexMarker842" class="calibre3"/><span class="kobospan" id="kobo.1304.1"> data is just an object containing a </span><a id="_idIndexMarker843" class="calibre3"/><span class="kobospan" id="kobo.1305.1">username. </span><em class="italic"><span class="kobospan" id="kobo.1306.1">Listing 15.28</span></em><span class="kobospan" id="kobo.1307.1"> uses Passport to authenticate requests:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1308.1">Listing 15.28: Using Passport in the index.ts File in the src/server/auth Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1309.1">import { Express, NextFunction, RequestHandler } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
import jwt from "jsonwebtoken";
import { HookContext } from "@feathersjs/feathers";
</span><strong class="screentext"><span class="kobospan" id="kobo.1310.1">import passport </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1311.1">from "passport";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1312.1">import { configurePassport } from "./passport_config";</span></strong><span class="kobospan" id="kobo.1313.1">
const jwt_secret = "mytokensecret";
const store: AuthStore = new OrmAuthStore();
</span><strong class="screentext"><span class="kobospan" id="kobo.1314.1">//type User = { username: string }</span></strong><span class="kobospan" id="kobo.1315.1">
declare module "express-session" {
    interface SessionData { username: string; }
}
declare global {
    module Express {
       </span><strong class="screentext"><span class="kobospan" id="kobo.1316.1"> //interface Request { user: User, authenticated: boolean }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1317.1">        interface Request { authenticated: boolean }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1318.1">        interface User {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1319.1">            username: string</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1320.1">        }</span></strong><span class="kobospan" id="kobo.1321.1">
    }
}
export const createAuth = (app: Express) =&gt; {
    configurePassport({ store, jwt_secret });
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            </span><strong class="screentext"><span class="kobospan" id="kobo.1322.1">// username: req.query["username"],</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1323.1">            // password: req.query["password"],</span></strong><span class="kobospan" id="kobo.1324.1">
            failed: req.query["failed"] ? </span><span class="kobospan" id="kobo.1324.2">true : false,
            signinpage: true
        }
        resp.render("signin", data);
    });
   </span><strong class="screentext"><span class="kobospan" id="kobo.1325.1"> app.post</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1326.1">("/signin", passport.authenticate("local", {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1327.1">        failureRedirect: `/signin?failed=1`,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1328.1">        successRedirect: "/"</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1329.1">    }));</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1330.1">    app.use(passport.authenticate</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1331.1">("session"), (req, resp, next) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1332.1">        resp.locals.user = req.user;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1333.1">        resp.locals.authenticated</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1334.1">            = req.authenticated = req.user</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1335.1"> !== undefined;           </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1336.1">        next();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1337.1">    });</span></strong><span class="kobospan" id="kobo.1338.1">
    app.post("/api/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const result: any = {
            success: await store.validateCredentials(username, password)
        }
        if (result.success) {
            result.token = jwt.sign({username} , jwt_secret,
                { expiresIn: "1hr"});
        }
        resp.json(result);
        resp.end();   
    });
    app.post("/signout", async (req, resp) =&gt; {
        req.session.destroy(() =&gt; {
            resp.redirect("/");
        })
    });
    app.get("/unauthorized", async (req, resp) =&gt; {
        resp.render("unauthorized");
    });
}
export const roleGuard = (role: string)
        : RequestHandler&lt;Request, Response, NextFunction&gt; =&gt; {
    return async (req, resp, next) =&gt; {
        if (req.authenticated) {
           </span><strong class="screentext"><span class="kobospan" id="kobo.1339.1"> const username = req.user</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1340.1">?.username;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1341.1">            if (username != undefined</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1342.1">                    &amp;&amp; await store.validateMembership(username, role)) {</span></strong><span class="kobospan" id="kobo.1343.1">
                next();
                return;
            }
            resp.redirect("/unauthorized");
        } else {
            resp.redirect("/signin");
        }
    }
}
export const roleHook = (role: string) =&gt; {
    return async (ctx: HookContext) =&gt; {
        if (!ctx.params.authenticated) {
            ctx.http = { status: 401 };
            ctx.result = {};
        } else if (!(await store.validateMembership(
                ctx.params.user.username, role))) {
            ctx.http = { status: 403 };
            ctx.result = {};
        }
    }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1344.1">Passport </span><a id="_idIndexMarker844" class="calibre3"/><span class="kobospan" id="kobo.1345.1">provides its own additions to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1346.1">Express</span></code> <code class="inlinecode"><span class="kobospan" id="kobo.1347.1">Request</span></code><span class="kobospan" id="kobo.1348.1"> object, so adjustments are required to prevent conflicts. </span><span class="kobospan" id="kobo.1348.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1349.1">Passport</span></code> <code class="inlinecode"><span class="kobospan" id="kobo.1350.1">authenticate</span></code><span class="kobospan" id="kobo.1351.1"> function is used twice. </span><span class="kobospan" id="kobo.1351.2">When used with a route, the </span><code class="inlinecode"><span class="kobospan" id="kobo.1352.1">authenticate</span></code><code class="inlinecode"><a id="_idIndexMarker845" class="calibre3"/></code><span class="kobospan" id="kobo.1353.1"> method is used to create a request handler that will validate credentials using the local strategy: </span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1354.1">...
</span><span class="kobospan" id="kobo.1354.2">app.post("/signin", passport.</span><strong class="screentext"><span class="kobospan" id="kobo.1355.1">authenticate</span></strong><span class="kobospan" id="kobo.1356.1">("local", {
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1357.1">The configuration options tell Passport where to redirect the browser for successful and failed sign-in attempts. </span><span class="kobospan" id="kobo.1357.2">Passport doesn’t include the username and password in redirections for failed sign-in attempts, which is why the values are no longer included when the sign-in template is rendered.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1358.1">The other use of the </span><code class="inlinecode"><span class="kobospan" id="kobo.1359.1">authenticate</span></code><span class="kobospan" id="kobo.1360.1"> function is to authenticate requests, and the argument specifies that the session is the source of authentication data:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1361.1">...
</span><span class="kobospan" id="kobo.1361.2">app.use(passport.</span><strong class="screentext"><span class="kobospan" id="kobo.1362.1">authenticate</span></strong><span class="kobospan" id="kobo.1363.1">("session"), (req, resp, next) =&gt; {
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1364.1">Passport doesn’t have an </span><code class="inlinecode"><span class="kobospan" id="kobo.1365.1">authenticate</span></code><span class="kobospan" id="kobo.1366.1"> property, but a follow-on handler function allows the property to be set, along with the local data required for templates.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1367.1">As noted, Passport doesn’t create JWT tokens, so the code that authenticates API clients remains unchanged. </span><span class="kobospan" id="kobo.1367.2">Passport does </span><em class="italic"><span class="kobospan" id="kobo.1368.1">validate</span></em><span class="kobospan" id="kobo.1369.1"> JWT tokens, however, which is why the code that read and validated the bearer token was removed in </span><em class="italic"><span class="kobospan" id="kobo.1370.1">Listing 15.28</span></em><span class="kobospan" id="kobo.1371.1">. </span><em class="italic"><span class="kobospan" id="kobo.1372.1">Listing 15.29</span></em><span class="kobospan" id="kobo.1373.1"> uses Passport to authenticate bearer tokens for web service requests:</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1374.1">Listing 15.29: Using Passport in the index.ts file in the src/server/api folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1375.1">import { Express } from "express";
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
import { Validator } from "./validation_adapter";
import { ResultWebServiceValidation } from "./results_api_validation";
import { FeathersWrapper } from "./feathers_adapter";
import { feathers } from "@feathersjs/feathers";
import feathersExpress, { rest } from "@feathersjs/express";
import { ValidationError } from "./validation_types";
import { roleHook } from "../auth";
</span><strong class="screentext"><span class="kobospan" id="kobo.1376.1">import passport from "passport";</span></strong><span class="kobospan" id="kobo.1377.1">
export const createApi = (app: Express) =&gt; {
    const feathersApp = feathersExpress(feathers(), app).configure(rest());
    const service = new Validator(new ResultWebService(),
        ResultWebServiceValidation);
    </span><strong class="screentext"><span class="kobospan" id="kobo.1378.1">feathersApp.use('/api/results',</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1379.1">        passport.authenticate("jwt", { session: false</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1380.1"> }),</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1381.1">        (req, resp, next) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1382.1">            req.feathers.user = req.user;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1383.1">            req.feathers.authenticated</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1384.1">                = req.authenticated = req.user !== undefined</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1385.1">;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1386.1">            next();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1387.1">        },</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1388.1">        new FeathersWrapper(service));</span></strong><span class="kobospan" id="kobo.1389.1">
    feathersApp.hooks({
        error: {
            all: [(ctx) =&gt; {                       
                    if (ctx.error instanceof ValidationError) {
                        ctx.http = { status: 400};
                        ctx.error = undefined;
                    }
                }]
        },
        before: {
            create: [roleHook("Users")],
            remove: [roleHook("Admins")],
            update: [roleHook("Admins")],
            patch: [roleHook("Admins")]
        }       
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1390.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1391.1">authenticate</span></code><span class="kobospan" id="kobo.1392.1"> function</span><a id="_idIndexMarker846" class="calibre3"/><span class="kobospan" id="kobo.1393.1"> is used to create a request handler that will validate tokens, using the JWT strategy. </span><span class="kobospan" id="kobo.1393.2">A follow-on function is used to set the values used by the Feathers hook so that authorization</span><a id="_idIndexMarker847" class="calibre3"/><span class="kobospan" id="kobo.1394.1"> checks can be performed.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.1395.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.1396.1">Feathers has its own</span><a id="_idIndexMarker848" class="calibre3"/><span class="kobospan" id="kobo.1397.1"> authentication and authorization features, which are useful if you are creating a stand-alone API project, and they are described at </span><a href="https://feathersjs.com/api/authentication" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.1398.1">https://feathersjs.com/api/authentication</span></span></a><span class="kobospan" id="kobo.1399.1">. </span><span class="kobospan" id="kobo.1399.2">Mixing authentication features from multiple packages can be difficult, which is why I have used Passport for all authentication in the examples, even though some features, like JWT creation, are not available.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.1400.1">The use of the Passport package doesn’t alter the way authentication works, and users sign into the application in the same way. </span><span class="kobospan" id="kobo.1400.2">The difference is the reduction in custom code and support for a wider range of authentication strategies, which can make it easier to integrate an application into an existing environment or to use third-party authentication services.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1401.1">Custom code is still required to perform role-based authorization, which is why it is important to understand how users and requests are authenticated, and how the results can be used to restrict access to application features.</span></p>
<h1 class="heading" id="_idParaDest-275"><span class="kobospan" id="kobo.1402.1">Summary</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1403.1">In this chapter, I demonstrated how users and requests can be authenticated, and how authentication data can be used to authorize access to application features:</span></p>
<ul class="calibre4">
<li class="bulletlist"><span class="kobospan" id="kobo.1404.1">Users present their credentials, whether using an HTML form or a JSON payload.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1405.1">When credentials are validated, the client is sent a temporary token that can be used to authenticate subsequent requests.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1406.1">The temporary authentication token can be a cookie (and a session cookie is often used) or a bearer token.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1407.1">Authorization is usually performed through roles, which prevents you having to hardcode user permissions into the application. </span><span class="kobospan" id="kobo.1407.2">The relationship between users and roles is stored in a database, so it can be altered without releasing a new version of the application.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1408.1">There are good open-source packages available for user and request authentication, but authorization is typically done using custom code.</span></li>
</ul>
<p class="normal"><span class="kobospan" id="kobo.1409.1">In </span><em class="italic"><span class="kobospan" id="kobo.1410.1">Part 3</span></em><span class="kobospan" id="kobo.1411.1">, I use the features described in </span><em class="italic"><span class="kobospan" id="kobo.1412.1">Parts 1</span></em><span class="kobospan" id="kobo.1413.1"> and </span><em class="italic"><span class="kobospan" id="kobo.1414.1">2</span></em><span class="kobospan" id="kobo.1415.1"> of this book to create an online store that shows how the different parts of an application work together.</span></p>
</div>
</body></html>