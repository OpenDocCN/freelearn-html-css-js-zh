<html><head></head><body>
<div><h1 class="chapternumber">15</h1>
<h1 class="chaptertitle" id="_idParaDest-258">Authenticating and Authorizing Requests</h1>
<p class="normal1">Most projects need to restrict access to features; otherwise, anyone who knows an application’s URL can execute any operation. This is currently how the example application is set up: anyone who can request <code class="inlinecode">http://localhost:5000</code> will be able to store and delete data, regardless of who they are.</p>
<p class="normal"><em class="italic">Authorization</em>, often <a id="_idIndexMarker773" class="calibre3"/>referred to as <em class="italic">AuthZ</em>, is the process of restricting access so that operations can only be performed by some users – known, naturally enough, as <em class="italic">authorized users</em>. <em class="italic">Authentication</em>, often referred to as <em class="italic">AuthN</em>, is the process of a user <a id="_idIndexMarker774" class="calibre3"/>identifying themselves so that the application can determine whether the user is authorized for the operations they request. This chapter explains how Node.js applications can apply authentication and authorization, building on the features described in earlier chapters. <em class="italic">Table 15.1</em> puts this chapter in context.</p>
<p class="packt_figref">Table 15.1: Putting authorization and authentication in context</p>
<table class="table-container" id="table001-12">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">Authentication<a id="_idIndexMarker775" class="calibre3"/> is the process of identifying a user. Authorization<a id="_idIndexMarker776" class="calibre3"/> is the process of restricting access to application features to a subset of users.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Identifying users allows an application to alter its behavior by using data or preferences that are specific to one account. Restricting access to features means that applications can support operations that would otherwise be dangerous or prejudicial to effective service provision.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How is it used?</p>
</td>
<td class="table-cell">
<p class="normal">Users identify themselves by presenting credentials to the application, which produces a temporary token that is included in subsequent requests. The token is used to associate an identity with each request, which can be inspected to authorize access to restricted features.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Thorough testing is required to ensure that authentication and authorization<a id="_idIndexMarker777" class="calibre3"/> work as expected. Many applications will require additional work to support user enrolment and account maintenance.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Not all applications require authentication<a id="_idIndexMarker778" class="calibre3"/> and authorization, but most do. Some of the surrounding features can be delegated to third-party authentication providers, but integration is still required.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 15.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 15.2: Chapter summary</p>
<table class="table-container" id="table002-12">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Authenticate users</p>
</td>
<td class="table-cell">
<p class="normal">Provide a mechanism that allows the user to provide credentials, which can be validated against stored data.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">4-9, 26-28</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Create an authentication token for HTML clients</p>
</td>
<td class="table-cell">
<p class="normal">Include the user’s identity in the session so that the session cookie becomes the authentication token.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">10-12</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Create an authentication token for API clients</p>
</td>
<td class="table-cell">
<p class="normal">Create a bearer token.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">13-16</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Authorize requests </p>
</td>
<td class="table-cell">
<p class="normal">Use the identity associated with a request to determine if the user is entitled to perform the target operation.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">17-25, 29</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-259">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">part2app</code> project from <em class="italic">Chapter 14</em>. The first set of examples in this chapter is for a round-trip application. To prepare, add a file named <code class="inlinecode">data.handlebars</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 15.1</em>:</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 15.1: The contents of the data.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;form class="m-2"&gt;
    &lt;table class="table table-sm table-striped"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;th&gt;Years&lt;/th&gt;
                &lt;th&gt;Next Age&lt;/th&gt;&lt;th&gt;&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            {{#unless data }}&lt;tr&gt;&lt;td colspan="5"&gt;No Data&lt;/td&gt;&lt;/tr&gt;{{/unless }}
            {{#each data }}
                &lt;tr&gt;
                    &lt;td&gt;{{ this.id }} &lt;/td&gt;
                    &lt;td&gt;{{ this.name }} &lt;/td&gt;
                    &lt;td&gt;{{ this.age }} &lt;/td&gt;
                    &lt;td&gt;{{ this.years }} &lt;/td&gt;
                    &lt;td&gt;{{ this.nextage }} &lt;/td&gt;
                    &lt;td&gt;
                        &lt;button class="btn btn-danger btn-sm"
                            formmethod="post"
                            formaction="/form/delete/{{this.id}}"&gt;
                                Delete
                        &lt;/button&gt; 
                    &lt;/td&gt;
                &lt;/tr&gt;               
            {{/each }}
        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;button class="btn btn-primary"
        formmethod="post"
        formaction="/form/add"&gt;
            Add
    &lt;/button&gt;                    
    &lt;input type="hidden" name="name" value="Alice" /&gt;
    &lt;input type="hidden" name="age" value="40" /&gt;
    &lt;input type="hidden" name="years" value="10" /&gt;
&lt;/form&gt;           
</code></pre>
<p class="normal">This template contains a table that displays data, with a form that sends HTTP requests to the server. To handle the HTTP requests, replace the contents of the <code class="inlinecode">forms.ts</code> file in the <code class="inlinecode">src/server</code> folder with the code shown in <em class="italic">Listing 15.2</em>.</p>
<p class="packt_figref">Listing 15.2: The contents of the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
import cookieMiddleware from "cookie-parser";
import { sessionMiddleware } from "./sessions/session_helpers";
import { Result } from "./data/repository";
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
    app.use(cookieMiddleware("mysecret"));
    app.use(sessionMiddleware());
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("data", {data: await repository.getAllResults(rowLimit)});
    });
    app.post("/form/delete/:id", async (req, resp) =&gt; {
        const id = Number.parseInt(req.params["id"]);
        await repository.delete(id);
        resp.redirect("/form");
        resp.end();
    });
       
    app.post("/form/add", async (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body["age"])
            + Number.parseInt(req.body["years"]);
        await repository.saveResult({...req.body, nextage } as Result);
        resp.redirect("/form");
        resp.end();
    });
}
</code></pre>
<p class="normal">The routes defined in <em class="italic">Listing 15.2</em> render the data template, delete an item from the database, and store an item. After data is stored or deleted, the browser is sent a redirection to the <code class="inlinecode">/form</code> URL that will show the user the results of their actions. Run the command shown in <em class="italic">Listing 15.3</em> in the <code class="inlinecode">part2app</code> folder to start the development tools:</p>
<p class="packt_figref">Listing 15.3: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/form</code>, and you will see the content generated by the new template, as shown in <em class="italic">Figure 15.1</em>. Clicking one of the <strong class="screentext">Delete</strong> buttons will remove an item from the database, and clicking the <strong class="screentext">Add</strong> button will store a new item using fixed data values.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_15_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 15.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-260">Understanding the end-to-end process</h1>
<p class="normal1">The topics covered in this chapter are part of a larger process through which a user gains access to the features provided by an application. The process is as follows: </p>
<ol class="calibre6">
<li class="bulletlist1" value="1">Enrolment. The enrolment process<a id="_idIndexMarker779" class="calibre3"/> creates an account for the user, who is given credentials to identify themselves. </li>
<li class="bulletlist1">User Authentication. The user <a id="_idIndexMarker780" class="calibre3"/>presents their credentials when they want to use the application. The authentication process, often called signing in, produces a token that temporarily identifies the user. </li>
<li class="bulletlist1">Request Authentication. When making <a id="_idIndexMarker781" class="calibre3"/>HTTP requests, the client includes the temporary token to identify the user without needing to provide the credentials again. </li>
<li class="bulletlist1">Authorization. The<a id="_idIndexMarker782" class="calibre3"/> token included in the request is used to determine whether the user can access the feature specified by the request. </li>
</ol>
<p class="normal">This chapter covers the authentication and authorization parts of the process. The details of the enrolment process are not described because they depend on the type of application. For corporate applications, enrolment will usually happen when a new employee joins the company and, for larger companies, will be done by the HR department through a central employee directory. For consumer-facing applications, enrolment is often linked to payment and is done before the user receives access to the application (for services, such as Spotify) or after they have made a product selection (for goods, such as Amazon). In both cases, the user enrolls themselves.</p>
<p class="normal">Applications that require users to enroll themselves usually provide account maintenance tools, which allow users to change their credentials, update personal information, and close their accounts. In some parts of the world, users are legally entitled to receive a copy of all of the data held about them, and this is often part of the account management process.</p>
<h1 class="heading" id="_idParaDest-261">Authenticating users</h1>
<p class="normal1">The authentication process <a id="_idIndexMarker783" class="calibre3"/>requires the user to present their credentials to identify themselves to the application. The standard credentials are a username and password. The password is known only to the user, which means they can prove they are the user who owns the account by submitting the correct password.</p>
<p class="normal">Of course, passwords can be stolen or shared, and so a common approach is to require additional proof of identity. The conventional approach is to combine a password with a physical token, which can be a dedicated hardware device or an authenticator app running on a phone. The device provides a time-limited code that proves the user has the device.</p>
<p class="normal">To work through the details of how users are authenticated, I am going to add support for usernames and passwords to the example application. Later in the chapter, I’ll introduce an open-source package that supports a wider range of credentials, but simple passwords are enough to explain how the overall authentication and authorization processes work. <em class="italic">Part 3</em> of this book demonstrates the use of a <a id="_idIndexMarker784" class="calibre3"/>third-party authentication service.</p>
<h2 class="heading1" id="_idParaDest-262">Creating a credential store</h2>
<p class="normal1">To authenticate <a id="_idIndexMarker785" class="calibre3"/>users, an application needs to have a store of credentials against which requests can be validated. Create the <code class="inlinecode">src/server/auth</code> folder and add to it a file named <code class="inlinecode">auth_types.ts</code>, with the content shown in <em class="italic">Listing 15.4</em>:</p>
<p class="packt_figref">Listing 15.4: The contents of the auth_types.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">export interface Credentials {
    username: string;
    hashedPassword: Buffer;
    salt: Buffer;
}
export interface AuthStore {
    getUser(name: string) : Promise&lt;Credentials | null&gt;;
    storeOrUpdateUser(username: string, password: string):
        Promise&lt;Credentials&gt;;
    validateCredentials(username: string, password: string): Promise&lt;boolean&gt;
}
</code></pre>
<p class="normal">The <code class="inlinecode">Credentials</code> interface describes a user’s credentials as they are stored for validation. It is poor practice to store passwords in plain text, and the conventional approach is to create a one-way hash code and store that instead. To validate credentials, the password provided by the user is put through the same hashing algorithm and compared with the stored value. Hash algorithms always produce the same result, which means the credential store will contain the same hash code for all users who pick the same password. If the password for one of those accounts is obtained, then anyone who can see the credential store will be able to figure out which other accounts can be accessed. </p>
<p class="normal">To avoid this problem, a random <em class="italic">salt</em> value is added to the password so that users can have the same password without causing duplicate hash codes in the credential store. The salt value must be stored alongside the password so that credentials can be validated. The hash code and the salt are <code class="inlinecode">Buffer</code> values, which is the type that Node.js uses to represent byte arrays. The <code class="inlinecode">AuthStore</code> interface defines the methods that will be used to retrieve and store credentials. </p>
<p class="normal">Add a file<a id="_idIndexMarker786" class="calibre3"/> named <code class="inlinecode">orm_auth_models.ts</code> to the <code class="inlinecode">src/server/auth</code> folder with the contents shown in <em class="italic">Listing 15.5</em>, which defines the data model for credentials using the <em class="italic">Sequelize ORM package</em> introduced in <em class="italic">Chapter 12</em>:</p>
<p class="packt_figref">Listing 15.5: The contents of the orm_auth_models.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, InferAttributes, InferCreationAttributes, Model,
    Sequelize } from "sequelize";
import { Credentials } from "./auth_types";
export class CredentialsModel
        extends Model&lt;InferAttributes&lt;CredentialsModel&gt;,
            InferCreationAttributes&lt;CredentialsModel&gt;&gt;
        implements Credentials {
    declare username: string;
    declare hashedPassword: Buffer;
    declare salt: Buffer;
}
export const initializeAuthModels = (sequelize: Sequelize) =&gt; {
    CredentialsModel.init({
        username: { type: DataTypes.STRING, primaryKey: true },
        hashedPassword: { type: DataTypes.BLOB },
        salt: { type: DataTypes.BLOB }
    }, { sequelize });
}
</code></pre>
<p class="normal">The <code class="inlinecode">CredentialsModel</code> class extends the Sequelize <code class="inlinecode">Model</code> class and implements the <code class="inlinecode">Credentials</code> interface, which allows <code class="inlinecode">CredentialsModel</code> objects to be stored in the database and used as a method result with the <code class="inlinecode">AuthStore</code> interface. The <code class="inlinecode">initializeAuthModels</code> function receives a <code class="inlinecode">Sequelize</code> object and initializes the <code class="inlinecode">CredentialsModel</code> for database storage, identifying the <code class="inlinecode">username</code> property as the primary key and telling <code class="inlinecode">Sequelize</code> to represent values, using the SQL <code class="inlinecode">STRING</code> data type for the username property and the <code class="inlinecode">BLOB</code> type for the hash code and salt values (the <code class="inlinecode">BLOB</code> type allows data to be stored as strings or buffers). </p>
<p class="normal">To create a<a id="_idIndexMarker787" class="calibre3"/> Sequelize implementation of the <code class="inlinecode">AuthStore</code> interface, add a file named <code class="inlinecode">orm_authstore.ts</code> to the <code class="inlinecode">src/server/auth</code> folder with the contents shown in <em class="italic">Listing 15.6</em>.</p>
<p class="packt_figref">Listing 15.6: The contents of the orm_authstore.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import { Sequelize } from "sequelize";
import { CredentialsModel, initializeAuthModels }
    from "./orm_auth_models";
import { AuthStore } from "./auth_types"
import { pbkdf2, randomBytes, timingSafeEqual } from "crypto";
export class OrmAuthStore implements AuthStore {
    sequelize: Sequelize;
    constructor() {
        this.sequelize = new Sequelize({
            dialect: "sqlite",
            storage: "orm_auth.db",
            logging: console.log,
            logQueryParameters: true
        });
        this.initModelAndDatabase();
    }
    async initModelAndDatabase() : Promise&lt;void&gt; {
        initializeAuthModels(this.sequelize);
        await this.sequelize.drop();       
        await this.sequelize.sync();       
        await this.storeOrUpdateUser("alice", "mysecret");
        await this.storeOrUpdateUser("bob", "mysecret");       
    }
    async getUser(name: string) {
        return await CredentialsModel.findByPk(name);
    }
    async storeOrUpdateUser(username: string, password: string) {
        const salt = randomBytes(16);
        const hashedPassword = await this.createHashCode(password, salt);
        const [model] = await CredentialsModel.upsert({
            username, hashedPassword, salt
        });
        return model;
    }
    async validateCredentials(username: string, password: string):
            Promise&lt;boolean&gt; {
        const storedCreds = await this.getUser(username);
        if (storedCreds) {
            const candidateHash =
                await this.createHashCode(password, storedCreds.salt);
            return timingSafeEqual(candidateHash, storedCreds.hashedPassword);
        }
        return false;
    }
    private createHashCode(password: string, salt: Buffer) : Promise&lt;Buffer&gt; {
        return new Promise((resolve, reject) =&gt; {
            pbkdf2(password, salt, 100000, 64, "sha512", (err, hash) =&gt; {
                if (err) {
                    reject(err)
                };
                resolve(hash);
            })      
        })
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">OrmAuthStore</code> class implements the <code class="inlinecode">AuthStore</code> interface using the Sequelize features<a id="_idIndexMarker788" class="calibre3"/> presented by the <code class="inlinecode">CredentialsModel</code> class. The <code class="inlinecode">getUser</code> method is implemented using the <code class="inlinecode">findByPk</code> method, which queries the database using a primary key value. The <code class="inlinecode">storeOrUpdateUser</code> method is implemented using the <code class="inlinecode">upsert</code> method, which updates an existing value if there is one and otherwise creates a new value. The data will be stored in an SQLite database file named <code class="inlinecode">orm_auth.db</code>.</p>
<p class="normal">The <code class="inlinecode">createHashCode</code> method accepts a password and a salt value and creates a new hash code, using the <code class="inlinecode">pbkdf2</code> function from the Node.js <code class="inlinecode">crypto</code> module. This function is an implementation of a <strong class="screentext">Password-Based Key Derivation Function</strong> (<strong class="screentext">PBKDF</strong>), which is a<a id="_idIndexMarker789" class="calibre3"/> function that is well-suited to<a id="_idIndexMarker790" class="calibre3"/> create hash codes from passwords (see <a href="https://en.wikipedia.org/wiki/PBKDF2" class="calibre3">https://en.wikipedia.org/wiki/PBKDF2</a> for details). The arguments to the <code class="inlinecode">pbkdf2</code> function are the password to be hashed, the salt value, the number of iterations used to generate the hash code, the length of the hash code, and the algorithm that will be used to generate the hash code. </p>
<p class="normal"><em class="italic">Listing 15.6</em> uses the values described in the Node.js API (<a href="https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback" class="calibre3">https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback</a>). The <code class="inlinecode">pbkdf2</code> function uses a callback, which is wrapped in a Promise to make it easier to work with the <code class="inlinecode">Sequelize</code> API.</p>
<p class="normal">The <code class="inlinecode">validateCredentials</code> method uses the <code class="inlinecode">getUser</code> method to retrieve the stored credentials and uses the stored salt value to compute a new hash code with the candidate password, which is then compared to the stored hash code, using the <code class="inlinecode">timingSafeEqual</code> function in the Node.js <code class="inlinecode">crypto</code> module. This function is used to compare hash codes securely, as described in the API documentation <code class="inlinecode">(</code><a href="https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b" class="calibre3">https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b</a>). </p>
<p class="normal">The <a id="_idIndexMarker791" class="calibre3"/>database is seeded with two sets of credentials, matching those described in <em class="italic">Table 15.3</em>. Credentials are usually created as part of an enrolment process, as described earlier in the chapter, but test credentials are enough for this chapter. See <em class="italic">Part 3</em> for an example of an enrolment process typical of an online store. As with examples in earlier chapters, the database is reset each time the application is started.</p>
<p class="packt_figref">Table 15.3: The test credentials added to the database</p>
<table class="table-container" id="table003-12">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Password</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">alice</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">mysecret</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">bob</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">mysecret</code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2 class="heading1" id="_idParaDest-263">Creating the authentication workflow</h2>
<p class="normal1">The next<a id="_idIndexMarker792" class="calibre3"/> step is to create a workflow that allows a user to sign in and out of the application. Add a file named <code class="inlinecode">signin.handlebars</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 15.7</em>:</p>
<p class="packt_figref">Listing 15.7: The contents of the signin.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">{{#if failed }}
    &lt;h4 class="bg-danger text-white p-2 text-center"&gt;
        Authentication failed. Please try again.
    &lt;/h4&gt;
{{/if}}
&lt;form method="post"&gt;
    &lt;div class="m-2"&gt;
        &lt;label class="form-label"&gt;Name&lt;/label&gt;
        &lt;input name="username" class="form-control" value="{{ username }}"/&gt;
    &lt;/div&gt;
    &lt;div class="m-2"&gt;
        &lt;label class="form-label"&gt;Password&lt;/label&gt;
        &lt;input name="password" type="password" class="form-control"
            value="{{ password }}"/&gt;
    &lt;/div&gt;   
    &lt;button type="submit" class="btn btn-primary mx-2"&gt;Sign In&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p class="normal">The <a id="_idIndexMarker793" class="calibre3"/>template contains a form to send a username and password to the application, along with an error message that is hidden by default but which will be displayed if the user provides invalid credentials.</p>
<p class="normal">The next step is to create the Express routes that will present the user with the contents of the <code class="inlinecode">signin</code> template and validate credentials when they are submitted. Add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/server/auth</code> folder with the content shown in <em class="italic">Listing 15.8</em>:</p>
<p class="packt_figref">Listing 15.8: The contents of the index.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
const store: AuthStore = new OrmAuthStore();
export const createAuth = (app: Express) =&gt; {
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            username: req.query["username"],
            password: req.query["password"],
            failed: req.query["failed"] ? true : false
        }
        resp.render("signin", data);
    });
    app.post("/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const valid = await store.validateCredentials(username, password);
        if (valid) {
            resp.redirect("/");
        } else {
            resp.redirect(
                `/signin?username=${username}&amp;password=${password}&amp;failed=1`);
        }
    });
}
</code></pre>
<p class="normal">This file<a id="_idIndexMarker794" class="calibre3"/> exports a function named <code class="inlinecode">createAuth</code>, which sets up authentication for the application. The contents of the <code class="inlinecode">signin</code> template are rendered when a GET request is sent to <code class="inlinecode">/signin</code>. When a POST request is sent to <code class="inlinecode">/signin</code>, the credentials it contains are validated. A redirection is used to send the user back to the application if the credentials are valid.</p>
<p class="normal">A redirection is also sent when credentials fail validation but, this time, to the same URL. This is a pattern known as <code class="inlinecode">Post/Redirect/Get</code>, and it ensures that the user can reload the browser without triggering another sign-in attempt. This pattern can be used in any form, but it is particularly useful for authentication, where repeated failed attempts are often counted and can lead to an account being logged out. The URL query string is used to include the credentials provided by the user so they will be displayed by the result of the GET request. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Authentication should always be performed over an encrypted HTTP connection; otherwise, the credentials provided by the user can be exposed to network sniffing. See <em class="italic">Chapter 5</em> for details of setting up HTTPS for a stand-alone Node.js server and see <em class="italic">Part 3</em> for an example that demonstrates how HTTPS is typically set up for more complex Node.js applications. </p>
</div>
<p class="normal"><em class="italic">Listing 15.9</em> calls the <code class="inlinecode">createAuth</code> function as part of the server startup so that the authentication features are part of the request-handling process:</p>
<p class="packt_figref">Listing 15.9: Enabling authentication in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import httpProxy from "http-proxy";
import helmet from "helmet";
import { engine } from "express-handlebars";
import { registerFormMiddleware, registerFormRoutes } from "./forms";
import { createApi } from "./api";
<strong class="screentext">import { createAuth } from "./auth";</strong>
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
expressApp.set("views", "templates/server");
expressApp.engine("handlebars", engine());
expressApp.set("view engine", "handlebars");
expressApp.use(helmet());
expressApp.use(express.json({
    type: ["application/json", "application/json-patch+json"]
}));
registerFormMiddleware(expressApp);
<strong class="screentext">createAuth(expressApp);</strong>
registerFormRoutes(expressApp);
createApi(expressApp);
expressApp.use("^/$", (req, resp) =&gt; resp.redirect("/form"));
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <code class="inlinecode">createAuth</code> method is called after the middleware components required by forms are set up, but before the rest of the application. This allows the authentication request handlers to rely on the features previously described for forms, such as decoding form data and using sessions.</p>
<p class="normal">To test the <a id="_idIndexMarker795" class="calibre3"/>authentication workflow, use a web browser to request <code class="inlinecode">http://localhost:5000/signin</code>, enter <code class="inlinecode">alice</code> and <code class="inlinecode">badpass</code> into the form, and click the <strong class="screentext">Sign In</strong> button. Validation will fail because the wrong password has been provided. Change the password to <code class="inlinecode">mysecret</code> and click the button again. This time, the credentials are validated, and the browser is redirected to the root URL. This sequence is shown in <em class="italic">Figure 15.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_15_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 15.2: The signing-in workflow</p>
<h1 class="heading" id="_idParaDest-264">Authenticating requests</h1>
<p class="normal1">The <a id="_idIndexMarker796" class="calibre3"/>application can validate credentials, but that isn’t much use because there is currently no association between credentials sent to the <code class="inlinecode">/signin</code> URL and any subsequent HTTP requests made by the browser. </p>
<p class="normal">This<a id="_idIndexMarker797" class="calibre3"/> is the purpose of the temporary token that can be presented to the application to prove that the user has been through the credential validation process. Cookies are the most common way to solve this problem, either by creating a separate cookie or by associating authentication data with an existing session cookie, which is the approach I am going to take in this chapter because it is the simplest approach and takes advantage of session features, such as automatic inactivity expiration. <em class="italic">Listing 15.10</em> uses a session to record successful authentication, and it defines middleware that detects the new session data and adds a <code class="inlinecode">user</code> property to the request object:</p>
<p class="packt_figref">Listing 15.10: Completing authentication in the index.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
const store: AuthStore = new OrmAuthStore();
<strong class="screentext">type </strong><strong class="screentext">User = { username: string }</strong>
<strong class="screentext">declare module "express-session" {</strong>
<strong class="screentext">    interface SessionData { username: string; }</strong>
<strong class="screentext">}</strong>
<strong class="screentext">declare global {</strong>
<strong class="screentext">    module </strong><strong class="screentext">Express {</strong>
<strong class="screentext">        interface Request { user: User, authenticated: boolean }</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
export const createAuth = (app: Express) =&gt; {
    <strong class="screentext">app.</strong><strong class="screentext">use((req, resp, next) =&gt; {</strong>
<strong class="screentext">        const username = req.session.username;</strong>
<strong class="screentext">        if (username) {</strong>
<strong class="screentext">            req.authenticated = true;</strong>
<strong class="screentext">            req.user = { username };</strong>
<strong class="screentext">        } </strong><strong class="screentext">else {</strong>
<strong class="screentext">            req.authenticated = false;</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        next();</strong>
<strong class="screentext">    });</strong>
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            username: req.query["username"],
            password: req.query["password"],
            failed: req.query["failed"] ? true : false
        }
        resp.render("signin", data);
    });
    app.post("/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const valid = await store.validateCredentials(username, password);
        if (valid) {
           <strong class="screentext"> req.session.username = username;</strong>
            resp.redirect("/");
        } else {
            resp.redirect(
                `/signin?username=${username}&amp;password=${password}&amp;failed=1`);
        }
    });
    <strong class="screentext">app.post("/signout", async (req, resp) =&gt; {</strong>
<strong class="screentext">        req.session.destroy(() =&gt; {</strong>
<strong class="screentext">            resp.</strong><strong class="screentext">redirect("/");</strong>
<strong class="screentext">        })</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The<a id="_idIndexMarker798" class="calibre3"/> first <code class="inlinecode">declare</code> statement extends the <code class="inlinecode">SessionData</code> interface to define a <code class="inlinecode">username</code> property so that a user’s identity can be associated with a session. It can be tempting to put more complex data in the session, but the purpose of this new property is just to identify the user, which can be done by just adding one <code class="inlinecode">string</code> property to the <code class="inlinecode">SessionData</code> interface. The second <code class="inlinecode">declare</code> statement adds <code class="inlinecode">user</code> and <code class="inlinecode">authenticated</code> properties to the Express <code class="inlinecode">Request</code> interface, which will allow more complex user data to be provided to the rest of the application.</p>
<p class="normal">When <a id="_idIndexMarker799" class="calibre3"/>the user’s credentials are validated, the <code class="inlinecode">username</code> property added to the <code class="inlinecode">SessionData</code> interface is used to store the username:</p>
<pre class="programlisting"><code class="hljs-code">...
req.session.<strong class="screentext">username</strong> = username;
...
</code></pre>
<p class="normal">The new middleware component inspects the session data for requests to check to see if this property has been set. If it has, then the <code class="inlinecode">username</code> and <code class="inlinecode">authenticated</code> properties of the <code class="inlinecode">Request</code> object are set, which is how the rest of the application will be able to identify the authenticated user.</p>
<p class="normal">The final addition is a new route for the <code class="inlinecode">/signout</code> URL, which lets a user sign out of the application by destroying the session, by calling the <code class="inlinecode">destroy</code> method, which is a feature provided by the <code class="inlinecode">express-session</code> package added to the project in <em class="italic">Chapter 13</em>.</p>
<p class="normal">This means that the session cookie has been transformed into the temporary token that authenticates the user’s requests. When the browser includes the session cookie in a request, the application knows that the request has been sent on behalf of the user because the session cookie represents the successful validation of the user’s credentials.</p>
<h2 class="heading1" id="_idParaDest-265">Using the authentication data</h2>
<p class="normal1">To <a id="_idIndexMarker800" class="calibre3"/>complete the authentication feature, the user has to be able to see that they have successfully signed in and allowed to sign out again. Express has a useful feature for working with templates, called <em class="italic">local data</em> or <em class="italic">locals</em>, that allows data to be provided to a template outside of the call to the render method. Local data is specific to a single request/response pair, and any value that is assigned to the <code class="inlinecode">Response.locals</code> property is available for use within any template. This is perfect for <a id="_idIndexMarker801" class="calibre3"/>providing authentication information to templates, which would otherwise have to be added to the context data for every call to the <code class="inlinecode">render</code> method. <em class="italic">Listing 15.11</em> uses this feature to provide templates with authentication information:</p>
<p class="packt_figref">Listing 15.11: Providing authentication details in the index.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">...
app.use((req, resp, next) =&gt; {
    const username = req.session.username;
    if (username) {
        req.authenticated = true;
        req.user = { username };
    } else {
        req.authenticated = false;
    }
    <strong class="screentext">resp.locals.user = req.user;</strong>
<strong class="screentext">    resp.locals.authenticated = req.authenticated;   </strong>
    next();
});
app.get("/signin", (req, resp) =&gt; {
    const data = {
        username: req.query["username"],
        password: req.query["password"],
        failed: req.query["failed"] ? true : false,
       <strong class="screentext"> signinpage: true</strong>
    }
    resp.render("signin", data);
});
...
</code></pre>
<p class="normal">The new statements added to the middleware component create local data values named <code class="inlinecode">user</code> and <code class="inlinecode">authenticated</code>, which means that this information will be available to any template that is executed by a request/response that has been processed by this middleware. There is also a regular context data property named <code class="inlinecode">signinpage</code>, which is passed to the <code class="inlinecode">render</code> method when the sign-in form is presented to the user.</p>
<p class="normal"><em class="italic">Listing 15.12</em> updates<a id="_idIndexMarker802" class="calibre3"/> the layout that is used with all templates, which allows the authentication information to be displayed throughout the application:</p>
<p class="packt_figref">Listing 15.12: Using authentication data in the main.handlebars file in the templates/server/layouts folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;       
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
      <strong class="screentext">  {{#if authenticated }}</strong>
<strong class="screentext">            &lt;div class="bg-primary text-white p-1 clearfix"&gt;</strong>
<strong class="screentext">                &lt;form method="post" action="/signout"&gt;</strong>
<strong class="screentext">                    &lt;span class="h5"&gt;</strong><strong class="screentext">User: {{ user.username }}&lt;/span&gt;</strong>
<strong class="screentext">                    &lt;button class="btn btn-secondary btn-sm float-end"</strong>
<strong class="screentext">                        type="submit"&gt;Sign Out&lt;/button&gt;</strong><strong class="screentext"> </strong>
<strong class="screentext">                &lt;/form&gt;</strong>
<strong class="screentext">            &lt;/div&gt;</strong>
<strong class="screentext">        {{else }}</strong>
<strong class="screentext">            {{#unless signinpage }}</strong>
<strong class="screentext">                &lt;div class="bg-primary text-white p-1 clearfix"&gt;</strong>
<strong class="screentext">                    &lt;a </strong><strong class="screentext">href="/signin"</strong>
<strong class="screentext">                        class="btn btn-secondary btn-sm float-end"&gt;Sign In&lt;/a&gt;</strong>
<strong class="screentext">                &lt;/div&gt;</strong>
<strong class="screentext">            {{/unless }}</strong>
<strong class="screentext">        {{/if}}</strong>
        {{{ body }}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Local data values are used in the same way as regular template context data, and the additions to the template display the user’s name and a sign-out button if the request has been authenticated. If the request isn’t authenticated, then the template displays a sign-in button, unless the <code class="inlinecode">signinpage</code> property is set, in which case no new content is shown.</p>
<p class="normal">To see the<a id="_idIndexMarker803" class="calibre3"/> effect of the changes, use a browser to navigate to <code class="inlinecode">http://localhost:5000/signin</code>, enter <code class="inlinecode">alice</code> and <code class="inlinecode">mysecret</code> into the <code class="inlinecode">Name</code> and <code class="inlinecode">Password</code> fields, respectively, and click the <strong class="screentext">Sign In</strong> button. The credentials will be validated, and the browser will display the username and a <strong class="screentext">Sign Out</strong> button. Click the <strong class="screentext">Sign Out</strong> button, and a <strong class="screentext">Sign In</strong> button will be displayed. This sequence is shown in <em class="italic">Figure 15.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_15_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 15.3: Using authentication data</p>
<h1 class="heading" id="_idParaDest-266">Authenticating web service requests</h1>
<p class="normal1">Applications can’t rely <a id="_idIndexMarker804" class="calibre3"/>on forms to authenticate web services because clients may not be browsers and cannot be relied on to render HTML.</p>
<p class="normal">Web service clients can use cookies – because they are a standard part of HTTP – but session cookies can often cause problems because the session expiry is often set to suit round-trip clients, where every user interaction refreshes the cookie. Web service clients only send requests when they need data, and the frequency of requests can be so low that sessions expire too quickly to be useful. </p>
<p class="normal">Applications can address the lack of HTML support by providing an API to present credentials as JSON data. Instead of a cookie, the authentication API produces a <em class="italic">bearer token</em>, which is a string that can be included in requests, much like a cookie, but with its own lifecycle and without the dependency on sessions. </p>
<p class="normal">The most common form of bearer token is <a id="_idIndexMarker805" class="calibre3"/>the <strong class="screentext">JSON Web Token</strong> (<strong class="screentext">JWT</strong>) standard, which is a self-contained authentication token that doesn’t depend on server-side data. (There is a good overview of JWT at <a href="https://jwt.io" class="calibre3">https://jwt.io</a>, along <a id="_idIndexMarker806" class="calibre3"/>with tools to validate tokens, which can be useful during development).</p>
<p class="normal">As with just <a id="_idIndexMarker807" class="calibre3"/>about every aspect of web services, there are no hard-and-fast standards for how a client performs authentication, but I am going to follow widely used conventions. To sign in, the client will send an <code class="inlinecode">HTTP POST</code> request to the <code class="inlinecode">/api/signin</code> URL, with a JSON payload that includes the user’s credentials, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{
    "username": "alice",
    "password": "mysecret"
}
...
</code></pre>
<p class="normal">The result will contain a JSON object that contains a success property that indicates whether the credentials were accepted and, if they were, a <code class="inlinecode">token</code> property that contains the bearer token, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
}
...
</code></pre>
<p class="normal">Real JWT<a id="_idIndexMarker808" class="calibre3"/> tokens are longer sequences of characters, but I have shorted this one for brevity. The client doesn’t have to parse or process the token in any way, and they just have to include the token in HTTP requests using the <code class="inlinecode">Authorization</code> header, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
...
</code></pre>
<p class="normal">The value of the <code class="inlinecode">Authorization</code> header is a scheme, which is <code class="inlinecode">Bearer</code>, followed by the token generated during authentication. The server decodes the token and uses it to determine the identity of the authenticated user. </p>
<div><p class="normal"><strong class="screentext">Understanding API keys</strong></p>
<p class="normal">The examples in this chapter focus on user authentication. Web services can also use API keys, which identify the client making the request on behalf of the user, which can be useful when a third-party creates clients that consume your project’s APIs. API keys usually have a long life and are used to control access to API features, track request volumes, and so on. I don’t describe API keys in this book, but there is a good <a id="_idIndexMarker809" class="calibre3"/>overview available at <a href="https://cloud.google.com/endpoints/docs/openapi/when-why-api-key" class="calibre3">https://cloud.google.com/endpoints/docs/openapi/when-why-api-key</a>. </p>
</div>
<h2 class="heading1" id="_idParaDest-267">Creating the authentication API</h2>
<p class="normal1">Run the command<a id="_idIndexMarker810" class="calibre3"/> shown in <em class="italic">Listing 15.13</em> in the <code class="inlinecode">part2app</code> folder to add a JWT package and its type descriptions to the example project:</p>
<p class="packt_figref">Listing 15.13: Installing a package</p>
<pre class="programlisting1"><code class="hljs-con">npm install jsonwebtoken@9.0.2
npm install --save-dev @types/jsonwebtoken@9.0.5
</code></pre>
<p class="normal">It is possible to <a id="_idIndexMarker811" class="calibre3"/>generate and validate JWT values using custom code, but it is simpler and easier to use a good package. <em class="italic">Listing 15.14</em> adds support to sign in API clients:</p>
<p class="packt_figref">Listing 15.14: Signing in API clients in the index.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
<strong class="screentext">import jwt from "jsonwebtoken";</strong>
<strong class="screentext">const jwt_secret = "mytokensecret";</strong>
const store: AuthStore = new OrmAuthStore();
type User = { username: string }
declare module "express-session" {
    interface SessionData { username: string; }
}
declare global {
    module Express {
        interface Request { user: User, authenticated: boolean }
    }
}
export const createAuth = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        const username = req.session.username;
        if (username) {
            req.authenticated = true;
            req.user = { username };
     <strong class="screentext">   } else if (req.headers.authorization) {</strong>
<strong class="screentext">            let token = req.headers.authorization;</strong>
<strong class="screentext">            if (token.</strong><strong class="screentext">startsWith("Bearer ")) {</strong>
<strong class="screentext">                token = token.substring(7);</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">            try {</strong>
<strong class="screentext">                const decoded = jwt.verify(token, jwt_secret) as User;</strong>
<strong class="screentext">                req.authenticated = </strong><strong class="screentext">true;</strong>
<strong class="screentext">                req.user = { username: decoded.username };</strong>
<strong class="screentext">            } catch {</strong>
<strong class="screentext">                // do nothing - cannot verify token</strong>
<strong class="screentext">            }</strong>
        } else {
            req.authenticated = false;
        }
        resp.locals.user = req.user;
        resp.locals.authenticated = req.authenticated;   
        next();
    });
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            username: req.query["username"],
            password: req.query["password"],
            failed: req.query["failed"] ? true : false,
            signinpage: true
        }
        resp.render("signin", data);
    });
    app.post("/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const valid = await store.validateCredentials(username, password);
        if (valid) {
            req.session.username = username;
            resp.redirect("/");
        } else {
            resp.redirect(
                `/signin?username=${username}&amp;password=${password}&amp;failed=1`);
        }
    });
<strong class="screentext">    app.post("/api/signin", </strong><strong class="screentext">async (req, resp) =&gt; {</strong>
<strong class="screentext">        const username = req.body.username;</strong>
<strong class="screentext">        const password = req.body.password;</strong>
<strong class="screentext">        const result: any = {</strong>
<strong class="screentext">            success: </strong><strong class="screentext">await store.validateCredentials(username, password)</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        if (result.success) {</strong>
<strong class="screentext">            result.token = jwt.sign({username} , jwt_secret,</strong>
<strong class="screentext">                { expiresIn: "1hr"});</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        resp.json(result);</strong>
<strong class="screentext">        resp.end();   </strong>
<strong class="screentext">    });</strong>
    app.post("/signout", async (req, resp) =&gt; {
        req.session.destroy(() =&gt; {
            resp.redirect("/");
        })
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">/api/signin</code> route relies on the Express JSON middleware to parse the data sent by the client and validates the user’s credentials. If the credentials are valid, then a token is created, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
result.token = jwt.sign({username} , jwt_secret, { expiresIn: "1hr"});
...
</code></pre>
<p class="normal">The <code class="inlinecode">sign</code> function<a id="_idIndexMarker812" class="calibre3"/> creates a token, which is signed to prevent tampering. The arguments are the data to use as the token payload, a secret used to sign the token (which must be used again during validation), and a configuration object that is used to specify the token expiry.</p>
<p class="normal">The <code class="inlinecode">jsonwebtoken</code> package supports setting expiry times using the syntax defined by the <code class="inlinecode">ms</code> package (<a href="https://github.com/vercel/ms" class="calibre3">https://github.com/vercel/ms</a>). This allows the <code class="inlinecode">expiresIn</code> property to be set to <code class="inlinecode">1h</code>, which creates a token that’svalid for 60 mins.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">You can put any data in a token that is consumed by the same application that generates it. If you are generating tokens that will be validated by third parties, then there are well-defined payload properties that are used to describe authentication and authorization data, which can be found at <a href="https://jwt.io/introduction" class="calibre3">https://jwt.io/introduction</a>. Tokens are signed but not encrypted, which means that sensitive data should not be included in a token.</p>
</div>
<p class="normal">The authentication <a id="_idIndexMarker813" class="calibre3"/>middleware checks to see if the request includes the <code class="inlinecode">Authorization</code> header and, if it does, verifies its value as a token. The verification checks the signature to ensure that the payload hasn’t been altered and ensures the token has not expired. The username is read from the token’s payload and used to authenticate the request.</p>
<h2 class="heading1" id="_idParaDest-268">Authenticating the web service client</h2>
<p class="normal1">To complete the <a id="_idIndexMarker814" class="calibre3"/>authentication implementation, <em class="italic">Listing 15.15</em> updates the command-line client to add operations to sign in and out of the application:</p>
<p class="packt_figref">Listing 15.15: Adding authentication in the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">import { input } from "@inquirer/prompts";
const baseUrl = "http://localhost:5000";
<strong class="screentext">let bearer_token;</strong>
export const ops = {
  <strong class="screentext">  "Sign In": async () =&gt; {</strong>
<strong class="screentext">        const creds = {</strong>
<strong class="screentext">            username: await</strong><strong class="screentext"> input({message: "Username?"}),</strong>
<strong class="screentext">            password: await input({message: "Password?"}),</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">        const response = await</strong><strong class="screentext"> sendRequest("POST", "/api/signin", creds);</strong>
<strong class="screentext">        if (response.success == true) {</strong>
<strong class="screentext">            bearer_token = response.token;</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">    },</strong>
<strong class="screentext">    "Sign Out": () =&gt; { bearer_token = undefined</strong><strong class="screentext"> },</strong>
    "Get All": () =&gt; sendRequest("GET", "/api/results"),
    // ... other operations omitted for brevity...
}
const sendRequest = async (method, url, body, contentType) =&gt; {
   <strong class="screentext"> const headers = { "Content-Type": contentType ?? "application/json"};</strong>
<strong class="screentext">    if (bearer_token) {</strong>
<strong class="screentext">        headers["Authorization"] = "Bearer " + bearer_token;</strong>
<strong class="screentext">    }</strong>
    const response = await fetch(baseUrl + url, {
       <strong class="screentext"> method, headers, body</strong><strong class="screentext">: JSON.stringify(body)</strong>
    });
    if (response.status == 200) {
        const data = await response.json();
        (Array.isArray(data) ? data : [data])
            .forEach(elem =&gt; console.log(JSON.stringify(elem)));
        <strong class="screentext">return data;</strong>
    } else {
        console.log(response.status + " " + response.statusText);
    }
}
</code></pre>
<p class="normal">The token <a id="_idIndexMarker815" class="calibre3"/>received from successfully signing in is assigned to the variable named <code class="inlinecode">bearer_token</code>, which is included in subsequent requests using the <code class="inlinecode">Authorization</code> header. Note that the client doesn’t explicitly sign out of the application but simply discards the token. That’s because the server doesn’t keep track of the tokens it has issued, and there is no way to invalidate them. Once a token has been issued, it is valid until it has expired, and so web service clients simply stop using the token.</p>
<p class="normal">Open a second command prompt, and run the command shown in <em class="italic">Listing 15.16</em> in the <code class="inlinecode">part2app</code> folder to start the command-line client:</p>
<p class="packt_figref">Listing 15.16: Starting the client</p>
<pre class="programlisting1"><code class="hljs-con">npm run cmdline
</code></pre>
<p class="normal">Select the <strong class="screentext">Sign In</strong> option, and enter <code class="inlinecode">alice</code> as the username and <code class="inlinecode">mysecret</code> as the password. The response from the server shows the outcome of the authentication<a id="_idIndexMarker816" class="calibre3"/> and the token, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Sign In
? Username? alice
? Password? mysecret
{"success":true,"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFsaWNlIiwiaWF0IjoxNzA2MzQ2NDgyLCJleHAiOjE3MDYzNTAwODJ9.YjWggUNH1aP9CSGSnQGIQqZc36aQE7RG_Cb0ovEOj1k"}
...
</code></pre>
<p class="normal">You will see a different token value, but the structure of the data will be the same.</p>
<h1 class="heading" id="_idParaDest-269">Authorizing requests</h1>
<p class="normal1">Now that the user<a id="_idIndexMarker817" class="calibre3"/> can authenticate themselves, the next step is to restrict access to operations based on the user’s identity so that actions can only be performed by authorized users. </p>
<p class="normal">The foundation for authorization is<a id="_idIndexMarker818" class="calibre3"/> the <em class="italic">authorization policy</em>, which is a mapping between the operations the application provides and the users that are allowed to perform them. At its simplest, the mapping can be expressed as a simple list, as shown in <em class="italic">Table 15.4</em> for the example application, which provides <code class="inlinecode">Add</code> and <code class="inlinecode">Delete</code> operations.</p>
<p class="packt_figref">Table 15.4: A simple authorization policy</p>
<table class="table-container" id="table004-8">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Operation</p>
</td>
<td class="table-cell">
<p class="normal">Authorized Users</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Add</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">alice, bob</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Delete</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">alice</code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal">The problem with <a id="_idIndexMarker819" class="calibre3"/>this approach is that the authorization policy is an integral part of the application, which means that adding a new user or changing the operations that a user can perform requires a code change and a new release to be tested and deployed.</p>
<p class="normal">For this reason, most applications introduce <em class="italic">roles</em> and rely on <em class="italic">role</em> <em class="italic">assignment </em>to authorize requests. Rather than checking to see if the user is on the list, the application checks to see if the user has been assigned to one of the roles that are authorized to perform an operation. The details of which users are assigned to each role can be stored in a database so that changes can be made without altering the application’s code. </p>
<p class="normal">Applications are free to assign users to roles in whatever way makes the most sense, but a common approach is to focus on the different ways in which they engage with an application. For this chapter, I am going to create two roles, as described in <em class="italic">Table 15.5</em>. </p>
<p class="packt_figref">Table 15.5: The example application roles</p>
<table class="table-container" id="table005-7">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Roles</p>
</td>
<td class="table-cell">
<p class="normal">Members</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Users</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">alice, bob</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Admins</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">alice</code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal">The authorization policy can now be expressed in terms of authorized roles, rather than individual users, as described in <em class="italic">Table 15.6</em>.</p>
<p class="packt_figref">Table 15.6: A role-based authorization policy</p>
<table class="table-container" id="table006-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Operation</p>
</td>
<td class="table-cell">
<p class="normal">Authorized Roles</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Add</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Users</code>
</code></pre>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Delete</code></p>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Admins</code>
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="normal">The user <code class="inlinecode">alice</code> has been assigned to both roles and will be able to perform the <code class="inlinecode">Add</code> and <code class="inlinecode">Delete</code> operations. The user <code class="inlinecode">bob</code> has been assigned to the <code class="inlinecode">Users</code> role and will be able to<a id="_idIndexMarker820" class="calibre3"/> perform the <code class="inlinecode">Add</code> operation, but not the <code class="inlinecode">Delete</code> operation.</p>
<h2 class="heading1" id="_idParaDest-270">Adding support for roles</h2>
<p class="normal1">The first step is to expand the <a id="_idIndexMarker821" class="calibre3"/>database to add support for describing roles, as shown in <em class="italic">Listing 15.17</em>:</p>
<p class="packt_figref">Listing 15.17: Adding types in the auth_types.ts in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">export interface Credentials {
    username: string;
    hashedPassword: Buffer;
    salt: Buffer;
}
<strong class="screentext">export interface Role {</strong>
<strong class="screentext">    name: string;</strong>
<strong class="screentext">    members</strong><strong class="screentext">: string[];</strong>
<strong class="screentext">}</strong>
export interface AuthStore {
    getUser(name: string) : Promise&lt;Credentials | null&gt;;
    storeOrUpdateUser(username: string, password: string):
        Promise&lt;Credentials&gt;;
    validateCredentials(username: string, password: string): Promise&lt;boolean&gt;
    <strong class="screentext">getRole(name: string) : Promise</strong><strong class="screentext">&lt;Role | null&gt;;</strong>
<strong class="screentext">    getRolesForUser(username: string): Promise&lt;string[]&gt;;</strong>
<strong class="screentext">    storeOrUpdateRole(role: Role</strong><strong class="screentext">) : Promise&lt;Role&gt;;</strong>
<strong class="screentext">    validateMembership(username: string, role: string): Promise&lt;boolean&gt;;</strong>
}
</code></pre>
<p class="normal"><em class="italic">Listing 15.18</em> defines the model class that Sequelize will use to represent roles in the database <a id="_idIndexMarker822" class="calibre3"/>and modifies the existing model class:</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">For consistency, it is easier to store credentials and role assignments in the same database so that the primary key for a user account can be used as a foreign key for role membership. You can use separate databases, if you prefer, just as long as you ensure that changes are applied consistently, such as updating role memberships when a user account is deleted.</p>
</div>
<p class="packt_figref">Listing 15.18: Adding a model in the orm_auth_models.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { DataTypes, InferAttributes, InferCreationAttributes, Model,</strong>
<strong class="screentext">    Sequelize, HasManySetAssociationsMixin }</strong>
<strong class="screentext">        from "sequelize";</strong>
<strong class="screentext">import</strong><strong class="screentext"> { Credentials, Role } from "./auth_types";</strong>
export class CredentialsModel
        extends Model&lt;InferAttributes&lt;CredentialsModel&gt;,
            InferCreationAttributes&lt;CredentialsModel&gt;&gt;
        implements Credentials {
    declare username: string;
    declare hashedPassword: Buffer;
    declare salt: Buffer;
 <strong class="screentext">   declare RoleModels?: InferAttributes&lt;RoleModel&gt;[];</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export class RoleModel extends Model&lt;InferAttributes&lt;</strong><strong class="screentext">RoleModel&gt;,</strong>
<strong class="screentext">        InferCreationAttributes&lt;RoleModel&gt;&gt;  {</strong>
<strong class="screentext">    declare name: string;</strong>
<strong class="screentext">    declare CredentialsModels?: InferAttributes&lt;CredentialsModel&gt;[];</strong>
<strong class="screentext">    declare setCredentialsModels:</strong>
<strong class="screentext"> </strong><strong class="screentext">HasManySetAssociationsMixin&lt;CredentialsModel, string&gt;;</strong>
<strong class="screentext">}</strong>
export const initializeAuthModels = (sequelize: Sequelize) =&gt; {
    CredentialsModel.init({
        username: { type: DataTypes.STRING, primaryKey: true },
        hashedPassword: { type: DataTypes.BLOB },
        salt: { type: DataTypes.BLOB }
    }, { sequelize });
  <strong class="screentext">  RoleModel.init({</strong>
<strong class="screentext">        name: { type: DataTypes.STRING, primaryKey: </strong><strong class="screentext">true },</strong>
<strong class="screentext">    }, {  sequelize });</strong>
<strong class="screentext">    RoleModel.belongsToMany(CredentialsModel,</strong>
<strong class="screentext">        { through: "RoleMembershipJunction", foreignKey: "name" });</strong>
<strong class="screentext">    CredentialsModel.belongsToMany(</strong><strong class="screentext">RoleModel,</strong>
<strong class="screentext">        { through: "RoleMembershipJunction", foreignKey: "username" });  </strong>
}
</code></pre>
<p class="normal">Storing role<a id="_idIndexMarker823" class="calibre3"/> memberships requires a <em class="italic">many-to-many relationship</em>, where each role can be associated with many user credentials, and each user credential can be associated with many roles. The <code class="inlinecode">RoleModel</code> class represents a role, with properties that provide the role name and an array of <code class="inlinecode">CredentialsModels</code> objects. </p>
<p class="normal">Many-to-many relationships are represented in SQL using a junction table, where each row represents the relationship between one user and one role. Many-to-many relationships are always awkwardly represented by ORM packages, and some trial and error is usually required to get the objects created by the ORM to match up to the SQL tables that are created. Sequelize has a better-than-average approach, and the relationship between the model classes is created using the <code class="inlinecode">belongsToMany</code> method, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
RoleModel.belongsToMany(CredentialsModel,
    { through: "RoleMembershipJunction", foreignKey: "name" });
CredentialsModel.belongsToMany(RoleModel,
{ through: "RoleMembershipJunction", foreignKey: "username" });
...
</code></pre>
<p class="normal">The<a id="_idIndexMarker824" class="calibre3"/> arguments define the many-to-many relationship using a table named after the <code class="inlinecode">RoleMembershipJunction</code> class to create the junction. Sequelize will create the table and figure out the column data types automatically and will include associated data in results when the <code class="inlinecode">include</code> query configuration setting is used, as you will see in <em class="italic">Listing 15.18</em>. The associated data can be read using properties that are added to the model class, which are described to TypeScript like this:</p>
<pre class="programlisting"><code class="hljs-code">...
declare RoleModels?: InferAttributes&lt;RoleModel&gt;[];
...
declare CredentialsModels?: InferAttributes&lt;CredentialsModel&gt;[];
...
</code></pre>
<p class="normal">The properties are optional, as denoted by the <code class="inlinecode">?</code> character, because they will only be populated when the query includes related data. Sequelize adds methods to model objects to allow their relationships to other models to be used for more than reading data. For the benefit of TypeScript, the <code class="inlinecode">declare</code> keyword has to be used to describe the properties, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
declare <strong class="screentext">setCredentialsModels</strong>: HasManySetAssociationsMixin&lt;CredentialsModel, string&gt;;
...
</code></pre>
<p class="normal">The names given to the methods combine the operation and the model class, such that <code class="inlinecode">setCredentialsModels</code> is a method that allows the <code class="inlinecode">CredentialModels</code> objects associated with a <code class="inlinecode">RoleModel</code> to be set in a single operation.</p>
<p class="normal">For each of these methods, Sequelize provides types that can be used with the <code class="inlinecode">declare</code> statement. In the case of the set operation, the type is named <code class="inlinecode">HasManySetAssociationsMixin</code>, and the generic type parameters are used to specify the<a id="_idIndexMarker825" class="calibre3"/> associated model class as the type of the primary key.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">This is the only method I need for this example because roles are updated by replacing all of the members, but Sequelize adds methods to read, add, and remove associated data, along with type descriptions for each of them, as described at <a href="https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances" class="calibre3">https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances</a>.</p>
</div>
<p class="normal">The next step is to extend the store to add support to query, store, and check roles, as shown in <em class="italic">Listing 15.19</em>.</p>
<p class="packt_figref">Listing 15.19: Supporting roles in the orm_authstore.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import</strong><strong class="screentext"> { Sequelize, Op } from "sequelize";</strong>
<strong class="screentext">import { CredentialsModel, initializeAuthModels, RoleModel }</strong>
<strong class="screentext">    from "./orm_auth_models";</strong>
<strong class="screentext">import</strong><strong class="screentext"> { AuthStore, Role } from "./auth_types";</strong>
import { pbkdf2, randomBytes, timingSafeEqual } from "crypto";
export class OrmAuthStore implements AuthStore {
    sequelize: Sequelize;
    constructor() {
        this.sequelize = new Sequelize({
            dialect: "sqlite",
            storage: "orm_auth.db",
            logging: console.log,
            logQueryParameters: true
        });
        this.initModelAndDatabase();
    }
    async initModelAndDatabase() : Promise&lt;void&gt; {
        initializeAuthModels(this.sequelize);
        await this.sequelize.drop();       
        await this.sequelize.sync();       
        await this.storeOrUpdateUser("alice", "mysecret");
        await this.storeOrUpdateUser("bob", "mysecret");       
        <strong class="screentext">await this.storeOrUpdateRole({</strong>
<strong class="screentext">            name: "Users", </strong><strong class="screentext">members: ["alice", "bob"]</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">        await this.storeOrUpdateRole({</strong>
<strong class="screentext">            name: "Admins", members: ["alice"]</strong>
<strong class="screentext">        });</strong>
    }
    // ...methods omitted for brevity...
   <strong class="screentext"> async getRole(name: string) {</strong>
<strong class="screentext">        const stored = await RoleModel.findByPk(name, {</strong>
<strong class="screentext">            include: [{ </strong><strong class="screentext">model: CredentialsModel, attributes: ["username"]}]</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">        if (stored) {</strong>
<strong class="screentext">            return {</strong>
<strong class="screentext">                name: stored.name,</strong>
<strong class="screentext">                members: stored.CredentialsModels?.</strong><strong class="screentext">map(m =&gt; m.username) ?? []</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        return null;</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async getRolesForUser(username: string): Promise&lt;string[]&gt; {</strong>
<strong class="screentext">        return</strong><strong class="screentext"> (await RoleModel.findAll({</strong>
<strong class="screentext">            include: [{</strong>
<strong class="screentext">                model: CredentialsModel,</strong>
<strong class="screentext">                where: { username },</strong>
<strong class="screentext">                attributes: []</strong>
<strong class="screentext">            }]</strong>
<strong class="screentext">        })).map(rm</strong><strong class="screentext"> =&gt; rm.name);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async storeOrUpdateRole(role: Role) {</strong>
<strong class="screentext">        return await this.sequelize.transaction(</strong><strong class="screentext">async (transaction) =&gt; {</strong>
<strong class="screentext">            const users = await CredentialsModel.findAll({</strong>
<strong class="screentext">                where: { username: { [Op.in]: role.members } },</strong>
<strong class="screentext">                transaction</strong>
<strong class="screentext">            });           </strong>
<strong class="screentext"> </strong><strong class="screentext">const [rm] = await RoleModel.findOrCreate({</strong>
<strong class="screentext">                where: { name: role.name}, transaction });</strong>
<strong class="screentext">            await rm.setCredentialsModels(users, { transaction });</strong>
<strong class="screentext">            return role;</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">    }</strong>
<strong class="screentext"> </strong><strong class="screentext">async validateMembership(username: string, rolename: string) {</strong>
<strong class="screentext">        return (await this.getRolesForUser(username)).includes(rolename);</strong>
<strong class="screentext">    }   </strong>
}
</code></pre>
<p class="normal">The new<a id="_idIndexMarker826" class="calibre3"/> statements in the constructor initialize the database models and add the <code class="inlinecode">Admins</code> and <code class="inlinecode">Users</code> roles, which will be used to demonstrate the authorization process. </p>
<p class="normal">The <code class="inlinecode">getRole</code> method queries the database for <code class="inlinecode">RoleModel</code> objects and uses the <code class="inlinecode">include</code> option to include the associated <code class="inlinecode">CredentialsModel</code> objects in the results, which is transformed into the <code class="inlinecode">Role</code> result required by the <code class="inlinecode">RoleStore</code> interface. I only need the <code class="inlinecode">username</code> value to create a role, and I have specified the column I want <code class="inlinecode">Sequelize</code> to include in the query using the <code class="inlinecode">attributes</code> property:</p>
<pre class="programlisting"><code class="hljs-code">...
const stored = await RoleModel.findByPk(name, {
    include: [{<strong class="screentext"> model: CredentialsModel, attributes: ["username"]</strong>}]
});
...
</code></pre>
<p class="normal">The <code class="inlinecode">include</code> property is configured with an object whose <code class="inlinecode">model</code> property specifies the associated data and <code class="inlinecode">attributes</code> property specifies the model properties to populate in the result.</p>
<p class="normal">A similar technique is used to implement the <code class="inlinecode">getRolesForUser</code> method. The <code class="inlinecode">findAll</code> method is used to query for all <code class="inlinecode">RoleModel</code> objects, but the <code class="inlinecode">where</code> clause is used to make a selection based on the associated data so that only <code class="inlinecode">RoleModel</code> objects that have associations with <code class="inlinecode">CredentialsModel</code> objects whose <code class="inlinecode">username</code> property <a id="_idIndexMarker827" class="calibre3"/>matches a given value. An empty <code class="inlinecode">attributes</code> array is used to exclude all of the <code class="inlinecode">CredentialModel</code> data from the result:</p>
<pre class="programlisting"><code class="hljs-code">...
return (await RoleModel.findAll({
    include: [{
        model: CredentialsModel,
        where: { username },
       <strong class="screentext"> attributes: []</strong>
    }]
})).map(rm =&gt; rm.name);
...
</code></pre>
<p class="normal">There can be several different ways to approach queries when there are relationships between models, and the same data can be obtained by starting with the <code class="inlinecode">CredentialModel</code> class and including the <code class="inlinecode">RoleModel</code> class. My advice is to pick whichever approach feels the most natural to you, which will be a matter of personal preference.</p>
<p class="normal">The <code class="inlinecode">storeOrUpdateRole</code> method accepts a <code class="inlinecode">Role</code> object and queries the database for all of the matching <code class="inlinecode">CredentialsModel</code> objects, which ensures that any name for which there are no user credentials is ignored. The <code class="inlinecode">findOrCreate</code> method ensures that a <code class="inlinecode">RoleModel</code> object exists in the database, and the <code class="inlinecode">setCredentialsModels</code> method is used to set the role membership. A transaction is used to ensure that the update is performed atomically.</p>
<p class="normal">The <code class="inlinecode">validateMembership</code> method gets the roles to which a user has been assigned and checks that one of them matches the required role.</p>
<h2 class="heading1" id="_idParaDest-271">Checking authorization</h2>
<p class="normal1">The next step <a id="_idIndexMarker828" class="calibre3"/>is to guard routes so that only users who are assigned to authorized roles can perform operations. There are lots of ways to implement authorization, but one of the simplest is to use the Express feature that allows middleware components to be added to individual routes, which means that requests can be inspected and rejected before they are passed to the route’s request handler. <em class="italic">Listing 15.20</em> adds a function that creates a middleware component that restricts access to one or more roles:</p>
<p class="packt_figref">Listing 15.20: Defining a guard handler in the index.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { Express</strong><strong class="screentext">, NextFunction, RequestHandler } from "express";</strong>
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
import jwt from "jsonwebtoken";
const jwt_secret = "mytokensecret";
const store: AuthStore = new OrmAuthStore();
type User = { username: string }
declare module "express-session" {
    interface SessionData { username: string; }
}
declare global {
    module Express {
        interface Request { user: User, authenticated: boolean }
    }
}
export const createAuth = (app: Express) =&gt; {
    // ...other routes omitted for brevity...
<strong class="screentext">    app.get("/unauthorized", async (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.render("unauthorized");</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const roleGuard = (role: string)</strong>
<strong class="screentext">        : RequestHandler</strong><strong class="screentext">&lt;Request, Response, NextFunction&gt; =&gt; {</strong>
<strong class="screentext">    return async (req, resp, next) =&gt; {</strong>
<strong class="screentext">        if (req.authenticated) {</strong>
<strong class="screentext">            const username = req.user.username</strong><strong class="screentext">;</strong>
<strong class="screentext">            if (await store.validateMembership(username, role)) {</strong>
<strong class="screentext">                next();</strong>
<strong class="screentext">                return;</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">            resp.redirect("/unauthorized");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            resp.redirect("/signin"</strong><strong class="screentext">);           </strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">roleGuard</code> function <a id="_idIndexMarker829" class="calibre3"/>accepts a role and returns a middleware component that will only pass on the request to the handler if the user has been assigned to that role, which is checked using the <code class="inlinecode">validateMembership</code> method provided by the store. </p>
<p class="normal">There are two outcomes for unauthorized requests. If the user has not been authenticated, then the user is redirected to the <code class="inlinecode">/signin</code> URL, so they can authenticate themselves and try again. </p>
<p class="normal">For authenticated requests, the user is redirected to the <code class="inlinecode">/unauthorized</code> URL. <em class="italic">Listing 15.20</em> adds a route for <code class="inlinecode">/unauthorized</code> that renders a template. To create the template, add a file named <code class="inlinecode">unauthorized.handlebars</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 15.21</em>:</p>
<p class="packt_figref">Listing 15.21: The contents of the unauthorized.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="bg-danger text-white  m-1 p-2"&gt;
    &lt;div class="h2"&gt;Unauthorized&lt;/div&gt;
    &lt;div class="h4"&gt;
        You do not have permission to perform this operation
    &lt;/div&gt;
&lt;/div&gt;
&lt;a href="/" class="btn btn-secondary mx-1"&gt;Back&lt;/a&gt;
</code></pre>
<p class="normal">The final step is <a id="_idIndexMarker830" class="calibre3"/>to apply the guard to restrict access to operations, as shown in <em class="italic">Listing 15.22</em>:</p>
<p class="packt_figref">Listing 15.22: Authorizing requests in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
import cookieMiddleware from "cookie-parser";
import { sessionMiddleware } from "./sessions/session_helpers";
<strong class="screentext">import { roleGuard } </strong><strong class="screentext">from "./auth";</strong>
<strong class="screentext">import { Result } from "./data/repository";</strong>
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
    app.use(cookieMiddleware("mysecret"));
    app.use(sessionMiddleware());
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("data", {data: await repository.getAllResults(rowLimit)});
    });
  <strong class="screentext">  app.post("/form/delete/:id", roleGuard("Admins"), async (req, resp) =&gt; {</strong>
<strong class="screentext">        const id = </strong><strong class="screentext">Number.parseInt(req.params["id"]);</strong>
        await repository.delete(id);
        resp.redirect("/form");
        resp.end();
    });
       
   <strong class="screentext"> app.post("</strong><strong class="screentext">/form/add", roleGuard("Users"), async (req, resp) =&gt; {</strong>
<strong class="screentext">        const nextage = Number.parseInt(req.body["age"])</strong>
<strong class="screentext">            + Number.</strong><strong class="screentext">parseInt(req.body["years"]);</strong>
<strong class="screentext">        await repository.saveResult({...req.body, nextage } as Result);</strong>
        resp.redirect("/form");
        resp.end();
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">/form/add</code> route<a id="_idIndexMarker831" class="calibre3"/> is restricted to the <code class="inlinecode">Users</code> role, and the <code class="inlinecode">/form/delete/:id</code> route is restricted to the <code class="inlinecode">Admins</code> role.</p>
<p class="normal">Applying the role guard reveals an inconsistency in the type descriptions for the Express API, which causes the TypeScript compiler to complain about statements like this: </p>
<pre class="programlisting"><code class="hljs-code">...
const id = Number.parseInt(req.params.id);
...
</code></pre>
<p class="normal">The type that the compiler uses for the <code class="inlinecode">Request.params</code> property has changed, and the compiler will complain about the <code class="inlinecode">id</code> property. It is possible to correct this by adding a type annotation to the request handler, but a quick fix is to access the property like this:</p>
<pre class="programlisting"><code class="hljs-code">...
const id = Number.parseInt(req.params["id"]);
...
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code>, and make sure that no user is signed in. Click the <strong class="screentext">Add</strong> button. The browser will send a request to the <code class="inlinecode">/form/add</code> route, but since the request is unauthenticated, the browser will be redirected to the <code class="inlinecode">/signin</code> page. Sign in with the username <code class="inlinecode">bob</code> and the password <code class="inlinecode">mysecret</code>, and click the <strong class="screentext">Add</strong> button again. This time, the request is authenticated, and the user has been assigned to the <code class="inlinecode">Users</code> role, so the request is authorized and passed onto the request handler, which adds a new value to the database.</p>
<p class="normal">Click the <strong class="screentext">Delete</strong> button, and the browser will send a request to the <code class="inlinecode">/form/delete/:id</code> route. The request is authenticated but the user has not been assigned to the <code class="inlinecode">Admins</code> role, so the browser is redirected to the <code class="inlinecode">/unauthorized</code> URL. The complete sequence is shown in <em class="italic">Figure 15.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_15_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 15.4: Testing authorization</p>
<h2 class="heading1" id="_idParaDest-272">Authorizing API requests</h2>
<p class="normal1">The <code class="inlinecode">Feathers</code> package that I <a id="_idIndexMarker832" class="calibre3"/>introduced in <em class="italic">Chapter 14</em> provides support for hooks, which allow requests to be intercepted, and which I used to alter the status code when a specific error was thrown. In this chapter, I am going to use the same feature to manage authorization. The first step is to create a function that will create a hook that checks the user’s membership of a role, as shown in <em class="italic">Listing 15.23</em>:</p>
<p class="packt_figref">Listing 15.23: Adding a hook function in the index.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, NextFunction, RequestHandler } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
import jwt from "jsonwebtoken";
<strong class="screentext">import { HookContext } from "@feathersjs/feathers";</strong>
const jwt_secret = "mytokensecret";
// ...statements omitted for brevity...
export const roleGuard = (role: string)
        : RequestHandler&lt;Request, Response, NextFunction&gt; =&gt; {
    return async (req, resp, next) =&gt; {
        if (req.authenticated) {
            const username = req.user.username;
            if (await store.validateMembership(username, role)) {
                next();
                return;
            }
            resp.redirect("/unauthorized");
        } else {
            resp.redirect("/signin");           
        }
    }
}
<strong class="screentext">export const roleHook = (</strong><strong class="screentext">role: string) =&gt; {</strong>
<strong class="screentext">    return async (ctx: HookContext) =&gt; {</strong>
<strong class="screentext">        if (!ctx.params.authenticated) {</strong>
<strong class="screentext">            ctx.http = { status: </strong><strong class="screentext">401 };</strong>
<strong class="screentext">            ctx.result = {};</strong>
<strong class="screentext">        } else if (!(await store.validateMembership(</strong>
<strong class="screentext">                ctx.params.user.username, role))) {</strong>
<strong class="screentext">            ctx.http = { </strong><strong class="screentext">status: 403 };</strong>
<strong class="screentext">            ctx.result = {};</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">roleHook</code> function <a id="_idIndexMarker833" class="calibre3"/>creates a hook that will authorize access if a user has been assigned to a specified role. The user’s identity is accessed through the <code class="inlinecode">HookContext</code> parameter, which Feathers provides when a hook is invoked. The key difference from the route guard used for non-API requests is that the responses are HTTP status codes and not HTML documents. The <code class="inlinecode">401</code> status code indicates a request that does not include authentication data, and a <code class="inlinecode">403</code> status code is sent when the user is authenticated but not authorized. The status code is set using the <code class="inlinecode">HookContext.http</code> property, and setting the <code class="inlinecode">result</code> property has the effect of terminating request handling. </p>
<p class="normal"><em class="italic">Listing 15.24</em> applies the hook and configures Feathers so that the hook receives the request’s authentication data:</p>
<p class="packt_figref">Listing 15.24: Applying authorization in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
import { Validator } from "./validation_adapter";
import { ResultWebServiceValidation } from "./results_api_validation";
import { FeathersWrapper } from "./feathers_adapter";
import { feathers } from "@feathersjs/feathers";
import feathersExpress, { rest } from "@feathersjs/express";
import { ValidationError } from "./validation_types";
<strong class="screentext">import { roleHook } from "../auth";</strong>
export const createApi = (app: Express) =&gt; {
    const feathersApp = feathersExpress(feathers(), app).configure(rest());
    const service = new Validator(new ResultWebService(),
        ResultWebServiceValidation);
    <strong class="screentext">feathersApp.use('/api/results',</strong>
<strong class="screentext">        (req, resp, next) =&gt; {</strong>
<strong class="screentext">            req.feathers.user = req.user;</strong>
<strong class="screentext">            req.</strong><strong class="screentext">feathers.authenticated = req.authenticated;</strong>
<strong class="screentext">            next();</strong>
<strong class="screentext">        },</strong>
<strong class="screentext">        new FeathersWrapper(service));</strong>
    feathersApp.hooks({
        error: {
            all: [(ctx) =&gt; {                       
                    if (ctx.error instanceof ValidationError) {
                        ctx.http = { status: 400};
                        ctx.error = undefined;
                    }
                }]
        },
       <strong class="screentext"> </strong><strong class="screentext">before: {</strong>
<strong class="screentext">            create: [roleHook("Users")],</strong>
<strong class="screentext">            remove: [roleHook("Admins")],</strong>
<strong class="screentext">            update: [roleHook("Admins")],</strong>
<strong class="screentext"> </strong><strong class="screentext">patch: [roleHook("Admins")]</strong>
<strong class="screentext">        }       </strong>
    });
}
</code></pre>
<p class="normal">The first step is to get the <a id="_idIndexMarker834" class="calibre3"/>authentication data from the request and add it to the <code class="inlinecode">feathers</code> property, which is added to requests when Feathers is used and presented through the <code class="inlinecode">HookContext</code> object provided to hooks.</p>
<p class="normal">The second step is to create hooks to protect the web service. The <code class="inlinecode">before</code> property is used to register hooks that are invoked before a web service method is invoked, and the <code class="inlinecode">create</code>, <code class="inlinecode">remove</code>, <code class="inlinecode">update</code>, and <code class="inlinecode">patch</code> methods are protected by hooks that require either the <code class="inlinecode">Users</code> or <code class="inlinecode">Admins</code> role.</p>
<p class="normal">If you closed the command-line client from earlier in the chapter, then open a new command prompt, navigate to the <code class="inlinecode">part2app</code> folder, and run the command shown in <em class="italic">Listing 15.25</em>:</p>
<p class="packt_figref">Listing 15.25: Starting the command-line client</p>
<pre class="programlisting1"><code class="hljs-con">npm run cmdline
</code></pre>
<p class="normal">Select the <strong class="screentext">Store</strong> option, enter the data values, and when the request is sent, the server will response with a <code class="inlinecode">401</code> status code, which indicates that an operation requires authorization but the request contained no authentication data, like this:</p>
<pre class="programlisting1"><code class="hljs-con">? Select an operation Store
? Name? Joe
? Age? 30
? Years? 10
401 Unauthorized
</code></pre>
<p class="normal">Sign in as <code class="inlinecode">bob</code> with the password <code class="inlinecode">mysecret</code> and repeat the process. This time, the request will contain the bearer token, and the user <code class="inlinecode">bob</code> has been assigned to the <code class="inlinecode">Users</code> role, so the operation will be authorized, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Sign In
? Username? bob
? Password? mysecret
{"success":true,"token":"eyJhbGciOi...&lt;...data omitted...&gt;"}
? Select an operation Store
? Name? Joe
? Age? 30
? Years? 10
201 Created
...
</code></pre>
<p class="normal">Select <strong class="screentext">Delete</strong> and enter an <code class="inlinecode">ID</code>. The request will contain a token, but <code class="inlinecode">bob</code> hasn’t been assigned to the <code class="inlinecode">Admins</code> role, so the server will respond with a <code class="inlinecode">403</code> status code:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Delete
? ID? 1
403 Forbidden
...
</code></pre>
<p class="normal">Sign in as <code class="inlinecode">alice</code> and <a id="_idIndexMarker835" class="calibre3"/>repeat the <code class="inlinecode">Delete</code> request, which will succeed because <code class="inlinecode">alice</code> has been assigned to the <code class="inlinecode">Admins</code> role:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Username? alice
? Password? mysecret
{"success":true,"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFsaWNlIiwiaWF0IjoxNzA2NDY1NzM2LCJleHAiOjE3MDY0NjkzMzZ9.GWEZl6qypJpdX-csNifgIRjZksZTxc-Nf35uVnTq4Ss"}
? Select an operation Delete
? ID? 1
true
...
</code></pre>
<p class="normal">The authorization process for the web service is based on the same user data as for HTML clients, but returning a status code gives API clients a response that can be handled programmatically.</p>
<h1 class="heading" id="_idParaDest-273">Using packages for authentication and authorization</h1>
<p class="normal1">Now that you understand how authentication and authorization work together in a web application, it is time to replace some of the custom code with open-source packages.</p>
<p class="normal">There are two good reasons to use open-source packages for authentication in particular. The first reason is that it is easy to make a mistake when writing custom code that creates a security vulnerability. The second reason is that a good authentication package will support a range of different authentication strategies, including authentication with third-party services, such as Google and Facebook. </p>
<p class="normal">In <em class="italic">Part 3</em> of this book, I demonstrate a different authentication strategy, but for this chapter, I am going to use open-source packages but still use usernames and passwords for authentication.</p>
<p class="normal">Not all features can be replaced with custom code. The focus tends to be on authentication, while authorization is left to individual applications to implement.</p>
<h2 class="heading1" id="_idParaDest-274">Authenticating HTML clients</h2>
<p class="normal1">I am going to use the <a id="_idIndexMarker836" class="calibre3"/>Passport package (<a href="https://www.passportjs.org" class="calibre3">https://www.passportjs.org</a>) to provide authentication. Passport supports a wide range of authentication <a id="_idIndexMarker837" class="calibre3"/>strategies, including support for using third-party authentication services, and provides an API to implement custom strategies. In this chapter, I use the <code class="inlinecode">Local</code> strategy, which provides support to authenticate users with locally stored username and password data and uses sessions to authenticate subsequent requests. I also use the <strong class="screentext">JWT</strong> strategy, which uses bearer tokens to authenticate requests. Run the commands shown in <em class="italic">Listing 15.26</em> in the <code class="inlinecode">part2app</code> folder to install the main passport package, the packages that contain the strategies, and type descriptions for all of them:</p>
<p class="packt_figref">Listing 15.26: Installing packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install passport@0.7.0
npm install passport-local@1.0.0
npm install passport-jwt@4.0.1
npm install --save-dev @types/passport@1.0.16
npm install --save-dev @types/passport-local@1.0.38
npm install --save-dev @types/passport-jwt@4.0.1
</code></pre>
<p class="normal">Passport<a id="_idIndexMarker838" class="calibre3"/> requires configuration so that it can be integrated into the <a id="_idIndexMarker839" class="calibre3"/>application. Add a file named <code class="inlinecode">passport_config.ts</code> to the <code class="inlinecode">src/server/auth</code> folder, with the content shown in <em class="italic">Listing 15.27</em>:</p>
<p class="packt_figref">Listing 15.27: The contents of the passport_config.ts file in the src/server/auth folder</p>
<pre class="programlisting"><code class="hljs-code">import passport from "passport";
import { Strategy as LocalStrategy }  from "passport-local";
import { Strategy as JwtStrategy, ExtractJwt  } from "passport-jwt";
import { AuthStore } from "./auth_types";
type Config = {
    jwt_secret: string,
    store: AuthStore
}
export const configurePassport = (config: Config) =&gt; {
    passport.use(new LocalStrategy(async (username, password, callback) =&gt; {
        if (await config.store.validateCredentials(username, password)) {
            return callback(null, { username });
        }
        return callback(null, false);
    }));
    passport.use(new JwtStrategy({
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
        secretOrKey: config.jwt_secret
    }, (payload, callback) =&gt; {
        return callback(null, { username: payload.username });
    }));
    passport.serializeUser((user, callback) =&gt; {
        callback(null, user);
    });
    passport.deserializeUser((user, callback) =&gt; {
        callback(null, user as Express.User );
    });   
}
</code></pre>
<p class="normal">The <code class="inlinecode">passport.use</code> function is used to set up strategies, and in <em class="italic">Listing 15.27</em>, the local and JWT strategies are applied. These strategies require a verification function, which receives the request data and returns an object representing the user.</p>
<p class="normal">The verification <a id="_idIndexMarker840" class="calibre3"/>function for the local strategy receives the username and password sent by the user, which is validated using the stored credentials. The outcome is <a id="_idIndexMarker841" class="calibre3"/>provided to Passport with a callback, which either provides an object that represents the user or <code class="inlinecode">false</code> if verification fails:</p>
<pre class="programlisting"><code class="hljs-code">...
if (await config.store.validateCredentials(username, password)) {
   <strong class="screentext"> return callback(null, { username });</strong>
<strong class="screentext">}</strong>
<strong class="screentext">return callback(null, false);</strong>
...
</code></pre>
<p class="normal">The verification function will only be called when the user signs in, after which Passport uses a temporary token to authenticate subsequent requests. One option is to use session cookies to store the user data, which is the same approach used by the custom code.</p>
<p class="normal">The verification for the JWT strategy is different. Passport doesn’t generate JWT tokens, and the verification function is called when a bearer token is received. The strategy is configured with an object that tells Passport how to locate the bearer token in the request and provides the key to check the token signature. The verification function receives the payload from the token and is responsible for providing an object that represents the authenticated user.</p>
<p class="normal">The <code class="inlinecode">serializeUser</code> and <code class="inlinecode">deserializeUser</code> functions are used by Passport to include user information in the session. These functions must be defined even when, as in this case, user<a id="_idIndexMarker842" class="calibre3"/> data is just an object containing a <a id="_idIndexMarker843" class="calibre3"/>username. <em class="italic">Listing 15.28</em> uses Passport to authenticate requests:</p>
<p class="packt_figref">Listing 15.28: Using Passport in the index.ts File in the src/server/auth Folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, NextFunction, RequestHandler } from "express"
import { AuthStore } from "./auth_types";
import { OrmAuthStore } from "./orm_authstore";
import jwt from "jsonwebtoken";
import { HookContext } from "@feathersjs/feathers";
<strong class="screentext">import passport </strong><strong class="screentext">from "passport";</strong>
<strong class="screentext">import { configurePassport } from "./passport_config";</strong>
const jwt_secret = "mytokensecret";
const store: AuthStore = new OrmAuthStore();
<strong class="screentext">//type User = { username: string }</strong>
declare module "express-session" {
    interface SessionData { username: string; }
}
declare global {
    module Express {
       <strong class="screentext"> //interface Request { user: User, authenticated: boolean }</strong>
<strong class="screentext">        interface Request { authenticated: boolean }</strong>
<strong class="screentext">        interface User {</strong>
<strong class="screentext">            username: string</strong>
<strong class="screentext">        }</strong>
    }
}
export const createAuth = (app: Express) =&gt; {
    configurePassport({ store, jwt_secret });
    app.get("/signin", (req, resp) =&gt; {
        const data = {
            <strong class="screentext">// username: req.query["username"],</strong>
<strong class="screentext">            // password: req.query["password"],</strong>
            failed: req.query["failed"] ? true : false,
            signinpage: true
        }
        resp.render("signin", data);
    });
   <strong class="screentext"> app.post</strong><strong class="screentext">("/signin", passport.authenticate("local", {</strong>
<strong class="screentext">        failureRedirect: `/signin?failed=1`,</strong>
<strong class="screentext">        successRedirect: "/"</strong>
<strong class="screentext">    }));</strong>
<strong class="screentext">    app.use(passport.authenticate</strong><strong class="screentext">("session"), (req, resp, next) =&gt; {</strong>
<strong class="screentext">        resp.locals.user = req.user;</strong>
<strong class="screentext">        resp.locals.authenticated</strong>
<strong class="screentext">            = req.authenticated = req.user</strong><strong class="screentext"> !== undefined;           </strong>
<strong class="screentext">        next();</strong>
<strong class="screentext">    });</strong>
    app.post("/api/signin", async (req, resp) =&gt; {
        const username = req.body.username;
        const password = req.body.password;
        const result: any = {
            success: await store.validateCredentials(username, password)
        }
        if (result.success) {
            result.token = jwt.sign({username} , jwt_secret,
                { expiresIn: "1hr"});
        }
        resp.json(result);
        resp.end();   
    });
    app.post("/signout", async (req, resp) =&gt; {
        req.session.destroy(() =&gt; {
            resp.redirect("/");
        })
    });
    app.get("/unauthorized", async (req, resp) =&gt; {
        resp.render("unauthorized");
    });
}
export const roleGuard = (role: string)
        : RequestHandler&lt;Request, Response, NextFunction&gt; =&gt; {
    return async (req, resp, next) =&gt; {
        if (req.authenticated) {
           <strong class="screentext"> const username = req.user</strong><strong class="screentext">?.username;</strong>
<strong class="screentext">            if (username != undefined</strong>
<strong class="screentext">                    &amp;&amp; await store.validateMembership(username, role)) {</strong>
                next();
                return;
            }
            resp.redirect("/unauthorized");
        } else {
            resp.redirect("/signin");
        }
    }
}
export const roleHook = (role: string) =&gt; {
    return async (ctx: HookContext) =&gt; {
        if (!ctx.params.authenticated) {
            ctx.http = { status: 401 };
            ctx.result = {};
        } else if (!(await store.validateMembership(
                ctx.params.user.username, role))) {
            ctx.http = { status: 403 };
            ctx.result = {};
        }
    }
}
</code></pre>
<p class="normal">Passport <a id="_idIndexMarker844" class="calibre3"/>provides its own additions to the <code class="inlinecode">Express</code> <code class="inlinecode">Request</code> object, so adjustments are required to prevent conflicts. The <code class="inlinecode">Passport</code> <code class="inlinecode">authenticate</code> function is used twice. When used with a route, the <code class="inlinecode">authenticate</code><code class="inlinecode"><a id="_idIndexMarker845" class="calibre3"/></code> method is used to create a request handler that will validate credentials using the local strategy: </p>
<pre class="programlisting"><code class="hljs-code">...
app.post("/signin", passport.<strong class="screentext">authenticate</strong>("local", {
...
</code></pre>
<p class="normal">The configuration options tell Passport where to redirect the browser for successful and failed sign-in attempts. Passport doesn’t include the username and password in redirections for failed sign-in attempts, which is why the values are no longer included when the sign-in template is rendered.</p>
<p class="normal">The other use of the <code class="inlinecode">authenticate</code> function is to authenticate requests, and the argument specifies that the session is the source of authentication data:</p>
<pre class="programlisting"><code class="hljs-code">...
app.use(passport.<strong class="screentext">authenticate</strong>("session"), (req, resp, next) =&gt; {
...
</code></pre>
<p class="normal">Passport doesn’t have an <code class="inlinecode">authenticate</code> property, but a follow-on handler function allows the property to be set, along with the local data required for templates.</p>
<p class="normal">As noted, Passport doesn’t create JWT tokens, so the code that authenticates API clients remains unchanged. Passport does <em class="italic">validate</em> JWT tokens, however, which is why the code that read and validated the bearer token was removed in <em class="italic">Listing 15.28</em>. <em class="italic">Listing 15.29</em> uses Passport to authenticate bearer tokens for web service requests:</p>
<p class="packt_figref">Listing 15.29: Using Passport in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
import { Validator } from "./validation_adapter";
import { ResultWebServiceValidation } from "./results_api_validation";
import { FeathersWrapper } from "./feathers_adapter";
import { feathers } from "@feathersjs/feathers";
import feathersExpress, { rest } from "@feathersjs/express";
import { ValidationError } from "./validation_types";
import { roleHook } from "../auth";
<strong class="screentext">import passport from "passport";</strong>
export const createApi = (app: Express) =&gt; {
    const feathersApp = feathersExpress(feathers(), app).configure(rest());
    const service = new Validator(new ResultWebService(),
        ResultWebServiceValidation);
    <strong class="screentext">feathersApp.use('/api/results',</strong>
<strong class="screentext">        passport.authenticate("jwt", { session: false</strong><strong class="screentext"> }),</strong>
<strong class="screentext">        (req, resp, next) =&gt; {</strong>
<strong class="screentext">            req.feathers.user = req.user;</strong>
<strong class="screentext">            req.feathers.authenticated</strong>
<strong class="screentext">                = req.authenticated = req.user !== undefined</strong><strong class="screentext">;</strong>
<strong class="screentext">            next();</strong>
<strong class="screentext">        },</strong>
<strong class="screentext">        new FeathersWrapper(service));</strong>
    feathersApp.hooks({
        error: {
            all: [(ctx) =&gt; {                       
                    if (ctx.error instanceof ValidationError) {
                        ctx.http = { status: 400};
                        ctx.error = undefined;
                    }
                }]
        },
        before: {
            create: [roleHook("Users")],
            remove: [roleHook("Admins")],
            update: [roleHook("Admins")],
            patch: [roleHook("Admins")]
        }       
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">authenticate</code> function<a id="_idIndexMarker846" class="calibre3"/> is used to create a request handler that will validate tokens, using the JWT strategy. A follow-on function is used to set the values used by the Feathers hook so that authorization<a id="_idIndexMarker847" class="calibre3"/> checks can be performed.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Feathers has its own<a id="_idIndexMarker848" class="calibre3"/> authentication and authorization features, which are useful if you are creating a stand-alone API project, and they are described at <a href="https://feathersjs.com/api/authentication" class="calibre3">https://feathersjs.com/api/authentication</a>. Mixing authentication features from multiple packages can be difficult, which is why I have used Passport for all authentication in the examples, even though some features, like JWT creation, are not available.</p>
</div>
<p class="normal">The use of the Passport package doesn’t alter the way authentication works, and users sign into the application in the same way. The difference is the reduction in custom code and support for a wider range of authentication strategies, which can make it easier to integrate an application into an existing environment or to use third-party authentication services.</p>
<p class="normal">Custom code is still required to perform role-based authorization, which is why it is important to understand how users and requests are authenticated, and how the results can be used to restrict access to application features.</p>
<h1 class="heading" id="_idParaDest-275">Summary</h1>
<p class="normal1">In this chapter, I demonstrated how users and requests can be authenticated, and how authentication data can be used to authorize access to application features:</p>
<ul class="calibre4">
<li class="bulletlist">Users present their credentials, whether using an HTML form or a JSON payload.</li>
<li class="bulletlist1">When credentials are validated, the client is sent a temporary token that can be used to authenticate subsequent requests.</li>
<li class="bulletlist1">The temporary authentication token can be a cookie (and a session cookie is often used) or a bearer token.</li>
<li class="bulletlist1">Authorization is usually performed through roles, which prevents you having to hardcode user permissions into the application. The relationship between users and roles is stored in a database, so it can be altered without releasing a new version of the application.</li>
<li class="bulletlist1">There are good open-source packages available for user and request authentication, but authorization is typically done using custom code.</li>
</ul>
<p class="normal">In <em class="italic">Part 3</em>, I use the features described in <em class="italic">Parts 1</em> and <em class="italic">2</em> of this book to create an online store that shows how the different parts of an application work together.</p>
</div>
</body></html>