<html><head></head><body>
        

                            
                    <h1 class="header-title">Introducing Aurelia</h1>
                
            
            
                
<p class="mce-root">If you were born in the 80s or 90s, without doubt, you were a witness to the internet evolution. The first web pages were composed only of black text in a white screen; everything they wrote was in pure HTML format, and really, really static. After some years, the first CSS was adding some color to the web, and, after some unsuccessful  attempts, JavaScript did appear.</p>
<p>From its first appearance, JavaScript has improved over the years and adapted to build the next generation of web pages. Many companies such as Microsoft were involved in the evolution of this language, adding features and increasing its popularity. This new scripting language allowed the developers to improve the customer experience and application performance and, in a short time, there began to appear the first JavaScript frameworks that made JavaScript the new rock star of web development.</p>
<p>All this sounds great, but, was it always as awesome as the strong language we have today? Uhmm, no it was not. The first JavaScript version was created by <em>Brendan Eich</em> in 1995 for the <em>Netscape Navigator</em>, named in those times as <em>Mocha</em>, then <em>LiveScript</em>, and finally, JavaScript.</p>
<p>Let's explore more about the features of this powerful language and how it becomes one of the most used for application development.</p>
<p>In this chapter, we will walk through the following topics:</p>
<ul>
<li>JavaScript fundamentals</li>
<li>The ECMAScript standard</li>
<li>Setting up our environment</li>
<li>The Aurelia framework</li>
<li>The Aurelia command line</li>
<li>Overview of the example app</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript fundamentals</h1>
                
            
            
                
<p>JavaScript is a programming language used to add custom behavior to your web page by executing code in your web browser side (commonly named client side). So, this allows us to create rich dynamic projects such as games, execute custom code in response to events when the user presses some button, apply dynamic effects to our web page elements, form data validation, and so on.</p>
<p>JavaScript as a single language is very flexible, and there is a big community of developers writing and unlocking additional functionality, big companies working on new libraries and of course, we as empowered developers ready to get all these features and make the web awesome.</p>
<p>There are a few basic characteristics of JavaScript:</p>
<ul>
<li>Dynamic typing</li>
<li>Object oriented</li>
<li>Functional</li>
<li>Prototyped</li>
<li>Event handling</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dynamic typing</h1>
                
            
            
                
<p>In most of the scripting languages, the type is associated with the value, not with the variable itself. What it means? JavaScript and other languages such as Python, called <strong>weakly typed</strong>, does not need to specify which kind of data we will use to store in the variable. JavaScript has many ways to ensure the correct type of an object, including <em>duck typing</em>.</p>
<p>Why duck?<br/>Well, James Whitcomb did a humorous inference explaining the deductive thinking about it—"If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck"</p>
<p>Let’s look at an example:</p>
<pre>1.  var age = 26;<br/>2.  age = "twenty-six";<br/>3.  age = false;</pre>
<p>In the preceding code, the defined variables accept any data type, because data types will be evaluated at runtime, so, for example, the <kbd>age</kbd> variable in line <kbd>1</kbd> will be an integer, will become a string in line <kbd>2</kbd> and, finally, Boolean. Sounds tricky? Don't worry, think of the variable as an empty vial without a label. You can put anything you want, cookies, milk, or salt. What you will store in the vial? Depending of your needs, if you want to make a breakfast, milk should be the better option. The only thing you must keep in mind, is remember what is containing this vial! We would hate to confuse salt with sweet.</p>
<p>If we need to ensure that the value belongs to some specific type, we can use the <kbd>typeof</kbd> operator to retrieve the data type of a given variable. Let's have a look at them:<br/></p>
<ul>
<li><kbd>typeof "Diego"</kbd>: This will return <kbd>string</kbd></li>
<li><kbd>typeof false</kbd>: This will return <kbd>boolean</kbd></li>
<li><kbd>typeof "Diego" == boolean</kbd>: This will return <kbd>false</kbd></li>
</ul>
<p>The <kbd>typeof</kbd> operator is very useful, but keep in mind it only gives primary types (<kbd>number</kbd>, <kbd>string</kbd>, <kbd>boolean</kbd> or <kbd>object</kbd>). Different from other similar operators such <kbd>instanceof</kbd> of Java, <kbd>typeof</kbd> won't return the object type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object oriented</h1>
                
            
            
                
<p>JavaScript objects are based on associative arrays, improved with the prototyping inclusion. The properties and values can be changed at runtime. Another common way to create objects is using the <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) or using functions.</p>
<p>Let's see how an object created by JavaScript code looks, and its JSON representation:</p>
<pre>// Let's create the person object<br/>function Person(first, last, age) {<br/>    this.firstName = first;<br/>    this.lastName = last;<br/>    this.age = age;<br/>}<br/>var diego = new Person("Diego", "Arguelles", 27);<br/><br/>//JSON representation of the same object<br/>{<br/>    firstName: "Diego",<br/>    lastName: "Arguelles",<br/>    age: 27<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Functional</h1>
                
            
            
                
<p>A function is an object inside itself. They have properties, methods, and can include inner functions. It's a way to encapsulate a functionality you want to reuse in more than one place in your application; you just need to write the function name instead of all the code inside that, just like the following example:</p>
<pre>function sum(numberA, numberB){<br/>    return numberA + numberB<br/>}<br/>sum(4,5) //9<br/>sum(5,2) //7<br/>sum(sum(5,1),9) //15<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Prototyped</h1>
                
            
            
                
<p>JavaScript uses prototypes instead of classes for inheritance. It is possible to emulate all OOP characteristics using just prototypes:</p>
<pre>function Person(first, last, age) {<br/>    this.firstName = first;<br/>    this.lastName = last;<br/>    this.age = age;<br/>}<br/><br/>var diego = new Person('Diego', 'Arguelles', 26)<br/>diego.nationality = 'Peruvian'<br/>console.log(diego) <br/>// Person {firstName: "Diego", lastName: "Arguelles", age: 26, nationality: "Peruvian"}<br/><br/>Person.prototype.career = 'Engineering'<br/>console.log(diego.career) // Engineering</pre>
<p>That being said, what is exactly a prototype? Different from objects, one prototype does not have a closed structure. In objects, we define standard properties and we just have these properties for work, since JavaScript is not completely an object-oriented language, we have the advantage to add, remove, or change properties and values of our prototypes depending on our needs.</p>
<p>We can modify prototype attributes at runtime. Note that even if you can modify any prototype, you should only modify yours. If you modify standard prototypes (for example, the  array prototype) you will encounter very weird bugs in your application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Events handling</h1>
                
            
            
                
<p>Events allow you to add the real interaction on your web page. JavaScript allows you to attach event handlers on your HTML pages and execute custom code when they are triggered. For example, the given code will display an alert when the user clicks on your web page body:</p>
<pre>document.querySelector('body').onclick = function() {<br/>    alert('You clicked the page body!!!');<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The ECMAScript standard</h1>
                
            
            
                
<p>In the beginning, some companies such as Microsoft were trying to develop their own JavaScript implementation, in this case, JScript for Internet Explorer 3.0, in the year  1996. To define a standard, Netscape delivered JavaScript to the <strong>European Computer Manufacturers Association</strong> (<strong>ECMA</strong>), a standards organization for information and communication systems.</p>
<p>The first edition of ECMA-262 was adopted by the ECMA General Assembly in June 1997. Several editions of the language standard have been published since then. The name <em>ECMAScript</em> was a compromise between the organizations involved in standardizing the language, especially Netscape and Microsoft, whose disputes dominated the early standards sessions.</p>
<p>So, after all these standardization processes and paperwork, what are we using? ECMAScript, JScript, ActionScript, or JavaScript? Are they the same? Well, basically no. After the standardization, ECMAScript was defined as the main language, and JavaScript, JScript, and ActionScript are dialects of this language, of course, JavaScript being the most known and used.</p>
<p>The ECMAScript Version 5 is supported by most browsers nowadays, released in 2011. Some of the features managed for this version are as listed:</p>
<ul>
<li>Support for new Array methods</li>
<li>Support for manage dates</li>
<li>Support for JSON</li>
</ul>
<p>At this point, we’ve seen pure ES5 syntax, very verbose, sometimes highly coupled with other functionality, and if we are planning to develop a big application, it can become difficult to maintain.</p>
<p>Thank God we won’t have to deal with this syntax anymore. The <strong>ECMAScript 6</strong> (<strong>ES6</strong>) version came with a lot of changes that simplify the development and understanding of our code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ES 6</h1>
                
            
            
                
<p>This version arrives with significant changes in the language syntax. Let's review the new features and compare with the ES5 syntax.</p>
<p>In ES5, to make a near representation of an object in JavaScript, we commonly type something like this:</p>
<pre>function Person(name, age) {<br/>    this.name = name;<br/>    this.age   = age;<br/>}<br/>Person.prototype.sayHi = function() {<br/>    return 'Hi, my name is ' + this.name + ' and i have ' + this.age + ' years old';<br/>}<br/><br/>var Erikson = new Person('Erikson', 26);<br/>Erikson.sayHi(); // 'Hi, my name is Erikson and i have 26 years old'<br/></pre>
<p>If we want to improve our code, maybe we can do some refactoring, as follows:</p>
<pre>function Person(name, age) {<br/>    this.name = name;<br/>    this.age   = age;<br/><br/>    this.sayHi = function () {<br/>        return 'Hi, my name is ' + this.name + ' and i have ' + this.age + ' years old';<br/>    }<br/>}</pre>
<p>That's how <strong>Object-Oriented Programming</strong> (<strong>OOP</strong>) is done on JavaScript these days, but for programmers with previous experience on Java or PHP, that syntax result is a little difficult to understand, because they are not dealing with real objects, they are dealing directly with the prototypes. ES6 introduces a new syntax to declare objects:</p>
<pre>class Person {<br/>    <br/>    // Contructor define properties for our object representartion<br/>    constructor(name, age) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/>    // Class method<br/>    sayHi() {<br/>        return 'Hi, my name is ' + this.name + ' and i have ' + this.age + ' years old';<br/>    }<br/>}<br/>var Erikson = new Person('Erikson', 26);<br/>Erikson.sayHi() // Hi , my name is Erikson and I have 26 years old</pre>
<p>As you can see, now, the syntax is more readable and understandable, and we can extend from another class, just like other languages, such as Java:</p>
<pre>class Developer extends Person {<br/><br/>    constructor(name, age, role){<br/>        super(name, age)<br/>        this.role = role;<br/>    }<br/>    sayHi(){<br/>        return super.sayHi() + ' and i am a ' + this.role<br/>    }<br/>}<br/>var Erikson = new Person('Erikson', 26, 'Javascript developer');<br/>Erikson.sayHi() // 'Hi, my name is Erikson and i have 26 years old and i am a Javascript developer'</pre>
<p>Also, of course, we can use encapsulation principles to manipulate our object properties. Similar to Java, we can define mutator methods to get the property value or set some value to a property:</p>
<pre>class Person {<br/><br/>    constructor(name, age) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/>    get checkName() {<br/>        return this.name;<br/>    }<br/>    set giveName(newName) {<br/>        this.name = newName;<br/>    }<br/>}<br/>var Erikson = new Person('Erikson', 26);<br/>Erikson.checkName() // returns Erikson<br/>Erikson.giveName('Hazis')<br/>Erikson.checkName() // returns Hazis</pre>
<p>Having these kind of methods does not avoid the fact that you can still be using the JavaScript native syntax to change the values or add properties at runtime. You will still be able to do the following:</p>
<pre>Erikson.name = 'Diego'<br/>Erikson.name // Returns Diego</pre>
<p>Like other languages, ES6 allows static methods using the static modifier:</p>
<pre>class Example {<br/>    static returnMessage(){<br/>        return 'From static method'<br/>    }<br/>}<br/>let staticMessage = Example.returnMessage() // From static method</pre>
<p>Do you note something? In the last example, we used <kbd>let</kbd> instead of <kbd>var</kbd> to declare a variable. ES6 has two new ways of defining a variable: <kbd>let</kbd> is the direct replacement of <kbd>var</kbd>, and <kbd>const</kbd> will be used if we are declaring a constant. Can we still use <kbd>var</kbd> instead of the new ES6 declaration syntax? Yes, but let's imagine that you are an experienced developer and have two trainees under your supervision. In your code, you can define something like this:</p>
<pre>var PI = 3.1416</pre>
<p>Also, of course, we do not want this value changed, for any reason. As this is still a <kbd>var</kbd>, any trainee developer is able to change the value, directly or indirectly (from a method call, assignation error, bad comparison syntax, and so on), so we are exposed to get errors on our application. To prevent these kind of scenarios, <kbd>const</kbd> would be a more accurate modifier for this variable.</p>
<p>Does ES6 only improve syntax for objects' declaration? No. At this moment, we only focused on our class definition syntax, because it will be the core of all applications, just like OOP. Now, we will check other improvements that we are pretty sure you will find very useful in your day-to-day work.</p>
<p>A very important note: You must know that different to other code languages, in Javascript you can define <kbd>const MY_ARRAY = []</kbd> and you will still being able to do <kbd>MY_ARRAY.push(3)</kbd>. The <kbd>const</kbd> prefix will only avoid the overwriting, so you cannot do <kbd>MY_ARRAY = [1,2]</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Arrow functions</h1>
                
            
            
                
<p>You need to iterate over the elements of an array; normally, you would write something like this:</p>
<pre>var data = ['Ronaldo', 'Messi', 'Maradona'];<br/>data.forEach(function (elem) {<br/>    console.log(elem)<br/>});</pre>
<p>With the arrow functions, you can refactor your code and write something as follows:</p>
<pre>var data = ['Ronaldo', 'Messi', 'Maradona'];<br/>data.forEach(elem =&gt; {<br/>    console.log(elem);<br/>});</pre>
<p>The arrow (<kbd>=&gt;</kbd>) operator defines a function in one line, making our code readable and ordered. First, you need to declare the inputs; the arrow will send these params to the function body defined by the operator:</p>
<pre>// We could transform this<br/>let sum = function(num) {<br/>    return num + num;<br/>};<br/>// Into just this<br/>let sum = (num) =&gt; num + num;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">String interpolation</h1>
                
            
            
                
<p>Do you remember those times when you needed to concatenate a string using the <kbd>+</kbd> operator? It won’t be necessary anymore. For example, the following code concatenates <kbd>string1</kbd> and <kbd>string2</kbd> using the <kbd>+</kbd> operator:</p>
<pre>let <strong>string1 </strong>= "JavaScript";<br/>let <strong>string2 </strong>= "awesome";<br/>let string3 = <strong>string1</strong> + " " + <strong>string2</strong></pre>
<p>Now, let's look at how interpolation helps us write simpler code:</p>
<pre>let <strong>string1 </strong>= "JavaScript";<br/>let <strong>string2 </strong>= "awesome";<br/>let string3 = `${<strong>string1}</strong> ${<strong>string2}`</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Destructuring</h1>
                
            
            
                
<p>We have a new way to assign values to objects and arrays. Let’s look at some examples:</p>
<pre>var [a, b] = ["hello", "world"];<br/>console.log(a); // "hello"<br/>console.log(b); // "world"<br/><br/>var obj = { name: "Diego", lastName: "Arguelles" };<br/>var { name, lastName } = obj;<br/>console.log(name); // "Diego"<br/><br/>var foo = function() {<br/>    return ["175", "75"];<br/>};<br/>var [height, weight] = foo();<br/>console.log(height); //175<br/>console.log(weight); //75</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up our environment</h1>
                
            
            
                
<p>At this point, we are ready to start writing our first functions and methods in JavaScript language. We know how to deal with the new ES6 syntax and how we can use all these new features to improve our application. Let's set up our environment and install Node.js.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Node.js</h1>
                
            
            
                
<p>The first thing you need to do to start using NPM is download Node.js. Node is an asynchronous event-driven JavaScript runtime. It is not a new language or a new syntax; it's just the platform where you can write JavaScript code outside the browser and Node.js will use the power of Google's V8 JavaScript Engine to execute it.</p>
<p>If you're using OS X or Windows, the best way to install Node.js is to use one of the installers from the Node.js download page.</p>
<p>If you're using Linux, you can use your package manager or check the download page to see whether there's a more recent version that works with your system.</p>
<p>To check whether you have a previous version installed, run the following command:</p>
<pre><strong>$ node –v</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Node Package Manager</h1>
                
            
            
                
<p>The <strong>Node Package Manager</strong> (<strong>NPM</strong>) is a complete tool created to help developers share, maintain, and reuse JavaScript code bundled in packages with other developers to reuse it on their own applications. NPM is made up of three distinct components:</p>
<ul>
<li>The NPM website</li>
<li>The NPM registry</li>
<li>The NPM command-line tool</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">NPM website</h1>
                
            
            
                
<p>This website serves as the primary tool for users to discover packages; you’ll find something like this:</p>
<div><img src="img/8b39f41c-df77-4799-964a-a5a60aa36fc9.png" style="width:35.58em;height:24.25em;"/></div>
<p>This page describes all the features of the package you want to download, a brief documentation about it, the GitHub URL, and instructions to import them into your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NPM Registry</h1>
                
            
            
                
<p>It is a large database of information about each package. The official public NPM registry is at <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>. It is powered by a CouchDB database, of which there is a public mirror at <a href="https://skimdb.npmjs.com/registry">https://skimdb.npmjs.com/registry</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NPM CLI</h1>
                
            
            
                
<p>A command-line tool for interacting with the registry and allowing the developers to publish or download packages.</p>
<p>Once you have the code downloaded on your machine, NPM will make it very easy to check whether there is an update available and download those changes when they’re made. More than two bits of reusable code is called a package. That’s just a directory with one or more files in it, along with a file called <kbd>package.json</kbd>, which contains all the metadata about that package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Common NPM operations</h1>
                
            
            
                
<p>Like all the command-line tools, it is important to understand the options provided by NPM. The NPM CLI is a powerful tool that will help us in the development cycle of our project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating NPM</h1>
                
            
            
                
<p>The first step is complete! We have the Node runtime on our machine ready to execute our <kbd>.js</kbd> files, so the last thing we need to start working on is the NPM. Node comes with NPM installed by default, but NPM gets updated more frequently than Node, so we can check the updation of our NPM CLI by executing the following command:</p>
<pre><strong>$ npm install npm@latest -g</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing NPM packages</h1>
                
            
            
                
<p>NPM is installed and configured; now it's time to start working. There are two ways to install NPM packages. Our choice will depend on how we want to use the package. The options are as listed:</p>
<ul>
<li><strong>Globally:</strong> Install the given package globally as part of our command-line tools</li>
<li><strong>Locally:</strong> Install the given package to be available only in our application context</li>
</ul>
<p>With this in mind, type the following command to install a new package:</p>
<pre><strong>$ npm install &lt;package-name&gt;</strong></pre>
<p>This instruction will create a folder called <kbd>node_modules</kbd>, where we will download all the packages we need. We can ensure that we have the package downloaded, entering the folder and checking the existence of a folder with a name similar to our package name. Run the following command to list all the packages installed in your project:</p>
<pre><strong>$ ls node_modules</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Versions</h1>
                
            
            
                
<p>If no package version is specified, we will get the latest. To install a specific version, we need to add the following to the <kbd>install</kbd> command:</p>
<pre><strong>npm install &lt;package-name&gt;@&lt;version&gt;</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The package.json file</h1>
                
            
            
                
<p>We know how to download a package and how to import it into our project. However, we will commonly need more than one package, with some specific versions. Should we memorize them to download manually each time we set up the project? No, now is the moment to create a <kbd>package.json</kbd> file.</p>
<p>This file is not only to map our dependencies; it must contain all the metadata about our project, and it serves as a quick documentation for which packages your project depends on. As minimal, the <kbd>package.json</kbd> should contain the following:</p>
<ul>
<li><strong>Name</strong>: Project name, all lowercase with no blank spaces (you can use underscores if needed)</li>
<li><strong>Version</strong>: In the form of x.x.x</li>
</ul>
<p>We can create this file manually, but NPM allows us to create it automatically by executing the following command:</p>
<pre><strong>$ npm init</strong></pre>
<p>The preceding command will prompt you with a bunch of questions that will be present in your <kbd>package.json</kbd> file. If you don't want to accept the defaults without being prompted any question, run the same command, adding a <kbd>--yes</kbd> flag at the end:</p>
<pre><strong>$ npm init --yes</strong></pre>
<p>Then, you will get a <kbd>package.json</kbd> file, as follows:</p>
<pre>{<br/>  "name": "my_package",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "https://github.com/package_owner/my_package.git"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "bugs": {<br/>    "url": "https://github.com/package_owner/my_package/issues"<br/>  },<br/>  "homepage": "https://github.com/package_owner/my_package"<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependencies and devDependencies</h1>
                
            
            
                
<p>You have all your dependencies installed now. You start working and during the development process, you may need some other dependencies to improve your code. You just need to run the NPM CLI to get the new dependency, but this will not be present in your <kbd>package.json</kbd> file! It can be very dangerous, because if you don't have the list of libraries or dependencies you need for your project, when you want to run it in a different machine, your code will fail, because the dependency is not installed in that machine.</p>
<p>We can ensure that the new package name will be added to our dependencies' list, adding the <kbd>–-save</kbd> or <kbd>–-save-dev</kbd> flag. The first will add the package name to the dependencies' section of the <kbd>package.json</kbd> file. This means that the dependency is mandatory for the application itself and should be installed before running or deploying the application. On the other hand, we have the devDependencies' part, where there will be only the dependencies used for our development process:</p>
<pre><strong>$ npm install &lt;package_name&gt; --save</strong></pre>
<p>Now, we are ready to start developing JavaScript applications. In the next section, you will make use of NPM to install the Aurelia command-line tool required to create new Aurelia projects, but let's continue exploring the Aurelia framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Aurelia framework</h1>
                
            
            
                
<p>Before we start working with Aurelia and learning this amazing framework, it is important to have it clear why you should choose Aurelia over other popular frameworks. For that reason, let's explore in detail what a JavaScript framework is and the key differentiator present in Aurelia.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a JavaScript framework?</h1>
                
            
            
                
<p>In the last section, we were reviewing all concerns about JavaScript and how we can organize our packages using NPM and Yarn. Now, it's time to review some tools that will improve our development experience; it's time to talk about frameworks.</p>
<p>A framework can be described as a group of tools and methodologies organized to solve common problems in the project development. Those solutions are generic; each one was tested in different environments and allows you to reuse that functionality to save time and cost.</p>
<p>So, based on the previous explanation, we can define a JavaScript framework as a collection of components and libraries (in most cases, interdependent) to fill the needs of the application in browser clients. What are these needs? Let's check some of the most generic ones:</p>
<ul>
<li>Routing</li>
<li>Data sending features and retrieval (XMLHttpRequest)</li>
<li>Correct DOM management</li>
<li>Managing and organizing your code in separated functionality</li>
<li>Defining standard data flows for the application</li>
<li>Defining lifecycle for some functionality</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Why use a JavaScript framework?</h1>
                
            
            
                
<p>In general, a JavaScript framework will help us do the following:</p>
<ul>
<li>Organizing your code</li>
<li>Structuring it in a maintainable and ordered way</li>
<li>Making separation of concerns</li>
<li>Implementing tested solutions to the most common problems</li>
<li>Working on a base structure that any developer can follow</li>
</ul>
<p>More specifically, a JavaScript framework is particularly helpful for applications where much of the business logic will take place on the client side—routing, templating, first-pass model validation, table building and pagination—pretty much whatever you might have used the server for in the past, but now without the latency and overhead that additional HTTP calls would have incurred.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript framework comparison</h1>
                
            
            
                
<p>One problem always has more than just one solution, and JavaScript developers know that. Before 2010, developers had very limited options to implement their functionality in their day-to-day work. The most popular option in these times was jQuery, used a lot nowadays too. Although jQuery was not a bad choice, but it has a great weakness. For example, if your project growth and your business code become more complex, jQuery will be really difficult to maintain, your concerns will be mixed, and you will be involved in one of the most common anti-patron—<strong>Spaghetti code</strong>.</p>
<p>In 2010, Google released one of the most popular JavaScript frameworks—Angular. Different from jQuery, Angular comes with a complete set of tools and a new way to organize the JavaScript code, introducing new concepts such as modules, components, routes, and templates. After Angular, many JavaScript frameworks were appearing; some of them became very popular for the company sponsoring them, such as Facebook with React.js, others gained fame by the adoption of the community, such as Meteor and Vue, and others are really new in the neighborhood.</p>
<p>As innovation is the essence of technology, one of the main engineers of Angular 2 project developed a new awesome framework called Aurelia, which, in just three years in the market, is becoming the new rock star in the neighborhood.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why Aurelia?</h1>
                
            
            
                
<p class="grammarly-disable-indicator">Over the last years in our current day-to-day work, we were getting involved with a vast variety of JavaScript frameworks; the most popular was always Angular, but we learned that popularity is not synonymous with quality. For understanding purposes, we will check some of the most used frameworks nowadays and then make a little comparison with our battle horse, Aurelia.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Angular</h1>
                
            
            
                
<p>The component-based framework uses Typescript as the main (and unique) JavaScript platform. Angular is a complete superset of libraries designed for all purposes of <strong>Single Page Applications</strong> (<strong>SPA</strong>), very useful for developing applications from scratch. You can link your templates and your <kbd>Typescript</kbd> code so you <kbd>HTML</kbd> is updated with values from your code and ready to react on user actions . You need to learn three basic concepts about this framework—directives, modules, and components. Each one involves another, and you need to register each component with one Module to make it available. JavaScript also has its own module system for managing collections of JavaScript objects. It's completely different and unrelated to Angular's module system. Angular has its own implementation to define service classes, routes, double data binding, HTTP requests, and so on, making this framework very heavyweight.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical information</h1>
                
            
            
                
<ul>
<li><strong>Size</strong>: 698 Kb</li>
<li><strong>Standard compliance</strong>: ES 2016 (TypeScript)</li>
<li><strong>Non-compliant</strong>: NG2 Markup and Dart</li>
<li><strong>Interoperability</strong>: Average</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency injection</h1>
                
            
            
                
<p>The dependency injection framework requires more configuration. In contrast to Aurelia, Angular requires you to specify the HTML <kbd>selector</kbd> and <kbd>template</kbd>, increasing the file complexity. Aurelia will detect the template based on a name strategy:</p>
<pre>@Injectable()
class Ticket { /* */ }

@Component({
  selector: 'ticket',
  providers: [Ticket],
  template: `...`
}) //Configuration code mixed with business class
export class Sale {
    constructor(private ticket: Ticket) {}

    public activate() {
        // do something...
        this.ticket.toast("Sale processed!");
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Component encapsulation</h1>
                
            
            
                
<p>Angular components need more explicit configuration and some (in some cases confusing) characters in the template. You can put the template in a separate file, or for simpler components, you can include the template inline:</p>
<pre>/* product-list.component.ts */
@Component({
    selector: 'product-list',
    template: `&lt;div&gt;&lt;product-detail *ngFor="let thing of things" [product]="product" /&gt;&lt;/div&gt;`
})
export class ProductList {
    public products: Product[];
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">React.js</h1>
                
            
            
                
<p>Different from Angular, React.js is a library that can be integrated with any JavaScript project. It is used for handling the view layer for the web applications and build reusable UI components. React is component based too, but it mixes the HTML code inside the JavaScript files, in JSX format. JSX is a React syntax very similar to XML format since you can manage your view layer and add some behavior defining some attributes as the state or properties of your component. Sounds a little confusing? Yes, you will need to learn how JSX works and read about some of the new concepts about the tool.</p>
<p>React.js has a great feature—server-side rendering. What does that mean? Common JavaScript frameworks let the render work to the client side, so the browser needs to interpret your JavaScript files and transform it to plain HTML files. It can take time depending on how much data will be displayed on the page. With React.js, you can configure your server to have all those pages processed in the server side, so the browser just needs to call the correct HTML file and of course, the loading time will be less.</p>
<p>Similar to Angular, React.js offers you a complete set of libraries to implement dynamic routing, data binding, HTTP requests, and other React implementations libraries such as Inferno.js, with a rendering algorithm more powerful and optimized.</p>
<p>One very important note! Aurelia now has its own server side rendering plugin. You can find more info there: <a href="https://aurelia.io/docs/ssr/introduction/">https://aurelia.io/docs/ssr/introduction/</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical information</h1>
                
            
            
                
<ul>
<li><strong>Size</strong>: 156 KB or 167 KB with plugins</li>
<li><strong>Standard compliance</strong>: ES 2015</li>
<li><strong>Non-compliant</strong>: JSX</li>
<li><strong>Interoperability</strong>: High friction</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency injection</h1>
                
            
            
                
<p>There is no such dependency injection concept in React.js.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Component encapsulation</h1>
                
            
            
                
<p>A component is <em>one</em> JS class. Do you want to include another component in your component? Just import it:</p>
<pre>import {ProductDetail} from "./ProductDetail";

interface Props {
    products: Product[];
}
export class ProductList extends React.Component&lt;Props, undefined&gt; {
    render() {
        return &lt;div&gt;
            {this.props.products.map(th =&gt; &lt;ProductDetail key={th.id} product={th} /&gt;)}
        &lt;/div&gt;
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Aurelia</h1>
                
            
            
                
<p>Aurelia is a new JavaScript framework created by one of the team members of Angular 2 project. Different from Angular, Aurelia is composed of a collection of libraries that work together using well-defined interfaces so that it’s completely modular. This means that a web application only needs to include the dependencies that it needs, not the complete bundle.</p>
<p>Aurelia's APIs are carefully designed to be consumed naturally by both today's and tomorrow's most useful web programming languages. Aurelia supports ES5, ES2015, ES2016, and Typescript, which are very helpful and give you high flexibility.</p>
<p>Furthermore, writing web applications using ES6 is not a new thing. In fact, there are many solutions out there that can allow you to write Angular apps using ES6 (you need to configure it manually and it's not included in the default Angular configuration).</p>
<p>You don't need to worry about special framework concepts or syntax; Aurelia is a <em>convention over configuration</em> framework, encouraging you to use good practices when developing applications, and it allows the developers to focus only on business code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical information</h1>
                
            
            
                
<ul>
<li><strong>Size</strong>: 252 kb minimum, 302 kb with standard plugin</li>
<li><strong>Standard compliance</strong>: HTML, ES 2016, Web Components (including the Shadow DOM)</li>
<li><strong>Interoperability</strong>: Very interoperable</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency injection</h1>
                
            
            
                
<p>All you need is the <kbd>@autoinject</kbd> annotation. The JS/HTML mapping is performed automatically by the framework:</p>
<pre>class Ticket { /* class code, properties, methods... */ }

@inject
export class Sale {<br/>    constructor( ticket ) {}

    public activate() {
        // do something...
        this.ticket.toast("Sale processed!");
    }
}</pre>
<p>For <kbd>Typescript</kbd> users, the annotation names are very similar. Use <kbd>@autoinject</kbd> instead of <kbd>@inject</kbd> and don't forget to specify the visibility and type of object in the constructor : <kbd>constructor(private ticket : Ticket)</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Component encapsulation</h1>
                
            
            
                
<p>Component encapsulation uses a separate template file that looks more or less like every other web templating language you've ever used. By convention, if your component class is in <kbd>hello.ts</kbd>, then its template is in <kbd>hello.html</kbd> and your component will be <kbd>&lt;hello/&gt;</kbd>:</p>
<pre>&lt;!-- product-list.html --&gt;
&lt;template&gt;
    &lt;require from="product-detail"/&gt;
    &lt;div&gt;
        &lt;product-detail repeat.for="product of products" product.bind="product"/&gt;
    &lt;/div&gt;
&lt;/template&gt;
/* producty-list.js */
export class ProductList {
    public products[];
}</pre>
<p>Each JavaScript framework has its own way of working, and we can explore more features about each one, but Aurelia has something special—you don't need to go far away from learning how the framework works, and in extreme cases, in their own way/syntax for developing. With Aurelia, you will feel like writing plain JavaScript and HTML code, highly maintainable, scalable, and focusing only on your business purposes.</p>
<p>Now it's time to start working with Aurelia. So, let's explore the Aurelia command line to start our trip. Keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aurelia command-line tool</h1>
                
            
            
                
<p class="mce-root">There are many ways to create an Aurelia project. For this book, we will use the official Aurelia command-line tool, which is supported by the Aurelia team. Although there are other options to configure your Aurelia application, such as Webpack and JSPM, we consider that the CLI is powerful and will help us save valuable time configuring our application skeleton and build tools.</p>
<p class="mce-root">In this section, we will explore in detail the CLI capabilities, and you will convince yourself that this is the best option for our adventure. After this section, you will be a master in using the Aurelia CLI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation</h1>
                
            
            
                
<p>Installing the CLI is not a big deal if you have installed Node.js in the previous section. We just need to open your favorite Terminal and execute the following command, and if you are using a Unix-based operating system, remember to add <kbd>sudo</kbd> before the command if you have permission issues:</p>
<pre><strong>npm install -g aurelia-cli</strong></pre>
<p>The preceding command will install the Aurelia CLI as a global executable command-line tool. This allows us to use the CLI with the <kbd>au</kbd> command as any other command of our operative system Terminal, for example, the <kbd>dir</kbd> command.</p>
<p>After the installation is complete, execute the following command:</p>
<pre><strong>au help</strong></pre>
<p>This should return the following output that displays the CLI help. As you can see, this command has two main options:</p>
<div><img src="img/d0a072b5-e86d-4b18-9703-b838a3f376bc.png" style="width:35.50em;height:19.67em;"/></div>
<p>Now that we are sure that it is working as we expected, let's learn how to get the most out of it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new application</h1>
                
            
            
                
<p>This is one of the most important options. As its name says, it will create a new Aurelia application with a well-defined application folder structure and all the initial configuration files in just three steps.</p>
<p>Execute the following command and replace <kbd>my-app</kbd> with your application's name:</p>
<pre><strong>au new my-app</strong></pre>
<p>When the Aurelia CLI wizard is running, we will select the following options to create our application:</p>
<ol>
<li>Select <kbd>1</kbd> for ECMAScript next generation language</li>
<li>Select <kbd>1</kbd> to create the project</li>
<li>Select <kbd>1</kbd> to install the dependencies</li>
</ol>
<p>Once you answer the last question, the CLI will install all the dependencies and once everything is complete, you will see the following output in your Terminal window:</p>
<div><img src="img/5622f4ca-8706-40b8-a6f9-7469d9317136.png" style="width:42.58em;height:23.67em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Running our Application</h1>
                
            
            
                
<p>Next, we will look into the run option. This option allows us to run our application, and it provides us with an option to create a productive development environment by specifying the <kbd>--watch</kbd> option, which configures a watcher to detect changes in our source code and update our browser automatically. This cool feature is known as browser-sync or auto-refresh.</p>
<p>The <kbd>run</kbd> command also allows us to specify the environment where we want to execute our application; these are the default environments: <kbd>dev</kbd>, <kbd>stage</kbd>, and <kbd>prod</kbd>. By default, the CLI will run our application using the <kbd>dev</kbd> environment. Use the <kbd>--env</kbd> flag to change it.</p>
<p>What means exactly each environment? Well, in software development, commonly when you are writing your application you test your code on you local development environment (<kbd>dev</kbd>). Once you think its complete, you send it to a Quality Assurance area to test your application, this tests won't be performed on your machine so you need to export your application and deploy it on another server, it will be called the <kbd>test</kbd> environment. Finally, once the QA people gives his approval, you code will be deployed in the real world environment (<kbd>prod</kbd>). Of course, this is a very basic scope, you will find many more environments in other companies such UAT (User Acceptance Test).</p>
<p>For example, let's get into our application (<kbd>cd</kbd> command) and execute the following command:</p>
<pre><strong>cd my-app</strong><br/><strong>au run --watch --env prod</strong></pre>
<p>The following is the output that has two URLs where we can see our application up and running:</p>
<div><img src="img/19dc38ec-7abb-4250-98fe-2c8273cbb356.png" style="width:50.08em;height:6.75em;"/></div>
<p>Open the <kbd>http://localhost:9000</kbd> URL in your favorite web browser, and you should see the following:</p>
<div><img src="img/c558fe0a-93b8-43b0-b679-082b8b5c2c1a.png" style="width:20.50em;height:12.33em;"/></div>
<p>Pay attention to the last two lines in the console. Those tell you in which port is running your application, it could be different depending on your operating system and which port you have available.</p>
<p>Now, let's test how auto-refresh works, remember that this feature is enabled by adding the <kbd>--watch</kbd> option in the <kbd>au run</kbd> command.</p>
<p>Open the <kbd>app.js</kbd> file located in the <kbd>src</kbd> folder and change the <kbd>'Hello World!'</kbd> string to <kbd>'Hola Mundo!'</kbd>:</p>
<pre>export class App {<br/>  constructor() {<br/>    this.message = 'Hola Mundo!';<br/>  }<br/>}</pre>
<p>Save it and go back to your browser; the CLI will detect the change you made in the <kbd>app.js</kbd> file and will refresh your browser automatically.</p>
<p>To be more productive, you can use two displays—the first with your application running in the browser and the second with your source code editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing our application</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">Of course, testing is an important skill all developers need to have. We have a complete chapter to talk about testing and discuss TDD, unit testing, and end-to-end testing.</p>
<p>The test command comes with the <kbd>--watch</kbd> and the <kbd>--env</kbd> flags. Use the watch option to tell the CLI to detect changes in the <kbd>test</kbd> folder and execute the tests again.</p>
<p>In order to run tests, the CLI uses Karma, which is a test runner technology that is configured to use Jasmine testing framework to write all our testing files that should be saved into the <kbd>test</kbd> folder.</p>
<p>For example, the preceding command will run the <kbd>app.sec.js</kbd> file located in the <kbd>test/unit</kbd> folder:</p>
<pre><strong>au test --watch --env stage</strong></pre>
<p>The following is the output that has executed one test successfully:</p>
<div><img src="img/023c5016-8482-44b2-ab42-2b7a2ed9d94b.png" style="width:43.33em;height:13.92em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Building our application</h1>
                
            
            
                
<p>Now is the time to deploy our application, but before we do this, we need to compress and minify our Aurelia code. Aurelia CLI provides us with the build option to generate these ready-to-deploy files that contain all our application code.</p>
<p>As you might want to build your application for different environments (<kbd>dev</kbd>, <kbd>stage</kbd>, or <kbd>prod</kbd>), this build option comes along with the <kbd>--env</kbd> flag. For example, execute the following command in your project:</p>
<pre><strong>au build --env prod</strong></pre>
<p>The following is a sample output of <kbd>my-app</kbd> project:</p>
<div><img src="img/b4eb79cc-8b18-485e-8b7e-0b59b4b3a63d.png"/></div>
<p>As the output shows, there are two main files generated: <kbd>app-bundle.js</kbd>, which contains our application logic and <kbd>vendor-bundle.js</kbd>, which contains third-party dependencies. These two files are generated into the <kbd>scripts</kbd> folder in our root application folder.</p>
<p>If you want to run your application and check whether everything is okay with the bundles you recently created, let's install the <kbd>http-server</kbd> module using <kbd>npm</kbd>. Run the following command in your Terminal:</p>
<pre><strong>npm install -g http-server</strong></pre>
<p>Now, create a <kbd>dist</kbd> folder in your application root folder and copy the <kbd>index.html</kbd> page and the <kbd>scripts</kbd> folder that contain our bundles.</p>
<div><img src="img/ed491977-216f-4e7e-8ce1-40ccf419150f.png" style="width:20.83em;height:8.83em;"/></div>
<p>For the last step, get into the <kbd>dist</kbd> folder in your Terminal and run the following command:</p>
<pre><strong>cd dist</strong><br/><strong>http-server<br/></strong></pre>
<p>Use the <kbd>cd</kbd> command to navigate across your folders in your Terminal.</p>
<p>This command will expose some four URLs where the web server is running; copy the first URL and open it on your web browser, and you should see your application up and running:</p>
<div><img src="img/2f0fc693-35f5-4383-8d6f-69f6809c9e6c.png" style="width:63.42em;height:9.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating custom resources</h1>
                
            
            
                
<p>Aurelia, like many JavaScript frameworks, allows you to create reusable components that help you avoid writing duplicated code, reuse your component in multiple parts of your app, and also export them as plugins to reuse them in other projects.</p>
<p class="mce-root">Aurelia allows you to generate the reusable pieces of code utilizing the following templates:</p>
<ul>
<li class="mce-root">Components</li>
<li class="mce-root">Custom elements</li>
<li class="mce-root">Custom attributes</li>
<li class="mce-root">Binding-behaviors</li>
<li class="mce-root">Value-converters</li>
</ul>
<p class="mce-root">These templates are all located in our project root folder in the <kbd>aurelia_project/generators</kbd> folder. For example, the following command generates a custom Aurelia element:</p>
<pre><strong>au generate element my-reusable-element</strong></pre>
<p>The source code will be generated in the <kbd>src/resources/{type}</kbd> folder depending on the <strong>type</strong> you selected.</p>
<p class="mce-root">Each type will be discussed in the following chapters, so don't feel bad if you don't understand the differences between them. Keep reading my friend! :)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">World Cup app overview</h1>
                
            
            
                
<p>Now it is time to talk about our application we will build together. Apart from our web application written, of course, in Aurelia, we also need a backend service to persist our data. For the backend service, we will be using Node.js with the Express framework to build a robust API and MongoDB as our non-relational data storage. The following diagram explains our World Cup project architecture:</p>
<div><img src="img/d3e73934-0c97-4d34-9899-29018c24ebeb.png" style="width:19.50em;height:15.33em;"/></div>
<p class="mce-root">This a very simple architecture; the Aurelia app talks to the Node API directly, and the Node API talks to the database, which is a MongoDB database, using a very popular open source library called Mongoose. This is getting better; keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the application features</h1>
                
            
            
                
<p>The app we will develop is the Football World Cup app. We will use an awesome UI framework called Materialize, which, by default, will help us create a responsive web application, so our users can open this app in their mobile and desktop browser with an adaptable user interface.</p>
<p>Although this is a simple application, we will cover the most important concepts of Aurelia that you will find in a real production application. We will improve this app along with the book. Listed are the features we will develop for this app:</p>
<ul>
<li>Matches explorer</li>
<li>Teams explorer</li>
<li>News</li>
<li>Admin portal</li>
<li>Social authentication</li>
</ul>
<p>So, let's start exploring the features that this application delivers to our users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Matches explorer</h1>
                
            
            
                
<p>This feature is related to the matches in the entire competition. The users will be able to perform the following actions:</p>
<ul>
<li>List the Matches activity</li>
<li>Create a new Match, which requires admin</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the matches</h1>
                
            
            
                
<p>The user will see the list of matches represented as cards. A calendar is shown to the user to navigate and see the matches scheduled per day. The mock-up is shown here:</p>
<div><img src="img/c4a4b456-80df-4fd3-83e5-0fd0c82258cd.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new Match</h1>
                
            
            
                
<p>To create a new Match, an admin account is required. Once the user is authenticated, they can schedule a new Match by selecting the teams and the time. The mock-up is shown as follows:</p>
<div><img src="img/a030e940-a579-431d-be78-3cb1e848e5fc.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Teams explorer</h1>
                
            
            
                
<p>This feature is related to the matches in the entire competition. The users will be able to perform the following actions:</p>
<ul>
<li>List the Teams</li>
<li>Create a new Team, which requires admin</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the teams</h1>
                
            
            
                
<p>The user will see the list of teams represented as cards. The mock-up is as follows:</p>
<div><img src="img/229c7f42-2bc3-41b3-a4b5-2d2fd936ee20.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new team</h1>
                
            
            
                
<p>To create a new Team, an admin account is required. Once the user is authenticated, they can create a new team. The mock-up is this:</p>
<div><img src="img/68d4aa16-d1ac-4a98-870b-dadec78660d2.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">News</h1>
                
            
            
                
<p>This feature is related to the news. The users will be able to perform the following actions:</p>
<ul>
<li>List the News</li>
<li>Create a New item, which requires admin</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the News</h1>
                
            
            
                
<p>The user will see the list of news represented as cards. The mock-up is as shown:</p>
<div><img src="img/813597ca-09d7-45fc-875b-5261b16bf067.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Create a New</h1>
                
            
            
                
<p>To create a New, an admin account is required. Once the user is authenticated, they can create a New. The mock-up is this:</p>
<div><img src="img/af6d1b9c-108a-42f7-ad5a-fe10ef1307b2.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Social authentication</h1>
                
            
            
                
<p>The user will be able to sign in using their Google or Facebook account. The mock-up is this:</p>
<div><img src="img/3766eb38-8903-4d95-9749-038ad863dba7.png"/></div>
<p>Now that we have an idea of the application we will develop, let's continue creating the initial application project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our app</h1>
                
            
            
                
<p>Let's start creating our application. If you remember our last section about the Aurelia CLI, we need to use it again to create a new application, so open your favorite Terminal tool and execute the following command:</p>
<pre><strong>au new worldcup-app</strong></pre>
<p>Enter the following input in the Terminal:</p>
<ol>
<li>Select <kbd>3</kbd> to define our custom options for this project</li>
<li>
<p>First option: <kbd>Which module loader / bundler would you like to use? RequireJS (Default)</kbd></p>
</li>
<li>
<p>Second option: <kbd>What transpiler would you like to use? : Babel (Default)</kbd></p>
</li>
<li>
<p>Third option: <kbd>How would you like to setup your template? : Default</kbd> (<kbd>No markup processing</kbd>.)</p>
</li>
<li>
<p>Fourth option: <kbd>What CSS processor would you like to use?</kbd> In this case, we will choose <kbd>Sass</kbd> (<kbd>3</kbd>)</p>
</li>
<li>
<p>Fifth option: <kbd>Would you like to configure unit testing?</kbd> Of course, we will mark <kbd>Yes (Default)</kbd></p>
</li>
<li>Sixth option: <kbd>What is your default code editor?</kbd> We use WebStorm, but you can choose the most familiar to you.</li>
</ol>
<p>Now, you will see the main structure of your application on the console:</p>
<pre>Project Configuration<br/>    Name: worldcup-app<br/>    Platform: Web<br/>    Bundler: Aurelia-CLI<br/>    Loader: RequireJS<br/>    Transpiler: Babel<br/>    Markup Processor: None<br/>    CSS Processor: Sass<br/>    Unit Test Runner: Karma<br/>    Editor: WebStorm</pre>
<ol start="8">
<li>Finally, select  <kbd>1</kbd> to create the project and then install the project dependencies</li>
</ol>
<p>This is a custom setup. Our project will be composed with the following features:</p>
<ul>
<li><strong>RequireJS</strong>: Well known file and module loader, with a good browser support. Another option could be SystemJS and Webpack.</li>
<li><strong>Babel</strong>: Babel is one of the most used <em>transpilation</em> tools nowadays. A <kbd>transpiler</kbd> is a tool that transforms code written in JavaScript ES6 syntax or later into ES5 code. Why? Because most of the browsers does not have well supported yet the last JavaScript version.</li>
<li><strong>Markup processing</strong>: It loads our modules and create the final files which will be interpreted by the browser. We won't use a custom markup processing in this stage.</li>
<li><strong>SASS</strong>: A nice preprocessor CSS library, we will review it at more detail in the next chapter.</li>
<li><strong>Karma</strong>: A JavaScript test library. We will talk about it in more detail in the  <a href="" target="_blank">Chapter 3</a>, <em>Testing and Debugging</em>.</li>
<li><strong>WebStorm</strong>: A very nice IDE for JavaScript developers. It is not free but if you have an educational email account from your university or institute, you can get a student license for one year. </li>
</ul>
<p>Once everything is done, open the <kbd>worldcup-app</kbd> folder with your favorite editor.</p>
<p>We know Webpack is a very awesome module loader, but for learning purposes, we prefer to use RequireJS across all this book because is more simple and let us explain better how to configure manually  each tool and library we will use in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The project structure</h1>
                
            
            
                
<p>The Aurelia CLI will generate the source code with its base structure, which has everything configured and ready to start writing our application's source code.</p>
<p>The following screenshot shows the root application folder:</p>
<div><img src="img/66864749-292f-4edf-9ba5-c6aa06196762.png" style="width:17.83em;height:25.17em;"/></div>
<p>Let's start talking about the <kbd>aurelia_project</kbd> folder, which contains the main <kbd>aurelia.json</kbd> configuration file with all the settings about the dependencies, blunder, build target, loaders, testing run-time tool such as Karma, testing framework, and more. You will modify this file frequently to specify new dependencies our application needs to use.</p>
<p>The next element in the <kbd>aurelia_folder</kbd> is the <kbd>environments</kbd> folder, which contains three files: <kbd>dev.json</kbd>, <kbd>stage.json</kbd>, and <kbd>prod.json</kbd>. These files contain values depending on the environment you are running on. Do you remember the <kbd>--env</kbd> flag in the run option? The CLI will use one of these files to configure our app's environmental values.</p>
<p>The remaining two folders are <kbd>generators</kbd> and <kbd>tasks</kbd>. They are used to generate Aurelia custom reusable components and to declare gulp tasks, respectively.</p>
<p>The <kbd>scripts</kbd> folder contains the bundles generated after we execute the <kbd>au build</kbd> command.</p>
<p>As you might guess, the <kbd>src</kbd> folder contains our application source code, followed by the <kbd>test</kbd> folder, which contains our source code to test our project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Bootstrap process</h1>
                
            
            
                
<p>Like many JavaScript frameworks such as Angular and React, Aurelia needs a place in the <kbd>index.html</kbd> page to mount the application. This place is known as the entry point. Open the <kbd>index.html</kbd> file, and you should see something similar to the following code:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;Aurelia&lt;/title&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;<br/>  &lt;/head&gt;<br/><br/>  &lt;body <strong>aurelia-app="main"</strong>&gt;<br/>    &lt;script src="img/vendor-bundle.js" data-main="aurelia-bootstrapper"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Aurelia requires an HTML element to load our application. By default, the application is loaded in the <kbd>body</kbd> element; we know this because this element uses the <kbd>aurelia-app</kbd> attribute, which is used to specify the main JavaScript script file that contains all the configuration for our application, and as you note, by default, Aurelia is configured to use the <kbd>main</kbd> file. The following is the content of the <kbd>main.js</kbd> file:</p>
<pre>import environment from <strong>'./environment'</strong>;<br/><br/>export function <strong>configure</strong>(<strong>aurelia</strong>) {<br/>  <strong>aurelia</strong>.use<br/>    .<strong>standardConfiguration</strong>()<br/>    .feature('resources');<br/><br/>  if (environment.debug) {<br/>    aurelia.use.developmentLogging();<br/>  }<br/><br/>  if (environment.testing) {<br/>    aurelia.use.plugin('aurelia-testing');<br/>  }<br/><br/>  <strong>aurelia.start().then(() =&gt; aurelia.setRoot());</strong><br/>}</pre>
<p>Let's analyze this file; the first line imports the environment variables from the <kbd>environment.js</kbd> file located in the root folder. When you specify the <kbd>--flag</kbd> <kbd>{env}</kbd> option, the CLI looks for the <kbd>{env}.json</kbd> file in the <kbd>aurelia_project</kbd> folder and copies its content into the <kbd>environment.js</kbd> file.</p>
<p>This file also exports a single <strong><kbd>configure</kbd></strong> function, which receives as a parameter the <kbd>aurelia</kbd> object that you use to override default configurations and add any code you wish before the app is launched. For example, you can tell Aurelia that you want to declare components as global (features), configure internationalization to manage different languages, and so on.</p>
<p>Once the <kbd>aurelia</kbd> object is configured, the last line of code will render our application into the root HTML element, which has the <kbd>aurelia-app</kbd> attribute in the <kbd>index.html</kbd> page. By default, it renders the <kbd>app.js</kbd> component into the root element. Of course, we can override the default values by passing the element you wish to render as the first parameter and the HTML element where you wish to render the app as a second parameter:</p>
<pre> aurelia.start().then(() =&gt; aurelia.setRoot(<strong>'my-component'</strong>, <strong>document.getElementById('my-div')</strong>));</pre>
<p>We will be modifying this file along the way; the most important thing to remember is that this file is processed before the app is rendered and apart from the <kbd>Aurelia.json</kbd> file, this is the second most important file. The following diagram explains the bootstrapping process:</p>
<div><img src="img/97a04ff3-773c-427b-8129-0b833ccfb369.png" style="width:47.58em;height:14.08em;"/></div>
<p>Now you know how the bootstrapping process works. Let's understand how you can create reusable components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding components</h1>
                
            
            
                
<p>In the last section, we saw that Aurelia requires a component to mount as the root of our entire application and by default, it was the app component. Now let's explore this component.</p>
<p>A <strong>component</strong> is composed of two files, the first written in JavaScript that contains the component's view model and the second one is the markup template written in HTML. They must have the same filename to help the view model resolve its view template. The component's view model is a JavaScript file, which exports a class that contains the component's attributes and functions. For example, this is the content of the <kbd>app.js</kbd> component:</p>
<pre>export class App {<br/>  constructor() {<br/>    this.message = 'Hello World!';<br/>  }<br/>}</pre>
<p>The <kbd>App</kbd> class declares a constructor that initializes the <kbd>message</kbd> property. Properties can be declared into the <kbd>constructor</kbd> or can be defined outside of it. Consider this example:</p>
<pre>export class App {<br/>  message = 'Hello World!';<br/>}</pre>
<p>Use the outside property declaration style when you are declaring simple classes such as <strong>Plain Old CLR Objects</strong> (<strong>POCO</strong>), which now implements more logic than simply get and set its property values.</p>
<p>To use the properties defined in our <kbd>app.js</kbd> view model, we need an HTML template with the same filename. Open the <kbd>app.html</kbd> file to see its content:</p>
<pre>&lt;template&gt;<br/>  &lt;h1&gt;${message}&lt;/h1&gt;<br/>&lt;/template&gt;</pre>
<p>The first thing to note is that the <kbd>message</kbd> property declared in the view model is present, but in order to bind the value, we have to use the <kbd>${}</kbd> string interpolation operator. Finally, when Aurelia renders the component in the web page, the <kbd>${message}</kbd> declaration will be replaced by <kbd>'Hello World!'</kbd>.</p>
<p>We can extend our components by adding functions that can be called from the template. For example, let's declare the <kbd>changeMessage()</kbd> function:</p>
<pre>export class App {<br/><br/>  constructor() {<br/>    this.message = 'Hello World!';<br/>  }<br/><br/>  <strong>changeMessage() {</strong><br/><strong>    this.message = 'World-Cup App';</strong><br/><strong>  }</strong><br/><br/>}</pre>
<p>From the preceding code, you can see how declaring a function is a simple; we use the same syntax of the <kbd>contructor</kbd> declaration. If you want to use the properties declared in the <kbd>App</kbd> class, you have to use the <kbd>this</kbd> reserved word to access any property or function.</p>
<p>Now it is time to invoke our <kbd>changeMessage</kbd> function. First, we will create a button in our template in the <kbd>app.html</kbd> file and declare a trigger to the <kbd>click</kbd> event of the button. Open the <kbd>app.html</kbd> file and apply the following changes:</p>
<pre>&lt;template&gt;<br/>  &lt;h1&gt;${message}&lt;/h1&gt;<br/>  &lt;button <strong>click.trigger="changeMessage()"</strong>&gt;Change&lt;/button&gt;<br/>&lt;/template&gt;</pre>
<p>The first thing to note here is that we don't use the default HTML <kbd>onclick</kbd> event; instead, we use the <kbd>click</kbd> event with no <kbd>on</kbd> at the start of the event name. This convention is used only for the Aurelia templating engine. So, we say that we want to invoke the <kbd>changeMessage()</kbd> functions by binding this function to the <kbd>click</kbd> event using the <kbd>trigger</kbd> binding mechanism.</p>
<p>Launch your app by executing the <kbd>au run</kbd> command in your Terminal, and test this out. When you click on the Change button, you should see how the message is changed from <kbd>'Hello World!'</kbd> to <kbd>'World-Cup' App</kbd>. The <kbd>h1</kbd> HTML element is changed because we have previously declared and bound the <kbd>${message}</kbd> property into its content.</p>
<p>Binding is a big concept we will cover in next chapters in a more detailed way. So, keep reading my friend, it just starting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned how Aurelia is different from other popular frameworks; we compared Aurelia to ReactJS and Angular. We saw that Aurelia is more lightweight and has better performance, but the most important thing is that Aurelia is based on the ECMAScript 6 standard. So, instead of learning a framework, with Aurelia, you are learning an International Standard.</p>
<p>Also, we installed NodeJS and the NPM; these two open source technologies are extremely important, because Aurelia requires them in order to set our development environment and install our dependencies.</p>
<p>We explored the Aurelia command-line tool in detail, dived into its capabilities, and now you are familiar with it and are able to create, launch, test, and build your apps.</p>
<p>Finally, we talked about the example application we will build—an awesome FIFA World Cup single-page application. You also learned what an Aurelia component is and understood the way they split the view model and the template into two separate files that have to use the same filename with the <kbd>.js</kbd> and <kbd>.html</kbd> extensions, respectively.</p>
<p>In the next chapter, you will learn how to apply style and color to our application by installing and configuring the Google Material Design plugin in our app. Enjoy the next chapter!</p>


            

            
        
    </body></html>