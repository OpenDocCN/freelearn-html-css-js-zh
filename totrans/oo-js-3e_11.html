<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Coding and Design Patterns</h1></div></div></div><p>Now that you know all about the objects in JavaScript, mastered prototypes and inheritance, and seen some practical examples of using browser-specific objects, let's move forward, or rather, move a level up. Let's take a look at some common JavaScript patterns.</p><p>But first, what's a pattern? In short, a pattern is a good solution to a common problem. Codifying the solution into a pattern makes it repeatable as well.</p><p>Sometimes, when you're facing a new programming problem, you may recognize right away that you've previously solved another, suspiciously similar problem. In such cases, it's worth isolating this class of problems and searching for a common solution. A pattern is a proven and reusable solution (or an approach to a solution) to a class of problems.</p><p>There are cases where a pattern is nothing more than an idea or a name. Sometimes, just using a name helps you think more clearly about a problem. Also, when working with other developers in a team, it's much easier to communicate when everybody uses the same terminology to discuss a problem or a solution.</p><p>Other times, you may come across a unique problem that doesn't look like anything you've seen before and doesn't readily fit into a known pattern. Blindly applying a pattern just for the sake of using a pattern, is not a good idea. It's preferable to not use any known pattern than to try to tweak your problem so that it fits an existing solution.</p><p>This chapter talks about two types of patterns, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Coding patterns</strong>: These are mostly JavaScript-specific best practices</li><li class="listitem" style="list-style-type: disc"><strong>Design patterns</strong>: These are language-independent patterns, popularized by the famous <em>Gang of Four</em> book</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Coding patterns</h1></div></div></div><p>Let's start with some patterns that reflect JavaScript's unique features. Some patterns aim to help you organize your code, for example, namespacing; others are related to improving performance, such as lazy definitions and init-time branching; and some make up for missing features, such as private properties. The patterns discussed in this section include the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Separating behavior</li><li class="listitem" style="list-style-type: disc">Namespaces</li><li class="listitem" style="list-style-type: disc">Init-time branching</li><li class="listitem" style="list-style-type: disc">Lazy definition</li><li class="listitem" style="list-style-type: disc">Configuration objects</li><li class="listitem" style="list-style-type: disc">Private variables and methods</li><li class="listitem" style="list-style-type: disc">Privileged methods</li><li class="listitem" style="list-style-type: disc">Private functions as public methods</li><li class="listitem" style="list-style-type: disc">Immediate functions</li><li class="listitem" style="list-style-type: disc">Chaining</li><li class="listitem" style="list-style-type: disc">JSON</li></ul></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec144"/>Separating behavior</h2></div></div></div><p>As discussed previously, the three building blocks of a web page are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Content (HTML)</li><li class="listitem" style="list-style-type: disc">Presentation (CSS)</li><li class="listitem" style="list-style-type: disc">Behavior (JavaScript)</li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec74"/>Content</h3></div></div></div><p>HTML is the content of the web page, the actual text. Ideally, the content should be marked-up using the least amount of HTML tags that sufficiently describe the semantic meaning of that content. For example, if you're working on a navigation menu, it's a good idea to use the <code class="literal">&lt;ul&gt;</code> and <code class="literal">&lt;li&gt;</code> tags as a navigation menu is in essence, just a list of links.</p><p>Your content (HTML) should be free from any formatting elements. Visual formatting belongs to the presentation layer and should be achieved through the use of <strong>CSS</strong> (<strong>Cascading Style Sheets</strong>). This means the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The style attribute of HTML tags should not be used, if possible.</li><li class="listitem" style="list-style-type: disc">Presentational HTML tags such as <code class="literal">&lt;font&gt;</code> should not be used at all.</li><li class="listitem" style="list-style-type: disc">Tags should be used for their semantic meaning, not because of how browsers render them by default. For instance, developers sometimes use a <code class="literal">&lt;div&gt;</code> tag where a <code class="literal">&lt;p&gt;</code> would be more appropriate. It's also favorable to use <code class="literal">&lt;strong&gt;</code> and <code class="literal">&lt;em&gt;</code> instead of <code class="literal">&lt;b&gt;</code> and <code class="literal">&lt;i&gt;</code> as the latter describe the visual presentation rather than the meaning.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec75"/>Presentation</h3></div></div></div><p>A good approach to keep presentation out of the content is to reset or nullify all browser defaults, for example, using <code class="literal">reset.css</code> from the Yahoo! UI library. This way, the browser's default rendering won't distract you from consciously thinking about the proper semantic tags to use.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec76"/>Behavior</h3></div></div></div><p>The third component of a web page is the behavior. Behavior should be kept separate from both the content and the presentation. It is usually added by using JavaScript that is isolated to <code class="literal">&lt;script&gt;</code> tags, and preferably contained in external files. This means not using any inline attributes, such as <code class="literal">onclick</code>, <code class="literal">onmouseover</code>, and so on. Instead, you can use the <code class="literal">addEventListener</code>/<code class="literal">attachEvent</code> methods from the previous chapter.</p><p>The best strategy to separate behavior from content is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Minimize the number of <code class="literal">&lt;script&gt;</code> tags</li><li class="listitem" style="list-style-type: disc">Avoid inline event handlers</li><li class="listitem" style="list-style-type: disc">Do not use CSS expressions</li><li class="listitem" style="list-style-type: disc">Toward the end of your content, when you are ready to close the <code class="literal">&lt;body&gt;</code> tag, insert a single <code class="literal">external.js</code> file</li></ul></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec5"/>Example of separating behavior</h4></div></div></div><p>Let's say you have a search form on a page, and you want to validate the form with JavaScript. So, you go ahead and keep the <code class="literal">form</code> tags free from any JavaScript, and then immediately before closing the <code class="literal">&lt;/body&gt;</code> tag, you insert a <code class="literal">&lt;script&gt;</code> tag that links to an external file, as follows:</p><pre class="programlisting">    &lt;body&gt; &#13;
      &lt;form id="myform" method="post" action="server.php"&gt; &#13;
      &lt;fieldset&gt; &#13;
        &lt;legend&gt;Search&lt;/legend&gt; &#13;
        &lt;input &#13;
          name="search" &#13;
          id="search" &#13;
          type="text"   &#13;
        /&gt; &#13;
        &lt;input type="submit" /&gt; &#13;
        &lt;/fieldset&gt; &#13;
      &lt;/form&gt; &#13;
      &lt;script src="img/behaviors.js"&gt;&lt;/script&gt; &#13;
    &lt;/body&gt; &#13;
</pre><p>In <code class="literal">behaviors.js</code> you attach an event listener to the submit event. In your listener, you can check to see if the text input field was left blank and, if so, stop the form from being submitted. This way, you will save a roundtrip between the server and the client and make the application immediately responsive.</p><p>The content of <code class="literal">behaviors.js</code> is given in the following code. It assumes that you've created your <code class="literal">myevent</code> utility from the exercise at the end of the previous chapter:</p><pre class="programlisting">    // init &#13;
    myevent.addListener('myform', 'submit', function (e) { &#13;
      // no need to propagate further &#13;
      e = myevent.getEvent(e); &#13;
      myevent.stopPropagation(e); &#13;
      // validate &#13;
      var el = document.getElementById('search'); &#13;
      if (!el.value) { // too bad, field is empty &#13;
        myevent.preventDefault(e); // prevent the form submission &#13;
        alert('Please enter a search string'); &#13;
      } &#13;
    }); &#13;
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec77"/>Asynchronous JavaScript loading</h3></div></div></div><p>You noticed how the script was loaded at the end of the HTML, right before closing the body. The reason is that JavaScript blocks the DOM construction of the page, and in some browsers, even downloads of the other components that follow. By moving the scripts to the bottom of the page, you ensure that the script is out of the way, and when it arrives, it simply enhances the already usable page.</p><p>Another way to prevent external JavaScript files from blocking the page is to load them asynchronously. This way you can start loading them earlier. HTML5 has the <code class="literal">defer</code> attribute for this purpose. Consider the following line of code:</p><pre class="programlisting">    &lt;script defer src="img/behaviors.js"&gt;&lt;/script&gt; &#13;
</pre><p>Unfortunately, the <code class="literal">defer</code> attribute is not supported by older browsers, but luckily, there is a solution that works across browsers, old and new. The solution is to create a <code class="literal">script</code> node dynamically and append it to the DOM. In other words, you can use a bit of inline JavaScript to load the external JavaScript file. You can have this script loader snippet at the top of your document so that the download has an early start. Take a look at the following code example:</p><pre class="programlisting">    ... &#13;
    &lt;head&gt; &#13;
    &lt;script&gt; &#13;
    (function () { &#13;
      var s = document.createElement('script'); &#13;
      s.src = 'behaviors.js'; &#13;
      document.getElementsByTagName('head')[0].appendChild(s); &#13;
    }()); &#13;
    &lt;/script&gt; &#13;
    &lt;/head&gt; &#13;
    ... &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec145"/>Namespaces</h2></div></div></div><p>Global variables should be avoided in order to reduce the possibility of variable naming collisions. You can minimize the number of globals by namespacing your variables and functions. The idea is simple, you will create only one global object, and all your other variables and functions become properties of that object.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec78"/>An Object as a namespace</h3></div></div></div><p>Let's create a global object called <code class="literal">MYAPP</code>:</p><pre class="programlisting">    // global namespace &#13;
    var MYAPP = MYAPP || {}; &#13;
</pre><p>Now, instead of having a global <code class="literal">myevent</code> utility (from the previous chapter), you can have it as an <code class="literal">event</code> property of the <code class="literal">MYAPP</code> object, as follows:</p><pre class="programlisting">    // sub-object &#13;
    MYAPP.event = {}; &#13;
</pre><p>Adding the methods to the <code class="literal">event</code> utility is still the same. Consider the following example:</p><pre class="programlisting">    // object together with the method declarations &#13;
    MYAPP.event = { &#13;
      addListener: function (el, type, fn) { &#13;
        // .. do the thing &#13;
      }, &#13;
      removeListener: function (el, type, fn) { &#13;
        // ... &#13;
      }, &#13;
      getEvent: function (e) { &#13;
        // ... &#13;
      } &#13;
      // ... other methods or properties &#13;
    }; &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec79"/>Namespaced constructors</h3></div></div></div><p>Using a namespace doesn't prevent you from creating constructor functions. Here is how you can have a DOM utility that has an <code class="literal">Element</code> constructor, which allows you to create DOM elements easily:</p><pre class="programlisting">    MYAPP.dom = {}; &#13;
    MYAPP.dom.Element = function (type, properties) { &#13;
      var tmp = document.createElement(type); &#13;
      for (var i in properties) { &#13;
        if (properties.hasOwnProperty(i)) { &#13;
          tmp.setAttribute(i, properties[i]); &#13;
        } &#13;
      } &#13;
       return tmp; &#13;
    }; &#13;
</pre><p>Similarly, you can have a <code class="literal">Text</code> constructor to create text nodes. Consider the following code example:</p><pre class="programlisting">    MYAPP.dom.Text = function (txt) { &#13;
      return document.createTextNode(txt); &#13;
    }; &#13;
</pre><p>Using the constructors to create a link at the bottom of a page can be done as follows:</p><pre class="programlisting">    var link = new MYAPP.dom.Element('a',  &#13;
      {href: 'http://phpied.com', target: '_blank'}); &#13;
    var text = new MYAPP.dom.Text('click me'); &#13;
    link.appendChild(text); &#13;
    document.body.appendChild(link); &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec80"/>A namespace() method</h3></div></div></div><p>You can create a namespace utility that makes your life easier so that you can use more convenient syntax as follows:</p><pre class="programlisting">    MYAPP.namespace('dom.style'); &#13;
</pre><p>Instead of the more verbose syntax as follows:</p><pre class="programlisting">    MYAPP.dom = {}; &#13;
    MYAPP.dom.style = {}; &#13;
</pre><p>Here's how you can create such a <code class="literal">namespace()</code> method. First, you will create an array by splitting the input string using the period (<code class="literal">.</code>) as a separator. Then, for every element in the new array, you will add a property to your global object, if one doesn't already exist, as follows:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.namespace = function (name) { &#13;
      var parts = name.split('.'); &#13;
      var current = MYAPP; &#13;
      for (var i = 0; i &lt; parts.length; i++) { &#13;
        if (!current[parts[i]]) { &#13;
          current[parts[i]] = {}; &#13;
        } &#13;
        current = current[parts[i]]; &#13;
      } &#13;
    }; &#13;
</pre><p>Testing the new method is done as follows:</p><pre class="programlisting">    MYAPP.namespace('event'); &#13;
    MYAPP.namespace('dom.style'); &#13;
</pre><p>The result of the preceding code is the same as if you did the following:</p><pre class="programlisting">    var MYAPP = { &#13;
      event: {}, &#13;
      dom: { &#13;
        style: {} &#13;
      } &#13;
    }; &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec146"/>Init-time branching</h2></div></div></div><p>In the previous chapter, you noticed that sometimes, different browsers have different implementations for the same or similar functionalities. In such cases, you will need to branch your code, depending on what's supported by the browser currently executing your script. Depending on your program, this branching can happen far too often and, as a result, may slow down the script execution.</p><p>You can mitigate this problem by branching some parts of the code during initialization, when the script loads, rather than during runtime. Building upon the ability to define functions dynamically, you can branch and define the same function with a different body, depending on the browser. Let's see how.</p><p>First, let's define a namespace and placeholder method for the <code class="literal">event</code> utility:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.event = { &#13;
      addListener: null, &#13;
      removeListener: null &#13;
    }; &#13;
</pre><p>At this point, the methods to add or remove a listener are not implemented. Based on the results from feature sniffing, these methods can be defined differently, as follows:</p><pre class="programlisting">    if (window.addEventListener) { &#13;
      MYAPP.event.addListener = function (el, type, fn) { &#13;
        el.addEventListener(type, fn, false); &#13;
      }; &#13;
      MYAPP.event.removeListener = function (el, type, fn) { &#13;
        el.removeEventListener(type, fn, false); &#13;
      }; &#13;
    } else if (document.attachEvent) { // IE &#13;
      MYAPP.event.addListener = function (el, type, fn) { &#13;
        el.attachEvent('on' + type, fn); &#13;
      }; &#13;
      MYAPP.event.removeListener = function (el, type, fn) { &#13;
        el.detachEvent('on' + type, fn); &#13;
      }; &#13;
    } else { // older browsers &#13;
      MYAPP.event.addListener = function (el, type, fn) { &#13;
        el['on' + type] = fn; &#13;
      }; &#13;
      MYAPP.event.removeListener = function (el, type) { &#13;
        el['on' + type] = null; &#13;
      }; &#13;
    } &#13;
</pre><p>After this script executes, you have the <code class="literal">addListener()</code> and <code class="literal">removeListener()</code> methods defined in a browser-dependent way. Now, every time you invoke one of these methods, there's no more feature-sniffing, and it results in less work and faster execution.</p><p>One thing to watch out for when sniffing features is not to assume too much after checking for one feature. In the previous example, this rule is broken because the code only checks for <code class="literal">addEventListener</code> support, but then defines both <code class="literal">addListener()</code> and <code class="literal">removeListener()</code>. In this case, it's probably safe to assume that if a browser implements <code class="literal">addEventListener()</code>, it also implements <code class="literal">removeEventListener()</code>. However, imagine what happens if a browser implements <code class="literal">stopPropagation()</code> but not <code class="literal">preventDefault()</code>, and you haven't checked for these individually. You have assumed that because <code class="literal">addEventListener()</code> is not defined, the browser must be an old IE and write your code using your knowledge and assumptions of how IE works. Remember that all of your knowledge is based on the way a certain browser works today, but not necessarily the way it will work tomorrow. So, to avoid many rewrites of your code as new browser versions are shipped, it's best to individually check for features you intend to use and don't generalize on what a certain browser supports.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec147"/>Lazy definition</h2></div></div></div><p>The lazy definition pattern is similar to the previous init-time branching pattern. The difference is that the branching happens only when the function is called for the first time. When the function is called, it redefines itself with the best implementation. Unlike the init-time branching, where the if happens once, during loading, here it may not happen at all, in cases when the function is never called. The lazy definition also makes the initialization process lighter as there's no init-time branching work to be done.</p><p>Let's see an example that illustrates this via the definition of an <code class="literal">addListener()</code> function. The function is first defined with a generic body. It checks which functionality is supported by the browser when it's called for the first time and then redefines itself using the most suitable implementation. At the end of the first call, the function calls itself, so that the actual event attaching is performed. The next time you call the same function, it will be defined with its new body and be ready for use, so no further branching is necessary. The following is the code snippet:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.myevent = { &#13;
     addListener: function (el, type, fn) { &#13;
        if (el.addEventListener) { &#13;
          MYAPP.myevent.addListener = function (el, type, fn) { &#13;
            el.addEventListener(type, fn, false); &#13;
          }; &#13;
        } else if (el.attachEvent) { &#13;
          MYAPP.myevent.addListener = function (el, type, fn) { &#13;
            el.attachEvent('on' + type, fn); &#13;
          }; &#13;
        } else { &#13;
          MYAPP.myevent.addListener = function (el, type, fn) { &#13;
            el['on' + type] = fn; &#13;
          }; &#13;
        } &#13;
        MYAPP.myevent.addListener(el, type, fn); &#13;
      } &#13;
    }; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec148"/>Configuration object</h2></div></div></div><p>This pattern is convenient when you have a function or method that accepts a lot of optional parameters. It's up to you to decide how many constitutes a lot. But generally, a function with more than three parameters is not convenient to call, because you have to remember the order of the parameters, and it is even more inconvenient when some of the parameters are optional.</p><p>Instead of having many parameters, you can use one parameter and make it an object. The properties of the object are the actual parameters. This is suitable to pass configuration options because these tend to be numerous and optional (with smart defaults). The beauty of using a single object as opposed to multiple parameters is described as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The order doesn't matter</li><li class="listitem" style="list-style-type: disc">You can easily skip parameters that you don't want to set</li><li class="listitem" style="list-style-type: disc">It's easy to add more optional configuration attributes</li><li class="listitem" style="list-style-type: disc">It makes the code more readable because the configuration object's properties are present in the calling code along with their names</li></ul></div><p>Imagine you have some sort of UI widget constructor you use to create fancy buttons. It accepts the text to put inside the button (the <code class="literal">value</code> attribute of the <code class="literal">&lt;input&gt;</code> tag) and an optional parameter of the <code class="literal">type</code> of button. For simplicity, let's say the fancy button takes the same configuration as a regular button. Take a look at the following code:</p><pre class="programlisting">    // a constructor that creates buttons &#13;
    MYAPP.dom.FancyButton = function (text, type) { &#13;
      var b = document.createElement('input'); &#13;
      b.type = type || 'submit'; &#13;
      b.value = text; &#13;
      return b; &#13;
    }; &#13;
</pre><p>Using the constructor is simple; you just give it a string. Then, you can add the new button to the body of the document as follows:</p><pre class="programlisting">    document.body.appendChild( &#13;
      new MYAPP.dom.FancyButton('puuush') &#13;
    ); &#13;
</pre><p>This is all well and works fine, but then you decide you also want to be able to set some of the style properties of the button, such as colors and fonts. You can end up with a definition like the following:</p><pre class="programlisting">    MYAPP.dom.FancyButton =  &#13;
      function (text, type, color, border, font) { &#13;
      // ... &#13;
    }; &#13;
</pre><p>Now, using the constructor can become a little inconvenient, especially when you want to set the third and fifth parameter, but not the second or the fourth. Consider the following example:</p><pre class="programlisting">    new MYAPP.dom.FancyButton( &#13;
      'puuush', null, 'white', null, 'Arial'); &#13;
</pre><p>A better approach is to use one <code class="literal">config</code> object parameter for all the settings. The function definition can become something like the following code snippet:</p><pre class="programlisting">    MYAPP.dom.FancyButton = function (text, conf) { &#13;
      var type = conf.type || 'submit'; &#13;
      var font = conf.font || 'Verdana'; &#13;
      // ... &#13;
    }; &#13;
</pre><p>Using the constructor is shown as follows:</p><pre class="programlisting">    var config = { &#13;
      font: 'Arial, Verdana, sans-serif', &#13;
      color: 'white' &#13;
    }; &#13;
    new MYAPP.dom.FancyButton('puuush', config); &#13;
</pre><p>Another usage example is as follows:</p><pre class="programlisting">    document.body.appendChild( &#13;
      new MYAPP.dom.FancyButton('dude', {color: 'red'}) &#13;
    ); &#13;
</pre><p>As you can see, it's easy to set only some of the parameters and to switch around their order. In addition, the code is friendlier and easier to understand when you see the names of the parameters at the same place where you call the method.</p><p>A drawback of this pattern is the same as its strength. It's trivial to keep adding more parameters, which means trivial to abuse the technique. Once you have an excuse to add to this free-for-all bag of properties, you will find it tempting to keep adding some that are not entirely optional, or some that are dependent on other properties.</p><p>As a rule of thumb, all these properties should be independent and optional. If you have to check all possible combinations inside your function ("oh, A is set, but A is only used if B is also set"), this is a recipe for a large function body, which quickly becomes confusing and difficult, if not impossible, to test, because of all the combinations.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec149"/>Private properties and methods</h2></div></div></div><p>JavaScript doesn't have the notion of access modifiers, which set the privileges of the properties in an object. Other languages often have access modifiers, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Public</code>: All users of an object can access these properties or methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">Private</code>: Only the object itself can access these properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">Protected</code>: Only objects inheriting the object in question can access these properties</li></ul></div><p>JavaScript doesn't have a special syntax to denote private properties or methods, but as discussed in <a class="link" href="ch03.html" title="Chapter 3. Functions">Chapter 3</a>, <em>Functions</em>, you can use local variables and methods inside a function and achieve the same level of protection.</p><p>Continuing with the example of the <code class="literal">FancyButton</code> constructor, you can have local variable styles that contains all the defaults, and a local <code class="literal">setStyle()</code> function. These are invisible to the code outside of the constructor. Here's how <code class="literal">FancyButton</code> can make use of the local private properties:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.dom = {}; &#13;
    MYAPP.dom.FancyButton = function (text, conf) { &#13;
      var styles = { &#13;
        font: 'Verdana', &#13;
        border: '1px solid black', &#13;
        color: 'black', &#13;
        background: 'grey' &#13;
      }; &#13;
      function setStyles(b) { &#13;
        var i; &#13;
        for (i in styles) { &#13;
          if (styles.hasOwnProperty(i)) { &#13;
            b.style[i] = conf[i] || styles[i]; &#13;
          } &#13;
       } &#13;
      } &#13;
      conf = conf || {}; &#13;
      var b = document.createElement('input'); &#13;
      b.type = conf.type || 'submit'; &#13;
      b.value = text; &#13;
      setStyles(b); &#13;
      return b; &#13;
    }; &#13;
</pre><p>In this implementation, <code class="literal">styles</code> is a private property and <code class="literal">setStyle()</code> is a private method. The constructor uses them internally (and they can access anything inside the constructor), but they are not available to code outside of the function.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec150"/>Privileged methods</h2></div></div></div><p>Privileged methods (this term was coined by Douglas Crockford) are normal public methods that can access private methods or properties. They can act like a bridge in making some of the private functionality accessible, but in a controlled manner, wrapped in a privileged method.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec151"/>Private functions as public methods</h2></div></div></div><p>Let's say you've defined a function that you absolutely need to keep intact, so you make it private. However, you also want to provide access to the same function, so that outside code can also benefit from it. In this case, you can assign the private function to a publicly available property.</p><p>Let's define <code class="literal">_setStyle()</code> and <code class="literal">_getStyle()</code> as private functions, but then assign them to the public <code class="literal">setStyle()</code> and <code class="literal">getStyle()</code>, consider the following example:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.dom = (function () { &#13;
      var _setStyle = function (el, prop, value) { &#13;
        console.log('setStyle'); &#13;
      }; &#13;
      var _getStyle = function (el, prop) { &#13;
        console.log('getStyle'); &#13;
      }; &#13;
      return { &#13;
        setStyle: _setStyle, &#13;
        getStyle: _getStyle, &#13;
        yetAnother: _setStyle &#13;
      }; &#13;
    }()); &#13;
</pre><p>Now, when you call <code class="literal">MYAPP.dom.setStyle()</code>, it invokes the private <code class="literal">_setStyle()</code> function. You can also overwrite <code class="literal">setStyle()</code> from the outside as follows:</p><pre class="programlisting">    MYAPP.dom.setStyle = function () {alert('b');}; &#13;
</pre><p>Now, the result is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MYAPP.dom.setStyle</code> points to the new function</li><li class="listitem" style="list-style-type: disc"><code class="literal">MYAPP.dom.yetAnother</code> still points to <code class="literal">_setStyle()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">_setStyle()</code> is always available when any other internal code relies on it to be working as intended, regardless of the outside code</li></ul></div><p>When you expose something private, keep in mind that objects (functions and arrays are objects too) are passed by reference and, therefore, can be modified from the outside.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec152"/>Immediate functions</h2></div></div></div><p>Another pattern that helps you keep the global namespace clean is to wrap your code in an anonymous function and execute that function immediately. This way, any variables inside the function are local, as long as you use the <code class="literal">var</code> statement, and are destroyed when the function returns, if they aren't part of a closure. This pattern was discussed in more detail in <a class="link" href="ch03.html" title="Chapter 3. Functions">Chapter 3</a>, <em>Functions</em>. Take a look at the following code:</p><pre class="programlisting">    (function () { &#13;
      // code goes here... &#13;
    }()); &#13;
</pre><p>This pattern is especially suitable for on-off initialization task, performed when the script loads.</p><p>The immediate self-executing function pattern can be extended to create and return objects. If the creation of these objects is more complicated and involves some initialization work, then you can do this in the first part of the self-executable function and return a single object that can access and benefit from any private properties at the top portion, as follows:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.dom = (function () { &#13;
      // initialization code... &#13;
      function _private() { &#13;
        // ...  &#13;
      } &#13;
      return { &#13;
        getStyle: function (el, prop) { &#13;
          console.log('getStyle'); &#13;
          _private(); &#13;
        }, &#13;
        setStyle: function (el, prop, value) { &#13;
          console.log('setStyle'); &#13;
        } &#13;
      }; &#13;
    }()); &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec153"/>Modules</h2></div></div></div><p>Combining several of the previous patterns gives you a new pattern, commonly referred to as a module pattern. The concept of modules in programming is convenient as it allows you to code separate pieces or libraries and combine them as needed, just like pieces of a puzzle.</p><p>The module pattern includes the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Namespaces to reduce naming conflicts among modules</li><li class="listitem" style="list-style-type: disc">An immediate function to provide a private scope and initialization</li><li class="listitem" style="list-style-type: disc">Private properties and methods</li></ul></div><div><div><h3 class="title"><a id="note27"/>Note</h3><p>ES5 doesn't have a built-in concept of modules. There is the module specification from <a class="ulink" href="http://www.commonjs.org">http://www.commonjs.org</a>, which defines a <code class="literal">require()</code> function and an exports object.
ES6, however, supports modules. <a class="link" href="ch08.html" title="Chapter 8. Classes and Modules">Chapter 8</a>, Classes and Modules has covered modules in detail.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Returning an object that has the public API of the module as follows:<pre class="programlisting">        namespace('MYAPP.module.amazing'); &#13;
 &#13;
        MYAPP.module.amazing = (function () { &#13;
 &#13;
          // short names for dependencies &#13;
          var another = MYAPP.module.another; &#13;
 &#13;
          // local/private variables &#13;
          var i, j; &#13;
 &#13;
          // private functions &#13;
          function hidden() {} &#13;
 &#13;
          // public API &#13;
          return { &#13;
            hi: function () { &#13;
              return "hello"; &#13;
            } &#13;
          }; &#13;
        }()); &#13;
</pre></li></ul></div><p>And, you can use the module in the following way:</p><pre class="programlisting">    MYAPP.module.amazing.hi(); // "hello" &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec154"/>Chaining</h2></div></div></div><p>Chaining is a pattern that allows you to invoke multiple methods on one line as if the methods are the links in a chain. This is convenient when calling several related methods. You invoke the next method on the result of the previous without the use of an intermediate variable.</p><p>Say you've created a constructor that helps you work with DOM elements. The code to create a new <code class="literal">&lt;span&gt;</code> tag that is added to the <code class="literal">&lt;body&gt;</code> tag can look something like the following:</p><pre class="programlisting">    var obj = new MYAPP.dom.Element('span'); &#13;
    obj.setText('hello'); &#13;
    obj.setStyle('color', 'red'); &#13;
    obj.setStyle('font', 'Verdana'); &#13;
    document.body.appendChild(obj); &#13;
</pre><p>As you know, constructors return the object referred to as <code class="literal">this</code> keyword that they create. You can make your methods, such as <code class="literal">setText()</code> and <code class="literal">setStyle()</code>, also return <code class="literal">this</code> keyword, which allows you to call the next method on the instance returned by the previous one. This way, you can chain method calls, as follows:</p><pre class="programlisting">    var obj = new MYAPP.dom.Element('span'); &#13;
    obj.setText('hello') &#13;
       .setStyle('color', 'red') &#13;
       .setStyle('font', 'Verdana'); &#13;
    document.body.appendChild(obj); &#13;
</pre><p>You don't even need the <code class="literal">obj</code> variable if you don't plan on using it after the new element has been added to the tree, so the code looks like the following:</p><pre class="programlisting">    document.body.appendChild( &#13;
      new MYAPP.dom.Element('span') &#13;
        .setText('hello') &#13;
        .setStyle('color', 'red') &#13;
        .setStyle('font', 'Verdana') &#13;
    );    &#13;
</pre><p>A drawback of this pattern is that it makes it a little harder to debug when an error occurs somewhere in a long chain, and you don't know which link is to blame because they are all on the same line.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec155"/>JSON</h2></div></div></div><p>Let's wrap up the coding patterns section of this chapter with a few words about JSON. JSON is not technically a coding pattern, but you can say that using it is a good pattern.</p><p>JSON is a popular lightweight format to exchange data. It's often preferred over XML when using <code class="literal">XMLHttpRequest()</code> to retrieve data from the server. There's nothing specifically interesting about <strong>JSON</strong> other than the fact that it's extremely convenient. The JSON format consists of data defined using object and array literals. Here is an example of a JSON string that your server can respond with after an <code class="literal">XHR</code> request:</p><pre class="programlisting">    { &#13;
      'name':   'Stoyan', &#13;
      'family': 'Stefanov', &#13;
      'books':  ['OOJS', 'JSPatterns', 'JS4PHP'] &#13;
    } &#13;
</pre><p>An XML equivalent of this will be something like the following piece of code:</p><pre class="programlisting">    &lt;?xml version="1.1" encoding="iso-8859-1"?&gt; &#13;
    &lt;response&gt; &#13;
      &lt;name&gt;Stoyan&lt;/name&gt; &#13;
      &lt;family&gt;Stefanov&lt;/family&gt; &#13;
      &lt;books&gt; &#13;
        &lt;book&gt;OOJS&lt;/book&gt; &#13;
        &lt;book&gt;JSPatterns&lt;/book&gt; &#13;
        &lt;book&gt;JS4PHP&lt;/book&gt; &#13;
      &lt;/books&gt; &#13;
    &lt;/response&gt; &#13;
</pre><p>First, you can see how JSON is lighter in terms of the number of bytes. However, the main benefit is not the smaller byte size, but the fact that it's trivial to work with JSON in JavaScript. Let's say, you've made an <code class="literal">XHR</code> request and have received a JSON string in the <code class="literal">responseText</code> property of the <code class="literal">XHR</code> object. You can convert this string of data into a working JavaScript object by simply using <code class="literal">eval()</code>. Consider the following example:</p><pre class="programlisting">    // warning: counter-example &#13;
    var response = eval('(' + xhr.responseText + ')'); &#13;
</pre><p>Now, you can access the data in <code class="literal">obj</code> as object properties as follows:</p><pre class="programlisting">    console.log(response.name); // "Stoyan" &#13;
    console.log(response.books[2]); // "JS4PHP" &#13;
</pre><p>The problem is that <code class="literal">eval()</code> is insecure, so it's best if you use the JSON object to parse the JSON data (a fallback for older browsers is available at <a class="ulink" href="http://json.org/">http://json.org/</a>). Creating an object from a JSON string is still trivial as follows:</p><pre class="programlisting">    var response = JSON.parse(xhr.responseText); &#13;
</pre><p>To do the opposite, that is, to convert an object to a JSON string, you can use the <code class="literal">stringify()</code> method, as follows:</p><pre class="programlisting">    var str = JSON.stringify({hello: "you"}); &#13;
</pre><p>Due to its simplicity, JSON has quickly become popular as a language-independent format to exchange data, and you can easily produce JSON on the server side using your preferred language. In PHP, for example, there are the <code class="literal">json_encode()</code> and <code class="literal">json_decode()</code> functions that let you serialize a PHP array or object into a JSON string, and vice versa.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec156"/>Higher order functions</h2></div></div></div><p>Functional programming was confined to a limited set of languages so far. With more languages adding features to support functional programming, interest in the area is gaining momentum. JavaScript is evolving to support common features of functional programming. You will gradually see a lot of code written in this style. It is important to understand the functional programming style, even if you don't feel inclined just yet to use it in your code.</p><p>Higher order functions are one of the important mainstays of functional programing. Higher order function is a function that does at least one of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Takes one or more functions as arguments</li><li class="listitem" style="list-style-type: disc">Returns a function as a result</li></ul></div><p>As functions are first class objects in JavaScript, passing and returning functions to and from a function is a pretty routine affair. Callbacks are higher order functions. Let's take a look at how we can take these two principles together and write a higher order function.</p><p>Let's write a <code class="literal">filter</code> function; this function filters out values from an array based on a criteria determined by a function. This function takes two arguments-a function, which returns a Boolean value, <code class="literal">true</code> for keeping this element.</p><p>For example, with this function, we are filtering all odd values from an array. Consider the following lines of code:</p><pre class="programlisting">    console.log([1, 2, 3, 4, 5].filter(function(ele){&#13;
      return ele % 2 == 0; })); &#13;
    //[2,4] &#13;
</pre><p>We are passing an anonymous function to the <code class="literal">filter</code> function as the first argument. This function returns a Boolean based on a condition that checks if the element is odd or even.</p><p>This is an example of one of the several higher order functions added to ECMAScript 5. The point we are trying to make here is that you will increasingly see similar patterns of usage in JavaScript. You must first understand how higher order functions work and later, once you are comfortable with the concept, try to incorporate them in your code as well.</p><p>With ES6 function syntax changes, it is even more elegant to write higher order functions. Let's take a small example in ES5 and see how that translates into its ES6 equivalent:</p><pre class="programlisting">    function add(x){ &#13;
      return function(y){ &#13;
        return y + x; &#13;
      }; &#13;
    } &#13;
     var add3 = add(3); &#13;
    console.log(add3(3));          // =&gt; 6 &#13;
    console.log(add(9)(10));       // =&gt; 19 &#13;
</pre><p>The <code class="literal">add</code> function takes <code class="literal">x</code> and returns a function that takes <code class="literal">y</code> as an argument and then returns value of expression <code class="literal">y+x</code>.</p><p>When we looked at arrow functions, we discussed that arrow functions return results of a single expression implicitly. So, the preceding function can be turned into an arrow function by making the body of the arrow function another arrow function. Take a look at the following example:</p><pre class="programlisting">    const add = x =&gt; y =&gt; y + x; &#13;
</pre><p>Here, we have an outer function, <code class="literal">x =&gt;</code> [inner function with <code class="literal">x</code> as argument], and we have an inner function, <code class="literal">y =&gt; y+x</code>.</p><p>This introduction will help you get familiar with the increasing usage of higher order functions, and their increased importance in JavaScript.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec86"/>Design patterns</h1></div></div></div><p>The second part of this chapter presents a JavaScript approach to a subset of the design patterns introduced by <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, an influential book most commonly referred to as the <em>Book of Four</em>, the <em>Gang of Four</em>, or <em>GoF</em> (after its four authors). The patterns discussed in the <em>GoF</em> book are divided into the three following groups:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creational patterns that deal with how objects are created (instantiated)</li><li class="listitem" style="list-style-type: disc">Structural patterns that describe how different objects can be composed in order to provide new functionality</li><li class="listitem" style="list-style-type: disc">Behavioral patterns that describe ways for objects to communicate with each other</li></ul></div><p>There are 23 patterns in the <em>Book of Four</em>, and more patterns have been identified since the book's publication. It's way beyond the scope of this book to discuss all of them, so the remainder of the chapter demonstrates only four, along with examples of their implementation in JavaScript. Remember that the patterns are more about interfaces and relationships rather than implementation. Once you have an understanding of a design pattern, it's often not difficult to implement it, especially in a dynamic language such as JavaScript.</p><p>The patterns discussed through the rest of the chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Singleton</li><li class="listitem" style="list-style-type: disc">Factory</li><li class="listitem" style="list-style-type: disc">Decorator</li><li class="listitem" style="list-style-type: disc">Observer</li></ul></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec157"/>Singleton pattern</h2></div></div></div><p>Singleton is a creational design pattern, meaning that its focus is on creating objects. It helps you when you want to make sure there is only one object of a given kind or class. In a classical language, this would mean that an instance of a class is only created once, and any subsequent attempts to create new objects of the same class would return the original instance.</p><p>In JavaScript, because there are no classes, a singleton is the default and most natural pattern. Every object is a singleton object.</p><p>The most basic implementation of the singleton in JavaScript is the object literal. Take a look at the following line of code:</p><pre class="programlisting">    var single = {}; &#13;
</pre><p>That was easy, right?</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec158"/>Singleton 2 pattern</h2></div></div></div><p>If you want to use a class-like syntax and still implement the singleton pattern, things become a bit more interesting. Let's say, you have a constructor called <code class="literal">Logger()</code>, and you want to be able to do something like the following:</p><pre class="programlisting">    var my_log = new Logger(); &#13;
    my_log.log('some event'); &#13;
 &#13;
    // ... 1000 lines of code later in a different scope ... &#13;
 &#13;
    var other_log = new Logger(); &#13;
    other_log.log('some new event'); &#13;
    console.log(other_log === my_log); // true &#13;
</pre><p>The idea is that, although you use <code class="literal">new</code>, only one instance needs to be created, and this instance is then returned in consecutive calls.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec81"/>Global variable</h3></div></div></div><p>One approach is to use a global variable to store the single instance. Your constructor could look like the following code snippet:</p><pre class="programlisting">    function Logger() { &#13;
      if (typeof global_log === "undefined") { &#13;
        global_log = this; &#13;
      } &#13;
      return global_log; &#13;
    } &#13;
</pre><p>Using this constructor gives the expected result, which is as follows:</p><pre class="programlisting">    var a = new Logger(); &#13;
    var b = new Logger(); &#13;
    console.log(a === b); // true &#13;
</pre><p>The drawback is, obviously, the use of a global variable. It can be overwritten at any time, even accidentally, and you can lose the instance. The opposite, your global variable overwriting someone else's is also possible.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec82"/>Property of the constructor</h3></div></div></div><p>As you know, functions are objects and they have properties. You can assign the single instance to a property of the constructor function, as follows:</p><pre class="programlisting">    function Logger() { &#13;
      if (!Logger.single_instance) { &#13;
        Logger.single_instance = this; &#13;
      } &#13;
      return Logger.single_instance; &#13;
    } &#13;
</pre><p>If you write <code class="literal">var a = new Logger()</code>, <code class="literal">a</code> points to the newly created <code class="literal">Logger.single_instance</code> property. A subsequent <code class="literal">var b = new Logger()</code> call results in <code class="literal">b</code> pointing to the same <code class="literal">Logger.single_instance</code> property, which is exactly what you want.</p><p>This approach certainly solves the global namespace issue because no global variables are created. The only drawback is that the property of the <code class="literal">Logger</code> constructor is publicly visible, so it can be overwritten at any time. In such cases, the single instance can be lost or modified. Of course, you can only provide so much protection against fellow programmers shooting themselves in the foot. After all, if someone can mess with the single-instance property, they can mess up the <code class="literal">Logger</code> constructor directly as well.
</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec83"/>In a private property</h3></div></div></div><p>The solution to the problem of overwriting the publicly visible property is not to use a public property, but a private one. You already know how to protect variables with a closure, so as an exercise, you can implement this approach to the singleton pattern.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec159"/>Factory pattern</h2></div></div></div><p>The factory is another creational design pattern, as it deals with creating objects. The factory can help you when you have similar types of objects and you don't know in advance which one you want to use. Based on user input or other criteria, your code determines the type of object it needs on the fly.</p><p>Let's say you have three different constructors that implement similar functionality. All the objects they create take a URL but do different things with it. One creates a text DOM node; the second creates a link; and the third, an image, as follows:</p><pre class="programlisting">    var MYAPP = {}; &#13;
    MYAPP.dom = {}; &#13;
    MYAPP.dom.Text = function (url) { &#13;
      this.url = url; &#13;
      this.insert = function (where) { &#13;
        var txt = document.createTextNode(this.url); &#13;
        where.appendChild(txt); &#13;
      }; &#13;
    }; &#13;
    MYAPP.dom.Link = function (url) { &#13;
      this.url = url; &#13;
      this.insert = function (where) { &#13;
        var link = document.createElement('a'); &#13;
        link.href = this.url; &#13;
        link.appendChild(document.createTextNode(this.url)); &#13;
        where.appendChild(link); &#13;
      }; &#13;
    }; &#13;
    MYAPP.dom.Image = function (url) { &#13;
      this.url = url; &#13;
      this.insert = function (where) { &#13;
        var im = document.createElement('img'); &#13;
        im.src = this.url; &#13;
        where.appendChild(im); &#13;
      }; &#13;
    }; &#13;
</pre><p>Using the three different constructors is exactly the same-pass the <code class="literal">url</code> variable and call the <code class="literal">insert()</code> method, as follows:</p><pre class="programlisting">    var url = 'http://www.phpied.com/images/covers/oojs.jpg'; &#13;
 &#13;
    var o = new MYAPP.dom.Image(url); &#13;
    o.insert(document.body); &#13;
 &#13;
    var o = new MYAPP.dom.Text(url); &#13;
    o.insert(document.body); &#13;
 &#13;
    var o = new MYAPP.dom.Link(url); &#13;
    o.insert(document.body); &#13;
</pre><p>Imagine your program doesn't know in advance which type of object is required. The user decides, during runtime, by clicking on a button for example. If <code class="literal">type</code> contains the required type of object, you'll need to use an <code class="literal">if</code> or a <code class="literal">switch</code> statement, and write something like the following piece of code:</p><pre class="programlisting">    var o; &#13;
    if (type === 'Image') { &#13;
      o = new MYAPP.dom.Image(url); &#13;
    } &#13;
    if (type === 'Link') { &#13;
      o = new MYAPP.dom.Link(url); &#13;
    } &#13;
    if (type === 'Text') { &#13;
      o = new MYAPP.dom.Text(url); &#13;
    } &#13;
    o.url = 'http://...'; &#13;
    o.insert(); &#13;
</pre><p>This works fine; however, if you have a lot of constructors, the code becomes too lengthy and hard to maintain. Also, if you are creating a library or a framework that allows extensions or plugins, you don't even know the exact names of all the constructor functions in advance. In such cases, it's convenient to have a factory function that takes care of creating an object of the dynamically determined type.</p><p>Let's add a factory method to the <code class="literal">MYAPP.dom</code> utility:</p><pre class="programlisting">    MYAPP.dom.factory = function (type, url) { &#13;
      return new MYAPP.dom[type](url); &#13;
    }; &#13;
</pre><p>Now, you can replace the three <code class="literal">if</code> functions with the simpler code, as follows:</p><pre class="programlisting">    var image = MYAPP.dom.factory("Image", url); &#13;
    image.insert(document.body); &#13;
</pre><p>The example <code class="literal">factory()</code> method in the previous code was simple; however, in a real-life scenario, you'd want to do some validation against the type value (for example, check if <code class="literal">MYAPP.dom[type]</code> exists) and optionally do some set up work common to all object types (for example, set up the URL all constructors use).</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec160"/>Decorator pattern</h2></div></div></div><p>The decorator design pattern is a structural pattern; it doesn't have much to do with how objects are created, but rather how their functionality is extended. Instead of using inheritance, where you extend in a linear way (parent-child-grandchild), you can have one base object and a pool of different decorator objects that provide extra functionality. Your program can pick and choose which decorators it wants, and in which order. For a different program or code path, you may have a different set of requirements and pick different decorators out of the same pool. Take a look at the following code snippet to see how the usage part of the decorator pattern can be implemented:</p><pre class="programlisting">    var obj = { &#13;
      doSomething: function () { &#13;
        console.log('sure, asap'); &#13;
      } &#13;
      //  ... &#13;
    }; &#13;
    obj = obj.getDecorator('deco1'); &#13;
    obj = obj.getDecorator('deco13'); &#13;
    obj = obj.getDecorator('deco5'); &#13;
    obj.doSomething(); &#13;
</pre><p>You can see how you can start with a simple object that has a <code class="literal">doSomething()</code> method. Then, you can pick one of the decorator objects you have lying around and which can be identified by name. All decorators provide a <code class="literal">doSomething()</code> method that first calls the same method of the previous decorator and then proceeds with its own code. Every time you add a decorator, you overwrite the base <code class="literal">obj</code> with an improved version of it. In the end, when you are finished adding decorators, you call <code class="literal">doSomething()</code>. As a result, all of the <code class="literal">doSomething()</code> methods of all the decorators are executed in sequence. Let's see an example.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec84"/>Decorating a christmas tree</h3></div></div></div><p>Let's illustrate the decorator pattern with an example of decorating a Christmas tree. You can start with the <code class="literal">decorate()</code> method as follows:</p><pre class="programlisting">    var tree = {}; &#13;
    tree.decorate = function () { &#13;
      alert('Make sure the tree won't fall'); &#13;
    }; &#13;
</pre><p>Now, let's implement a <code class="literal">getDecorator()</code> method that adds extra decorators. The decorators will be implemented as constructor functions, and they'll all inherit from the base <code class="literal">tree</code> object as follows:</p><pre class="programlisting">    tree.getDecorator = function (deco) { &#13;
      tree[deco].prototype = this; &#13;
      return new tree[deco]; &#13;
    }; &#13;
</pre><p>Now, let's create the first decorator, <code class="literal">RedBalls()</code>, as a property of <code class="literal">tree</code>, in order to keep the global namespace cleaner. The red ball objects also provide a <code class="literal">decorate()</code> method, but they make sure they call their parent's <code class="literal">decorate()</code> first. For example, take a look at the following code:</p><pre class="programlisting">    tree.RedBalls = function () { &#13;
      this.decorate = function () { &#13;
        this.RedBalls.prototype.decorate(); &#13;
        alert('Put on some red balls'); &#13;
      }; &#13;
    }; &#13;
</pre><p>Similarly, implement <code class="literal">BlueBalls()</code> and <code class="literal">Angel()</code> decorators as follows:</p><pre class="programlisting">    tree.BlueBalls = function () { &#13;
      this.decorate = function () { &#13;
        this.BlueBalls.prototype.decorate(); &#13;
        alert('Add blue balls'); &#13;
      }; &#13;
    }; &#13;
    tree.Angel = function () { &#13;
      this.decorate = function () { &#13;
        this.Angel.prototype.decorate(); &#13;
        alert('An angel on the top'); &#13;
      }; &#13;
    }; &#13;
</pre><p>Now, let's add all of the decorators to the base object, as shown in the following code snippet:</p><pre class="programlisting">    tree = tree.getDecorator('BlueBalls'); &#13;
    tree = tree.getDecorator('Angel'); &#13;
    tree = tree.getDecorator('RedBalls'); &#13;
</pre><p>Finally, run the <code class="literal">decorate()</code> method as follows:</p><pre class="programlisting">    tree.decorate(); &#13;
</pre><p>This single call results in the following alerts, specifically in this order:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure the tree won't fall.</li><li class="listitem">Add the blue balls.</li><li class="listitem">Add an angel at the top.</li><li class="listitem">Add some red balls.</li></ol></div><p>As you see, this functionality allows you to have as many decorators as you like, and to choose and combine them in any way you like.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec161"/>Observer pattern</h2></div></div></div><p>The observer pattern, also known as the <strong>subscriber-publisher</strong> pattern, is a behavioral pattern, which means that it deals with how different objects interact and communicate with each other. When implementing the observer pattern, you have the following objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One or more publisher objects that announce when they do something important.</li><li class="listitem" style="list-style-type: disc">One or more subscribers tuned in to one or more publishers. They listen to what the publishers announce and then act appropriately.</li></ul></div><p>The observer pattern may look familiar to you. It sounds similar to the browser events discussed in the previous chapter, and rightly so, because the browser events are one example application of this pattern. The browser is the publisher; it announces the fact that an event, such as a <code class="literal">click</code>, has happened. Your event listener functions that are subscribed to listen to this type of event will be notified when it happens. The browser-publisher sends an event object to all of the subscribers. In your custom implementations, you can send any type of data you find appropriate.</p><p>There are two subtypes of the observer pattern: push and pull. Push is where the publishers are responsible to notify each subscriber, and pull is where the subscribers monitor for changes in a publisher's state.</p><p>Let's take a look at an example implementation of the push model. Let's keep the observer-related code in a separate object and then use this object as a mix-in, adding its functionality to any other object that decides to be a publisher. In this way, any object can become a publisher and any function can become a subscriber. The observer object will have the following properties and methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An array of <code class="literal">subscribers</code> that are just callback functions</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> addSubscriber()</code>and <code class="literal">removeSubscriber()</code> methods that add to, and remove from, the <code class="literal">subscribers</code> collection</li><li class="listitem" style="list-style-type: disc">A <code class="literal">publish()</code> method that takes data and calls all subscribers, passing the data to them</li><li class="listitem" style="list-style-type: disc">A <code class="literal">make()</code> method that takes any object and turns it into a publisher by adding all of the methods mentioned previously to it</li></ul></div><p>Here's the observer mix-in object that contains all the subscription-related methods and can be used to turn any object into a publisher:</p><pre class="programlisting">    var observer = { &#13;
      addSubscriber: function (callback) { &#13;
        if (typeof callback === "function") { &#13;
          this.subscribers[this.subscribers.length] = callback; &#13;
        } &#13;
      }, &#13;
      removeSubscriber: function (callback) { &#13;
        for (var i = 0; i &lt; this.subscribers.length; i++) { &#13;
          if (this.subscribers[i] === callback) { &#13;
            delete this.subscribers[i]; &#13;
          } &#13;
        } &#13;
      }, &#13;
      publish: function (what) { &#13;
        for (var i = 0; i &lt; this.subscribers.length; i++) { &#13;
          if (typeof this.subscribers[i] === 'function') { &#13;
            this.subscribers[i](what); &#13;
          } &#13;
        } &#13;
      }, &#13;
      make: function (o) { // turns an object into a publisher &#13;
        for (var i in this) { &#13;
          if (this.hasOwnProperty(i)) { &#13;
            o[i] = this[i]; &#13;
            o.subscribers = []; &#13;
          } &#13;
        } &#13;
      } &#13;
   }; &#13;
</pre><p>Now, let's create some publishers. A publisher can be any object and its only duty is to call the <code class="literal">publish()</code> method whenever something important occurs. Here's a <code class="literal">blogger</code> object that calls <code class="literal">publish()</code> every time a new blog posting is ready:</p><pre class="programlisting">    var blogger = { &#13;
      writeBlogPost: function() { &#13;
        var content = 'Today is ' + new Date(); &#13;
        this.publish(content); &#13;
      } &#13;
    }; &#13;
</pre><p>Another object can be the LA Times newspaper that calls <code class="literal">publish()</code> when a new newspaper issue is out. Consider the following lines of code:</p><pre class="programlisting">    var la_times = { &#13;
      newIssue: function() { &#13;
        var paper = 'Martians have landed on Earth!'; &#13;
        this.publish(paper); &#13;
      } &#13;
    }; &#13;
</pre><p>You can turn these objects into publishers as follows:</p><pre class="programlisting">    observer.make(blogger); &#13;
    observer.make(la_times); &#13;
</pre><p>Now, let's have the following two simple objects, <code class="literal">jack</code> and <code class="literal">jill</code>:</p><pre class="programlisting">    var jack = { &#13;
      read: function(what) { &#13;
        console.log("I just read that " + what) &#13;
      } &#13;
    }; &#13;
    var jill = { &#13;
      gossip: function(what) { &#13;
        console.log("You didn't hear it from me, but " + what) &#13;
      } &#13;
    }; &#13;
</pre><p>The<code class="literal"> jack</code> and <code class="literal">jill</code> objects can subscribe to the <code class="literal">blogger</code> object by providing the callback methods they want to call when something is published, as follows:</p><pre class="programlisting">    blogger.addSubscriber(jack.read); &#13;
    blogger.addSubscriber(jill.gossip); &#13;
</pre><p>What happens now, when the <code class="literal">blogger</code> object writes a new post? The result is that <code class="literal">jack</code> and <code class="literal">jill</code> will get notified:</p><pre class="programlisting">    &gt; blogger.writeBlogPost(); &#13;
       I just read that Today is Fri Jan 04 2013 19:02:12 GMT-0800 (PST) &#13;
       You didn't hear it from me, but Today is Fri Jan 04 2013 19:02:12 GMT-0800    &#13;
         (PST) &#13;
</pre><p>At any time, <code class="literal">jill</code> may decide to cancel her subscription. Then, when writing another blog post, the unsubscribed object is no longer notified. Consider the following code snippet:</p><pre class="programlisting">    &gt; blogger.removeSubscriber(jill.gossip); &#13;
    &gt; blogger.writeBlogPost();&#13;
    I just read that Today is Fri Jan 04 2013 19:03:29 GMT-0800 (PST) &#13;
</pre><p>The <code class="literal">jill</code> object may decide to subscribe to LA Times, as an object can be a subscriber to many publishers, as follows:</p><pre class="programlisting">    &gt; la_times.addSubscriber(jill.gossip); &#13;
</pre><p>Then, when LA Times publishes a new issue, <code class="literal">jill</code> gets notified and <code class="literal">jill.gossip()</code> is executed, as follows:</p><pre class="programlisting">    &gt; la_times.newIssue();&#13;
    You didn't hear it from me, but Martians have landed on Earth! &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec87"/>Summary</h1></div></div></div><p>In this chapter, you learned about common JavaScript coding patterns and learned how to make your programs cleaner, faster, and better at working with other programs and libraries. Then, you saw a discussion and sample implementations of a handful of the design patterns from the <em>Book of Four</em>. You can see how JavaScript is a fully featured dynamic programming language, and that implementing classical patterns in a dynamic loosely typed language is pretty easy. The patterns are, in general, a large topic, and you can join the author of this book in a further discussion of the JavaScript patterns at <a class="ulink" href="http://www.jspatterns.com/">JSPatterns.com</a>, or take a look at the <em>JavaScript Patterns</em> book. The next chapter focuses on testing and debugging methodologies.</p></div></body></html>