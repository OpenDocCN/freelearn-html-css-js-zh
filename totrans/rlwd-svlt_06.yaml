- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Integrating Libraries with Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作整合库
- en: There are a lot of JavaScript UI libraries out there on the internet. However,
    at the time of writing this book, Svelte is relatively new. Not all the UI libraries
    out there are written using Svelte and written specifically for Svelte. But that
    does not mean that we can’t use them in our Svelte component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多JavaScript UI库。然而，在撰写本书时，Svelte相对较新。并不是所有的UI库都是用Svelte编写的，也不是专门为Svelte编写的。但这并不意味着我们不能在我们的Svelte组件中使用它们。
- en: There are many ways to integrate third-party JavaScript UI libraries into Svelte.
    In this chapter, we are going to explore how we can do it using Svelte actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将第三方JavaScript UI库集成到Svelte中。在本章中，我们将探讨如何使用Svelte操作来实现这一点。
- en: We will start by integrating an imaginary UI library, slowly building up our
    case for why Svelte actions are suitable for the job. Along the way, I will explain
    how to use Svelte actions for different scenarios and show you where Svelte actions
    fall short. I’ll discuss my reasonings and personal opinions on when to choose
    Svelte actions and when to choose otherwise.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先整合一个假设的UI库，逐步构建我们的案例，说明为什么Svelte操作适合这项工作。在这个过程中，我将解释如何使用Svelte操作处理不同的场景，并展示Svelte操作在哪些方面不足。我将讨论我选择Svelte操作和选择其他选项的理由和个人的观点。
- en: Following that, I will show you some real-world UI library examples. After that,
    we will explore integrating UI libraries written in other frameworks, such as
    React and Vue, with a few more examples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我将向你展示一些真实的UI库示例。然后，我们将探索如何使用更多示例将用其他框架（如React和Vue）编写的UI库集成到Svelte中。
- en: By the end of this chapter, you will see that you are not limited to using only
    UI libraries written in Svelte in your Svelte application – you can reuse any
    UI library that is available on the internet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将看到你不仅限于在你的Svelte应用程序中只使用用Svelte编写的UI库——你可以重用互联网上可用的任何UI库。
- en: 'This chapter covers the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Integrating JavaScript UI libraries into Svelte
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JavaScript UI库集成到Svelte中
- en: Why we should use actions to integrate UI libraries and other alternatives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用操作来整合UI库和其他替代方案
- en: Integrating UI libraries written in other frameworks into Svelte
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用其他框架编写的UI库集成到Svelte中
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the examples and code for this chapter here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的示例和代码：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06)。
- en: Integrating vanilla JavaScript UI libraries into Svelte
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将纯JavaScript UI库集成到Svelte中
- en: First, we will explore UI libraries that are written in vanilla JavaScript.
    When we use the phrase *vanilla JavaScript*, we’re referring to plain JavaScript,
    or JavaScript in the absence of frameworks or libraries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索用纯JavaScript编写的UI库。当我们使用“纯JavaScript”这个短语时，我们指的是普通的JavaScript，或者在没有框架或库的情况下使用的JavaScript。
- en: 'There are many reasons a UI library is written in vanilla JavaScript:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因使得UI库是用纯JavaScript编写的：
- en: Performance reasons – it would be much easier to optimize without the abstractions
    from the web framework
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能原因——没有Web框架的抽象，优化会更容易
- en: The library author’s personal preference to be framework-agnostic
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库作者的个性化偏好，希望库不依赖于任何框架
- en: The library was created predating any modern web frameworks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库是在任何现代Web框架之前创建的
- en: For us, vanilla JavaScript UI libraries are great because they do not depend
    on any specific framework runtime, which is an extra overhead on top of the UI
    library itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，纯JavaScript UI库很棒，因为它们不依赖于任何特定的框架运行时，这给UI库本身带来了额外的开销。
- en: For example, if we use a calendar component library that is implemented in React,
    then besides installing the calendar component library, we would need to install
    React’s framework as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用一个用React实现的日历组件库，那么除了安装日历组件库之外，我们还需要安装React的框架。
- en: This additional dependency leads to an increased bundle size and potential conflicts
    with Svelte. Therefore, when using a component library in Svelte, it is generally
    preferable to choose a library that does not depend on any specific framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的依赖导致包的大小增加，并且可能与Svelte发生冲突。因此，当在Svelte中使用组件库时，通常更倾向于选择不依赖于任何特定框架的库。
- en: Now that we have learned about why vanilla JavaScript UI libraries are great,
    let’s discuss how we can integrate them into Svelte. In this chapter, we will
    explore integrating libraries in Svelte using Svelte actions, which begs the question,
    why do we choose to use Svelte actions to integrate a UI library?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了为什么纯JavaScript UI库很棒，让我们讨论如何将它们集成到Svelte中。在本章中，我们将探索使用Svelte动作在Svelte中集成库，这引发了一个问题，为什么我们选择使用Svelte动作来集成UI库？
- en: Why use Svelte actions to integrate a UI library?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用Svelte动作来集成UI库？
- en: In the previous chapter, we explored how Svelte actions are useful for adding
    custom event handlers. At the same time, Svelte actions function as element-level
    life cycle functions, making them very useful for interfacing with third-party
    libraries. Now, let’s explore why that’s the case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Svelte动作在添加自定义事件处理程序方面的有用性。同时，Svelte动作作为元素级别的生命周期函数，这使得它们在与第三方库交互时非常有用。现在，让我们探讨为什么这是这种情况。
- en: Let’s take a calendar component library as an example. For simplicity’s sake
    and to not get bogged down by implementation details, let’s imagine the library
    as an imaginary library instead of using any real-life calendar component library.
    This allows us to focus on the general problem itself rather than the specific
    library’s implementation details.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个日历组件库为例。为了简化起见，并且避免被实现细节所困扰，让我们想象这个库是一个虚构的库，而不是使用任何真实的日历组件库。这使我们能够专注于一般问题本身，而不是特定库的实现细节。
- en: We will look at some real-life UI libraries afterward.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之后查看一些真实的UI库。
- en: To decide where the calendar component will be added to the DOM, component libraries
    usually require us to specify a container element to house the library component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定日历组件将被添加到DOM中的位置，组件库通常要求我们指定一个容器元素来容纳库组件。
- en: 'For example, here, `ImaginaryCalendar` requires us to pass the container element
    as part of the argument for the constructor:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，`ImaginaryCalendar`要求我们将容器元素作为构造函数参数的一部分传递：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To get the reference to an element in Svelte, we can use `bind:this`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Svelte中元素的引用，我们可以使用`bind:this`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `containerElement` variable is only updated with the reference of the element
    after the element is mounted, so it can only be referred to in `onMount`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerElement`变量仅在元素挂载后更新为元素的引用，因此它只能在`onMount`中引用：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that we are keeping the reference of the `calendar` instance because we
    can use it to call calendar methods to get or set values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们保留了对`calendar`实例的引用，因为我们可以使用它来调用日历方法以获取或设置值：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, we call `calendar.cleanup()` when the component unmounts for cleanup purposes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当组件卸载时，我们也调用`calendar.cleanup()`进行清理。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The calendar library is just an imaginary example. However, most UI libraries
    will provide similar APIs or methods to retrieve or modify the component instance’s
    internal state and clean up when they are no longer in use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 日历库只是一个虚构的例子。然而，大多数UI库都会提供类似的API或方法来检索或修改组件实例的内部状态，并在不再使用时进行清理。
- en: 'We need to be extra careful when we are using the `calendar` instance here.
    We want to avoid referencing the `calendar` instance before it is initialized
    to prevent encountering a reference error as the calendar instance is only declared
    and initialized after `onMount`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`calendar`实例时，我们需要格外小心。我们希望避免在初始化之前引用`calendar`实例，以防止在`calendar`实例仅在`onMount`之后声明和初始化时遇到引用错误：
- en: To be safe, we should check whether the `calendar` instance is defined before
    calling any of its methods. In the code example below, we verify if the calendar
    instance is defined, before calling the `calendar.setDate()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们应该在调用`calendar`实例的任何方法之前检查它是否已定义。在下面的代码示例中，我们在调用`calendar.setDate()`方法之前验证日历实例是否已定义。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The need for this extra level of cautiousness is more obvious when the calendar
    is conditionally created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当日历条件性地创建时，这种额外谨慎的需求更为明显：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, you can see that `<div>` is conditionally created based
    on `someCondition`. That is why in `onMount`, we need to check whether `containerElement`
    is available before we create `ImaginaryCalendar` using `containerElement` as
    a container. And the `calendar` instance is only available if `ImaginaryCalendar`
    is created, and thus only available if `someCondition` is `true`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到 `<div>` 是基于 `someCondition` 条件有条件地创建的。这就是为什么在 `onMount` 中，我们需要在用
    `containerElement` 作为容器创建 `ImaginaryCalendar` 之前检查 `containerElement` 是否可用。并且，只有当
    `ImaginaryCalendar` 被创建时，`calendar` 实例才可用，因此只有在 `someCondition` 为 `true` 时才可用。
- en: The preceding code illustrates one of the many possibilities where the `calendar`
    instance could be undefined.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码说明了 `calendar` 实例可能未定义的许多可能性之一。
- en: One thing to note about this code is that it is not behaviorally correct as
    it does not attempt to create `ImaginaryCalendar` whenever the value of `someCondition`
    turns from `false` to `true` and does cleanup whenever it turns back to `false`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码，有一点需要注意，它的行为是不正确的，因为它没有尝试在 `someCondition` 的值从 `false` 变为 `true` 时创建
    `ImaginaryCalendar`，也没有在它变回 `false` 时进行清理。
- en: This is where Svelte actions shine.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Svelte 操作大放异彩的地方。
- en: Using Svelte actions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Svelte 操作
- en: By altering the preceding code so that it uses actions, you will see that we
    do not need the extra check to ensure that `containerElement` is available before
    instantiating `ImaginaryCalendar`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改前面的代码，使其使用操作，你会发现我们不需要额外的检查来确保在实例化 `ImaginaryCalendar` 之前 `containerElement`
    是可用的。
- en: 'The following code shows how such an action could be implemented. Here, the
    name of our Svelte action is `calendar`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何实现这样的操作。在这里，我们的 Svelte 操作名为 `calendar`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is because, when using Svelte actions, the action function will only be
    called with the reference of the element whenever the element is created and mounted
    onto the DOM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，当使用 Svelte 操作时，操作函数只有在元素被创建并挂载到 DOM 上时才会被调用，并且只传递元素的引用。
- en: When the condition changes to such that the `<div>` element is removed from
    the DOM, the `destroy` method of the action will be called to clean things up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件改变到 `<div>` 元素从 DOM 中移除时，操作的 `destroy` 方法将被调用以清理资源。
- en: 'Using Svelte actions, we can now create as many `ImaginaryCalendar` instances
    as we want within one component by adding the action to different HTML elements:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Svelte 操作，我们现在可以在一个组件内创建任意多的 `ImaginaryCalendar` 实例，只需将操作添加到不同的 HTML 元素中：
- en: To prove my point, in the code snippet below, in addition to the original `<div>`
    element you’ve seen in the previous examples, I am adding another `<div>` element
    and three more `<div>` elements using the `{#each}` block. I am then applying
    the calendar actions to all four `<div>` elements to create four more calendars,
    and we do not run into any errors for having multiple calendars at once.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我的观点，在下面的代码片段中，除了在之前的例子中看到的原始 `<div>` 元素外，我还添加了另一个 `<div>` 元素和另外三个 `<div>`
    元素，使用 `{#each}` 块来实现。然后，我将日历操作应用于所有四个 `<div>` 元素，以创建四个更多的日历，并且一次创建多个日历时我们没有遇到任何错误。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we were to use `bind:this` and `onMount`, we would have to repeat ourselves
    multiple times by declaring multiple `containerElement` variables multiple times
    and instantiate `ImaginaryCalendar` with each of the `containerElement` variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用 `bind:this` 和 `onMount`，我们就必须多次重复自己，通过多次声明多个 `containerElement` 变量，并使用每个
    `containerElement` 变量实例化 `ImaginaryCalendar`。
- en: Now, with the `calendar` instance encapsulated within the action, how should
    we call the `calendar` instance method to update the `calendar` state from the
    outside?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着 `calendar` 实例被封装在操作中，我们应该如何从外部调用 `calendar` 实例方法来更新 `calendar` 状态？
- en: That’s what the action data is for!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是操作数据的作用！
- en: Adding data to Svelte actions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 Svelte 操作添加数据
- en: In the previous section, we created a `calendar` action and instantiated an
    `ImaginaryCalendar` instance inside that action. If we want to call an instance
    method of `ImaginaryCalendar` outside the `calendar` action, such as calling `calendar.setDate(date)`
    to set the date of the calendar, what should we do?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了一个 `calendar` 操作并在其中实例化了 `ImaginaryCalendar` 实例。如果我们想在 `calendar`
    操作外部调用 `ImaginaryCalendar` 实例的方法，例如调用 `calendar.setDate(date)` 来设置日历的日期，我们应该怎么做？
- en: There’s no way to call `calendar.setDate(date)` outside of the `calendar` action
    since the `calendar` instance is defined within the `calendar` action. A workaround
    is to pass `date` through action data – that is, we can provide `date` as action
    data and call `calendar.setDate(date)` with the date passed in.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `calendar` 实例是在 `calendar` 动作中定义的，因此无法在 `calendar` 动作之外调用 `calendar.setDate(date)`。一种解决方案是通过动作数据传递
    `date` – 也就是说，我们可以将 `date` 作为动作数据提供，并使用传入的日期调用 `calendar.setDate(date)`。
- en: 'For example, in the following code snippet, we’re passing `date` into the `calendar`
    action:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码片段中，我们将 `date` 传递给 `calendar` 动作：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `calendar` action, we call `calendar.setDate(date)` with the date passed
    in. In addition to that, we define an `update` method in the action, such that
    whenever the date that’s passed to the calendar action changes, Svelte will call
    `calendar.setDate(date)`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `calendar` 动作中，我们使用传入的日期调用 `calendar.setDate(date)`。除此之外，我们在动作中定义了一个 `update`
    方法，以便每当传递给 `calendar` 动作的日期更改时，Svelte 将调用 `calendar.setDate(date)`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we can pass different dates to the different `calendar` instances:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以向不同的 `calendar` 实例传递不同的日期：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s great!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那太好了！
- en: Now, what if you want to call a different `calendar` instance method, such as
    `calendar.setMode()`, whenever the mode changes?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想在模式更改时调用不同的 `calendar` 实例方法，比如 `calendar.setMode()`，会怎么样？
- en: 'You could pass both `date` and `mode` into the action:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `date` 和 `mode` 都传递给动作：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In that case, the `calendar` action would need to handle both `date` and `mode`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`calendar` 动作需要同时处理 `date` 和 `mode`：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `update` method of the `calendar` action will be called whenever either
    `date` or `mode` changes. This means that in the preceding code, we are calling
    both `calendar.setDate()` and `calendar.setMode()` whenever either `date` or `mode`
    changes. This may not have any apparent consequences, but we may be doing an unnecessary
    job.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `date` 或 `mode` 中的任何一个更改时，`calendar` 动作的 `update` 方法将被调用。这意味着在先前的代码中，每当 `date`
    或 `mode` 发生更改时，我们都会调用 `calendar.setDate()` 和 `calendar.setMode()`。这可能没有明显的后果，但我们可能正在进行不必要的操作。
- en: 'A workaround for this is to keep track and always check whether `date` or `mode`
    have changed in the `update` method. This is how we can do this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是跟踪并始终在 `update` 方法中检查 `date` 或 `mode` 是否已更改。这就是我们如何做到这一点：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we’re checking if `newDate` is different from the current
    `date`, and if it is different, then we call the `calendar.setDate()` method and
    update our current reference of `date`. We do a similar thing for `mode`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们正在检查 `newDate` 是否与当前的 `date` 不同，如果是的话，我们就调用 `calendar.setDate()` 方法并更新我们的当前
    `date` 引用。我们对 `mode` 做了类似的事情。
- en: This works. However, as you can see, it is more code and more complex than what
    we set up when we first started creating the `calendar` action.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。然而，正如你所看到的，这比我们最初创建 `calendar` 动作时设置的代码更多，也更复杂。
- en: And what if you want to call a `calendar` instance method that is not tied to
    any data, such as `calendar.refreshDates()`?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果你想要调用一个与任何数据无关的 `calendar` 实例方法，比如 `calendar.refreshDates()`，会怎么样？
- en: This is where using actions falls short.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用动作的不足之处。
- en: An alternative to Svelte actions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Svelte 动作的一个替代方案
- en: Remember the previous example, where we used `bind:this` and `onMount` to initialize
    `ImaginaryCalendar`?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前的例子，我们使用了 `bind:this` 和 `onMount` 来初始化 `ImaginaryCalendar` 吗？
- en: 'We said that the approach is not versatile enough and falls short if we need
    to do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，这种方法不够灵活，如果需要执行以下操作，就会不足：
- en: Conditionally render the container and create `ImaginaryCalendar`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件渲染容器并创建 `ImaginaryCalendar`
- en: Have multiple calendars within the same component
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一组件内拥有多个日历
- en: 'These drawbacks are all true, but there’s a use case in which it is perfectly
    fine to use `bind:this` and `onMount` to initialize `ImaginaryCalendar`. This
    is when the conditions we mentioned previously are never true:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺点都是真实的，但有一个用例，使用 `bind:this` 和 `onMount` 初始化 `ImaginaryCalendar` 是完全可行的。这是当之前提到的条件从未为真时：
- en: We do not need to conditionally render the container
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要条件渲染容器
- en: We do not need to have multiple calendar instances within the same component
    (this is not exactly true, but we will come back to this)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要在同一个组件内拥有多个日历实例（这并不完全正确，但我们会回到这一点）
- en: I’m not sure whether you are thinking the same thing right now but allow me
    to cut the suspense.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定你现在是否在想同样的事情，但让我来打破这种悬念。
- en: This is when we want to use `ImaginaryCalendar` as a Svelte component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这时我们想要将 `ImaginaryCalendar` 作为 Svelte 组件使用。
- en: 'Within the `ImaginaryCalendar` Svelte component itself, we will have only one
    container element, and it will always be available:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ImaginaryCalendar` Svelte 组件内部，我们只有一个容器元素，它始终可用：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then use this component conditionally:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以有条件地使用这个组件：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can use it however many times as you like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以根据需要多次使用它：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we’ve swapped out elements using actions, `<div use:calendar />`, with
    Svelte components, `<``ImaginaryCalendarComponent />`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用动作替换了元素，`<div use:calendar />`，用 Svelte 组件，`<``ImaginaryCalendarComponent
    />`。
- en: This is perfectly normal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这很正常。
- en: In the previous chapter, we contemplated between abstracting logic through components
    or abstracting through actions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们考虑了通过组件或动作进行逻辑抽象。
- en: In this scenario, we are looking at abstracting the logic of instantiating a
    UI library using an element as a container, and we could abstract it into a Svelte
    action or a Svelte component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们正在考虑将使用元素作为容器实例化 UI 库的逻辑进行抽象，我们可以将其抽象为一个 Svelte 动作或一个 Svelte 组件。
- en: Both options are equally fine.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都同样合适。
- en: Both options are designed for this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都是为了这个目的而设计的。
- en: So, which options should you choose? Let’s find out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该选择哪些选项呢？让我们来了解一下。
- en: Choosing between Svelte actions and Svelte components
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Svelte 动作和 Svelte 组件之间进行选择
- en: Here are my personal preferences when faced with a choice between either option.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临选择这两个选项之一时，我的个人偏好如下。
- en: 'Choose a Svelte action to integrate with a UI library when you are looking
    for an option that provides the following aspects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '当你在寻找提供以下方面的选项时，选择 Svelte 动作与 UI 库集成： '
- en: Is more lightweight. A Svelte component has slightly more overhead compared
    to a Svelte action.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更轻量级。与 Svelte 动作相比，Svelte 组件有稍微多一点的开销。
- en: Only passes zero to one data into the UI library component instance. If you
    were to pass in two or more pieces of data into the action, then the update method
    of the action will be called whenever any part of the data changes.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只传递零到一份数据到 UI 库组件实例。如果你要将两份或更多数据传递到动作中，那么每当数据中的任何部分发生变化时，动作的更新方法将被调用。
- en: 'You should choose a Svelte component if you are looking for an option that
    provides the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找提供以下功能的选项，你应该选择 Svelte 组件：
- en: Allows more room for optimization and finer control
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更多的优化空间和更精细的控制。
- en: Allows you to call UI library component instance methods directly
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你直接调用 UI 库组件实例方法。
- en: Allows you to pass in child content into the UI component library
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你将子内容传递到 UI 组件库中。
- en: 'We did not discuss this much, but integrating a UI library as a component opens
    up the possibility of passing additional content into the UI component library
    through slots:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有过多讨论这一点，但将 UI 库作为组件集成可以打开通过插槽向 UI 组件库传递额外内容的可能性：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you are interested in learning more about slots and how to compose components
    in Svelte, read [*Chapter 4*](B18887_04.xhtml#_idTextAnchor064), where we explored
    this topic extensively. Now that we’ve covered how we could integrate a UI library
    using Svelte actions, why we should use Svelte actions, as well as the alternatives
    and considerations, let’s take a look at a real-world example, Tippy.js.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于插槽和如何在 Svelte 中组合组件的信息，请阅读[*第 4 章*](B18887_04.xhtml#_idTextAnchor064)，在那里我们广泛地探讨了这一主题。现在我们已经介绍了如何使用
    Svelte 动作集成 UI 库，为什么我们应该使用 Svelte 动作，以及替代方案和考虑因素，让我们来看一个真实世界的例子，Tippy.js。
- en: Example – integrating Tippy.js
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 集成 Tippy.js
- en: Tippy.js is a tooltip, popover, dropdown, and menu library.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Tippy.js 是一个提示框、弹出框、下拉菜单和菜单库。
- en: I do not have any affiliation with the Tippy.js library, and the reason I chose
    Tippy.js as an example is purely by chance. Nonetheless, Tippy.js has a nice and
    simple API, making it a good candidate for an example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我与 Tippy.js 库没有任何关联，我选择 Tippy.js 作为示例纯粹是偶然的。不过，Tippy.js 有一个简洁的 API，使其成为示例的好候选。
- en: 'First, let’s look at the Tippy.js documentation: [https://atomiks.github.io/tippyjs/](https://atomiks.github.io/tippyjs/).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Tippy.js 的文档：[https://atomiks.github.io/tippyjs/](https://atomiks.github.io/tippyjs/)。
- en: 'After installing the `tippy.js` library using a package manager of our choice,
    we can then import Tippy.js into our code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们选择的包管理器安装了 `tippy.js` 库之后，我们就可以将 Tippy.js 导入到我们的代码中：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can initialize `tippy` with the following constructor function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下构造函数初始化 `tippy`：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we pass in the element where Tippy.js should provide a tooltip.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了 Tippy.js 应该提供提示的元素。
- en: 'You can specify any customizations of the tooltip''s content through the data
    attributes of the element, which Tippy.js will pick up as it initializes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过元素的数据属性指定提示内容的任何自定义设置，Tippy.js将在初始化时拾取这些设置：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, you can pass this in the constructor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在构造函数中传递这个方法：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To update the content after initialization, call the Tippy.js `setContent`
    method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在初始化后更新内容，请调用Tippy.js的`setContent`方法：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To permanently destroy and clean up the tooltip instance, Tippy.js provides
    the `destroy` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要永久销毁并清理提示实例，Tippy.js提供了`destroy`方法：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we have all we need to create a `tippy` action. We have methods to do
    the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经有了一切创建`tippy`动作所需的东西。我们有以下方法：
- en: Create the `tippy` tooltip – `tippy(…)`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`tippy`提示——`tippy(…)`
- en: Clean up the `tippy` tooltip – `tooltipInstance.destroy()`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理`tippy`提示——`tooltipInstance.destroy()`
- en: Update the `tippy` tooltip – `tooltipInstance.setContent(…)`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`tippy`提示——`tooltipInstance.setContent(…)`
- en: Let’s take a look at what the `tippy` action should look like.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`tippy`动作应该是什么样子。
- en: 'Here is how I want it to look:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我希望它看起来像的样子：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code snippet, we applied our `tippy` action to a `<div>` element.
    The content within the tooltip created by Tippy.js should be passed into the `tippy`
    action as action data, represented by the `tooltipContent` variable. Whenever
    `tooltipContent` changes, the action should react to it and update the tooltip.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将我们的`tippy`动作应用于一个`<div>`元素。由Tippy.js创建的提示内容应该作为动作数据传递给`tippy`动作，表示为`tooltipContent`变量。每当`tooltipContent`更改时，动作应该对其做出反应并更新提示。
- en: 'So, let’s write our `tippy` Svelte action. Here’s the scaffolding for an action:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写我们的`tippy` Svelte动作。以下是动作的脚手架：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we created the `tippy` action based on the Svelte action contract:
    a function that returns an object with `destroy` and `update` methods.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们基于Svelte动作合约创建了`tippy`动作：一个返回包含`destroy`和`update`方法的对象的函数。
- en: 'I left three TODOs in the code, each marking different stages of Svelte actions.
    Let’s go through each one and fill them up. The first `TODO` is where the action
    will be called after the element is created and mounted onto the DOM. Here, we
    are given the element the action is applied to and the action data, and we should
    use it to initialize the Tippy.js tooltip:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中留下了三个`TODO`，每个都标记了Svelte动作的不同阶段。让我们逐一过一遍并填补它们。第一个`TODO`是动作在元素创建并挂载到DOM后被调用的地方。在这里，我们得到了动作应用到的元素和动作数据，我们应该使用它来初始化Tippy.js提示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The second `TODO` is inside the `update` method. This method will be called
    every time the action data changes. Here, we need to call the Tippy.js tooltip
    instance to reflect the dataset in the Svelte component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`TODO`位于`update`方法中。这个方法将在动作数据每次更改时被调用。在这里，我们需要调用Tippy.js提示实例以反映Svelte组件中的数据集：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The third `TODO` is inside the `destroy` method. This method will be called
    after the element is removed from the DOM. Here, we need to do the cleanup on
    the Tippy.js tooltip instance that we created in the action:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`TODO`位于`destroy`方法中。这个方法将在元素从DOM中移除后被调用。在这里，我们需要清理我们在动作中创建的Tippy.js提示实例：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And that’s it – we now have a working `tippy` action that integrates the Tippy.js
    tooltip and will show a tooltip with customizable content whenever we hover over
    the element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们现在有一个工作的`tippy`动作，它集成了Tippy.js提示，并且每当我们将鼠标悬停在元素上时，都会显示一个具有自定义内容的提示。
- en: 'You can find the complete code on GitHub: [https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy](https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的代码：[https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy](https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy).
- en: Let’s look at one more example, through which I want to show you one more thing
    that you can do with actions when integrating with UI libraries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，通过这个例子我想向你展示在集成UI库时可以使用动作做的一些其他事情。
- en: The UI library we are going to look at next is CodeMirror.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的UI库是CodeMirror。
- en: Example – integrating CodeMirror
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例——集成CodeMirror
- en: CodeMirror is a code editor component that has many great features for editing,
    such as syntax highlighting, code folding, and more.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: CodeMirror是一个具有许多出色编辑功能的代码编辑组件，例如语法高亮、代码折叠等。
- en: You can find the CodeMirror documentation at [https://codemirror.net/](https://codemirror.net/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://codemirror.net/](https://codemirror.net/)找到CodeMirror的文档。
- en: At the time of writing, CodeMirror is currently at version 5.65.9.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，CodeMirror目前处于版本5.65.9。
- en: 'After installing the `codemirror` library using the package manager of our
    choice, we can import `codemirror` into our code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们选择的包管理器安装了`codemirror`库之后，我们可以在代码中导入`codemirror`：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can initialize CodeMirror with the following constructor function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下构造函数初始化CodeMirror：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we pass in the element where we want the CodeMirror code editor to be.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了我们要放置CodeMirror代码编辑器的元素。
- en: 'Before I continue, at this point, note that we are looking for the same set
    of things from CodeMirror:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续之前，请注意，我们现在从CodeMirror中寻找的是同一组东西：
- en: Methods to initialize CodeMirror
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化CodeMirror的方法
- en: Any method needed to clean up a CodeMirror instance
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理CodeMirror实例所需的任何方法
- en: Any method to update a CodeMirror instance
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何更新CodeMirror实例的方法
- en: I am going to leave it to you to complete the checklist and figure it out.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个清单的完成和解决方法留给你。
- en: 'However, allow me to draw your attention to one particular API from the CodeMirror
    instance:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请允许我特别提醒您注意CodeMirror实例中的一个特定API：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `on` method from CodeMirror allows the CodeMirror instance to listen to
    events and react to them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CodeMirror的`on`方法允许CodeMirror实例监听事件并对它们做出反应。
- en: So, if we want to add event listeners to the CodeMirror instance from outside
    of the action, how should we do it?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们想从动作外部向CodeMirror实例添加事件监听器，我们应该怎么做？
- en: In the previous chapter, we saw that we could create custom events on the element
    using actions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了我们可以在元素上使用操作来创建自定义事件。
- en: 'This means that we can allow users to listen to the `''change''` event from
    the element that uses the `codemirror` action:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以允许用户监听使用`codemirror`动作的元素的`'change'`事件：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make this happen, you can dispatch an event from within the action:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，你可以在动作内部触发一个事件：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember to check whether you need to clean up or unlisten to any event in the
    `destroy` method so that you don’t cause any unwanted behavior.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在`destroy`方法中检查是否需要清理或取消监听任何事件，以免引起任何不期望的行为。
- en: And that’s it!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: The rest of the action is left to you as an exercise.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的操作留给你作为练习。
- en: 'You can find the complete code on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的代码：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror)。
- en: In this section, we learned how to integrate vanilla UI libraries into Svelte.
    However, not all UI libraries are implemented independently without any framework.
    Sometimes, the library you are looking for might be implemented in a different
    framework, such as React or Vue. In such cases, how can you integrate them into
    a Svelte application? That is what we will explore next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将纯UI库集成到Svelte中。然而，并非所有UI库都是独立实现的，没有任何框架。有时，你可能需要的库可能是在不同的框架中实现的，比如React或Vue。在这种情况下，如何将它们集成到Svelte应用程序中？这就是我们接下来要探讨的。
- en: Using UI libraries written in other frameworks
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他框架编写的UI库
- en: It is not impossible to use components from other frameworks in Svelte.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Svelte中使用其他框架的组件并非不可能。
- en: However, doing so will introduce the framework’s runtime and other overheads
    that come along with the framework. The runtime usually includes code to handle
    reactivity and normalize browser APIs and events. Each framework usually ships
    its own code for this logic and does not share it with other frameworks. The runtime
    for React version 18.2.0 weighs 6.4 kB when minified, which is additional code
    you need to include when you want to use a React component within Svelte.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做将会引入框架的运行时和其他与框架相关的开销。运行时通常包括处理响应性和标准化浏览器API和事件的代码。每个框架通常为其逻辑提供自己的代码，并且不会与其他框架共享。React版本18.2.0的运行时在压缩后重量为6.4
    kB，这是当你想在Svelte中使用React组件时需要包含的额外代码。
- en: So, this is not recommended unless it is necessary.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非必要，否则不建议这样做。
- en: The reason this section has been included in this book is more for educational
    purposes and to demonstrate that this is possible, as well as what needs to be
    done to make it happen.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节被包含在这本书中更多的是出于教育目的，以及为了展示这是可能的，以及为了实现它需要做什么。
- en: Creating components in various frameworks
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在各种框架中创建组件
- en: Each framework usually provides an API that takes in a container element and
    the framework component as the root of the application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架通常提供一个API，它接受一个容器元素和框架组件作为应用程序的根。
- en: In this section, we’re going to take a look at React and Vue, the two most popular
    JavaScript frameworks at the time of writing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 React 和 Vue，这两个在撰写本文时最受欢迎的 JavaScript 框架。
- en: 'For example, in React 18, we use the `createRoot` API:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 React 18 中，我们使用 `createRoot` API：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code uses the JSX syntax, which is not part of the standard JavaScript
    language syntax. It is syntactic sugar for `jsx`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了 JSX 语法，这不是标准 JavaScript 语言的语法。它是 `jsx` 的语法糖：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will have to write the preceding code if you do not configure any transpiling
    process in your code to turn JSX syntax into valid JavaScript.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在代码中配置任何将 JSX 语法转换为有效 JavaScript 的转换过程，你将不得不编写前面的代码。
- en: 'On the other hand, In Vue 3, there is the `createApp` API:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在 Vue 3 中，有 `createApp` API：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Vue framework uses the word *application* in the documentation, mentioning
    that the `createApp` method is used to create a new application instance. The
    word *application* is aptly used as integrating component libraries written in
    other frameworks is very much like starting a new sub-application within our Svelte
    application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 框架在文档中使用“application”这个词，提到 `createApp` 方法用于创建一个新的应用程序实例。这个词“application”用得恰到好处，因为将其他框架编写的组件库集成到我们的
    Svelte 应用程序中，就像是在我们的 Svelte 应用程序中启动一个新的子应用程序一样。
- en: You may have also started to notice the similarity between the APIs from these
    frameworks and other UI libraries that we’ve seen so far – all of them take in
    a container element so that they know where to render the content or apply changes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也已经注意到了这些框架的 API 与我们之前看到的其他 UI 库之间的相似性——它们都接受一个容器元素，以便知道在哪里渲染内容或应用更改。
- en: Similar to integrating UI libraries using actions, after figuring out what APIs
    we can use to render a component within a container element, the next thing we
    must check is whether there is any API to clean up when it is no longer needed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用动作集成 UI 库类似，在弄清楚我们可以使用哪些 API 在容器元素内渲染组件之后，接下来我们必须检查是否有任何 API 在不再需要时进行清理。
- en: Cleaning up the components in various frameworks
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在各种框架中清理组件
- en: Depending on the underlying framework of the component library, different APIs
    are provided to clean up whenever the component is no longer needed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据组件库的底层框架，提供了不同的 API 来清理不再需要的组件。
- en: 'In React, there is a method for this called `unmount`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，有一个名为 `unmount` 的方法来做这件事：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Vue, it is also called `unmount`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 中，这也被称为 `unmount`：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The next thing we need to check is whether there is any API to pass data into
    our component and API so that they can be updated later.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要检查的是是否有任何 API 可以将数据传递到我们的组件和 API 中，以便它们可以在以后进行更新。
- en: Updating the component in various frameworks
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在各种框架中更新组件
- en: Similar to different frameworks having different APIs for cleaning up, frameworks
    provide different APIs to update the component with new data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与不同框架提供不同的清理 API 类似，框架提供了不同的 API 来用新数据更新组件。
- en: 'If you are familiar with React, you can pass data into a React component through
    props:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 React，你可以通过 props 将数据传递给 React 组件：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is akin to the props in a Svelte component.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于 Svelte 组件中的 props。
- en: 'The preceding code desugars into the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码简化为以下内容：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To update the props of the component, React allows us to call `root.render`
    again with the same component but with a different prop value:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新组件的 props，React 允许我们再次调用 `root.render`，使用相同的组件但不同的 prop 值：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: React will reconcile this internally and figure out how to update the DOM.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: React 将内部进行协调并找出如何更新 DOM。
- en: 'On the other hand, in Vue, you can pass data through props in the `createApp`
    API:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在 Vue 中，你可以在 `createApp` API 中通过 props 传递数据：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, to the best of my knowledge, there’s no straightforward way to update
    the props’ value from the outside.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，据我所知，没有直接更新 props 值的简单方法。
- en: 'However, you could use a Vue Composition API, such as `ref()`, to create a
    reactive and mutable ref. With that, you could modify the ref instead of updating
    the props directly:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用 Vue 的组合式 API，例如 `ref()`，来创建一个可响应和可变的 ref。有了这个，你可以修改 ref 而不是直接更新 props：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It is okay if you are not familiar with how React and Vue work. This book is
    for Svelte, not for React or Vue.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 React 和 Vue 的工作原理，那也无所谓。这本书是针对 Svelte 的，而不是针对 React 或 Vue。
- en: 'The most important thing to take home from this is that when integrating a
    UI library, whether it is in vanilla JavaScript, React, or Vue, we look for three
    things:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们学到最重要的一点是，在集成 UI 库时，无论是使用纯 JavaScript、React 还是 Vue，我们都在寻找三件事：
- en: A method to create the component with a container element
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种创建带有容器元素组件的方法
- en: A method to clean up the component instance
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种清理组件实例的方法
- en: A method to pass in data and update the data
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种传递数据和更新数据的方法
- en: If you are familiar with a framework, you will be able to figure out a way to
    do all these things.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉某个框架，你将能够找到一种方法来完成所有这些事情。
- en: With that out of the way, let’s take a look at a real-world example, where we
    will integrate a React calendar library, `react-calendar`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这个问题，让我们看看一个现实世界的例子，我们将集成一个React日历库，`react-calendar`。
- en: Integrating react-calendar into Svelte
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将react-calendar集成到Svelte中
- en: The `react-calendar` library is a calendar component library written in React.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-calendar`库是一个用React编写的日历组件库。'
- en: 'You can read more about it here: [https://projects.wojtekmaj.pl/react-calendar/](https://projects.wojtekmaj.pl/react-calendar/).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多信息：[https://projects.wojtekmaj.pl/react-calendar/](https://projects.wojtekmaj.pl/react-calendar/).
- en: The `react-calendar` library takes in various props for customization purposes.
    But for demonstration purposes, we are only going to focus on two props, `value`
    and `onChange`, which allow us to control the selected date of the library.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-calendar`库接受各种属性以进行定制。但为了演示目的，我们只关注两个属性，`value`和`onChange`，这两个属性允许我们控制库选择的日期。'
- en: We pass the selected date through a prop named `value`. The `onChange` prop,
    on the other hand, is used to pass in an event handler that will be called when
    the value changes from within the calendar component. We saw how we could handle
    event handlers in a UI library in the previous section when we discussed CodeMirror.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个名为`value`的属性传递选定的日期。另一方面，`onChange`属性用于传递一个事件处理器，当值在日历组件内部发生变化时将被调用。我们在上一节讨论CodeMirror时看到了如何处理事件处理器。
- en: 'So, here is what I think using the `calendar` action would look like:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是我认为使用`calendar`动作的样子：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, `event.detail` is the data attached to the custom `'change'` event, which
    would be the date value that’s sent from the `react-calendar` component through
    the `onChange` props.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`event.detail`是附加到自定义`'change'`事件的 数据，这将是从`react-calendar`组件通过`onChange`属性发送的日期值。
- en: Now that we know what our `calendar` action would look like, let’s write the
    action out.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的`calendar`动作会是什么样子，让我们把它写出来。
- en: 'Again, here’s the scaffolding of an action:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是动作的框架：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, I’ve created a basic code structure of a Svelte action and left a few
    TODOs within the code. The first two TODOs are to set up the `calendar` instance
    with the element the action is applied to. The third `TODO` is to handle when
    a new date is passed into the action, and the last `TODO` is to clean up when
    the element is removed from the DOM.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个Svelte动作的基本代码结构，并在代码中留下了一些TODOs。前两个TODOs是设置动作应用的元素上的`calendar`实例。第三个`TODO`是处理当新日期传递到动作中时的情况，最后一个`TODO`是当元素从DOM中移除时进行清理。
- en: So, let’s fill up the TODOs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们填写TODOs。
- en: 'For the first `TODO`, let’s create a React root and render our `react-calendar`
    component:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个`TODO`，让我们创建一个React根实例并渲染我们的`react-calendar`组件：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we passed in `onChange`, which we have not defined yet.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递了`onChange`，但我们还没有定义它。
- en: 'Let’s do this now:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做这件事：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code snippet, whenever `onChange` is called, we will dispatch
    a new custom event, with `value` passed in as the detail for the custom event.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，每当调用`onChange`时，我们将分派一个新的自定义事件，并将`value`作为自定义事件的详细信息传递。
- en: 'The third `TODO` is the content for the `update` method. Whenever a new date
    value is passed in from the action, we will re-render the `Calendar` component
    again:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`TODO`是`update`方法的内容。每当从动作传递新的日期值时，我们将重新渲染`Calendar`组件：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the last `TODO`, in the `destroy` method, we unmount our `Calendar` component:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个`TODO`中，在`destroy`方法中，我们卸载了`Calendar`组件：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And that’s it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了。
- en: 'You can find the complete code on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的代码：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar).
- en: With that, you’ve written a Svelte action that integrates a component library
    from a different framework, React, into Svelte, and you set up and updated the
    component’s value in a controlled manner.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就已经编写了一个Svelte动作，该动作将来自不同框架的组件库（React）集成到Svelte中，并且以受控的方式设置和更新了组件的值。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use actions to integrate UI libraries, either
    written in vanilla JavaScript or any other frameworks into Svelte. We went through
    two real-world examples – integrating Tippy.js and `react-calendar` into Svelte
    using Svelte actions. In both examples, we went through a step-by-step process
    of writing out a Svelte action. We started by creating the structure of a Svelte
    action and then filled up the steps within the action for when the Svelte action
    is initialized as the element is created, when the data changes, and when the
    element is removed from the DOM. We also discussed why we choose to use Svelte
    actions, as well as the other alternatives and considerations when it comes to
    integrating UI libraries.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用动作将 UI 库集成到 Svelte 中，无论是用纯 JavaScript 编写的还是任何其他框架。我们通过两个真实世界的例子进行了演示——使用
    Svelte 动作将 Tippy.js 和 `react-calendar` 集成到 Svelte 中。在两个例子中，我们都经历了一个逐步的过程来编写 Svelte
    动作。我们首先创建了 Svelte 动作的结构，然后在动作中填充了步骤，包括当 Svelte 动作初始化为元素创建时、数据变化时以及元素从 DOM 中移除时的步骤。我们还讨论了为什么选择使用
    Svelte 动作，以及集成 UI 库时的其他替代方案和考虑因素。
- en: In the next chapter, we will look at the next common pattern of actions, which
    is to progressively enhance your elements.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨动作的下一个常见模式，即逐步增强你的元素。
