- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating Libraries with Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of JavaScript UI libraries out there on the internet. However,
    at the time of writing this book, Svelte is relatively new. Not all the UI libraries
    out there are written using Svelte and written specifically for Svelte. But that
    does not mean that we can’t use them in our Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to integrate third-party JavaScript UI libraries into Svelte.
    In this chapter, we are going to explore how we can do it using Svelte actions.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by integrating an imaginary UI library, slowly building up our
    case for why Svelte actions are suitable for the job. Along the way, I will explain
    how to use Svelte actions for different scenarios and show you where Svelte actions
    fall short. I’ll discuss my reasonings and personal opinions on when to choose
    Svelte actions and when to choose otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, I will show you some real-world UI library examples. After that,
    we will explore integrating UI libraries written in other frameworks, such as
    React and Vue, with a few more examples.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will see that you are not limited to using only
    UI libraries written in Svelte in your Svelte application – you can reuse any
    UI library that is available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating JavaScript UI libraries into Svelte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why we should use actions to integrate UI libraries and other alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating UI libraries written in other frameworks into Svelte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the examples and code for this chapter here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating vanilla JavaScript UI libraries into Svelte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will explore UI libraries that are written in vanilla JavaScript.
    When we use the phrase *vanilla JavaScript*, we’re referring to plain JavaScript,
    or JavaScript in the absence of frameworks or libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons a UI library is written in vanilla JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance reasons – it would be much easier to optimize without the abstractions
    from the web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library author’s personal preference to be framework-agnostic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library was created predating any modern web frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For us, vanilla JavaScript UI libraries are great because they do not depend
    on any specific framework runtime, which is an extra overhead on top of the UI
    library itself.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we use a calendar component library that is implemented in React,
    then besides installing the calendar component library, we would need to install
    React’s framework as well.
  prefs: []
  type: TYPE_NORMAL
- en: This additional dependency leads to an increased bundle size and potential conflicts
    with Svelte. Therefore, when using a component library in Svelte, it is generally
    preferable to choose a library that does not depend on any specific framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about why vanilla JavaScript UI libraries are great,
    let’s discuss how we can integrate them into Svelte. In this chapter, we will
    explore integrating libraries in Svelte using Svelte actions, which begs the question,
    why do we choose to use Svelte actions to integrate a UI library?
  prefs: []
  type: TYPE_NORMAL
- en: Why use Svelte actions to integrate a UI library?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we explored how Svelte actions are useful for adding
    custom event handlers. At the same time, Svelte actions function as element-level
    life cycle functions, making them very useful for interfacing with third-party
    libraries. Now, let’s explore why that’s the case.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a calendar component library as an example. For simplicity’s sake
    and to not get bogged down by implementation details, let’s imagine the library
    as an imaginary library instead of using any real-life calendar component library.
    This allows us to focus on the general problem itself rather than the specific
    library’s implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some real-life UI libraries afterward.
  prefs: []
  type: TYPE_NORMAL
- en: To decide where the calendar component will be added to the DOM, component libraries
    usually require us to specify a container element to house the library component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here, `ImaginaryCalendar` requires us to pass the container element
    as part of the argument for the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the reference to an element in Svelte, we can use `bind:this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `containerElement` variable is only updated with the reference of the element
    after the element is mounted, so it can only be referred to in `onMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are keeping the reference of the `calendar` instance because we
    can use it to call calendar methods to get or set values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, we call `calendar.cleanup()` when the component unmounts for cleanup purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The calendar library is just an imaginary example. However, most UI libraries
    will provide similar APIs or methods to retrieve or modify the component instance’s
    internal state and clean up when they are no longer in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be extra careful when we are using the `calendar` instance here.
    We want to avoid referencing the `calendar` instance before it is initialized
    to prevent encountering a reference error as the calendar instance is only declared
    and initialized after `onMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: To be safe, we should check whether the `calendar` instance is defined before
    calling any of its methods. In the code example below, we verify if the calendar
    instance is defined, before calling the `calendar.setDate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The need for this extra level of cautiousness is more obvious when the calendar
    is conditionally created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that `<div>` is conditionally created based
    on `someCondition`. That is why in `onMount`, we need to check whether `containerElement`
    is available before we create `ImaginaryCalendar` using `containerElement` as
    a container. And the `calendar` instance is only available if `ImaginaryCalendar`
    is created, and thus only available if `someCondition` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code illustrates one of the many possibilities where the `calendar`
    instance could be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note about this code is that it is not behaviorally correct as
    it does not attempt to create `ImaginaryCalendar` whenever the value of `someCondition`
    turns from `false` to `true` and does cleanup whenever it turns back to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Svelte actions shine.
  prefs: []
  type: TYPE_NORMAL
- en: Using Svelte actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By altering the preceding code so that it uses actions, you will see that we
    do not need the extra check to ensure that `containerElement` is available before
    instantiating `ImaginaryCalendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how such an action could be implemented. Here, the
    name of our Svelte action is `calendar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is because, when using Svelte actions, the action function will only be
    called with the reference of the element whenever the element is created and mounted
    onto the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: When the condition changes to such that the `<div>` element is removed from
    the DOM, the `destroy` method of the action will be called to clean things up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Svelte actions, we can now create as many `ImaginaryCalendar` instances
    as we want within one component by adding the action to different HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: To prove my point, in the code snippet below, in addition to the original `<div>`
    element you’ve seen in the previous examples, I am adding another `<div>` element
    and three more `<div>` elements using the `{#each}` block. I am then applying
    the calendar actions to all four `<div>` elements to create four more calendars,
    and we do not run into any errors for having multiple calendars at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we were to use `bind:this` and `onMount`, we would have to repeat ourselves
    multiple times by declaring multiple `containerElement` variables multiple times
    and instantiate `ImaginaryCalendar` with each of the `containerElement` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the `calendar` instance encapsulated within the action, how should
    we call the `calendar` instance method to update the `calendar` state from the
    outside?
  prefs: []
  type: TYPE_NORMAL
- en: That’s what the action data is for!
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to Svelte actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we created a `calendar` action and instantiated an
    `ImaginaryCalendar` instance inside that action. If we want to call an instance
    method of `ImaginaryCalendar` outside the `calendar` action, such as calling `calendar.setDate(date)`
    to set the date of the calendar, what should we do?
  prefs: []
  type: TYPE_NORMAL
- en: There’s no way to call `calendar.setDate(date)` outside of the `calendar` action
    since the `calendar` instance is defined within the `calendar` action. A workaround
    is to pass `date` through action data – that is, we can provide `date` as action
    data and call `calendar.setDate(date)` with the date passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code snippet, we’re passing `date` into the `calendar`
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `calendar` action, we call `calendar.setDate(date)` with the date passed
    in. In addition to that, we define an `update` method in the action, such that
    whenever the date that’s passed to the calendar action changes, Svelte will call
    `calendar.setDate(date)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can pass different dates to the different `calendar` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That’s great!
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if you want to call a different `calendar` instance method, such as
    `calendar.setMode()`, whenever the mode changes?
  prefs: []
  type: TYPE_NORMAL
- en: 'You could pass both `date` and `mode` into the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case, the `calendar` action would need to handle both `date` and `mode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `update` method of the `calendar` action will be called whenever either
    `date` or `mode` changes. This means that in the preceding code, we are calling
    both `calendar.setDate()` and `calendar.setMode()` whenever either `date` or `mode`
    changes. This may not have any apparent consequences, but we may be doing an unnecessary
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workaround for this is to keep track and always check whether `date` or `mode`
    have changed in the `update` method. This is how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we’re checking if `newDate` is different from the current
    `date`, and if it is different, then we call the `calendar.setDate()` method and
    update our current reference of `date`. We do a similar thing for `mode`.
  prefs: []
  type: TYPE_NORMAL
- en: This works. However, as you can see, it is more code and more complex than what
    we set up when we first started creating the `calendar` action.
  prefs: []
  type: TYPE_NORMAL
- en: And what if you want to call a `calendar` instance method that is not tied to
    any data, such as `calendar.refreshDates()`?
  prefs: []
  type: TYPE_NORMAL
- en: This is where using actions falls short.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to Svelte actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the previous example, where we used `bind:this` and `onMount` to initialize
    `ImaginaryCalendar`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We said that the approach is not versatile enough and falls short if we need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally render the container and create `ImaginaryCalendar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have multiple calendars within the same component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These drawbacks are all true, but there’s a use case in which it is perfectly
    fine to use `bind:this` and `onMount` to initialize `ImaginaryCalendar`. This
    is when the conditions we mentioned previously are never true:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to conditionally render the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not need to have multiple calendar instances within the same component
    (this is not exactly true, but we will come back to this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m not sure whether you are thinking the same thing right now but allow me
    to cut the suspense.
  prefs: []
  type: TYPE_NORMAL
- en: This is when we want to use `ImaginaryCalendar` as a Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `ImaginaryCalendar` Svelte component itself, we will have only one
    container element, and it will always be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use this component conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use it however many times as you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve swapped out elements using actions, `<div use:calendar />`, with
    Svelte components, `<``ImaginaryCalendarComponent />`.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfectly normal.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we contemplated between abstracting logic through components
    or abstracting through actions.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we are looking at abstracting the logic of instantiating a
    UI library using an element as a container, and we could abstract it into a Svelte
    action or a Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: Both options are equally fine.
  prefs: []
  type: TYPE_NORMAL
- en: Both options are designed for this.
  prefs: []
  type: TYPE_NORMAL
- en: So, which options should you choose? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between Svelte actions and Svelte components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are my personal preferences when faced with a choice between either option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a Svelte action to integrate with a UI library when you are looking
    for an option that provides the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Is more lightweight. A Svelte component has slightly more overhead compared
    to a Svelte action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only passes zero to one data into the UI library component instance. If you
    were to pass in two or more pieces of data into the action, then the update method
    of the action will be called whenever any part of the data changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should choose a Svelte component if you are looking for an option that
    provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows more room for optimization and finer control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to call UI library component instance methods directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to pass in child content into the UI component library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We did not discuss this much, but integrating a UI library as a component opens
    up the possibility of passing additional content into the UI component library
    through slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in learning more about slots and how to compose components
    in Svelte, read [*Chapter 4*](B18887_04.xhtml#_idTextAnchor064), where we explored
    this topic extensively. Now that we’ve covered how we could integrate a UI library
    using Svelte actions, why we should use Svelte actions, as well as the alternatives
    and considerations, let’s take a look at a real-world example, Tippy.js.
  prefs: []
  type: TYPE_NORMAL
- en: Example – integrating Tippy.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tippy.js is a tooltip, popover, dropdown, and menu library.
  prefs: []
  type: TYPE_NORMAL
- en: I do not have any affiliation with the Tippy.js library, and the reason I chose
    Tippy.js as an example is purely by chance. Nonetheless, Tippy.js has a nice and
    simple API, making it a good candidate for an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the Tippy.js documentation: [https://atomiks.github.io/tippyjs/](https://atomiks.github.io/tippyjs/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the `tippy.js` library using a package manager of our choice,
    we can then import Tippy.js into our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can initialize `tippy` with the following constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass in the element where Tippy.js should provide a tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify any customizations of the tooltip''s content through the data
    attributes of the element, which Tippy.js will pick up as it initializes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can pass this in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the content after initialization, call the Tippy.js `setContent`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To permanently destroy and clean up the tooltip instance, Tippy.js provides
    the `destroy` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have all we need to create a `tippy` action. We have methods to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `tippy` tooltip – `tippy(…)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean up the `tippy` tooltip – `tooltipInstance.destroy()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `tippy` tooltip – `tooltipInstance.setContent(…)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at what the `tippy` action should look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I want it to look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we applied our `tippy` action to a `<div>` element.
    The content within the tooltip created by Tippy.js should be passed into the `tippy`
    action as action data, represented by the `tooltipContent` variable. Whenever
    `tooltipContent` changes, the action should react to it and update the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s write our `tippy` Svelte action. Here’s the scaffolding for an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we created the `tippy` action based on the Svelte action contract:
    a function that returns an object with `destroy` and `update` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I left three TODOs in the code, each marking different stages of Svelte actions.
    Let’s go through each one and fill them up. The first `TODO` is where the action
    will be called after the element is created and mounted onto the DOM. Here, we
    are given the element the action is applied to and the action data, and we should
    use it to initialize the Tippy.js tooltip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `TODO` is inside the `update` method. This method will be called
    every time the action data changes. Here, we need to call the Tippy.js tooltip
    instance to reflect the dataset in the Svelte component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The third `TODO` is inside the `destroy` method. This method will be called
    after the element is removed from the DOM. Here, we need to do the cleanup on
    the Tippy.js tooltip instance that we created in the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it – we now have a working `tippy` action that integrates the Tippy.js
    tooltip and will show a tooltip with customizable content whenever we hover over
    the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete code on GitHub: [https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy](https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at one more example, through which I want to show you one more thing
    that you can do with actions when integrating with UI libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The UI library we are going to look at next is CodeMirror.
  prefs: []
  type: TYPE_NORMAL
- en: Example – integrating CodeMirror
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CodeMirror is a code editor component that has many great features for editing,
    such as syntax highlighting, code folding, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the CodeMirror documentation at [https://codemirror.net/](https://codemirror.net/).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, CodeMirror is currently at version 5.65.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the `codemirror` library using the package manager of our
    choice, we can import `codemirror` into our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can initialize CodeMirror with the following constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass in the element where we want the CodeMirror code editor to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I continue, at this point, note that we are looking for the same set
    of things from CodeMirror:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods to initialize CodeMirror
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any method needed to clean up a CodeMirror instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any method to update a CodeMirror instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am going to leave it to you to complete the checklist and figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, allow me to draw your attention to one particular API from the CodeMirror
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `on` method from CodeMirror allows the CodeMirror instance to listen to
    events and react to them.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we want to add event listeners to the CodeMirror instance from outside
    of the action, how should we do it?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that we could create custom events on the element
    using actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can allow users to listen to the `''change''` event from
    the element that uses the `codemirror` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this happen, you can dispatch an event from within the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember to check whether you need to clean up or unlisten to any event in the
    `destroy` method so that you don’t cause any unwanted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it!
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the action is left to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete code on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to integrate vanilla UI libraries into Svelte.
    However, not all UI libraries are implemented independently without any framework.
    Sometimes, the library you are looking for might be implemented in a different
    framework, such as React or Vue. In such cases, how can you integrate them into
    a Svelte application? That is what we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Using UI libraries written in other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not impossible to use components from other frameworks in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: However, doing so will introduce the framework’s runtime and other overheads
    that come along with the framework. The runtime usually includes code to handle
    reactivity and normalize browser APIs and events. Each framework usually ships
    its own code for this logic and does not share it with other frameworks. The runtime
    for React version 18.2.0 weighs 6.4 kB when minified, which is additional code
    you need to include when you want to use a React component within Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is not recommended unless it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this section has been included in this book is more for educational
    purposes and to demonstrate that this is possible, as well as what needs to be
    done to make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating components in various frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each framework usually provides an API that takes in a container element and
    the framework component as the root of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’re going to take a look at React and Vue, the two most popular
    JavaScript frameworks at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in React 18, we use the `createRoot` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the JSX syntax, which is not part of the standard JavaScript
    language syntax. It is syntactic sugar for `jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You will have to write the preceding code if you do not configure any transpiling
    process in your code to turn JSX syntax into valid JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, In Vue 3, there is the `createApp` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The Vue framework uses the word *application* in the documentation, mentioning
    that the `createApp` method is used to create a new application instance. The
    word *application* is aptly used as integrating component libraries written in
    other frameworks is very much like starting a new sub-application within our Svelte
    application.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also started to notice the similarity between the APIs from these
    frameworks and other UI libraries that we’ve seen so far – all of them take in
    a container element so that they know where to render the content or apply changes.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to integrating UI libraries using actions, after figuring out what APIs
    we can use to render a component within a container element, the next thing we
    must check is whether there is any API to clean up when it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the components in various frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on the underlying framework of the component library, different APIs
    are provided to clean up whenever the component is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, there is a method for this called `unmount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In Vue, it is also called `unmount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to check is whether there is any API to pass data into
    our component and API so that they can be updated later.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the component in various frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to different frameworks having different APIs for cleaning up, frameworks
    provide different APIs to update the component with new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with React, you can pass data into a React component through
    props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is akin to the props in a Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code desugars into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the props of the component, React allows us to call `root.render`
    again with the same component but with a different prop value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: React will reconcile this internally and figure out how to update the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, in Vue, you can pass data through props in the `createApp`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: However, to the best of my knowledge, there’s no straightforward way to update
    the props’ value from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you could use a Vue Composition API, such as `ref()`, to create a
    reactive and mutable ref. With that, you could modify the ref instead of updating
    the props directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It is okay if you are not familiar with how React and Vue work. This book is
    for Svelte, not for React or Vue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing to take home from this is that when integrating a
    UI library, whether it is in vanilla JavaScript, React, or Vue, we look for three
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: A method to create the component with a container element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to clean up the component instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to pass in data and update the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are familiar with a framework, you will be able to figure out a way to
    do all these things.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, let’s take a look at a real-world example, where we
    will integrate a React calendar library, `react-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating react-calendar into Svelte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `react-calendar` library is a calendar component library written in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about it here: [https://projects.wojtekmaj.pl/react-calendar/](https://projects.wojtekmaj.pl/react-calendar/).'
  prefs: []
  type: TYPE_NORMAL
- en: The `react-calendar` library takes in various props for customization purposes.
    But for demonstration purposes, we are only going to focus on two props, `value`
    and `onChange`, which allow us to control the selected date of the library.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the selected date through a prop named `value`. The `onChange` prop,
    on the other hand, is used to pass in an event handler that will be called when
    the value changes from within the calendar component. We saw how we could handle
    event handlers in a UI library in the previous section when we discussed CodeMirror.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is what I think using the `calendar` action would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, `event.detail` is the data attached to the custom `'change'` event, which
    would be the date value that’s sent from the `react-calendar` component through
    the `onChange` props.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what our `calendar` action would look like, let’s write the
    action out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, here’s the scaffolding of an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve created a basic code structure of a Svelte action and left a few
    TODOs within the code. The first two TODOs are to set up the `calendar` instance
    with the element the action is applied to. The third `TODO` is to handle when
    a new date is passed into the action, and the last `TODO` is to clean up when
    the element is removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s fill up the TODOs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first `TODO`, let’s create a React root and render our `react-calendar`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed in `onChange`, which we have not defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, whenever `onChange` is called, we will dispatch
    a new custom event, with `value` passed in as the detail for the custom event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third `TODO` is the content for the `update` method. Whenever a new date
    value is passed in from the action, we will re-render the `Calendar` component
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last `TODO`, in the `destroy` method, we unmount our `Calendar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete code on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar).'
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve written a Svelte action that integrates a component library
    from a different framework, React, into Svelte, and you set up and updated the
    component’s value in a controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use actions to integrate UI libraries, either
    written in vanilla JavaScript or any other frameworks into Svelte. We went through
    two real-world examples – integrating Tippy.js and `react-calendar` into Svelte
    using Svelte actions. In both examples, we went through a step-by-step process
    of writing out a Svelte action. We started by creating the structure of a Svelte
    action and then filled up the steps within the action for when the Svelte action
    is initialized as the element is created, when the data changes, and when the
    element is removed from the DOM. We also discussed why we choose to use Svelte
    actions, as well as the other alternatives and considerations when it comes to
    integrating UI libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the next common pattern of actions, which
    is to progressively enhance your elements.
  prefs: []
  type: TYPE_NORMAL
