<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Authentication</h1></div></div></div><p>Most of the web applications use some kind of authorization and <a id="id410" class="indexterm"/>authentication subsystems to allow its users to access private information of the application. However, the authentication process can be tricky if you don't have a clear idea about how to implement it as Backbone does not provide a hint about how to do it.</p><p>Backbone is authentication agnostic, which means that its does not provide objects or tools to implement an authentication strategy. The advantage is that Backbone is not coupled with an authentication mechanism and the disadvantage is that you should care about it.</p><p>As Backbone was made with REST APIs in mind, you will have to deal with the authentication mechanisms that are common in that kind of APIs. That's a good reason why Backbone does not impose or provide tools in order to authenticate users.</p><p>Another thing to keep in mind is that REST APIs should be stateless, which means that they do not keep track of the requests that you previously made. What it means for you is that if you make a login request, you will expect the server to recognize you on the subsequent requests; however, in a stateless server, it will not remember you.</p><p>This may sound crazy if you have not worked with REST web services before; however, you have to authenticate each time you make a requests to the server. That's necessary and there are many available ways to do it; you should consult the API documentation in order to know the exact details of the authentication algorithm.</p><p>Despite the many options that are available, they are very similar each other with changes in just some kind of details; however, in essence, they work in a very similar way. Therefore, don't worry about the number of different ways that are available to authenticate; learn the basics and change the details.</p><div class="section" title="Stateless API authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Stateless API authentication</h1></div></div></div><p>Authenticate<a id="id411" class="indexterm"/> against a stateless API implies that you <a id="id412" class="indexterm"/>should authenticate each time that you make a request to the server; keep in mind that a stateless server does not keep track of the previous requests. This means that each time you make a request to the server, it will process the petition as the first one.</p><p>As sessions are not stored in the server, you should put that information somewhere else. For Backbone applications, the right place to store the session data is the browser, you can use <code class="literal">localStorage</code> to store and retrieve the session data and JavaScript to manage the session.</p><div class="section" title="HTTP Basic authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec53"/>HTTP Basic authentication</h2></div></div></div><p>The simplest way <a id="id413" class="indexterm"/>to authenticate against a RESTFul API is with the HTTP Basic Authentication. The idea behind this is simple; you should include an encoded version of your username and password for every request you make. It may sound risky to send your user and password for each request, and it is. For this reason, it's highly advisable to only use Basic authentication where you have the HTTPS connections enabled:</p><div class="mediaobject"><img src="graphics/B01962_10_01.jpg" alt="HTTP Basic authentication"/><div class="caption"><p>Figure 10.1 Basic authentication schema</p></div></div><p>The user and password should be sent under the <code class="literal">Authentication</code> header of the request. Consider the following scenario:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User: myuser</li><li class="listitem" style="list-style-type: disc">Password: 123456</li></ul></div><p>To encode <a id="id414" class="indexterm"/>the <code class="literal">Authentication</code> header, the user and password should be concatenated with the <code class="literal">:</code> character as the separator.</p><div class="informalexample"><pre class="programlisting">myuser:123456</pre></div><p>Then, the string should be encoded as <code class="literal">base64</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo myuser:123456 | base64</strong></span>
<span class="strong"><strong>bXl1c2VyOjEyMzQ1Ngo=</strong></span>
</pre></div><p>The resulting string should be used for every request made to the server:</p><div class="informalexample"><pre class="programlisting">GET /api/contacts
Authorization: Basic bXl1c2VyOjEyMzQ1Ngo=</pre></div><p>The server will decode and authenticate you for each request you make. Remember that you should not use this mechanism without HTTPS. It's very easy for someone to intercept a request header and decode the string in order to discover your user and password.</p></div><div class="section" title="The OAuth2 authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec54"/>The OAuth2 authentication</h2></div></div></div><p>The <a id="id415" class="indexterm"/>OAuth2 protocol was made to share resources among services without the use of a user and password. It is possible that you have used an application where you can authenticate using a social network account. That's OAuth2 in action. The OAuth2 authentication is an authorization framework described in RFC 6749, as follows:</p><div class="mediaobject"><img src="graphics/B01962_10_02.jpg" alt="The OAuth2 authentication"/><div class="caption"><p>Figure 10.2 OAuth2 abstract flow</p></div></div><p>In the preceding figure, you can see an abstract diagram of authentication using the OAuth2 algorithm. You can identify the next entities, as shown in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>Resource Owner</strong></span> is the <a id="id416" class="indexterm"/>entity that owns the protected data. This is normally a person.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Web application</strong></span> is the <a id="id417" class="indexterm"/>application that wants to access the private data of the Resource Owner.</li><li class="listitem" style="list-style-type: disc">An <span class="strong"><strong>Authorization server</strong></span> identifies<a id="id418" class="indexterm"/> and authenticates the users of the Resource server, where the protected data lives.</li><li class="listitem" style="list-style-type: disc">An <span class="strong"><strong>Access token</strong></span> is <a id="id419" class="indexterm"/>the data to be used in the Resource server in order to authorize the resource access. The Access tokens normally have an expiration time.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Resource server</strong></span> is the host that serves the protected data.</li></ul></div><p>Note that the <a id="id420" class="indexterm"/>Resource server and the Authorization server can be the same host. The authentication process is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The application asks for authorization to the resource owner.</li><li class="listitem">The resource owner authorizes and an authorization key is issued.</li><li class="listitem">The application uses the authorization key to exchange it for an access token.</li><li class="listitem">The authorization server validates the authorization key and the applications.</li><li class="listitem">The authorization server issues an access token and returns it to the application.</li><li class="listitem">The application can use the access token to access the protected resources.</li></ol></div><p>The issued access token should normally expire from time to time in order to prevent an attacker from using it maliciously. When a token expires, the application should repeat the authentication process.</p><p>However, it's not practical to log in each time that a token expires. In order to prevent this, the authorization server issues another token named <code class="literal">refresh token</code> that can be used to issue a new access token when the current access token expires.</p><div class="section" title="Service applications"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec03"/>Service applications</h3></div></div></div><p>When you <a id="id421" class="indexterm"/>want to access the private data of a service such as Facebook, Twitter, Google, and so on, you must register your application with the service first. When you register your application with the service, they will ask you for an application name, description, website, and so on.</p><p>When the application is registered, the service will give you some tokens to identify your application, these tokens include two key data, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ClientID</strong></span>: This<a id="id422" class="indexterm"/> univocally identifies your application against the service</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ClientSecret</strong></span>: This <a id="id423" class="indexterm"/>is used to authenticate whether the request made with a given ClientID is legitimate</li></ul></div><p>If the REST server that you are building for your application is accessed only by you, you can manually generate a <code class="literal">ClientID</code> and <code class="literal">ClientSecret</code> as constant values in the application.</p><p>If your REST server will expose a public API for anyone who wants to play with the application data, you should develop some kind of application registration (such as user signup) in order to allow others to register their applications.</p></div></div><div class="section" title="OAuth2 grant types"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec55"/>OAuth2 grant types</h2></div></div></div><p>In the <a id="id424" class="indexterm"/>previous section, you have seen the OAuth2 protocol as an <a id="id425" class="indexterm"/>abstract schema of authentication. The RFC 6749 document specification describes four different ways to obtain an access token.</p><div class="section" title="Authorization code grant"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec04"/>Authorization code grant</h3></div></div></div><p>Authorization<a id="id426" class="indexterm"/> code grant is the most complete authorization flow; its main usage is to access private resources of the user from another server:</p><div class="mediaobject"><img src="graphics/B01962_10_03.jpg" alt="Authorization code grant"/><div class="caption"><p>Figure 10.3 Authorization code grant</p></div></div><p>Refer to preceding figure. Server App is an application server (such as Node.js, Python, and so on), and the API Server is a third-party server, where the private resources lives (such as Facebook, Google, and so on).</p><p>In the Authorization Code Grant scenario, the Server App wants to access the data from the API Server in benefit of the <span class="strong"><strong>User</strong></span>. This is done through the Server App; as the user interacts with Backbone App, it makes requests to the Server App, then Server App can fetch the data from the API Server, apply some processing, and return a response to the Backbone App.</p><p>The Backbone App never establishes a single connection to the API Server, it is the responsibility of Server App so that Backbone App only sees a single Server App.</p></div><div class="section" title="Implicit Grant"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec05"/>Implicit Grant</h3></div></div></div><p>This is a<a id="id427" class="indexterm"/> simplification of Authorization Code Grant; the usage of implicit grant is for pure frontend applications without server or mobile applications:</p><div class="mediaobject"><img src="graphics/B01962_10_04.jpg" alt="Implicit Grant"/><div class="caption"><p>Figure 10.4 Implicit grant</p></div></div><p>In the<a id="id428" class="indexterm"/> implicit grant, App Server does not exist, therefore, the Backbone App should communicate directly with the API Server. Despite the simplicity of the implicit grant, you should be warned about the security issues.</p><p>To minimize this risk, your applications should be secured with HTTPS and do not use this flow type if you don't have it enabled. Another related issue is that this grant type does not issue a refresh token, which means that you should re-login when the access token expires.</p></div><div class="section" title="Resource Owner Password Credentials Grant"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec06"/>Resource Owner Password Credentials Grant</h3></div></div></div><p>This <a id="id429" class="indexterm"/>grant type is useful when the Backbone App and API Server are the same application. In other words, the frontend application and the backend server are developed by you, which means that you are not accessing to third-party resources.</p><p>As your application owns all the resources, you will need the user and password of the application to authenticate it:</p><div class="mediaobject"><img src="graphics/B01962_10_05.jpg" alt="Resource Owner Password Credentials Grant"/><div class="caption"><p>Figure 10.5 Resource owner password</p></div></div><p>The preceding diagram is very similar to the Implicit Grant diagram; however, in this case, you don't need to use ClientID and ClientSecret tokens, which simplifies the authentication process.</p><p>When you use <a id="id430" class="indexterm"/>this grant type, it feels like the classic way of authentication; you should send your user and password to the server and it will then tell you whether your credentials are valid or not. If they are valid, you will receive a valid access token that you can store and use as you want.</p></div><div class="section" title="Client credentials grant"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec07"/>Client credentials grant</h3></div></div></div><p>Client credentials grant is used when <a id="id431" class="indexterm"/>you have a trusted client that accesses the server resources. A business partner, for example. In this grant type, you are not authenticating an user but an application, therefore, you don't need an user or password.</p><p>In this grant, you should use ClientID and ClientSecret, if the API Server trusts the client, an access token will be issued.</p><div class="mediaobject"><img src="graphics/B01962_10_06.jpg" alt="Client credentials grant"/><div class="caption"><p>Figure 10.6 Client credentials</p></div></div></div><div class="section" title="Resume"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec08"/>Resume</h3></div></div></div><p>In the <a id="id432" class="indexterm"/>previous sections, you have seen how to use the OAuth2 framework to authenticate against a REST server; in the OAuth2, specifications are described in four ways to make authentication and the use of any one of them depends on the requirements of the application.</p><p>However, the goal of the all these grant types is to get an access token that can be used for the next server request. Once you have an access token, the interaction with the API server should be transparent for Backbone App, the token should be send without the knowledge of rest of the application.</p></div></div></div></div>
<div class="section" title="Implementing HTTP Basic Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Implementing HTTP Basic Authentication</h1></div></div></div><p>Let's implement the Basic Auth protocol in <code class="literal">Contacts App</code>. As you have learned in the previous sections, you will need to add the <code class="literal">Authorization</code> header for every request that you make to the server in order to be authenticated. From the server side, you will need to read and parse this header.</p><p>A <a id="id433" class="indexterm"/>useful <code class="literal">npm</code> package to decode the <code class="literal">Authorization</code> header has been developed. With the <code class="literal">basic-auth</code> module, you can read the request headers and return an object with two fields: <code class="literal">name</code> and <code class="literal">pass</code>, these fields can be used to authenticate the user. For simplicity, we will use a hardcoded user and password, not a real database:</p><div class="informalexample"><pre class="programlisting">// server/basicAuthMiddleware.js
var basicAuth = require('basic-auth');

var authorizationRequired = function (req, res, next) {
  var credentials = basicAuth(req) || {};

  if (credentials.name === 'john' &amp;&amp; credentials.pass === 'doe') {
    return next();
  } else {
    return res.sendStatus(401);
  }
};

module.exports = authorizationRequired;</pre></div><p>The middleware <a id="id434" class="indexterm"/>checks whether the user is <code class="literal">john</code> and the password is <code class="literal">doe</code>. If not, an HTTP <code class="literal">401</code> error will be sent to the client. You can use the middleware for each resources that you want to protect:</p><div class="informalexample"><pre class="programlisting">var controller = require('./controller');
var authorizationRequired = require('./basicAuthMiddleware');


module.exports = routes = function(server) {
  server.post('/api/contacts',
authorizationRequired, controller.createContact);
  server.get('/api/contacts',
authorizationRequired, controller.showContacts);
  server.get('/api/contacts/:contactId',
authorizationRequired, controller.findContactById);
  server.put('/api/contacts/:contactId',
authorizationRequired, controller.updateContact);
  server.delete('/api/contacts/:contactId',
authorizationRequired, controller.deleteContact);
  server.post('/api/contacts/:contactId/avatar',
authorizationRequired, controller.uploadAvatar);
};</pre></div><p>The <code class="literal">WWW-Authenticate</code> header that we include in the HTTP 401 response will make sure that the browser prompts a dialog box asking you for a user and password. You can use the <code class="literal">john</code> user and the <code class="literal">doe </code>password in the dialog, then the browser will build and send the Authentication header for you:</p><div class="mediaobject"><img src="graphics/B01962_10_07.jpg" alt="Implementing HTTP Basic Authentication"/><div class="caption"><p>Figure 10.7 Basic authentication login</p></div></div><p>To have <a id="id435" class="indexterm"/>more control over how to ask for authentication, you can create a <code class="literal">form</code> view and add some routes for authentication purposes:</p><div class="informalexample"><pre class="programlisting">&lt;div class="col-xs-12 col-sm-offset-4 col-sm-4"&gt;
&lt;div class="panel"&gt;
&lt;div class="panel-body"&gt;
&lt;h4&gt;
Login required
&lt;/h4&gt;
&lt;p&gt;
Use 'john' as user and 'doe' as password.
&lt;/p&gt;
&lt;form&gt;
&lt;div class="form-group"&gt;
&lt;label for="username"&gt;User&lt;/label&gt;
&lt;input type="user" class="form-control" id="username" placeholder="Username"&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
&lt;label for="password"&gt;Password&lt;/label&gt;
&lt;input type="password" class="form-control" id="password" placeholder="Password"&gt;
&lt;/div&gt;
&lt;p id="message" class="pull-left"&gt;&lt;/p&gt;
&lt;button type="submit" class="btn btn-primary pull-right"&gt;Login&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</pre></div><p>The <code class="literal">LoginView</code>  method <a id="id436" class="indexterm"/>should handle the authentication process when the user clicks the <span class="strong"><strong>Login</strong></span> button:</p><div class="informalexample"><pre class="programlisting">// apps/login/views/loginView.js
'use strict';

var Common = require('../../../common');
var template = require('../templates/login.tpl');

class LoginView extends Common.ModelView {
  constructor(options) {
    super(options);
    this.template = template;
  }

  get className() {
    return 'row';
  }

  get events() {
    return {
      'click button': 'makeLogin'
    };
  }

  makeLogin(event) {
    event.preventDefault();

    var username = this.$el.find('#username').val();
    var password = this.$el.find('#password').val();

console.log('Will login the user', username,
                'with password', password);
  }
}

module.exports = LoginView; </pre></div><p>A new route <a id="id437" class="indexterm"/>should be added to show the <code class="literal">#/login</code> form:</p><div class="informalexample"><pre class="programlisting">// apps/login/router.js
'use strict';

var Backbone = require('backbone');
var LoginView = require('./views/loginView');

class LoginRouter extends Backbone.Router {
  constructor(options) {
    super(options);

    this.routes = {
      'login': 'showLogin'
    };

    this._bindRoutes();
  }

  showLogin() {
    var App = require('../../app');
    var login = new LoginView();

    App.mainRegion.show(login);
  }
}

module.exports = new LoginRouter();</pre></div><p>You will need to include this new router when the application bootstraps, as follows:</p><div class="informalexample"><pre class="programlisting">// app.js
// ...

// Initialize all available routes
require('./apps/contacts/router');
require('./apps/login/router');

// ...</pre></div><p>When an <a id="id438" class="indexterm"/>unauthenticated user accesses the <code class="literal">#/contacts</code> route, Backbone Application should redirect them to the login form:</p><div class="informalexample"><pre class="programlisting">Backbone.$.ajaxSetup({
  statusCode: {
    401: () =&gt;{
      window.location.replace('/#login');

    }
  }
});</pre></div><p>When the server responds with an HTTP 401, it means that the user is not authenticated and you then can show the login window. Remember to remove the <code class="literal">WWW-Authenticate</code> response header in order to prevent the browser from showing its login dialog:</p><div class="informalexample"><pre class="programlisting">function unauthorized(res) {
  // res.set('WWW-Authenticate', 'Basic realm=Authorization Required');
  return res.sendStatus(401);
};</pre></div><div class="mediaobject"><img src="graphics/B01962_10_08.jpg" alt="Implementing HTTP Basic Authentication"/><div class="caption"><p>Figure 10.8 Login form</p></div></div><p>Now that we have <a id="id439" class="indexterm"/>a login form in place, we can put the authentication code in it. That's going to be done in the following three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Build the Authentication string.</li><li class="listitem">Test whether the Authentication string is valid.</li><li class="listitem">Save the Authentication string for future requests.</li></ol></div><p>The authentication string is easy to build, you can use the <code class="literal">btoa()</code>function to convert strings to <code class="literal">base64</code>, as follows:</p><div class="informalexample"><pre class="programlisting">class LoginView extends Common.ModelView {
  // ...

  makeLogin(event) {
    event.preventDefault();

    var username = this.$el.find('#username').val();
    var password = this.$el.find('#password').val();
    var authString = this.buildAuthString(
      username, password
    );

    console.log('Will use', authString);
  }

  buildAuthString(username, password) {
    return btoa(username + ':' + password);
  }
}</pre></div><p>Then, you can <a id="id440" class="indexterm"/>use <code class="literal">authString</code> to test whether can get the contacts resource successfully. If the server answers successfully, then the user is using the right credentials:</p><div class="informalexample"><pre class="programlisting">class LoginView extends Common.ModelView {
  // ...

  makeLogin(event) {
    event.preventDefault();

    var username = this.$el.find('#username').val();
    var password = this.$el.find('#password').val();
    var authString = this.buildAuthString(
      username, password
    );

    Backbone.$.ajax({
      url: '/api/contacts',
      headers: {
        Authorization: 'Basic ' + authString
      },
      success: () =&gt; {
        var App = require('../../../app');
        App.router.navigate('contacts', true);
      },
      error: jqxhr =&gt; {
        if (jqxhr.status === 401) {
          this.showError('User/Password are not valid');
        } else {
          this.showError('Oops... Unknown error happens');
        }
      }
    });
  }

  buildAuthString(username, password) {
    return btoa(username + ':' + password);
  }

  showError(message) {
    this.$('#message').html(message);
  }
}</pre></div><p>If the Authentication <a id="id441" class="indexterm"/>string is valid, then the user is redirected to the contact list; however, the redirection will not work as expected as the <code class="literal">Authorization</code> header in the contact list is not sent. Remember that you should send the Authorization header for every request.</p><p>You will need to save the <code class="literal">Authentication</code> string in <code class="literal">sessionStorage</code> to be used in future requests. The <code class="literal">sessionStorage</code> is similar to <code class="literal">localStorage</code>; however, in <code class="literal">sessionStorage</code>, the data will be removed when the browser is closed:</p><div class="informalexample"><pre class="programlisting">class LoginView extends Common.ModelView {
  // ...

  makeLogin(event) {
// ...

    Backbone.$.ajax({
      url: '/api/contacts',
      headers: {
        Authorization: 'Basic ' + authString
      },
      success: () =&gt; {
        var App = require('../../../app');
        App.saveAuth('Basic', authSting);
        App.router.navigate('contacts', true);
      },
      error: jqxhr =&gt; {
        if (jqxhr.status === 401) {
          this.showError('User/Password are not valid');
        } else {
          this.showError('Oops... Unknown error happens');
        }
      }
    });
  }

// ...
}</pre></div><p>The <code class="literal">App</code> object will be responsible for storing the token:</p><div class="informalexample"><pre class="programlisting">// app.js
var App = {
  // ...

  // Save an authentication token
  saveAuth(type, token) {
    var authConfig = type + ':' + token;

    sessionStorage.setItem('auth', authConfig);
    this.setAuth(type, token);
  },

  // ...
}</pre></div><p>After the token is <a id="id442" class="indexterm"/>saved in <code class="literal">sessionStorage</code>, you should include the <code class="literal">Authorization</code> header for every future request:</p><div class="informalexample"><pre class="programlisting">// app.js
var App = {
  // ...

  // Set an authorization token
  setAuth(type, token) {
    var authString = type + ' ' + token;
    this.setupAjax(authString);
  },

  // Set Authorization header for authentication
  setupAjax(authString) {
    var headers = {};

    if (authString) {
      headers = {
        Authorization: authString
      };
    }

    Backbone.$.ajaxSetup({
      statusCode: {
        401: () =&gt; {
          App.router.navigate('login', true);
        }
      },
      headers: headers
    });
  }

  // ...
}</pre></div><p>When the <a id="id443" class="indexterm"/>application is bootstrapped, it should look whether there is an active session open; if so, it should use the session, as shown in the following:</p><div class="informalexample"><pre class="programlisting">// app.js
var App = {
start() {
    // The common place where sub-applications will be showed
    App.mainRegion = new Region({el: '#main'});

    this.initializePlugins();

    // Load authentication data
    this.initializeAuth();

    // Create a global router to enable sub-applications
    // to redirect to
    // other URLs
    App.router = new DefaultRouter();
    Backbone.history.start();
  },

  // ...

  // Load authorization data from sessionStorage
  initializeAuth() {
    var authConfig = sessionStorage.getItem('auth');

    if (!authConfig) {
      return window.location.replace('/#login');
    }

    var splittedAuth = authConfig.split(':');
    var type = splittedAuth[0];
    var token = splittedAuth[1];

    this.setAuth(type, token);
  },

  // ...
}</pre></div><p>The user should <a id="id444" class="indexterm"/>be able to log out. Let's add a route for the user to log out in the App router:</p><div class="informalexample"><pre class="programlisting">// app.js

// General routes non sub-application dependant
class DefaultRouter extends Backbone.Router {
  constructor(options) {
    super(options);
    this.routes = {
      '': 'defaultRoute',
      'logout': 'logout'
    };
    this._bindRoutes();
  }

  // Redirect to contacts app by default
  defaultRoute() {
    this.navigate('contacts', true);
  }

  // Drop session data
  logout() {
    App.dropAuth();
    this.navigate('login', true);
  }
}</pre></div><p>The session is removed when the <code class="literal">auth</code> string is removed from <code class="literal">sessionStorage</code> and the Authentication header is not sent anymore:</p><div class="informalexample"><pre class="programlisting">var App = {
  // ...

  // Remove authorization token
  dropAuth() {
    sessionStorage.removeItem('auth');
    this.setupAjax(null);
  },

  // …
}</pre></div><p>That's how you <a id="id445" class="indexterm"/>can implement authorization with the HTTP Basic Auth protocol. An authorization string is generated and attached for every request made to the server, that's done with the help of the <code class="literal">ajaxSetup()</code>method of jQuery. In the following section, we will see how to implement the OAuth2 protocol.</p></div>
<div class="section" title="Implementing OAuth authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Implementing OAuth authentication</h1></div></div></div><p>As we <a id="id446" class="indexterm"/>did for <a id="id447" class="indexterm"/>Basic Auth, we are going to build a server-side implementation of the OAuth2 protocol. As the Backbone App and Server App are both built by us, the best grant type to choose is <span class="emphasis"><em>Resource Owner Password Credentials Grant</em></span>.</p><p>A difference from Basic Auth is that OAuth2 needs to add an endpoint that is used to issue access and refresh tokens. As described in RFC-6749, the requests made to this endpoint should include the following:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>The client makes a request to the token endpoint by adding the following parameters using the "application/x-www-form-urlencoded":</em></span></p><p><span class="emphasis"><em>grant_type: REQUIRED.  Value MUST be set to "password".</em></span></p><p><span class="emphasis"><em>username: REQUIRED.  The resource owner username.</em></span></p><p><span class="emphasis"><em>Password: REQUIRED.  The resource owner password.</em></span></p></blockquote></div><p>A valid request will look as shown in the following:</p><div class="informalexample"><pre class="programlisting">POST /api/oauth/token HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;username=john&amp;password=doe</pre></div><p>Then, the server <a id="id448" class="indexterm"/>will respond with a valid access token, an optional refresh token, and a token type; it could contain additional values, as follows:</p><div class="informalexample"><pre class="programlisting">HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "example_parameter":"example_value"
}</pre></div><p>The <code class="literal">token_type</code> value tells the client about the kind of token that was issued, in our case, it is <code class="literal">Bearer</code>. We can start the implementation by creating the necessary functions in order to issue authorization tokens:</p><div class="informalexample"><pre class="programlisting">function authorize(data, callback) {
  var grantType = data.grant_type;
  var username = data.username;
  var password = data.password;

  if (grantType !== 'password') {
    return callback({error: 'invalid_grant'});
  }

  if (!username || !password) {
    return callback({error: 'invalid_request'});
  }

  if (username === 'john' &amp;&amp; password === 'doe') {
    issueAuthorization(username, callback);
  } else {
    callback({error: 'invalid_grant'});
  }
}</pre></div><p>As specified in <a id="id449" class="indexterm"/>the RFC document, if the grant type is not supported, then we should respond with an <code class="literal">invalid_grant</code> error; and if a parameter is missing in the request, then we should respond with an <code class="literal">invalid_request</code> error.</p><p>If the username and password coincide, then we can issue an authorization token:</p><div class="informalexample"><pre class="programlisting">const DEFAULT_EXPIRATION_TIME = 3600; // seconds (1 hour)

// ...

function issueAuthorization(username, callback) {
  var accessToken = generateToken();
  var refreshToken = generateToken();
  var token = {
    access_token: accessToken,
    token_type: 'Bearer',
    expires_in: DEFAULT_EXPIRATION_TIME,
    refresh_token: refreshToken
  };

  saveValidToken(token, username);
  callback(token);
}</pre></div><p>The generated tokens are just a random string generated with the <code class="literal">generateToken()</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">const TOKEN_LENGTH = 20;

// ...

function generateToken() {
return crispy.base32String(TOKEN_LENGTH);
}</pre></div><p>These tokens should be stored somewhere in order to be validated for future requests. For simplicity, in this <a id="id450" class="indexterm"/>book, we will store the tokens in memory objects; however, you can use a databases such as Redis for real projects:</p><div class="informalexample"><pre class="programlisting">var validTokens = {};
var refreshTokens = {};

// ...

function saveValidToken(token, username) {
  var tokenCopy = _.clone(token);
  tokenCopy.username = username;

  validTokens[token.access_token] = tokenCopy;
  refreshTokens[token.refresh_token] = tokenCopy;

  setTimeout(function() {
    expireToken(tokenCopy.access_token);
  }, DEFAULT_EXPIRATION_TIME * 1000);
}

function expireToken(token) {
  delete validTokens[token];
}</pre></div><p>The <code class="literal">validTokens</code> and <code class="literal">refreshTokens</code>are hash tables store the tokens. The tokens in <code class="literal">validTokens </code>should be removed after the <a id="id451" class="indexterm"/>
<span class="strong"><strong>TTL</strong></span> (<span class="strong"><strong>Time to live</strong></span>) expires, the <code class="literal">setTimeout()</code> call will ensure that these items are automatically removed.</p><p>To validate whether a user is authenticated, we just need to check whether the token is active in the <code class="literal">validTokens</code>hash table, as follows:</p><div class="informalexample"><pre class="programlisting">function authenticate(token, callback) {
  if (_.has(validTokens, token)) {
    callback({valid: true, token: validTokens[token]});
  } else {
    callback({valid: false, token: null});
  }
}</pre></div><p>With the function that is described in this section, it is possible to implement OAuth2 in our Contacts App project. Let's add a route in order to generate the access tokens and add a middleware to protect the resources, as follows:</p><div class="informalexample"><pre class="programlisting">var controller = require('./controller');
var auth = require('./oauth2Middleware);

module.exports = routes = function(server) {
  server.post('/api/oauth/token', auth.authenticate);
  server.post('/api/contacts', auth.requireAuthorization,
    controller.createContact);
  server.get('/api/contacts', auth.requireAuthorization,
    controller.showContacts);
  server.get('/api/contacts/:contactId',
    auth.requireAuthorization, controller.findContactById);
  server.put('/api/contacts/:contactId',
    auth.requireAuthorization, controller.updateContact);
  server.delete('/api/contacts/:contactId',
    auth.requireAuthorization, controller.deleteContact);
  server.post('/api/contacts/:contactId/avatar',
    auth.requireAuthorization, controller.uploadAvatar);
};</pre></div><p>The <code class="literal">oauth2Middleware</code> module<a id="id452" class="indexterm"/> provides the <code class="literal">requireAuthorization()</code> middleware and the <code class="literal">authenticate()</code>authentication handler as described in the following:</p><div class="informalexample"><pre class="programlisting">module.exports = {
  authenticate(req, res) {
    authorize(req.body || {}, _.bind(res.json, res));
  }
}</pre></div><p>To issue a new token, you need to call the <code class="literal">authorize()</code> function, which returns a valid OAuth2 response as specified in the RFC document:</p><div class="informalexample"><pre class="programlisting">requireAuthorization(req, res, next) {
  var authorization = req.headers.authorization || '';

  if (!authorization) {
    return res.sendStatus(401);
  }

  var splitValues = authorization.split(' ');
  var tokenType = splitValues[0];
  var token = splitValues[1];

  if (!tokenType || tokenType !== 'Bearer' || !token) {
    return res.sendStatus(401);
  }

  authenticate(token, function(response) {
    if (response.valid) {
      next();
    } else {
      return res.sendStatus(401);
    }
  });
}</pre></div><p>The <code class="literal">requireAuthorization()</code> middleware is used to protect the resources with our OAuth2 protocol implementation. The middleware splits the token in two parts: the token type and the <a id="id453" class="indexterm"/>token itself; it verifies whether the token type and its existence in the active access tokens list is valid.</p><p>In the Backbone App, we can reuse the objects that we made for the Basic Auth protocol; however, we have to make small changes. In the <code class="literal">LoginView</code> object, you should change the <code class="literal">url</code> request to <code class="literal">/api/oauth/token</code> and change the method to <code class="literal">POST</code>, as follows:</p><div class="informalexample"><pre class="programlisting">class LoginView extends Common.ModelView {
  // ...

  makeLogin(event) {
    event.preventDefault();

    var username = this.$el.find('#username').val();
    var password = this.$el.find('#password').val();

    Backbone.$.ajax({
      method: 'POST',
      url: '/api/oauth/token',
      data: {
        grant_type: 'password',
        username: username,
        password: password
      },
      success: response =&gt; {
        var App = require('../../../app');
        var accessToken = response.access_token;
        var tokenType = response.token_type;

        App.saveAuth(tokenType, accessToken);
        App.router.navigate('contacts', true);
      },
      error: jqxhr =&gt; {
        if (jqxhr.status === 401) {
          this.showError('User/Password are not valid');
        } else {
          this.showError('Oops... Unknown error happens');
        }
      }
    });
  }

  buildAuthenticationString(token) {
    return 'Bearer ' + token;
  }

  showError(message) {
    this.$('#message').html(message);
  }
}</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Summary</h1></div></div></div><p>Authentication in Backbone applications can be tricky if you don't have a clear vision of how authentication works in REST servers. As Backbone is authentication agnostic, it does not force you to use an authentication mechanism. As a developer, it's your responsibility to create one or adhere to an existing one.</p><p>In Backbone Apps, backed by stateless servers, you should move the session handling code to the browser. In the examples shown in this chapter, we used <code class="literal">sessionStorage</code> to store the access tokens; however, you can use another storage solution such as <code class="literal">localStorage</code> and <code class="literal">indexeddb</code>, or even cookies.</p><p>Then, we saw how to combine the theory with the practical implementation of the Basic Auth and OAuth2 protocols in Contacts App. The implementation was transparent for the rest of the application, therefore, you can switch between the implementations easily.</p></div></body></html>