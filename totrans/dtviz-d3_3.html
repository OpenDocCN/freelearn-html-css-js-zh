<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Making Data Useful"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Making Data Useful</h1></div></div></div><p>At its core, d3.js <a id="id168" class="indexterm"/>is a data manipulation library. We're going to take a look at making our datasets useful with both d3.js and plain old JavaScript.</p><p>We start with a quick dip into functional programming to bring everyone up to speed. You can skip this part if you use Haskell, Scala, or Lisp, or already write JavaScript in a functional style.</p><p>We continue loading external data, taking a closer look at the scales I can't stop writing about, and finish with some temporal and geographic data.</p><div class="section" title="Thinking about data functionally"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Thinking about data functionally</h1></div></div></div><p>Due to the functional design of d3.js, we have to start thinking of our code and data with a functional mindset.</p><p>The good news is that JavaScript<a id="id169" class="indexterm"/> almost counts as a functional language; there are enough features to get the benefits of a functional style, and also provides enough freedom to do things imperatively or in an object-oriented way. The bad news is that, unlike real functional languages, the environment gives no guarantee about our code.</p><p>In this section, we'll go through the basics of functional-style coding and look at wrangling the data so that it's easier to work with. If you want to try proper functional programming, I suggest looking at Haskell and <span class="emphasis"><em>Learn You a Haskell for Great Good</em></span> available at <a class="ulink" href="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a>.</p><p>The idea behind functional <a id="id170" class="indexterm"/>programming is simple—compute by relying only on function arguments. Simple, but the consequences are far reaching.</p><p>The biggest consequence is that we don't have to rely on state, which in turn gives us referential transparency. This means functions executed with the same parameters will always give the same results regardless of when or how they're called.</p><p>In practice this means we design the code and dataflow, that is, get data as input, execute a sequence of functions that pass changed data down the chain, and eventually get a result.</p><p>You've already seen this in previous examples.</p><p>Our dataset started and <a id="id171" class="indexterm"/>ended as an array of values. We performed some actions for each item and we relied only on the current item when deciding what to do. We also had the current index, so we could cheat a little with an imperative approach by looking ahead and behind in the stream.</p><div class="section" title="Built-in array functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Built-in array functions</h2></div></div></div><p>JavaScript comes with a slew of array-manipulation functions<a id="id172" class="indexterm"/>. We'll focus on those which are more functional in nature, the iteration methods.</p><p>A smart man once told me you can model any algorithm by using <code class="literal">map</code> and <code class="literal">reduce</code>. But he was wrong. What you need is recursion, a way to add two arrays together, the ability to get the first and second element of an array, an equality comparator, and a way to decide if something is a value or an array. In fact that's how LISP is defined.</p><p>But you will get pretty far with <code class="literal">map</code>, <code class="literal">reduce</code>, and <code class="literal">filter</code> in combination with their predicates.</p><p>The <code class="literal">map</code> command<a id="id173" class="indexterm"/> applies a<a id="id174" class="indexterm"/> function on every element of an array and returns a new array with changed values:</p><div class="informalexample"><pre class="programlisting">&gt; [1,2,3,4].map(function (d) { return d+1; })
[ 2, 3, 4, 5 ]</pre></div><p>The <code class="literal">reduce</code> function<a id="id175" class="indexterm"/> uses <a id="id176" class="indexterm"/>a combining function and a starting value to collapse an array into a single value:</p><div class="informalexample"><pre class="programlisting">&gt; [1,2,3,4].reduce(function (accumulator, current) { return accumulator+current; }, 0)
10</pre></div><p>The <code class="literal">filter</code> function<a id="id177" class="indexterm"/> goes through <a id="id178" class="indexterm"/>an array and keeps elements for which the predicate returns <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">&gt; [1,2,3,4].filter(function (d) { return d%2; })
[ 1, 3 ]</pre></div><p>Two more useful functions are <code class="literal">.every()</code> and <code class="literal">.some()</code>, which are true if every or some items in the array are true. Sometimes, using <code class="literal">.forEach()</code> instead of <code class="literal">.map()</code> is better because <code class="literal">forEach</code> operates on the original array instead of creating a copy, which is important for working with large arrays and is mainly used for the side-effect.</p><p>These functions are relatively new to JavaScript, whereas <code class="literal">map</code> and <code class="literal">filter</code> have existed since JavaScript 1.7, and <code class="literal">reduce</code> since 1.8; these are also a part of the emerging ECMAScript 6 standard and, thus, not supported on older browsers. You can use libraries, such as underscore.js or one of the various es6 shims to support older browsers.</p></div><div class="section" title="Data functions of d3.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Data functions of d3.js</h2></div></div></div><p>d3.js comes with <a id="id179" class="indexterm"/>plenty of its own array functions. They mostly have to do with<a id="id180" class="indexterm"/> handling data; it comprises calculating averages, ordering, bisecting arrays, and many helper functions for associative arrays.</p><p>Let's play with data functions and draw an unsolved mathematical problem named Ulam spiral. Discovered in 1963, it reveals patterns in the distribution of prime numbers on a two-dimensional plane. So far, nobody has found a formula that explains them.</p><p>We'll construct the spiral by simulating Ulam's pen-and-paper method; we'll write natural numbers in a spiraling pattern, and then remove all non-primes.</p><p>Instead of numbers we'll draw dots. The first stage in our experiment will look as follows:</p><div class="mediaobject"><img src="images/0007OS_03_01.jpg" alt="Data functions of d3.js"/></div><p>Doesn't look like much, but that's only the first 5,000 primes in a spiral. Notice the diagonals? Some can be described with polynomials, which brings interesting implications about predicting prime numbers and by extension, the safety of cryptography.</p><p>We begin with a drawing area:</p><div class="informalexample"><pre class="programlisting">var width = 768,
  height = 768,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
                  height: height});</pre></div><p>Then we define the <a id="id181" class="indexterm"/>algorithm that generates a list of numbers and their <a id="id182" class="indexterm"/>spiraling coordinates on a grid. We start with some helpful variables:</p><div class="informalexample"><pre class="programlisting">var spiral = function (n) {
  var directions = {up: [0, -1],
                      left: [-1, 0],
                      down: [0, 1],
                      right: [1, 0]};

  var x = 0,
    y = 0,
      min = [0, 0],
      max = [0, 0],
      add = [0, 0],
      direction = 0;

  var spiral = [];
});</pre></div><p>We defined a <code class="literal">spiral</code> function<a id="id183" class="indexterm"/> that takes a single upper-bound argument, <code class="literal">n</code>. The function starts with four directions of travel and some variables for our algorithm. The combination of <code class="literal">min</code> and <code class="literal">max</code> known coordinates will tell us when to turn; <code class="literal">x</code> and <code class="literal">y</code> will be the current position, whereas <code class="literal">direction</code> will tell us which part of the spiral we're tracing.</p><p>Next we add the algorithm itself to the bottom of our function:</p><div class="informalexample"><pre class="programlisting">d3.range(1, n).forEach(function (i) {
    spiral.push({x: x, y: y, n: i});

    add = directions[['up', 'left', 'down', 'right'][direction]];
    x += add[0], y += add[1];

    if (x &lt; min[0]) {
      direction = (direction+1)%4;
      min[0] = x;
    }
    if (x &gt; max[0]) {
      direction = (direction+1)%4;
      max[0] = x;
    }
    if (y &lt; min[1]) {
      direction = (direction+1)%4;
      min[1] = y;
    }
    if (y &gt; max[1]) {
      direction = (direction+1)%4;
      max[1] = y;
    }
  });

  return spiral;</pre></div><p>
<code class="literal">d3.range()</code> generates <a id="id184" class="indexterm"/>an array of numbers between the two arguments that we iterate <a id="id185" class="indexterm"/>with <code class="literal">forEach</code>. Each iteration adds a new <code class="literal">{x: x, y: y, n: i}</code> triplet to the spiral array. The rest is just using <code class="literal">min</code> and <code class="literal">max</code> to change the direction on the spiral's corners. Yes it's repetitive, but we don't always have to be clever.</p><p>Now we get to draw stuff:</p><div class="informalexample"><pre class="programlisting">var dot = d3.svg.symbol().type('circle').size(3),
  center = 400,
    x = function (x, l) { return center+l*x; },
    y = function (y, l) { return center+l*y; };</pre></div><p>We've defined a <code class="literal">dot</code> generator and two functions to help us turn grid coordinates from the <code class="literal">spiral</code> function<a id="id186" class="indexterm"/> into pixel positions. <code class="literal">l</code> is the length and width of a square in the grid.</p><p>We can avoid the dirty work of calculating primes by getting a list online. I found a list at <a class="ulink" href="http://www.mathsisfun.com/">http://www.mathsisfun.com/</a> and placed it on GitHub next to the code examples at <a class="ulink" href="https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt">https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt</a>.</p><div class="informalexample"><pre class="programlisting">d3.text('primes-to-100k.txt', function (data) {
  var primes = data.split('\n').slice(0, 5000).map(Number),
    sequence = spiral(d3.max(primes)).filter(function (d) {
    return _.indexOf(primes, d['n'], true) &gt; -1;
    });
  var l = 2;

  svg.selectAll('path')
    .data(sequence)
    .enter()
    .append('path')
    .attr('transform',
         function (d) { return 'translate('+x(d['x'], l)+', '+y(d['y'], l)+')'; })
    .attr('d', dot);
});</pre></div><p>We load the <a id="id187" class="indexterm"/>primes as a text file, split it into lines, use <code class="literal">.slice()</code> to get the <a id="id188" class="indexterm"/>first <code class="literal">5000</code> elements, then turn them into numbers using <code class="literal">.map(Number)</code>. We'll use <code class="literal">l</code> to tell the <code class="literal">x</code> and <code class="literal">y</code> functions how big the grid is.</p><p>We call <code class="literal">spiral</code> with the largest prime on our list, (<code class="literal">d3.max()</code>), to generate the spiraling sequence of numbers and then use <code class="literal">.filter()</code> to remove all non-primes from the spiral when feeding them into the drawing code.</p><p>We used <code class="literal">_.indexOf</code> of underscore.js to search for primes because it uses binary search and makes our code faster. The caveat is that we have to know our list is ordered. You can get underscore.js from <a class="ulink" href="http://underscorejs.org">http://underscorejs.org</a>.</p><p>My aging machine still takes about two seconds to draw the interesting pixelated image.</p><p>Let's make it more interesting by visualizing the density of primes. We'll define a grid with larger squares, and then color them depending on how many dots they contain. Squares will be red when there are fewer primes than median, and green when there are more. The shading will tell us how far they are from the median.</p><p>First, we'll use the <code class="literal">nest</code> structure of d3.js to define a new grid:</p><div class="informalexample"><pre class="programlisting">var scale = 8;

  var regions = d3.nest()
    .key(function (d) { return Math.floor(d['x']/scale); })
    .key(function (d) { return Math.floor(d['y']/scale); })
    .rollup(function (d) { return d.length; })
     .map(sequence);</pre></div><p>We scale by a factor of <code class="literal">8</code>, that is, each new square contains 64 of the old squares.</p><p>
<code class="literal">d3.nest()</code> is handy for turning data into nested dictionaries according to a key. The first <code class="literal">.key()</code> function creates our columns; every <code class="literal">x</code> is mapped to the corresponding <code class="literal">x</code> of the new grid. The second <code class="literal">.key()</code> function does the same for <code class="literal">y</code>. We then use <code class="literal">.rollup()</code> to turn the resulting lists into a single value, a count of the dots.</p><p>The data goes in with <code class="literal">.map()</code> and we get a structure as follows:</p><div class="informalexample"><pre class="programlisting">{
    "0": {
        "0": 5,
        "-1": 2
    },
    "-1": {
        "0": 3,
        "-1": 4
    }
}</pre></div><p>Not very self-explanatory, but that's a collection of columns containing rows. The (<code class="literal">0</code>, <code class="literal">0</code>) square contains <code class="literal">5</code> primes, (<code class="literal">-1</code>, <code class="literal">0</code>) contains <code class="literal">2</code>, and so on.</p><p>To get the median and the number of shades, we need those counts in an array:</p><div class="informalexample"><pre class="programlisting">var values = d3.merge(d3.keys(regions).map(function (_x) {
      return d3.values(regions[_x]);
    }));

  var median = d3.median(values),
    extent = d3.extent(values),
      shades = (extent[1]-extent[0])/2;</pre></div><p>We map through the <a id="id189" class="indexterm"/>keys of our regions (<code class="literal">x</code> coordinates) to get a list of values for each <a id="id190" class="indexterm"/>column, and then use <code class="literal">d3.merge()</code> to flatten the resulting array of arrays.</p><p>
<code class="literal">d3.median()</code> gives us the middle value of our array and <code class="literal">d3.extent()</code> gives us the lowest and highest number, which we used to calculate the number of shades we needed.</p><p>Finally, we walk the coordinates again to color the new grid:</p><div class="informalexample"><pre class="programlisting">d3.keys(regions).forEach(function (_x) {
    d3.keys(regions[_x]).forEach(function (_y) {

      var color,
        red = '#e23c22',
        green = '#497c36';

      if (regions[_x][_y] &gt; median) {
        color = d3.rgb(green).brighter(regions[_x][_y]/shades);
      }else{
        color = d3.rgb(red).darker(regions[_x][_y]/shades);
      }

      svg.append('rect')
        .attr({x: x(_x, a*scale),
                  y: y(_y, a*scale),
                  width: a*scale,
                  height: a*scale})
        .style({fill: color,
                 'fill-opacity': 0.9});
    });
  });</pre></div><p>Our image looks<a id="id191" class="indexterm"/> like <a id="id192" class="indexterm"/>one of those Chiptunes album covers:</p><div class="mediaobject"><img src="images/0007OS_03_02.jpg" alt="Data functions of d3.js"/></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Loading data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Loading data</h1></div></div></div><p>One of the greatest <a id="id193" class="indexterm"/>features of d3.js is that it can asynchronously load external data without any help from third-party libraries or a programmer. We've already glanced at data loading, but it's time to take a closer look.</p><p>The reason we want to load data externally is that bootstrapping large datasets into the page with predefined variables isn't very practical. Loading hundreds of kilobytes of data takes a while and doing so asynchronously lets the rest of the page render in the meantime.</p><p>To make HTTP requests, d3.js uses <a id="id194" class="indexterm"/>XMLHttpRequests (XHR for short). This limits us to a single domain because of the browser's security model, but we can do cross-domain requests if the server sends an <code class="literal">Access-Control-Allow-Origin: *</code> header.</p><div class="section" title="The core"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>The core</h2></div></div></div><p>At the core of all this<a id="id195" class="indexterm"/> loading, is the humble <code class="literal">d3.xhr()</code>, the manual way of issuing an XHR request.</p><p>It takes a URL and an optional callback. If present, the callback will immediately trigger the request and receives data as an argument once the request finishes.</p><p>If there's no callback, we get to tweak the request; everything from the headers to the request method.</p><p>To make a request you might have to write the following code:</p><div class="informalexample"><pre class="programlisting">var xhr = d3.xhr('&lt;a_url&gt;');
xhr.mimeType('application/json');
xhr.header('User-Agent', 'our example');
xhr.on('load', function (request) { … });
xhr.on('error', function (error) { … });
xhr.on('progress', function () { … });
xhr.send('GET');</pre></div><p>This will send a GET request expecting a JSON response and tell the server we're an example. One way to shorten this is by defining a callback immediately, but then you can't define custom headers or listen for other request events.</p><p>Another way is convenience functions. We'll be using these throughout the book.</p></div><div class="section" title="Convenience functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Convenience functions</h2></div></div></div><p>d3.js comes with <a id="id196" class="indexterm"/>several convenience functions that use <code class="literal">d3.xhr()</code> behind the scenes, and parse the response before giving it back to us. This lets us limit our workflow to calling the appropriate function and defining a callback, which takes an <code class="literal">error</code> and a <code class="literal">data</code> argument. d3.js is nice enough to let us throw caution to the wind and use callbacks with a single <code class="literal">data</code> argument that will be undefined in case of error.</p><p>We have a choice of data formats such as TEXT, JSON, XML, HTML, CSV, and TSV. JSON and CSV/TSV are used the most: JSON for small structured data, and CSV/TSV for large data dumps where we want to conserve space.</p><p>A lot of our code will follow this kind of pattern:</p><div class="informalexample"><pre class="programlisting">d3.json('a_dataset.json', function (data) {
  // draw stuff
});</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Scales"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Scales</h1></div></div></div><p>Scales <a id="id197" class="indexterm"/>are functions that map a domain to a range. Yeah, yeah, I keep saying that, but there really isn't much more to say.</p><p>The reason we use them is to avoid math. This makes our code shorter, easier to understand, and more robust as mistakes in high school mathematics are some of the hardest bugs to track down.</p><p>If you haven't just spent four years listening to mathematics at school, a function's domain are those values where it is defined (the input), and the range are those values it returns.</p><p>The following figure is borrowed from Wikipedia:</p><div class="mediaobject"><img src="images/0007OS_03_03.jpg" alt="Scales"/></div><p>Here, <span class="strong"><strong>X</strong></span> is the domain, <span class="strong"><strong>Y</strong></span> is the range, and arrows are the functions.</p><p>We need a bunch of code to implement this manually:</p><div class="informalexample"><pre class="programlisting">var shape_color = function (shape) {
  if (shape == 'triangle') {
    return 'red';
  }else if (shape == 'line') {
    return 'yellow';
  }else if (shape == 'pacman') {
    return 'green';
  }else if (shape == 'square') {
    return 'red';
  }
};</pre></div><p>You could also do it with a dictionary, but <code class="literal">d3.scale</code> will always be more elegant and flexible:</p><div class="informalexample"><pre class="programlisting">var scale = d3.scale.ordinal()
    .domain(['triangle', 'line', 'pacman', 'square'])
    .range(['red', 'yellow', 'green', 'red']);</pre></div><p>Much better!</p><p>Scales come in three<a id="id198" class="indexterm"/> types; ordinal scales have a discrete domain, quantitative scales have a continuous domain, and time scales have a time-based continuous domain.</p><div class="section" title="Ordinal scales"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Ordinal scales</h2></div></div></div><p>Ordinal scales<a id="id199" class="indexterm"/> are the simplest, essentially just a dictionary where keys are the domain and values are the range.</p><p>In the preceding example, <a id="id200" class="indexterm"/>we defined an ordinal scale by explicitly setting both the input domain and the output range. If we don't define a domain, it's inferred from use, but that can give unpredictable results.</p><p>A cool thing about ordinal scales is that having a range smaller than the domain makes the scale cycle values. Furthermore, we'd get the same result if the range was just <code class="literal">['red', 'yellow', 'green']</code>. But, cutting a continuous interval into chunks can make an even better range, histograms, for instance.</p><p>Let's try.</p><p>First we need a drawing area:</p><div class="informalexample"><pre class="programlisting">var width = 800,
  height = 600,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
           height: height});</pre></div><p>Then we define the three scales we need, and generate some data:</p><div class="informalexample"><pre class="programlisting">var data = d3.range(30),
  colors = d3.scale.category10(),
  points = d3.scale.ordinal().domain(data)
                 .rangePoints([0, height], 1.0),
  bands = d3.scale.ordinal().domain(data)
                 .rangeBands([0, width], 0.1);</pre></div><p>Our data is just a list of numbers going upto <code class="literal">30</code>, and the <code class="literal">colors</code> scale is from <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <span class="emphasis"><em>A Primer on DOM, SVG, and CSS</em></span>. It is a predefined ordinal scale with an undefined domain and a range of ten colors.</p><p>Then we defined <a id="id201" class="indexterm"/>two scales that split our drawing into equal parts. <code class="literal">points</code> uses <code class="literal">.rangePoints()</code> to distribute <code class="literal">30</code> equally-spaced points along the height of our drawing. We set the edge padding<a id="id202" class="indexterm"/> with a factor of <code class="literal">1.0</code>, which sets the distance from the last point to the edge to half the distance between the points. End points are moved inwards from the range edge using <code class="literal">point_distance*padding/2</code>.</p><div class="mediaobject"><img src="images/0007OS_03_11.jpg" alt="Ordinal scales"/></div><p>
<code class="literal">bands</code> uses <code class="literal">.rangeBands()</code> to divide the width into <code class="literal">30</code> equal bands with a padding factor of <code class="literal">0.1</code> between bands. This time we're setting the distance between bands, using <code class="literal">step*padding</code>, and a third argument would set edge padding using <code class="literal">step*outerPadding</code>.</p><div class="mediaobject"><img src="images/0007OS_03_12.jpg" alt="Ordinal scales"/></div><p>We'll use code you already know from <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <span class="emphasis"><em>A Primer on DOM, SVG, and CSS</em></span>, to draw two lines using these scales:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('path')
  .data(data)
  .enter()
  .append('path')
  .attr({d: d3.svg.symbol().type('circle').size(10),
      transform: function (d) { 
        return 'translate('+(width/2)+', '+points(d)+')'; }
    })
  .style('fill', function (d) { return colors(d); });

svg.selectAll('rect')
  .data(data)
  .enter()
  .append('rect')
  .attr({x: function (d) { return bands(d); },
     y: height/2,
     width: bands.rangeBand(),
     height: 10})
  .style('fill', function (d) { return colors(d); });</pre></div><p>To get the positions <a id="id203" class="indexterm"/>for each <a id="id204" class="indexterm"/>dot or rectangle, we called the scales as functions and used <code class="literal">bands.rangeBand()</code> to get the rectangle width.</p><p>The picture looks as follows:</p><div class="mediaobject"><img src="images/0007OS_03_04.jpg" alt="Ordinal scales"/></div></div><div class="section" title="Quantitative scales"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Quantitative scales</h2></div></div></div><p>Quantitative scales <a id="id205" class="indexterm"/>come in a few different flavors, but they all share a common <a id="id206" class="indexterm"/>characteristic that the input domain is continuous. Instead of a set of discrete values, a continuous scale can be modeled with a simple function. The seven types of quantitative scales are linear, identity, power, log, quantize, quantile, and threshold. They define different transformations of the input domain. The first four have a continuous output range while the latter three map to a discrete range.</p><p>To see how they behave, we'll use all these scales to manipulate the <code class="literal">y</code> coordinate when drawing the<a id="id207" class="indexterm"/> <code class="literal">weierstrass</code> function; the first discovered function that is continuous everywhere but differentiable nowhere. This means that even though you can draw the function without lifting your pen, you can never define the angle you're drawing at (calculate a derivative).</p><p>We begin with a drawing area and the <code class="literal">weierstrass</code> function as found on Wikipedia is as follows:</p><div class="informalexample"><pre class="programlisting">var width = 800,
  height = 600,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
           height: height});

var weierstrass = function (x) {
  var a = 0.5,
    b = (1+3*Math.PI/2)/a;

  return d3.sum(d3.range(100).map(function (n) {
    return Math.pow(a, n)*Math.cos(Math.pow(b, n)*Math.PI*x);
  }));
};</pre></div><p>A drawing function will help us avoid code repetition:</p><div class="informalexample"><pre class="programlisting">var draw_one = function (line) {
  return svg.append('path')
    .datum(data)
    .attr("d", line)
    .style({'stroke-width': 2,
            fill: 'none'});
};</pre></div><p>We generate some data, get the <code class="literal">extent</code> of the <code class="literal">weierstrass</code> function, and use a linear scale for <code class="literal">x</code>:</p><div class="informalexample"><pre class="programlisting">var data = d3.range(-100, 100).map(function (d) { return d/200; }),
  extent = d3.extent(data.map(weierstrass)),
  colors = d3.scale.category10(),
  x = d3.scale.linear().domain(d3.extent(data)).range([0, width]);</pre></div><div class="section" title="Continuous range scales"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Continuous range scales</h3></div></div></div><p>We can draw <a id="id208" class="indexterm"/>using the<a id="id209" class="indexterm"/> following code:</p><div class="informalexample"><pre class="programlisting">var linear = d3.scale.linear().domain(extent).range([height/4, 0]),
  line1 = d3.svg.line()
    .x(x)
    .y(function(d) { return linear(weierstrass(d)); });

draw_one(line1)
  .attr('transform', 'translate(0, '+(height/16)+')')
  .style('stroke', colors(0));</pre></div><p>We defined a linear scale with the domain encompassing all the values returned by the <code class="literal">weierstrass</code> function, and a range from zero to the drawing width. The scale will use linear interpolation to translate between the input and the output, and will even predict values that fall outside its domain. If we don't want that happening, we can use <code class="literal">.clamp()</code>. Using more than two numbers in the domain and range, we can create a polylinear scale where each section behaves like a separate linear scale.</p><p>The linear scale creates the following screenshot:</p><div class="mediaobject"><img src="images/0007OS_03_05.jpg" alt="Continuous range scales"/></div><p>Let's add the other continuous scales in one fell swoop:</p><div class="informalexample"><pre class="programlisting">var identity = d3.scale.identity().domain(extent),
  line2 = line1.y(function (d) { return identity(weierstrass(d)); });

draw_one(line2)
  .attr('transform', 'translate(0, '+(height/12)+')')
  .style('stroke', colors(1));

var power = d3.scale.pow().exponent(0.2).domain(extent).range([height/2, 0]),
  line3 = line1.y(function (d) { return power(weierstrass(d)); });

draw_one(line3)
  .attr('transform', 'translate(0, '+(height/8)+')')
  .style('stroke', colors(2));

var log = d3.scale.log().domain(
  d3.extent(data.filter(function (d) { return d &gt; 0 ? d : 0; }))).range([0, width]),
  line4 = line1.x(function (d) { return d &gt; 0 ? log(d) : 0; })
    .y(function (d) { return linear(weierstrass(d)); });
draw_one(line4)
  .attr('transform', 'translate(0, '+(height/4)+')')
  .style('stroke', colors(3));</pre></div><p>We keep re-using the <a id="id210" class="indexterm"/>same <code class="literal">line</code> definition, changing the scale <a id="id211" class="indexterm"/>used for <code class="literal">y</code>, except for the <code class="literal">power</code> scale, because changing <code class="literal">x</code> makes a better example.</p><p>We also took into account that <code class="literal">log</code> is only defined on positive numbers, but you usually wouldn't use it for periodic functions anyway. It's much better at showing large and small numbers on the same graph.</p><p>Now our picture looks as follows:</p><div class="mediaobject"><img src="images/0007OS_03_06.jpg" alt="Continuous range scales"/></div><p>The <code class="literal">identity</code> scale is orange and wiggles around by barely a pixel because the data we feed into the function only goes from -0.5 to 0.5, the <code class="literal">power</code> scale is green, and the <code class="literal">logarithmic</code> scale is red.</p></div><div class="section" title="Discrete range scales"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Discrete range scales</h3></div></div></div><p>The interesting scales for <a id="id212" class="indexterm"/>our comparison are <code class="literal">quantize</code> <a id="id213" class="indexterm"/>and <code class="literal">threshold</code>. The <code class="literal">quantize</code> scale cuts the input domain into equal parts and maps them to values in the output range, while <code class="literal">threshold</code> scales let us map arbitrary domain sections to discrete values:</p><div class="informalexample"><pre class="programlisting">var quantize = d3.scale.quantize().domain(extent)
                        .range(d3.range(-1, 2, 0.5).map(function (d) { return d*100; })),
  line5 = line1.x(x).y(function (d) { return quantize(weierstrass(d)); }),
  offset = 100

draw_one(line5)
  .attr('transform', 'translate(0, '+(height/2+offset)+')')
  .style('stroke', colors(4));

var threshold = d3.scale.threshold().domain([-1, 0, 1]).range([-50, 0, 50, 100]),
  line6 = line1.x(x).y(function (d) { return threshold(weierstrass(d)); });

draw_one(line6)
  .attr('transform', 'translate(0, '+(height/2+offset*2)+')')
  .style('stroke', colors(5));</pre></div><p>The <code class="literal">quantize</code> scale will divide the <code class="literal">weierstrass</code> function into discrete values between 1 and 2 with a step of 0.5 (-1, -0.5, 0, and so on), and threshold will map values smaller than -1 to -50, -1 to 0, and so on.</p><p>The result looks as follows:</p><div class="mediaobject"><img src="images/0007OS_03_07.jpg" alt="Discrete range scales"/></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Time</h1></div></div></div><p>You don't understand <a id="id214" class="indexterm"/>time. You might think you do, but you don't.</p><p>Keep this in mind next time you want to add 3,600 seconds to a timestamp to advance it by an hour, or basically <code class="literal">now+24*3600</code> is tomorrow.</p><p>Time is a complicated beast. An hour <a id="id215" class="indexterm"/>can last 3600 seconds or 3599 seconds, if there's a leap second. Tomorrow can be 23 to 25 hours away, months range from 28 to 31 days, and a year can be 365 or 366 days. Some decades have fewer days than others.</p><p>Considering many datasets are closely tied to time, this can become a big problem. Just how do you handle time?</p><p>Luckily, d3.js comes with a bunch of time-handling features.</p><div class="section" title="Formatting"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Formatting</h2></div></div></div><p>You can create a new <a id="id216" class="indexterm"/>formatter by giving <code class="literal">d3.time.format()</code> a format string. You can then use it for parsing strings into <code class="literal">Date</code> objects and vice-versa.</p><p>The whole language is explained in the documentation of d3.js, but let's look at a few examples:</p><div class="informalexample"><pre class="programlisting">&gt; format = d3.time.format('%Y-%m-%d')
&gt; format.parse('2012-02-19')
Sun Feb 19 2012 00:00:00 GMT+0100 (CET)</pre></div><p>We defined a new formatter with <code class="literal">d3.time.format()</code> (year-month-day), then parsed a date as they often appear in datasets. This gave us a proper <code class="literal">date</code> object with default values for hours, minutes, and seconds.</p><p>The same formatter works the other way:</p><div class="informalexample"><pre class="programlisting">&gt; format(new Date())
"2013-02-19"</pre></div><p>You can find the full ISO<a id="id217" class="indexterm"/> standard time formatter at <code class="literal">d3.time.format.iso</code>. That often comes in handy.</p></div><div class="section" title="Time arithmetic"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Time arithmetic</h2></div></div></div><p>We also get a full suite of time arithmetic functions<a id="id218" class="indexterm"/> that work with <a id="id219" class="indexterm"/>JavaScript's <code class="literal">Date</code> objects and follow a few simple rules:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">d3.time.interval</code>, where <code class="literal">interval</code> can be a <code class="literal">second</code>, <code class="literal">minute</code>, <code class="literal">hour</code>, and so on. It returns a new time interval. For instance, <code class="literal">d3.time.hour</code> will be an hour long.</li><li class="listitem"><code class="literal">d3.time.interval</code>(<code class="literal">Date</code>), is an alias for <code class="literal">interval.floor()</code>, which rounds <code class="literal">Date</code> down so that more specific units than the <code class="literal">interval</code> are set to zero.</li><li class="listitem"><code class="literal">interval.offset</code>(<code class="literal">Date</code>, <code class="literal">step</code>), will move the date by a specified number of steps to the correct unit.</li><li class="listitem"><code class="literal">interval.range</code>(<code class="literal">Date_start</code>, <code class="literal">Date_stop</code>), will return every <code class="literal">interval</code> between the two specified dates.</li><li class="listitem"><code class="literal">d3.time.intervals</code>, where an <code class="literal">interval</code> is <code class="literal">seconds</code>, <code class="literal">minutes</code>, <code class="literal">hours</code>, and so on. They are helpful aliases for <code class="literal">interval.range</code>.</li></ol></div><p>For instance, if you want to find the time an hour from now, you'd do this:</p><div class="informalexample"><pre class="programlisting">&gt; d3.time.hour.offset(new Date(), 1)
Tue Feb 19 2013 06:09:17 GMT+0100 (CET)</pre></div><p>And find out it's getting really late and you should stop writing books about JavaScript, and go to bed.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Geography"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Geography</h1></div></div></div><p>Other useful data types are<a id="id220" class="indexterm"/> geospatial coordinates, often used for weather or population data; anything where you want to draw a map.</p><p>d3.js gives us three tools for geographic data: paths produce the final pixels, projections turn sphere coordinates into Cartesian coordinates, and streams speed things up.</p><p>The main data format <a id="id221" class="indexterm"/>we'll use is TopoJSON, a more compact extension of GeoJSON, created by Mike Bostock. In a way, TopoJSON is to GeoJSON what DivX is to video. While GeoJSON<a id="id222" class="indexterm"/> uses the JSON format to encode geographical data with points, lines, and polygons, TopoJSON instead encodes basic features with arcs and re-uses them to build more and more complex features. As a result, files can be as much as 80 percent smaller than when we use GeoJSON.</p><div class="section" title="Getting geodata"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Getting geodata</h2></div></div></div><p>Now, unlike many other <a id="id223" class="indexterm"/>datasets, geodata can't be found just lying around the Internet. Especially not in a fringe format such as <a id="id224" class="indexterm"/>TopoJSON. We'll find some data in Shapefile or GeoJSON formats, and then use the<a id="id225" class="indexterm"/> <code class="literal">topojson</code> command-line utility to transform them into TopoJSON. Finding detailed data can be difficult, but is not impossible, look for your country's census bureau. For instance, the US Census Bureau has many useful datasets available at <a class="ulink" href="http://www.census.gov/geo/www/cob/index.html">http://www.census.gov/geo/www/cob/index.html</a>.</p><p>Natural Earth is another magnificent resource for geodata at different levels of detail. The biggest advantage is that different layers (oceans, countries, roads, and so on) are carefully made to fit together without discrepancies and are frequently updated. You can find the datasets at <a class="ulink" href="http://www.naturalearthdata.com/">http://www.naturalearthdata.com/</a>.</p><p>Let's prepare some data for the next example. Go to <a class="ulink" href="http://www.naturalearthdata.com/">http://www.naturalearthdata.com/</a> and download the <code class="literal">ocean</code>, <code class="literal">land</code>, <code class="literal">rivers and lake centerlines</code>, and <code class="literal">land boundary lines</code> datasets at 50m detail level, and the <code class="literal">urban areas</code> dataset at 10m. You'll find them in the <span class="strong"><strong>Downloads</strong></span> tab. The files are also in the examples on GitHub available at <a class="ulink" href="https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data">https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data</a>.</p><p>Unzip the five files. We'll combine them into three TopoJSON files to save the request time, three big files are quicker than five small files, and we prefer TopoJSON because of the smaller file size.</p><p>We'll merge categorically so that we can reuse the files later; one for water data, another for land data, and a third for cultural data.</p><p>You'll need to install <code class="literal">topojson</code>, which needs node.js. Follow the installation instructions for your computer on <code class="literal">nodejs.org</code>, then open a terminal, and run this command:</p><div class="informalexample"><pre class="programlisting">&gt; npm install -global topojson</pre></div><p>
<code class="literal">npm</code> is node's built-in package manager. It downloads and installs the <code class="literal">topojson</code> library globally. You might have to run this as a super user.</p><p>Next, we transform the files with three simple commands:</p><div class="informalexample"><pre class="programlisting">&gt; topojson -o water.json ne_50m_rivers_lake_centerlines.shp ne_50m_ocean.shp
&gt; topojson -o land.json ne_50m_land.shp
&gt; topojson -o cultural.json ne_50m_admin_0_boundary_lines.shp ne_10m_urban_areas.shp</pre></div><p>The <code class="literal">topojson</code> library transforms shape files into TopoJSON files and merges the files we wanted. We specified where to put the results with <code class="literal">-o</code>; the other arguments were source files.</p><p>We've generated <a id="id226" class="indexterm"/>three files: <code class="literal">water.json</code>, <code class="literal">land.json</code>, and <code class="literal">cultural.json</code>. Feel free to look at them, but they aren't very human-friendly.</p></div><div class="section" title="Drawing geographically"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Drawing geographically</h2></div></div></div><p>
<code class="literal">d3.geo.path()</code> <a id="id227" class="indexterm"/>is going to be the work horse of our <a id="id228" class="indexterm"/>geographic drawings. It's similar to the SVG path generators we learned about earlier, except it draws geographic data and is smart enough to decide whether to draw a line or an area.</p><p>To flatten spherical objects such as planets into a 2D image, <code class="literal">d3.geo.path()</code> uses projections. Different kinds of projections are designed to showcase different things about the data, but the end result is you can completely change what the map looks like, just by changing the projection or moving its focal point.</p><p>With the right projection you can even make the data of Europe look like the U.S. Rather unfortunately then, the default projection is <code class="literal">albersUsa</code> designed specifically to draw the standard map of U.S.</p><p>Let's draw a map of the world, centered and zoomed into Europe because that's where I'm from. We'll make it navigable in <a class="link" href="ch04.html" title="Chapter 4. Making Things Move">Chapter 4</a>, <span class="emphasis"><em>Making Things Move</em></span>.</p><p>We first need to add some things to our standard HTML file.</p><p>Add an empty <code class="literal">style</code> definition above the main div; we'll use it later to make our map look better:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;&lt;/style&gt;</pre></div><p>We also need two more JavaScript files right after d3.js:</p><div class="informalexample"><pre class="programlisting">&lt;script src="http://d3js.org/topojson.v0.min.js"&gt;&lt;/script&gt;
&lt;script src="http://d3js.org/queue.v1.min.js"&gt;&lt;/script&gt;</pre></div><p>These load the TopoJSON parser and a queue utility to help us load more than one dataset.</p><p>We continue in our JavaScript file with a drawing area:</p><div class="informalexample"><pre class="programlisting">var width = 1800,
  height = 1200,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
             height: height});</pre></div><p>Next, we define a geographic <code class="literal">projection</code>:</p><div class="informalexample"><pre class="programlisting">var projection = d3.geo.equirectangular()
    .center([8, 56])
    .scale(800);</pre></div><p>The <code class="literal">equirectangular</code> projection<a id="id229" class="indexterm"/> is one of the twelve projections that come with d3.js, and is perhaps the most common projection we're used to seeing ever since high school.</p><p>The problem<a id="id230" class="indexterm"/> with <code class="literal">equirectangular</code> is that it doesn't preserve areas or represent the earth's surface all that well. A full discussion of projecting a sphere onto a two dimensional surface would take too much time, so I suggest looking at the Wikipedia page of d3.js and the visual comparison of all the projections implemented in the projection plugin. It is available at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Geo-Projections">https://github.com/mbostock/d3/wiki/Geo-Projections</a>.</p><p>The next two lines define where our map is centered and how zoomed in it is. By fiddling I got all three values latitude of <code class="literal">8</code>, longitude of <code class="literal">56</code>, and a scaling factor of <code class="literal">800</code>. Play around to get a different look.</p><p>Now we load our data:</p><div class="informalexample"><pre class="programlisting">queue()
  .defer(d3.json, 'data/water.json')
  .defer(d3.json, 'data/land.json')
  .defer(d3.json, 'data/cultural.json')
  .await(draw);</pre></div><p>We're using Mike Bostock's <code class="literal">queue</code> library to run the three loading operations in sequence. Each will use <code class="literal">d3.json</code> to load and parse the data, and when they're all done, <code class="literal">queue</code> will call <code class="literal">draw</code> with the results.</p><p>We need one more thing before we start drawing; a function that adds a feature to the map, which will help us reduce code repetition:</p><div class="informalexample"><pre class="programlisting">function add_to_map(collection, key) {
  return svg.append('g')
    .selectAll('path')
    .data(topojson.object(collection,
                   collection.objects[key]).geometries)
        .enter()
    .append('path')
    .attr('d', d3.geo.path().projection(projection));
}</pre></div><p>This function takes a collection of objects and a key to choose which object to display. <code class="literal">topojson.object()</code> translates a TopoJSON topology into a GeoJSON one for <code class="literal">d3.geo.path()</code>.</p><p>Whether it's more efficient to transform to GeoJSON than transferring data in the target representation depends on your use case. Transforming data takes some computational time, but transferring megabytes instead of kilobytes can make a big difference in responsiveness.</p><p>Finally, we<a id="id231" class="indexterm"/> create a new <code class="literal">d3.geo.path()</code>, and tell it to use our projection. Other than generating the SVG path string, <code class="literal">d3.geo.path()</code> can also calculate different properties of our feature, such as the area (<code class="literal">.area()</code>) and the bounding box (<code class="literal">.bounds()</code>).</p><p>Now we can start drawing:</p><div class="informalexample"><pre class="programlisting">function draw (err, water, land, cultural) {
  add_to_map(water, 'ne_50m_ocean')
    .classed('ocean', true);
};</pre></div><p>Our <code class="literal">draw</code> function<a id="id232" class="indexterm"/> takes the error returned from loading data, and the three datasets then lets <code class="literal">add_to_map</code> do the heavy lifting.</p><p>Add some styling to the HTML:</p><div class="informalexample"><pre class="programlisting">.ocean {
  fill: #759dd1;
}</pre></div><p>Refreshing the page will reveal some oceans.</p><div class="mediaobject"><img src="images/0007OS_03_08.jpg" alt="Drawing geographically"/></div><p>We add <a id="id233" class="indexterm"/>four more <code class="literal">add_to_map</code> calls to the <code class="literal">draw</code> function to fill in the other features:</p><div class="informalexample"><pre class="programlisting">  add_to_map(land, 'ne_50m_land')
    .classed('land', true);

  add_to_map(water, 'ne_50m_rivers_lake_centerlines')
    .classed('river', true);

  add_to_map(cultural, 'ne_50m_admin_0_boundary_lines_land')
    .classed('boundary', true);

  add_to_map(cultural, 'ne_10m_urban_areas')
    .classed('urban', true);</pre></div><p>Add some style definitions as follows:</p><div class="informalexample"><pre class="programlisting">.river {
  fill: none;
  stroke: #759dd1;
  stroke-width: 1;
}

.land {
  fill: #ede9c9;
  stroke: #79bcd3;
  stroke-width: 2;
}

.boundary {
  stroke: #7b5228;
  stroke-width: 1;
  fill: none;
}

.urban {
  fill: #e1c0a3;
}</pre></div><p>We now have a slowly rendering world map zoomed into Europe, displaying the world's urban areas as blots:</p><div class="mediaobject"><img src="images/0007OS_03_09.jpg" alt="Drawing geographically"/></div><p>There are <a id="id234" class="indexterm"/>many reasons why it's so slow. We transform between TopoJSON and GeoJSON on every call to <code class="literal">add_to_map</code>. Even when using the same dataset, we're using data that's too detailed for such a zoomed out map, and we render the whole world to look at a tiny part. We traded flexibility for rendering speed.</p><div class="section" title="Using geography as a base"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Using geography as a base</h3></div></div></div><p>Geography isn't just about <a id="id235" class="indexterm"/>drawing maps. A map<a id="id236" class="indexterm"/> is usually a base we build to show some data.</p><p>Let's turn this into a map of the world's airports. I wanted to make a map of the routes between airports at first, but it looked too crowded.</p><p>The first step is fetching the <code class="literal">airports.dat</code> and <code class="literal">routes.dat</code> datasets from <a class="ulink" href="http://openflights.org/data.html">http://openflights.org/data.html</a>. You can also find it in the examples on GitHub at <a class="ulink" href="https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat">https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat</a>.</p><p>Add a call to <code class="literal">add_airlines()</code> at the bottom of <code class="literal">draw</code>. We'll use it to load more data and draw the airports:</p><div class="informalexample"><pre class="programlisting">function add_airlines() {
  queue()
    .defer(d3.text, 'data/airports.dat')
    .defer(d3.text, 'data/routes.dat')
    .await(draw_airlines);
};</pre></div><p>The function <a id="id237" class="indexterm"/>loads the two datasets, and then calls <code class="literal">draw_airlines</code> to draw them. We use <code class="literal">d3.text</code> instead of <code class="literal">d3.csv</code> because the files don't have a header line so we have to parse them manually.</p><p>In <code class="literal">draw_airlines</code>, we first wrangle the data into JavaScript objects, airports into a dictionary by <code class="literal">id</code>, and routes into a mapping of source to the target airport:</p><div class="informalexample"><pre class="programlisting">function draw_airlines(err, _airports, _routes) {
  var airports = {},
    routes = {};

  d3.csv.parseRows(_airports).forEach(function (airport) {
    var id = airport[0];

    airports[id] = {
      lat: airport[6],
      lon: airport[7]
    };
  });

  d3.csv.parseRows(_routes).forEach(function (route) {
    var from_airport = route[3];

    if (!routes[from_airport]) {
      routes[from_airport] = [];
    }

    routes[from_airport].push({
      to: route[5],
      from: from_airport,
      stops: route[7]
    });
  });
}</pre></div><p>We used <code class="literal">d3.csv.parseRows</code> to parse CSV files into arrays and manually turned them into dictionaries. The array indices aren't very legible unfortunately, but they make sense when you look at the raw data:</p><div class="informalexample"><pre class="programlisting">1,"Goroka","Goroka","Papua New Guinea","GKA","AYGA",-6.081689,145.391881,5282,10,"U"
2,"Madang","Madang","Papua New Guinea","MAG","AYMD",-5.207083,145.7887,20,10,"U"</pre></div><p>The radius of each airport circle will show how many routes are leaving from it. So, we need a scale:</p><div class="informalexample"><pre class="programlisting">var route_N = d3.values(routes).map(function (routes) {
  return routes.length;
  }),
    r = d3.scale.linear().domain(d3.extent(route_N)).range([2, 15]);</pre></div><p>We took an <a id="id238" class="indexterm"/>array of route counts and turned it into a linear scale.</p><p>Now we can draw the airports:</p><div class="informalexample"><pre class="programlisting">svg.append('g')
    .selectAll('circle')
    .data(d3.keys(airports))
    .enter()
    .append('circle')
    .attr("transform", function (id) {
      var airport = airports[id];
      return "translate("+projection([airport.lon, airport.lat])+")";
    })
    .attr('r', function (id) { return routes[id] ? r(routes[id].length) : 1; })
    .classed('airport', true);</pre></div><p>The tricky part is that we used the same <code class="literal">projection</code> we gave to <code class="literal">d3.geo.path()</code> to turn airport positions into circle coordinates. We avoided the <code class="literal">cx</code> and <code class="literal">cy</code> attributes so that we can take advantage of <code class="literal">projection</code> working on two coordinates at once. By now, everything else should be familiar from <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <span class="emphasis"><em>A Primer on DOM, SVG, and CSS</em></span>.</p><p>Airports without routes will be very small dots.</p><p>Later we add some more CSS to our HTML:</p><div class="informalexample"><pre class="programlisting">.airport {
  fill: #9e56c7;
  opacity: 0.6;
  stroke: #69349d;
}</pre></div><p>The following <a id="id239" class="indexterm"/>screenshot displays the result:</p><div class="mediaobject"><img src="images/0007OS_03_10.jpg" alt="Using geography as a base"/></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Summary</h1></div></div></div><p>You've made it through the chapter on data!</p><p>We really got to the core of what d3.js is about, that is, data wrangling. The part about functional programming hopefully inspired you to take up functional-style programming, if you were still on the fence. Learning about data wrangling we saw some interesting properties of prime numbers, learned all about loading external data, and effectively used scales to avoid calculation.</p><p>Finally, we made a cool map to learn how simple geographic data can be once you get a hand on a good source and transform it into a better format.</p></div></div>
</body></html>