- en: Chapter 6. Auction Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on building an auction-like application that will rely
    on the previously built e-commerce application's API. It is going to be a small
    proof-of-concept application. The backend solution of our application is going
    to consume the backend API of our e-commerce application. I want the last chapter
    to be a playground for us, so we can go through some interesting technologies
    used in this book, and also have some fun with a smaller but interesting app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the base app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start with our classic boilerplate for an Express application.
    Follow these steps to set up the base project:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the project from GitHub at [https://github.com/robert52/express-api-starter](https://github.com/robert52/express-api-starter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename your boilerplate project `auction-app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want, you can stop pointing to the initial Git remote repository by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to your working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install all dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a development configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your configuration file, `auction-app/config/environments/development.js`,
    should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What we are building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build an English auction site. The previous e-commerce application
    is going to serve us with products, and an admin can create auctions using those
    products. Auctions have different features; we are not going to discuss each of
    them, but instead we are going to describe an English auction.
  prefs: []
  type: TYPE_NORMAL
- en: The most common auction is the English auction; it's a single dimensional auction,
    and the only thing considered is the bid price offered for the goods. Usually
    it's seller oriented, meaning it's one-sided.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, a starting price is set for the auction; it's called the **reserve
    price**, under which the seller won't sell the goods. Each buyer makes a bid and
    everyone knows every bid, so it's open-cry. The winner pays the winning price.
  prefs: []
  type: TYPE_NORMAL
- en: No lower bid is called than the current winning bid. Usually, the auction ends
    when no one is interested in paying the latest price. Also, an end time could
    be set for the auction.
  prefs: []
  type: TYPE_NORMAL
- en: The end time could be an absolute time, in our case a standard datetime, or
    a time relative to the last bid, such as 120 seconds. Later in the chapter, we
    are going to discuss the benefits of relative time.
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, an auction is a special event in which users—or more precisely,
    bidders—can bid on an item available for sale. An item is a product from the e-commerce
    platform, but one that retains only the necessary information to be displayed
    to the user. Let's discuss each model in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Auction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An auction is going to hold all the necessary information about the event. As
    discussed earlier, we are going to implement an English auction, in which we are
    going to sell goods from our main e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: An English auction is open-cry, which means that everyone is aware of each bid.
    The winner will pay the winning price. Each bid is going to increase the price
    of the goods, and the next bidder has to pay more in order to win the auction.
  prefs: []
  type: TYPE_NORMAL
- en: All auctions will have a reserved price, a starting value below which we are
    not going to sell our product. In other words, it is the lowest acceptable price
    by the seller.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify things, we are going to set an end time for our auction. The last
    bid closer to the end time will be the winning bid. You could go with a relative
    time, which means that you can set a time limit from the last bid (that is, 10
    minutes) and just call the winner if no bids were made in that time frame. This
    could be very useful to prevent bid sniping.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you bid the starting price of 39 USD on a product. Normally,
    you have the highest bid. Now imagine that the auction is ending, but before the
    end with just few seconds another bidder attempts a bid at 47 USD. This will leave
    you with no time to react, so the last bidder wins the auction. This is how usually
    bid snipping works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the Mongoose auction schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Besides the information discussed earlier, we embedded all the bids in our auction
    document. This would not be a good idea if there are going to be many bids in
    an auction, but since we are going to have a fixed-time auction, there are only
    going to be a few of them. For popular auctions, you could just move the bids
    to a separate collection and have a reference to the auction document.
  prefs: []
  type: TYPE_NORMAL
- en: Bidder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are using the backend API from our e-commerce application, so we don''t
    need to store users in our database. But we can store additional data about our
    bidding users. For this we can create a new model, called `app/models/bidder.js`,
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`profileId` stores the `_id` of the user in order to have a reference to the
    user document from the e-commerce platform. You could also store additional data
    in this model and store the auctions in which the bidder is present.'
  prefs: []
  type: TYPE_NORMAL
- en: Auction backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we added a service layer to our architecture. We are
    going to follow the same pattern. Also, we are going to add an extra component
    called `Mediator`, which will serve as a single point of entry to assist us in
    communicating with different modules.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow the mediator design pattern in the construction of our modules,
    which is a behavioral design pattern. This is going to be a single central point
    of control, through which communication flows.
  prefs: []
  type: TYPE_NORMAL
- en: The Mediator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `Mediator` is going to be an object that will coordinate interaction with
    different modules through channels. A module can subscribe to a given event and
    get notified when that event occurs. All this event-related discussion pretty
    much makes us think about using the events core module from Node.js, which is
    used to emit named events that cause execution of the functions to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good starting point. One thing we need to solve is that our `Mediator`
    needs to be a single point of entry, and only one instance can exist at the execution
    time of our application. We could just use a singleton design pattern. With all
    this in mind, let''s implement our mediator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This should give us a solid start for our module; for now this should be enough.
    Because we are using the ES6 features, we can just extend the `EventEmitter` class.
    Instead of exporting the whole `Mediator` class, we are exporting a function that
    checks whether there is already an instance, and if not, we just create a new
    instance of our `Mediator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of how we are going to use this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We just require the `mediator` instance, and using the `.on()` method, we subscribe
    to events and execute a function. Using the `.emit()` method, we publish the named
    event and pass a message as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when using `arrow` functions in ES6 that the `this` keyword in the
    listener function no longer points to `EventEmitter`.
  prefs: []
  type: TYPE_NORMAL
- en: Auction manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of implementing all the business logic in the application's controller
    layer, we are going to build another service, called `AuctionManager`. This service
    will have all the necessary methods for correct execution of an auction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this technique, we can easily decide later how we are going to export
    our application''s business logic: using traditional endpoints or through WebSockets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow a few steps to implement our auction manager:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `/app/services/auction-manager.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Getting all auctions method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Joining an auction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we started using our mediator to emit events. At this point,
    we are emitting an event when a bidder joins the auction. This does not add much
    value for us right now, but it will come handy when we start playing around with
    our real-time communication solution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Placing a bid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When placing a bid, we just want to add it to the list of bids on our auction,
    and for that, we are going to use atomic operators to update the `currentPrice`
    and add the current bid. Also, after successfully placing a bid, we are going
    to emit an event for that.
  prefs: []
  type: TYPE_NORMAL
- en: Auctioneer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to give a fancy name for our upcoming module, and we are going
    to call it `Auctioneer`. Why this name? Well, we are building an auction application,
    so we can add a touch of old-school feeling and add an auctioneer, which will
    call out new bids and who joins the auction.
  prefs: []
  type: TYPE_NORMAL
- en: As you must have already guessed, this will be our real-time communication module.
    This module will use `SocketIO`, and we are going to do something similar as in
    [Chapter 4](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b "Chapter 4. Chat
    Application"), *Chat Application*, where we used the module for real-time communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll go only through the most important parts from our module to see different
    concepts in action. Let''s create a file called `app/services/auctioneer.js` and
    add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So basically, we just structured our class and called a few methods in the
    constructor. We are already familiar with a few lines of code from the constructor;
    for example, the `.initMiddlewares()` method looks similar to [Chapter 4](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b
    "Chapter 4. Chat Application"), *Chat Application*, where we use middlewares to
    authorize and authenticate users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We made a clear split between our `SocketIO` handlers that are initialized when
    we call the `.bindHandlers()` method, and attached the listeners to our mediator
    by calling the `.bindListeners()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our `.bindHandlers()` method will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember that this is only partial code, and the final version will have more
    handlers. So, when a new client connects, we attach a few handlers to our socket.
    For example, in the preceding code, we listen to the `place:bid` event, which
    will be called when a user places a new bid, and the `AuctionManager` service
    will persist that bid.
  prefs: []
  type: TYPE_NORMAL
- en: Now, obviously we would need to notify other clients about the occurred changes;
    we are not going to handle that here. Our `.placeBid()` method emits an event
    through the `Mediator` each time a new bid is successfully recorded. The only
    thing we need to do is listen for that event, which we already did when we called
    `.bindListeners()` in the Auctioneer's constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a partial code sample from the `.bindListeners()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are listening when a bidder joins an auction, and
    we broadcast a message to each client, expecting only the triggering socket client.
    When a new bid is placed, we emit an event to each socket client. So basically,
    we have two similar broadcast functionalities but with a major difference; one
    sends a message to each client expecting the one that triggered the event, and
    the second emits to all connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: Using the service from controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, our services can be consumed from any module and exposed
    in different ways to clients. Earlier, we used `AuctionManager` and exposed its
    business logic through WebSockets. Now, we are going to do the same using simple
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a controller file called `app/controllers/auction.js` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have already done this many times throughout the book, so there's nothing
    new here. The controller exports a function that will attach all the auctions
    returned from the service, and later on the response will be transformed into
    a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing data from the e-commerce API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating auctions, we need additional information about the item we add
    to the auction. All the info about the product item is stored on the e-commerce
    platform built in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't cover the creation of auctions in this chapter, but we can discuss
    the underlining communication layer with the e-commerce API. In the data modeling
    phase, we didn't discuss storing users in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for not including user management is that we are going to consume
    a third-party API to manage our users. For example, authentication and registration
    will be handled through the e-commerce platform.
  prefs: []
  type: TYPE_NORMAL
- en: E-commerce client service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To communicate with the third-party API, we are going to create a service to
    proxy the requests. As we don't consume many endpoints from the API, we can create
    a single service to handle everything. As your application grows, you could easily
    group your files by domain context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `app/services/ecommerce-client.js`, and follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the constants used in the service and include the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a custom `RequestOptions` class used to configure the request object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To reduce the necessary code structure used to make calls with `request`, we
    defined a custom class to instantiate a default request option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `EcommerceClient` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `EcommerceClient` class is going to be our main entry point to the third-party
    API. It's more of a facade to not know the underlining data source used in our
    application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Specify how to authenticate users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The API server will handle the authentication for us; we are just using the
    token returned when making calls to the API. Our custom `RequestOptions` class
    permits us to add extra header data, such as the `Authorization` field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Append the `getProducts()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, with the same principle, we can retrieve data from our e-commerce
    application. The only thing is that we need to add a token to our calls. We are
    not going to discuss how we consume our service, as we have done this many times
    throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: It should be fairly simple to use it in a controller and configure a router
    to expose the necessary endpoints to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are touching only the most significant part of our application, we are
    going to discuss the implementation of our services used in the Angular application.
    I think it's important to understand the underlying communication layer with the
    backend application.
  prefs: []
  type: TYPE_NORMAL
- en: Auction service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AuctionService` will handle all communications with the backend API to get
    info about a specific auction, or simply get all the available auctions. To do
    that, we are going to create a new file, `public/src/services/auction.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported our dependencies, and we''ve added an `URL` constant for better
    code readability, but you may handle your base URL configuration as you desire.
    A few things are missing before we can add the necessary methods, so let''s define
    the constructor and class props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are exporting an Observable for a single auction and a list of auctions.
    Also, we are interested in the current auction. Besides all the familiar definitions,
    we added a third service to be used internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'When getting a single auction or all auctions, we''ll update the next value
    of the observers, so that subscribers get notified by the occurrence of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a single auction, we can use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this service is going to communicate with our Node.js application and store
    all the received data in an internal store. Besides getting data from the server,
    we also want to eventually store the current auction, so this piece of code should
    handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The socket service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The socket service is going to handle the communication with the SocketIO server.
    The benefit is that we have a single point of entry and we can abstract the underlying
    logic to the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `public/src/common/socket.service.ts`, and add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We just import the SocketIO client and all the rest of the data types. Also,
    don''t forget to add the rest of the necessary code for your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting thing we are doing here is to expose Observables—and the rest
    of the application can just subscribe to the stream of data—using the following
    technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The nice part about RxJs is that we can create Observables from events. As the
    socket emits events, we can just create an Observable from that. With the preceding
    code, we can subscribe to incoming data from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to send information to the backend through SocketIO, we can expose
    an `.emit()` method that would be just a wrapper around the `.emit()` method on
    the socket client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The bid service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the big picture, we can take a look at the `BidService` found under
    the following path: `public/src/bid/bid.service.ts`. The class will have a similar
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`BidService` will interact with `SocketService` in order to place bids, which
    will be pushed to all connected clients through the Express backend application.
    We also filter each incoming bid by the currently selected auction.'
  prefs: []
  type: TYPE_NORMAL
- en: When the currently selected auction changes, we want to update our local copy
    by subscribing to `currentAuction` from `AuctionService`.
  prefs: []
  type: TYPE_NORMAL
- en: The bidder service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BidderService` is going to be the first one to use `SocketService` and subscribe
    to changes on the `bidder` object. It will store all the incoming data from the
    backend Node.js server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `public/src/services/bidder.service.ts`, and
    add the following base content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a starting point, we can define our constructor and declare
    all the necessary properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this proof of concept, we are not going to do any HTTP calls from this service,
    and mostly we are going to store information inside the data store. The following
    `public` methods will come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding logic was used in a similar form in earlier chapters. To keep
    it short, we just store the bidders or a single bidder in our data structures
    and update the next value of the observer, so that every subscriber gets notified
    to get the latest values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we used a `Bidder` custom data type—or a model if it sounds more familiar
    to you. Let''s take a quick look at it, found under the following path—`public/src/datatypes/bidder.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The Auction module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken the initial steps and implemented our services. Now we can start
    to use them in our components. There are many moving things in our `Auction` application.
    The most demanding part of the app will be the auction detail page.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code will list the details about a specific auction and also list
    the current bids. When a new bid is placed, it will be pushed to the `bids` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in our services, we used the `Auction` model. Let''s take a look at
    it first. It can be found under `public/src/auction/auction.model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It has a long list of properties. We are doing some initializations when we
    instantiate the model. We use a custom `Money` model, which reflects our custom
    monetary type from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, in the `Job Board` application, we used nice URLs to access
    a company. I wanted to have the same aspect but add a little bit of a twist to
    experiment with a different structure. We have the same concept but a different
    identifier for an auction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the product''s slug in combination with the auction''s `_id` for
    our `identifier` property. Now let''s take a look at the `Money` model, `public/src/common/money.model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can remember, we are using these techniques to have initial values for
    our objects and to make sure we have the necessary properties. To fresh up our
    memories, the `amount` is obtained by multiplying the `display` value with the
    `factor`. This is all done on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The base component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to add a base component that configures our routes. Our base component
    is usually pretty basic, without much logic; it has only routing-related logic.
    Create a new file called `public/src/auction/components/auction-base.component.ts`,
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The auction list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display a list of currently available auctions, we are going to create a
    new component, called `public/src/auction/components/auction-list.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: From this component, we'll link to the auction detail. As you can see, we used
    the `identifier` as a router param. The value of the property was constructed
    inside the `Auction` model.
  prefs: []
  type: TYPE_NORMAL
- en: The detail page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The detail page will have the most moving parts in this application. We are
    going to display the auction''s details and list all new bids. Also, the user
    can bid from this page. To implement this component, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `public/src/auction/components/auction-detail.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `Component` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `ngOnInit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `ngOnDestroy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the component is destroyed, we want to set `currentAuction` to be empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the private `getAuctionId` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using `RouterParams` to get the identifier. Because we have the nice
    URI we need to strip only the necessary information from the identifier. For that,
    we used a private method that splits the URL component into chunks and gets only
    the last portion.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the URL is the auction's `id`. After we have the necessary
    `id`, we can retrieve the information from our API.
  prefs: []
  type: TYPE_NORMAL
- en: This component uses two other components, `BidListComponent` and `BidFormComponent`.
    The first is used to display a list of bids, listen to the bids' data stream,
    and update the bids list.
  prefs: []
  type: TYPE_NORMAL
- en: The second, `BidFormComponent`, is used to make bids. It's easier to encapsulate
    all the functionalities into separate components. This way, each component can
    focus on its domain requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The bid module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to close our chapter with the `bid` module, as we used many of
    its components in the previous `auction` module. Only the `bid listing` will be
    discussed, as it implies working with the underlining socket stream.
  prefs: []
  type: TYPE_NORMAL
- en: Listing bids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the previous `AuctionDetailComponent`, we can see that this component will
    have the bids as input. This data comes from the `auction` entity, which holds
    previously placed bids.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `public/src/bid/components/bid-list.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We subscribe to the `bid` data stream from `BidService` to push all the new
    incoming bids and display them using `BidComponent`. The subscription is also
    stored so that we can unsubscribe from the stream when the component is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The bid component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our bid component is going to be fairly simple. It will have a `bid` input,
    and after the view is initialized successfully, we are going to scroll to the
    bottom of the bid listing view. Let''s create the following component under `public/src/bid/components/bid.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Also let''s take a look at our `bid` model, `public/bid/bid.model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a full round trip from the backend to our frontend components. Data
    is streamed from the WebSocket server to our Angular 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: This application had the purpose of going through all the techniques used in
    the book, and we had a chance to put together a proof of concept. The main focus
    of the chapter was to see the underlining modules, how they will be combined,
    and how data will be modeled and transmitted between each module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is our final chapter, and we created a small proof-of-concept application.
    The purpose was to go through some of the most interesting parts and methods used
    in the book and see how we can combine exciting ideas to create something small
    but powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we used our existing e-commerce API to retrieve information about product
    items and manage our users. There was no reason to go through this process again
    as we can rely on third-party APIs for faster prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: Through most of the chapters, we only touched the most important parts. All
    the necessary code can be found on the Packt Publishing website ([https://www.packtpub.com/](https://www.packtpub.com/))
    for each chapter.
  prefs: []
  type: TYPE_NORMAL
