<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Particles, Sprites, and the Point Cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Particles, Sprites, and the Point Cloud</h1></div></div></div><p>In the previous chapters, we discussed the most important concepts, objects, and APIs that Three.js has to offer. In this chapter, we'll look into the only concept we've skipped until now: particles. With particles (sometimes also called sprites), it is very easy to create many small objects that you can use to simulate rain, snow, smoke, and other interesting effects. For instance, you can render individual geometries as a set of particles and control these particles separately. In this chapter, we'll explore the various particle features provided by Three.js. To be more specific, we'll look at the following subjects in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and styling particles using <code class="literal">THREE.SpriteMaterial</code></li><li class="listitem" style="list-style-type: disc">Using a point cloud to create a grouped set of particles</li><li class="listitem" style="list-style-type: disc">Creating a point cloud from existing geometries</li><li class="listitem" style="list-style-type: disc">Animating particles and the particle system</li><li class="listitem" style="list-style-type: disc">Using a texture to style the particles</li><li class="listitem" style="list-style-type: disc">Using the canvas to style a particle with <code class="literal">THREE.SpriteCanvasMaterial</code></li></ul></div><p>Let's start by exploring what a particle is and how you can create one. Before we get started, though, a quick note on some of the names used in this chapter. In recent versions of Three.js, the names of the objects related to particles have changed. <code class="literal">THREE.PointCloud</code>, which we use in this chapter, used to be called <code class="literal">THREE.ParticleSystem</code>, <code class="literal">THREE.Sprite</code> used to be called <code class="literal">THREE.Particle</code>, and also the materials have undergone some name changes. So, if you see online examples using these old names, remember that they are talking about the same concepts. In this chapter, we use the new naming convention introduced in the latest versions of Three.js.</p><div class="section" title="Understanding particles"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Understanding particles</h1></div></div></div><p>Like <a id="id674" class="indexterm"/>we do with most new concepts, we'll start with an example. In the sources for this chapter, you'll find an example with the name <code class="literal">01-particles.html</code>. Open this example and you'll see a grid of very uninteresting-looking white cubes, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_07_01.jpg" alt="Understanding particles"/></div><p>What you see in this screenshot are 100 sprites. A sprite is a 2D plane that always faces the camera. If you create a sprite without any properties, they are rendered as small, white, two-dimensional squares. These sprites were created with the following lines of code:</p><div class="informalexample"><pre class="programlisting">function createSprites() {
  var material = new THREE.SpriteMaterial();
  for (var x = -5; x &lt; 5; x++) {
    for (var y = -5; y &lt; 5; y++) {
      var sprite = new THREE.Sprite(material);
      sprite.position.set(x * 10, y * 10, 0);
      scene.add(sprite);
    }
  }
}</pre></div><p>In this example, we create the sprites manually using the <code class="literal">THREE.Sprite(material)</code> constructor. The only item we pass in is a material. This has to be either <code class="literal">THREE.SpriteMaterial</code> or <code class="literal">THREE.SpriteCanvasMaterial</code>. We'll look at both of these materials in more depth in the rest of this chapter.</p><p>Before we<a id="id675" class="indexterm"/> move on to more interesting particles, let's look a bit closer at the <code class="literal">THREE.Sprite</code> object. A <code class="literal">THREE.Sprite</code> object extends from the <code class="literal">THREE.Object3D</code> object just as <code class="literal">THREE.Mesh</code> does. This means that most of the properties and functions you know from <code class="literal">THREE.Mesh</code> can be used on <code class="literal">THREE.Sprite</code>. You can set its position using the <code class="literal">position</code> attribute, scale it using the <code class="literal">scale</code> property, and move it relatively using the <code class="literal">translate</code> properties.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>Note that in older versions of Three.js, you were unable to use <code class="literal">THREE.Sprite</code> objects with <code class="literal">THREE.WebGLRenderer</code> and could use it only with <code class="literal">THREE.CanvasRenderer</code>. In the current version, <code class="literal">THREE.Sprite</code> objects can be used with both renderers.</p></div></div><p>With <code class="literal">THREE.Sprite</code>, you can very easily create a set of objects and move them around the scene. This works great when you're working with a small number of objects, but you'll quickly run into performance issues when you want to work with a high number of <code class="literal">THREE.Sprite</code> objects because each of the objects needs to be managed separately by Three.js. Three.js provides an alternative way of handling a large number of sprites (or particles) using <code class="literal">THREE.PointCloud</code>. With <code class="literal">THREE.PointCloud</code>, Three.js doesn't have to manage many individual <code class="literal">THREE.Sprite</code> objects, but only the <code class="literal">THREE.PointCloud</code> instance.</p><p>To get the same result as the screenshot we saw earlier, but this time using <code class="literal">THREE.PointCloud</code>, we do the following:</p><div class="informalexample"><pre class="programlisting">function createParticles() {

  var geom = new THREE.Geometry();
  var material = new THREE.PointCloudMaterial({size: 4, vertexColors: true, color: 0xffffff});

  for (var x = -5; x &lt; 5; x++) {
    for (var y = -5; y &lt; 5; y++) {
      var particle = new THREE.Vector3(x * 10, y * 10, 0);
      geom.vertices.push(particle);
      geom.colors.push(new THREE.Color(Math.random() * 0x00ffff));
    }
  }

  var cloud = new THREE.PointCloud(geom, material);
  scene.add(cloud);
}</pre></div><p>As you <a id="id676" class="indexterm"/>can see, for each particle (each point in the cloud), we need to create a vertex (represented by <code class="literal">THREE.Vector3</code>), add it to <code class="literal">THREE.Geometry</code>, use <code class="literal">THREE.Geometry</code> together with <code class="literal">THREE.PointCloudMaterial</code> to create <code class="literal">THREE.PointCloud</code>, and add cloud to the scene. An example of <code class="literal">THREE.PointCloud</code> in action (with colored squares) can be found in the <code class="literal">02-particles-webgl.html</code> example. The following screenshot shows this example:</p><div class="mediaobject"><img src="graphics/2215OS_07_02.jpg" alt="Understanding particles"/></div><p>In the following sections, we'll explore <code class="literal">THREE.PointCloud</code> further.</p></div></div>
<div class="section" title="Particles, THREE.PointCloud, and THREE.PointCloudMaterial"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Particles, THREE.PointCloud, and THREE.PointCloudMaterial</h1></div></div></div><p>At the end of the previous section, we quickly introduced <code class="literal">THREE.PointCloud</code>. The constructor of<a id="id677" class="indexterm"/> <code class="literal">THREE.PointCloud</code> takes two properties: a geometry and a material. The material is used to color and texture the particles (as we'll see later on), and the geometry defines where the individual particles are positioned. Each vertex and each point used to define the geometry is shown as a particle. When we create <code class="literal">THREE.PointCloud</code> based on <code class="literal">THREE.BoxGeometry</code>, we get 8 particles, one for each corner of the cube. Normally, though, you won't create <code class="literal">THREE.PointCloud</code> from one of the standard Three.js geometries, but add the vertices manually to a geometry created from scratch (or use an externally loaded model) just like we did at the end of the previous section. In this section, we'll dive a bit deeper into this approach and look at how you can use <code class="literal">THREE.PointCloudMaterial</code> to style the particles. We'll explore this using the <code class="literal">03-basic-point-cloud.html</code> example. The following screenshot shows this example:</p><div class="mediaobject"><img src="graphics/2215OS_07_03.jpg" alt="Particles, THREE.PointCloud, and THREE.PointCloudMaterial"/></div><p>In this<a id="id678" class="indexterm"/> example, we create <code class="literal">THREE.PointCloud</code>, which we fill with 15,000 particles. All the particles are styled with <code class="literal">THREE.PointCloudMaterial</code>. To create <code class="literal">THREE.PointCloud</code>, we used the following code:</p><div class="informalexample"><pre class="programlisting">function createParticles(size, transparent, opacity, vertexColors, sizeAttenuation, color) {


  var geom = new THREE.Geometry();
  var material = new THREE.PointCloudMaterial({size: size, transparent: transparent, opacity: opacity, vertexColors: vertexColors, sizeAttenuation: sizeAttenuation, color: color});

  var range = 500;
  for (var i = 0; i &lt; 15000; i++) {
    var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
    geom.vertices.push(particle);
    var color = new THREE.Color(0x00ff00);
    color.setHSL(color.getHSL().h, color.getHSL().s, Math.random() * color.getHSL().l);
    geom.colors.push(color);
  }

  cloud = new THREE.PointCloud(geom, material);
  scene.add(cloud);
}</pre></div><p>In this<a id="id679" class="indexterm"/> listing, we first create <code class="literal">THREE.Geometry</code>. We'll add the particles, represented as <code class="literal">THREE.Vector3</code>, to this geometry. For this, we've created a simple loop that creates <code class="literal">THREE.Vector3</code> at a random position and adds it. In this same loop, we also specify the array of colors, <code class="literal">geom.colors</code>, that are used when we set the <code class="literal">vertexColors</code> property of <code class="literal">THREE.PointCloudMaterial</code> to <code class="literal">true</code>. The last thing to do is create<a id="id680" class="indexterm"/> <code class="literal">THREE.PointCloudMaterial</code> and add it to the scene.</p><p>The following table explains all the properties you can set on <code class="literal">THREE.PointCloudMaterial</code>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the <a id="id681" class="indexterm"/>color of all the particles in <code class="literal">ParticleSystem</code>. Setting the <code class="literal">vertexColors</code> property to true and specifying the colors using the colors property of the geometry overrides this property (to be more precise, the color of a vertex will be multiplied with this value to determine the final color). The default value is <code class="literal">0xFFFFFF</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>map</p>
</td><td style="text-align: left" valign="top">
<p>With<a id="id682" class="indexterm"/> this property, you can apply a texture to the particles. You can, for instance, make them look like snowflakes. This property isn't shown in this example but is explained later on in this chapter.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>size</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id683" class="indexterm"/>the size of the particle. The default value is <code class="literal">1</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>sizeAnnutation</p>
</td><td style="text-align: left" valign="top">
<p>If<a id="id684" class="indexterm"/> this is set to false, all the particles will have the same size regardless of how far from the camera they are positioned. If this is set to true, the size is based on the distance from the camera. The default value is <code class="literal">true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>vertexColors</p>
</td><td style="text-align: left" valign="top">
<p>Normally, all <a id="id685" class="indexterm"/>the particles in <code class="literal">THREE.PointCloud</code> have the same color. If this property is set to <code class="literal">THREE.VertexColors</code> and the colors array in the geometry has been filled, the colors from that array will be used instead (also see the color entry in this table). The default value is <code class="literal">THREE.NoColors</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>opacity</p>
</td><td style="text-align: left" valign="top">
<p>This, together <a id="id686" class="indexterm"/>with the transparent property, sets the opacity of the particle. The default value is <code class="literal">1</code> (no opacity).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>transparent</p>
</td><td style="text-align: left" valign="top">
<p>If this<a id="id687" class="indexterm"/> is set to true, the particle will be rendered with the opacity set by the opacity property. The default value is <code class="literal">false</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>blending</p>
</td><td style="text-align: left" valign="top">
<p>This is the<a id="id688" class="indexterm"/> blend mode to use when rendering the particle. See <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <span class="emphasis"><em>Animations and Moving the Camera</em></span>, for more information on blend modes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>fog</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id689" class="indexterm"/> determines whether the particles are affected by fog added to the scene. This defaults to <code class="literal">true</code>.</p>
</td></tr></tbody></table></div><p>The previous example provides a simple control menu that you can use to experiment with the properties specific to <code class="literal">THREE.ParticleCloudMaterial</code>.</p><p>So far, we've only rendered the particles as small cubes, which is the default behavior. There are, however, a few additional ways you can use to style the particles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can apply <code class="literal">THREE.SpriteCanvasMaterial</code> (which only works for <code class="literal">THREE.CanvasRenderer</code>) to use the results from an HTML canvas element as a texture</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">THREE.SpriteMaterial</code> and a HTML5-based texture to use the output of an HTML canvas when working with <code class="literal">THREE.WebGLRenderer</code></li><li class="listitem" style="list-style-type: disc">Load an external image file (or use the HTML5 canvas) with the <code class="literal">map</code> property of <code class="literal">THREE.PointCloudMaterial</code> to style all particles of <code class="literal">THREE.ParticleCloud</code></li></ul></div><p>In the next section, we look into how you can do this.</p></div>
<div class="section" title="Styling particles with the HTML5 canvas"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Styling particles with the HTML5 canvas</h1></div></div></div><p>Three.js offers<a id="id690" class="indexterm"/> three different ways you can use an HTML5 canvas<a id="id691" class="indexterm"/> to style your particles. If you use <code class="literal">THREE.CanvasRenderer</code>, you can directly reference an HTML5 canvas from <code class="literal">THREE.SpriteCanvasMaterial</code>. When you use <code class="literal">THREE.WebGLRenderer</code>, you need to take a couple of extra steps to use an HTML5 canvas to style your particles. In the following two sections, we'll show you the different approaches.</p><div class="section" title="Using HTML5 canvas with THREE.CanvasRenderer"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Using HTML5 canvas with THREE.CanvasRenderer</h2></div></div></div><p>With <a id="id692" class="indexterm"/>
<code class="literal">THREE.SpriteCanvasMaterial</code>, you <a id="id693" class="indexterm"/>can use the output from an HTML5 canvas as a texture for your particles. This material is specifically created for <code class="literal">THREE.CanvasRenderer</code> and <a id="id694" class="indexterm"/>only works when you use this specific renderer. Before we look at how to use this material, let's first look at the attributes you can set on this material:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id695" class="indexterm"/> is the color of the particle. Depending on the specified <code class="literal">blending</code> mode, this affects the color of the canvas image.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">program</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id696" class="indexterm"/> a function that takes a canvas context as a parameter. This function is called when the particle is rendered. The output from the calls to this 2D drawing context is shown as the particle.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">opacity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id697" class="indexterm"/>determines the opacity of the particle. The default value is <code class="literal">1</code>, and there is no opacity.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">transparent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id698" class="indexterm"/>determines whether the particle is transparent or not. This works together with the <code class="literal">opacity</code> property.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blending</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id699" class="indexterm"/>is the blend mode to be used. See <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <span class="emphasis"><em>Animations and Moving the Camera</em></span> for more details.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">rotation</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id700" class="indexterm"/> property allows you to rotate the contents of the canvas. You'll usually need to set this to PI to correctly align the contents of the canvas. Note that this property can't be passed in to the constructor of the material, but needs to be set explicitly. </p>
</td></tr></tbody></table></div><p>To see <code class="literal">THREE.SpriteCanvasMaterial</code> in action, you can open the <code class="literal">04-program-based-sprites.html</code> example. The following screenshot shows this example:</p><div class="mediaobject"><img src="graphics/2215OS_07_04.jpg" alt="Using HTML5 canvas with THREE.CanvasRenderer"/></div><p>In this example, the <a id="id701" class="indexterm"/>particles are created in the <code class="literal">createSprites</code> function:</p><div class="informalexample"><pre class="programlisting">function createSprites() {

  var material = new THREE.SpriteCanvasMaterial({
    program: draw,
    color: 0xffffff});
   material.rotation = Math.PI;

  var range = 500;
  for (var i = 0; i &lt; 1000; i++) {
    var sprite = new THREE.Sprite(material);
    sprite.position = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
    sprite.scale.set(0.1, 0.1, 0.1);
    scene.add(sprite);
  }
}</pre></div><p>This code looks a lot like the code we saw in the previous section. The main change is that because<a id="id702" class="indexterm"/> we're working with <code class="literal">THREE.CanvasRenderer</code>, we create <code class="literal">THREE.Sprite</code> objects directly, instead of using <code class="literal">THREE.PointCloud</code>. In this code, we also define <code class="literal">THREE.SpriteCanvasMaterial</code> with a <code class="literal">program</code> attribute that points to the <code class="literal">draw</code> function. This <code class="literal">draw</code> function defines what a particle will look like (in our case, a ghost from <span class="emphasis"><em>Pac-Man</em></span>):</p><div class="informalexample"><pre class="programlisting">var draw = function(ctx) {
  ctx.fillStyle = "orange";
  ...
  // lots of other ctx drawing calls
  ...
  ctx.beginPath();
  ctx.fill();
}</pre></div><p>We won't dive into the actual canvas code required to draw our shape. What's important here is that we define a function that accepts a 2D canvas context (<code class="literal">ctx</code>) as its parameter. Everything that is drawn onto that context is used as the shape for <code class="literal">THREE.Sprite</code>.</p></div><div class="section" title="Using HTML5 canvas with WebGLRenderer"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Using HTML5 canvas with WebGLRenderer</h2></div></div></div><p>If we <a id="id703" class="indexterm"/>want to use an HTML5 canvas with <code class="literal">THREE.WebGLRenderer</code>, we<a id="id704" class="indexterm"/> can take two different approaches. We can use <code class="literal">THREE.PointCloudMaterial</code> and create <code class="literal">THREE.PointCloud</code>, or we can use <code class="literal">THREE.Sprite</code> and the <code class="literal">map</code> property of <code class="literal">THREE.SpriteMaterial</code>.</p><p>Let's start with the first approach and create <code class="literal">THREE.PointCloud</code>. In the attributes for <code class="literal">THREE.PointCloudMaterial</code>, we mentioned the <code class="literal">map</code> property. With the <code class="literal">map</code> property, we can load a texture for the particle. With Three.js, this texture can also be the output from an HTML5 canvas. An example showing this concept is <code class="literal">05a-program-based-point-cloud-webgl.html</code>. The following screenshot shows this example:</p><div class="mediaobject"><img src="graphics/2215OS_07_05.jpg" alt="Using HTML5 canvas with WebGLRenderer"/></div><p>Let's look at <a id="id705" class="indexterm"/>the code we wrote to get this effect. Most<a id="id706" class="indexterm"/> of the code is the same as our previous WebGL example, so we won't go into too much detail. The important code changes that were made to get this example are shown here:</p><div class="informalexample"><pre class="programlisting">var getTexture = function() {
  var canvas = document.createElement('canvas');
  canvas.width = 32;
  canvas.height = 32;

  var ctx = canvas.getContext('2d');
  ...
  // draw the ghost
  ...
  ctx.fill();
  var texture = new THREE.Texture(canvas);
  texture.needsUpdate = true;
  return texture;
}

function createPointCloud(size, transparent, opacity, sizeAttenuation, color) {

  var geom = new THREE.Geometry();


  var material = new THREE.PointCloudMaterial ({size: size, transparent: transparent, opacity: opacity, map: getTexture(), sizeAttenuation: sizeAttenuation, color: color});


  var range = 500;
  for (var i = 0; i &lt; 5000; i++) {
    var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
    geom.vertices.push(particle);
  }

  cloud = new THREE.PointCloud(geom, material);
  cloud.sortParticles = true;
  scene.add(cloud);
}</pre></div><p>In <code class="literal">getTexture</code>, the<a id="id707" class="indexterm"/> first of these two<a id="id708" class="indexterm"/> JavaScript functions, we create <code class="literal">THREE.Texture</code> based on an HTML5 canvas element. In the second function, <code class="literal">createPointCloud</code>, we assign this texture to the <code class="literal">map</code> property of <code class="literal">THREE.PointCloudMaterial</code>. In this function, you can also see that we set the <code class="literal">sortParticles</code> property of <code class="literal">THREE.PointCloud</code> to <code class="literal">true</code>. This property makes sure that before the particles are rendered, they are sorted according to their <span class="emphasis"><em>z</em></span> position on screen. If you see partly overlapping particles or incorrect transparency, setting this property to <code class="literal">true</code> will (in most cases) fix that. You should note, though, that setting this property to <code class="literal">true</code> will affect the performance of your scene. When this is set to true, Three.js will have to determine the distance to the camera for each individual particle. For a <code class="literal">THREE.PointCloud</code> object that is very large, this can have a big impact on performance.</p><p>While we're talking about the properties of <code class="literal">THREE.PointCloud</code>, there is one additional property you can set on <code class="literal">THREE.PointCloud: FrustumCulled</code>. If this property is set to true, it means that if particles fall outside the visible camera range, they aren't rendered. This can be used to improve performance and frame rate if needed.</p><p>The result of this is that everything we draw to the canvas in the <code class="literal">getTexture()</code> method is used for the particles in <code class="literal">THREE.PointCloud</code>. In the following section, we'll look a bit deeper into how this works with textures we load from external files. Note that in this example, we only see a very small part of what is possible with textures. In <a class="link" href="ch10.html" title="Chapter 10. Loading and Working with Textures">Chapter 10</a>, <span class="emphasis"><em>Loading and Working with Textures</em></span>, we'll dive into the details of what can be done with textures.</p><p>At the beginning of this section, we mentioned that we could also use <code class="literal">THREE.Sprite</code> together with the<a id="id709" class="indexterm"/> <code class="literal">map</code> property to create a canvas-based particle. For this, we use the same approach to create <code class="literal">THREE.Texture</code> as we saw in the previous example. This time, however, we assign it to <code class="literal">THREE.Sprite</code> like this:</p><div class="informalexample"><pre class="programlisting">function createSprites() {
  var material = new THREE.SpriteMaterial({
    map: getTexture(),
    color: 0xffffff
  });

  var range = 500;
  for (var i = 0; i &lt; 1500; i++) {
    var sprite = new THREE.Sprite(material);
    sprite.position.set(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
    sprite.scale.set(4,4,4);
    scene.add(sprite);
  }
}</pre></div><p>Here, you can <a id="id710" class="indexterm"/>see that we use a standard <code class="literal">THREE.SpriteMaterial</code> object and assign the output of the canvas as <code class="literal">THREE.Texture</code> to the <code class="literal">map</code> property of the material. You can view an example of this by opening <code class="literal">05b-program-based-sprites-webgl.html</code> in your browser. Both of these approaches have their own advantages and disadvantages. With <code class="literal">THREE.Sprite</code>, you have more control over the individual particle, but it becomes less performant and more complex when you're working with a large number of particles. With <code class="literal">THREE.PointCloud</code>, you can easily manage a large number of particles, but have less control over each individual particle.</p></div></div>
<div class="section" title="Using textures to style particles"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Using textures to style particles</h1></div></div></div><p>In the previous <a id="id711" class="indexterm"/>example, we saw how you could style <code class="literal">THREE.PointCloud</code> and individual <code class="literal">THREE.Sprite</code> objects using an HTML5 canvas. Since you can draw<a id="id712" class="indexterm"/> anything you want and even load external images, you can use this approach to add all kinds of styles to the particle system. There is, however, a more direct way to use an image to style your particles. You can use the <code class="literal">THREE.ImageUtils.loadTexture()</code> function to load an image as <code class="literal">THREE.Texture</code>. <code class="literal">THREE.Texture</code> can then be assigned to the <code class="literal">map</code> property of a material.</p><p>In this section, we'll show you two examples and explain how to create them. Both these examples use an image as a texture for your particles. In the first example, we create a simulation <a id="id713" class="indexterm"/>of rain, <code class="literal">06-rainy-scene.html</code>. The following screenshot shows this example:</p><div class="mediaobject"><img src="graphics/2215OS_07_06.jpg" alt="Using textures to style particles"/></div><p>The first<a id="id714" class="indexterm"/> thing we need to do is get a texture that will represent our raindrop. You can find a couple of examples in the <code class="literal">assets/textures/particles</code> folder. In <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <span class="emphasis"><em>Animations and Moving the Camera</em></span>, we will explain all the details and requirements for textures. For now, all you need to know is that the texture should be square and preferably a power of 2 (for example, 64 x 64, 128 x 128, 256 x 256). For this example, we'll use this texture:</p><div class="mediaobject"><img src="graphics/2215OS_07_07.jpg" alt="Using textures to style particles"/></div><p>This image <a id="id715" class="indexterm"/>uses a black background (needed for correct blending) and shows the shape and color of a raindrop. Before we can use this texture in <code class="literal">THREE.PointCloudMaterial</code>, we first need to load it. This can be done with the following line of code:</p><div class="informalexample"><pre class="programlisting">var texture = THREE.ImageUtils.loadTexture("../assets/textures/particles/raindrop-2.png");</pre></div><p>With this<a id="id716" class="indexterm"/> line of code, Three.js will load the texture, and we can use it in our material. For this example, we defined the material like this:</p><div class="informalexample"><pre class="programlisting">var material = new THREE.PointCloudMaterial({size: 3, transparent: true, opacity: true, map: texture, blending: THREE.AdditiveBlending, sizeAttenuation: true, color: 0xffffff});</pre></div><p>In this chapter, we've discussed all of these properties. The main thing to understand here is that the <code class="literal">map</code> property points to the texture we loaded with the <code class="literal">THREE.ImageUtils.loadTexture()</code> function, and we specify <code class="literal">THREE.AdditiveBlending</code> as the <code class="literal">blending</code> mode. This <code class="literal">blending</code> mode means that when a new pixel is drawn, the color of the background pixel is added to the color of this new pixel. For our raindrop texture, this means that the black background won't be shown. A logical alternative would be to replace the black from our texture with a transparent background, but that doesn't work with particles and WebGL unfortunately.</p><p>That takes care of styling <code class="literal">THREE.PointCloud</code>. What you'll also see when you open up this example is that the particles themselves are moving. In the previous examples, we moved the entire particle system; this time, we position the individual particles within <code class="literal">THREE.PointCloud</code>. Doing this is actually very simple. Each particle is represented as a vertex that makes up the geometry that was used to create <code class="literal">THREE.PointCloud</code>. Let's look at how we add the particles for <code class="literal">THREE.PointCloud</code>:</p><div class="informalexample"><pre class="programlisting">var range = 40;
for (var i = 0; i &lt; 1500; i++) {
  var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range * 1.5, Math.random() * range - range / 2);

  particle.velocityX = (Math.random() - 0.5) / 3;
  particle.velocityY = 0.1 + (Math.random() / 5);
  geom.vertices.push(particle);
}</pre></div><p>This isn't that <a id="id717" class="indexterm"/>different from the previous examples we saw. Here, we added two additional properties to each particle (<code class="literal">THREE.Vector3</code>): <code class="literal">velocityX</code> and <code class="literal">velocityY</code>. The first one defines how a particle (a raindrop) moves horizontally, and the second one defines how fast the raindrop falls down. The horizontal velocity ranges from -0.16 to +0.16, and the vertical speed ranges from 0.1 to 0.3. Now that each raindrop has its own speed, we can move the individual particles inside the render loop:</p><div class="informalexample"><pre class="programlisting">var vertices = system2.geometry.vertices;
vertices.forEach(function (v) {
  v.x = v.x - (v.velocityX);
  v.y = v.y - (v.velocityY);

  if (v.x &lt;= -20 || v.x &gt;= 20) v.velocityX = v.velocityX * -1;
  if (v.y &lt;= 0) v.y = 60;
});</pre></div><p>In this piece <a id="id718" class="indexterm"/>of code, we get all <code class="literal">vertices</code> (particles) from the geometry that was used to create <code class="literal">THREE.PointCloud</code>. For each of the particles, we take <code class="literal">velocityX</code> and <code class="literal">velocityY</code> and use them to change the current position of the particle. The last two lines make sure the particles stay within the range we've defined. If the <code class="literal">v.y</code> position drops below zero, we add the raindrop back to the top, and if the <code class="literal">v.x</code> position reaches any of the edges, we make it bounce back by inverting the horizontal velocity.</p><p>Let's look at another example. This time, we won't make rain, but we'll make snow. Additionally, we won't be using just a single texture, but we'll use five separate images (taken from the Three.js examples). Let's start by looking at the result again (see <code class="literal">07-snowy-scene.html</code>):</p><div class="mediaobject"><img src="graphics/2215OS_07_08.jpg" alt="Using textures to style particles"/></div><p>In the preceding screenshot, you<a id="id719" class="indexterm"/> can see that instead of using just a single image as texture, we've used multiple images. You<a id="id720" class="indexterm"/> might wonder how we did this. As you probably remember, we can only have a single material for <code class="literal">THREE.PointCloud</code>. If we want to have multiple materials, we just have to make multiple particle systems, as follows:</p><div class="informalexample"><pre class="programlisting">function createPointClouds(size, transparent, opacity, sizeAttenuation, color) {

  var texture1 = THREE.ImageUtils.loadTexture("../assets/textures/particles/snowflake1.png");
  var texture2 = THREE.ImageUtils.loadTexture("../assets/textures/particles/snowflake2.png");
  var texture3 = THREE.ImageUtils.loadTexture("../assets/textures/particles/snowflake3.png");
  var texture4 = THREE.ImageUtils.loadTexture("../assets/textures/particles/snowflake5.png");

  scene.add(createPointCloud("system1", texture1, size, transparent, opacity, sizeAttenuation, color));
  scene.add(createPointCloud ("system2", texture2, size, transparent, opacity, sizeAttenuation, color));
  scene.add(createPointCloud ("system3", texture3, size, transparent, opacity, sizeAttenuation, color));
  scene.add(createPointCloud ("system4", texture4, size, transparent, opacity, sizeAttenuation, color));
}</pre></div><p>Here, you can see<a id="id721" class="indexterm"/> that we load the textures separately and <a id="id722" class="indexterm"/>pass all the information on how to create <code class="literal">THREE.PointCloud</code> to the <code class="literal">createPointCloud</code> function. This function looks like this:</p><div class="informalexample"><pre class="programlisting">function createPointCloud(name, texture, size, transparent, opacity, sizeAttenuation, color) {
  var geom = new THREE.Geometry();

  var color = new THREE.Color(color);
  color.setHSL(color.getHSL().h, color.getHSL().s, (Math.random()) * color.getHSL().l);

  var material = new THREE.PointCloudMaterial({size: size, transparent: transparent, opacity: opacity, map: texture, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: sizeAttenuation, color: color});

  var range = 40;
  for (var i = 0; i &lt; 50; i++) {
    var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range * 1.5, Math.random() * range - range / 2);
    particle.velocityY = 0.1 + Math.random() / 5;
    particle.velocityX = (Math.random() - 0.5) / 3;
    particle.velocityZ = (Math.random() - 0.5) / 3;
    geom.vertices.push(particle);
  }

  var cloud = new THREE.ParticleCloud(geom, material);
  cloud.name = name;
  cloud.sortParticles = true;
  return cloud;
}</pre></div><p>The first thing we do in this function is define the color in which the particles for this specific texture should be rendered. This is done by randomly changing the <span class="emphasis"><em>lightness</em></span> of the passed-in color. Next, the material is created in the same manner we did before. The only change here is that the <code class="literal">depthWrite</code> property is set to <code class="literal">false</code>. This property defines whether this <a id="id723" class="indexterm"/>object affects the WebGL depth buffer. By setting this to <code class="literal">false</code>, we make sure that the various point clouds don't interfere with each other. If <a id="id724" class="indexterm"/>this property isn't set to <code class="literal">false</code>, you'll see that the black background from the texture is sometimes shown when a particle is in front of a particle from another <code class="literal">THREE.PointCloud</code> object. The last step taken in this piece of code is randomly placing the particles and adding a random speed to each particle. In the render loop, we can now update the position of all the particles from each <code class="literal">THREE.PointCloud</code> object like this:</p><div class="informalexample"><pre class="programlisting">scene.children.forEach(function (child) {
  if (child instanceof THREE.ParticleSystem) {
    var vertices = child.geometry.vertices;
    vertices.forEach(function (v) {
      v.y = v.y - (v.velocityY);
      v.x = v.x - (v.velocityX);
      v.z = v.z - (v.velocityZ);

      if (v.y &lt;= 0) v.y = 60;
      if (v.x &lt;= -20 || v.x &gt;= 20) v.velocityX = v.velocityX * -1;
      if (v.z &lt;= -20 || v.z &gt;= 20) v.velocityZ = v.velocityZ * -1;
    });
  }
});</pre></div><p>With this approach, we can have particles that have different textures. This approach, however, is a bit limited. The more different textures we want, the more point clouds we'll have to create and manage. If you have a limited set of particles with different styles, you'd better use the <code class="literal">THREE.Sprite</code> object we showed at the beginning of this chapter.</p></div>
<div class="section" title="Working with sprite maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Working with sprite maps</h1></div></div></div><p>At the beginning <a id="id725" class="indexterm"/>of this chapter, we used a <code class="literal">THREE.Sprite</code> object to render single particles with <code class="literal">THREE.CanvasRenderer</code> and <code class="literal">THREE.WebGLRenderer</code>. These sprites were positioned somewhere in the 3D world, and their size was based on the distance from the camera (this is also sometimes <a id="id726" class="indexterm"/>called <span class="strong"><strong>billboarding</strong></span>). In this section, we'll show an alternative use of the <code class="literal">THREE.Sprite</code> object. We'll show you how you can use <code class="literal">THREE.Sprite</code> to create a layer similar to <span class="strong"><strong>head-up display</strong></span> (<span class="strong"><strong>HUD</strong></span>) for<a id="id727" class="indexterm"/> your 3D content using an extra <code class="literal">THREE.OrthographicCamera</code> instance. We will also show you how to select the image for a <code class="literal">THREE.Sprite</code> object using a sprite map.</p><p>As an example, we're going to create a simple <code class="literal">THREE.Sprite</code> object that moves from left to right over <a id="id728" class="indexterm"/>the screen. In the background, we'll render a 3D scene with a moving camera to illustrate that <code class="literal">THREE.Sprite</code> moves independently of the camera. The following screenshot shows what we'll be creating for the first example (<code class="literal">08-sprites.html</code>):</p><div class="mediaobject"><img src="graphics/2215OS_07_09.jpg" alt="Working with sprite maps"/></div><p>If you open this example in your browser, you'll see a Pac-Man ghost-like sprite moving across the screen and changing color and form whenever it hits the right edge. The first thing we'll do is look at how we create <code class="literal">THREE.OrthographicCamera</code> and a separate scene to render <code class="literal">THREE.Sprite</code> in:</p><div class="informalexample"><pre class="programlisting">var sceneOrtho = new THREE.Scene();
var cameraOrtho = new THREE.OrthographicCamera( 0, window.innerWidth, window.innerHeight, 0, -10, 10 );</pre></div><p>Next, let's look at the construction of <code class="literal">THREE.Sprite</code> and how the various shapes the sprite can take are loaded:</p><div class="informalexample"><pre class="programlisting">function getTexture() {
  var texture = new THREE.ImageUtils.loadTexture("../assets/textures/particles/sprite-sheet.png");
  return texture;
}

function createSprite(size, transparent, opacity, color, spriteNumber) {
  var spriteMaterial = new THREE.SpriteMaterial({
    opacity: opacity,
    color: color,
    transparent: transparent,
    map: getTexture()});


  // we have 1 row, with five sprites
  spriteMaterial.map.offset = new THREE.Vector2(1/5 * spriteNumber, 0);
  spriteMaterial.map.repeat = new THREE.Vector2(1/5, 1);
  spriteMaterial.blending = THREE.AdditiveBlending;

  // makes sure the object is always rendered at the front
  spriteMaterial.depthTest = false;
  var sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(size, size, size);
  sprite.position.set(100, 50, 0);
  sprite.velocityX = 5;

  sceneOrtho.add(sprite);
}</pre></div><p>In <a id="id729" class="indexterm"/>the <code class="literal">getTexture()</code> function, we load a texture. However, instead of loading five different images for each <span class="emphasis"><em>ghost</em></span>, we load a single texture that contains all the sprites. The texture looks like this:</p><div class="mediaobject"><img src="graphics/2215OS_07_10.jpg" alt="Working with sprite maps"/></div><p>With the <code class="literal">map.offset</code> and the <code class="literal">map.repeat</code> properties, we select the correct sprite to show on screen. With the <code class="literal">map.offset</code> property, we determine the offset for the <span class="emphasis"><em>x</em></span> axis (u) and the <span class="emphasis"><em>y</em></span> axis (v) for the texture we loaded. The scale for these properties runs from 0 to 1. In our example, if we want to select the third ghost, we set the u-offset (<span class="emphasis"><em>x</em></span> axis) to 0.4, and, because we've only got one row, we don't need to change the v-offset (<span class="emphasis"><em>y</em></span> axis). If we only set this <a id="id730" class="indexterm"/>property, the texture shows the third, fourth, and fifth ghosts compressed together on screen. To only show one ghost, we need to zoom in. We do this by setting the <code class="literal">map.repeat</code> property for the u-value to 1/5. This means that we zoom in (only for the <span class="emphasis"><em>x</em></span> axis) to only show 20 percent of the texture, which is exactly one ghost.</p><p>The final step we need to take is update the <code class="literal">render</code> function:</p><div class="informalexample"><pre class="programlisting">webGLRenderer.render(scene, camera);
webGLRenderer.autoClear = false;
webGLRenderer.render(sceneOrtho, cameraOrtho);</pre></div><p>We first render the scene with the normal camera and the moving sphere, and after that, we render the scene containing our sprite. Note that we need to set the <code class="literal">autoClear</code> property of the WebGLRenderer to <code class="literal">false</code>. If we don't do this, Three.js will clear the scene before it renders the sprite, and the sphere wouldn't show up.</p><p>The following table shows an overview of all the properties of <code class="literal">THREE.SpriteMaterial</code> we used in the previous examples:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id731" class="indexterm"/>the color of the sprite.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">map</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id732" class="indexterm"/> is the texture to be used for this sprite. This can be a sprite sheet, as shown in the example in this section.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sizeAnnutation</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If this is <a id="id733" class="indexterm"/>set to <code class="literal">false</code>, the size of the sprite won't be affected by the distance it's removed from the camera. The default value is <code class="literal">true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">opacity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This sets the<a id="id734" class="indexterm"/> transparency of the sprite. The default value is <code class="literal">1</code> (no opacity).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blending</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id735" class="indexterm"/> defines the blend mode to be used when rendering the sprite. See <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <span class="emphasis"><em>Animations and Moving the Camera</em></span>, for more information on blend modes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fog</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id736" class="indexterm"/>determines whether the sprite is affected by fog added to the scene. This defaults to <code class="literal">true</code>.</p>
</td></tr></tbody></table></div><p>You can also set the <code class="literal">depthTest</code> and <code class="literal">depthWrite</code> properties on this material. For more information on these properties, see <a class="link" href="ch04.html" title="Chapter 4. Working with Three.js Materials">Chapter 4</a>, <span class="emphasis"><em>Working with Three.js Materials</em></span>.</p><p>We can, of course, also use a sprite map when positioning <code class="literal">THREE.Sprites</code> in 3D (as we did at the beginning of this chapter). An example (<code class="literal">09-sprites-3D.html</code>) of this is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_07_11.jpg" alt="Working with sprite maps"/></div><p>With the <a id="id737" class="indexterm"/>properties we saw in the previous table, we can very easily create the effect we see in the preceding screenshot:</p><div class="informalexample"><pre class="programlisting">function createSprites() {

  group = new THREE.Object3D();
  var range = 200;
  for (var i = 0; i &lt; 400; i++) {
    group.add(createSprite(10, false, 0.6, 0xffffff, i % 5, range));
  }
  scene.add(group);
}

function createSprite(size, transparent, opacity, color, spriteNumber, range) {


  var spriteMaterial = new THREE.SpriteMaterial({
    opacity: opacity,
    color: color,
    transparent: transparent,
    map: getTexture()}
  );

  // we have 1 row, with five sprites
  spriteMaterial.map.offset = new THREE.Vector2(0.2*spriteNumber, 0);
  spriteMaterial.map.repeat = new THREE.Vector2(1/5, 1);
  spriteMaterial.depthTest = false;

  spriteMaterial.blending = THREE.AdditiveBlending;

  var sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(size, size, size);
  sprite.position.set(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
  sprite.velocityX = 5;

  return sprite;
}</pre></div><p>In this <a id="id738" class="indexterm"/>example, we create 400 sprites based on the sprite sheet we showed earlier. You'll probably know and understand most of the properties and concepts shown here. As we've added the separate sprites to a group, rotating them is very easy and can be done like this:</p><div class="informalexample"><pre class="programlisting">group.rotation.x+=0.1;</pre></div><p>In this chapter, so far we've mainly looked at creating sprites and point clouds from scratch. An interesting option, though, is to create <code class="literal">THREE.PointCloud</code> from an existing geometry.</p></div>
<div class="section" title="Creating THREE.PointCloud from an advanced geometry"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Creating THREE.PointCloud from an advanced geometry</h1></div></div></div><p>As you<a id="id739" class="indexterm"/> remember, <code class="literal">THREE.PointCloud</code> renders each particle based on the vertices from the supplied geometry. This means that if we provide a complex geometry (for example, a torus knot or a tube), we can create <code class="literal">THREE.PointCloud</code> based on the vertices from that specific geometry. For this last section of this chapter, we'll create a torus knot, like the one we saw in the previous chapter, and render it as <code class="literal">THREE.PointCloud</code>.</p><p>We've already explained the torus knot in the previous chapter, so we won't go into much detail here. We're using the exact code from the previous chapter, and we've added a single menu option that you can use to transform the rendered mesh into <code class="literal">THREE.PointCloud</code>. You can find the example (<code class="literal">10-create-particle-system-from-model.html</code>) in the sources for this chapter. The following screenshot shows the example:</p><div class="mediaobject"><img src="graphics/2215OS_07_12.jpg" alt="Creating THREE.PointCloud from an advanced geometry"/></div><p>As you can see in the preceding screenshot, every vertex used to generate the torus knot is used as a particle. In this example, we've added a nice-looking material, based on a HTML canvas, to create this glowing effect. We'll only look at the code to the create the material and the particle system as <a id="id740" class="indexterm"/>we've already discussed the other properties in this chapter:</p><div class="informalexample"><pre class="programlisting">function generateSprite() {

  var canvas = document.createElement('canvas');
  canvas.width = 16;
  canvas.height = 16;

  var context = canvas.getContext('2d');
  var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);

  gradient.addColorStop(0, 'rgba(255,255,255,1)');
  gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
  gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
  gradient.addColorStop(1, 'rgba(0,0,0,1)');

  context.fillStyle = gradient;
  context.fillRect(0, 0, canvas.width, canvas.height);

  var texture = new THREE.Texture(canvas);
  texture.needsUpdate = true;
  return texture;
}

function createPointCloud(geom) {
  var material = new THREE.PointCloudMaterial({
    color: 0xffffff,
    size: 3,
    transparent: true,
    blending: THREE.AdditiveBlending,
    map: generateSprite()
  });

  var cloud = new THREE.PointCloud(geom, material);
  cloud.sortParticles = true;
  return cloud;
}

// use it like this
var geom = new THREE.TorusKnotGeometry(...);
var knot = createPointCloud(geom);</pre></div><p>In this code<a id="id741" class="indexterm"/> fragment, you can see two functions: <code class="literal">createPointCloud()</code> and <code class="literal">generateSprite()</code>. In the first function, we create a simple <code class="literal">THREE.PointCloud</code> object directly from the geometry provided (in this example, a torus knot) and set the texture (the <code class="literal">map</code> property) to a glowing dot (generated on an HTML5 canvas element) with the <code class="literal">generateSprite()</code> function, which looks like this:</p><div class="mediaobject"><img src="graphics/2215OS_07_13.jpg" alt="Creating THREE.PointCloud from an advanced geometry"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Summary</h1></div></div></div><p>That's a wrap for this chapter. We've explained what particles, sprites, and particle systems are and how you can style these objects with the available materials. In this chapter, you saw how you can use <code class="literal">THREE.Sprite</code> directly with <code class="literal">THREE.CanvasRenderer</code> and <code class="literal">THREE.WebGLRenderer</code>. If you want to create a large number of particles, however, you should use <code class="literal">THREE.PointCloud</code>. With <code class="literal">THREE.PointCloud</code>, all the particles share the same material, and the only property you can change for an individual particle is their color by setting the <code class="literal">vertexColors</code> property of the material to <code class="literal">THREE.VertexColors</code> and providing a color value in the <code class="literal">colors</code> array of <code class="literal">THREE.Geometry</code> used to create <code class="literal">THREE.PointCloud</code>. We also showed how you can easily animate particles by changing their position. This works the same for an individual <code class="literal">THREE.Sprite</code> instance and the vertices from the geometry used to create <code class="literal">THREE.PointCloud</code>.</p><p>So far, we have created meshes based on geometries provided by Three.js. This works great for simple models such as spheres and cubes but isn't the best approach when you want to create complex 3D models. For those models, you'd usually use a 3D modeling application such as Blender or 3D Studio Max. In the next chapter, you'll learn how you can load and display models created by such 3D modeling applications.</p></div></body></html>