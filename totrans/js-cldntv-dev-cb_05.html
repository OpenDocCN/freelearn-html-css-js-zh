<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing Cloud-Native Systems</h1>
                
            
            
                
<p class="mce-root">In this chapter, the following recipes will be covered:</p>
<ul>
<li>Securing your cloud account</li>
<li>Creating a federated identity pool</li>
<li>Implementing sign up, sign in, and sign out</li>
<li>Securing an API Gateway with OpenID Connect</li>
<li>Implementing a custom authorizer</li>
<li>Authorizing a GraphQL-based service</li>
<li>Implementing a JWT filter</li>
<li>Using envelope encryption</li>
<li>Creating an SSL certificate for encryption in transit</li>
<li>Configuring a web application firewall</li>
<li>Replicating the data lake for disaster recovery</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Security in the cloud is based on the shared responsibility model. Below a certain line in the stack is the responsibility of the cloud provider and above that line is the responsibility of the cloud consumer. Cloud-native and serverless computing push that line higher and higher. This allows teams to focus their efforts on what they know best—their business domains. With the security mechanisms provided by the cloud, teams can practice <em>security-by-design</em> and concentrate on <em>defense-in-depth</em> techniques to secure their data. In each recipe, so far, we have seen how serverless computing requires us to define security policies between components at each layer in the stack. The recipes in this chapter will cover securing our cloud accounts, securing our applications with OAuth 2.0/Open ID Connect, securing our data at rest, and creating a perimeter around our cloud-native systems by delegating aspects of security to the edge of the cloud.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing your cloud account</h1>
                
            
            
                
<p>Everything we do to secure our cloud-native systems is all for nothing if we do not endeavor to secure our cloud accounts as well. There is a set of best practices that we must put in place for every cloud account we create. As we strive to create autonomous services, we should leverage the natural bulkhead between cloud accounts by grouping related services into more, fine-grained accounts instead of fewer, coarse-grained accounts. In this recipe, we will see how treating accounts as code enables us to manage many accounts easily by applying the same infrastructure-as-code practices we employ to manage our many autonomous services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/account-as-code --path cncb-account-as-code</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-account-as-code</kbd> directory with <kbd>cd cncb-account-as-code</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-account-as-code<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::${self:custom.accountNumber}:role/${opt:stage}-cfnRole<br/><br/>custom:<br/>  accountNumber: 123456789012<br/><br/>resources:<br/>  Resources:<br/>    <strong>AuditBucket</strong>:<br/>      Type: AWS::S3::Bucket<br/>      DeletionPolicy: Retain<br/>      ...<br/>    <strong>CloudTrail</strong>: <br/>      Type: AWS::CloudTrail::Trail<br/>      ...<br/><br/>    <strong>CloudFormationServiceRole</strong>:<br/>      Type: AWS::IAM::Role<br/>      Properties: <br/>        RoleName: ${opt:stage}-cfnRole<br/>        ...<br/>    <strong>ExecuteCloudFormationPolicy</strong>: <br/>      Type: AWS::IAM::ManagedPolicy<br/>      ...<br/>    <strong>CiCdUser</strong>: <br/>      Type: AWS::IAM::User<br/>      Properties:<br/>        ManagedPolicyArns:<br/>          - Ref: ExecuteCloudFormationPolicy <br/><br/>    AdminUserGroup: <br/>      Type: AWS::IAM::Group<br/>      ...<br/>    ReadOnlyUserGroup: <br/>      Type: AWS::IAM::Group<br/>      ...<br/>    PowerUserGroup: <br/>      Type: AWS::IAM::Group<br/>      ...<br/>    <strong>ManageAccessKey</strong>:<br/>      Condition: IsDev<br/>      Type: AWS::IAM::ManagedPolicy<br/>      ...<br/>    <strong>MfaOrHqRequired</strong>:<br/>      Condition: Exclude<br/>      Type: AWS::IAM::ManagedPolicy<br/>      ...<br/>  ... </pre>
<ol start="4">
<li>Update <kbd>accountNumber</kbd> in <kbd>serverless.yml</kbd>.</li>
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-account-as-code@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-account-as-code<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...</pre>
<ol start="9">
<li>Review the stack and resources in the AWS Console.</li>
<li>Uncomment <kbd>cfnRole</kbd> and then deploy again with the <kbd>force</kbd> flag with <kbd>npm run dp:lcl -- -s $MY_STAGE --force</kbd>.</li>
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Every account I create starts off with the same essential security settings using a <kbd>serverless.yml</kbd>, such as the one in this recipe. I create no other stacks in the account until this account-scoped stack is created. All further changes, other than creating users, are delivered as changes to this stack. The first responsibility of this stack is to turn on <kbd>CloudTrail</kbd>. In <a href="64a4c0f7-3b2d-4638-a52c-f72953ff66d9.xhtml">Chapter 7</a>, <em>Optimizing Observability</em>, we will see how we can use this audit trail to monitor and alert about unexpected changes to security policies. <kbd>AuditBucket</kbd> is also a candidate for replicating to the recovery account as discussed in the <em>Replicating the data lake for disaster recovery</em> recipe.</p>
<p>Next, the stack creates the user groups that will be used for granting permissions to all users of the account. The <kbd>AdminUserGroup</kbd>, <kbd>PowerUserGroup</kbd>, and <kbd>ReadOnlyUserGroup</kbd> groups are a good starting point, along with using the managed policies provided by AWS. As the usage of the account matures, these groups will evolve using the same approach discussed in <a href="390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml">Chapter 6</a>, <em>Building a Continuous Deployment Pipeline</em>. However, only the security policies are codified. The assignment of users to groups is a manual process that should follow an appropriate approval process. The stack includes the <kbd>MfaOrHqRequired</kbd>, policy to require <strong>Multi-Factor Authentication</strong> (<strong>MFA</strong>) and whitelist the corporate IP addresses, but it is disabled initially. It should certainly be enabled for all production accounts. In a development account, most developers are assigned to the power user group, so that they can freely experiment with cloud services. The power user group has no IAM permissions, so an optional <kbd>ManageAccessKey</kbd> policy is included to allow power users to manage their access keys. Note, it is very important to control the usage of access keys and frequently rotate them.</p>
<p>When executing a <kbd>serverless.yml</kbd> file, we need an access key. As an added security measure, CloudFormation supports the use of a service role that allows CloudFormation to assume a specific role with temporary credentials. Using the <kbd>cfnRole</kbd> attribute in a <kbd>serverless.yml</kbd> file enables this feature. This stack creates an initial <kbd>CloudFormationServiceRole</kbd> that should be used by all stacks. As the account matures, this role should be tuned to the least possible privileges. The <kbd>ExecuteCloudFormationPolicy</kbd> included only has enough permissions to execute a <kbd>serverless.yml</kbd> file. This policy will be used by <kbd>CiCdUser</kbd>, which we will use in <a href="390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml">Chapter 6</a>, <em>Building a Continuous Deployment Pipeline</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a federated identity pool</h1>
                
            
            
                
<p>Managing users is a requirement of virtually every system. Over a long career, I can certainly attest to creating identity management functionality over and over again. Fortunately, we can now get this functionality as a service from many providers, including our cloud providers. And because there are so many options available, we need a federated solution that delegates to many other identity management systems while presenting a single, unified model to our cloud-native system. In this recipe, we will show how to create an <em>AWS Cognito user pool</em>, which we will then use in other recipes to secure our services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/cognito-pool --path cncb-cognito-pool</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-cognito-pool</kbd> directory with <kbd>cd cncb-cognito-pool</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-cognito-pool<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/><br/>resources:<br/>  Resources:<br/>    CognitoUserPoolCncb:<br/>      Type: AWS::Cognito::<strong>UserPool</strong><br/>      Properties:<br/>        UserPoolName: cncb-${opt:stage}<br/>        ...<br/>        Schema:<br/>          - AttributeDataType: 'String'<br/>            DeveloperOnlyAttribute: false<br/>            Mutable: true<br/>            Name: '<strong>email</strong>'<br/>            Required: true<br/>        ...<br/>    CognitoUserPoolCncbClient:<br/>      Type: AWS::Cognito::<strong>UserPoolClient</strong><br/>      Properties:<br/>        UserPoolId:<br/>          Ref: CognitoUserPoolCncb<br/><br/>  Outputs:<br/>    ...<br/><br/>plugins:<br/>  - <strong>cognito-plugin</strong><br/><br/>custom:<br/>  pool:<br/>    <strong>domain</strong>: cncb-${opt:stage}<br/>    allowedOAuthFlows: ['<strong>implicit</strong>']<br/>    allowedOAuthFlowsUserPoolClient: true<br/>    allowedOAuthScopes: ...<br/>    <strong>callbackURLs</strong>: ['http://localhost:3000/implicit/callback']<br/>    <strong>logoutURLs</strong>: ['http://localhost:3000']<br/>    refreshTokenValidity: 30<br/>    supportedIdentityProviders: ['COGNITO']</pre>
<ol start="4">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-cognito-pool@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-cognito-pool<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/><br/>Stack Outputs<br/>userPoolArn: arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_tDXH8JAky<br/><strong>userPoolClientId</strong>: 4p5p08njgmq9sph130l3du2b7q<br/><strong>loginURL</strong>: https://<strong>cncb-john.auth.us-east-1.amazoncognito.com</strong>/login?redirect_uri=http://localhost:3000/implicit/callback&amp;response_type=token&amp;client_id=4p5p08njgmq9sph130l3du2b7q<br/>userPoolProviderName: cognito-idp.us-east-1.amazonaws.com/us-east-1_tDXH8JAky<br/><strong>userPoolId</strong>: us-east-1_tDXH8JAky<br/>userPoolProviderURL: https://cognito-idp.us-east-1.amazonaws.com/us-east-1_tDXH8JAky</pre>
<ol start="8">
<li>Review the stack and resources in the AWS Console.</li>
<li>Access <kbd>loginURL</kbd> from the stack output to verify that the user pool was created successfully.</li>
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>
<p>We will be referencing this user pool in other recipes in this chapter, so remove this stack after you are finished with this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This recipe simply codifies the creation of an AWS Cognito user pool. Like any other infrastructure resource, we want to treat it as code and manage it in a continuous delivery pipeline. For this recipe, we define the bare essentials. You will want to define any additional attributes that you want the pool to manage. For this recipe, we just specify the <kbd>email</kbd> attribute.</p>
<p>It is important to understand that these attributes cannot be changed via CloudFormation without creating a new user pool, which has a ripple effect on any resources that are dependent on the user pool. So, expect to focus some effort on experimenting upfront with the right combination of attributes.</p>
<p>For each application that will rely on this user pool, we need to define a <kbd>UserPoolClient</kbd>. Each application would typically define the client in a stack that it manages. However, it is important not to overuse a single user pool. Once again this is a question of autonomy. If the pool of users and the applications used by those users are truly independent, then they should be managed in separate Cognito user pools, even if that requires some duplication of effort. For example, if you find yourself writing complicated logic using Cognito user groups to segregate users unnaturally, then you may be better off with multiple user pools. An example of misuse is mixing employees and customers in the same user pool.</p>
<p>CloudFormation, as of the writing of this chapter, does not have full support for the Cognito API. Therefore a plugin is used for the additional settings on the <kbd>UserPoolClient</kbd>, such as <kbd>domain</kbd>, <kbd>callbackUrls</kbd>, and <kbd>allowedOAuthFlows</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing sign up, sign in, and sign out</h1>
                
            
            
                
<p>Implementing sign up, sign in, and sign out over and over again is not very lean. Implementing this logic in a single-page application is also not desirable. In this recipe, we will see how to implement the <em>OpenID Connect Implicit Flow</em> in a single-page application to authenticate users with the <em>AWS Cognito Hosted UI</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/cognito-signin --path cncb-cognito-signin</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-cognito-signin</kbd> directory with <kbd>cd cncb-cognito-signin</kbd>.</li>
<li>Review the file named <kbd>src/App.js</kbd> with the following content and update the <kbd>clientId</kbd> and <kbd>domain</kbd> fields with the values from the <kbd>userPool</kbd> stack output in the previous recipe:</li>
</ol>
<pre style="padding-left: 30px">import React, { Component } from 'react';<br/>import { BrowserRouter as Router, Route } from 'react-router-dom';<br/>import { <strong>CognitoSecurity</strong>, <strong>ImplicitCallback</strong>, <strong>SecureRoute</strong> } from '<strong>./authenticate</strong>';<br/>import Home from './Home';<br/><br/>class App extends Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;<strong>CognitoSecurity</strong><br/>          <strong>domain</strong>='cncb-&lt;stage&gt;.auth.us-east-1.amazoncognito.com'<br/>          <strong>clientId</strong>='a1b2c3d4e5f6g7h8i9j0k1l2m3'<br/>          ...<br/>          <strong>redirectSignIn</strong>={`${window.location.origin}<strong>/implicit/callback</strong>`}<br/>          <strong>redirectSignOut</strong>={window.location.origin}<br/>        &gt;<br/>          &lt;<strong>SecureRoute</strong> path='/' exact component={Home} /&gt;<br/>          &lt;Route path='<strong>/implicit/callback</strong>' component={ImplicitCallback} /&gt;<br/>        &lt;/CognitoSecurity&gt;<br/>      &lt;/Router&gt;<br/>    );<br/>  }<br/>}<br/><br/>export default App;</pre>
<ol start="4">
<li>Review the file named <kbd>src/Home.js</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">import React from 'react';<br/>import { <strong>withAuth</strong> } from './<strong>authenticate</strong>';<br/>...<br/><br/>const Home = ({ <strong>auth</strong> }) =&gt; (<br/>  &lt;div ...&gt;<br/>    ...<br/>    &lt;button onClick={<strong>auth.logout</strong>}&gt;Logout&lt;/button&gt;<br/>    &lt;pre ...&gt;{JSON.stringify(<strong>auth.getSession()</strong>, null, 2)}&lt;/pre&gt;<br/>  &lt;/div&gt;<br/>);<br/><br/>export default <strong>withAuth</strong>(Home);</pre>
<ol start="5">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the app locally with <kbd>npm start</kbd>.</li>
<li>Browse to <kbd>http://localhost:3000</kbd>.</li>
<li>Click the <kbd>Sign Up</kbd> link and follow the instructions.</li>
<li>Click the <kbd>Sign Out</kbd> link and then <kbd>Sign In</kbd> again.</li>
<li>Review the <kbd>idToken</kbd> displayed on the page.</li>
</ol>
<p>We will use these screens to create a valid <kbd>idToken</kbd> in the authorization recipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Adding sign up, sign in, and sign out to a single-page app is very straightforward. We include some additional libraries, initialize them with the proper configurations, and decorate the existing code. In this recipe, we make these changes to our simple example React application. AWS provides the <kbd>amazon-cognito-auth-js</kbd> library to simplify this task and we wrap it in some React components in <kbd>src/authenticate</kbd> folder. First, we initialize the <kbd>CognitoSecurity</kbd> component in the <kbd>src/App.js</kbd>. Next, we set up <kbd>SecureRoute</kbd> for the <kbd>Home</kbd> component that will redirect to the <em>Cognito hosted UI</em> if the user is not authenticated. The <kbd>ImpicitCallback</kbd> component will handle the redirect after the user logs in. Finally, we add the <kbd>withAuth</kbd> decorator to the <kbd>Home</kbd> component. In more elaborate applications, we would just be decorating more routes and components. The framework handles everything else, such as saving the <strong>JSON Web Token</strong> (<strong>JWT</strong>) to local storage and making it available for use in the <kbd>auth</kbd> property. For example, the <kbd>Home</kbd> component displays the tokens (<kbd>auth.getSession()</kbd>) and provides a logout button (<kbd>auth.logout</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing an API Gateway with OpenID Connect</h1>
                
            
            
                
<p>One of the advantages of using an API Gateway is that we are pushing security concerns, such as authorization, to the perimeter of our system and away from our internal resources. This simplifies the internal code and improves scalability. In this recipe, we will configure an <em>AWS API Gateway</em> to authorize against an <em>AWS Cognito user pool</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the Cognito user pool created in the <em>Creating a federated identity pool</em> recipe and the sample application created in the <em>Implementing sign up, sign in, and sign out</em> recipe to create the identity token used in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/cognito-authorizer --path cncb-cognito-authorizer</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-cognito-authorizer</kbd> directory with <kbd>cd cncb-cognito-authorizer</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-cognito-authorizer<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/>  ...<br/><br/>functions:<br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http:<br/>          ...<br/>          <strong>authorizer</strong>:<br/>            arn: ${cf:cncb-cognito-pool-${opt:stage}.<strong>userPoolArn</strong>}</pre>
<ol start="4">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test -- -s $MY_STAGE</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-cognito-authorizer@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-cognito-authorizer<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>endpoints:<br/>  GET - https://ff70szvc44.execute-api.us-east-1.amazonaws.com/john/hello<br/>functions:<br/>  hello: cncb-cognito-authorizer-john-hello</pre>
<ol start="8">
<li>Review the stack and resources in the AWS Console.</li>
<li>Invoke the following <kbd>curl</kbd> command, after updating <kbd>&lt;API-ID&gt;</kbd>, to attempt to access the service without an <kbd>Authorization</kbd> token:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl https://&lt;API-ID&gt;.execute-api.us-east-1.amazonaws.com/$MY_STAGE/hello | json_pp</strong><br/><br/>{<br/>   "message" : "Unauthorized"<br/>}</pre>
<ol start="10">
<li>Use the app in the previous recipe to sign in and generate <kbd>idToken</kbd>, and then export <kbd>idToken</kbd> with the following command:</li>
</ol>
<pre style="padding-left: 30px">$ export CNCB_TOKEN=&lt;idToken value&gt;</pre>
<ol start="11">
<li>Invoke the following <kbd>curl</kbd> command, after updating <kbd>&lt;API-ID&gt;</kbd>, to access the service successfully with an <kbd>Authorization</kbd> token:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v -H "Authorization: Bearer $CNCB_TOKEN"  https://&lt;API-ID&gt;.execute-api.us-east-1.amazonaws.com/$MY_STAGE/hello | json_pp</strong><br/><br/>{<br/>   "message" : "JavaScript Cloud Native Development Cookbook! Your function executed successfully!",<br/>   "input" : {<br/>      "headers" : {<br/>         "Authorization" : "...",<br/>         ...<br/>      },<br/>      ...<br/>      "<strong>requestContext</strong>" : {<br/>         ...<br/>         "<strong>authorizer</strong>" : {<br/>            "<strong>claims</strong>" : {<br/>               "email_verified" : "true",<br/>               "auth_time" : "1528264383",<br/>               "cognito:<strong>username</strong>" : "john",<br/>               "event_id" : "e091cd96-694d-11e8-897c-e3fe55ba3d67",<br/>               "iss" : "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_tDXH8JAky",<br/>               "exp" : "Wed Jun 06 06:53:03 UTC 2018",<br/>               "sub" : "e4bdd021-a160-4aff-bce2-e652f9469e3e",<br/>               "aud" : "4p5p08njgmq9sph130l3du2b7q",<br/>               "<strong>email</strong>" : "john@example.com",<br/>               "iat" : "Wed Jun 06 05:53:03 UTC 2018",<br/>               "token_use" : "id"<br/>            }<br/>         }<br/>      },<br/>      ...<br/>   }<br/>}</pre>
<ol start="12">
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The combination of the AWS API Gateway, AWS Cognito, and the Serverless Framework make securing a service with OpenID Connect extremely straightforward. The AWS API Gateway can use authorizer functions to control access to a service. These functions verify the JWT passed in the <kbd>Authorization</kbd> header and return an IAM policy. We will delve into these details in the <em>Implementing a custom authorizer</em> recipe. AWS Cognito provides an authorizer function that verifies the JWTs generated by a specific user pool. In the <kbd>serverless.yml</kbd> file, we simply need to set <kbd>authorizer</kbd> to the <kbd>userPoolArn</kbd> of the specific Cognito user pool. Once authorized, the API Gateway passes the decode <kbd>claims</kbd> from the JWT along to the lambda function in the <kbd>requestContext</kbd>, so this data can be used in the business logic, if needs be.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a custom authorizer</h1>
                
            
            
                
<p>In the <em>Securing an API Gateway with OpenID Connect</em> recipe, we leveraged the Cognito authorizer that is provided by AWS. This is one of the advantages of using Cognito. However, this is not the only option. Sometimes we may want more control over the policy that is returned. In other cases, we may need to use a third-party tool such as <em>Auth0</em> or <em>Okta</em>. In this recipe, we will show how to support these scenarios by implementing a custom authorizer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the Cognito user pool created in the <em>Creating a federated identity pool</em> recipe and the sample application created in the <em>Implementing sign up, sign in, and sign out</em> recipe to create the identity token used in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/custom-authorizer --path cncb-custom-authorizer</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-custom-authorizer</kbd> directory with <kbd>cd cncb-custom-authorizer</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-custom-authorizer<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/>  ...<br/><br/>functions:<br/>  authorizer:<br/>    handler: handler.<strong>authorize</strong><br/>    environment:<br/>      <strong>AUD</strong>: ${cf:cncb-cognito-pool-${opt:stage}.userPoolClientId}<br/>      <strong>ISS</strong>: ${cf:cncb-cognito-pool-${opt:stage}.userPoolProviderURL}<br/>      <strong>JWKS</strong>: ${self:functions.authorizer.environment.ISS}/.well-known/jwks.json<br/>      DEBUG: '*'<br/><br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http:<br/>          ...<br/>          authorizer: <strong>authorizer</strong></pre>
<ol start="4">
<li>Review the file named <kbd>handler.js</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">...<br/>module.exports.<strong>authorize</strong> = (event, context, cb) =&gt; {<br/>  <strong>decode</strong>(event)<br/>    .then(<strong>fetchKey</strong>)<br/>    .then(<strong>verify</strong>)<br/>    .then(<strong>generatePolicy</strong>)<br/>    ...<br/>};<br/><br/>const <strong>decode</strong> = ({ authorizationToken, methodArn }) =&gt; {<br/>  ...<br/>  return Promise.resolve({<br/>    ...<br/>    <strong>token</strong>: match[1],<br/>    <strong>decoded</strong>: jwt.<strong>decode</strong>(match[1], { complete: true }),<br/>  });<br/>};<br/><br/>const <strong>fetchKey</strong> = (uow) =&gt; {<br/>  ...<br/>  return client.<strong>getSigningKeyAsync</strong>(kid)<br/>    .then(key =&gt; ({<br/>      key: key.<strong>publicKey</strong> || key.rsaPublicKey,<br/>      ...uow,<br/>    }));<br/>};<br/><br/>const <strong>verify</strong> = (uow) =&gt; {<br/>  ...<br/>  return <strong>verifyAsync</strong>(<strong>token</strong>, <strong>key</strong>, {<br/>    audience: process.env.<strong>AUD</strong>,<br/>    issuer: process.env.<strong>ISS</strong><br/>  })<br/>    ...<br/>};<br/><br/>const <strong>generatePolicy</strong> = (uow) =&gt; {<br/>  ...<br/>  return {<br/>    policy: {<br/>      principalId: claims.<strong>sub</strong>,<br/>      policyDocument: {<br/>        Statement: [{ Action: 'execute-api:Invoke', Effect, Resource }],<br/>      },<br/>      context: <strong>claims</strong>,<br/>    },<br/>    ...uow,<br/>  };<br/>};<br/>...</pre>
<ol start="5">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test -- -s $MY_STAGE</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-custom-authorizer@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-custom-authorizer<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>endpoints:<br/>  GET - https://8iznazkhr0.execute-api.us-east-1.amazonaws.com/john/hello<br/>functions:<br/>  authorizer: cncb-custom-authorizer-john-authorizer<br/>  hello: cncb-custom-authorizer-john-hello<br/><br/>Stack Outputs<br/>...<br/><strong>ServiceEndpoint</strong>: https://8iznazkhr0.execute-api.us-east-1.amazonaws.com/john</pre>
<ol start="9">
<li>Review the stack and resources in the AWS Console.</li>
<li>Invoke the following <kbd>curl</kbd> command, after updating <kbd>&lt;API-ID&gt;</kbd>, to attempt to access the service without an <kbd>Authorization</kbd> token:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl https://&lt;API-ID&gt;.execute-api.us-east-1.amazonaws.com/$MY_STAGE/hello | json_pp</strong><br/><br/>{<br/>   "message" : "Unauthorized"<br/>}</pre>
<ol start="11">
<li>Use the app in the <em>Implementing sign up, sign in, and sign out</em> recipe to sign in and generate <kbd>idToken</kbd>, and then export <kbd>idToken</kbd> with the following command:</li>
</ol>
<pre style="padding-left: 30px">$ export CNCB_TOKEN=&lt;idToken value&gt;</pre>
<ol start="12">
<li>Invoke the following <kbd>curl</kbd> command, after updating <kbd>&lt;API-ID&gt;</kbd>, to access the service successfully with an <kbd>Authorization</kbd> token:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v -H "Authorization: Bearer $CNCB_TOKEN"  https://&lt;API-ID&gt;.execute-api.us-east-1.amazonaws.com/$MY_STAGE/hello | json_pp</strong><br/><br/>{<br/>   "message" : "JavaScript Cloud Native Development Cookbook! Your function executed successfully!",<br/>   "input" : {<br/>      "headers" : {<br/>         "Authorization" : "...",<br/>         ...<br/>      },<br/>      ...<br/>      "requestContext" : {<br/>         ...<br/>         "authorizer" : {<br/>            "exp" : "1528342765",<br/>            "cognito:username" : "john",<br/>            "<strong>iss</strong>" : "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_tDXH8JAky",<br/>            "<strong>sub</strong>" : "e4bdd021-a160-4aff-bce2-e652f9469e3e",<br/>            "iat" : "1528339165",<br/>            "email_verified" : "true",<br/>            "auth_time" : "1528339165",<br/>            "email" : "john@example.com",<br/>            "<strong>aud</strong>" : "4p5p08njgmq9sph130l3du2b7q",<br/>            "event_id" : "fdcdf125-69fb-11e8-a6ef-ab31871bed60",<br/>            "token_use" : "id",<br/>            "principalId" : "e4bdd021-a160-4aff-bce2-e652f9469e3e"<br/>         }<br/>      },<br/>      ...<br/>   }<br/>}</pre>
<ol start="13">
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The process for connecting a custom authorizer to the API Gateway is the same as with the Cognito authorizer. We can implement the <kbd>authorizer</kbd> function in the same project, as we have in this recipe, or it can be implemented in another stack so that it can be shared across services. The <kbd>jwks-rsa</kbd> and <kbd>jsonwebtoken</kbd> open source libraries implement the bulk of the logic. First, we assert the presence of the token and <kbd>decode</kbd> it. Next, we use the key ID (<kbd>kid</kbd>) that is present in the decoded token to retrieve the <kbd>.well-known/jwks.json</kbd> public key for the issuer. Then, we verify the signature of the token against the key and assert that the audience (<kbd>aud</kbd>) and issuer (<kbd>iss</kbd>) are as expected. Finally, the function returns an IAM policy that grants access to the service based on the path. The <kbd>claims</kbd> of the token are also returned in the <kbd>context</kbd> field so that they can be forwarded to the backend function. If any validations fail then we return an <kbd>Unauthorized</kbd> error.</p>
<p>The claims object must be flattened, otherwise <kbd>AuthorizerConfigurationException</kbd> is thrown.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authorizing a GraphQL-based service</h1>
                
            
            
                
<p>We have seen how to use a <em>JWT</em> to authorize access to services. In addition to this coarse-grained access control, we can also leverage the claims in the JWT to perform fine-grained, role-based access control. In this recipe, we will show how to use directives to create annotations that are used to define role-based permissions declaratively in a GraphQL schema.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the Cognito user pool created in the <em>Creating a federated identity pool</em> recipe and the sample application created in the <em>Implementing sign up, sign in, and sign out</em> recipe to create the identity token used in this recipe. You will need to assign the <kbd>Author</kbd> group, via the Cognito Console, to the user that you will use in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/graphql-jwt --path cncb-graphql-jwt</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-graphql-jwt</kbd> directory with <kbd>cd cncb-graphql-jwt</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-graphql-jwt<br/><br/>provider:<br/>  name: aws<br/>  runtime: nodejs8.10<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/><br/>functions:<br/>  graphql:<br/>    handler: handler.graphql<br/>    events:<br/>      - http:<br/>          ...<br/>          authorizer:<br/>            arn: ${cf:cncb-cognito-pool-${opt:stage}.userPoolArn}</pre>
<ol start="4">
<li>Review the <kbd>index.js</kbd>, <kbd>schema/thing/typedefs.js</kbd>, and <kbd>directives.js</kbd> files with the following content:</li>
</ol>
<pre style="padding-left: 30px"><strong>index.js</strong><br/>...<br/>const { <strong>directiveResolvers</strong> } = require('./directives');<br/><br/>const directives = `<br/>  directive @<strong>hasRole</strong>(roles: [String]) on QUERY | FIELD | MUTATION<br/>`;<br/>...<br/>module.exports = {<br/>  typeDefs: [directives, schemaDefinition, query, mutation, thingTypeDefs],<br/>  resolvers: merge({}, thingResolvers),<br/>  <strong>directiveResolvers</strong>,<br/>};<br/><br/><strong>schema/thing/typedefs.js</strong><br/><br/>module.exports = `<br/>  ...<br/>  extend type Mutation {<br/>    saveThing(<br/>      input: ThingInput<br/>    ): Thing <strong>@hasRole(roles: ["Author"])</strong><br/>    deleteThing(<br/>      id: ID!<br/>    ): Thing <strong>@hasRole(roles: ["Manager"])</strong><br/>  }<br/>`;<br/><br/><strong>directives.js</strong><br/><br/>const <strong>getGroups</strong> = ctx =&gt; get(ctx.event, 'requestContext.authorizer.claims.<strong>cognito:groups</strong>', '');<br/><br/>const <strong>directiveResolvers</strong> = {<br/>  hasRole: (next, source, { roles }, ctx) =&gt; {<br/>    const <strong>groups</strong> = getGroups(ctx).split(',');<br/>    if (intersection(groups, <strong>roles</strong>).length &gt; 0) {<br/>      return next();<br/>    }<br/>    throw new UserError('<strong>Access Denied</strong>');<br/>  },<br/>}<br/><br/>module.exports = { directiveResolvers };</pre>
<ol start="5">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test -- -s $MY_STAGE</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-graphql-jwt@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-graphql-jwt<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>endpoints:<br/>  POST - https://b33zxnw20b.execute-api.us-east-1.amazonaws.com/john/graphql<br/>functions:<br/>  graphql: cncb-graphql-jwt-john-graphql<br/><br/>Stack Outputs<br/>...<br/>ServiceEndpoint: https://b33zxnw20b.execute-api.us-east-1.amazonaws.com/john</pre>
<ol start="9">
<li>Review the stack and resources in the AWS Console.</li>
<li>Use the app in the <em>Implementing sign up, sign in, and sign out</em> recipe to sign in and generate <kbd>idToken</kbd>, and then export <kbd>idToken</kbd> with the following command:</li>
</ol>
<pre style="padding-left: 30px">$ export CNCB_TOKEN=&lt;idToken value&gt;</pre>
<ol start="11">
<li>Invoke the following <kbd>curl</kbd> commands, after updating <kbd>&lt;API-ID&gt;</kbd>, to successfully access the service with an <kbd>Authorization</kbd> token:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v -X POST -H "Authorization: Bearer $CNCB_TOKEN" -H 'Content-Type: application/json' -d '{"query":"mutation { saveThing(input: { id: \"55555555-6666-1111-1111-000000000000\", name: \"thing1\", description: \"This is thing one of two.\" }) { id } }"}' https://b33zxnw20b.execute-api.us-east-1.amazonaws.com/$MY_STAGE/graphql | json_pp</strong><br/><br/>{<br/>   "data" : {<br/>      "saveThing" : {<br/>         "id" : "55555555-6666-1111-1111-000000000000"<br/>      }<br/>   }<br/>}<br/><br/><strong>$ curl -v -X POST -H "Authorization: Bearer $CNCB_TOKEN" -H 'Content-Type: application/json' -d '{"query":"query { thing(id: \"55555555-6666-1111-1111-000000000000\") { id name description }}"}' https://b33zxnw20b.execute-api.us-east-1.amazonaws.com/$MY_STAGE/graphql | json_pp</strong><br/>{<br/>   "data" : {<br/>      "thing" : {<br/>         "name" : "thing1",<br/>         "id" : "55555555-6666-1111-1111-000000000000",<br/>         "description" : "This is thing one of two."<br/>      }<br/>   }<br/>}<br/><br/><strong>$ curl -v -X POST -H "Authorization: Bearer $CNCB_TOKEN" -H 'Content-Type: application/json' -d '{"query":"mutation { deleteThing( id: \"55555555-6666-1111-1111-000000000000\" ) { id } }"}' https://b33zxnw20b.execute-api.us-east-1.amazonaws.com/$MY_STAGE/graphql | json_pp</strong><br/>{<br/>   "data" : {<br/>      "deleteThing" : null<br/>   },<br/>   "errors" : [<br/>      {<br/>         "message" : "<strong>Access Denied</strong>"<br/>      }<br/>   ]<br/>}</pre>
<ol start="12">
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The service is configured with a Cognito <kbd>authorizer</kbd> that verifies the token and forwards <kbd>claims</kbd>. These <kbd>claims</kbd> include the <kbd>groups</kbd> that the user is a member of. At design time, we want to define the roles declaratively that are required to access privileged actions. In GraphQL, we can annotate a <kbd>schema</kbd> using <kbd>directives</kbd>. In this recipe, we define a <kbd>hasRole</kbd> directive and implement a <kbd>resolver</kbd> that checks the allowed <kbd>roles</kbd> defined in the annotation against <kbd>groups</kbd> present in the claims, and then it either allows or denies access. The <kbd>resolver</kbd> logic is decoupled from <kbd>schema</kbd> and the annotations in <kbd>schema</kbd> are straightforward and clean.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a JWT filter</h1>
                
            
            
                
<p>We have seen how to use a JWT to authorize access to services and how we can use the claims in the token to perform fine-grained, role-based authorization on actions within a service. We usually need to control access at the data instance level as well. For example, a customer should only have access to his or her data, or an employee should only have access to the data for a specific division. To accomplish this, we typically adorn filters to queries based on the user's entitlements. In a RESTful API, this information is usually included in the URL as path parameters as well. It is typical to use path parameters to perform queries.</p>
<p>However, we want to use the claims in the JWT to perform filters instead, because the values in the token are asserted by the authenticity of the token signature. In this recipe, we will demonstrate how to use the claims in the JWT to create query filters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the Cognito user pool created in the <em>Creating a federated identity pool</em> recipe and the sample application created in the <em>Implementing sign up, sign in, and sign out</em> recipe to create the identity token used in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/jwt-filter --path cncb-jwt-filter</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-jwt-filter</kbd> directory with <kbd>cd cncb-jwt-filter</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-jwt-filter<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/>  ...<br/><br/>functions:<br/>  save:<br/>    handler: handler.<strong>save</strong><br/>    events:<br/>      - http:<br/>          ...<br/>          authorizer:<br/>            arn: ${cf:cncb-cognito-pool-${opt:stage}.userPoolArn}<br/>  get:<br/>    handler: handler.<strong>get</strong><br/>    events:<br/>      - http:<br/>          path: things/{<strong>sub</strong>}/{id}<br/>          ...<br/>          <strong>authorizer</strong>:<br/>            arn: ${cf:cncb-cognito-pool-${opt:stage}.userPoolArn}<br/><br/>resources:<br/>  Resources:<br/>    Table:<br/>      ...<br/>        KeySchema:<br/>          - AttributeName: <strong>sub</strong><br/>            KeyType: HASH<br/>          - AttributeName: id<br/>            KeyType: RANG</pre>
<ol start="4">
<li>Review the file named <kbd>handler.js</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">module.exports.<strong>save</strong> = (request, context, callback) =&gt; {<br/>  const body = JSON.parse(request.body);<br/>  const <strong>sub</strong> = request.requestContext.authorizer.claims.<strong>sub</strong>;<br/>  const id = body.id || uuid.v4();<br/><br/>  const params = {<br/>    TableName: process.env.TABLE_NAME,<br/>    Item: {<br/>      <strong>sub</strong>,<br/>      id,<br/>      ...body<br/>    }<br/>  };<br/><br/>  ...<br/>  db.<strong>put</strong>(params, (err, resp) =&gt; {<br/>    ...<br/>  });<br/>};<br/><br/>module.exports.<strong>get</strong> = (request, context, callback) =&gt; {<br/>  const <strong>sub</strong> = request.requestContext.authorizer.claims.<strong>sub</strong>;<br/>  const id = request.pathParameters.id;<br/><br/>  if (<strong>sub</strong> !== request.pathParameters.<strong>sub</strong>) {<br/>    callback(null, { statusCode: <strong>401</strong> });<br/>    return;<br/>  }<br/><br/>  const params = {<br/>    TableName: process.env.TABLE_NAME,<br/>    Key: {<br/>      <strong>sub</strong>,<br/>      id,<br/>    },<br/>  };<br/><br/>  ...<br/>  db.<strong>get</strong>(params, (err, resp) =&gt; {<br/>    ...<br/>  });<br/>};</pre>
<ol start="5">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test -- -s $MY_STAGE</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-jwt-filter@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-jwt-filter<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>endpoints:<br/>  POST - https://ho1q4u5hp6.execute-api.us-east-1.amazonaws.com/john/things<br/>  GET - https://ho1q4u5hp6.execute-api.us-east-1.amazonaws.com/john/things/{sub}/{id}<br/>functions:<br/>  save: cncb-jwt-filter-john-save<br/>  get: cncb-jwt-filter-john-get</pre>
<ol start="9">
<li>Review the stack and resources in the AWS Console.</li>
<li>Use the app in the <em>Implementing sign up, sign in, and sign out</em> recipe to sign in and generate <kbd>idToken</kbd>, and then export <kbd>idToken</kbd> with the following command:</li>
</ol>
<pre style="padding-left: 30px">$ export CNCB_TOKEN=&lt;idToken value&gt;</pre>
<ol start="11">
<li>Invoke the following <kbd>curl</kbd> commands, after updating <kbd>&lt;API-ID&gt;</kbd>, to access data successfully within the restrictions of the  <kbd>Authorization</kbd> token:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v -X POST -H "Authorization: Bearer $CNCB_TOKEN" -H 'Content-Type: application/json' -d '{ "id": "55555555-7777-1111-1111-000000000000", "name": "thing1", "description": "This is thing one of two." }' https://&lt;API-ID&gt;.execute-api.us-east-1.amazonaws.com/$MY_STAGE/things</strong><br/><br/>&lt; HTTP/1.1 201 Created<br/>&lt; <strong>location</strong>: https://ho1q4u5hp6.execute-api.us-east-1.amazonaws.com/john/things/e4bdd021-a160-4aff-bce2-e652f9469e3e/55555555-7777-1111-1111-000000000000<br/><br/><strong>$ curl -v -H "Authorization: Bearer $CNCB_TOKEN" &lt;Location response header from POST&gt; | json_pp</strong><br/><br/>{<br/>   "description" : "This is thing one of two.",<br/>   "id" : "55555555-7777-1111-1111-000000000000",<br/>   "name" : "thing1",<br/>   "sub" : "e4bdd021-a160-4aff-bce2-e652f9469e3e"<br/>}<br/><br/><strong>$ curl -v -H "Authorization: Bearer $CNCB_TOKEN" https://&lt;API-ID&gt;.execute-api.us-east-1.amazonaws.com/</strong><strong>$MY_STAGE</strong><strong>/things/&lt;An invalid value&gt;/55555555-7777-1111-1111-000000000000 | json_pp</strong><br/><br/>&lt; HTTP/1.1 401 Unauthorized</pre>
<ol start="12">
<li>Take a look at the logs:</li>
</ol>
<pre style="padding-left: 30px">$ sls logs -f save -r us-east-1 -s $MY_STAGE<br/><br/>$ sls logs -f get -r us-east-1 -s $MY_STAGE</pre>
<ol start="13">
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The client of an API can use any values to formulate a URL, but it cannot tamper with the content of the JWT token because the issuer has signed the token. Therefore, we need to override any request values with the values from the token. In this recipe, we are saving and retrieving data for a specific user as determined by the subject or subclaim in the user's token. The service is configured with an <kbd>authorizer</kbd> that verifies the token and forwards <kbd>claims</kbd>.</p>
<p>To simplify the example, the subject is used as the <kbd>HASH</kbd> key and the data <kbd>uuid</kbd> as the <kbd>RANGE</kbd> key. When the data is retrieved, we assert the query parameter against the value in the token and return a <kbd>401</kbd> <kbd>statusCode</kbd> if they do not match. If they match, we use the value from the token in the actual query to guard against any bugs in the assertion logic that could inadvertently return unauthorized data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using envelope encryption</h1>
                
            
            
                
<p>Encrypting data at rest is critical for most systems. We must ensure the privacy of our customer's data and of our corporate data. Unfortunately, we all too often turn on disk-based encryption and then check off the requirement as complete. However, this only protects the data when the disk is disconnected from the system. When the disk is connected, then the data is automatically decrypted when it is read from disk. For example, create a DynamoDB table with server-side encryption enabled and then create some data and view it in the console. So long as you have permission, you will be able to see the data in clear text. To truly ensure the privacy of data at rest, we must encrypt data at the application level and effectively redact all sensitive information. In this recipe, we use the AWS <strong>Key Management Service</strong> (<strong>KMS</strong>) and a technique called <em>envelope encryption</em> to secure data at rest in a DynamoDB table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/envelope-encryption --path cncb-envelope-encryption</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-envelope-encryption</kbd> directory with <kbd>cd cncb-envelope-encryption</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-envelope-encryption<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/>  runtime: nodejs8.10<br/>  endpointType: REGIONAL<br/>  iamRoleStatements:<br/>    ...<br/>  environment:<br/>    TABLE_NAME:<br/>      Ref: Table<br/>    <strong>MASTER_KEY_ALIAS</strong>:<br/>      Ref: MasterKeyAlias<br/><br/>functions:<br/>  save:<br/>    ...<br/>  get:<br/>    ...<br/><br/>resources:<br/>  Resources:<br/>    Table:<br/>      ...<br/><br/>    <strong>MasterKey</strong>:<br/>      Type: AWS::KMS::Key<br/>      Properties:<br/>        KeyPolicy:<br/>          Version: '2012-10-17'<br/>          ...<br/><br/>    <strong>MasterKeyAlias</strong>:<br/>      Type: AWS::KMS::Alias<br/>      Properties:<br/>        AliasName: alias/${self:service}-${opt:stage}<br/>        TargetKeyId:<br/>          Ref: MasterKey<br/>  ...</pre>
<ol start="4">
<li>Review the file named <kbd>handler.js</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">const <strong>encrypt</strong> = (thing) =&gt; {<br/>  const params = {<br/>    KeyId: process.env.<strong>MASTER_KEY_ALIAS</strong>,<br/>    KeySpec: 'AES_256',<br/>  };<br/><br/>  ...<br/>  return kms.<strong>generateDataKey</strong>(params).promise()<br/>    .then((dataKey) =&gt; {<br/>      const <strong>encryptedThing</strong> = Object.keys(thing).reduce((encryptedThing, key) =&gt; {<br/>        if (key !== 'id')<br/>          encryptedThing[key] = <br/>            CryptoJS.AES.<strong>encrypt</strong>(thing[key], dataKey.Plaintext);<br/>        return encryptedThing;<br/>      }, {});<br/><br/>      return {<br/>        id: thing.id,<br/>        <strong>dataKey</strong>: dataKey.<strong>CiphertextBlob</strong>.toString('base64'),<br/>        ...<strong>encryptedThing</strong>,<br/>      };<br/>    });<br/>};<br/><br/>const <strong>decrypt</strong> = (thing) =&gt; {<br/>  const params = {<br/>    CiphertextBlob: Buffer.from(thing.<strong>dataKey</strong>, 'base64'),<br/>  };<br/><br/>  ...<br/>  return kms.<strong>decrypt</strong>(params).promise()<br/>    .then((dataKey) =&gt; {<br/>      const <strong>decryptedThing</strong> = Object.keys(thing).<strong>reduce</strong>((decryptedThing, key) =&gt; {<br/>        if (key !== 'id' &amp;&amp; key !== 'dataKey')<br/>          decryptedThing[key] = <br/>            CryptoJS.AES.<strong>decrypt</strong>(thing[key], dataKey.Plaintext);<br/>        return decryptedThing;<br/>      }, {});<br/><br/>      return {<br/>        id: thing.id,<br/>        ...<strong>decryptedThing</strong>,<br/>      };<br/>    });<br/>};<br/><br/>module.exports.<strong>save</strong> = (request, context, callback) =&gt; {<br/>  const thing = JSON.parse(request.body);<br/>  const id = thing.id || uuid.v4();<br/><br/>  <strong>encrypt</strong>(thing)<br/>    .then((encryptedThing) =&gt; {<br/>      const params = {<br/>        TableName: process.env.TABLE_NAME,<br/>        Item: {<br/>          id,<br/>          ...<strong>encryptedThing</strong>,<br/>        }<br/>      };<br/><br/>      ...<br/>      return db.<strong>put</strong>(params).promise();<br/>    })<br/>    ...<br/>};<br/><br/>module.exports.<strong>get</strong> = (request, context, callback) =&gt; {<br/>  const id = request.pathParameters.id;<br/>  ...<br/>  db.<strong>get</strong>(params).promise()<br/>    .then((resp) =&gt; {<br/>      return resp.Item ? <strong>decrypt</strong>(resp.Item) : null;<br/>    })<br/>    ...<br/>};</pre>
<ol start="5">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-envelope-encryption@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-envelope-encryption<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>endpoints:<br/>  POST - https://7wpqdcsoad.execute-api.us-east-1.amazonaws.com/john/things<br/>  GET - https://7wpqdcsoad.execute-api.us-east-1.amazonaws.com/john/things/{id}<br/>functions:<br/>  save: cncb-envelope-encryption-john-save<br/>  get: cncb-envelope-encryption-john-get<br/><br/>Stack Outputs<br/>...<br/><strong>MasterKeyId</strong>: c83de811-bda8-4bdc-83e1-32e8491849e5<br/>MasterKeyArn: arn:aws:kms:us-east-1:123456789012:key/c83de811-bda8-4bdc-83e1-32e8491849e5</pre>
<pre style="padding-left: 30px">ServiceEndpoint: https://7wpqdcsoad.execute-api.us-east-1.amazonaws.com/john<br/><strong>MasterKeyAlias</strong>: alias/cncb-envelope-encryption-john</pre>
<ol start="9">
<li>Review the stack and resources in the AWS Console.</li>
<li>Invoke the following <kbd>curl</kbd> commands, after updating <kbd>&lt;API-ID&gt;</kbd>, to encrypt and decrypt data:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v -X POST -d '{ "id": "55555555-8888-1111-1111-000000000000", "name": "thing1", "description": "This is thing one of two." }' https://7wpqdcsoad.execute-api.us-east-1.amazonaws.com/$MY_STAGE/things</strong><br/><br/>&lt; HTTP/1.1 201 Created<br/>&lt; location: https://7wpqdcsoad.execute-api.us-east-1.amazonaws.com/john/things/55555555-8888-1111-1111-000000000000<br/><br/><strong>$ curl -v https://7wpqdcsoad.execute-api.us-east-1.amazonaws.com/$MY_STAGE/things/55555555-8888-1111-1111-000000000000 | json_pp</strong><br/><br/>{<br/>   "name" : "thing1",<br/>   "id" : "55555555-8888-1111-1111-000000000000",<br/>   "description" : "This is thing one of two."<br/>}</pre>
<ol start="11">
<li>Review the encrypted data in the DynamoDB Console.</li>
<li>Take a look at the logs:</li>
</ol>
<pre style="padding-left: 30px">$ sls logs -f save -r us-east-1 -s $MY_STAGE<br/><br/>$ sls logs -f get -r us-east-1 -s $MY_STAGE</pre>
<ol start="13">
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>
<p>KMS is not included in the AWS free tier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Envelope encryption is, in essence, the practice of encrypting one key with another key; sensitive data is encrypted with a data key and then the data key is encrypted with a master key. In this recipe, the <kbd>save</kbd> function encrypts the data before saving it to DynamoDB, and the <kbd>get</kbd> function decrypts the data after retrieving it from DynamoDB and before returning the data to the caller. In the <kbd>serverless.yml</kbd> file, we define a KMS <kbd>MasterKey</kbd> and a <kbd>MasterKeyAlias</kbd>. The alias facilitates the rotation of the master key. The <kbd>save</kbd> function calls <kbd>kms.generateDataKey</kbd> to create a data key for the object. Each object gets its own data key and a new key is generated each time the object is saved. Again, this practice facilitates key rotation. Following the <em>security-by-design</em> practice, we identify which fields are sensitive as we design and develop a service. In this recipe, we encrypt all of the fields individually. The data key is used to encrypt each field locally using an <kbd>AES</kbd> encryption library. The data key was also encrypted by the master key and returned to the <kbd>CyphertextBlob</kbd> field when the data key was generated. The encrypted data key is stored alongside the data so that it can be decrypted by the <kbd>get</kbd> function. The <kbd>get</kbd> function has direct access to the encrypted data key once the data has been retrieved from the database. The <kbd>get</kbd> function has been granted permission to call <kbd>kms.decrypt</kbd> to decrypt the data key. This piece of the puzzle is crucial. Access to the master key must be restricted as per the least privilege principle. The fields are decrypted locally using an AES encryption library so that they can be returned to the caller.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an SSL certificate for encryption in transit</h1>
                
            
            
                
<p>Encrypting data in transit is critical for systems with sensitive data, which accounts for most systems these days. Fully managed cloud services, such as function-as-a-service, cloud-native databases, and API Gateways, encrypt data in transit as a matter of course. This helps ensure that our data in motion is secured across the full stack, with little to no effort on our part. However, we ultimately want to expose our cloud-native resources via custom domain names. To do this and support SSL, we must provide our own SSL certificates. This process can be tedious and we must ensure that we rotate certificates in a timely manner before they expire and cause a system outage. Fortunately, more and more cloud providers are offering fully managed certificates that are automatically rotated. In the recipe, we will use the <em>AWS Certificate Manager</em> to create a certificate and associate it with a <em>CloudFront</em> distribution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need a registered domain name and a Route 53 hosted zone that you can use in this recipe to create a subdomain for the site that will be deployed, and you will need authority to approve the creation of the certificate or access to someone with the authority.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/ssl-cert --path cncb-ssl-cert</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-ssl-cert</kbd> directory with <kbd>cd cncb-ssl-cert</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-ssl-cert<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/><br/>plugins:<br/> - serverless-spa-deploy<br/> - serverless-spa-config<br/><br/>custom:<br/>  spa:<br/>    ...<br/>  dns:<br/>    hostedZoneId: <strong>ZXXXXXXXXXXXXX</strong><br/>    <strong>validationDomain</strong>: <strong>example.com</strong><br/>    <strong>domainName</strong>: ${self:custom.dns.validationDomain}<br/>    <strong>wildcard</strong>: '*.${self:custom.dns.domainName}'<br/>    <strong>endpoint</strong>: ${opt:stage}-${self:service}.${self:custom.dns.domainName}<br/>  cdn:<br/>    <strong>acmCertificateArn</strong>: <br/>      Ref: WildcardCertificate<br/><br/>resources:<br/>  Resources:<br/>    <strong>WildcardCertificate</strong>:<br/>      Type: AWS::CertificateManager::Certificate<br/>      Properties:<br/>        DomainName: ${self:custom.dns.wildcard}<br/>        DomainValidationOptions:<br/>          - DomainName: ${self:custom.dns.wildcard}<br/>            <strong>ValidationDomain</strong>: ${self:custom.dns.validationDomain}<br/>        SubjectAlternativeNames:<br/>          - ${self:custom.dns.domainName}<br/><br/>  ...</pre>
<ol start="4">
<li>Update the <kbd>serverless.yml</kbd> file with your <kbd>hostedZoneId</kbd> and  <kbd>validationDomain</kbd>.</li>
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-ssl-cert@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-ssl-cert<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/><br/>Stack Outputs<br/><strong>...</strong><br/>WebsiteDistributionURL: https://d19i44112h4l3r.cloudfront.net<br/>...<br/><strong>WebsiteURL</strong>: https://john-cncb-ssl-cert.example.com<br/>WebsiteDistributionId: EQSJSWLD0F1JI<br/><strong>WildcardCertificateArn</strong>: arn:aws:acm:us-east-1:870671212434:certificate/72807b5b-fe37-4d5c-8f92-25ffcccb6f79<br/><br/>Serverless: Path: ./build<br/>Serverless: File: index.html (text/html)</pre>
<p>To complete this step, an authorized person is needed to receive the certificate approval request email and approve the creation of the certificate. The CloudFormation stack will appear to pause until the certificate is approved.</p>
<ol start="9">
<li>Review the stack and resources in the AWS Console.</li>
<li>Invoke the following <kbd>curl</kbd> command with the <kbd>WebsiteURL</kbd> from the stack output:</li>
</ol>
<pre style="padding-left: 30px">$ curl -v -https://john-cncb-ssl-cert.example.com</pre>
<ol start="11">
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the resources section of the <kbd>serverless.yml</kbd> file, we define the <kbd>WildcardCertificate</kbd> resource to instruct the AWS Certificate Manager to create the desired certificate. We create a wildcard certificate so that it can be used by many services. It is important to specify the correct <kbd>validationDomain</kbd>, because this will be used to request approval before creating the certificate. You must also provide <kbd>hostedZoneId</kbd> for the top-level domain name. Everything else is handled by the <kbd>serverless-spa-config</kbd> plugin. The recipe deploys a simple site consisting of an <kbd>index.html</kbd> page. The <kbd>endpoint</kbd> for the site is used to create a Route 53 record set in the hosted zone and is assigned as the alias of the site's CloudFront distribution. The wildcard certificate matches the endpoint and its <kbd>acmCertificateArn</kbd> is assigned to the distribution. Ultimately, we can access <kbd>WebsiteURL</kbd> with the <kbd>https</kbd> protocol and the custom domain name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring a web application firewall</h1>
                
            
            
                
<p>A <strong>web application firewall</strong> (<strong>WAF</strong>) is an important tool for controlling the traffic of a cloud-native system. A WAF protects the system by blocking traffic from common exploits such as bad bots, SQL injection, <strong>Cross-Site Scripting</strong> (<strong>XSS</strong>), HTTP floods, and known attackers. We effectively create a perimeter around the system that blocks traffic at the edge of the cloud before it can impact system resources. We can use many of the techniques in this book to monitor internal and external resources and dynamically update the firewall rules as the flow of traffic changes. Managed rules are also available on the market, so we can leverage the extensive security expertise of third parties. In this recipe, we will demonstrate how the pieces fit together by creating a rule to block traffic from outside a corporate network and associate the WAF with a <em>CloudFront</em> distribution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/waf --path cncb-waf</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-waf</kbd> directory with <kbd>cd cncb-waf</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-waf<br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/><br/>plugins:<br/> - serverless-spa-deploy<br/> - serverless-spa-config<br/><br/>custom:<br/>  spa:<br/>    ...<br/>  cdn:<br/>    <strong>webACLId</strong>: <br/>      Ref: WebACL<br/>    # logging:<br/>    #   bucketName: ${cf:cncb-account-as-code-${opt:stage}.AuditBucketName}<br/><br/>resources:<br/>  Resources:<br/>    <strong>WhitelistIPSet</strong>: <br/>      Type: AWS::WAF::IPSet<br/>      Properties: <br/>        Name: IPSet for whitelisted IP adresses<br/>        IPSetDescriptors: <br/>          - Type: IPV4<br/>            Value: <strong>0.0.0.1/32</strong><br/><br/>    <strong>WhitelistRule</strong>: <br/>      Type: AWS::WAF::Rule<br/>      Properties: <br/>        Name: WhitelistRule<br/>        MetricName: WhitelistRule<br/>        Predicates: <br/>          - DataId: <br/>              Ref: WhitelistIPSet<br/>            Negated: false<br/>            Type: IPMatch  <br/>        <br/>    <strong>WebACL</strong>: <br/>      Type: AWS::WAF::WebACL<br/>      Properties: <br/>        Name: Master WebACL<br/>        DefaultAction: <br/>          Type: <strong>BLOCK</strong><br/>        MetricName: MasterWebACL<br/>        Rules: <br/>          - Action: <br/>              Type: <strong>ALLOW</strong><br/>            Priority: 1<br/>            RuleId: <br/>              Ref: WhitelistRule        <br/><br/>  Outputs:<br/>    WebACLId:<br/>      Value:<br/>        Ref: WebACL</pre>
<ol start="4">
<li>Determine your corporate external public IP address by logging in to your VPN and then executing the following command:</li>
</ol>
<pre style="padding-left: 30px">$ curl ipecho.net/plain ; echo</pre>
<ol start="5">
<li>Update <kbd>WhitelistIPSet</kbd> in the <kbd>serverless.yml</kbd> file with your IP address followed by <kbd>/32</kbd>.</li>
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-waf@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-waf<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/><br/>Stack Outputs<br/><strong>WebsiteDistributionURL</strong>: https://d3a9sc88i7431l.cloudfront.net<br/>WebsiteS3URL: http://cncb-waf-john-websitebucket-1c13hrzslok5s.s3-website-us-east-1.amazonaws.com<br/>WebsiteBucketName: cncb-waf-john-websitebucket-1c13hrzslok5s<br/>WebsiteDistributionId: E3OLRBU9LRZBUE<br/><strong>WebACLId</strong>: 68af80b5-8eda-43d0-be25-6c65d5cc691e<br/><br/>Serverless: Path: ./build<br/>Serverless: File: index.html (text/html)</pre>
<ol start="10">
<li>Review the stack and resources in the AWS Console.</li>
<li>Browse to the <kbd>WebsiteDistributionURL</kbd> listed in the stack outputs while connecting to your VPN and you will be able to access the page.</li>
<li>Now, disconnect from the VPN and you will be denied access to the page once the cache has cleared.</li>
<li>Remove the stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first thing to note is that usage of the AWS WAF is predicated on using CloudFront. The <kbd>serverless-spa-config</kbd> plugin creates the CloudFront distribution and assigns <kbd>webACLId</kbd>. For this recipe, we are securing a simple <kbd>index.html</kbd> page. We create a static <kbd>WebACL</kbd> to block everything except a single IP address. We define the <kbd>WhitelistIPSet</kbd> for the single address and associate it with <kbd>WhitelistRule</kbd>. Then, we associate the rule with an <strong>access control list</strong> (<strong>ACL</strong>) and define the default action to <kbd>BLOCK</kbd> all access, and then an action to <kbd>ALLOW</kbd> access based on <kbd>WhitelistRule</kbd>.</p>
<p>This example is useful, but it only scratches the surface of what is possible. For example, we could uncomment the logging configuration for the CloudFront distribution and then process the access logs and dynamically create rules based on suspicious activity. On a daily basis, we can retrieve public reputation lists and update the rule sets as well. Defining and maintaining effective rules can be a full-time effort, therefore the fully managed rules that are available on the AWS marketplace are an attractive alternative for, or companion to, custom rules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Replicating the data lake for disaster recovery</h1>
                
            
            
                
<p>When I first read this story about Code Spaces (<a href="https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html">https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html</a>), I was a bit horrified until I realized that this company perished so that we could all learn from its experience. Code Spaces was a company that used AWS and their account was hijacked and held to ransom. They fought back and the entire contents of their account were deleted, including their backups, and they simply went out of business. Proper use of MFA and proper access key hygiene is critical to ward off such attacks. It is also crucial to maintain backups as an entirely separate and disconnected account, so that the breach of a single account does not spell disaster for an entire system and company. In this recipe, we will use the S3 replication feature to replicate buckets to a dedicated recovery account. At a minimum, this technique should be used to replicate the contents of the data lake, since the events in the data lake can be replayed to recreate the system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the source and recovery projects from the following templates:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/dr/recovery-account --path cncb-dr-recovery-account<br/><br/>$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch5/dr/src1-account --path cncb-dr-src1-account</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-dr-recovery-account</kbd> directory with <kbd>cd cncb-dr-recovery-account</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-dr-<strong>recovery-account</strong><br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/><br/>custom:<br/>  accounts:<br/>    src1:<br/>      accountNumber: '#{AWS::AccountId}' # using same account to simplify recipe<br/>...<br/>resources:<br/>  Resources:<br/>    <strong>DrSrc1Bucket1</strong>:<br/>      Type: AWS::S3::Bucket<br/>      DeletionPolicy: Retain<br/>      Properties:<br/>        BucketName: cncb-${opt:stage}-<strong>us-west-1</strong>-src1-bucket1-dr<br/>        <strong>VersioningConfiguration</strong>:<br/>          Status: Enabled<br/>    <strong>DrSrc1Bucket1Policy</strong>: <br/>      Type: AWS::S3::BucketPolicy<br/>      Properties: <br/>        Bucket: <br/>          Ref: DrSrc1Bucket1<br/>        PolicyDocument:<br/>          Statement:<br/>            - Effect: Allow<br/>              Principal:<br/>                AWS: arn:aws:iam::${self:custom.accounts.<strong>src1</strong>.accountNumber}:root<br/>              Action:<br/>                - s3:ReplicateDelete<br/>                - s3:ReplicateObject<br/>                - s3:ObjectOwnerOverrideToBucketOwner<br/>              Resource:<br/>                ...<br/>  ...</pre>
<ol start="4">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-dr@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-dr<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>Stack Outputs<br/><strong>DrSrc1Bucket1Name</strong>: cncb-john-us-west-1-src1-bucket1-dr</pre>
<ol start="8">
<li>Navigate to the <kbd>cncb-dr-src1-account</kbd> directory with <kbd>cd cncb-dr-src1-account</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-dr-<strong>src1-account</strong><br/><br/>provider:<br/>  name: aws<br/>  # cfnRole: arn:aws:iam::&lt;account-number&gt;:role/${opt:stage}-cfnRole<br/>  ...<br/><br/>custom:<br/>  replicationBucketArn: arn:aws:s3:::cncb-${opt:stage}-<strong>us-west-1</strong>-src1-bucket1-dr<br/>  recovery:<br/>    accountNumber: '#{AWS::AccountId}' # using same account to simplify recipe<br/>...<br/>resources:<br/>  Resources:<br/>    <strong>Src1Bucket1</strong>:<br/>      Type: AWS::S3::Bucket<br/>      DeletionPolicy: Retain<br/>      Properties:<br/>        BucketName: cncb-${opt:stage}-us-east-1-src1-bucket1<br/>        <strong>VersioningConfiguration</strong>:<br/>          Status: Enabled<br/>        <strong>ReplicationConfiguration</strong>:<br/>          Role: arn:aws:iam::#{AWS::AccountId}:role/${self:service}-${opt:stage}-${opt:region}-replicate<br/>          Rules:<br/>            - Destination:<br/>                Bucket: ${self:custom.<strong>replicationBucketArn</strong>}<br/>                <strong>StorageClass</strong>: STANDARD_IA<br/>                Account: ${self:custom.<strong>recovery</strong>.accountNumber}<br/>                <strong>AccessControlTranslation</strong>:<br/>                  Owner: Destination<br/>              Status: Enabled<br/>              Prefix: ''<br/><br/>    <strong>Src1Bucket1ReplicationRole</strong>:<br/>      DependsOn: Src1Bucket1<br/>      Type: AWS::IAM::Role<br/>      Properties:<br/>        RoleName: ${self:service}-${opt:stage}-${opt:region}-replicate<br/>        AssumeRolePolicyDocument:<br/>          Statement:<br/>            - Effect: Allow<br/>              Principal:<br/>                Service:<br/>                  - <strong>s3.amazonaws.com</strong><br/>              Action:<br/>                - sts:<strong>AssumeRole</strong><br/>        Policies:<br/>          - PolicyName: replicate<br/>            PolicyDocument:<br/>              Statement:<br/>                ...<br/>                - Effect: Allow<br/>                  Action:<br/>                    - s3:ReplicateObject<br/>                    - s3:ReplicateDelete<br/>                    - s3:ObjectOwnerOverrideToBucketOwner<br/>                  Resource: ${self:custom.<strong>replicationBucketArn</strong>}/*<br/>       <br/>  ...</pre>
<ol start="10">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests with <kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-dr@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-dr<br/>&gt; sls deploy -v -r us-east-1 "-s" "john"<br/><br/>Serverless: Packaging service...<br/>...<br/>Serverless: Stack update finished...<br/>...<br/>Stack Outputs<br/><strong>Src1Bucket1Name</strong>: cncb-john-us-east-1-src1-bucket1</pre>
<ol start="14">
<li>Review the stacks and buckets in the AWS Console.</li>
<li>Invoke the following command to load data:</li>
</ol>
<pre style="padding-left: 30px">$ sls invoke -r us-east-1 -f load -s $MY_STAGE</pre>
<ol start="16">
<li>Review the contents of both buckets to see that the data has replicated.</li>
<li>Remove each stack once you are finished with <kbd>npm run rm:lcl -- -s $MY_STAGE</kbd></li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>AWS S3 does all the heavy lifting of replicating the contents of one bucket to another. We just have to define what and where we want to replicate and set up all the permissions correctly. It is important to replicate to a separate account that is completely disconnected from any other accounts to ensure that a breach in another account does not impact the recovery account. To simplify this recipe, we will use a single account, but this does not change the CloudFormation templates other than the account number value. It is also a good idea to replicate into a region that you are not otherwise using, so that an outage in one of your regions does not also mean there is an outage in your recovery region. Next, we need to create a corresponding bucket in the recovery account for every source bucket that we want to replicate. It is a good idea to use a naming convention with prefixes and/or suffixes to differentiate the source bucket easily from the destination bucket. All of the buckets must turn on versioning to support replication. The source buckets grant permission to the S3 service to perform the replication, and the destination buckets grant permission to the source account to write to the recovery account. We also transfer ownership of the replicated contents to the recovery account. Ultimately, if the contents are completely deleted from the source bucket, the destination bucket will still contain the contents along with the deletion marker.</p>


            

            
        
    </body></html>