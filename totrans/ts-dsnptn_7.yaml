- en: Chapter 9. The Road to Enterprise Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 企业应用程序之路
- en: After walking through common design patterns, we have now the basis of code
    designing. However, software engineering is more about writing beautiful code.
    While we are trying to keep the code healthy and robust, we still have a lot to
    do to keep the project and the team healthy, robust, and ready to scale. In this
    chapter, we'll talk about popular elements in the workflow of web applications,
    and how to design a workflow that fits your team.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了常见的设计模式之后，我们现在有了代码设计的基石。然而，软件工程更多的是关于编写优美的代码。当我们试图保持代码健康和健壮时，我们仍然有很多工作要做，以确保项目和团队健康、健壮，并准备好扩展。在本章中，我们将讨论
    Web 应用程序工作流程中的流行元素，以及如何设计适合您团队的工作流程。
- en: The first part would be setting up the build steps of our demo project. We'll
    quickly walk through how to build frontend projects with *webpack*, one of the
    most popular packaging tools these days. And we'll configure tests, code linter,
    and then set up continuous integration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分将是设置我们的演示项目的构建步骤。我们将快速介绍如何使用 *webpack*（目前最受欢迎的打包工具之一）构建前端项目。然后我们将配置测试、代码检查器，并设置持续集成。
- en: There are plenty of nice choices when it comes to workflow integration. Personally,
    I prefer Team Foundation Server for private projects or a combination of GitHub
    and Travis-CI for open-source projects. While Team Foundation Server (or Visual
    Studio Team Services as its cloud-based version) provides a one-stop solution
    for the entire application life cycle, the combination of GitHub and Travis-CI
    is more popular in the JavaScript community. In this chapter, we are going use
    the services provided by GitHub and Travis-CI for our workflow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流程集成方面有很多不错的选择。我个人更喜欢为私人项目使用 Team Foundation Server，或者为开源项目使用 GitHub 和 Travis-CI
    的组合。虽然 Team Foundation Server（或其基于云的版本 Visual Studio Team Services）为整个应用程序生命周期提供了一站式解决方案，但
    GitHub 和 Travis-CI 的组合在 JavaScript 社区中更为流行。在本章中，我们将使用 GitHub 和 Travis-CI 提供的服务来构建我们的工作流程。
- en: 'Here are what we are going to walk through:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要介绍的内容：
- en: Packaging frontend assets with webpack.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 webpack 打包前端资源。
- en: Setting up tests and linter.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试和代码检查器。
- en: Getting our hands on a Git flow branching model and other Git-related workflow.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Git 分支模型和其他 Git 相关的工作流程。
- en: Connecting a GitHub repository with Travis-CI.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GitHub 仓库与 Travis-CI 连接。
- en: A peek into automated deployment.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署的简要介绍。
- en: Creating an application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: We've talked about creating TypeScript applications for both frontend and backend
    projects in the [Chapter 1](ch01.html "Chapter 1. Tools and Frameworks"), *Tools
    and Frameworks*. And now we are going to create an application that contains two
    TypeScript projects at the same time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](ch01.html "第 1 章. 工具和框架") *工具和框架* 中讨论了为前端和后端项目创建 TypeScript 应用程序。现在我们将创建一个同时包含两个
    TypeScript 项目的应用程序。
- en: Decision between SPA and "normal" web applications
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 SPA 和“常规”Web 应用程序之间做出决定
- en: Applications for different purposes result in different choices. SPA (single
    page application) usually delivers a better user experience after being loaded,
    but it can also lead to trade-offs on SEO and may rely on more complex MV* frameworks
    like Angular.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不同目的的应用程序会导致不同的选择。单页应用（SPA）在加载后通常提供更好的用户体验，但也可能导致 SEO 方面的权衡，并可能依赖于更复杂的 MV* 框架，如
    Angular。
- en: One solution to build SEO-friendly SPA is to build a universal (or isomorphic)
    application that runs the *same* code on both frontend and backend, but that could
    introduce even more complexity. Or a reverse proxy could be configured to render
    automatically generated pages with the help of tools like *Phantom*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一种构建 SEO 友好型 SPA 的解决方案是构建一个在前后端都运行 *相同* 代码的通用（或同构）应用程序，但这可能会引入更多的复杂性。或者可以配置反向代理，利用像
    *Phantom* 这样的工具自动渲染自动生成的页面。
- en: 'In this demo project, we''ll choose a more traditional web application with
    multiple pages to build. And here''s the file structure of the client project:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示项目中，我们将选择一个更传统的多页面 Web 应用程序来构建。以下是客户端项目的文件结构：
- en: '![Decision between SPA and "normal" web applications](img/image_09_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![在 SPA 和“常规”Web 应用程序之间做出决定](img/image_09_001.jpg)'
- en: Taking team collaboration into consideration
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑团队协作
- en: Before we actually start creating a real-world application, we need to come
    up with a reasonable application structure. A proper application structure is
    more than something under which the code compiles and runs. It should be a result,
    taking how your team members work together into consideration.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际开始创建真实世界的应用程序之前，我们需要提出一个合理的应用程序结构。适当的应用程序结构不仅仅是代码编译和运行的地方。它应该是一个结果，考虑到团队成员如何一起工作。
- en: 'For example, a naming convention is involved in this demo client structure
    shown earlier: page assets are named after page names instead of their types (for
    example, `style.scss`) or names like `index.ts`. And the consideration behind
    this convention is making it more friendly for file navigation by the keyboard.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面展示的此演示客户端结构中涉及到了一个命名约定：页面资源以页面名称命名，而不是它们的类型（例如，`style.scss`）或像`index.ts`这样的名称。这个约定的背后考虑是使文件通过键盘导航更加友好。
- en: 'Of course, this consideration is valid only if a significant number of developers
    in your team are cool with keyboard navigation. Other than operation preferences,
    the experiences and backgrounds of a team should be seriously considered as well:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只有当你们团队中相当一部分开发者对键盘导航感到满意时，这种考虑才是有效的。除了操作偏好之外，团队的体验和背景也应该被认真考虑：
- en: Should the "full-stack" mode be enabled for your team?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该为你们团队启用“全栈”模式吗？
- en: Should the "full-stack" mode be enabled for every engineer in your team?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该为你们团队中的每位工程师启用“全栈”模式吗？
- en: How should you divide work between frontend and backend?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该如何在前后端之间分配工作？
- en: Usually, it's not necessary and not efficient to limit the access of a frontend
    engineer to client-side development. If it's possible, frontend engineers could
    take over the controller layer of the backend and leave hardcore business models
    and logic to engineers that focus more on the backend.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，限制前端工程师访问客户端开发的访问权限既不必要也不高效。如果可能的话，前端工程师可以接管后端的控制器层，将核心业务模型和逻辑留给更专注于后端开发的工程师。
- en: We are having the client and server-side projects in the same repository for
    an easier integration during development. But it does not mean everything in the
    frontend or backend code base should be in this single repository. Instead, multiple
    modules could be extracted and maintained by different developers in practice.
    For example, you can have database models and business logic models separated
    from the controllers on the backend.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一个存储库中拥有客户端和服务器端项目，以便在开发期间更容易集成。但这并不意味着前端或后端代码库中的所有内容都应该在这个单一存储库中。相反，在实践中，多个模块可以由不同的开发者提取和维护。例如，你可以将数据库模型和业务逻辑模型从后端的控制器中分离出来。
- en: Building and testing projects
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试项目
- en: We have already talked about building and testing TypeScript projects at the
    beginning of this book. In this section, we will go a little bit further for frontend
    projects, including the basis of using Webpack to load static assets as well as
    **code linting**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的开头讨论了构建和测试TypeScript项目。在本节中，我们将进一步探讨前端项目，包括使用Webpack加载静态资产以及**代码检查**的基础。
- en: Static assets packaging with webpack
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用webpack进行静态资源打包
- en: Modularizing helps code keep a healthy structure and makes it maintainable.
    However, it could lead to performance issues if development-time code written
    in *small* modules are directly deployed without bundling for production usage.
    So static assets packaging becomes a serious topic of frontend engineering.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化有助于代码保持健康结构，并使其易于维护。然而，如果开发时在*小*模块中编写的代码直接部署到生产使用而没有打包，可能会导致性能问题。因此，静态资源打包成为前端工程的一个严肃话题。
- en: Back to the old days, packaging JavaScript files was just about *uglifying*
    source code and concatenating files together. The project might be modularized
    as well, but in a *global* way. Then we have libraries like Require.js, with modules
    no longer automatically exposing themselves to the global scope.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到过去，打包JavaScript文件仅仅是*丑化*源代码并将文件连接在一起。项目可能也会进行模块化，但以*全局*的方式。然后我们有了像Require.js这样的库，模块不再自动暴露到全局作用域。
- en: But as I have mentioned, having the client download module files separately
    is not ideal for performance; soon we had tools like browserify, and later, webpack
    - one of the most popular frontend packaging tools these days.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我之前提到的，让客户端分别下载模块文件对于性能来说并不理想；很快我们就有了像browserify这样的工具，后来还有webpack——目前最受欢迎的前端打包工具之一。
- en: Introduction to webpack
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: webpack简介
- en: Webpack is an integrated packaging tool dedicated (at least at the beginning)
    to frontend projects. It is designed to package not only JavaScript, but also
    other static assets in a frontend project. Webpack provides built-in support for
    both **asynchronous module definition** (**AMD**) and commonjs, and can load ES6
    or other types of resources via plugins.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是一个针对前端项目集成的打包工具（至少最初是针对前端项目的）。它旨在打包不仅限于 JavaScript，还包括前端项目中的其他静态资源。Webpack
    内置了对 **异步模块定义**（**AMD**）和 commonjs 的支持，并且可以通过插件加载 ES6 或其他类型的资源。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES6 module support will get built-in for webpack 2.0, but by the time this chapter
    is written, you still need plugins like `babel-loader` or `ts-loader` to make
    it work. And of course we are going to use `ts-loader` later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块支持将在 webpack 2.0 中内置，但到本章编写时，你仍然需要像 `babel-loader` 或 `ts-loader` 这样的插件来使其工作。当然，我们稍后也会使用
    `ts-loader`。
- en: 'To install webpack via `npm`, execute the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 `npm` 安装 webpack，请执行以下命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Bundling JavaScript
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 JavaScript 打包
- en: Before we actually use webpack to load TypeScript files, we'll have a quick
    walk through of bundling JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际使用 webpack 加载 TypeScript 文件之前，我们将快速浏览 JavaScript 打包的过程。
- en: 'First, let''s create the file `index.js` under the directory `client/src/`
    with the following code inside:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `client/src/` 目录下创建名为 `index.js` 的文件，并在其中包含以下代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then create the file `foo.js` in the same folder with the following content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在同一文件夹中创建名为 `foo.js` 的文件，内容如下：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can have them bundled as a single file using the webpack command-line
    interface:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 webpack 命令行界面将它们打包成一个单独的文件：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By viewing the `bundle.js` file generated by webpack, you will see that the
    contents of both `index.js` and `foo.js` have been wrapped into that single file,
    together with the bootstrap code of webpack. Of course, we would prefer not to
    type those file paths in the command line every time, but to use a configuration
    file instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 webpack 生成的 `bundle.js` 文件，你会看到 `index.js` 和 `foo.js` 的内容都被封装进那个单独的文件中，以及
    webpack 的引导代码。当然，我们更愿意每次都不在命令行中输入这些文件路径，而是使用配置文件。
- en: Webpack provides configuration file support in the form of JavaScript files,
    which makes it more flexible to generate necessary data like bundle entries automatically.
    Let's create a simple configuration file that does what the previous command did.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 以 JavaScript 文件的形式提供配置文件支持，这使得它能够更灵活地自动生成必要的数据，如捆绑条目。让我们创建一个简单的配置文件，执行之前命令的功能。
- en: 'Create file `client/webpack.config.js` with the following lines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件 `client/webpack.config.js`，包含以下行：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These are the two things to mention:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件事需要提及：
- en: The value of the `entry` field is not the filename, but the *module id* (most
    of the time this is unresolved) instead. This means that you can have the `.js`
    extension omitted, but have to prefix it with `./` or `../` by default when referencing
    a file.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`entry` 字段的值不是文件名，而是模块 ID（大多数情况下这是未解析的）。这意味着你可以省略 `.js` 扩展名，但在引用文件时默认需要以 `./`
    或 `../` 前缀。'
- en: The output path is required to be absolute. Building an absolute path with `__dirname`
    ensures it works properly if we are not executing webpack under the same directory
    as the configuration file.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出路径必须是绝对路径。使用 `__dirname` 构建绝对路径可以确保如果我们不在与配置文件相同的目录下执行 webpack，它也能正常工作。
- en: Loading TypeScript
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 TypeScript
- en: 'Now we are going to load and transpile our beloved TypeScript using the webpack
    plugin `ts-loader`. Before updating the configuration, let''s install the necessary
    npm packages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 webpack 插件 `ts-loader` 加载和转换我们喜爱的 TypeScript。在更新配置之前，让我们安装必要的 npm 包：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If things go well, you should have the TypeScript compiler as well as the `ts-loader`
    plugin installed locally. We may also want to rename and update the files `index.js`
    and `foo.js` to TypeScript files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该已经安装了 TypeScript 编译器和 `ts-loader` 插件。我们可能还想将 `index.js` 和 `foo.js`
    文件重命名并更新为 TypeScript 文件。
- en: 'Rename `index.js` to `index.ts` and update the module importing syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `index.js` 重命名为 `index.ts` 并更新模块导入语法：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Rename `foo.js` to `foo.ts` and update the module exporting syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `foo.js` 重命名为 `foo.ts` 并更新模块导出语法：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, we would want to add the `tsconfig.json` file for those TypeScript
    files (in the folder `client`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还想为 TypeScript 文件添加 `tsconfig.json` 文件（在 `client` 文件夹中）：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler option `outDir` is omitted here because it is managed in the webpack
    configuration file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器选项 `outDir` 在这里被省略了，因为它在 webpack 配置文件中管理。
- en: 'To make webpack work with TypeScript via `ts-loader`, we''ll need to tell webpack
    some information in the configuration file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 webpack 通过 `ts-loader` 与 TypeScript 一起工作，我们需要在配置文件中告诉 webpack 一些信息：
- en: Webpack will need to resolve files with `.ts` extensions. Webpack has a default
    extensions list to resolve, including `''` (empty string), `'.webpack.js'`, `'.web.js'`,
    and `'.js'`. We need to add `'.ts'` to this list for it to recognize TypeScript
    files.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack 需要解析具有 `.ts` 扩展名的文件。Webpack 有一个默认的扩展名列表用于解析，包括 `''`（空字符串）、`'.webpack.js'`、`'.web.js'`
    和 `'.js'`。我们需要将 `'.ts'` 添加到这个列表中，以便它能够识别 TypeScript 文件。
- en: Webpack will need to have `ts-loader` loading `.ts` modules because it does
    not compile TypeScript itself.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack 需要使用 `ts-loader` 加载 `.ts` 模块，因为它本身不编译 TypeScript。
- en: 'And here is the updated `webpack.config.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是更新后的 `webpack.config.js`:'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now execute the command `webpack` under the `client` folder again, we should
    get the compiled and bundled output as expected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次在 `client` 文件夹下执行 `webpack` 命令，我们应该得到预期的编译和打包输出。
- en: During development, we can enable *transpile mode* (corresponding to the compiler
    option `isolatedModules`) of TypeScript to have better performance on compiling
    changing files. But it means we'll need to rely on an IDE or an editor to provide
    error hints. And remember to make another compilation with transpile mode disabled
    after debugging to ensure things still work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间，我们可以启用 TypeScript 的 *转译模式*（对应于编译器的 `isolatedModules` 选项），以在编译更改文件时获得更好的性能。但这意味着我们需要依赖
    IDE 或编辑器来提供错误提示。并且记得在调试后禁用转译模式进行另一次编译，以确保一切仍然正常工作。
- en: 'To enable transpile mode, add a `ts` field (defined by the `ts-loader` plugin)
    with `transpileOnly` set to `true`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '要启用转译模式，添加一个 `ts` 字段（由 `ts-loader` 插件定义），并将 `transpileOnly` 设置为 `true`:'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Splitting code
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码拆分
- en: To take the advantage of code caching across pages, we might want to split the
    packaged modules as common pieces. The webpack provides a built-in plugin called
    `CommonsChunkPlugin` that can pick out common modules and have them packed separately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用跨页面的代码缓存，我们可能想要将打包的模块拆分为通用组件。webpack 提供了一个名为 `CommonsChunkPlugin` 的内置插件，可以提取公共模块并将它们单独打包。
- en: 'For example, if we create another file called `bar.ts` that imports `foo.ts`
    just like `index.ts` does, `foo.ts` can be treated as a common chunk and be packed
    separately:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建另一个名为 `bar.ts` 的文件，它像 `index.ts` 一样导入 `foo.ts`，则 `foo.ts` 可以被视为一个公共块并单独打包：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For multi-page applications, it is common to have different pages with different
    entry scripts. Instead of manually updating the `entry` field in the configuration
    file, we can take advantage of it being JavaScript and generate proper entries
    automatically. To do so, we might want the help of the npm package `glob` for
    matching page entries:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多页面应用程序，通常不同的页面有不同的入口脚本。我们不必手动更新配置文件中的 `entry` 字段，可以利用它是 JavaScript 的特性来自动生成适当的入口。为此，我们可能需要
    npm 包 `glob` 的帮助来匹配页面入口：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then update the webpack configuration file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新 webpack 配置文件：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Splitting the code can be rather a complex topic for deep dive, so we'll stop
    here and let you explore.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码拆分可能是一个相当复杂的深入主题，所以我们在这里停止，并让您去探索。
- en: Loading other static assets
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载其他静态资源
- en: As we've mentioned, webpack can also be used to load other static assets like
    stylesheet and its extensions. For example, you can use the combination of `style-loader`,
    `css-loader` and `sass-loader`/`less-loader` to load `.sass`/`.less` files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，webpack 还可以用来加载其他静态资源，如样式表及其扩展。例如，您可以使用 `style-loader`、`css-loader`
    和 `sass-loader`/`less-loader` 的组合来加载 `.sass`/`.less` 文件。
- en: 'The configuration is similar to `ts-loader` so we''ll not spend extra pages
    for their introductions. For more information, refer to the following URLs:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 配置与 `ts-loader` 类似，因此我们不会额外花费页面来介绍它们。更多信息，请参考以下网址：
- en: 'Embedded stylesheets in webpack: [https://webpack.github.io/docs/stylesheets.html](https://webpack.github.io/docs/stylesheets.html)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 中的嵌入式样式表：[https://webpack.github.io/docs/stylesheets.html](https://webpack.github.io/docs/stylesheets.html)
- en: 'SASS loader for webpack: [https://github.com/jtangelder/sass-loader](https://github.com/jtangelder/sass-loader)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 的 SASS 加载器：[https://github.com/jtangelder/sass-loader](https://github.com/jtangelder/sass-loader)
- en: 'LESS loader for webpack: [https://github.com/webpack/less-loader](https://github.com/webpack/less-loader)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 的 LESS 加载器：[https://github.com/webpack/less-loader](https://github.com/webpack/less-loader)
- en: Adding TSLint to projects
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 TSLint 添加到项目中
- en: A consistent code style is an important factor of code quality, and linters
    are our best friends when it comes to code styles (and they also helps with common
    mistakes). For TypeScript linting, TSLint is currently the simplest choice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的代码风格是代码质量的重要因素，当涉及到代码风格时，linters是我们的最佳拍档（它们也帮助我们避免常见的错误）。对于TypeScript的linting，TSLint目前是最佳选择。
- en: 'The installation and configuration of TSLint are easy. To begin with, let''s
    install `tslint` as a global command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: TSLint的安装和配置很简单。首先，让我们全局安装`tslint`命令：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then we need to initialize a configuration file using the following command
    under the project root directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在项目根目录下使用以下命令初始化一个配置文件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'TSLint will then generate a default configuration file named `tslint.json`,
    and you may customize it based on your own preferences. And now we can use it
    to lint our TypeScript source code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，TSLint将生成一个名为`tslint.json`的默认配置文件，你可以根据自己的喜好进行自定义。现在我们可以用它来检查我们的TypeScript源代码：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Integrating webpack and tslint command with npm scripts
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将webpack和tslint命令与npm脚本集成
- en: 'As we''ve mentioned before, an advantage of using npm scripts is that they
    can handle local packages with executables properly by adding `node_modules/.bin`
    to `PATH`. And to make our application easier to build and test for other developers,
    we can have `webpack` and `tslint` installed as development dependencies and add
    related scripts to `package.json`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用npm脚本的一个优点是它们可以通过将`node_modules/.bin`添加到`PATH`来正确处理带有可执行文件的本地包。为了使我们的应用程序更容易被其他开发者构建和测试，我们可以将`webpack`和`tslint`作为开发依赖项安装，并将相关的脚本添加到`package.json`中：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Version control
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: Thinking back to my senior high school days, I knew nothing about version control
    tools. The best thing I could do was to create a daily archive of my code on a
    USB disk. And yes I did lose one!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回想起我的高中时代，我对版本控制工具一无所知。我能做的最好的事情就是每天将我的代码存档到U盘上。是的，我确实丢失过一次！
- en: Nowadays, with the boom of version control tools like Git and the availabilities
    of multiple free services like GitHub and Visual Studio Team Services, managing
    code with version control tools has become a daily basis for every developer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着Git等版本控制工具的兴起以及GitHub和Visual Studio Team Services等多家免费服务的可用性，使用版本控制工具管理代码已经成为每个开发者的日常工作。
- en: As the most popular version control tool, Git has already been playing an important
    role in your work or personal projects. In this section, we'll talk about popular
    practices of using Git in a team.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最受欢迎的版本控制工具，Git已经在你的工作或个人项目中扮演着重要的角色。在本节中，我们将讨论在团队中使用Git的流行实践。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I am assuming that you already have the basic knowledge of Git, and
    know how to make operations like `init`, `commit`, `push`, `pull` and `merge`.
    If not, please get hands on and try to understand those operations before continue.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我假设你已经具备了Git的基本知识，并且知道如何进行`init`、`commit`、`push`、`pull`和`merge`等操作。如果不是这样，请在继续之前动手尝试理解这些操作。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Check out this quick tutorial at: [https://try.github.io/](https://try.github.io/).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看这个快速教程：[https://try.github.io/](https://try.github.io/)。
- en: Git flow
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git flow
- en: Version control plays an important a role and it does not only influence the
    source code management process but also shapes the entire workflow of product
    development and delivery. Thus a *successful* branching model becomes a serious
    choice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制扮演着非常重要的角色，它不仅影响源代码管理过程，还塑造了整个产品开发和交付的工作流程。因此，一个*成功*的分支模型成为一个严肃的选择。
- en: Git flow is a collection of Git extensions that provides high-level repository
    operations for a branching model raised by Vincent Driessen. The name *Git flow*
    usually refers to the branching model as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Git flow是一组Git扩展，它为Vincent Driessen提出的分支模型提供了高级的仓库操作。*Git flow*这个名字通常也指代分支模型。
- en: 'In this branching model, there are two main branches: `master` and `develop`,
    as well as three different types of supporting branches: `feature`, `hotfix` ,
    and `release`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分支模型中，有两个主要的分支：`master`和`develop`，以及三种不同类型的支持分支：`feature`、`hotfix`和`release`。
- en: 'With the help of Git flow extensions, we can easily apply this branching model
    without having to remember and type detailed sequences of commands. To install,
    please check out the installation guide of Git flow at: [https://github.com/nvie/gitflow/wiki/Installation](https://github.com/nvie/gitflow/wiki/Installation).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Git flow扩展的帮助下，我们可以轻松地应用这个分支模型，而无需记住和输入详细的命令序列。要安装，请查看Git flow的安装指南：[https://github.com/nvie/gitflow/wiki/Installation](https://github.com/nvie/gitflow/wiki/Installation)。
- en: 'Before we can use Git flow to create and merge branches, we''ll need to make
    an initialization:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用 Git flow 创建和合并分支之前，我们需要进行初始化：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here `-d` stands for using default branch naming conventions. If you would like
    to customize, you may omit the `-d` option and answer the questions about `git
    flow init` command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `-d` 表示使用默认的分支命名约定。如果您想自定义，可以省略 `-d` 选项并回答有关 `git flow init` 命令的问题。
- en: This will create `master` and `develop` branches (if not present) and save Git
    flow-related configuration to the local repository.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建（如果不存在）`master` 和 `develop` 分支，并将 Git flow 相关配置保存到本地仓库。
- en: Main branches
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主分支
- en: 'The branching model defines two main branches: `master` and `develop`. Those
    two branches exist in the lifetime of the current repository:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分支模型定义了两个主要分支：`master` 和 `develop`。这两个分支存在于当前仓库的生命周期中：
- en: '![Main branches](img/image_09_002-1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![主分支](img/image_09_002-1.jpg)'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The graph in the preceding shows a simplified relationship between `develop`
    and `master` branches.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了 `develop` 和 `master` 分支之间简化的关系。
- en: '**Branch master**: The *HEAD* of `master` branch should always contain production-ready
    source code. It means that no daily development is done on `master` branch in
    this branching model, and only commits that are fully tested and can be performed
    with a fast-forward should be merged into this branch.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支 master**：`master` 分支的 *HEAD* 应始终包含生产就绪的源代码。这意味着在这个分支模型中，`master` 分支上不进行日常开发，只有经过完全测试并且可以快速前向合并的提交才能合并到这个分支。'
- en: '**Branch develop**: The *HEAD* of `develop` branch should contain delivered
    development source code. Changes to `develop` branch will finally be merged into
    `master`, but usually not directly. We''ll come to that later when we talk about
    `release` branches.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支 develop**：`develop` 分支的 *HEAD* 应包含交付的开发源代码。对 `develop` 分支的更改最终将合并到 `master`，但通常不是直接合并。我们将在讨论
    `release` 分支时再详细说明。'
- en: Supporting branches
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持分支
- en: 'There are three types of supporting branches in the branching model of Git
    flow: `feature`, `hotfix`, and `release`. What they roughly do has already been
    suggested by their names, and we''ll have more details to follow.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git flow 的分支模型中，有三种类型的支持分支：`feature`、`hotfix` 和 `release`。它们大致的功能已经由它们的名字暗示，我们将在后续的细节中了解更多。
- en: Feature branches
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能分支
- en: A feature branch has only direct interactions with the `develop` branch, which
    means it checks out from a `develop` branch and merges back to a `develop` branch.
    The feature branches might be the simplest type of branches out of the three.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分支只与 `develop` 分支有直接交互，这意味着它从 `develop` 分支检出并合并回 `develop` 分支。功能分支可能是三种分支中最简单的一种。
- en: 'To create a feature branch with Git flow, simply execute the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Git flow 创建功能分支，只需执行以下命令：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now Git flow will automatically checkout a new branch named after `feature/<feature-name>`,
    and you are ready to start development and commit changes occasionally.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Git flow 将自动检出以 `feature/<feature-name>` 命名的新分支，您就可以开始开发和偶尔提交更改了。
- en: 'After completing feature development, Git flow can automatically merge things
    back to the `develop` branch by the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成功能开发后，Git flow 可以通过以下命令自动将内容合并回 `develop` 分支：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A feature branch is usually started by the developer who is assigned to the
    development of that very feature and is merged by the developer him or herself,
    or the owners of the `develop` branch (for example, if code review is required).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分支通常由被分配开发该特定功能的开发者启动，并由该开发者本人或 `develop` 分支的所有者（例如，如果需要代码审查）合并。
- en: Release branches
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发布分支
- en: In a single iteration of a product, after finishing the development of features,
    we usually need a stage for fully testing everything, fixing bugs, and actually
    getting it ready to be released. And work for this stage will be done on release
    branches.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品的单个迭代中，在完成功能开发后，我们通常需要一个阶段来全面测试一切、修复错误，并实际上准备好发布。这个阶段的工作将在发布分支上完成。
- en: 'Unlike feature branches, a repository usually has only one active release branch
    at a time, and it is usually created by the owner of the repository. When the
    development branch is reaching a state of release and a thorough test is about
    to begin, we can then create a release branch using the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能分支不同，一个仓库通常一次只有一个活跃的发布分支，并且通常由仓库所有者创建。当开发分支即将达到发布状态并且即将开始全面测试时，我们可以使用以下命令创建一个发布分支：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From now on, bug fixes that are going to be released in this iteration should
    be merged or committed to branch `release/<version>` and changes to the current
    `release` branch can be merged back to the `develop` branch anytime.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，本迭代将要发布的错误修复应该合并或提交到`release/<version>`分支，并且对当前`release`分支的更改可以随时合并回`develop`分支。
- en: 'If the test goes well and important bugs have been fixed, we can then finish
    this release and put it online:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试顺利并且重要错误已被修复，我们就可以完成这次发布并将其上线：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After executing this command, Git flow will merge the current release branch
    to both `master` and `develop` branches. So in a standard Git flow branching model,
    the `develop` branch will not be merged into the `master` directly, though after
    finishing a release, the content on `develop` and `master` branches could be identical
    (if no more changes are made to the `develop` branch during the releasing stage).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，Git flow会将当前发布分支合并到`master`和`develop`分支。所以在标准的Git flow分支模型中，`develop`分支不会直接合并到`master`，尽管在发布完成后，`develop`和`master`分支上的内容可能相同（如果在发布阶段没有对`develop`分支进行更多更改）。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Finishing the current release usually means the end of the iteration, and the
    decision should be made with serious consideration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成当前发布通常意味着迭代的结束，这个决定应该经过认真考虑。
- en: Hotfix branches
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: hotfix分支
- en: 'Unfortunately, there''s a phenomenon in the world of developers: bugs are always
    harder to find before the code goes live. After releasing, if serious bugs were
    found, we would have to use hotfixes to make things right.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在开发者的世界中存在一种现象：在代码上线之前，总是更难找到错误。发布后，如果发现了严重的错误，我们就必须使用hotfix来纠正问题。
- en: A `hotfix` branch works kind of like a release branch but lasts shorter (because
    you would probably want it merged as soon as possible). Unlike feature branches
    being checked out from `develop` branch, a `hotfix` branch is checked out from
    `master`. And after getting things done, it should be merged back to both `master`
    and `develop` branches, just like a release branch does.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`hotfix`分支有点像发布分支，但持续时间更短（因为你可能希望尽快将其合并）。与从`develop`分支检出功能分支不同，`hotfix`分支是从`master`分支检出的。完成工作后，它应该像发布分支一样合并回`master`和`develop`分支。'
- en: 'To create a `hotfix` branch, similarly you can execute the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`hotfix`分支，同样可以执行以下命令：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And to finish, execute the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行以下命令：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary of Git flow
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git flow总结
- en: The most valuable idea in Git flow beside the branching model itself is, in
    my opinion, the clear outline of one iteration. You may not need to follow every
    step mentioned thus far to use Git flow, but just make it fit your work. For example,
    for small features that can be done in a single commit, you might not actually
    need a feature branch. But conversely, Git flow might not bring much value if
    the iteration itself gets chaotic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Git flow中，除了分支模型本身之外，我认为最有价值的想法是，一个迭代的清晰概述。你可能不需要遵循迄今为止提到的每个步骤来使用Git flow，但只需让它适应你的工作。例如，对于可以在单个提交中完成的小功能，你可能实际上不需要一个功能分支。但相反，如果迭代本身变得混乱，Git
    flow可能不会带来太多价值。
- en: Pull request based code review
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于pull request的代码审查
- en: '**Code review** could be a very important joint of team cooperation. It ensures
    acceptable quality of the code itself and helps newcomers correct their misunderstanding
    of the project and accumulate experiences rapidly without taking a wrong path.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码审查**可能是团队合作中非常重要的环节。它确保代码本身的质量可接受，并帮助新成员纠正对项目的误解，快速积累经验而不会走错路。'
- en: If you have tried to contribute code to open-source projects on GitHub, you
    must be familiar with pull requests or PR. There are actually tools or IDEs with
    code reviewing workflow built-in. But with GitHub and other self-hosted services
    like GitLab, we can get it done smoothly without relying on specific tools.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试向GitHub上的开源项目贡献代码，你一定熟悉pull requests或PR。实际上有一些工具或IDE内置了代码审查工作流程。但使用GitHub和其他自托管的如GitLab服务，我们可以顺利完成任务，而不依赖于特定的工具。
- en: Configuring branch permissions
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置分支权限
- en: Restrictions on accessing specific branches like `master` and `develop` are
    not technically necessary. But without those restrictions, developers can easily
    skip code reviewing because they are just able to do so. In services provided
    by the Visual Studio Team Foundation Server, we may add a custom check in policy
    to force code review. But in lighter services like GitHub and GitLab, it might
    be harder to have similar functionality.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对`master`和`develop`等特定分支的访问限制在技术上不是必需的。但没有这些限制，开发者可以轻易地跳过代码审查，因为他们能够这样做。在Visual
    Studio Team Foundation Server提供的服务中，我们可以在策略中添加自定义检查来强制代码审查。但在GitHub和GitLab等较轻量级的服务中，可能更难实现类似的功能。
- en: The easiest way might be to have developers who are more qualified and familiar
    with the current project have the permissions for writing the `develop` branch,
    and restrict code reviewing in this group verbally. For other developers working
    on this project, pull requests are now forced for getting changes they merged.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法可能是让更合格且熟悉当前项目的开发者拥有写入`develop`分支的权限，并口头限制该组的代码审查。对于其他在此项目上工作的开发者，现在强制进行拉取请求以获取他们合并的更改。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GitHub requires an organization account to specify push permissions for branches.
    Besides this, GitHub provides a status API and can add restrictions to merging
    so that only branches with a valid status can get merged.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub要求指定分支的推送权限的组织账户。除此之外，GitHub提供状态API，可以添加合并限制，以便只有具有有效状态的分支才能合并。
- en: Comments and modifications before merge
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并前的评论和修改
- en: A great thing about those popular Git services is that the reviewer and maybe
    other colleagues of yours may comment on your pull requests or even specific lines
    of code to raise their concerns or suggestions. And accordingly, you can make
    modifications to the active pull request and make things a little bit closer to
    perfect.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那些流行的Git服务的一个好处是，审阅者以及可能的其他同事可以对您的拉取请求或甚至特定的代码行进行评论，以提出他们的关注或建议。相应地，您可以修改活动拉取请求，使事情更接近完美。
- en: Furthermore, references between issues and pull requests are shown in the conversation.
    This along with the comments and modification records makes the context of current
    pull requests clear and traceable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，问题与拉取请求之间的引用在对话中显示。这连同评论和修改记录一起，使当前拉取请求的上下文清晰且可追溯。
- en: Testing before commits
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交前的测试
- en: Ideally, we would expect every  commit we make to pass tests and code linting.
    But because we are human, we can easily forget about running tests before committing
    changes. And then, if we have already set up continuous integration (we'll come
    to that shortly) of this project, pushing the changes would make it red. And if
    your colleague has set up a CI light with an alarm, you would make it flash and
    sound out.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望我们做出的每个提交都能通过测试和代码检查。但因为我们都是人类，我们很容易忘记在提交更改之前运行测试。然后，如果我们已经设置了项目的持续集成（我们很快就会谈到），推送更改会使它变红。如果你的同事设置了带有警报的CI轻量级服务，你将使它闪烁并发出声音。
- en: To avoid breaking the build constantly, you might want to add a `pre-commit`
    hook to your local repository.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不断破坏构建，您可能希望向您的本地仓库添加一个`pre-commit`钩子。
- en: Git hooks
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git钩子
- en: Git provides varieties of hooks corresponding to specific phases of an operation
    or an event. After initializing a Git repository, Git will create hook samples
    under the directory `.git/hooks`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Git为操作或事件的特定阶段提供了各种钩子。在初始化Git仓库后，Git将在`.git/hooks`目录下创建钩子样本。
- en: 'Now let''s create the file `pre-commit` under the directory `.git/hooks` with
    the following content:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`.git/hooks`目录下创建一个名为`pre-commit`的文件，并包含以下内容：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The hook file does not have to be a bash file, and it can just be any executable.
    For example, if you want like to work with a Node.js hook, you can update the
    shebang as `#!/usr/bin/env node` and then write the hook in JavaScript.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子文件不一定要是bash文件，它可以是任何可执行文件。例如，如果你想使用Node.js钩子，你可以更新shebang为`#!/usr/bin/env
    node`，然后使用JavaScript编写钩子。
- en: And now Git will run tests before every commit of changes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Git将在每次提交更改之前运行测试。
- en: Adding pre-commit hook automatically
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动添加pre-commit钩子
- en: Adding hooks manually to the local repository could be trivial, but luckily
    we have npm packages like `pre-commit` that will add pre-commit hooks automatically
    when it's installed (as you usually might need to run `npm install` anyway).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将钩子手动添加到本地仓库可能很简单，但幸运的是，我们有像`pre-commit`这样的npm包，当安装时它会自动添加pre-commit钩子（因为您通常可能需要运行`npm
    install`）。
- en: 'To use the `pre-commit` package, just install it as a development dependency:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `pre-commit` 包，只需将其作为开发依赖项安装：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It will read your `package.json` and execute npm scripts listed with the field
    `pre-commit` or `precommit`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它将读取您的 `package.json` 并执行带有 `pre-commit` 或 `precommit` 字段的 npm 脚本：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, npm package `pre-commit` uses symbolic links to create
    Git hook, which requires administrator privileges on Windows. But failing to create
    a symbolic link won't stop the `npm install` command from completing. So if you
    are using Windows, you probably might want to ensure `pre-commit` is properly
    installed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，npm 包 `pre-commit` 使用符号链接创建 Git 钩子，这需要在 Windows 上具有管理员权限。但创建符号链接失败不会阻止
    `npm install` 命令完成。因此，如果你使用 Windows，你可能需要确保 `pre-commit` 正确安装。
- en: Continuous integration
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: The **continuous integration** (**CI**) refers to a practice of integrating
    multiple parts of a project or solution together regularly. Depending on the size
    of the project, the integration could be taken for every single change or on a
    timed schedule.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是指定期将项目或解决方案的多个部分集成在一起的做法。根据项目的大小，集成可以是每次单个更改或按时间表进行。'
- en: The main goal of continuous integration is to avoid integration issues, and
    it also enforces the discipline of frequent automated testing, this helps to find
    bugs earlier and prevents the degeneration of functionalities.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的主要目标是避免集成问题，它还强制执行频繁的自动化测试的纪律，这有助于更早地发现错误并防止功能的退化。
- en: There are many solutions or services with continuous integration support. For
    example, self-hosted services like TFS and Jenkins, or cloud-based services like
    Visual Studio Team Services, Travis-CI, and AppVeyor. We are going to walk through
    the basic configuration of Travis-CI with our demo project.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多具有持续集成支持的解决方案或服务。例如，自托管的 TFS 和 Jenkins 服务，或基于云的 Visual Studio Team Services、Travis-CI
    和 AppVeyor 服务。我们将通过我们的演示项目来介绍 Travis-CI 的基本配置。
- en: Connecting GitHub repository with Travis-CI
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 GitHub 仓库与 Travis-CI 连接
- en: 'We are going to use GitHub as the Git service behind continuous integration.
    First of all, let''s get our GitHub repository and Travis-CI settings ready:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GitHub 作为持续集成背后的 Git 服务。首先，让我们准备好我们的 GitHub 仓库和 Travis-CI 设置：
- en: 'Create a correspondent repository as origin and push the local repository to
    GitHub:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对应的远程仓库作为 origin，并将本地仓库推送到 GitHub：
- en: '[PRE28]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Sign into Travis-CI with your GitHub account at: [https://travis-ci.org/auth](https://travis-ci.org/auth).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的 GitHub 账户登录 Travis-CI：[https://travis-ci.org/auth](https://travis-ci.org/auth)。
- en: Go to the account page, find the project we are working with, and then flick
    the repository switch on.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往账户页面，找到我们正在工作的项目，然后切换到仓库。
- en: Now the only thing we need to make the continuous integration setup work is
    a proper Travis-CI configuration file. Travis-CI has built-in support for many
    languages and runtimes. It provides multiple versions of Node.js and makes it
    extremely easy to test Node.js projects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的唯一一件事是创建一个合适的 Travis-CI 配置文件，以使持续集成设置生效。Travis-CI 对许多语言和运行时提供了内置支持。它提供了多个版本的
    Node.js，使得测试 Node.js 项目变得极其简单。
- en: 'Create the file `.travis.yml` in the root of project with the following content:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建文件 `.travis.yml`，内容如下：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This configuration file tells Travis-CI to test with both Node.js v4 and v6,
    and execute the command `npm run build` before testing (it will run the `npm test`
    command automatically).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件告诉 Travis-CI 使用 Node.js v4 和 v6 进行测试，并在测试前执行命令 `npm run build`（它将自动运行 `npm
    test` 命令）。
- en: Almost ready! Now add and commit the new `.travis.yml` file and push it to `origin`.
    If everything goes well, we should see Travis-CI start the build of this project
    shortly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎准备好了！现在添加并提交新的 `.travis.yml` 文件，并将其推送到 `origin`。如果一切顺利，我们应该会看到 Travis-CI 短时间内开始构建此项目。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be seeing building status badges everywhere nowadays, and it''s easy
    to add one to the `README.md` of your own project. In the project page on Travis-CI,
    you should see a badge next to the project name. Copy its URL and add it to the
    `README.md` as an image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能到处都能看到构建状态徽章，并且很容易将其添加到自己的项目的 `README.md` 中。在 Travis-CI 的项目页面上，你应该会在项目名称旁边看到一个徽章。复制其
    URL 并将其作为图片添加到 `README.md` 中：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Deployment automation
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自动化
- en: Rather than a version control tool, Git is also popular for relatively simple
    deployment automation. And in this section, we'll get our hands on and configure
    automated deployment based on Git.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了版本控制工具外，Git 还因其相对简单的部署自动化而受到欢迎。在本节中，我们将动手配置基于 Git 的自动化部署。
- en: Passive deployment based on Git server side hooks
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 Git 服务器端钩子的被动部署
- en: 'The idea of passive deployment is simple: when a client pushes commits to the
    bare repository on the server, a `post-receive` hook of Git will be triggered.
    And thus we can add scripts checking out changes and start deployment.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 被动部署的想法很简单：当客户端将提交推送到服务器上的裸仓库时，Git 的 `post-receive` 钩子将被触发。因此，我们可以添加检查出更改并启动部署的脚本。
- en: 'The elements involved in the Git deployment solution on both the client and
    server sides includes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器端 Git 部署解决方案中涉及到的元素包括：
- en: '![Passive deployment based on Git server side hooks](img/image_09_003-1.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![基于 Git 服务器端钩子的被动部署](img/image_09_003-1.jpg)'
- en: 'To make this mechanism work, we need to perform the following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此机制工作，我们需要执行以下步骤：
- en: 'Create a bare repository on the server with the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在服务器上创建一个裸仓库：
- en: '[PRE31]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A bare repository usually has the extension `.git` and can be treated as a centralized
    place for sharing purposes. Unlike normal repositories, a bare repository does
    not have the working copy of source files, and its structure is quite similar
    to what's inside a `.git` directory of a normal repository.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个裸仓库通常具有 `.git` 扩展名，可以作为共享的集中式位置。与普通仓库不同，裸仓库没有源文件的副本，其结构与普通仓库的 `.git` 目录内部结构非常相似。
- en: 'Add `deployment.git` as a remote repository of our project, and try to push
    the `master` branch to the `deployment.git` repository:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `deployment.git` 添加为项目的远程仓库，并尝试将 `master` 分支推送到 `deployment.git` 仓库：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are adding a local bare repository as the remote repository in this example.
    Extra steps might be required to create real remote repositories.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本例中，我们将添加一个本地裸仓库作为远程仓库。创建真正的远程仓库可能需要额外的步骤。
- en: Add a `post-receive` hook for the `deployment.git` repository. We've already
    worked with the client side Git hook `pre-commit`, and the server side hooks work
    the same way.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `deployment.git` 仓库添加一个 `post-receive` 钩子。我们已经与客户端 Git 钩子 `pre-commit` 一起工作过，服务器端钩子的工作方式相同。
- en: But when it comes to a serious production deployment, how to write the hook
    could be a hard question to answer. For example, how do we minimize the impact
    of deploying new builds?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当涉及到严肃的生产部署时，如何编写钩子可能是一个难以回答的问题。例如，我们如何最小化部署新构建的影响？
- en: 'If we have set up our application with high availability load balancing, it
    might not be a big issue to have one of them offline for minutes. But certainly
    not all of them in this case. So here are some basic requirements of the deploy
    scripts on both the client and server sides:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经设置了具有高可用性负载均衡的应用程序，那么其中之一离线几分钟可能不是大问题。但当然，在这种情况下，不是所有这些都会离线。因此，以下是客户端和服务器端部署脚本的一些基本要求：
- en: The deployment should be proceeded in a certain sequence
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应按照一定的顺序进行
- en: The deployment should stop running services gently
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应温柔地停止运行服务
- en: 'And we can do better by:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式做得更好：
- en: Building outside of the previous deployment directory
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在之前的部署目录外构建
- en: Only trying to stop running services after the newly deployed application is
    ready to start immediately
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在新的部署应用准备好立即启动后，才尝试停止正在运行的服务
- en: Proactive deployment based on timers or notifications
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于定时器或通知的主动部署
- en: Instead of using Git hooks, we can have other tools pull and build the application
    automatically as well. In this way, we no longer need the client to push changes
    to servers separately. And instead, the program on the server will pull changes
    from a remote repository and complete deployment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其他工具自动拉取和构建应用程序，而不是使用 Git 钩子。这样，我们就不再需要客户端分别将更改推送到服务器。相反，服务器上的程序将从远程仓库拉取更改并完成部署。
- en: A notification mechanism is preferred to avoid frequent fetching though, and
    there are already tools like PM2 that have automated deployment built-in. You
    can also consider building up your own using hooks provided by cloud-based or
    self-hosted Git services.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然首选通知机制以避免频繁抓取，但已经存在像 PM2 这样的工具，它们内置了自动化部署。您也可以考虑使用基于云或自托管 Git 服务提供的钩子构建自己的工具。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we built the outline of a complete workflow starting
    with building and testing to continuous integration and automated deployment.
    We've covered some popular services or tools and provide other options for readers
    to discover and explore.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后，我们从构建和测试开始，构建了完整工作流程的概要，直到持续集成和自动化部署。我们介绍了一些流行的服务或工具，并为读者提供了其他发现和探索的选项。
- en: Among the varieties of choice, you might agree that the most appropriate workflow
    for your team is the workflow that fits the best. Taking people rather than technologies
    alone into consideration is an important part of software engineering, and it
    is also the key to keeping the team efficient (and happy, perhaps).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多选择中，你可能会同意最适合你团队的工作流程是那个最适合的工作流程。仅从人的角度而不是仅从技术角度考虑是软件工程的一个重要部分，这同样是保持团队高效（也许还有快乐）的关键。
- en: The sad thing about a team, or a crowd of people is that usually only a few
    of them can keep the passion burning. We’ve talked about finding the balance point,
    but that is what we still need to practice. And in most of the cases, expecting
    every one of your team to find the right point is just unreasonable. When it comes
    to team projects, we'd better have rules that can be validated automatically instead
    of conventions that are not testable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 团队或人群的悲哀之处在于，通常只有其中的一小部分人能够保持热情。我们谈论过寻找平衡点，但那正是我们需要练习的。在大多数情况下，期望团队中的每个人都找到正确的点是不切实际的。当涉及到团队项目时，我们最好有可以自动验证的规则，而不是不可测试的惯例。
- en: 'After reading this book, I hope the reader gets the outlines of the build steps,
    workflow, and of course knowledge of common design patterns. But rather than the
    cold explanations of different terms and patterns, there are more important ideas
    I wanted to deliver:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书之后，我希望读者能够了解构建步骤、工作流程的概要，以及当然的常见设计模式的知识。但与不同术语和模式的冷冰冰的解释相比，我更想传达一些更重要的想法：
- en: We as humans are dull, and should always keep our work divided as controllable
    pieces, instead of acting like a genius. And that's also why we need to *design*
    software to make our lives easier.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们作为人类是平凡的，应该始终将我们的工作划分为可控的部分，而不是像天才一样行事。这也是我们需要*设计*软件来使我们的生活更轻松的原因。
- en: And we are also unreliable, especially at a scale of some mass (like a team).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也并不可靠，尤其是在一些规模较大的集体（比如一个团队）中。
- en: As a learner, always try to understand the reason behind a conclusion or mechanism
    behind a phenomenon.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名学习者，始终尝试理解结论背后的原因或现象背后的机制。
