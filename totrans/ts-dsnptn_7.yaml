- en: Chapter 9. The Road to Enterprise Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After walking through common design patterns, we have now the basis of code
    designing. However, software engineering is more about writing beautiful code.
    While we are trying to keep the code healthy and robust, we still have a lot to
    do to keep the project and the team healthy, robust, and ready to scale. In this
    chapter, we'll talk about popular elements in the workflow of web applications,
    and how to design a workflow that fits your team.
  prefs: []
  type: TYPE_NORMAL
- en: The first part would be setting up the build steps of our demo project. We'll
    quickly walk through how to build frontend projects with *webpack*, one of the
    most popular packaging tools these days. And we'll configure tests, code linter,
    and then set up continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of nice choices when it comes to workflow integration. Personally,
    I prefer Team Foundation Server for private projects or a combination of GitHub
    and Travis-CI for open-source projects. While Team Foundation Server (or Visual
    Studio Team Services as its cloud-based version) provides a one-stop solution
    for the entire application life cycle, the combination of GitHub and Travis-CI
    is more popular in the JavaScript community. In this chapter, we are going use
    the services provided by GitHub and Travis-CI for our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are what we are going to walk through:'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging frontend assets with webpack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up tests and linter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting our hands on a Git flow branching model and other Git-related workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a GitHub repository with Travis-CI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A peek into automated deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about creating TypeScript applications for both frontend and backend
    projects in the [Chapter 1](ch01.html "Chapter 1. Tools and Frameworks"), *Tools
    and Frameworks*. And now we are going to create an application that contains two
    TypeScript projects at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Decision between SPA and "normal" web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications for different purposes result in different choices. SPA (single
    page application) usually delivers a better user experience after being loaded,
    but it can also lead to trade-offs on SEO and may rely on more complex MV* frameworks
    like Angular.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to build SEO-friendly SPA is to build a universal (or isomorphic)
    application that runs the *same* code on both frontend and backend, but that could
    introduce even more complexity. Or a reverse proxy could be configured to render
    automatically generated pages with the help of tools like *Phantom*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demo project, we''ll choose a more traditional web application with
    multiple pages to build. And here''s the file structure of the client project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decision between SPA and "normal" web applications](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taking team collaboration into consideration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we actually start creating a real-world application, we need to come
    up with a reasonable application structure. A proper application structure is
    more than something under which the code compiles and runs. It should be a result,
    taking how your team members work together into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a naming convention is involved in this demo client structure
    shown earlier: page assets are named after page names instead of their types (for
    example, `style.scss`) or names like `index.ts`. And the consideration behind
    this convention is making it more friendly for file navigation by the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this consideration is valid only if a significant number of developers
    in your team are cool with keyboard navigation. Other than operation preferences,
    the experiences and backgrounds of a team should be seriously considered as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Should the "full-stack" mode be enabled for your team?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should the "full-stack" mode be enabled for every engineer in your team?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should you divide work between frontend and backend?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, it's not necessary and not efficient to limit the access of a frontend
    engineer to client-side development. If it's possible, frontend engineers could
    take over the controller layer of the backend and leave hardcore business models
    and logic to engineers that focus more on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: We are having the client and server-side projects in the same repository for
    an easier integration during development. But it does not mean everything in the
    frontend or backend code base should be in this single repository. Instead, multiple
    modules could be extracted and maintained by different developers in practice.
    For example, you can have database models and business logic models separated
    from the controllers on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already talked about building and testing TypeScript projects at the
    beginning of this book. In this section, we will go a little bit further for frontend
    projects, including the basis of using Webpack to load static assets as well as
    **code linting**.
  prefs: []
  type: TYPE_NORMAL
- en: Static assets packaging with webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modularizing helps code keep a healthy structure and makes it maintainable.
    However, it could lead to performance issues if development-time code written
    in *small* modules are directly deployed without bundling for production usage.
    So static assets packaging becomes a serious topic of frontend engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the old days, packaging JavaScript files was just about *uglifying*
    source code and concatenating files together. The project might be modularized
    as well, but in a *global* way. Then we have libraries like Require.js, with modules
    no longer automatically exposing themselves to the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: But as I have mentioned, having the client download module files separately
    is not ideal for performance; soon we had tools like browserify, and later, webpack
    - one of the most popular frontend packaging tools these days.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to webpack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Webpack is an integrated packaging tool dedicated (at least at the beginning)
    to frontend projects. It is designed to package not only JavaScript, but also
    other static assets in a frontend project. Webpack provides built-in support for
    both **asynchronous module definition** (**AMD**) and commonjs, and can load ES6
    or other types of resources via plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES6 module support will get built-in for webpack 2.0, but by the time this chapter
    is written, you still need plugins like `babel-loader` or `ts-loader` to make
    it work. And of course we are going to use `ts-loader` later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install webpack via `npm`, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Bundling JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we actually use webpack to load TypeScript files, we'll have a quick
    walk through of bundling JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the file `index.js` under the directory `client/src/`
    with the following code inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the file `foo.js` in the same folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can have them bundled as a single file using the webpack command-line
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By viewing the `bundle.js` file generated by webpack, you will see that the
    contents of both `index.js` and `foo.js` have been wrapped into that single file,
    together with the bootstrap code of webpack. Of course, we would prefer not to
    type those file paths in the command line every time, but to use a configuration
    file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack provides configuration file support in the form of JavaScript files,
    which makes it more flexible to generate necessary data like bundle entries automatically.
    Let's create a simple configuration file that does what the previous command did.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create file `client/webpack.config.js` with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the two things to mention:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `entry` field is not the filename, but the *module id* (most
    of the time this is unresolved) instead. This means that you can have the `.js`
    extension omitted, but have to prefix it with `./` or `../` by default when referencing
    a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output path is required to be absolute. Building an absolute path with `__dirname`
    ensures it works properly if we are not executing webpack under the same directory
    as the configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are going to load and transpile our beloved TypeScript using the webpack
    plugin `ts-loader`. Before updating the configuration, let''s install the necessary
    npm packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If things go well, you should have the TypeScript compiler as well as the `ts-loader`
    plugin installed locally. We may also want to rename and update the files `index.js`
    and `foo.js` to TypeScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename `index.js` to `index.ts` and update the module importing syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Rename `foo.js` to `foo.ts` and update the module exporting syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we would want to add the `tsconfig.json` file for those TypeScript
    files (in the folder `client`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler option `outDir` is omitted here because it is managed in the webpack
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make webpack work with TypeScript via `ts-loader`, we''ll need to tell webpack
    some information in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: Webpack will need to resolve files with `.ts` extensions. Webpack has a default
    extensions list to resolve, including `''` (empty string), `'.webpack.js'`, `'.web.js'`,
    and `'.js'`. We need to add `'.ts'` to this list for it to recognize TypeScript
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Webpack will need to have `ts-loader` loading `.ts` modules because it does
    not compile TypeScript itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here is the updated `webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now execute the command `webpack` under the `client` folder again, we should
    get the compiled and bundled output as expected.
  prefs: []
  type: TYPE_NORMAL
- en: During development, we can enable *transpile mode* (corresponding to the compiler
    option `isolatedModules`) of TypeScript to have better performance on compiling
    changing files. But it means we'll need to rely on an IDE or an editor to provide
    error hints. And remember to make another compilation with transpile mode disabled
    after debugging to ensure things still work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable transpile mode, add a `ts` field (defined by the `ts-loader` plugin)
    with `transpileOnly` set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Splitting code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To take the advantage of code caching across pages, we might want to split the
    packaged modules as common pieces. The webpack provides a built-in plugin called
    `CommonsChunkPlugin` that can pick out common modules and have them packed separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we create another file called `bar.ts` that imports `foo.ts`
    just like `index.ts` does, `foo.ts` can be treated as a common chunk and be packed
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For multi-page applications, it is common to have different pages with different
    entry scripts. Instead of manually updating the `entry` field in the configuration
    file, we can take advantage of it being JavaScript and generate proper entries
    automatically. To do so, we might want the help of the npm package `glob` for
    matching page entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And then update the webpack configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Splitting the code can be rather a complex topic for deep dive, so we'll stop
    here and let you explore.
  prefs: []
  type: TYPE_NORMAL
- en: Loading other static assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've mentioned, webpack can also be used to load other static assets like
    stylesheet and its extensions. For example, you can use the combination of `style-loader`,
    `css-loader` and `sass-loader`/`less-loader` to load `.sass`/`.less` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration is similar to `ts-loader` so we''ll not spend extra pages
    for their introductions. For more information, refer to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Embedded stylesheets in webpack: [https://webpack.github.io/docs/stylesheets.html](https://webpack.github.io/docs/stylesheets.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SASS loader for webpack: [https://github.com/jtangelder/sass-loader](https://github.com/jtangelder/sass-loader)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LESS loader for webpack: [https://github.com/webpack/less-loader](https://github.com/webpack/less-loader)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding TSLint to projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A consistent code style is an important factor of code quality, and linters
    are our best friends when it comes to code styles (and they also helps with common
    mistakes). For TypeScript linting, TSLint is currently the simplest choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation and configuration of TSLint are easy. To begin with, let''s
    install `tslint` as a global command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we need to initialize a configuration file using the following command
    under the project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'TSLint will then generate a default configuration file named `tslint.json`,
    and you may customize it based on your own preferences. And now we can use it
    to lint our TypeScript source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Integrating webpack and tslint command with npm scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve mentioned before, an advantage of using npm scripts is that they
    can handle local packages with executables properly by adding `node_modules/.bin`
    to `PATH`. And to make our application easier to build and test for other developers,
    we can have `webpack` and `tslint` installed as development dependencies and add
    related scripts to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thinking back to my senior high school days, I knew nothing about version control
    tools. The best thing I could do was to create a daily archive of my code on a
    USB disk. And yes I did lose one!
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, with the boom of version control tools like Git and the availabilities
    of multiple free services like GitHub and Visual Studio Team Services, managing
    code with version control tools has become a daily basis for every developer.
  prefs: []
  type: TYPE_NORMAL
- en: As the most popular version control tool, Git has already been playing an important
    role in your work or personal projects. In this section, we'll talk about popular
    practices of using Git in a team.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that I am assuming that you already have the basic knowledge of Git, and
    know how to make operations like `init`, `commit`, `push`, `pull` and `merge`.
    If not, please get hands on and try to understand those operations before continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out this quick tutorial at: [https://try.github.io/](https://try.github.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: Git flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Version control plays an important a role and it does not only influence the
    source code management process but also shapes the entire workflow of product
    development and delivery. Thus a *successful* branching model becomes a serious
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Git flow is a collection of Git extensions that provides high-level repository
    operations for a branching model raised by Vincent Driessen. The name *Git flow*
    usually refers to the branching model as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this branching model, there are two main branches: `master` and `develop`,
    as well as three different types of supporting branches: `feature`, `hotfix` ,
    and `release`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of Git flow extensions, we can easily apply this branching model
    without having to remember and type detailed sequences of commands. To install,
    please check out the installation guide of Git flow at: [https://github.com/nvie/gitflow/wiki/Installation](https://github.com/nvie/gitflow/wiki/Installation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use Git flow to create and merge branches, we''ll need to make
    an initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here `-d` stands for using default branch naming conventions. If you would like
    to customize, you may omit the `-d` option and answer the questions about `git
    flow init` command.
  prefs: []
  type: TYPE_NORMAL
- en: This will create `master` and `develop` branches (if not present) and save Git
    flow-related configuration to the local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Main branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The branching model defines two main branches: `master` and `develop`. Those
    two branches exist in the lifetime of the current repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Main branches](img/image_09_002-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graph in the preceding shows a simplified relationship between `develop`
    and `master` branches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Branch master**: The *HEAD* of `master` branch should always contain production-ready
    source code. It means that no daily development is done on `master` branch in
    this branching model, and only commits that are fully tested and can be performed
    with a fast-forward should be merged into this branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch develop**: The *HEAD* of `develop` branch should contain delivered
    development source code. Changes to `develop` branch will finally be merged into
    `master`, but usually not directly. We''ll come to that later when we talk about
    `release` branches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three types of supporting branches in the branching model of Git
    flow: `feature`, `hotfix`, and `release`. What they roughly do has already been
    suggested by their names, and we''ll have more details to follow.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature branches
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A feature branch has only direct interactions with the `develop` branch, which
    means it checks out from a `develop` branch and merges back to a `develop` branch.
    The feature branches might be the simplest type of branches out of the three.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a feature branch with Git flow, simply execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now Git flow will automatically checkout a new branch named after `feature/<feature-name>`,
    and you are ready to start development and commit changes occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing feature development, Git flow can automatically merge things
    back to the `develop` branch by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A feature branch is usually started by the developer who is assigned to the
    development of that very feature and is merged by the developer him or herself,
    or the owners of the `develop` branch (for example, if code review is required).
  prefs: []
  type: TYPE_NORMAL
- en: Release branches
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a single iteration of a product, after finishing the development of features,
    we usually need a stage for fully testing everything, fixing bugs, and actually
    getting it ready to be released. And work for this stage will be done on release
    branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike feature branches, a repository usually has only one active release branch
    at a time, and it is usually created by the owner of the repository. When the
    development branch is reaching a state of release and a thorough test is about
    to begin, we can then create a release branch using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From now on, bug fixes that are going to be released in this iteration should
    be merged or committed to branch `release/<version>` and changes to the current
    `release` branch can be merged back to the `develop` branch anytime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the test goes well and important bugs have been fixed, we can then finish
    this release and put it online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After executing this command, Git flow will merge the current release branch
    to both `master` and `develop` branches. So in a standard Git flow branching model,
    the `develop` branch will not be merged into the `master` directly, though after
    finishing a release, the content on `develop` and `master` branches could be identical
    (if no more changes are made to the `develop` branch during the releasing stage).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finishing the current release usually means the end of the iteration, and the
    decision should be made with serious consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Hotfix branches
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, there''s a phenomenon in the world of developers: bugs are always
    harder to find before the code goes live. After releasing, if serious bugs were
    found, we would have to use hotfixes to make things right.'
  prefs: []
  type: TYPE_NORMAL
- en: A `hotfix` branch works kind of like a release branch but lasts shorter (because
    you would probably want it merged as soon as possible). Unlike feature branches
    being checked out from `develop` branch, a `hotfix` branch is checked out from
    `master`. And after getting things done, it should be merged back to both `master`
    and `develop` branches, just like a release branch does.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `hotfix` branch, similarly you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And to finish, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary of Git flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most valuable idea in Git flow beside the branching model itself is, in
    my opinion, the clear outline of one iteration. You may not need to follow every
    step mentioned thus far to use Git flow, but just make it fit your work. For example,
    for small features that can be done in a single commit, you might not actually
    need a feature branch. But conversely, Git flow might not bring much value if
    the iteration itself gets chaotic.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request based code review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Code review** could be a very important joint of team cooperation. It ensures
    acceptable quality of the code itself and helps newcomers correct their misunderstanding
    of the project and accumulate experiences rapidly without taking a wrong path.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have tried to contribute code to open-source projects on GitHub, you
    must be familiar with pull requests or PR. There are actually tools or IDEs with
    code reviewing workflow built-in. But with GitHub and other self-hosted services
    like GitLab, we can get it done smoothly without relying on specific tools.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring branch permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Restrictions on accessing specific branches like `master` and `develop` are
    not technically necessary. But without those restrictions, developers can easily
    skip code reviewing because they are just able to do so. In services provided
    by the Visual Studio Team Foundation Server, we may add a custom check in policy
    to force code review. But in lighter services like GitHub and GitLab, it might
    be harder to have similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way might be to have developers who are more qualified and familiar
    with the current project have the permissions for writing the `develop` branch,
    and restrict code reviewing in this group verbally. For other developers working
    on this project, pull requests are now forced for getting changes they merged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub requires an organization account to specify push permissions for branches.
    Besides this, GitHub provides a status API and can add restrictions to merging
    so that only branches with a valid status can get merged.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and modifications before merge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great thing about those popular Git services is that the reviewer and maybe
    other colleagues of yours may comment on your pull requests or even specific lines
    of code to raise their concerns or suggestions. And accordingly, you can make
    modifications to the active pull request and make things a little bit closer to
    perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, references between issues and pull requests are shown in the conversation.
    This along with the comments and modification records makes the context of current
    pull requests clear and traceable.
  prefs: []
  type: TYPE_NORMAL
- en: Testing before commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, we would expect every  commit we make to pass tests and code linting.
    But because we are human, we can easily forget about running tests before committing
    changes. And then, if we have already set up continuous integration (we'll come
    to that shortly) of this project, pushing the changes would make it red. And if
    your colleague has set up a CI light with an alarm, you would make it flash and
    sound out.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid breaking the build constantly, you might want to add a `pre-commit`
    hook to your local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git provides varieties of hooks corresponding to specific phases of an operation
    or an event. After initializing a Git repository, Git will create hook samples
    under the directory `.git/hooks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the file `pre-commit` under the directory `.git/hooks` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hook file does not have to be a bash file, and it can just be any executable.
    For example, if you want like to work with a Node.js hook, you can update the
    shebang as `#!/usr/bin/env node` and then write the hook in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: And now Git will run tests before every commit of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pre-commit hook automatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding hooks manually to the local repository could be trivial, but luckily
    we have npm packages like `pre-commit` that will add pre-commit hooks automatically
    when it's installed (as you usually might need to run `npm install` anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `pre-commit` package, just install it as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will read your `package.json` and execute npm scripts listed with the field
    `pre-commit` or `precommit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, npm package `pre-commit` uses symbolic links to create
    Git hook, which requires administrator privileges on Windows. But failing to create
    a symbolic link won't stop the `npm install` command from completing. So if you
    are using Windows, you probably might want to ensure `pre-commit` is properly
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **continuous integration** (**CI**) refers to a practice of integrating
    multiple parts of a project or solution together regularly. Depending on the size
    of the project, the integration could be taken for every single change or on a
    timed schedule.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of continuous integration is to avoid integration issues, and
    it also enforces the discipline of frequent automated testing, this helps to find
    bugs earlier and prevents the degeneration of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: There are many solutions or services with continuous integration support. For
    example, self-hosted services like TFS and Jenkins, or cloud-based services like
    Visual Studio Team Services, Travis-CI, and AppVeyor. We are going to walk through
    the basic configuration of Travis-CI with our demo project.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting GitHub repository with Travis-CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use GitHub as the Git service behind continuous integration.
    First of all, let''s get our GitHub repository and Travis-CI settings ready:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a correspondent repository as origin and push the local repository to
    GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sign into Travis-CI with your GitHub account at: [https://travis-ci.org/auth](https://travis-ci.org/auth).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the account page, find the project we are working with, and then flick
    the repository switch on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the only thing we need to make the continuous integration setup work is
    a proper Travis-CI configuration file. Travis-CI has built-in support for many
    languages and runtimes. It provides multiple versions of Node.js and makes it
    extremely easy to test Node.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `.travis.yml` in the root of project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file tells Travis-CI to test with both Node.js v4 and v6,
    and execute the command `npm run build` before testing (it will run the `npm test`
    command automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Almost ready! Now add and commit the new `.travis.yml` file and push it to `origin`.
    If everything goes well, we should see Travis-CI start the build of this project
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be seeing building status badges everywhere nowadays, and it''s easy
    to add one to the `README.md` of your own project. In the project page on Travis-CI,
    you should see a badge next to the project name. Copy its URL and add it to the
    `README.md` as an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Deployment automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than a version control tool, Git is also popular for relatively simple
    deployment automation. And in this section, we'll get our hands on and configure
    automated deployment based on Git.
  prefs: []
  type: TYPE_NORMAL
- en: Passive deployment based on Git server side hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of passive deployment is simple: when a client pushes commits to the
    bare repository on the server, a `post-receive` hook of Git will be triggered.
    And thus we can add scripts checking out changes and start deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements involved in the Git deployment solution on both the client and
    server sides includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passive deployment based on Git server side hooks](img/image_09_003-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make this mechanism work, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a bare repository on the server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A bare repository usually has the extension `.git` and can be treated as a centralized
    place for sharing purposes. Unlike normal repositories, a bare repository does
    not have the working copy of source files, and its structure is quite similar
    to what's inside a `.git` directory of a normal repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add `deployment.git` as a remote repository of our project, and try to push
    the `master` branch to the `deployment.git` repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We are adding a local bare repository as the remote repository in this example.
    Extra steps might be required to create real remote repositories.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a `post-receive` hook for the `deployment.git` repository. We've already
    worked with the client side Git hook `pre-commit`, and the server side hooks work
    the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But when it comes to a serious production deployment, how to write the hook
    could be a hard question to answer. For example, how do we minimize the impact
    of deploying new builds?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have set up our application with high availability load balancing, it
    might not be a big issue to have one of them offline for minutes. But certainly
    not all of them in this case. So here are some basic requirements of the deploy
    scripts on both the client and server sides:'
  prefs: []
  type: TYPE_NORMAL
- en: The deployment should be proceeded in a certain sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment should stop running services gently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And we can do better by:'
  prefs: []
  type: TYPE_NORMAL
- en: Building outside of the previous deployment directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only trying to stop running services after the newly deployed application is
    ready to start immediately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proactive deployment based on timers or notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using Git hooks, we can have other tools pull and build the application
    automatically as well. In this way, we no longer need the client to push changes
    to servers separately. And instead, the program on the server will pull changes
    from a remote repository and complete deployment.
  prefs: []
  type: TYPE_NORMAL
- en: A notification mechanism is preferred to avoid frequent fetching though, and
    there are already tools like PM2 that have automated deployment built-in. You
    can also consider building up your own using hooks provided by cloud-based or
    self-hosted Git services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we built the outline of a complete workflow starting
    with building and testing to continuous integration and automated deployment.
    We've covered some popular services or tools and provide other options for readers
    to discover and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Among the varieties of choice, you might agree that the most appropriate workflow
    for your team is the workflow that fits the best. Taking people rather than technologies
    alone into consideration is an important part of software engineering, and it
    is also the key to keeping the team efficient (and happy, perhaps).
  prefs: []
  type: TYPE_NORMAL
- en: The sad thing about a team, or a crowd of people is that usually only a few
    of them can keep the passion burning. We’ve talked about finding the balance point,
    but that is what we still need to practice. And in most of the cases, expecting
    every one of your team to find the right point is just unreasonable. When it comes
    to team projects, we'd better have rules that can be validated automatically instead
    of conventions that are not testable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this book, I hope the reader gets the outlines of the build steps,
    workflow, and of course knowledge of common design patterns. But rather than the
    cold explanations of different terms and patterns, there are more important ideas
    I wanted to deliver:'
  prefs: []
  type: TYPE_NORMAL
- en: We as humans are dull, and should always keep our work divided as controllable
    pieces, instead of acting like a genius. And that's also why we need to *design*
    software to make our lives easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And we are also unreliable, especially at a scale of some mass (like a team).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a learner, always try to understand the reason behind a conclusion or mechanism
    behind a phenomenon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
