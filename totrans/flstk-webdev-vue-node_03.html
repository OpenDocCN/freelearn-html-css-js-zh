<html><head></head><body>
        

                            
                    <h1 class="header-title">Introducing MongoDB</h1>
                
            
            
                
<p>The name MongoDB comes from the phrase huMONGOus data, meaning that it can handle a lot of data. MongoDB is a document-oriented database architecture. It enables us to develop faster and scale better. In relational database designs, we store data by creating tables and rows, but with MongoDB, we can model our data as JSON documents, which is much simpler compared to those relational databases. If we are agile and our requirements keep changing very often, and if we need to do continuous deployment, then MongoDB is our choice. Being a document-based data model, MongoDB is very flexible as well. </p>
<p>The biggest advantage of using MongoDB is that the data is unstructured. We can customize our data in any format we like. In a <strong>relational database management system</strong> (<strong>RDBMS</strong>), we have to define exactly the number of fields a table can have, but with MongoDB, each document can have its own number of fields. We can add new data without even having to worry about changing the schema, which is why Mongo has a <strong>schemaless design model</strong> for the database.</p>
<p>If our business is growing fast, we need to scale faster, we need to access data in a more flexible way, and if we need to make changes to our data without having to worry about updating our application's database schemas, then MongoDB is the best choice for us. Adding new columns to tables in RDBMS also creates some performance issues. But, since MongoDB is schemaless, adding new fields is done in an instant without compromising the performance of our application.</p>
<p>In a relational database, the terminologies that we use are <strong>database</strong>, <strong>tables</strong>, and <strong>rows</strong>, whereas in MongoDB, we use <strong>database</strong>, <strong>collections</strong>, and <strong>documents</strong>, respectively.</p>
<p>Here is a brief summary of what we will be covering in this chapter:</p>
<ul>
<li>Introducing to MongoDB and the benefits of using MongoDB</li>
<li>Understanding the MongoDB database, collections, and documents</li>
<li>Introducing to Mongoose, creating a connection with Mongoose, understanding Mongoose, and CRUD operations with Mongoose</li>
<li>Adding default and custom validations with Mongoose</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Why MongoDB?</h1>
                
            
            
                
<p>MongoDB provides a lot of advantages, some of which are:</p>
<ul>
<li><strong>Flexible documents</strong>: A MongoDB collection holds several documents. Each document under one collection can have variable field names and can have a different size as well, which means we don't have to define the schema.</li>
<li><strong>No complex relationships</strong>: The documents in MongoDB are stored as JSON documents, which means we no longer have to scratch our head learning about the relationships between various components of the application.</li>
<li><strong>Easy to scale</strong>: MongoDB is easy to scale as it minimizes the database size by using a partitioning method called sharding. Sharding is a database partitioning method that allows us to segregate a large database into smaller pieces.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">MongoDB queries</h1>
                
            
            
                
<p>We did quickly review what Mongo queries look like in <a href="d95a8844-6413-49ed-8d4a-9607cb550211.xhtml">Chapter 1</a>, <em>Introduction to MEVN</em>. Here, we will dive deep into these queries.</p>
<p>The first thing we need to do is start the MongoDB server. We can do that with this command:</p>
<pre><strong>$ mongod</strong></pre>
<p>Now, let's open the mongo shell by typing <kbd>mongo</kbd> in our Terminal. When we enter the mongo shell, to display the list of databases, we type <kbd>show dbs</kbd>.</p>
<p>If you see the database in the list, type <kbd>use {database_name}</kbd> to start using this database. If we haven't created our database yet, just using <kbd>use {database_name}</kbd> will create a database for us. It's as simple as that. For this exercise, let's create a database called <kbd>mongo_test_queries</kbd>. So for that, we need to use:</p>
<pre><strong>&gt; use mongo_test_queries</strong></pre>
<p>This should output the following in the Terminal:</p>
<pre><strong># switched to db mongo_test_queries</strong></pre>
<p>Now, once we enter the database, the first thing that we need is a collection. We have a database but there are no collections. The best way to create a collection in MongoDB is by inserting a document. This not only initializes a collection but also adds the document to that collection. Simple as that. Now, let's move on to Mongo queries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating documents</h1>
                
            
            
                
<p>There are different queries to create a document in MongoDB, such as <kbd>insertOne()</kbd>, <kbd>insertMany()</kbd>, and <kbd>insert()</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">insertOne()</h1>
                
            
            
                
<p>The <kbd>insertOne()</kbd> command adds a single document to our collection. For example:</p>
<pre><strong>&gt; db.users.insertOne(</strong><br/><strong>    {</strong><br/><strong>        name: "Brooke",</strong><br/><strong>        email: "brooke@app.com",</strong><br/><strong>        address: 'Kathmandu'</strong><br/><strong>    }</strong><br/><strong>)</strong></pre>
<p>This command takes only a single parameter, which is an object, and we can pass the field names and values we want for our <kbd>users</kbd> collection. When we run the preceding code in our Terminal inside the Mongo shell, we should get the following output:</p>
<div><img src="img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png" style="width:47.75em;height:17.67em;"/></div>
<p>It returns the <kbd>_id</kbd> of the document that just got created. We have successfully created a collection and a document in the <kbd>users</kbd> collection.</p>
<p>The <kbd>insertOne()</kbd> and <kbd>insertMany()</kbd> commands only work for Mongo version 3.2 or higher.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">insertMany()</h1>
                
            
            
                
<p>This command is used for inserting multiple documents into a collection. In the preceding example, we saw that the <kbd>insertOne()</kbd> command takes an argument that is an object. The <kbd>insertMany()</kbd> command takes an array as a parameter so that we can pass multiple objects inside it and insert multiple documents in the collection. Let's look at an example:</p>
<pre><strong>&gt; db.users.insertMany(</strong><br/><strong>  [</strong><br/><strong>    { name: "Jack", email: "jack@mongo.com" },</strong><br/><strong>    { name: "John", email: "john@mongo.com" },</strong><br/><strong>    { name: "Peter", email: "peter@mongo.com" }</strong><br/><strong>  ]</strong><br/><strong>)</strong></pre>
<p>This snippet creates three documents in the <kbd>users</kbd> collection. When we run the command, the output should be:</p>
<div><img src="img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png" style="width:50.08em;height:23.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">insert()</h1>
                
            
            
                
<p>This command inserts single as well as multiple documents into a collection. It does the job of both the <kbd>insertOne()</kbd> and the <kbd>insertMany()</kbd> commands. To insert a single document, we can use:</p>
<pre>&gt; db.users.insert(<br/>    { name: "Mike", email: "mike@mongo.com" }<br/>)</pre>
<p>If the command is executed successfully, we should see the following output:</p>
<div><img src="img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png" style="width:54.67em;height:11.17em;"/></div>
<p>Now, if we want to insert multiple documents, we can simply use:</p>
<pre>&gt; db.users.insert(<br/>  [<br/>    { name: "Josh", email: "josh@mongo.com" },<br/>    { name: "Ross", email: "ross@mongo.com" },<br/>  ]<br/>)</pre>
<p>The output should be as follows:</p>
<div><img src="img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png" style="width:51.00em;height:25.08em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving documents</h1>
                
            
            
                
<p>Retrieving documents from collections in MongoDB is done using the <kbd>find()</kbd> command. There are many ways to use this command. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding all documents</h1>
                
            
            
                
<p>To retrieve all documents from a collection, we can use:</p>
<pre><strong>&gt; db.users.find()</strong></pre>
<p>We can also use the following:</p>
<pre><strong>&gt; db.users.find({})</strong></pre>
<p>This outputs the following:</p>
<div><img src="img/493ba105-c15e-4001-bec1-5c33c473e5e8.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding documents via filters</h1>
                
            
            
                
<p>We can add filters to the <kbd>find()</kbd> command as well. Let's retrieve documents with the name  <kbd>Mike</kbd>. For that, we can use:</p>
<pre><strong>&gt; db.users.find({ name: 'Mike' })</strong></pre>
<p>It should return a document with the following:</p>
<div><img src="img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png" style="width:54.83em;height:9.00em;"/></div>
<p>We can also specify multiple conditions with <kbd>AND</kbd> or <kbd>OR</kbd> queries.</p>
<p>To find a collection with the name <kbd>Mike</kbd> and the email <kbd>mike@mongo.com</kbd>, we can simply use:</p>
<pre><strong>&gt; db.users.find({ name: 'Mike', email: 'mike@mongo.com' })</strong></pre>
<p>The comma operator means an <kbd>AND</kbd> operator. We can specify as many conditions as we like with comma-separated values. The preceding command should output:</p>
<div><img src="img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png" style="width:50.00em;height:8.00em;"/></div>
<p>Now, specifying conditions with <kbd>AND</kbd> or comma operators is simple. If we want to use the OR operator, then we should use:</p>
<pre><strong>&gt; db.users.find(</strong><br/><strong> {</strong><br/><strong>   $or: [ { email: "josh@mongo.com" }, { name: "Mike" } ]</strong><br/><strong> }</strong><br/><strong>)</strong></pre>
<p>Here, we are saying: retrieve those documents for users whose name is Mike, and the email can be <kbd>josh@mongo.com</kbd> as well. The output is as follows:</p>
<div><img class="alignnone size-full wp-image-440 image-border" src="img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png" style="width:49.08em;height:9.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating documents</h1>
                
            
            
                
<p>Just like <kbd>insert()</kbd>, there are three methods of using the <kbd>update()</kbd> command in MongoDB: <kbd>updateOne()</kbd>, <kbd>updateMany()</kbd>, and <kbd>update()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">updateOne()</h1>
                
            
            
                
<p>This command updates only a single document in the collection. Here, we have inserted a couple of user entries with the incorrect emails. For the user with the name <kbd>Peter</kbd>, the email is <kbd>jack@mongo.com</kbd>. Let's update this document using <kbd>updateOne()</kbd>:</p>
<pre><strong>&gt; db.users.updateOne(</strong><br/><strong>  { "name": "Peter" },</strong><br/><strong>  {</strong><br/><strong>    $set: { "email": "peter@mongo.com" }</strong><br/><strong>  }</strong><br/><strong> )</strong></pre>
<p>This command will update Peter's email to <kbd>peter@mongo.com</kbd>. The output is:</p>
<div><img class="alignnone size-full wp-image-840 image-border" src="img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png" style="width:37.50em;height:10.58em;"/></div>
<p>As the output says, the <kbd>modifiedCount</kbd> is <kbd>1</kbd> and the <kbd>matchedCount</kbd> is <kbd>1</kbd>, which means the document with the given condition was found and updated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">updateMany()</h1>
                
            
            
                
<p>This command is used to update multiple documents in a collection. The command for updating documents with <kbd>updateOne()</kbd> and <kbd>updateMany()</kbd> is the same. To update the multiple records, we specify the condition and then set the desired values:</p>
<pre><strong>&gt; db.users.updateOne(</strong><br/><strong>  { "name": "Peter" },</strong><br/><strong>  {</strong><br/><strong>    $set: { "email": "peter@mongo.com" }</strong><br/><strong>  }</strong><br/><strong> )</strong></pre>
<p>The only difference between <kbd>updateOne()</kbd> and <kbd>updateMany()</kbd> is that <kbd>updateOne()</kbd> updates only the first document that is matched whereas <kbd>updateMany()</kbd> updates all the documents that are matched.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">update()</h1>
                
            
            
                
<p>Just like insert, the <kbd>update()</kbd> command does the job for <kbd>updateOne()</kbd> and <kbd>updateMany()</kbd>. To remove confusion, we can just use the <kbd>update()</kbd> command instead of <kbd>updateOne()</kbd> and <kbd>updateMany()</kbd>:</p>
<pre><strong>&gt; db.users.update(</strong><br/><strong>  { "name": "John" },</strong><br/><strong>  {</strong><br/><strong>    $set: { "email": "john@mongo.com" }</strong><br/><strong>  }</strong><br/><strong> )</strong></pre>
<p>The output is as follows:</p>
<div><img class="alignnone size-full wp-image-442 image-border" src="img/acd38c2b-330c-44af-bfe4-d799032d7288.png" style="width:37.42em;height:10.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting documents</h1>
                
            
            
                
<p>MongoDB provides multiple commands for deleting and removing documents from collections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">deleteOne()</h1>
                
            
            
                
<p><kbd>deleteOne()</kbd> removes only a single document from a collection:</p>
<pre class="mce-root"><strong>&gt; db.users.deleteOne( { name: "John" } )</strong></pre>
<p>This removes the entry of a user whose name is <kbd>John</kbd>. The output is as follows:</p>
<div><img class="alignnone size-full wp-image-443 image-border" src="img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png" style="width:28.33em;height:4.67em;"/></div>
<p>As you can see in the output, the <kbd>deletedCount</kbd> is <kbd>1</kbd>, which means the record has been deleted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">deleteMany()</h1>
                
            
            
                
<p>The command for <kbd>deleteMany()</kbd> is the same as <kbd>deleteOne()</kbd>. The only difference is that <kbd>deleteOne()</kbd> removes only a single entry with the matched filter whereas <kbd>deleteMany()</kbd> removes all the documents which match the given criteria:</p>
<pre><strong>&gt; db.users.deleteMany( { name: "Jack" } )</strong></pre>
<p>The output is as follows:</p>
<div><img src="img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png" style="width:45.83em;height:4.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">remove()</h1>
                
            
            
                
<p>The <kbd>remove()</kbd> command works to remove a single entry, as well as multiple entries, from a collection. If we want to remove only a single document that matched certain criteria, then we can pass the count of entries that we wish to delete. For example, let's first create an entry:</p>
<pre><strong>&gt; db.users.insertOne({ name: 'Mike', email: 'mike@mike.com' })</strong></pre>
<p>With this, now we have two entries for <kbd>Mike</kbd>. Now, if we want to remove just one entry using <kbd>remove()</kbd>, we can do so with:</p>
<pre><strong>&gt; db.users.remove({ name: 'Mike' }, 1)</strong></pre>
<p>The output is as follows:</p>
<div><img src="img/9c069d94-4b75-4853-855d-d584cbb13044.png" style="width:44.25em;height:3.67em;"/></div>
<p>As you can see, we had two entries with the name <kbd>Mike</kbd>, but it only removed one. Similarly, if we want to remove all the documents, we can just use:</p>
<pre><strong>&gt; db.users.remove({})</strong></pre>
<p>All documents will be removed.</p>
<p>We talked about the basic ideas on how we can query the documents in Mongo. To find out more details, visit <a href="https://docs.mongodb.com/v3.2/tutorial/query-documents/">https://docs.mongodb.com/v3.2/tutorial/query-documents/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Mongoose</h1>
                
            
            
                
<p>Mongoose is an elegant MongoDB object modeling library for Node.js. As I mentioned earlier, MongoDB is a schemaless database design. While this has its own advantages, sometimes we need to add certain validations as well, and this means defining the schemas for our documents. Mongoose provides an easy way to add such validations and to typecast the fields in a document. </p>
<p>For example, to insert data into a MongoDB document, we can use:</p>
<pre><strong>&gt; db.posts.insert({ title : 'test title', description : 'test description'})</strong></pre>
<p>Now, if we want to add another document and we want an extra field in that document, we can use:</p>
<pre><strong>&gt; db.posts.insert({ title : 'test title', description : 'test description', category: 'News'})</strong></pre>
<p>This is possible in MongoDB because no schemas are defined. These types of documents are also needed when building an application. MongoDB will silently accept any kind of document. However, there are times when we need to have documents look similar in order to behave in certain validations or to have a specific data type. In such situations, Mongoose comes to the rescue. We can also leverage these features with raw MongoDB as well, but writing validations in MongoDB is an extremely painful task. That's why Mongoose was created.</p>
<p>Mongoose is a data modeling technique for Mongo written in Node.js. Every document inside a Mongoose collection requires a fixed amount of fields. We have to explicitly define a <kbd>Schema</kbd> and adhere to it. An example of a Mongoose schema is: </p>
<pre><strong>const UserSchema = new Schema({</strong><br/><strong>  name: String,</strong><br/><strong>  bio: String,</strong><br/><strong>  extras: {}</strong><br/><strong>})</strong></pre>
<p>This means that the name and description fields must be a string, whereas the extras can take a whole JSON object in which we can store nested values as well. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Mongoose</h1>
                
            
            
                
<p>Like any other package, Mongoose can be installed in our project using NPM. Run the following command in our Terminal inside our <kbd>express_app</kbd> folder which we created in the previous chapter to install Mongoose inside that application:</p>
<pre><strong>$ npm install mongoose --save</strong></pre>
<p>If this is successfully installed, we should have a line added to our <kbd>package.json</kbd> file:</p>
<div><img src="img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png" style="width:37.75em;height:24.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting Mongoose to MongoDB</h1>
                
            
            
                
<p>Once Mongoose is installed, we have to connect it to the MongoDB in order to start working with it. This is pretty straightforward with Mongoose; we just have to add a piece of code to <kbd>require</kbd> Mongoose in our <kbd>app.js</kbd> file and use the <kbd>mongoose.connect</kbd> method to connect it to the database. Let's go ahead and do that. In the <kbd>app.js</kbd> file, add the following code:</p>
<pre>var express = require('express');<br/>var path = require('path');<br/>var favicon = require('serve-favicon');<br/>var logger = require('morgan');<br/>var cookieParser = require('cookie-parser');<br/>var bodyParser = require('body-parser');<br/><strong>var mongoose = require('mongoose');</strong></pre>
<p>This will import the Mongoose module into our codebase.</p>
<p>Now, to connect to the MongoDB database, add the following line of code in our <kbd>app.js</kbd>:</p>
<pre>var express = require('express');<br/>var path = require('path');<br/>var favicon = require('serve-favicon');<br/>var logger = require('morgan');<br/>var cookieParser = require('cookie-parser');<br/>var bodyParser = require('body-parser');<br/>var mongoose = require('mongoose');<br/><br/>var app = express();<br/><br/><strong>//connect to mongodb</strong><br/><strong>mongoose.connect('mongodb://localhost:27017/express_app', function() {</strong><br/><strong>  console.log('Connection has been made');</strong><br/><strong>})</strong><br/><strong>.catch(err =&gt; {</strong><br/><strong>  console.error('App starting error:', err.stack);</strong><br/><strong>  process.exit(1);</strong><br/><strong>});</strong><br/><br/>// Require file system module<br/>var fs = require('file-system');</pre>
<p>This creates a connection with our Mongoose database. Now, let's run the app with the following command:</p>
<pre><strong>$ nodemon app.js</strong></pre>
<p>and displays a message in our Terminal if it succeeded or failed:</p>
<div><img src="img/a9f674f8-65fb-4746-9de9-b5347303decc.png" style="width:40.75em;height:11.00em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">That's it! We have successfully made a connection to our MongoDB database. The URL here is the locally hosted database URL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating records in Mongoose</h1>
                
            
            
                
<p>Let's start by creating a new model in our application's <kbd>express_app</kbd>. Create a folder called <kbd>models</kbd> in the root of the project and name it <kbd>User.js</kbd>.</p>
<p>We are using a capital letter for the starting letter of the file name. Also, we are using the single form for <kbd>models</kbd>. Contrary to this, for <kbd>controllers</kbd>, we use the plural form and lowercase letters, such as <kbd>users.js</kbd>.</p>
<p>Once we create the file, paste the following code into it:</p>
<pre><strong>const mongoose = require('mongoose');</strong><br/><br/><strong>const Schema = mongoose.Schema;</strong><br/><br/><strong>const UserSchema = new Schema({</strong><br/><strong>  name: String,</strong><br/><strong>  email: String</strong><br/><strong>})</strong><br/><br/><strong>const User = mongoose.model("User", UserSchema)</strong><br/><strong>module.exports = User</strong></pre>
<p>The first line here just imports the Mongoose module. This Mongoose package provides us with several properties, one of which is to define the <kbd>Schema</kbd>. Now, the original <kbd>Schema</kbd> definition here is this highlighted part:</p>
<pre>const mongoose = require('mongoose');<br/><br/>const Schema = mongoose.Schema;<br/><br/><strong>const UserSchema = new Schema({</strong><br/><strong>  name: String,</strong><br/><strong>  email: String</strong><br/><strong>})</strong><br/><br/>const User = mongoose.model("User", UserSchema)<br/>module.exports = User</pre>
<p>What this does is it adds a validation to our <kbd>User</kbd> data model, where it says there must be two fields in total. It will not accept either one or more than two data fields while creating a document for a Mongoose collection. Also, it adds a validation layer to this <kbd>Schema</kbd> as well, which says that the two fields, both <kbd>name</kbd>, and <kbd>email</kbd>, should be a valid string. It won't accept an integer, Boolean, or anything other than a string for both of these fields. This is how we define the <kbd>Schema</kbd>:</p>
<pre>const mongoose = require("mongoose")<br/>const Schema = mongoose.Schema<br/><br/>const UserSchema = new Schema({<br/>  name: String,<br/>  email: String<br/>})<br/><br/><strong>const User = mongoose.model("User", UserSchema)</strong><br/><strong>module.exports = User</strong></pre>
<p>The highlighted part of this code represents the way to create a model. The first argument of the method is our model name, which maps to the corresponding plural version of the collection name. So, when we create a <kbd>User</kbd> model, this automatically maps to the <kbd>user</kbd> collections in our database.</p>
<p>Now, to create a user, the first thing to do is to create a resource:</p>
<pre>const user_resource = new User({<br/>  name: 'John Doe',<br/>  email: 'john@doe.com'<br/>})</pre>
<p>Now, finally, the part that actually creates the <kbd>user</kbd> is:</p>
<pre>user_resource.save((error) =&gt; {<br/>  <strong>if(error)</strong><br/><strong>    console.log(error);</strong><br/><br/>  res.send({<br/>    success: true,<br/>    code: 200,<br/>    msg: "User added!"<br/>  })<br/>})</pre>
<p>The previous code uses a Mongoose function called <kbd>save</kbd>. The save method has a callback function that is used for error handling. We can do whatever we want when we encounter an error while saving the resource to our database there:</p>
<pre>user_resource.save((error) =&gt; {<br/>  if(error)<br/>    console.log(error);<br/><br/>  <strong>res.send({</strong><br/><strong>    success: true,</strong><br/><strong>    code: 200,</strong><br/><strong>    msg: "User added!"</strong><br/><strong>  })</strong><br/>})</pre>
<p>The <kbd>res.send</kbd> method allows us to set what we want to send to the client when the resource is successfully saved to the database. The first element of the object is <kbd>success: true</kbd>, which denotes if the execution was successful or not. The second element is the status code or the response code. A <kbd>200</kbd> response code denotes successful execution. We will discuss this in further chapters as well.The last element is the message that is sent to the client; the users see this in the frontend.</p>
<p>That's how we create a resource in Mongoose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching records from Mongoose</h1>
                
            
            
                
<p>Now that we have successfully created a user, we have a record in the <kbd>users</kbd> collections in the database. There are two ways to fetch this record in our client: fetch all the records of users that we have or fetch a specific user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching all records</h1>
                
            
            
                
<p>There are lots of methods that come out of the box with a Mongoose model to make our lives easier. Two such methods are <kbd>find()</kbd> and <kbd>findById()</kbd>. In MongoDB, we saw how we could retrieve a collection's records data via raw MongoDB queries. This is similar, the only  difference being that Mongoose has a very easy way to do it. I recommend you learn MongoDB first instead of Mongoose because MongoDB gives you an overall idea of what a database is and you will learn the fundamentals of the database and about its queries. Mongoose just adds a layer on top of MongoDB to make it look a little bit easier for faster developments.</p>
<p>With that, let's look into the code snippet here:</p>
<pre>User.find({}, 'name email', function (error, users) {<br/>  if (error) { console.error(error); }<br/>  res.send({<br/>    users: users<br/>  })<br/>})</pre>
<p>The Mongoose model <kbd>User</kbd> calls a method called <kbd>find()</kbd>. The first parameter is our query string, which is left empty: <kbd>{}</kbd> in the preceding query. So, if we want to retrieve all users who share the same name, say, Peter, then we can replace that empty <kbd>{}</kbd> with <kbd>{ name: 'Peter'}</kbd>.</p>
<p>The second parameter denotes which fields we want to retrieve from the database. We can leave it blank if we want to retrieve all fields or we can just specify it here. For this example, we are just retrieving user names and emails.</p>
<p>The third parameter has a callback function attached to it. This function takes two parameters, unlike the <kbd>create</kbd> method. The first parameter handles the error. If, somehow, the execution is not done successfully, it returns an error and we can customize it the way we want. The second parameter is the important one here; it returns the response when the execution is successfully done. In this case, the <kbd>users</kbd> parameter is an array of objects that are retrieved from the <kbd>users</kbd> collection. The output of this call would be:</p>
<pre>users: [<br/>  {<br/>    name: 'John Doe',<br/>    email: 'john@doe.com'<br/>  }<br/>]</pre>
<p>Now we have all the records from the <kbd>users</kbd> collection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching a specific record</h1>
                
            
            
                
<p>This is also as simple as fetching all records from a collection. We talked about using <kbd>find()</kbd> in the previous section. To fetch a single record, we have to use <kbd>findById()</kbd> or <kbd>findOne()</kbd>, or we can also use the <kbd>where</kbd> query. The <kbd>where</kbd> query is the same as we talked about previously when we had to pass a parameter to fetch records that fell under the same category.</p>
<p>Let's move ahead on using the following query:</p>
<pre>User.findById(1, 'name email', function (error, user) {<br/>  if (error) { console.error(error); }<br/>  res.send(user)<br/>}) </pre>
<p>As you can see, the syntax for both <kbd>find()</kbd> and <kbd>findById()</kbd> are similar. Both take the same amount of parameters and behave the same. The only difference between these two is that the preceding <kbd>find()</kbd> method returned an array of records as a response, whereas <kbd>findById()</kbd> returns a single object. So, the response to the preceding query would be:</p>
<pre>{<br/>    name: 'John Doe',<br/>    email 'john@doe.com'<br/>}</pre>
<p>That's it – simple!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating records in Mongoose</h1>
                
            
            
                
<p>Let's move on to updating a record in a collection. There are multiple ways to update the collection records as well, just as in retrieving data from the collections. Updating a document in Mongoose is the combination of <kbd>read</kbd> and <kbd>create</kbd>(save) methods. To update a document, we first need to find that document using the read query of Mongoose, alter that document, and then save the changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">findById() and save()</h1>
                
            
            
                
<p>Let's look at an example as follows:</p>
<pre>User.findById(1, 'name email', function (error, user) {<br/>  if (error) { console.error(error); }<br/><br/>  user.name = 'Peter'<br/>  user.email = 'peter@gmail.com'<br/>  user.save(function (error) {<br/>    if (error) {<br/>      console.log(error)<br/>    }<br/>    res.send({<br/>      success: true<br/>    })<br/>  })<br/>})</pre>
<p>So, the first thing we need to do is find the user document, which we are doing by <kbd>findById()</kbd>. This method returns back the user with the given ID. Now that we have that user, we can alter whatever we like for this user. In the preceding case, we are changing the name and email of that person. </p>
<p>Now the important part. The job of updating this user's document is done by the <kbd>save()</kbd> method here. We have already altered the name and email of the user by doing:</p>
<pre>user.name = 'Peter'<br/>user.email = 'peter@gmail.com'</pre>
<p>We are changing the object that was returned via <kbd>findById()</kbd> in the first place directly. Now, when we use <kbd>user.save()</kbd>, this method overwrites whatever value it was before for this user with this new name and email.</p>
<p>There are other methods we can use to update a document in Mongoose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">findOneAndUpdate()</h1>
                
            
            
                
<p>This method can be used when we want to update a single entry. For example:</p>
<pre>User.findOneAndUpdate({name: 'Peter'}, { $set: { name: "Sara" } },   function(err){<br/>  if(err){<br/>    console.log(err);<br/>  }<br/>});</pre>
<p>As you can see, the first parameter defines the criteria describing the record we want to update, which, in this case, is the user whose name is Peter. The second parameter is the object in which we define what attributes of <kbd>user</kbd> do we want to update, which is defined by <kbd>{ $set: { name: "Sara" }</kbd>. This sets the <kbd>name</kbd> of <kbd>Peter</kbd> to <kbd>Sara</kbd>.</p>
<p>Now, let's make a small alteration to the preceding code:</p>
<pre>User.findOneAndUpdate({name: 'Peter'}, { $set: { name: "Sara" } },   function(err, <strong>user</strong>){<br/>  if(err){<br/>    console.log(err);<br/>  }<br/>  <strong>res.send(user);</strong><br/>});</pre>
<p>Here, notice that I have added a second parameter to the callback function called <kbd>user</kbd>.  What this does is that when Mongoose is done updating that document in the database, it returns the object. This is very useful when we want to make some decisions after we update the record and want to play with the newly updated document.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">findByIdAndUpdate()</h1>
                
            
            
                
<p>This is somewhat similar to <kbd>findOneAndUpdate()</kbd>. This method takes an ID as a parameter, unlike <kbd>findOneAndUpdate()</kbd>, where we can add our own criteria, and updates that document:</p>
<pre>User.findByIdAndUpdate(1, { $set: { name: "Sara" } },   function(err){<br/>  if(err){<br/>    console.log(err);<br/>  }<br/>});</pre>
<p>The only difference here is that the first parameter takes a single integer value, which is the ID of the document rather than an object. This method also returns the object that is being updated. So we can use:</p>
<pre>User.findByIdAndUpdate(1, { $set: { name: "Sara" } }, function(err){<br/>  if(err, <strong>user</strong>){<br/>    console.log(err);<br/>  }<br/><strong>  res.send(user);</strong><br/>});</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting records in Mongoose</h1>
                
            
            
                
<p>Just as there are many ways to create, fetch and update records in Mongoose, it also provides several ways to delete records from collections as well, such as <kbd>remove()</kbd>, <kbd>findOneAndRemove()</kbd>, and <kbd>findByIdAndRemove()</kbd>. We can use <kbd>remove()</kbd> to remove one or many documents. We can also find the documents we want to remove first and then use the <kbd>remove()</kbd> command to remove only those documents. If we want to find a specific document with some criteria, we can use <kbd>findOneAndRemove()</kbd>. We can use <kbd>findByIdAndRemove()</kbd> when we know the ID of the document we wish to remove.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">remove()</h1>
                
            
            
                
<p>Let's look at a sample for using this method:</p>
<pre>User.remove({<br/>  _id: 1<br/>}, function(err){<br/>  if (err)<br/>    res.send(err)<br/>  res.send({<br/>    success: true<br/>  })<br/>})</pre>
<p>The first argument of the <kbd>remove()</kbd> method takes the criteria for filtering which user we want to remove. It takes an ID as a parameter. It finds the user with the given ID and removes the document from the collection. The second parameter is the callback function, which we talked about before. If something goes wrong with the above operation, it returns an error, which we can use to better handle the exceptions or the errors that occur in our application. In the case of success, we can define our own logic as to what to return. In the preceding case, we are returning <kbd>{ success: true }</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">findOneAndRemove</h1>
                
            
            
                
<p><kbd>findOneAndRemove()</kbd> behaves the same way as <kbd>remove()</kbd> does and takes the same amount of parameters:</p>
<pre>User.findOneAndRemove({<br/>  _id: 1<br/>}, function(err){<br/>  if (err)<br/>    res.send(err)<br/>  res.send({<br/>    success: true<br/>  })<br/>})</pre>
<p>We just have to define the criteria for which documents we want to delete.</p>
<p>Now, we can also modify the preceding code:</p>
<pre>User.findOneAndRemove({<br/>  _id: 1<br/>}, function(err, <strong>user</strong>){<br/>  if (err)<br/>    res.send(err)<br/>  res.send({<br/>    success: true<strong>,</strong><br/>    <strong>user: user</strong><br/>  })<br/>})</pre>
<p>Here, I have highlighted the added piece of code. We can also pass on a second parameter to the callback function which returns the <kbd>user</kbd> object being deleted. Now, this is helpful if we want to display a certain message to the frontend and also add some user attributes such as <kbd>name</kbd> or <kbd>email</kbd> of the <kbd>user</kbd>. For example, if we want to display a message saying User with name {x} has been deleted. on the frontend, then we can pass <kbd>user</kbd> or other attributes of <kbd>user</kbd> here; in this case, it's the name, to be displayed on the frontend.</p>
<p>The main difference between <kbd>remove()</kbd> and <kbd>findOneAndRemove()</kbd> is that remove does not return the documents that were deleted but <kbd>findOneAndRemove()</kbd> does. Now we know when to use these two methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">findByIdAndRemove()</h1>
                
            
            
                
<p>This is the same as <kbd>findOneAndRemove()</kbd>, except that this always needs an <kbd>id</kbd> to be passed as a parameter:</p>
<pre>User.findByIdAndRemove(1, function(err){<br/>  if (err)<br/>    res.send(err)<br/>  res.send({<br/>    success: true<br/>  })<br/>})</pre>
<p>Did you find any difference in the code between <kbd>findOneAndRemove()</kbd> and the preceding code for <kbd>findByIdAndRemove()</kbd>? If we look at the first parameter of this method, it only takes a simple integer value, which is the document ID. Now, if we look into the preceding <kbd>findOneAndRemove()</kbd> code, we will notice that we have passed an object in the first parameter. That's because, for <kbd>findOneAndRemove()</kbd>, we can pass different arguments other than ID as well. For example, we can also pass <kbd>{ name: 'Anita' }</kbd> in that parameter for <kbd>findOneAndRemove()</kbd>. But, for <kbd>findByIdAndRemove()</kbd>, as is obvious from the method name, we don't need to pass an object but just an integer that denotes the document's ID.</p>
<p>It finds a document with the mentioned ID in the parameter and removes that document from the collections. Like <kbd>findOneAndRemove()</kbd>, this also returns the document that is being deleted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding validation with Mongoose </h1>
                
            
            
                
<p>Validations in Mongoose are defined at the schema level. Validations can be set in both strings and in numbers. Mongoose provides us with built-in validation techniques for strings and numbers. Also, we can customize these according to our need as well. Since validations are defined in the schemas, they are triggered when we hit the <kbd>save()</kbd> method for any document. If we only want to test these validations, we can do that as well by executing the validation method only via <kbd>{doc}.validate()</kbd>.</p>
<p><kbd>validate()</kbd> is also middleware, which means it has control when we are executing some methods in an asynchronous way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Default validations</h1>
                
            
            
                
<p>Let's talk about some of the default validations that Mongoose provides us with. These are also called built-in validators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">required()</h1>
                
            
            
                
<p>The <kbd>required()</kbd> validator checks if the field we added this validation on has some value or not. Previously, in the <kbd>User</kbd> model, we had this code:</p>
<pre>var mongoose = require("mongoose");<br/>var Schema = mongoose.Schema;<br/><br/>var UserSchema = new Schema({<br/>  name: String,<br/>  email: String<br/>});<br/><br/>var User = mongoose.model("User", UserSchema);<br/>module.exports = User;</pre>
<p>This code also has a validation associated with the fields of the user. It requires the name and email of a user to be a string and not numbers, or Boolean, or anything else. But this code doesn't make sure the name and email fields are set for the user. </p>
<p>So, if we want to add a <kbd>required()</kbd> validation, the code should be modified in this way:</p>
<pre>var mongoose = require("mongoose");<br/>var Schema = mongoose.Schema;<br/><br/>var UserSchema = new Schema({<br/>  name: <strong>{</strong><br/><strong>    required: true</strong><br/><strong>  },</strong><br/>  email: <strong>{</strong><br/><strong>    required: true</strong><br/><strong>  }</strong><br/>});<br/><br/>var User = mongoose.model("User", UserSchema);<br/>module.exports = User;</pre>
<p>As you can see, we have changed the value of the name key to an object instead of just a string. Here, we can add as many validations as we want. So, the added validation <kbd>required: true</kbd> checks if there is some value set on the name and email of the user before saving that document in the collection. It returns an error if the validation is not met.</p>
<p>We can also pass a message when the validation returns an error. For example:</p>
<pre>var mongoose = require("mongoose");<br/>var Schema = mongoose.Schema;<br/><br/>var UserSchema = new Schema({<br/>  name: <strong>{</strong><br/><strong>    required: [true, 'Let us know you by adding your name!']</strong><br/><strong>  },</strong><br/>  email: <strong>{</strong><br/><strong>    required: [true, 'Please add your email as well.']</strong><br/><strong>  }</strong><br/>});<br/><br/>var User = mongoose.model("User", UserSchema);<br/>module.exports = User;</pre>
<p>This way, we can also customize the messages as per our requirements. Very cool, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Type validation</h1>
                
            
            
                
<p>The type validation method defines the types of fields in a document. The different variations of type can be <kbd>String</kbd>, <kbd>boolean</kbd>, and <kbd>number</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">String</h1>
                
            
            
                
<p>The string itself has several validators under it, such as <kbd>enum</kbd>, <kbd>match</kbd>, <kbd>maxlength</kbd>, and <kbd>minlength</kbd>.</p>
<p><kbd>maxlength</kbd> and <kbd>minlength</kbd> define the length of a string.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Numbers</h1>
                
            
            
                
<p>Numbers have two validators: <kbd>min</kbd> and <kbd>max</kbd>. The <kbd>min</kbd> and <kbd>max</kbd> values define the range of values for a field in a collection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom validations</h1>
                
            
            
                
<p>We can also add custom validations in case the default built-in validations are not enough.  We can pass a <kbd>validate</kbd> function and write our custom code into that function. Let's look at an example:</p>
<pre>var userSchema = new Schema({<br/>  phone: {<br/>    type: String,<br/>    <strong>validate: {</strong><br/><strong>      validator: function(v) {</strong><br/><strong>        return /\d{3}-\d{3}-\d{4}/.test(v);</strong><br/><strong>      },</strong><br/><strong>      message: '{VALUE} is not a valid phone number!'</strong><br/><strong>    }</strong><br/>  }<br/>});</pre>
<p>Here, we have passed a <kbd>validate</kbd> method to the <kbd>Schema</kbd>. It takes a validator function where we can add our own code for the validation. The preceding method checks if the phone number field of the user is in the correct format or not. If it does not pass the validation, then it displays the message <kbd>{value} is not a valid phone number</kbd>.</p>
<p>We can also add nested validations in Mongoose: for example, if the name in our user collection is saved as <kbd>{ name: { first_name: 'Anita', last_name: 'Sharma' } }</kbd>, we will need to add validations for both <kbd>first_name</kbd> and <kbd>last_name</kbd>. To do that, we can use:</p>
<pre>var nameSchema = new Schema({<br/>  first_name: String,<br/>  last_name: String<br/>});<br/><br/>userSchema = new Schema({<br/>  name: {<br/>    type: nameSchema,<br/>    required: true<br/>  }<br/>});</pre>
<p>First, we define the <kbd>Schema</kbd> for a low-level object, which is <kbd>first_name</kbd> and <kbd>last_name</kbd>. Then, for the <kbd>userSchema</kbd>, we pass on the <kbd>nameSchema</kbd> for the name field.</p>
<p>Remember, we cannot add nested validations in a single <kbd>Schema</kbd> like this:</p>
<pre>var nameSchema = new Schema({<br/>  first_name: String,<br/>  last_name: String<br/>});<br/><br/>personSchema = new Schema({<br/>  name: {<br/>    type: {<br/>      first_name: String,<br/>      last_name: String<br/>    },<br/>    required: true<br/>  }<br/>});</pre>
<p>You can look into Mongoose validations here: <a href="http://mongoosejs.com/docs/validation.html">http://mongoosejs.com/docs/validation.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered basic information about MongoDB and its benefits, how to make CRUD operations and queries in MongoDB, and the basic validations with Mongoose.</p>
<p>Going further, in the next chapter, we will talk more about the REST APIs and the RESTful architecture design in our application.</p>


            

            
        
    </body></html>