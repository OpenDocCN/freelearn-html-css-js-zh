- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating Native Code with WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole point of actually using Node.js is convenience. Node.js never aspired
    to be the fastest runtime, the most complete one, or the most secure one. However,
    Node.js established a quick and powerful ecosystem that was capable of developing
    a set of tools and utilities to actually empower the web development standards
    that we are all used to today.
  prefs: []
  type: TYPE_NORMAL
- en: With the growth of Node.js, the demand for more specialized systems also increased.
    The rise of new runtimes that offered alternatives to Node.js actually resulted
    from this need. An interesting alternative can be found in the WebAssembly language.
    WebAssembly is a portable binary-code format like the **Java Virtual Machine**
    (**JVM**) or the **Microsoft Intermediate Language** (**MSIL**). This makes it
    a potential compilation offering for any language – especially lower-level languages
    such as C or Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn what WebAssembly has to offer, how you can integrate
    existing WebAssembly code in your Node.js applications, and how you can generate
    WebAssembly code yourself. By the end, you will be prepared to take your scripts
    to the next level – whether it is with WebAssembly itself or with WebAssembly
    running in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running WebAssembly in Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing WASM with AssemblyScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3DPH53P](https://bit.ly/3DPH53P).
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebAssembly** (**WASM**) is a language without any runtime. Any kind of functionality
    – from allocating some memory to making an HTTP request – needs to be integrated
    by the consuming application. There are, however, some emerging standards such
    as the **WebAssembly System Interface** (**WASI**) that aim to bring a set of
    standard functionalities to any platform. This way, we can write platform-independent
    applications using WASM, with a runner integrating WASI.'
  prefs: []
  type: TYPE_NORMAL
- en: WASI specification
  prefs: []
  type: TYPE_NORMAL
- en: The WASI specification covers everything that is needed to run WASM outside
    of a browser. Popular WASM runtimes such as **Wasmtime** or **Wasmer** implement
    WASI to actually run WASM applications. WASI specifies how system resources can
    be accessed by WASM. As a result, besides having WASI implemented in the runtime,
    the executed WASM code also needs to know (and use) the API provided by WASI.
    More details can be found at [https://wasi.dev/](https://wasi.dev/).
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, one of the advantages of WASM is its portability and ability to
    run in a sandbox. After all, there is no linking and ability to run system commands
    or access critical system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Even something as simple as logging to the console (i.e., the equivalent of
    using `console.log()` in Node.js) needs to be provided by the WASI layer, which
    could leave the access decision for certain resources to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of WASM is that it is not a language directly. Therefore,
    we can actually use any language that supports WASM as a compilation target. As
    of today, most system languages such as C/C++, Rust, Zig, and Go support WASM
    generation. Finally, the “write once, run everywhere” principle of Java seems
    to be fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, performance is considered another advantage of WASM. While WASM
    by itself can actually provide better performance than Node.js or similar runtimes,
    it will certainly still be slower than equivalent but very well-optimized native
    code. After all, this also just runs natively but with a bit less information,
    and in a more generic mode. Nevertheless, for some algorithms, the slowdown from
    WASM execution to native execution can be quite small, or even unnoticeable.
  prefs: []
  type: TYPE_NORMAL
- en: So, how is this all achieved? Well, first of all, the format of a WASM file
    is binary – that is, as efficient as possible. The structure in this binary is
    tailored to be parsed and executed really quickly. Instead of having high-level
    instructions such as loops, the language only offers labels and jump points –
    much like a true machine language.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10**.1*, you can see the general flow and portability promise offered
    by WASM. As a developer, we only need to care about compiling to a `.wasm` file.
    If our tooling is capable of doing that, users are able to consume such files
    with the WASM runtime of their choice, which can be a browser or Node.js, but
    many other options exist too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Portability in WASM with a WASM binary ](img/Figure_10.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Portability in WASM with a WASM binary
  prefs: []
  type: TYPE_NORMAL
- en: Like with machine languages, WASM has two formats – a text representation, which
    is great for seeing what’s going on, and a corresponding binary representation.
    The text representation looks quite close to programming languages such as **Lisp**,
    with lower-level fragments resembling actual processor instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of a WASM text representation for a library exporting
    a `sum` function to add two numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: sum.wat
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tools exist to translate the text representation into its binary counterpart.
    The most popular tool is **wat2wasm**, which has a powerful online demo, too.
    You can access it at [https://webassembly.github.io/wabt/demo/wat2wasm/](https://webassembly.github.io/wabt/demo/wat2wasm/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the preceding example, you’ll get a view as presented in *Figure 10**.2*.
    You’ll see that the online tool does a bit more than the text (upper left) to
    binary (upper right) translation. It also includes a small JavaScript playground
    (bottom left), which integrates the compiled WASM binary and runs it. The output
    of running code in the playground is then shown in the bottom-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The wat2wasm online tool applied to our example ](img/Figure_10.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The wat2wasm online tool applied to our example
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what WASM is, how it works, and what advantages it offers,
    it’s time to see how we can run it and – of course – also integrate it with Node.js.
    This makes our scripts even more powerful than beforehand, allowing platform-independent,
    almost native code to be integrated in a reliable, well-performing, and secure
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Running WASM in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has a direct integration of WASM via the `WASM` object. The API is exactly
    the same as in the browser, allowing us to potentially share the code between
    Node.js and browsers to integrate a compiled WASM file.
  prefs: []
  type: TYPE_NORMAL
- en: There are three functions in the API of `WASM`. We can compile an existing binary,
    transforming it into a WASM runtime module. This module can then be activated
    using the `instantiate` method. We can also validate an existing binary – to check
    whether a given file is indeed a valid WASM binary. All methods are asynchronous
    and return `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example using a WASM binary, `sum.wasm`, which exports a single
    function (`sum`) and adds two numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: app.mjs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Node.js makes the integration of WASM even more convenient by providing a `wasi`
    package out of the box. This package fulfills the WASI specification, allowing
    us to access system resources within WASM applications running in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what the integration of a WASM module that depends on WASI looks like,
    we’ll build a small application later, which will make use of WASI and be integrated
    into Node.js. The Node.js integration will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: app.mjs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At least with Node.js version 18, the `wasi` package is not active. To actually
    run the preceding application, you’ll need to add the `--``experimental-wasi-unstable-preview1`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The specifics of running the preceding example are explored in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: While running WASM in Node.js is great, we might also want to write some code
    ourselves. Of course, if you have any knowledge of languages such as C or Rust,
    you can use those with WASM as a compilation target. In general, however, for
    developers with a JavaScript background, a nice alternative exists with AssemblyScript.
  prefs: []
  type: TYPE_NORMAL
- en: Writing WASM with AssemblyScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are many options to actually generate valid WASM, one of the most
    attractive ways is to use AssemblyScript. AssemblyScript is a language that looks
    and feels quite similar to TypeScript, making it rather easy to learn from a syntax
    perspective. Under the hood, however, there are still some concepts relating to
    WASM that need to be known in order to write mid-sized to larger AssemblyScript
    applications or libraries.
  prefs: []
  type: TYPE_NORMAL
- en: One of the core concepts of AssemblyScript is to model the different data types
    used in WASM. For instance, using integers requires the use of the `i32` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at some example code. We’ll start with a small function that
    expects two parameters, adds them up, and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: module.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the exception of the `i32` type, everything in the preceding example looks
    and feels just like TypeScript. Even the file extension indicates a TypeScript
    file.
  prefs: []
  type: TYPE_NORMAL
- en: To actually compile the preceding code to WASM, you’ll need the `assemblyscript`
    package. Like `typescript`, you can either install this package globally or locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once AssemblyScript is installed, you can run the `asc` utility to compile
    the source code to a valid WASM binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'AssemblyScript can also be very helpful to scaffold a project structure that
    works – not only to compile source code but also to run WASM in the browser. This
    provides a nice way of writing code that works on multiple platforms, including
    various operating systems, browsers, and devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the generated structure in place, we can go ahead and try to make our previous
    example work – for instance, in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: For this, modify `index.ts` in the `assembly` directory of the scaffolded project
    folder. Replace its content with the preceding snippet containing the `sum` function.
    Now, open `index.html` in the project’s root. Change the import statement to obtain
    `sum` instead of `add`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script part of the `index.html` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can build and run everything using the `asbuild` script that was added
    during the scaffolding process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, a small web server should be running at port `3000`. Accessing `http://localhost:9000`
    brings you to an almost empty web page. What you should see is that `sum` function
    from our WASM library.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging WASM
  prefs: []
  type: TYPE_NORMAL
- en: A WASM module can be debugged in the same way as any other web application.
    The browser offers a visual debugger that can be used for inspection. By using
    source maps for WASM, the original code can actually be debugged instead of the
    not-so-easily readable WASM. AssemblyScript is also capable of producing WASM
    source maps. Here, the source map destination file has to be specified after the
    `--sourceMap` CLI flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'AssemblyScript can also be used to create WASM applications and libraries built
    on top of WASI. Let’s see how that would work. We start with a new project, where
    we add `assemblyscript` as well as `as-wasi` as dependencies, followed by scaffolding
    a new `AssemblyScript` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can modify the `assembly/index.ts` file with the following code, using
    the `wasi` package.
  prefs: []
  type: TYPE_NORMAL
- en: index.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By importing the `wasi` package, the whole module gets transformed into a WASI-compatible
    entry point. This allows us to use the abstractions from the `as-wasi` package,
    such as `Console` to access the console or `CommandLine` to obtain the provided
    command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the code we invoke the `asc` utility with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This instructs AssemblyScript to build the application found in `assembly/index.ts`.
    The generated WASM will be stored in `echo.wasm`. Through the `--debug` flag,
    we instruct `asc` to create a debug build.
  prefs: []
  type: TYPE_NORMAL
- en: A debug build can be done very fast, as the compiler does not need to invest
    in any optimizations. Besides a faster compilation time, the absence of further
    optimizations also can give us better error messages for critical failures later
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the binding for the `abort` command (usually taken from an implied
    `env` import to the WASM module) is set to use the `abort` method provided by
    WASI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the Node.js module, `app.mjs`, using the `wasi` package from
    the previous section. Don’t forget to add the necessary command-line argument.
    Since this will print a warning, we might want to add `--no-warnings` to suppress
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Equipped with this knowledge, you can now go ahead and write simple programs
    compiling to WASM, too. Let’s recap what you learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you extended your knowledge of potential source code files
    running in Node.js. You are now familiar with running WASM – a lower-level portable
    binary-code language that can be used as a compilation target by many programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: WASM can help you to write functionality once and run it on multiple platforms.
    Since WASM can be sandboxed very well, it is a good contender for the next wave
    of containerized computing, where performance and security are valued highly.
    You now know how to write WASM using AssemblyScript. You are also empowered to
    integrate created WASM modules in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will take a look at the use of JavaScript
    beyond Node.js. We’ll see that other runtimes exist, which are partially compatible
    with the Node.js ecosystem – providing a great drop-in replacement that can be
    handy for multiple use cases.
  prefs: []
  type: TYPE_NORMAL
