- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Integrating Native Code with WebAssembly
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将原生代码与 WebAssembly 集成
- en: The whole point of actually using Node.js is convenience. Node.js never aspired
    to be the fastest runtime, the most complete one, or the most secure one. However,
    Node.js established a quick and powerful ecosystem that was capable of developing
    a set of tools and utilities to actually empower the web development standards
    that we are all used to today.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实际使用 Node.js 的全部意义在于便利性。Node.js 从未追求成为最快的运行时、最完整的或最安全的。然而，Node.js 建立了一个快速而强大的生态系统，能够开发出一套工具和实用程序，实际上赋予了我们现在所习惯的
    Web 开发标准。
- en: With the growth of Node.js, the demand for more specialized systems also increased.
    The rise of new runtimes that offered alternatives to Node.js actually resulted
    from this need. An interesting alternative can be found in the WebAssembly language.
    WebAssembly is a portable binary-code format like the **Java Virtual Machine**
    (**JVM**) or the **Microsoft Intermediate Language** (**MSIL**). This makes it
    a potential compilation offering for any language – especially lower-level languages
    such as C or Rust.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Node.js 的发展，对更多专用系统的需求也增加了。提供 Node.js 替代方案的新运行时实际上正是出于这种需求而出现的。在 WebAssembly
    语言中，我们可以找到一个有趣的替代方案。WebAssembly 是一种可移植的二进制代码格式，类似于 **Java 虚拟机**（**JVM**）或 **微软中间语言**（**MSIL**）。这使得它成为任何语言（尤其是像
    C 或 Rust 这样的底层语言）的潜在编译器选择。
- en: In this chapter, you’ll learn what WebAssembly has to offer, how you can integrate
    existing WebAssembly code in your Node.js applications, and how you can generate
    WebAssembly code yourself. By the end, you will be prepared to take your scripts
    to the next level – whether it is with WebAssembly itself or with WebAssembly
    running in Node.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 WebAssembly 提供的内容，如何将现有的 WebAssembly 代码集成到你的 Node.js 应用程序中，以及如何自己生成
    WebAssembly 代码。到本章结束时，你将准备好将你的脚本提升到下一个层次——无论是使用 WebAssembly 本身还是使用在 Node.js 中运行的
    WebAssembly。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下关键主题：
- en: The advantages of using WebAssembly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 的优势
- en: Running WebAssembly in Node.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 中运行 WebAssembly
- en: Writing WASM with AssemblyScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AssemblyScript 编写 WASM
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的完整源代码可在以下链接找到：[https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10)。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3DPH53P](https://bit.ly/3DPH53P).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的 CiA 视频可通过以下链接访问：[https://bit.ly/3DPH53P](https://bit.ly/3DPH53P)。
- en: Advantages of using WebAssembly
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 的优势
- en: '**WebAssembly** (**WASM**) is a language without any runtime. Any kind of functionality
    – from allocating some memory to making an HTTP request – needs to be integrated
    by the consuming application. There are, however, some emerging standards such
    as the **WebAssembly System Interface** (**WASI**) that aim to bring a set of
    standard functionalities to any platform. This way, we can write platform-independent
    applications using WASM, with a runner integrating WASI.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebAssembly**（**WASM**）是一种没有运行时的语言。任何功能——从分配一些内存到发起 HTTP 请求——都需要由消费应用程序集成。然而，有一些新兴的标准，如
    **WebAssembly 系统接口**（**WASI**），旨在将一组标准功能带到任何平台。这样，我们可以使用 WASM 编写平台无关的应用程序，并使用集成
    WASI 的运行器。'
- en: WASI specification
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WASI 规范
- en: The WASI specification covers everything that is needed to run WASM outside
    of a browser. Popular WASM runtimes such as **Wasmtime** or **Wasmer** implement
    WASI to actually run WASM applications. WASI specifies how system resources can
    be accessed by WASM. As a result, besides having WASI implemented in the runtime,
    the executed WASM code also needs to know (and use) the API provided by WASI.
    More details can be found at [https://wasi.dev/](https://wasi.dev/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WASI 规范涵盖了在浏览器外运行 WASM 所需的一切。流行的 WASM 运行时，如 **Wasmtime** 或 **Wasmer**，实现了 WASI，以便实际运行
    WASM 应用程序。WASI 指定了系统资源如何被 WASM 访问。因此，除了在运行时实现 WASI 之外，执行中的 WASM 代码还需要（并使用）WASI
    提供的 API。更多详细信息请参阅 [https://wasi.dev/](https://wasi.dev/)。
- en: Consequently, one of the advantages of WASM is its portability and ability to
    run in a sandbox. After all, there is no linking and ability to run system commands
    or access critical system resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，WASM 的一个优势是其可移植性和在沙盒中运行的能力。毕竟，没有链接和运行系统命令或访问关键系统资源的能力。
- en: Even something as simple as logging to the console (i.e., the equivalent of
    using `console.log()` in Node.js) needs to be provided by the WASI layer, which
    could leave the access decision for certain resources to the user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 即使像向控制台记录（即Node.js中`console.log()`的等效物）这样简单的事情也需要由WASI层提供，这可能会将某些资源的访问决策留给用户。
- en: Another advantage of WASM is that it is not a language directly. Therefore,
    we can actually use any language that supports WASM as a compilation target. As
    of today, most system languages such as C/C++, Rust, Zig, and Go support WASM
    generation. Finally, the “write once, run everywhere” principle of Java seems
    to be fulfilled.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WASM的另一个优点是它不是一个直接的语言。因此，我们可以实际上使用任何支持WASM作为编译目标的语言。截至今天，大多数系统语言，如C/C++、Rust、Zig和Go，都支持WASM生成。最后，Java的“一次编写，到处运行”原则似乎得到了实现。
- en: Quite often, performance is considered another advantage of WASM. While WASM
    by itself can actually provide better performance than Node.js or similar runtimes,
    it will certainly still be slower than equivalent but very well-optimized native
    code. After all, this also just runs natively but with a bit less information,
    and in a more generic mode. Nevertheless, for some algorithms, the slowdown from
    WASM execution to native execution can be quite small, or even unnoticeable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，性能被认为是WASM的另一个优点。虽然WASM本身实际上可以提供比Node.js或类似运行时更好的性能，但它肯定仍然会比等效但非常优化的本地代码慢。毕竟，这也只是在本地运行，但信息略少，并且以更通用的模式运行。然而，对于某些算法，从WASM执行到本地执行的减速可以相当小，甚至不明显。
- en: So, how is this all achieved? Well, first of all, the format of a WASM file
    is binary – that is, as efficient as possible. The structure in this binary is
    tailored to be parsed and executed really quickly. Instead of having high-level
    instructions such as loops, the language only offers labels and jump points –
    much like a true machine language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切是如何实现的呢？首先，WASM文件的格式是二进制的——也就是说，尽可能高效。在这个二进制中的结构是为了快速解析和执行而量身定制的。该语言不提供高级指令，如循环，而只提供标签和跳转点——就像真正的机器语言一样。
- en: In *Figure 10**.1*, you can see the general flow and portability promise offered
    by WASM. As a developer, we only need to care about compiling to a `.wasm` file.
    If our tooling is capable of doing that, users are able to consume such files
    with the WASM runtime of their choice, which can be a browser or Node.js, but
    many other options exist too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图10.1**中，你可以看到WASM提供的一般流程和可移植性承诺。作为开发者，我们只需要关心编译到`.wasm`文件。如果我们的工具能够做到这一点，用户就可以使用他们选择的WASM运行时来消费这些文件，这可以是浏览器或Node.js，但还有许多其他选项。
- en: '![Figure 10.1 – Portability in WASM with a WASM binary ](img/Figure_10.1_B18989.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 使用WASM二进制文件的WASM的可移植性](img/Figure_10.1_B18989.jpg)'
- en: Figure 10.1 – Portability in WASM with a WASM binary
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 使用WASM二进制文件的WASM的可移植性
- en: Like with machine languages, WASM has two formats – a text representation, which
    is great for seeing what’s going on, and a corresponding binary representation.
    The text representation looks quite close to programming languages such as **Lisp**,
    with lower-level fragments resembling actual processor instructions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像机器语言一样，WASM有两种格式——一种文本表示，这对于查看正在发生的事情非常有用，以及相应的二进制表示。文本表示看起来非常接近像**Lisp**这样的编程语言，较低级别的片段类似于实际的处理器指令。
- en: 'Let’s see an example of a WASM text representation for a library exporting
    a `sum` function to add two numbers together:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个WASM文本表示的例子，这个库导出`sum`函数来将两个数字相加：
- en: sum.wat
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: sum.wat
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tools exist to translate the text representation into its binary counterpart.
    The most popular tool is **wat2wasm**, which has a powerful online demo, too.
    You can access it at [https://webassembly.github.io/wabt/demo/wat2wasm/](https://webassembly.github.io/wabt/demo/wat2wasm/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 存在将文本表示转换为其二进制对应物的工具。最受欢迎的工具是**wat2wasm**，它还有一个强大的在线演示。您可以通过[https://webassembly.github.io/wabt/demo/wat2wasm/](https://webassembly.github.io/wabt/demo/wat2wasm/)访问它。
- en: Adding the preceding example, you’ll get a view as presented in *Figure 10**.2*.
    You’ll see that the online tool does a bit more than the text (upper left) to
    binary (upper right) translation. It also includes a small JavaScript playground
    (bottom left), which integrates the compiled WASM binary and runs it. The output
    of running code in the playground is then shown in the bottom-right corner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的例子添加进去，你将得到如图**图10.2**所示的观点。你会发现在线工具在文本（左上角）到二进制（右上角）的转换之外还做了一些事情。它还包括一个小型的JavaScript游乐场（左下角），它集成了编译后的WASM二进制文件并运行它。游乐场中运行代码的输出随后显示在右下角。
- en: '![Figure 10.2 – The wat2wasm online tool applied to our example ](img/Figure_10.2_B18989.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 将 wat2wasm 在线工具应用于我们的示例](img/Figure_10.2_B18989.jpg)'
- en: Figure 10.2 – The wat2wasm online tool applied to our example
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 将 wat2wasm 在线工具应用于我们的示例
- en: Now that we know what WASM is, how it works, and what advantages it offers,
    it’s time to see how we can run it and – of course – also integrate it with Node.js.
    This makes our scripts even more powerful than beforehand, allowing platform-independent,
    almost native code to be integrated in a reliable, well-performing, and secure
    way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 WASM 是什么，它是如何工作的，以及它提供了哪些优势，现在是时候看看我们如何运行它，当然——以及如何与 Node.js 集成了。这使得我们的脚本比之前更加强大，允许以可靠、高性能和安全的方式集成平台无关的、几乎原生的代码。
- en: Running WASM in Node.js
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 中运行 WASM
- en: Node.js has a direct integration of WASM via the `WASM` object. The API is exactly
    the same as in the browser, allowing us to potentially share the code between
    Node.js and browsers to integrate a compiled WASM file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 通过 `WASM` 对象直接集成 WASM。API 与浏览器中的完全相同，允许我们有可能在 Node.js 和浏览器之间共享代码，以集成编译后的
    WASM 文件。
- en: There are three functions in the API of `WASM`. We can compile an existing binary,
    transforming it into a WASM runtime module. This module can then be activated
    using the `instantiate` method. We can also validate an existing binary – to check
    whether a given file is indeed a valid WASM binary. All methods are asynchronous
    and return `Promise`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 中，`WASM` 有三个函数。我们可以编译现有的二进制文件，将其转换为 WASM 运行时模块。然后，可以使用 `instantiate` 方法激活该模块。我们还可以验证现有的二进制文件——以检查给定的文件是否确实是有效的
    WASM 二进制文件。所有方法都是异步的，并返回 `Promise`。
- en: 'Let’s see an example using a WASM binary, `sum.wasm`, which exports a single
    function (`sum`) and adds two numbers together:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个使用 WASM 二进制文件 `sum.wasm` 的例子来看看，它导出一个单一的功能（`sum`）并将两个数字相加：
- en: app.mjs
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: app.mjs
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Node.js makes the integration of WASM even more convenient by providing a `wasi`
    package out of the box. This package fulfills the WASI specification, allowing
    us to access system resources within WASM applications running in Node.js.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 通过提供内置的 `wasi` 包，使得 WASM 的集成更加方便。这个包实现了 WASI 规范，允许我们在 Node.js 中运行的 WASM
    应用程序内访问系统资源。
- en: 'To see what the integration of a WASM module that depends on WASI looks like,
    we’ll build a small application later, which will make use of WASI and be integrated
    into Node.js. The Node.js integration will look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到依赖于 WASI 的 WASM 模块集成是什么样的，我们将在稍后构建一个小型应用程序，该应用程序将使用 WASI 并集成到 Node.js 中。Node.js
    集成将如下所示：
- en: app.mjs
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: app.mjs
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At least with Node.js version 18, the `wasi` package is not active. To actually
    run the preceding application, you’ll need to add the `--``experimental-wasi-unstable-preview1`
    flag:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在 Node.js 版本 18 中，`wasi` 包不是激活的。要实际运行前面的应用程序，你需要添加 `--experimental-wasi-unstable-preview1`
    标志：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The specifics of running the preceding example are explored in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上一例的运行细节将在下一节中进行探讨。
- en: While running WASM in Node.js is great, we might also want to write some code
    ourselves. Of course, if you have any knowledge of languages such as C or Rust,
    you can use those with WASM as a compilation target. In general, however, for
    developers with a JavaScript background, a nice alternative exists with AssemblyScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Node.js 中运行 WASM 很好，但我们可能也想自己编写一些代码。当然，如果你对 C 或 Rust 等语言有所了解，你可以使用这些语言，并将
    WASM 作为编译目标。然而，一般来说，对于有 JavaScript 背景的开发者来说，AssemblyScript 是一个不错的选择。
- en: Writing WASM with AssemblyScript
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AssemblyScript 编写 WASM
- en: While there are many options to actually generate valid WASM, one of the most
    attractive ways is to use AssemblyScript. AssemblyScript is a language that looks
    and feels quite similar to TypeScript, making it rather easy to learn from a syntax
    perspective. Under the hood, however, there are still some concepts relating to
    WASM that need to be known in order to write mid-sized to larger AssemblyScript
    applications or libraries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有生成有效 WASM 的许多选项，但其中最吸引人的方式之一是使用 AssemblyScript。AssemblyScript 是一种看起来和感觉与
    TypeScript 非常相似的语言，从语法角度来看，学习起来相当容易。然而，在底层，仍然有一些与 WASM 相关的概念需要了解，以便编写中等大小到较大的
    AssemblyScript 应用程序或库。
- en: One of the core concepts of AssemblyScript is to model the different data types
    used in WASM. For instance, using integers requires the use of the `i32` type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 的一个核心概念是模拟 WASM 中使用的不同数据类型。例如，使用整数需要使用 `i32` 类型。
- en: 'Let’s have a look at some example code. We’ll start with a small function that
    expects two parameters, adds them up, and returns the result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例代码。我们将从一个期望两个参数的小函数开始，将它们相加，并返回结果：
- en: module.ts
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: module.ts
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the exception of the `i32` type, everything in the preceding example looks
    and feels just like TypeScript. Even the file extension indicates a TypeScript
    file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `i32` 类型外，前一个示例中的所有内容看起来和感觉都像 TypeScript。甚至文件扩展名也表明这是一个 TypeScript 文件。
- en: To actually compile the preceding code to WASM, you’ll need the `assemblyscript`
    package. Like `typescript`, you can either install this package globally or locally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上编译前面的代码到 WASM，你需要 `assemblyscript` 包。像 `typescript` 一样，你可以全局或本地安装此包。
- en: 'Once AssemblyScript is installed, you can run the `asc` utility to compile
    the source code to a valid WASM binary:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 AssemblyScript，你就可以运行 `asc` 工具将源代码编译成有效的 WASM 二进制文件：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'AssemblyScript can also be very helpful to scaffold a project structure that
    works – not only to compile source code but also to run WASM in the browser. This
    provides a nice way of writing code that works on multiple platforms, including
    various operating systems, browsers, and devices:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 也可以非常有帮助地搭建一个工作良好的项目结构——不仅用于编译源代码，还可以在浏览器中运行 WASM。这为编写适用于多个平台（包括各种操作系统、浏览器和设备）的代码提供了一种很好的方式：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the generated structure in place, we can go ahead and try to make our previous
    example work – for instance, in a web browser.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在搭建好的结构中，我们可以继续尝试让之前的示例工作——例如，在网页浏览器中。
- en: For this, modify `index.ts` in the `assembly` directory of the scaffolded project
    folder. Replace its content with the preceding snippet containing the `sum` function.
    Now, open `index.html` in the project’s root. Change the import statement to obtain
    `sum` instead of `add`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，修改搭建项目文件夹中的 `assembly` 目录下的 `index.ts`。用包含 `sum` 函数的前一个片段替换其内容。现在，在项目的根目录中打开
    `index.html`。将导入语句更改为获取 `sum` 而不是 `add`。
- en: 'The script part of the `index.html` file should now look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 文件的脚本部分现在应该看起来像这样：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, you can build and run everything using the `asbuild` script that was added
    during the scaffolding process:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用在搭建过程中添加的 `asbuild` 脚本构建和运行一切：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, a small web server should be running at port `3000`. Accessing `http://localhost:9000`
    brings you to an almost empty web page. What you should see is that `sum` function
    from our WASM library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个小的网络服务器应该在端口 `3000` 上运行。访问 `http://localhost:9000` 会带你到一个几乎空白的网页。你应该看到的是来自我们
    WASM 库的 `sum` 函数。
- en: Debugging WASM
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 调试
- en: A WASM module can be debugged in the same way as any other web application.
    The browser offers a visual debugger that can be used for inspection. By using
    source maps for WASM, the original code can actually be debugged instead of the
    not-so-easily readable WASM. AssemblyScript is also capable of producing WASM
    source maps. Here, the source map destination file has to be specified after the
    `--sourceMap` CLI flag.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 模块可以像任何其他网络应用程序一样调试。浏览器提供了一个可视化的调试器，可以用于检查。通过使用 WASM 的源映射，实际上可以调试原始代码而不是不那么容易阅读的
    WASM。AssemblyScript 也能够生成 WASM 源映射。在这里，源映射目标文件必须在 `--sourceMap` CLI 标志之后指定。
- en: 'AssemblyScript can also be used to create WASM applications and libraries built
    on top of WASI. Let’s see how that would work. We start with a new project, where
    we add `assemblyscript` as well as `as-wasi` as dependencies, followed by scaffolding
    a new `AssemblyScript` project:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 也可以用来创建基于 WASI 的 WASM 应用程序和库。让我们看看这会怎样工作。我们从一个新项目开始，添加 `assemblyscript`
    和 `as-wasi` 作为依赖项，然后搭建一个新的 `AssemblyScript` 项目：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can modify the `assembly/index.ts` file with the following code, using
    the `wasi` package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `wasi` 包修改 `assembly/index.ts` 文件，使用以下代码。
- en: index.ts
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: index.ts
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By importing the `wasi` package, the whole module gets transformed into a WASI-compatible
    entry point. This allows us to use the abstractions from the `as-wasi` package,
    such as `Console` to access the console or `CommandLine` to obtain the provided
    command-line arguments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入 `wasi` 包，整个模块被转换成 WASI 兼容的入口点。这允许我们使用 `as-wasi` 包中的抽象，例如 `Console` 来访问控制台或
    `CommandLine` 来获取提供的命令行参数。
- en: 'To build the code we invoke the `asc` utility with the following arguments:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建代码，我们使用以下参数调用 `asc` 工具：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This instructs AssemblyScript to build the application found in `assembly/index.ts`.
    The generated WASM will be stored in `echo.wasm`. Through the `--debug` flag,
    we instruct `asc` to create a debug build.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示AssemblyScript构建位于`assembly/index.ts`中的应用程序。生成的WASM将被存储在`echo.wasm`中。通过`--debug`标志，我们指示`asc`创建一个调试构建。
- en: A debug build can be done very fast, as the compiler does not need to invest
    in any optimizations. Besides a faster compilation time, the absence of further
    optimizations also can give us better error messages for critical failures later
    at runtime.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调试构建可以非常快地完成，因为编译器不需要投资于任何优化。除了更快的编译时间外，缺乏进一步的优化还可以在运行时提供更好的错误信息，以便于处理关键的失败。
- en: Importantly, the binding for the `abort` command (usually taken from an implied
    `env` import to the WASM module) is set to use the `abort` method provided by
    WASI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，`abort`命令的绑定（通常从隐含的`env`导入到WASM模块中）被设置为使用WASI提供的`abort`方法。
- en: 'Now, we can add the Node.js module, `app.mjs`, using the `wasi` package from
    the previous section. Don’t forget to add the necessary command-line argument.
    Since this will print a warning, we might want to add `--no-warnings` to suppress
    it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用上一节中的`wasi`包添加Node.js模块`app.mjs`。别忘了添加必要的命令行参数。由于这将会打印警告，我们可能想要添加`--no-warnings`来抑制它：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Equipped with this knowledge, you can now go ahead and write simple programs
    compiling to WASM, too. Let’s recap what you learned in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，你现在可以继续编写编译为WASM的简单程序了。让我们回顾一下本章你学到了什么。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you extended your knowledge of potential source code files
    running in Node.js. You are now familiar with running WASM – a lower-level portable
    binary-code language that can be used as a compilation target by many programming
    languages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你扩展了在Node.js中运行的潜在源代码文件的知识。你现在熟悉了运行WASM——一种可以作为许多编程语言的编译目标的低级可移植二进制代码语言。
- en: WASM can help you to write functionality once and run it on multiple platforms.
    Since WASM can be sandboxed very well, it is a good contender for the next wave
    of containerized computing, where performance and security are valued highly.
    You now know how to write WASM using AssemblyScript. You are also empowered to
    integrate created WASM modules in Node.js.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WASM可以帮助你一次编写功能，并在多个平台上运行。由于WASM可以很好地沙箱化，它是有望成为下一波容器化计算的有力竞争者，在这一领域中，性能和安全被高度重视。你现在已经知道了如何使用AssemblyScript编写WASM。你也被赋予了在Node.js中集成创建的WASM模块的能力。
- en: In the next and final chapter, we will take a look at the use of JavaScript
    beyond Node.js. We’ll see that other runtimes exist, which are partially compatible
    with the Node.js ecosystem – providing a great drop-in replacement that can be
    handy for multiple use cases.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将探讨JavaScript在Node.js之外的用途。我们将看到存在其他运行时，它们部分兼容Node.js生态系统——提供了一种非常适合多种用例的即插即用替代方案。
