<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Playing Around</h1></div></div></div><p>Smartphones <a id="id830" class="indexterm"/>have been no strangers to fun little games that helped pass the time. From the seemingly eternally-existing Solitaire to Snake!, Tetris, or Pop-the-Bubble variants, we've found ways to pass the time with our mobile devices. Even if you nearly always write productive applications, sooner or later, the <em>bug</em> to write a game is likely to bite.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>What do we build?</h1></div></div></div><p>In this project, we're going to <a id="id831" class="indexterm"/>
<a id="id832" class="indexterm"/>put together a game called <em>Cave Runner</em>. Okay, it won't win any prizes based on the originality of the game (or the title), nor will it win <em>Best Game of the Year</em>. But it's amusing, and has a lot of potential to expand in various ways, and so serves as a good base, especially for the quick and diverting category that many games try to fit into.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec156"/>What does it do?</h2></div></div></div><p>To accomplish this, we're going to<a id="id833" class="indexterm"/> be relying heavily upon the HTML5 Canvas, which is quite literally the only way we're going to achieve anything even approaching 60 fps (the target for most games). Even so, only recent and powerful devices are going to meet this target, and so we also will need to sludge around in the mathematics around how to create a game that isn't reliant upon its frame rate. If the game's timing relied solely on the frame rate, 30 fps would feel as if we're sludging through mud, that is, the game would feel like it was progressing in slow motion. Instead, we have to act like we're running at 60 fps, even if we can't display that many frames, so that we avoid this effect.</p><p>While controlling a game character on a console, portable game machine, or PC is pretty obvious (keyboard, mouse, D-pad, Joystick, and so on), how does one control a game character on a mobile device which probably has none of those features? There are two answers: use the multi-touch screen, which can be used to simulate a Joystick or D-pad, or use the device's built-in accelerometer. We'll talk about using both in this task.</p><p>Which brings us to the last <a id="id834" class="indexterm"/>big thing; it's not so hard to implement, but it is absolutely critical to have in place—<strong>persistent</strong> <strong>settings</strong>. If we're going to provide two methods of control, we need a way to save which method the user prefers. While we have used the <code class="literal">File</code> API in previous projects to store persistent content, we're going to use <code class="literal">localStorage</code> this time. After all, we're only storing a simple flag, not a lot of user-generated content.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec157"/>Why is it great?</h2></div></div></div><p>Hopefully, you'll have a<a id="id835" class="indexterm"/> bit of fun with the game as it stands now, but even as a simple game, it introduces you to the concepts you'll need to create complex games further down the road. We'll work on keeping the game going at the same speed, regardless of frame rate. We'll talk about persistent settings using <code class="literal">localStorage</code>. We'll also work out how to control the game using the touch screen and the accelerometer. All of these things combine to create a good game, and you should have a good base from which to build on for any future endeavors.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec158"/>How are we going to do it?</h2></div></div></div><p>We're going to approach this <a id="id836" class="indexterm"/>much like we have the prior projects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the game</li><li class="listitem" style="list-style-type: disc">Implementing the options view</li><li class="listitem" style="list-style-type: disc">Generating levels</li><li class="listitem" style="list-style-type: disc">Drawing to the canvas</li><li class="listitem" style="list-style-type: disc">Keeping up</li><li class="listitem" style="list-style-type: disc">Performing updates</li><li class="listitem" style="list-style-type: disc">Handling touch-based input</li><li class="listitem" style="list-style-type: disc">Handling the accelerometer</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec159"/>What do I need to get started?</h2></div></div></div><p>Go ahead and create<a id="id837" class="indexterm"/> your project, or use the project in the code package for this book as a start. You'll want to use the images in <code class="literal">www/images</code>. If you want some insight on how we designed the graphic assets, feel free to look in the <code class="literal">/resources</code> directory in the code package for this project.</p><p>In general, we'll be talking more about the code that is already written than spelling the code out verbatim. As such, it would be a good idea to have the project downloaded so that you have the code as a reference. Go ahead and compile it for your device, too, and play with it, to get a better feel for what we'll be talking about.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Designing the game</h1></div></div></div><p>Where in previous projects we'd be developing the user interface and the interactions between the various widgets and views, we'll be designing how our game looks and acts instead. While similar, there's often a lot more that has to go into designing games (graphic assets, level design, character design, animation, and so on). Unfortunately, we can't go over everything given the length of the project, but we can give you a good start.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec160"/>Getting on with it</h2></div></div></div><p>The primary theme of<a id="id838" class="indexterm"/> the game may already be evident from the title, Cave Runner. These kinds of games have been around since the first computers, even if the graphical quality was a tad bit coarse. In short, we're going to develop a game that has a series of levels through which the player (who controls a ship) has to navigate safely in order to advance. Each level will be more difficult than the previous, and in our particular version, as long as the player can keep up, there's no end to the levels. In all practicality, there will be a point where the player can't navigate safely through a given level, and so the game always ends with a crash. Think of it as an endurance run where we already know the outcome – it's the journey that's the point.</p><p>The level consists of a cave-like structure with walls on both sides of the screen. These walls are irregular and random and together form a safe path for the ship. If the ship touches the edges, the game is over.</p><div><img src="img/9403_08_01.jpg" alt="Getting on with it"/></div><p>To make things a <a id="id839" class="indexterm"/>little more difficult, there are obstacles that get in the ship's way. In the first levels, they don't appear very often, but as the levels get harder, the obstacles appear more often. The obstacle looks like a <em>wall</em> with an opening cut out, and the ship must pass within the opening in order to be safe.</p><p>Our levels will be randomly generated according to certain parameters in order to create an ever-changing landscape. Even though our levels are random, you could just easily create static levels and load them in wherever necessary, something which we suggest at the end of the project.</p><p>Our ship will be very simple: a triangle. Yes, one can get a lot more complicated with animation and such, but for the simple visual style of our game, it works well for our needs.</p><p>In order to move the ship, the player has two options: touch or swipe the screen in order to control the ship, or tilt the device. The ship will move according to the direction of the swipe or the tilt, that is, tilting or swiping left will move the ship left, and vice versa. Since we're calling our character a <em>ship</em>, we're intentionally introducing some fuzzy mechanics to the movement. In other words, the ship doesn't respond instantly, nor does it stop instantly. Think of the ship as if it has thrusters on it.</p><p>Of course, we could have decided that the position of the ship was directly related to the position of the finger on the screen or the degree of the tilt, and for some games this would be appropriate. It is always important to recognize that you should tailor your control mechanism to your game and use what makes sense.</p><p>Our game itself will be contained within one view—the game view. Outside of the game will live the start view and an options view. The start view contains two buttons, namely, <strong>Play</strong> and <strong>Options</strong>. Tapping on <strong>Play</strong> will switch to the game view, while the <strong>Options</strong> button will switch to the options view.</p><p>The options view gives<a id="id840" class="indexterm"/> two iconic representations of controlling movement: one for tilting the device and one for sliding a finger across the screen. Tapping either of these elements will select that method as the control method. An additional <strong>Back</strong> button lets the user get back to the start view.</p><p>Inside the game view we have several items that need to be displayed. Of course, the level and the ship are required, but games often display other information as well. In our case, we'll display the current level and the distance travelled through the level. Should we need to display a message (such as <strong>*Crash!*</strong> or <strong>Level Complete</strong>) we'll show it in the middle of the screen along with two buttons: one to restart or continue, depending on the situation, and one to go back to the game view.</p><p>And that's it, really; it's not a complicated game, and yet it can provide a base for more complicated endeavors in the future.</p><p>Let's have a quick look at our graphical assets before we wrap this task up. Our splash screen looks like this:</p><div><img src="img/9403_08_02.jpg" alt="Getting on with it"/></div><p>Our control icons will look like this:</p><div><img src="img/9403_08_03.jpg" alt="Getting on with it"/></div><p>Our buttons that we <a id="id841" class="indexterm"/>use throughout the game won't require any graphical assets. We'll just use a rounded rectangle with a border and shadow, which we can accomplish with CSS.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec161"/>What did we do?</h2></div></div></div><p>In this task we designed our game mechanics and assets. We've figured out the views we need as well.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec162"/>What else do I need to know?</h2></div></div></div><p>By no means is game <a id="id842" class="indexterm"/>design this simple. We can quickly go through this particular game partly because it is both simple and the mechanism is also well known. Even slightly more complex games will require a good deal of time to design, and it is best to do so before even writing a single line of code. Figure out your visual style, your sound style, the mechanics of the game, control mechanisms, levels, and animations. All of this will take time and lots of paper.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Implementing the options view</h1></div></div></div><p>The start view is a simple view <a id="id843" class="indexterm"/>
<a id="id844" class="indexterm"/>that we're not going to dwell on; feel free to look at the code in <code class="literal">www/views/startView.html</code>. In this task we'll focus on the options view located in <code class="literal">www/views/optionsView.html</code>. It's only moderately more complex than the start view, so some of the code is very similar.</p><p>When done, we'll have something that looks like the following screenshot:</p><div><img src="img/9403_08_05.jpg" alt="Implementing the options view"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec163"/>Getting on with it</h2></div></div></div><p>Let's take a look at the HTML for the view first:</p><div><pre class="programlisting">&lt;div class="viewBackground"&gt;
    &lt;div id="optionsView_contentArea" style="padding: 0; height: auto; position: relative;"&gt;&lt;/div&gt;
&lt;/div&gt;</pre></div><p>The first portion is very simple; the actual content is in a template that we'll process for localization:</p><div><pre class="programlisting">&lt;div id="optionsView_actions" class="hidden"&gt;
 &lt;div id="optionsView_changeControls"&gt;
  &lt;div id="optionsView_tilt" ontouchend="optionsView.selectTilt();" &gt;&lt;img src="img/tilt.png" width=128 height=128&gt;
    %TILT%
  &lt;/div&gt;
  &lt;div id="optionsView_slide" ontouchend="optionsView.selectSlide();"&gt;&lt;img src="img/slide.png" width=128 height=128&gt;
    %SLIDE%
  &lt;/div&gt;
  &lt;/div&gt;
 &lt;div id="optionsView_backButton" ontouchend="PKUI.CORE.popView();" &gt;%BACK%&lt;/div&gt;
&lt;/div&gt;</pre></div><p>In this part of the code, we've defined two methods of control. Touching either the <code class="literal">optionsView_tilt</code> or <code class="literal">optionsView_slide</code> icon will call the method to select that control method. The <strong>Back</strong> button will pop the view and return to the start view.</p><p>Note that we've not defined any styles here; the styling lives in <code class="literal">www/styles/style.css</code>. Here's the styling we're using for our view:</p><div><pre class="programlisting">#startView_contentArea,
#optionsView_contentArea
{
  background-image: url('../images/splash.png') !important;
  height: 100% !important;
}</pre></div><p>We're using a <a id="id845" class="indexterm"/>
<a id="id846" class="indexterm"/>background image for our start and options view (but not the game view), which we define in the preceding code. This puts a nice image behind our controls, so we need to be careful where we place the buttons so as to not overwrite any critical text or graphical elements.</p><p>Each button is styled as follows:</p><div><pre class="programlisting">…
#optionsView_backButton,
…
{
  position: absolute;
  left: 50px;
  width: 200px;
  background-color: #8BF;
  height: 2em;
  font-size: 24pt;
  line-height: 1.75em;
  text-align: center;
  color: white;
  border: 4px solid white;
  border-radius: 1em;
  text-shadow: 0 1px 1px #000;
  box-shadow: 0px 10px 20px #000, 1px 1px 1px #000 inset;
  -webkit-transform: rotate(-12deg);
}</pre></div><p>This gives us a <a id="id847" class="indexterm"/>
<a id="id848" class="indexterm"/>nice rounded button with bright colors as seen in the screenshot heading this section. It's also slightly rotated off-kilter, something games can usually get away with. Doing this in a productivity application wouldn't be all that good an idea.</p><div><pre class="programlisting">#optionsView_backButton
{
  top: 300px;
  left: 32px;
  -webkit-transform: rotate(12deg);
}</pre></div><p>For each button, we have to specify the location of the button, and if we want, we also override the rotation to have buttons in different rotations on the screen.</p><div><pre class="programlisting">#optionsView_changeControls
{
  position: absolute;
  top: 120px;
  left: 32px;
  width: 256px;
}</pre></div><p>For our control selection, we first indicate where the icons will live, in the preceding code snippet, and then specify each one's properties as follows:</p><div><pre class="programlisting">#optionsView_tilt,
#optionsView_slide
{
  width: 128px;
  text-align: center;
  font-family: "Bradley Hand",sans-serif;
  font-size: 24pt;
  color: #FFFF80;
  text-shadow: 0px -1px 1px #000;
  height: 160px;
  float: left;
  color: #FFFFFF;
}</pre></div><p>The font, in this case, gives us a handwritten feel. Note that we provide a fallback in case the device doesn't support this font, which is likely on Android devices. All recent iOS devices provide this font automatically.</p><div><pre class="programlisting">#optionsView_tilt.selected,
#optionsView_slide.selected
{
  color: #FFFF80;
  background-color: rgba(255,255,255,0.25);
  border-radius: 25px;
}</pre></div><p>When selected, we <a id="id849" class="indexterm"/>
<a id="id850" class="indexterm"/>change the color of the text and make the selected item appear to be highlighted.</p><p>Let's take a look at the code; it's really pretty simple:</p><div><pre class="programlisting">  var optionsView = $ge("optionsView") || {};

  optionsView.initializeView = function()
  {

    $ge("optionsView_contentArea").innerHTML =
    
    PKUTIL.instanceOfTemplate ( $ge("optionsView_actions"),
    { "tilt": __T("TILT"),
    "slide": __T("SLIDE"),
    "back": __T("BACK")
    }
    );
    
    optionsView.displayControlSetting();
    
  }</pre></div><p>As always, our <code class="literal">initializeView</code> method<a id="id851" class="indexterm"/> is used to set the view up and perform the necessary localization. It also calls <code class="literal">displayControlSetting</code>, which will highlight the appropriate control method:</p><div><pre class="programlisting">  optionsView.displayControlSetting = function ()
  {
    $ge("optionsView_slide").className="";
    $ge("optionsView_tilt").className="";
    if (localStorage.controlSetting)
    {
      // use the saved setting
      if (localStorage.controlSetting == "slide")
      {
        $ge("optionsView_slide").className="selected";
      }
      else
      {
        $ge("optionsView_tilt").className="selected";
      }
    }
    else
    {
      // default to the slide control option
    $ge("optionsView_slide").className="selected";
    }
  }</pre></div><p>Notice that we're using <code class="literal">localStorage</code> here; it's almost so subtle you could miss it. First we check for the existence of our desired property (<code class="literal">controlSetting</code>). If it doesn't exist, we default to the <em>slide</em> control method. If it does exist, we'll use whichever value is stored in the property.</p><p>While <code class="literal">localStorage</code> isn't <a id="id852" class="indexterm"/>
<a id="id853" class="indexterm"/>guaranteed to be 100 percent persistent (iOS has the option to delete it should the device's space get low), it's good enough for these kinds of settings.</p><p>When the user taps one of the control methods, we set <code class="literal">localStorage.controlSetting</code> as follows:</p><div><pre class="programlisting">  optionsView.selectTilt = function ()
  {
    localStorage.controlSetting = "tilt";
    optionsView.displayControlSetting();
  }

  optionsView.selectSlide = function ()
  {
    localStorage.controlSetting = "slide";
    optionsView.displayControlSetting();
  }</pre></div><p>From this point on, the code is like we've used before, so we won't reprint it here.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec164"/>What did we do?</h2></div></div></div><p>In this task, we created our options view. We created the ability for the user to select either a <em>tilt</em> or <em>swipe</em> control method for their character, and we have used <code class="literal">localStorage</code> to both save and read back the user's preference.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec165"/>What else do I need to know?</h2></div></div></div><p>What if the user sees this screen and decides that <em>swipe</em> is the control method they want? This means we never set a property within <code class="literal">localStorage</code>. This means that when the game starts, how will it know which control method to use?</p><p>Simple, we'll do a check <a id="id854" class="indexterm"/>
<a id="id855" class="indexterm"/>there too. If there's nothing in <code class="literal">localStorage</code>, we'll assume the user wants to use the swipe method. The key here is to be consistent; if the game decided to use the tilt method instead, but displayed the swipe as the default in our options view, the player would obviously be confused as to which option means what.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Generating levels</h1></div></div></div><p>It's hard to imagine a game<a id="id856" class="indexterm"/>
<a id="id857" class="indexterm"/> without at least one level, and that level needs to have some sort of content in it. In this task, we'll examine how to generate content for the levels in our game.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec166"/>Getting ready</h2></div></div></div><p>Open the <code class="literal">gameView.html</code> file<a id="id858" class="indexterm"/> in <code class="literal">www/views</code>. We'll be using this file quite a bit, so it would be a good idea to have it open for reference.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec167"/>Getting on with it</h2></div></div></div><p>There are a few ways one can generate a level. One can use random content, pseudo-random content, or static content. The first is pretty easy: just use random numbers for everything. Unfortunately, this doesn't usually result in terribly nice levels, and there's little guarantee of winnability or difficulty.</p><p>The third method is also pretty easy: use static content. This means that you've determined the entire level ahead of time, and stored it in a file. When the game requests the level, it can be read back. This means it is the same every time, which can be good (or bad), depending on the game, but it also means that you have a clear way to ensure both winnability and difficulty. For puzzle games, this is nearly always the method one uses.</p><p>Our method is to be pseudo-random. We'll be using plenty of random numbers; we don't want perfectly straight cave walls or easily-guessed paths. But we also want to build in some level of increase in difficulty over time, as well as restrict the levels to a few parameters to help ensure (though not guarantee) winnability. It is possible to guarantee a level can be winnable with enough code, but we won't go quite that far in this game.</p><p>Let's go through the code used to generate a level using the following code snippet:</p><div><pre class="programlisting">function generateLevel ( lvl )
{
    points = new Array();
    points[0] = new Array();
    points[1] = new Array();
    points[2] = new Array();
    points[3] = new Array();</pre></div><p>First we initialize our<a id="id859" class="indexterm"/> <code class="literal">points[]</code> array, and then four arrays within it. The first two arrays contain the left and right points that make up the cave wall. The last two contain the edges of any obstacle opening, or <code class="literal">-1</code> if there is no obstacle in place.</p><div><pre class="programlisting">    …    

    var lastLeft= (cWidth/5) ;
    var lastRight=(cWidth/5) ;</pre></div><p>Next, we start to <a id="id860" class="indexterm"/>
<a id="id861" class="indexterm"/>define some variables that we'll be using to control our level. These two variables store the last points generated for the cave, but we need to have something to start from as well. <code class="literal">cWidth</code> <a id="id862" class="indexterm"/>is defined earlier in the file as being the width of the screen, so you can see how this would generate an open area in the middle of the screen at the beginning of our level. This is important, since we don't want to surprise the player with an immediate obstacle they can't avoid.</p><div><pre class="programlisting">    var bias = 0;</pre></div><p>
<code class="literal">bias</code> controls the <a id="id863" class="indexterm"/>direction our cave walls will tend towards. They'll still be randomly generated, but we introduce <code class="literal">bias</code> whenever the walls hit the edge of the screen so that there is always some movement.</p><div><pre class="programlisting">    var rndWidth = Math.floor(cWidth/ 10) + (lvl*10);</pre></div><p>
<code class="literal">rndWidth</code> <a id="id864" class="indexterm"/>controls how much our cave wall can vary over a particular distance. In this case, it is controlled by the width of the screen and our current level. This means the cave gets harder to navigate as we progress through our levels.</p><div><pre class="programlisting">    var channelWidth = Math.floor(cWidth / 2.25) - (lvl*16);</pre></div><p>
<code class="literal">channelWidth</code>, on the other hand, limits just how close the cave walls can get. It's also based on the width of the<a id="id865" class="indexterm"/> screen and the level. You'll notice that at some high level, the channel will be too small to permit passage of the ship. At this point, the game can be considered over, or one could also build in a way to prevent this value from ever getting too small.</p><div><pre class="programlisting">    var wallChance = 0.75 - (lvl/25);
    if (wallChance &lt; 0.15) { wallChance = 0.15; };</pre></div><p>An obstacle, or wall, is only generated every so often; we don't want an obstacle to appear at every point. So we generate some sort of chance that is also based on the level. Easier levels will have fewer obstacles, while harder levels will have several.</p><div><pre class="programlisting">    var wallEvery = Math.floor(30 - (lvl/2));
    if (wallEvery &lt; 10) { wallEvery = 10; };</pre></div><p>
<code class="literal">wallEvery</code> also<a id="id866" class="indexterm"/> factors in <a id="id867" class="indexterm"/>
<a id="id868" class="indexterm"/>how often obstacles appear, but in a different way. It controls how many points must be between an obstacle before it can have a chance to be generated. In this case, we'll start off at 29 points, but will steadily lower it as the levels increase. This means obstacles will not only appear more often, but closer together.</p><div><pre class="programlisting">    for (var i=0; i&lt; Math.floor(300 + ( 125 * (lvl/2) )); i++)
    { </pre></div><p>Next, we want to create a cave several hundred points long. The first level will start out with 366 points, and will only increase from there.</p><div><pre class="programlisting">        var newLeft = lastLeft + ( bias * (7+lvl) ) + ( (rndWidth/2) - Math.floor( Math.random()* (rndWidth+1) ) );
        var newRight = lastRight + ( bias * (7+lvl) )  + ( (rndWidth/2) - Math.floor( Math.random()* (rndWidth+1) ) );</pre></div><p>For each point, we determine the left and right side of the cave. We base this on the previous point, add in <code class="literal">bias</code> (increased with the level), and then add a random number within our allowed width, and we have a cavern wall that will vary by a random amount, but not by so much (at least in the first levels) that the level will be impossible.</p><div><pre class="programlisting">        if ( newLeft &lt; 10 ) { newLeft = 10; bias = 1; }
        if ( newLeft &gt; (cWidth/1.5) ) { newLeft = cWidth/1.5; bias = -1; }
        if ( cWidth - newRight &lt; newLeft + channelWidth )
        {
          newRight = cWidth - ( newLeft + (channelWidth) );
        }
        if ( cWidth - newRight &gt; newLeft + (channelWidth*1.5))
        {
          newRight = newRight + (Math.random() * rndWidth);
        }
        if ( newRight &lt; 10 ) { newRight = 10; }
        if ( newRight &gt; (cWidth-10)) { newRight = cWidth-10; }</pre></div><p>Of course, without a few restrictions on the sides, it would be possible for the cave to wander off the screen, which does the player no good if they can't see it. So, we keep the cave on the screen. For the first two restrictions, we also affect the <code class="literal">bias</code>; this will tend to give the cave a zig-zag pattern overall.</p><div><pre class="programlisting">        points[0].push ( newLeft );
        points[1].push ( newRight );
  
        lastLeft = newLeft;
        lastRight = newRight;</pre></div><p>Finally, we add the points to the array and store them for future reference (the next iteration in the loop).</p><div><pre class="programlisting">        if ( (i % wallEvery) == 0 &amp;&amp; ( i &gt; 30 ) )
        {</pre></div><p>Next, we determine if it <a id="id869" class="indexterm"/>
<a id="id870" class="indexterm"/>is time to put an obstacle in the way. First, we only check every so often (<code class="literal">wallEvery</code>), and we also restrict any obstacle from appearing within the first 30 points of the cave.</p><div><pre class="programlisting">            if (Math.random()&gt;wallChance)
            {</pre></div><p>Next we decide if a wall will appear at this point; this makes obstacles pretty rare early on, but they add up in later levels.</p><div><pre class="programlisting">                var openingWidth = channelWidth/1.35;
                var caveWidth = ((cWidth-newRight) - newLeft) - openingWidth;
                var wallOpening = Math.floor ( Math.random() * caveWidth );
                points[2].push ( newLeft + wallOpening );
                points[3].push ( newLeft + wallOpening + openingWidth );</pre></div><p>For the obstacle, we create an opening that is a smaller opening than the width of the cave; this means the wall juts out from the cave by some degree. We then determine some random value within the range of the cave's opening and that's where the opening will go.</p><div><pre class="programlisting">            }
            else   
               // no wall
                points[2].push ( -1 );
                points[3].push ( -1 );    
            }
        }
        else   
           // no wall
            points[2].push ( -1 );
            points[3].push ( -1 );    
        }
    }
}</pre></div><p>If there is no obstacle, we push <code class="literal">-1</code>; this way we can know if there's an obstacle (or not) at any given point.</p><p>And that's it! This will create a long, winding cave that's more treacherous the higher the level.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec168"/>What did we do?</h2></div></div></div><p>In this task, we generated the levels for our game, based on pseudo-random generation with some specific rules in place to create levels increasing in difficulty over the course of the game.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec169"/>What else do I need to know?</h2></div></div></div><p>This isn't the only way<a id="id871" class="indexterm"/>
<a id="id872" class="indexterm"/> to generate a pseudo-random level, of course. There's all sorts of ways that are beyond the scope of this book, and there are things you can do to ensure that a level always stays winnable too. Level generation is a subject all on its own (with many, many smart people working in the field), so it won't take long to get your mind blown with some of the level-generation techniques out there. See <a class="ulink" href="http://en.wikipedia.org/wiki/Procedural_generation">http://en.wikipedia.org/wiki/Procedural_generation</a> for examples of games that generate their levels procedurally as well as some links to articles describing various ways to generate levels procedurally. Keep in mind that this is highly specific to the kind of game you're developing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Drawing to the canvas</h1></div></div></div><p>Of course, it does no <a id="id873" class="indexterm"/>
<a id="id874" class="indexterm"/>good to generate a level if we don't display it to the player. That's what we'll be doing in this task.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec170"/>Getting on with it</h2></div></div></div><p>First, we set the canvas up, also taking care to deal with retina screens in the process.</p><div><pre class="programlisting">var c = $ge("gameView_canvas");
var ctx = c.getContext("2d");

c.setAttribute ("width", cWidth * window.devicePixelRatio);
c.setAttribute ("height",cHeight * window.devicePixelRatio);
c.setAttribute ("left", (screen.width/2) - (cWidth/2));
c.style.width = ""+cWidth+"px"; 
c.style.height = ""+cHeight+"px";</pre></div><p>We store these as<a id="id875" class="indexterm"/>
<a id="id876" class="indexterm"/> global variables, because it is important not to have to do DOM walking for every frame of content—that only slows us down—something that is a bad thing when we're trying to render a frame within 16 milliseconds (the maximum amount of time we can take if we're targeting 60 fps).</p><div><pre class="programlisting">function doAnim(timestamp)
{ 
…

    ctx.save();
    ctx.scale (window.devicePixelRatio, window.devicePixelRatio);
    ctx.fillStyle = "#802010";
    ctx.strokeStyle = "#A04020";
    ctx.clearRect ( 0, 0, cWidth, cHeight);</pre></div><p>Next, we set up a few properties and then clear the canvas. It is critical to clear the canvas for every frame; otherwise you'll end up leaving ghosts behind of the previous frame.</p><p>Then we draw both sides of the cave using a loop:</p><div><pre class="programlisting">    for (var i=0; i&lt;2; i++)
    {
        var pts;
        var cLeft = -10;
        if (i==0) { pts = points[0]; }
        if (i==1) { pts = points[1]; cLeft = cWidth+10; }</pre></div><p>Based on which part of the cave we're drawing, we assign either the <code class="literal">0</code> or <code class="literal">1</code> index of <code class="literal">points[]</code> to another variable, <code class="literal">pts</code>. This lets us avoid having to double index the points array such as <code class="literal">points[i][x]</code> and use <code class="literal">pts[x]</code> instead. We also define the left (or right) side of the wall that is off screen; this comes in handy for drawing the cave, since we need to fill the cave walls to make them solid. This means we are essentially drawing a big rectangle with one portion of it very rough; the rough side being the cave wall.</p><div><pre class="programlisting">        ctx.beginPath(); 
        ctx.moveTo ( cLeft, -pieceWidth );</pre></div><p>We begin the path and then move to the leftmost, topmost portion of the canvas; in fact, quite a way off of it. This ensures the player never sees the edge of the big rectangle we're drawing.</p><div><pre class="programlisting">        for (var j = Math.floor ( currentTop  / pieceWidth )-1; 
            j &lt; Math.floor ( currentTop / pieceWidth ) + ( (cHeight+(2*pieceWidth)) / pieceWidth );
            j++)
        {</pre></div><p>Next, we loop through each point in the array, but only over the ones necessary. If the player is halfway through the level, there's no point in drawing the previous points, nor is there any point in drawing parts of the cave that are beyond the screen's height.</p><div><pre class="programlisting">            var p = pts[j];
            var y = (j * pieceWidth) - currentTop;</pre></div><p>In order to keep<a id="id877" class="indexterm"/>
<a id="id878" class="indexterm"/> the motion of the cave smooth, we multiply the current piece by the piece width and subtract our current position in the level. Technically, this would result in a jumpy view at the first and last drawn index, but we're drawing a couple of points beyond both sides, so any jumpiness is kept off screen.</p><div><pre class="programlisting">            if (i==1) { p = cWidth - p; }
            ctx.lineTo ( p, y );</pre></div><p>Next, we draw a line to the given point. If we're working on the right side, the point is to the left of the screen's right edge, which is the right side of the cave.</p><div><pre class="programlisting">             if ( points[2][j] &gt; -1 )
            {
              ctx.lineTo ( points[i+2][j], y );
              ctx.lineTo ( points[i+2][j], y+pieceWidth );
            }</pre></div><p>If we have an obstacle to display, we also draw a line to the point and then a vertical line one <code class="literal">pieceWidth</code> high. This will cause the obstacle to appear like a wall with an opening in it.</p><div><pre class="programlisting">        }
        ctx.lineTo ( cLeft, ((cWidth+2)*pieceWidth) );
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }</pre></div><p>Finally, we draw a line off screen again, and then proceed to fill and stroke the path. The player will only see the rough edges of the cave wall.</p><div><pre class="programlisting">    ctx.strokeStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.moveTo ( shipPositionX-10, shipPositionY-5 );
    ctx.lineTo ( shipPositionX+10, shipPositionY-5 );
    ctx.lineTo ( shipPositionX   , shipPositionY+25 );
    ctx.lineTo ( shipPositionX-10, shipPositionY-5 );
    ctx.closePath();
    ctx.stroke();</pre></div><p>After we draw the cave walls, we need to draw the ship. In this case, we draw a simple triangle.</p><div><pre class="programlisting">    ctx.fillStyle = "#FFFF00";
    ctx.font = "16px Helvetica";
    ctx.fillText ( "Level: " + currentLevel, 10, 30 );
    ctx.fillText ( "Distance: " + Math.floor((currentTop / (points[0].length*pieceWidth))*100) + "%", 10, 48 );</pre></div><p>Generally most games <a id="id879" class="indexterm"/>
<a id="id880" class="indexterm"/>need to display some text (such as a score), and so we do something similar too. We show the current level and the distance travelled through the level.</p><div><pre class="programlisting">    if (amTouching)
    {
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      ctx.beginPath();
      ctx.arc ( lastTouchX, 400, 50, 0, 2*Math.PI, false );
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

…
}</pre></div><p>Finally, if the user's control method is swiping, we display a translucent circle where the user is touching (assuming it is at the bottom of the screen) so that the user knows that the touch has been registered.</p><p>Keep in mind that when drawing a frame, we need to be quick, and thankfully the operations that we just saw depend on the hardware; we can achieve a frame within a few milliseconds. If we stay under 17 milliseconds, we can achieve nearly 60 fps, though on older hardware, this is more like 20-30 milliseconds. So we need to do something else, which we'll cover next, that is, drop frames so that the game doesn't feel too sluggish.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec171"/>What did we do?</h2></div></div></div><p>In this task, we drew the level on the canvas, displayed the ship, and put various text on the canvas as well. We also kept it quick, something we could only do by using the <code class="literal">canvas</code> tag.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec172"/>What else do I need to know?</h2></div></div></div><p>Of course, the <a id="id881" class="indexterm"/>
<a id="id882" class="indexterm"/>preceding code only draws one frame; we need to call it multiple times in order to achieve fluid scrolling. There are two ways to do this: we can use <code class="literal">setTimeout</code> or use <code class="literal">requestAnimationFrame</code>. The latter is preferred, as it has better resolution than <code class="literal">setTimeout</code>, but it isn't yet supported in all mobile browsers. For our purposes, we use <code class="literal">setTimeout</code>. It calls in <code class="literal">doUpdate</code>, which we'll go over later, rather than <code class="literal">doAnim</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Keeping up</h1></div></div></div><p>Even if we can't hit 60 fps, we need to act like we are hitting 60 fps anyway. If we don't, any slowdowns will cause the game to feel as if it was in slow-mo. Instead, we need to <em>drop frames</em> and move things along as if we were getting 60 fps. The display will not be as smooth, but the gameplay won't get that slow-mo feeling until we drop down to a really low frame rate.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec173"/>Getting on with it</h2></div></div></div><p>If you were<a id="id883" class="indexterm"/> paying close attention to our code in the last task, you'll notice that we skipped a few lines. These were the lines crucial to keeping the game progressing as if it were hitting 60 fps:</p><div><pre class="programlisting">var startTime;
function doAnim(timestamp)
{ 
    if (!timestamp) { 
    timestamp = (new Date()).getTime(); 
    }
    var diff = timestamp - startTime;
…
    doUpdate ( 60/(1000/diff) );
    startTime = timestamp;
}</pre></div><p>All we're doing is measuring the time between frames and then applying some math to it. We then pass this in to <code class="literal">doUpdate</code>, which we'll discuss later. This number equates to the number of frames that should have passed in a given period of time. If we're at 60 fps, we'll always end up with this number being 1; but if we're at 30 fps, the number will be 2; and at 15 fps it will be 4, and so on. Since the number can be fractional, we can be very fine-grained when updating our game.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec174"/>What did we do?</h2></div></div></div><p>So, that was short, <a id="id884" class="indexterm"/>but it's not a terribly complicated concept. But it is very important; without it, if the device slowed down for any reason, the game would slow down too, making it feel as if it was in slow-motion. Instead, we'll drop the frames in order to keep the speed up. It won't be as smooth, but gameplay should always trump getting every frame in.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Performing updates</h1></div></div></div><p>Of course, drawing the<a id="id885" class="indexterm"/>
<a id="id886" class="indexterm"/> same frame over and over won't do any good. We need to update the game too. This includes responding to user input, checking for collisions, and moving us along the cave.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec175"/>Getting on with it</h2></div></div></div><p>We'll be doing all our updating in… guess what! <code class="literal">doUpdate</code>:</p><div><pre class="programlisting">function doUpdate ( f )
{</pre></div><p>If you recall from the last task, <code class="literal">f</code> is the incoming frame multiplier. We want this to be 1, but it might be 2 if we're getting 30 fps, or 4 if we're getting 15. We'll use this at various points to multiply any updates so that everything moves as if we were getting 60 fps, even when we aren't.</p><div><pre class="programlisting">    var gameOver = false;
    var levelOver = false;
    var pixels = ctx.getImageData(Math.floor(shipPositionX * window.devicePixelRatio), 
    Math.floor(shipPositionY * window.devicePixelRatio),1,1).data;</pre></div><p>There are the various methods of doing collision detection. We could determine it mathematically, but that gets more than a bit painful. Instead, we'll use the canvas' own data and do pixel-based collision detection instead.</p><p>The preceding line requests very little data from the canvas. In fact, we're only checking the center point of the ship for a collision. Part of this is so that we can be lenient on the user, part of it is laziness, but the other part is that pixel-based collision detection using the canvas is horribly slow. In fact, just checking for one pixel cuts our fps nearly in half.</p><div><pre class="programlisting">    if ( pixels[0] != 0 )
    {
      $ge("gameView_nextButton").innerHTML = __T("START_OVER");
      showMessage (__T('CRASHED'));
      gameOver = true;
      currentLevel = 0;
    }</pre></div><p>If the pixel data in the data returned from the canvas is not zero (black), then we know we've impacted on something; what we've hit doesn't matter. We mark the game as over, and tell the user about it.</p><div><pre class="programlisting">    if (f &gt; 0 &amp;&amp; f != Infinity)
    {</pre></div><p>Sometimes <code class="literal">f</code> comes in <a id="id887" class="indexterm"/>
<a id="id888" class="indexterm"/>as <code class="literal">0</code> or <code class="literal">Infinity</code>. This is most often at the start of a game, when we have to pass in a time difference, but there's not really been any. In this case, the division in <code class="literal">doAnim</code> will return <code class="literal">infinity</code>. We don't want to do anything in either case, so we make sure that we only operate if <code class="literal">f</code> is a reasonable value.</p><div><pre class="programlisting">if (controlMethod == 0)
   {
      if (buttonDown != 0)
        {
          if (Math.abs(shipAcceleration)&lt;1)
            { shipAcceleration = buttonDown; } 
              shipAcceleration = Math.min ( 10, shipAcceleration + ( buttonDown * deviceFactor) );
              //shipAcceleration = buttonDown * 3;
            }
            else  
            {
              shipAcceleration = shipAcceleration / 1.5;
              if (Math.abs(shipAcceleration)&lt;0.25)
              { shipAcceleration = 0; }
            }
            shipPositionX += (shipAcceleration*f);
        }</pre></div><p>
<code class="literal">buttonDown</code> reflects the user's input if they are using touch controls. If they are sliding left, <code class="literal">buttonDown</code> will be negative. If they are going to the right, <code class="literal">buttonDown</code> will be positive. If they aren't doing anything, it will be zero. If they are using tilt controls, we'll calculate this value differently, but we'll show that in the next section.</p><p>If we're non-zero, we <a id="id889" class="indexterm"/>
<a id="id890" class="indexterm"/>build up some acceleration, as if a thruster was on the ship. Since thrusters can't react instantly, the ship takes a little bit to react. This has the effect of making the game a little harder; one has to take into account the reaction time of the ship.</p><p>If we're zero, we reduce the acceleration, as if the ship was coasting to a stop. Once we reach a certain threshold, we stop the ship entirely, but until that point, there is some movement. Again, this adds some difficulty, as it must be considered when moving the ship.</p><p>One important variable in the preceding code snippet is <code class="literal">deviceFactor</code>. This is subjective; when the ship's movement felt right on an Android device, it felt too slow on an iOS device, and so this variable compensates a bit for that difference. Never be afraid to tweak the movement mechanics on different devices so that it feels the same, even if it isn't technically the same.</p><p>Note that we multiply the acceleration by <code class="literal">f</code>; this keeps the ship's movement working as if it were happening in a game with 60 fps.</p><div><pre class="programlisting">      var speed = ((4+currentLevel) * (f));
      currentTop+= speed;
    }</pre></div><p>Next, we calculate the vertical distance through the cave, which is done by adding a number to <code class="literal">currentTop</code>. We adjust it slowly based on the current level as well, so higher levels will get faster and faster. Again, we multiply by <code class="literal">f</code> to keep things feeling smooth.</p><div><pre class="programlisting">    if ( Math.floor (currentTop/pieceWidth) &gt; points[0].length )
    {
      $ge("gameView_nextButton").innerHTML = __T("CONTINUE");
      showMessage (__T('NEXT_LEVEL'));
      levelOver = true;
    }</pre></div><p>If the player has managed to navigate the entire level, we need to stop the game and tell the user that they made it. When they continue, they'll pick up at the next higher level.</p><div><pre class="programlisting">    if (!gameOver &amp;&amp; !levelOver)
    {
      timer = setTimeout ( doAnim,17);
    }
}</pre></div><p>Here's our <code class="literal">setTimeout</code> that keeps everything going. Note that we do this unless the game is over or the level is over. If one wanted to add a pause feature, one would also avoid setting a timer at this point.</p><p>The <code class="literal">17</code> here is<a id="id891" class="indexterm"/>
<a id="id892" class="indexterm"/> intended to get us as close to 60 fps as possible. It doesn't work out to that in reality, as browsers don't have good resolution, so the next frame could arrive in 12 milliseconds or in 30. WebKit, thankfully, has something on the order of 4 milliseconds resolution, so it isn't likely to be far off of <code class="literal">17</code>, and so we can get up to 56 fps, assuming a modern device.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec176"/>What did we do?</h2></div></div></div><p>In this task, we handled the updating of the ship's position, the position in the cave, and whether or not we crashed, or completed the level.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec177"/>What else do I need to know?</h2></div></div></div><p>Yeah, pixel-based collision detection is a pretty lazy way out. In nearly every circumstance, math-based collision detection is the better (and faster) way to do it. There's lots of good stuff out there about how to do good collision detection, and it falls out of the scope of this project. You might start with <a class="ulink" href="http://en.wikipedia.org/wiki/Collision_detection">http://en.wikipedia.org/wiki/Collision_detection</a> for more information.</p><p>It wouldn't be quite so bad in our game if it wasn't for the fact that even requesting a single pixel from the canvas data drops our frame rate by nearly half. I suspect this has to do with having to transfer the data off of the GPU and back to the CPU for processing, but that's just a guess. Even so, it's a bit painful, and if I'd had more caffeine when writing the collision detection routines, I'd have gone the math route.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Handling touch-based input</h1></div></div></div><p>Since we don't have a <a id="id893" class="indexterm"/>
<a id="id894" class="indexterm"/>physical keyboard or joystick or D-pad, we have to emulate one on the screen. We could do this with two buttons on the screen for our game: one to go left, and one to go right. In fact, the game has it built in, just hidden. Another way is to allow for the differences in how a swipe might occur: a slow movement when our ship is not in danger, or a sudden movement when we need to avoid an obstacle in a hurry. Another method would be to simply link up the touch position on the screen to the ship; essentially our finger would have to trace the path through the cave. For smaller devices this might be fine, but for larger devices, it is better to go with some other method.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec178"/>Getting on with it</h2></div></div></div><p>In our game, our touch input can handle swipes (where the finger isn't always on the screen) to move the ship in short bursts, or it can handle long drags where the finger is always on the screen and slight movements generate movement.</p><p>To put it simply: if we <a id="id895" class="indexterm"/>
<a id="id896" class="indexterm"/>move left, the ship should move left, and vice versa. However, if we need to get out of an obstacle's way in a hurry, we shouldn't have to move a long distance. We should be able to move a short distance in a quick burst, and so we also measure the distance between movements so we can tune the ship's movement to how fast our finger is moving. If the finger is moving slowly, the ship moves slowly. If it moves quickly, the ship moves really quickly.</p><p>None of this is hard; in fact, the hardest part isn't making it work, it's making it work well. It's hard to make a control method feel totally natural, and I won't claim to have mastered it here. It takes lots of testing to get a control mechanism just right.</p><p>Let's look at our code:</p><div><pre class="programlisting">    // check to see if our control method has changed
    if (!localStorage.controlSetting)
    {
      localStorage.controlSetting = "slide";
    }
    controlMethod = ( (localStorage.controlSetting) == "slide" ? 0 : 1 );</pre></div><p>Before the game starts, we check the control method the user has selected – remember the options view. If the control method is <code class="literal">slide</code>, we'll attach events to an overlay <code class="literal">DIV</code>:</p><div><pre class="programlisting">    if (controlMethod == 0)
    {
      $ge("gameView_overlay").addEventListener ( "touchstart", canvasTouchStart );
      $ge("gameView_overlay").addEventListener ( "touchmove",  canvasTouchMove  );
      $ge("gameView_overlay").addEventListener ( "touchend",   canvasTouchEnd   );
    }</pre></div><p>This overlay literally covers the entire canvas. You may wonder why we have to use an overlay—it turns out that the canvas itself isn't always so hot at handling touch events!</p><div><pre class="programlisting">function canvasTouchStart (evt)
{
  lastTouchX = evt.touches[0].pageX;
  amTouching = true;
}</pre></div><p>When a finger touches<a id="id897" class="indexterm"/>
<a id="id898" class="indexterm"/> the screen, we record the initial touch, and tell the game that a finger is touching the screen. If you remember <code class="literal">doUpdate</code>, this last part tells the game to draw a translucent circle at the x position of the touch to give the user feedback.</p><div><pre class="programlisting">function canvasTouchMove (evt)
{
  if (touchTimer&gt;-1) { clearTimeout(touchTimer); touchTimer = -1; }
  var curTouchX = evt.touches[0].pageX;
  var deltaX = curTouchX-lastTouchX;
  if (Math.abs(deltaX)&gt; 1)
  {
    buttonDown = ( (deltaX) / Math.abs(deltaX) ) / ( 8/Math.min(Math.abs(deltaX),8));
    lastTouchX = curTouchX;
  }
  else
  {
    buttonDown = 0;
  }
  // if player stays in same spot, clear the button...
  touchTimer = setTimeout ( function() { buttonDown = 0; }, 25 );
}</pre></div><p>If a movement is received, we need to calculate the distance between the last x position and the new x position. We then give <code class="literal">buttonDown</code> a negative or positive value based on the direction of the movement. We also divide it if the movement was slow; if it was a fast movement (over five pixels), we'd have values of <code class="literal">-1</code> for left and <code class="literal">+1</code> for right, but a slow movement might return <code class="literal">-0.2</code> and <code class="literal">+0.2</code>.</p><p>If the finger hasn't moved by much (it needs to have moved by more than one pixel to register movement to the ship), then we indicate that <code class="literal">buttonDown</code> is <code class="literal">0</code>, so that the ship will coast to a stop. We also set up a timer to fire in a few short ms to turn <code class="literal">buttonDown</code> to zero as well. This is because we won't receive a <code class="literal">touchMove</code> event if the finger stays absolutely still, so we need a way to catch this. If a movement is received before the timer expires, we cancel the timer so that the value never becomes zero as long as there is adequate movement.</p><div><pre class="programlisting">function canvasTouchEnd (evt)
{
  buttonDown = 0;
  amTouching = false;
}</pre></div><p>When the finger is lifted, we will instantly allow the ship to coast to a stop, and stop displaying the translucent circle.</p><p>This isn't the<a id="id899" class="indexterm"/>
<a id="id900" class="indexterm"/> only way to do movement, and I urge you to experiment with different ways of processing touch-based input.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec179"/>What did we do?</h2></div></div></div><p>In this task, we dealt with touch-based input in order to allow the user to move our game's ship.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Handling the accelerometer</h1></div></div></div><p>In order to respond to the tilt <a id="id901" class="indexterm"/>
<a id="id902" class="indexterm"/>of the device, we need to use the device's accelerometer. These aren't the easiest things to deal with, and our implementation is a bit naïve. Unfortunately, it doesn't take long until you start getting into the math that's more than a bit complicated, and so lies outside the scope of this project.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec180"/>Getting on with it</h2></div></div></div><p>Accelerometer-based input is hard – really hard. So hard, in fact, that the game doesn't have a particularly good implementation of it. You are encouraged to experiment with a lot of devices and algorithms to come up with a good control scheme.</p><p>To turn on the accelerometer check, we first have to set up a watch for it:</p><div><pre class="programlisting">tiltWatch = navigator.accelerometer.watchAcceleration ( 
                    updateAccelerometer,
                      accelerometerError,
                      { frequency: 40 } );</pre></div><p>This sets up a 40 milliseconds watch–not really quite as fast as I'd like, but workable. Every 40 milliseconds, the <code class="literal">updateAccelerometer</code> method<a id="id903" class="indexterm"/> will be called. If an error occurs, then <code class="literal">accelerometerError</code> will be called.</p><p>Watching the accelerometer takes some effort, so when done with it, it is always a good idea to clear it:</p><div><pre class="programlisting">navigator.accelerometer.clearWatch (tiltWatch);
tiltWatch = -1;</pre></div><p>So what do we get with the accelerometer? We get an object containing four values: a timestamp, an x value, a y value, and a z value. These values indicate the acceleration in a given direction. If the device is lying flat on a table, the x and y values will be zero, while the z value will be equal to the force of gravity. Generally we can assume that the x value corresponds to left/right tilt (assuming the device is upright), which is all we need for our game.</p><div><pre class="programlisting">function updateAccelerometer ( a )
{
  if (amCalibrated)
  {
    var p = previousAccelerometer;
    var avgX = (p.x * 0.7) + (a.x * 0.3);
    previousAccelerometer = a;
    previousAccelerometer.x = avgX;
  }</pre></div><p>When we receive an <a id="id904" class="indexterm"/>
<a id="id905" class="indexterm"/>update, we apply a weighted average of the new input and the previous input, giving more weight to the previous input. It turns out that accelerometer-based input is really, really noisy, and so we only give the new input small importance. This has the side-effect, unfortunately, of making movement feel a little sluggish. The fractional values make a big difference in how well the ship responds, but at the trade-off of a ship that feels jittery. Feel free to experiment with these numbers, but they need to add up to one.</p><p>Note the<a id="id906" class="indexterm"/> <code class="literal">amCalibrated</code> variable; you could also compare the data to a calibrated value instead. The calibrated value is often obtained just before the level begins, when <code class="literal">amCalibrated</code> would be set to <code class="literal">false</code>. The next accelerometer update would calibrate the device:</p><div><pre class="programlisting">  else
  {
    calibratedAccelerometer = a;
    previousAccelerometer = a;
    amCalibrated = true;
  }
}</pre></div><p>A better way to calibrate the accelerometer would be to take a series of inputs and average them out. For that matter, that is the same way to smooth out the accelerometer itself; but those algorithms are beyond the scope of this book.</p><p>Now, let's go back to <code class="literal">doUpdate</code> and look at the code specific for the tilt-based input:</p><div><pre class="programlisting">    if (f &gt; 0 &amp;&amp; f != Infinity)
    {
        if (controlMethod == 0)
        {             
         …
        }
        else
        {
            // calculate the position based on the acceleromter data
            if (amCalibrated)
            {
                shipPositionX = (window.innerWidth / 2) - (previousAccelerometer.x * 32);
                if ( shipPositionX &lt; 0 )
                {
                    shipPositionX = 0;
                }
                if ( shipPositionX &gt; (window.innerWidth))
                {
                    shipPositionX = window.innerWidth;
                }
            }
<code class="literal">        }</code>
</pre></div><p>Here we make the <a id="id907" class="indexterm"/>
<a id="id908" class="indexterm"/>assumption that with no tilt, the ship should be in the middle of the screen (which is <code class="literal">window.innerWidth / 2</code>). We then subtract the value of the x value from the last accelerometer sample and multiply it by <code class="literal">32</code>. This number is really quite arbitrary, feel free to experiment here. Personally, <code class="literal">32</code> felt about right–not requiring the device to tilt all the way over, but also requiring sufficient tilt to make movement feel substantial.</p><p>The remainder of the lines ensure that the ship can't go off the edges of the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec181"/>What did we do?</h2></div></div></div><p>In this task, we dealt with handling accelerometer-based input.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec182"/>What else do I need to know?</h2></div></div></div><p>Working with the accelerometer is no simple task. While our code is pretty simple, there are a lot of complicated algorithms out there to both reduce the noise but at the same time keep the movement from feeling sluggish–something I can't say we've really accomplished here.</p><p>Another alternative <a id="id909" class="indexterm"/>
<a id="id910" class="indexterm"/>is to use the device's gyroscope. These values aren't based on acceleration, but on the position of the device itself, and though noisy, they aren't as noisy as the accelerometer values. As such, they can be easier to work with. The problem is that only iOS exposes these to a browser. On Android, one would need to write a plugin to work with this type of sensor. Furthermore, not every device has a gyroscope, so you would need to provide a fallback to the accelerometer just in case.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Game Over..... Wrapping it up</h1></div></div></div><p>Whew! That was a lot of work, but the result is pretty fun. See how far you can get before it gets too hard. Let me tell you, it doesn't take me very long to crash and burn.</p><p>The final results are displayed in the following pages. I've not included Android screenshots since they appear virtually identical.</p><p>The starting screen will be as follows:</p><div><img src="img/9403_08_04.jpg" alt="Game Over..... Wrapping it up"/></div><p>The options view will be as follows:</p><p>  </p><div><img src="img/9403_08_05.jpg" alt="Game Over..... Wrapping it up"/></div><p>
</p><p>And an unfortunate crash is seen in the following screenshot:</p><p>  </p><div><img src="img/9403_08_06.jpg" alt="Game Over..... Wrapping it up"/></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Can you take the HEAT? The Hotshot Challenge</h1></div></div></div><p>There are a lot of ways this game could be enhanced. Why don't you try a few?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The game currently lacks a pause option; why don't you add one?</li><li class="listitem" style="list-style-type: disc">Our game is naïve with regards to multitasking. Upon resumption, it will happily extrapolate where we should be in the cave after what might be a very long time. A better method would be to pause the game when it is in the background.</li><li class="listitem" style="list-style-type: disc">We're using pixel-based collision detection. Why don't you try to use math-based detection instead?</li><li class="listitem" style="list-style-type: disc">Try various control schemes until you find some you like.</li><li class="listitem" style="list-style-type: disc">Use gyroscope values if available.</li><li class="listitem" style="list-style-type: disc">Add powerups or other objects in the map that could affect the player for good or bad.</li><li class="listitem" style="list-style-type: disc">Make static levels for the game that could be loaded on demand.</li><li class="listitem" style="list-style-type: disc">Add logic to make sure any level is winnable.</li></ul></div></div></body></html>