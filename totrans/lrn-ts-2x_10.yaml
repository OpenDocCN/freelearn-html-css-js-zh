- en: Node.js Development with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the preceding chapters of this book, we have been using Node.js and some
    of the tools of its ecosystem, but we haven''t developed a Node.js application.
    In this chapter, we are going to learn how to develop applications with Node.js.
    We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The main characteristics of Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main characteristics of the Node.js core API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side development with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing REST APIs with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js
    is single-threaded and uses an event-driven, non-blocking I/O model that makes
    it lightweight and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding non-blocking I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An input or output operation (I/O) is an operation that requires writing or
    reading from a physical source. This includes things such as saving a file into
    your hard disk or sending a file through the network.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, operating systems only allowed us to perform I/O operations in
    what is known as a blocking model. In a **blocking model**, we can run an application
    in a thread, but when an I/O request takes place, the thread is blocked until
    the request is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Web servers implemented using blocking I/O are not be able to handle multiple
    simultaneous connections using the same thread. For example, when an HTTP request
    arrives at the web server, it might need to perform some I/O operation (for example,
    reading from a database or talking to another server through the network) to provide
    the creator of the request with a response. If the web server uses one unique
    thread, it will be blocked until the I/O operation has been completed. As a result,
    if a second HTTP request hits the server, the server will not be able to handle
    it. The solution to this problem was to create a new thread for each HTTP request
    but this solution was not scalable because a single CPU cannot handle a very large
    number of threads and CPUs are one of the most expensive components of a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the blocking I/O model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41461bc3-57bc-4b33-bd33-c7c16ae88d28.png)'
  prefs: []
  type: TYPE_IMG
- en: The non-blocking I/O model is the solution to the limitations of the blocking
    I/O model. In the non-blocking model, an I/O request doesn't block the main thread.
    Instead of that, the I/O events are collected and queued by a component known
    as the event demultiplexer. Node.js implements a pattern known as the reactor
    pattern, which combines the JavaScript event loop with the event demultiplexer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the interactions between the event loop and
    the event demultiplexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70e4e029-a9dc-4f4e-88f5-2e6357fb9147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main idea behind it is to have a handler (which in Node.js is represented
    by a callback function) associated with each I/O operation. When the I/O operation
    is completed, an event is produced and consumed by the JavaScript event loop,
    which invokes the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding
    the Runtime*, to learn more about the JavaScript event loop and the way event
    handlers work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the web server uses one unique thread, it will not be blocked until the
    I/O operation has been completed. As a result, if a second HTTP request hits the
    server, the server will be able to handle it without the need for more threads.
    Each HTTP request creates I/O events and event handlers that are stored in memory,
    and if the server is hit by thousands of HTTP requests, it can still reach a limit.
    However, the level of concurrent HTTP requests is much higher than the previous
    limit imposed by the blocking I/O model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52a49ffb-02f9-464c-b4ca-4b4f0e61b7ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Node.js takes full advantage of the non-blocking I/O model and is fundamentally
    built on top of it, as we will see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The main components of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand how the non-blocking I/O model works, we are in a much
    better position to be able to understand each of the internal components of Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/108197ec-d968-4cb1-8ce1-a90a34d6cf63.png)'
  prefs: []
  type: TYPE_IMG
- en: V8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: V8 is the JavaScript engine originally developed for Google's Chrome. It is
    responsible for the parsing, interpretation, and execution of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the V8 documentation at [https://github.com/v8/v8/wiki](https://github.com/v8/v8/wiki)
    if you wish to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Libuv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each operating system has its interface for the event demultiplexer and each
    I/O operation can behave quite differently depending on the type of the resource,
    even within the same OS. Libuv is a C library that makes Node.js compatible with
    all the major platforms and normalizes the non-blocking behavior of the different
    types of resource; libuv today represents the low-level I/O engine of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the official libuv documentation at [https://libuv.org/](https://libuv.org/)
    and [http://docs.libuv.org/en/v1.x/](http://docs.libuv.org/en/v1.x/) if you wish
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bindings are a set of libraries that wrap the V8 and libuv public APIs in
    a way that allows us to consume them using JavaScript instead of C or C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js core API (node-core)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js includes a set of core APIs to perform common operations, such as reading
    files, sending an HTTP request, or encrypting a text file. These APIs use V8 and
    libuv under the hood, but they don't talk to them directly, they do it through
    the bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we will learn more about the Node.js core APIs later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js environment versus browser environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Node.js environment and the browser environment are not identical. For
    example, the environment in web browsers includes an API known as the **Document
    Object Model** (**DOM**) and an API known as the **Browser Object Model** (**BOM**).
    These APIs define APIs, such as the window object or the history API. However,
    these APIs are not available in the Node.js environment. The following table highlights
    some of the most significant differences between the environment Node.js and web
    browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Node.js** | **Web browsers** |'
  prefs: []
  type: TYPE_TB
- en: '| DOM | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| BOM | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Global variable is named window | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Global variable is named global | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| The require function | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Common JS modules | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Access to sensitive resources (for example, the filesystem) | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: The Node.js ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explore the Node.js ecosystem. We are going
    to learn what Node.js has to offer us, and some significant code conventions are
    followed by its entire ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js core API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Node.js core API, also known as node-core, is a set of libraries that are
    part of Node.js and, as a result, are installed in our OS when we install Node.js.
    The Node.js core API includes the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async_hooks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`child_process`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crypto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dgram`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dns`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`perf_hooks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`punycode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querystring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string_decoder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zlib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see in the preceding list, there are modules to work with **Domain
    Name Servers** (**DNS**), working with HTTP requests (`http`), or reading and
    writing files to the hard disk (`fs`). Covering all these modules is out of the
    scope of this book. However, we are going to use some of them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you can visit the official Node.js documentation at [https://nodejs.org/docs/](https://nodejs.org/docs/)
    to learn all the details about each of the features available in each of the modules.
  prefs: []
  type: TYPE_NORMAL
- en: The style of the Node.js core API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned how the reactor pattern and the non-blocking
    I/O model are two of the most fundamental characteristics of Node.js. This should
    help us to understand why callbacks are used so extensively in the entire Node.js
    core API. As we can imagine, the core API has a direct impact on all the other
    modules. As a result, the entire Node.js ecosystem uses callbacks extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js not only uses callbacks extensively, but it also uses them in a very
    consistent way:'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks in Node.js are always the last argument of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks in Node.js always take an error as the first argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet uses the filesystem API to read a text file. The
    `readFile` function showcases the two preceding rules in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few new rules about Node.js callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors are never thrown by a function that takes a callback. The errors should
    be passed to the callback instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have nested callbacks, if an error takes place, it should be passed
    to the callback in the top level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet showcases both the preceding rules in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Node.js uses callbacks because when it was originally implemented, promises,
    generators, and `async`/`await` were not available in V8\. This seems unfortunate
    because, as TypeScript users, we know how much nicer is to use `async`/`await`
    instead of callbacks and promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the consistency of the Node.js APIs, we can write a helper that takes
    a function implemented with a callback-based API and returns the same function
    implemented with a promise-based API. In fact, this function is part of the `util`
    core module and can be imported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding helper function to transform the `readFile` function
    that we used during the previous example into a function that returns a promise.
    The new function is named `readFileAsync`. Now that the function returns a promise,
    we can use `async`/`await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet showcases how to transform the second example into
    the `async`/`await` style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the future, Node.js will support promises in its core API natively but, for
    now, using the `promisify` helper is a good option.
  prefs: []
  type: TYPE_NORMAL
- en: The npm ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used npm previously in this book, and by now we should know how to
    use it well. The npm ecosystem is composed of thousands of external modules. We
    can use the official npm website at [https://www.npmjs.com/](https://www.npmjs.com/)
    to search for a package that might help us to complete a given task. Unlike the
    modules that are part of the core Node.js API, external `npm` modules need to
    be installed using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the module is not recognized by TypeScript, we will also need to install
    its type definitions (if available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 13](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml), *Application
    Performance*, and [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn more about other tools in the Node.js ecosystem,
    for example, the Node.js inspector, a tool that allows us to debug and analyze
    the performance of our Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up Node.js on your machine, you will need to visit the official download
    page at [https://nodejs.org/en/download](https://nodejs.org/en/download/) and
    follow the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an OS X or Linux user, you can additionally install the **node version
    manager** (**nvm**) following the instructions at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
    This tool allows us to install multiple versions of Node.js on the same machine
    and to switch between them in a matter of seconds. If you are a Windows user,
    you will need to install [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows/releases)
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use one of the Node.js core API modules, all we need to do is
    to import it. We don''t need to install an additional `npm` module. For example,
    the filesystem module can be used to read and write files and manage directories.
    If we want to use the filesystem API, all we need to do is to import the module
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, TypeScript will not recognize the module by default because it is
    not part of the JavaScript specification. We can solve this problem by installing
    the Node.js type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you may want to install `ts-node` to be able to execute Node.js applications
    implemented with TypeScript without the need to compile them first. We can run
    a Node.js application or a TypeScript application using the following commands
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Node.js development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to look at a few small real-world examples of
    the usage of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement a very small Node.js application. This application
    can be used as a search and replace tool. The result can be used as a command-line
    application and can be executed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will replace one word for another in all the matching files.
    We are going to use the core filesystem API (`fs`) and two external `npm` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`glob` is used to find files that match a given pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yargs` is used to parse command-line arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to install both packages and the corresponding type definition files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `promisify` function to transform some callback-based
    APIs into promise-based APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function reads the arguments from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function validates the command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function finds the path of files that match the `glob` pattern
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is used to find a word in a file and replace it with
    a second word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is the main function in the application and the application''s
    entry point. It delegates work to all the previous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can invoke the application''s entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Working with databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to interact with a database from
    a Node.js application using a TypeScript library known as TypeORM. TypeORM is
    an **object-relational mapping** (**ORM**) library. An ORM is a tool that allows
    us to use objects and methods to interact with a database instead of using one
    of the flavors of the SQL programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to need a Postgres database server running in our development
    environment before we can implement an example. There are multiple ways to get
    a server up and running, but we are going to use Docker. Docker is a virtualization
    service that allows us to run software in standalone virtual machines known as
    containers. A Docker container is an instance of a Docker image. We are going
    to start by installing the Docker community edition by following the instructions
    at the official Docker installation guide, which can be found at [https://docs.docker.com/install](https://docs.docker.com/install),
    and we will then run the following command to download the Docker Postgres image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following command to see all the installed images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to set some environment variables. The following should work if
    you are using Bash as your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Please note that if you are using Windows, you will need to use the `setx` command
    instead of the `export` command to declare an environment variable. You can learn
    more about the `setx` command at [https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can run a container using the Postgres image. The following
    command runs the container using the environment variables that we declared in
    the preceding step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the following command to see all the Docker containers on our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, you should see something like the following in your
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc5438b8-2cc2-4d48-a02e-ac5508f12b1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you need to start again, you can stop and remove the Docker container using
    the following commands respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we are not going to go into more details about Docker because
    it is out of the scope of this book. Please refer to the official Docker documentation
    at [https://docs.docker.com](https://docs.docker.com) if you need additional help.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should have a Postgres server running as a Docker container.
    We also need to install some `npm` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `pg` module is used by TypeORM to connect to the Postgres database. The
    `reflect-metadata` is used by TypeORM to read and write metadata. It is very important
    to import the `reflect-metadata` module only once in our entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet uses TypeORM to declare an entity named `Movie`.
    The `Movie` entity will be mapped into a database table by TypeORM. The example
    also creates a database connection and a `Movie` repository. We finally use the
    repository instance to insert a new movie into the movie table and to read the
    movies in the table that match the year 1977:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The repository design pattern uses classes to encapsulate the data access logic
    and the mapping between the database and the domain entities. You can learn more
    about the repository pattern at [https://msdn.microsoft.com/en-us/library/ff649690.aspx](https://msdn.microsoft.com/en-us/library/ff649690.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can run the example using `ts-node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the environment variables and the Postgres server must be configured
    correctly for this example to work.
  prefs: []
  type: TYPE_NORMAL
- en: Working with REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to implement some REST APIs using
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world (http)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `http` module allows us to perform tasks in relation to the HTTP protocol.
    The following code snippet showcases how we can use the `http` module to implement
    very minimal implantation of a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a web server that will listen to all the HTTP requests. The
    `http` module allows us to implement our web HTTP server, but its level of abstraction
    is very low. In a real-world application, we would prefer something with a higher
    level of abstraction, something that, for example, doesn''t require us to set
    the response status code by hand. There are multiple frameworks for Node.js that
    can provide us with a higher level of abstraction over the HTTP protocol. In the
    following section, we are going to learn how to use one of them: Express.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Hello world (Express.js)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express.js is a framework designed for the implementation of server-side web
    applications. To use Express with TypeScript, we are going to need the following
    `npm` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example implements an application with a behavior almost identical
    to the application that we implemented in the preceding section, but this time
    we use Express.js instead of the `http core` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, even in an example as simple as the preceding one, with Express,
    sometimes we don't need to take care of some low-level details, such as setting
    up the response status code.
  prefs: []
  type: TYPE_NORMAL
- en: Routing with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we learned how to declare a route; however, as our
    application grows, we are going to need to implement some route organization strategy.
    Express allows us to create multiple router instances and nest them as a tree-like
    data structure. The following code snippet demonstrates how to create two routers
    that deal with two different kinds of entities (`movies` and `directors`); the
    two routers are then used by the Express application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding example, two routes are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:3000/api/v1/directors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:3000/api/v1/directors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express also allows us to declare a middleware function. A middleware function
    allows us to implement cross-cutting concerns. A cross-cutting concern is a requirement
    that affects the entire application or a subset of it. Common examples of cross-cutting
    concerns are logging and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'A middleware function takes the current request and response as arguments together
    with a function known as `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can chain middleware functions, and the `next` function is what communicates
    to Express that the middleware has finished its task and the next middleware can
    be invoked. When no more middleware functions are available, the route handler
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares two middleware functions. The first middleware
    function (`timerMiddleware`) is invoked once for each HTTP request that hits the
    server. The second middleware function (`loggerMiddleware`) is invoked once for
    each HTTP request that hits the `http://localhost:3000` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding example, the following route becomes available:
    `http://localhost:3000`. When an HTTP request hits the preceding URL, the response
    is `Hello world!` and the console displays the output generated by both middleware
    functions previously declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Architecting Node.js application – the MVC design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Architecting Node.js applications is a very extensive topic that could take
    an entire book on its own. However, we are going to cover one of the most commonly
    used design patterns, the **Model-View-Controller** (**MVC**) design pattern,
    defined as follows by MSDN:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC framework includes the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Models`: Model objects are the parts of the application that implement the
    logic for the application''s data domain. Often, model objects retrieve and store
    model state in a database. For example, a `Product` object might retrieve information
    from a database, operate on it, and then write updated information back to a Products
    table in a database. In small applications, the model is often a conceptual separation
    instead of a physical one. For example, if the application only reads a dataset
    and sends it to the view, the application does not have a physical model layer
    and associated classes. In that case, the dataset takes on the role of a model
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Views`: Views are the components that display the application''s **user interface**
    (**UI**). Typically, this UI is created from the model data. An example would
    be an edit view of a Products table that displays text boxes, drop-down lists
    and checks boxes based on the current state of a `Product` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controllers`: Controllers are the components that handle user interaction,
    work with the model, and ultimately select a view to render that displays UI.
    In an MVC application, the view only displays information; the controller handles
    and responds to user input and interaction. For example, the controller handles
    query-string values and passes these values to the model, which in turn might
    use these values to query the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC design pattern can be implemented in both the backend and the frontend.
    However, in this section, we are going to implement it in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that to be able to run this example without problems, you must first
    install all dependencies using `npm install` from the `chapter_10` folder in the
    companion source code. Then you can open `09_mvc`.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our model is going to be composed of two layers. We are going to implement
    an entity and a repository. The entity is implemented using TypeORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The repository is also implemented with TypeORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The controller uses the model (entity + repository) and it is implemented using
    the Express routing techniques that we explored earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to declare routes to get all movies, filter movies by year, and
    create a new movie. The example also uses `req.params` to access the request parameter
    year.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that we can use the `get` method to declare a route
    handler for an HTTP GET request, while we can use the `post` method to declare
    a route handler for an HTTP POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our repository, we have used the `getConnection` function from TypeORM.
    Before we can invoke this function, we need to ensure that a connection has been
    created. The following function is used later to create a database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we are implementing REST services, we don't have a data presentation
    layer. The REST API can be completely decoupled from the web user interface. We
    will not learn how to implement the presentation layer in this chapter because
    this topic is going to be covered in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The index file is the application''s entry point. The entry point creates a
    new Express app and a database connection. It then connects the controller routes
    to the Express app and launches the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Controllers and routing with inversify-express-utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this book, we learned about dependency injection and dependency
    inversion with InversifyJS. In this section, we are going to learn how to use
    InversifyJS together with Express, using a helper `npm` module known as `inversify-express-utils`.
    We are going to need to install `inversify` and `inversify-express-utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Please note that to be able to run this example without problems, you must first
    install all dependencies using `npm install` from the `chapter_10` folder in the
    companion source code. Then you can open the `10_inversify_express_utils` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Model, repository, database, and view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can reuse 100% of the code used for the model, repository, database, and
    view in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to declare some identifiers required for the InversifyJS type bindings.
    If you don''t know what a type binding is, you should go back to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml),
    *Working with Dependencies*, to learn the basics about InversifyJS. We are going
    to declare a binding for the `MovieRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The InversifyJS Express utils allow us to declare controllers using what is
    known as declarative routing. Instead of declaring `Router` instances, we can
    annotate a controller class using some decorators. The metadata generated by the
    decorators is later used by the InversifyJS express utils to generate the `Router`
    instances for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the following decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@controller(path)`: It is used to declare the path of a router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@inject(type)`: It is used to inject dependencies into a class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@httpGet(subpath)`: It is used to declare a route handler for HTTP GET requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@httpPost(subpath)`: It is used to declare a route handler for HTTP POST requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@response()`: It is used to pass the response object to a route handler as
    an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@requestParam(paramName)`: It is used to pass a request parameter to a route
    handler as an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@requestBody()`: It is used to pass the request body to a route handler as
    an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another interesting feature of the InversifyJS Express utils is that we can
    use `async` methods. InversifyJS will automatically detect whether our methods
    are `async` and use `await` when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: InversifyJS configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to declare some type bindings. We are going to declare the type
    bindings using `AsyncContainerModule` because we need to wait for the database
    connection to be ready. We are going to declare a binding for `MovieRepository`.
    We don''t need to declare a binding for the `MovieController` because the `@controller(path)`
    annotation will create it for us. However, we need to import the controller to
    ensure that the decorator is executed and, as a result, the binding is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The index file is also different. Instead of creating a new *Express* app,
    we need to create a new *InversifyExpressServer* app. The `InversifyExpressServer`
    constructor requires an instance of `Container`. The type bindings for the container
    are declared in the bindings object, which is an instance of the `AsyncContainerModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, to learn more dependency injection and dependency inversion
    with InversifyJS.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the official InversifyJS express utils at [https://github.com/inversify/inversify-express-utils](https://github.com/inversify/inversify-express-utils)
    to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Other applications of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing command-line applications or REST APIs is not the only real-world
    application of Node.js. For example, we can develop desktop applications using
    Electron. Node.js is also commonly used as a reverse proxy and powers many web
    development tools.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the main characteristics of Node.js as a platform
    and its main components. We have also learned a little bit about the Node.js ecosystem
    and the kind of applications that we can create using it.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the chapter, we implemented a very small REST API. In the
    next two chapters, we are going to learn how we can use TypeScript to create web-based
    user interfaces that consume these APIs.
  prefs: []
  type: TYPE_NORMAL
