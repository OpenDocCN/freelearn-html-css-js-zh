- en: Node.js Development with TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript进行Node.js开发
- en: 'Over the preceding chapters of this book, we have been using Node.js and some
    of the tools of its ecosystem, but we haven''t developed a Node.js application.
    In this chapter, we are going to learn how to develop applications with Node.js.
    We are going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们一直在使用Node.js及其生态系统的一些工具，但尚未开发一个Node.js应用程序。在本章中，我们将学习如何使用Node.js开发应用程序。我们将涵盖以下主题：
- en: The main characteristics of Node.js
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的主要特性
- en: The main characteristics of the Node.js core API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js核心API的主要特性
- en: Server-side development with Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js进行服务器端开发
- en: Developing REST APIs with Node.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js开发REST API
- en: Understanding Node.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Node.js
- en: Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js
    is single-threaded and uses an event-driven, non-blocking I/O model that makes
    it lightweight and efficient.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。Node.js是单线程的，并使用事件驱动的、非阻塞的I/O模型，这使得它轻量级且高效。
- en: Understanding non-blocking I/O
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解非阻塞I/O
- en: An input or output operation (I/O) is an operation that requires writing or
    reading from a physical source. This includes things such as saving a file into
    your hard disk or sending a file through the network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 输入或输出操作（I/O）是需要从物理源写入或读取的操作。这包括将文件保存到硬盘驱动器或将文件通过网络发送等操作。
- en: In the past, operating systems only allowed us to perform I/O operations in
    what is known as a blocking model. In a **blocking model**, we can run an application
    in a thread, but when an I/O request takes place, the thread is blocked until
    the request is completed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，操作系统只允许我们在所谓的阻塞模型中执行I/O操作。在**阻塞模型**中，我们可以在一个线程中运行一个应用程序，但当发生I/O请求时，该线程会被阻塞，直到请求完成。
- en: Web servers implemented using blocking I/O are not be able to handle multiple
    simultaneous connections using the same thread. For example, when an HTTP request
    arrives at the web server, it might need to perform some I/O operation (for example,
    reading from a database or talking to another server through the network) to provide
    the creator of the request with a response. If the web server uses one unique
    thread, it will be blocked until the I/O operation has been completed. As a result,
    if a second HTTP request hits the server, the server will not be able to handle
    it. The solution to this problem was to create a new thread for each HTTP request
    but this solution was not scalable because a single CPU cannot handle a very large
    number of threads and CPUs are one of the most expensive components of a server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阻塞I/O实现的Web服务器无法使用相同的线程处理多个同时连接。例如，当一个HTTP请求到达Web服务器时，它可能需要进行一些I/O操作（例如，从数据库中读取或通过网络与另一个服务器通信）以向请求的创建者提供响应。如果Web服务器使用一个唯一的线程，它将一直被阻塞，直到I/O操作完成。因此，如果第二个HTTP请求击中服务器，服务器将无法处理它。解决这个问题的方法是为每个HTTP请求创建一个新的线程，但这种解决方案不可扩展，因为单个CPU无法处理大量线程，而CPU是服务器中最昂贵的组件之一。
- en: 'The following diagram represents the blocking I/O model:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了阻塞I/O模型：
- en: '![](img/41461bc3-57bc-4b33-bd33-c7c16ae88d28.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/41461bc3-57bc-4b33-bd33-c7c16ae88d28.png)'
- en: The non-blocking I/O model is the solution to the limitations of the blocking
    I/O model. In the non-blocking model, an I/O request doesn't block the main thread.
    Instead of that, the I/O events are collected and queued by a component known
    as the event demultiplexer. Node.js implements a pattern known as the reactor
    pattern, which combines the JavaScript event loop with the event demultiplexer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞I/O模型是解决阻塞I/O模型限制的方案。在非阻塞模型中，I/O请求不会阻塞主线程。相反，I/O事件由一个称为事件分配器的组件收集和排队。Node.js实现了一种称为反应器模式的模式，它将JavaScript事件循环与事件分配器结合起来。
- en: 'The following diagram represents the interactions between the event loop and
    the event demultiplexer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了事件循环与事件分配器之间的交互：
- en: '![](img/70e4e029-a9dc-4f4e-88f5-2e6357fb9147.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/70e4e029-a9dc-4f4e-88f5-2e6357fb9147.jpg)'
- en: The main idea behind it is to have a handler (which in Node.js is represented
    by a callback function) associated with each I/O operation. When the I/O operation
    is completed, an event is produced and consumed by the JavaScript event loop,
    which invokes the handler.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其背后的主要思想是为每个I/O操作关联一个处理程序（在Node.js中由回调函数表示）。当I/O操作完成时，会产生一个事件，并由JavaScript事件循环消费，从而调用处理程序。
- en: Please refer to [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding
    the Runtime*, to learn more about the JavaScript event loop and the way event
    handlers work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第6章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)，*理解运行时*，以了解更多关于JavaScript事件循环和事件处理器工作方式的信息。
- en: 'If the web server uses one unique thread, it will not be blocked until the
    I/O operation has been completed. As a result, if a second HTTP request hits the
    server, the server will be able to handle it without the need for more threads.
    Each HTTP request creates I/O events and event handlers that are stored in memory,
    and if the server is hit by thousands of HTTP requests, it can still reach a limit.
    However, the level of concurrent HTTP requests is much higher than the previous
    limit imposed by the blocking I/O model:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Web服务器使用一个唯一的线程，它将不会在I/O操作完成之前被阻塞。因此，如果第二个HTTP请求击中服务器，服务器将能够处理它，而无需更多线程。每个HTTP请求都会创建I/O事件和事件处理器，这些事件处理器存储在内存中，如果服务器被成千上万的HTTP请求击中，它仍然可以达到一个极限。然而，并发HTTP请求的水平比之前由阻塞I/O模型强加的限制要高得多：
- en: '![](img/52a49ffb-02f9-464c-b4ca-4b4f0e61b7ae.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52a49ffb-02f9-464c-b4ca-4b4f0e61b7ae.png)'
- en: Node.js takes full advantage of the non-blocking I/O model and is fundamentally
    built on top of it, as we will see in the following section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js充分利用了非阻塞I/O模型，并在其之上构建了根本，正如我们将在下一节中看到的那样。
- en: The main components of Node.js
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的主要组件
- en: 'Now that we understand how the non-blocking I/O model works, we are in a much
    better position to be able to understand each of the internal components of Node.js:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了非阻塞I/O模型的工作原理，我们处于更好的位置来理解Node.js的每个内部组件：
- en: '![](img/108197ec-d968-4cb1-8ce1-a90a34d6cf63.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/108197ec-d968-4cb1-8ce1-a90a34d6cf63.png)'
- en: V8
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V8
- en: V8 is the JavaScript engine originally developed for Google's Chrome. It is
    responsible for the parsing, interpretation, and execution of JavaScript.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: V8是最初为Google的Chrome开发的JavaScript引擎。它负责解析、解释和执行JavaScript。
- en: Please refer to the V8 documentation at [https://github.com/v8/v8/wiki](https://github.com/v8/v8/wiki)
    if you wish to learn more about it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于V8的信息，请参阅V8文档：[https://github.com/v8/v8/wiki](https://github.com/v8/v8/wiki)。
- en: Libuv
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Libuv
- en: Each operating system has its interface for the event demultiplexer and each
    I/O operation can behave quite differently depending on the type of the resource,
    even within the same OS. Libuv is a C library that makes Node.js compatible with
    all the major platforms and normalizes the non-blocking behavior of the different
    types of resource; libuv today represents the low-level I/O engine of Node.js.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有自己的事件解复用器接口，并且每个I/O操作的行为可能会根据资源类型的不同而大相径庭，即使在同一操作系统内部。Libuv是一个C库，使Node.js与所有主要平台兼容，并规范了不同类型资源的非阻塞行为；如今，libuv代表了Node.js的低级I/O引擎。
- en: Please refer to the official libuv documentation at [https://libuv.org/](https://libuv.org/)
    and [http://docs.libuv.org/en/v1.x/](http://docs.libuv.org/en/v1.x/) if you wish
    to learn more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多信息，请参阅官方libuv文档：[https://libuv.org/](https://libuv.org/) 和 [http://docs.libuv.org/en/v1.x/](http://docs.libuv.org/en/v1.x/)。
- en: Bindings
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: The bindings are a set of libraries that wrap the V8 and libuv public APIs in
    a way that allows us to consume them using JavaScript instead of C or C++ code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是一组库，它以允许我们使用JavaScript而不是C或C++代码的方式包装了V8和libuv的公共API。
- en: The Node.js core API (node-core)
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js核心API（node-core）
- en: Node.js includes a set of core APIs to perform common operations, such as reading
    files, sending an HTTP request, or encrypting a text file. These APIs use V8 and
    libuv under the hood, but they don't talk to them directly, they do it through
    the bindings.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js包含一组核心API来执行常见操作，例如读取文件、发送HTTP请求或加密文本文件。这些API在底层使用V8和libuv，但它们并不直接与之通信，而是通过绑定来实现。
- en: Please note that we will learn more about the Node.js core APIs later in this
    chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在本章的后面部分学习更多关于Node.js核心API的内容。
- en: Node.js environment versus browser environment
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js环境与浏览器环境
- en: 'The Node.js environment and the browser environment are not identical. For
    example, the environment in web browsers includes an API known as the **Document
    Object Model** (**DOM**) and an API known as the **Browser Object Model** (**BOM**).
    These APIs define APIs, such as the window object or the history API. However,
    these APIs are not available in the Node.js environment. The following table highlights
    some of the most significant differences between the environment Node.js and web
    browsers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 环境和浏览器环境并不相同。例如，浏览器环境包括一个称为 **文档对象模型**（**DOM**）的 API 和一个称为 **浏览器对象模型**（**BOM**）的
    API。这些 API 定义了诸如窗口对象或历史 API 等API。然而，这些 API 在 Node.js 环境中不可用。以下表格突出了 Node.js 环境和
    Web 浏览器之间的一些最显著差异：
- en: '| **Feature** | **Node.js** | **Web browsers** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **Node.js** | **Web 浏览器** |'
- en: '| DOM | No | Yes |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| DOM | 否 | 是 |'
- en: '| BOM | No | Yes |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| BOM | 否 | 是 |'
- en: '| Global variable is named window | No | Yes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 全局变量命名为 window | 否 | 是 |'
- en: '| Global variable is named global | Yes | No |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 全局变量命名为 global | 是 | 否 |'
- en: '| The require function | Yes | No |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| require 函数 | 是 | 否 |'
- en: '| Common JS modules | Yes | No |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Common JS 模块 | 是 | 否 |'
- en: '| Access to sensitive resources (for example, the filesystem) | Yes | No |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 访问敏感资源（例如，文件系统） | 是 | 否 |'
- en: The Node.js ecosystem
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 生态系统
- en: In this section, we are going to explore the Node.js ecosystem. We are going
    to learn what Node.js has to offer us, and some significant code conventions are
    followed by its entire ecosystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索 Node.js 生态系统。我们将了解 Node.js 能为我们提供什么，以及其整个生态系统遵循的一些重要代码约定。
- en: The Node.js core API
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 核心API
- en: 'The Node.js core API, also known as node-core, is a set of libraries that are
    part of Node.js and, as a result, are installed in our OS when we install Node.js.
    The Node.js core API includes the following modules:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 核心API，也称为 node-core，是一组库，它是 Node.js 的一部分，因此当我们安装 Node.js 时，它们会安装到我们的操作系统上。Node.js
    核心API 包括以下模块：
- en: '`assert`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`'
- en: '`async_hooks`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async_hooks`'
- en: '`buffer`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`'
- en: '`child_process`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`child_process`'
- en: '`cluster`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster`'
- en: '`crypto`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto`'
- en: '`dgram`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dgram`'
- en: '`dns`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns`'
- en: '`domain`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`'
- en: '`events`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events`'
- en: '`fs`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`'
- en: '`http`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`'
- en: '`http2`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http2`'
- en: '`https`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https`'
- en: '`net`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`'
- en: '`os`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os`'
- en: '`path`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`'
- en: '`perf_hooks`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perf_hooks`'
- en: '`punycode`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`punycode`'
- en: '`querystring`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querystring`'
- en: '`readline`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readline`'
- en: '`repl`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repl`'
- en: '`stream`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`'
- en: '`string_decoder`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string_decoder`'
- en: '`tls`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`'
- en: '`tty`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tty`'
- en: '`url`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`'
- en: '`util`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`v8`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v8`'
- en: '`vm`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vm`'
- en: '`zlib`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zlib`'
- en: As we can see in the preceding list, there are modules to work with **Domain
    Name Servers** (**DNS**), working with HTTP requests (`http`), or reading and
    writing files to the hard disk (`fs`). Covering all these modules is out of the
    scope of this book. However, we are going to use some of them later in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的列表所示，有模块可以与 **域名服务器**（**DNS**）一起工作，处理 HTTP 请求（`http`），或读取和写入硬盘上的文件（`fs`）。涵盖所有这些模块超出了本书的范围。然而，我们将在本章后面使用其中的一些模块。
- en: Please note that you can visit the official Node.js documentation at [https://nodejs.org/docs/](https://nodejs.org/docs/)
    to learn all the details about each of the features available in each of the modules.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过访问官方 Node.js 文档 [https://nodejs.org/docs/](https://nodejs.org/docs/)
    来了解每个模块中每个功能的所有详细信息。
- en: The style of the Node.js core API
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 核心API 的风格
- en: Earlier in this chapter, we learned how the reactor pattern and the non-blocking
    I/O model are two of the most fundamental characteristics of Node.js. This should
    help us to understand why callbacks are used so extensively in the entire Node.js
    core API. As we can imagine, the core API has a direct impact on all the other
    modules. As a result, the entire Node.js ecosystem uses callbacks extensively.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们学习了反应器模式和异步 I/O 模型是 Node.js 最基本的特点之一。这应该有助于我们理解为什么回调在 Node.js 核心API
    中被广泛使用。正如我们可以想象的那样，核心 API 对所有其他模块都有直接影响。因此，整个 Node.js 生态系统广泛使用回调。
- en: 'Node.js not only uses callbacks extensively, but it also uses them in a very
    consistent way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 不仅广泛使用回调，而且使用方式非常一致：
- en: Callbacks in Node.js are always the last argument of a function
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 中的回调总是函数的最后一个参数
- en: Callbacks in Node.js always take an error as the first argument
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 中的回调总是将错误作为第一个参数
- en: 'The following code snippet uses the filesystem API to read a text file. The
    `readFile` function showcases the two preceding rules in action:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用文件系统 API 读取文本文件。`readFile` 函数展示了前面两个规则的实际应用：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a few new rules about Node.js callbacks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Node.js 回调有一些新的规则：
- en: Errors are never thrown by a function that takes a callback. The errors should
    be passed to the callback instead.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数永远不会抛出错误。错误应该传递给回调。
- en: When we have nested callbacks, if an error takes place, it should be passed
    to the callback in the top level.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们遇到嵌套回调时，如果发生错误，应该将错误传递给顶层回调。
- en: 'The following code snippet showcases both the preceding rules in action:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了上述规则的实际应用：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Node.js uses callbacks because when it was originally implemented, promises,
    generators, and `async`/`await` were not available in V8\. This seems unfortunate
    because, as TypeScript users, we know how much nicer is to use `async`/`await`
    instead of callbacks and promises.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用回调是因为当它最初实现时，promises、generators和`async`/`await`在V8中是不可用的。这似乎很不幸，因为作为TypeScript用户，我们知道使用`async`/`await`而不是回调和promises要方便得多。
- en: 'Thanks to the consistency of the Node.js APIs, we can write a helper that takes
    a function implemented with a callback-based API and returns the same function
    implemented with a promise-based API. In fact, this function is part of the `util`
    core module and can be imported as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Node.js API的一致性，我们可以编写一个辅助函数，它接受一个使用基于回调的API实现的函数，并返回一个使用基于promise的API实现的相同函数。实际上，这个函数是`util`核心模块的一部分，可以按照以下方式导入：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the preceding helper function to transform the `readFile` function
    that we used during the previous example into a function that returns a promise.
    The new function is named `readFileAsync`. Now that the function returns a promise,
    we can use `async`/`await`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的辅助函数将我们在上一个示例中使用的`readFile`函数转换成一个返回promise的函数。新函数被命名为`readFileAsync`。现在函数返回promise，我们可以使用`async`/`await`：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code snippet showcases how to transform the second example into
    the `async`/`await` style:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将第二个示例转换为`async`/`await`风格：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the future, Node.js will support promises in its core API natively but, for
    now, using the `promisify` helper is a good option.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，Node.js将原生支持其核心API中的promises，但到目前为止，使用`promisify`辅助函数是一个不错的选择。
- en: The npm ecosystem
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm生态系统
- en: 'We have used npm previously in this book, and by now we should know how to
    use it well. The npm ecosystem is composed of thousands of external modules. We
    can use the official npm website at [https://www.npmjs.com/](https://www.npmjs.com/)
    to search for a package that might help us to complete a given task. Unlike the
    modules that are part of the core Node.js API, external `npm` modules need to
    be installed using `npm`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中我们之前已经使用了npm，到现在我们应该已经知道如何很好地使用它。npm生态系统由数千个外部模块组成。我们可以使用官方npm网站[https://www.npmjs.com/](https://www.npmjs.com/)来搜索可能帮助我们完成特定任务的包。与作为Node.js核心API一部分的模块不同，外部`npm`模块需要使用`npm`进行安装：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the module is not recognized by TypeScript, we will also need to install
    its type definitions (if available):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块不被TypeScript识别，我们还需要安装其类型定义（如果可用）：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please refer to [Chapter 13](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml), *Application
    Performance*, and [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn more about other tools in the Node.js ecosystem,
    for example, the Node.js inspector, a tool that allows us to debug and analyze
    the performance of our Node.js applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第13章](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml)，*应用性能*，以及[第9章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)，*自动化你的开发工作流程*，以了解Node.js生态系统中的其他工具，例如Node.js检查器，这是一个允许我们调试和分析我们的Node.js应用程序性能的工具。
- en: Setting up Node.js
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Node.js
- en: To set up Node.js on your machine, you will need to visit the official download
    page at [https://nodejs.org/en/download](https://nodejs.org/en/download/) and
    follow the instructions for your operating system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的机器上设置Node.js，你需要访问官方下载页面[https://nodejs.org/en/download](https://nodejs.org/en/download/)并遵循你操作系统的说明。
- en: If you are an OS X or Linux user, you can additionally install the **node version
    manager** (**nvm**) following the instructions at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
    This tool allows us to install multiple versions of Node.js on the same machine
    and to switch between them in a matter of seconds. If you are a Windows user,
    you will need to install [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows/releases)
    instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 OS X 或 Linux 用户，你可以按照 [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    上的说明额外安装 **node 版本管理器** (**nvm**)。这个工具允许我们在同一台机器上安装多个 Node.js 版本，并在几秒钟内切换它们。如果你是一个
    Windows 用户，你需要安装 [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows/releases)
    代替。
- en: 'If we want to use one of the Node.js core API modules, all we need to do is
    to import it. We don''t need to install an additional `npm` module. For example,
    the filesystem module can be used to read and write files and manage directories.
    If we want to use the filesystem API, all we need to do is to import the module
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 Node.js 的一个核心 API 模块，我们只需要导入它。我们不需要安装额外的 `npm` 模块。例如，文件系统模块可以用来读取和写入文件以及管理目录。如果我们想使用文件系统
    API，我们只需要按照以下方式导入模块：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, TypeScript will not recognize the module by default because it is
    not part of the JavaScript specification. We can solve this problem by installing
    the Node.js type definitions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TypeScript 默认不会识别该模块，因为它不是 JavaScript 规范的一部分。我们可以通过安装 Node.js 类型定义来解决此问题：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, you may want to install `ts-node` to be able to execute Node.js applications
    implemented with TypeScript without the need to compile them first. We can run
    a Node.js application or a TypeScript application using the following commands
    respectively:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想安装 `ts-node` 以能够在不先编译的情况下执行使用 TypeScript 实现的 Node.js 应用程序。我们可以使用以下命令分别运行
    Node.js 应用程序或 TypeScript 应用程序：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Node.js development
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 开发
- en: In this section, we are going to look at a few small real-world examples of
    the usage of Node.js.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几个 Node.js 的实际应用的小型示例。
- en: Working with the filesystem
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统一起工作
- en: 'We are going to implement a very small Node.js application. This application
    can be used as a search and replace tool. The result can be used as a command-line
    application and can be executed using the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个非常小的 Node.js 应用程序。这个应用程序可以用作搜索和替换工具。结果可以用作命令行应用程序，并可以使用以下命令执行：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The application will replace one word for another in all the matching files.
    We are going to use the core filesystem API (`fs`) and two external `npm` modules:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将在所有匹配的文件中将一个单词替换为另一个单词。我们将使用核心文件系统API (`fs`) 和两个外部 `npm` 模块：
- en: '`glob` is used to find files that match a given pattern'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glob` 用于查找与给定模式匹配的文件'
- en: '`yargs` is used to parse command-line arguments'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yargs` 用于解析命令行参数'
- en: 'We need to install both packages and the corresponding type definition files:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装这两个包以及相应的类型定义文件：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look at the source code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看源代码：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are going to use the `promisify` function to transform some callback-based
    APIs into promise-based APIs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `promisify` 函数将一些基于回调的 API 转换为基于 Promise 的 API：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following function reads the arguments from the command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数从命令行读取参数：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following function validates the command-line arguments:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数验证命令行参数：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following function finds the path of files that match the `glob` pattern
    provided:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数查找与提供的 `glob` 模式匹配的文件路径：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following function is used to find a word in a file and replace it with
    a second word:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于在文件中查找一个单词并将其替换为另一个单词：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This function is the main function in the application and the application''s
    entry point. It delegates work to all the previous functions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是应用程序中的主函数，也是应用程序的入口点。它将工作委托给所有前面的函数：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, we can invoke the application''s entry point:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以调用应用程序的入口点：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Working with databases
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: In this section, we are going to learn how to interact with a database from
    a Node.js application using a TypeScript library known as TypeORM. TypeORM is
    an **object-relational mapping** (**ORM**) library. An ORM is a tool that allows
    us to use objects and methods to interact with a database instead of using one
    of the flavors of the SQL programming language.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用TypeScript库TypeORM从Node.js应用程序与数据库交互。TypeORM是一个**对象关系映射**（ORM）库。ORM是一个工具，它允许我们使用对象和方法与数据库交互，而不是使用SQL编程语言的任何一种变体。
- en: 'We are going to need a Postgres database server running in our development
    environment before we can implement an example. There are multiple ways to get
    a server up and running, but we are going to use Docker. Docker is a virtualization
    service that allows us to run software in standalone virtual machines known as
    containers. A Docker container is an instance of a Docker image. We are going
    to start by installing the Docker community edition by following the instructions
    at the official Docker installation guide, which can be found at [https://docs.docker.com/install](https://docs.docker.com/install),
    and we will then run the following command to download the Docker Postgres image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实现一个示例之前，我们需要在我们的开发环境中运行一个Postgres数据库服务器。有多种方法可以让服务器启动并运行，但我们将使用Docker。Docker是一种虚拟化服务，它允许我们在称为容器的独立虚拟机中运行软件。Docker容器是Docker镜像的一个实例。我们将首先按照官方Docker安装指南中的说明安装Docker社区版，该指南可以在[https://docs.docker.com/install](https://docs.docker.com/install)找到，然后我们将运行以下命令来下载Docker
    Postgres镜像：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use the following command to see all the installed images:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来查看所有已安装的镜像：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need to set some environment variables. The following should work if
    you are using Bash as your command line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置一些环境变量。以下命令应该适用于使用Bash作为命令行的情况：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Please note that if you are using Windows, you will need to use the `setx` command
    instead of the `export` command to declare an environment variable. You can learn
    more about the `setx` command at [https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用的是Windows，你需要使用`setx`命令而不是`export`命令来声明环境变量。你可以在[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx)了解更多关于`setx`命令的信息。
- en: 'At this point, we can run a container using the Postgres image. The following
    command runs the container using the environment variables that we declared in
    the preceding step:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用Postgres镜像运行一个容器。以下命令使用我们在前一步中声明的环境变量来运行容器：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can run the following command to see all the Docker containers on our machine:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行以下命令来查看我们机器上的所有Docker容器：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If everything went well, you should see something like the following in your
    console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能在你的控制台看到以下类似的内容：
- en: '![](img/bc5438b8-2cc2-4d48-a02e-ac5508f12b1f.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc5438b8-2cc2-4d48-a02e-ac5508f12b1f.png)'
- en: 'If you need to start again, you can stop and remove the Docker container using
    the following commands respectively:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要重新开始，你可以使用以下命令分别停止和删除Docker容器：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Please note that we are not going to go into more details about Docker because
    it is out of the scope of this book. Please refer to the official Docker documentation
    at [https://docs.docker.com](https://docs.docker.com) if you need additional help.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不会深入探讨Docker的细节，因为这超出了本书的范围。如果你需要更多帮助，请参考官方Docker文档[https://docs.docker.com](https://docs.docker.com)。
- en: 'At this point, we should have a Postgres server running as a Docker container.
    We also need to install some `npm` modules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有一个作为Docker容器运行的Postgres服务器。我们还需要安装一些`npm`模块：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `pg` module is used by TypeORM to connect to the Postgres database. The
    `reflect-metadata` is used by TypeORM to read and write metadata. It is very important
    to import the `reflect-metadata` module only once in our entire application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg`模块被TypeORM用来连接到Postgres数据库。`reflect-metadata`被TypeORM用来读取和写入元数据。在我们的整个应用程序中，只导入一次`reflect-metadata`模块非常重要。'
- en: 'The following code snippet uses TypeORM to declare an entity named `Movie`.
    The `Movie` entity will be mapped into a database table by TypeORM. The example
    also creates a database connection and a `Movie` repository. We finally use the
    repository instance to insert a new movie into the movie table and to read the
    movies in the table that match the year 1977:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用TypeORM声明了一个名为`Movie`的实体。`Movie`实体将通过TypeORM映射到数据库表中。示例还创建了一个数据库连接和一个`Movie`存储库。我们最终使用存储库实例将一部新电影插入电影表，并读取表中匹配1977年的电影：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The repository design pattern uses classes to encapsulate the data access logic
    and the mapping between the database and the domain entities. You can learn more
    about the repository pattern at [https://msdn.microsoft.com/en-us/library/ff649690.aspx](https://msdn.microsoft.com/en-us/library/ff649690.aspx).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库设计模式使用类来封装数据访问逻辑以及数据库与域实体之间的映射。您可以在[https://msdn.microsoft.com/en-us/library/ff649690.aspx](https://msdn.microsoft.com/en-us/library/ff649690.aspx)了解更多关于存储库模式的信息。
- en: 'Finally, we can run the example using `ts-node`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`ts-node`运行示例：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that the environment variables and the Postgres server must be configured
    correctly for this example to work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使此示例正常工作，环境变量和Postgres服务器必须正确配置。
- en: Working with REST APIs
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与REST API一起工作
- en: In this section, we are going to learn how to implement some REST APIs using
    Node.js.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Node.js实现一些REST API。
- en: Hello world (http)
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello world (http)
- en: 'The `http` module allows us to perform tasks in relation to the HTTP protocol.
    The following code snippet showcases how we can use the `http` module to implement
    very minimal implantation of a web server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`http`模块允许我们执行与HTTP协议相关的任务。以下代码片段展示了我们如何使用`http`模块实现一个非常基础的Web服务器实现：'
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have created a web server that will listen to all the HTTP requests. The
    `http` module allows us to implement our web HTTP server, but its level of abstraction
    is very low. In a real-world application, we would prefer something with a higher
    level of abstraction, something that, for example, doesn''t require us to set
    the response status code by hand. There are multiple frameworks for Node.js that
    can provide us with a higher level of abstraction over the HTTP protocol. In the
    following section, we are going to learn how to use one of them: Express.js.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个将监听所有HTTP请求的Web服务器。`http`模块允许我们实现我们的Web HTTP服务器，但它的抽象级别非常低。在实际应用中，我们更倾向于使用更高抽象级别的工具，例如，不需要我们手动设置响应状态码。Node.js有多种框架可以为我们提供对HTTP协议的更高抽象级别。在下一节中，我们将学习如何使用其中之一：Express.js。
- en: Hello world (Express.js)
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello world (Express.js)
- en: 'Express.js is a framework designed for the implementation of server-side web
    applications. To use Express with TypeScript, we are going to need the following
    `npm` modules:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js是一个为服务器端Web应用程序实现而设计的框架。要使用TypeScript与Express一起使用，我们需要以下`npm`模块：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following example implements an application with a behavior almost identical
    to the application that we implemented in the preceding section, but this time
    we use Express.js instead of the `http core` module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实现了一个与前面章节中实现的应用程序行为几乎相同的应用程序，但这次我们使用Express.js而不是`http core`模块：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, even in an example as simple as the preceding one, with Express,
    sometimes we don't need to take care of some low-level details, such as setting
    up the response status code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，即使在前面提到的简单示例中，使用Express，有时我们不需要处理一些低级细节，例如设置响应状态码。
- en: Routing with Express
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express进行路由
- en: 'In the preceding section, we learned how to declare a route; however, as our
    application grows, we are going to need to implement some route organization strategy.
    Express allows us to create multiple router instances and nest them as a tree-like
    data structure. The following code snippet demonstrates how to create two routers
    that deal with two different kinds of entities (`movies` and `directors`); the
    two routers are then used by the Express application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何声明一个路由；然而，随着我们的应用程序增长，我们将需要实现一些路由组织策略。Express允许我们创建多个路由器实例并将它们作为树状数据结构嵌套。以下代码片段演示了如何创建两个处理不同类型实体（`movies`和`directors`）的路由器；然后这两个路由器被Express应用程序使用：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run the preceding example, two routes are available:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的示例时，有两个路由可用：
- en: '`http://localhost:3000/api/v1/directors`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:3000/api/v1/directors`'
- en: '`http://localhost:3000/api/v1/directors`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:3000/api/v1/directors`'
- en: Express middleware
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express中间件
- en: Express also allows us to declare a middleware function. A middleware function
    allows us to implement cross-cutting concerns. A cross-cutting concern is a requirement
    that affects the entire application or a subset of it. Common examples of cross-cutting
    concerns are logging and authorization.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Express还允许我们声明一个中间件函数。中间件函数允许我们实现横切关注点。横切关注点是一个影响整个应用程序或其子集的要求。横切关注点的常见例子是日志记录和授权。
- en: 'A middleware function takes the current request and response as arguments together
    with a function known as `next`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数接受当前请求和响应作为参数，以及一个名为`next`的函数：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can chain middleware functions, and the `next` function is what communicates
    to Express that the middleware has finished its task and the next middleware can
    be invoked. When no more middleware functions are available, the route handler
    is invoked.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以链式调用中间件函数，而`next`函数则是用来通知Express中间件已完成其任务，可以调用下一个中间件。当没有更多的中间件函数可用时，路由处理程序将被调用。
- en: 'The following code snippet declares two middleware functions. The first middleware
    function (`timerMiddleware`) is invoked once for each HTTP request that hits the
    server. The second middleware function (`loggerMiddleware`) is invoked once for
    each HTTP request that hits the `http://localhost:3000` endpoint:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了两个中间件函数。第一个中间件函数（`timerMiddleware`）在每次HTTP请求击中服务器时被调用一次。第二个中间件函数（`loggerMiddleware`）在每次HTTP请求击中`http://localhost:3000`端点时被调用一次：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we execute the preceding example, the following route becomes available:
    `http://localhost:3000`. When an HTTP request hits the preceding URL, the response
    is `Hello world!` and the console displays the output generated by both middleware
    functions previously declared:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的示例时，以下路由变得可用：`http://localhost:3000`。当HTTP请求击中前面的URL时，响应是`Hello world!`，控制台显示之前声明的两个中间件函数生成的输出：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Architecting Node.js application – the MVC design pattern
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Node.js应用程序——MVC设计模式
- en: 'Architecting Node.js applications is a very extensive topic that could take
    an entire book on its own. However, we are going to cover one of the most commonly
    used design patterns, the **Model-View-Controller** (**MVC**) design pattern,
    defined as follows by MSDN:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Node.js应用程序是一个非常广泛的话题，可能需要一本整本书来单独讲述。然而，我们将介绍最常用的设计模式之一，即MSDN定义的**模型-视图-控制器**（**MVC**）设计模式，如下所示：
- en: 'The MVC framework includes the following components:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MVC框架包括以下组件：
- en: '`Models`: Model objects are the parts of the application that implement the
    logic for the application''s data domain. Often, model objects retrieve and store
    model state in a database. For example, a `Product` object might retrieve information
    from a database, operate on it, and then write updated information back to a Products
    table in a database. In small applications, the model is often a conceptual separation
    instead of a physical one. For example, if the application only reads a dataset
    and sends it to the view, the application does not have a physical model layer
    and associated classes. In that case, the dataset takes on the role of a model
    object.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模型`：模型对象是应用程序中实现应用程序数据域逻辑的部分。通常，模型对象从数据库检索和存储模型状态。例如，一个`Product`对象可能会从数据库检索信息，对其进行操作，然后将更新后的信息写回到数据库中的`Products`表。在小型应用程序中，模型通常是概念上的分离，而不是物理上的分离。例如，如果应用程序只读取数据集并将其发送到视图，则应用程序没有物理模型层和相关类。在这种情况下，数据集承担了模型对象的角色。'
- en: '`Views`: Views are the components that display the application''s **user interface**
    (**UI**). Typically, this UI is created from the model data. An example would
    be an edit view of a Products table that displays text boxes, drop-down lists
    and checks boxes based on the current state of a `Product` object.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`视图`：视图是显示应用程序的**用户界面**（**UI**）的组件。通常，此UI由模型数据创建。一个例子是显示文本框、下拉列表和复选框的`Products`表的编辑视图，这些控件基于`Product`对象当前的状态。'
- en: '`Controllers`: Controllers are the components that handle user interaction,
    work with the model, and ultimately select a view to render that displays UI.
    In an MVC application, the view only displays information; the controller handles
    and responds to user input and interaction. For example, the controller handles
    query-string values and passes these values to the model, which in turn might
    use these values to query the database.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`控制器`：控制器是处理用户交互、与模型协同工作并最终选择一个视图以显示 UI 的组件。在 MVC 应用中，视图仅显示信息；控制器处理并响应用户输入和交互。例如，控制器处理查询字符串值并将这些值传递给模型，模型随后可能使用这些值来查询数据库。'
- en: The MVC design pattern can be implemented in both the backend and the frontend.
    However, in this section, we are going to implement it in the backend.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 设计模式可以在后端和前端中实现。然而，在本节中，我们将它在后端实现。
- en: Please note that to be able to run this example without problems, you must first
    install all dependencies using `npm install` from the `chapter_10` folder in the
    companion source code. Then you can open `09_mvc`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了能够无问题地运行此示例，您必须首先使用 `npm install` 从配套源代码中的 `chapter_10` 文件夹安装所有依赖项。然后您可以打开
    `09_mvc`。
- en: Model
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'Our model is going to be composed of two layers. We are going to implement
    an entity and a repository. The entity is implemented using TypeORM:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式将包含两层。我们将实现一个实体和一个仓库。实体是使用 TypeORM 实现的：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Repository
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: 'The repository is also implemented with TypeORM:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库也是使用 TypeORM 实现的：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Controller
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: The controller uses the model (entity + repository) and it is implemented using
    the Express routing techniques that we explored earlier in this chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器使用模型（实体 + 仓库），并且它是使用我们在本章早期探索的 Express 路由技术实现的。
- en: We are going to declare routes to get all movies, filter movies by year, and
    create a new movie. The example also uses `req.params` to access the request parameter
    year.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明路由以获取所有电影、按年份过滤电影以及创建一部新电影。示例还使用 `req.params` 来访问请求参数年份。
- en: 'It is important to note that we can use the `get` method to declare a route
    handler for an HTTP GET request, while we can use the `post` method to declare
    a route handler for an HTTP POST request:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们可以使用 `get` 方法来声明 HTTP GET 请求的路由处理程序，而我们可以使用 `post` 方法来声明 HTTP POST
    请求的路由处理程序：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Database
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: 'In our repository, we have used the `getConnection` function from TypeORM.
    Before we can invoke this function, we need to ensure that a connection has been
    created. The following function is used later to create a database connection:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的仓库中，我们使用了 TypeORM 的 `getConnection` 函数。在我们调用此函数之前，我们需要确保已创建了一个连接。以下函数用于稍后创建数据库连接：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: View
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Because we are implementing REST services, we don't have a data presentation
    layer. The REST API can be completely decoupled from the web user interface. We
    will not learn how to implement the presentation layer in this chapter because
    this topic is going to be covered in the upcoming chapters.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在实现 REST 服务，我们没有数据表示层。REST API 可以完全与网络用户界面解耦。我们不会在本章学习如何实现表示层，因为这个主题将在接下来的章节中介绍。
- en: Index
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: 'The index file is the application''s entry point. The entry point creates a
    new Express app and a database connection. It then connects the controller routes
    to the Express app and launches the web server:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 索引文件是应用程序的入口点。入口点创建一个新的 Express 应用和一个数据库连接。然后它将控制器路由连接到 Express 应用并启动网络服务器：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Controllers and routing with inversify-express-utils
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 inversify-express-utils 的控制器和路由
- en: 'Earlier in this book, we learned about dependency injection and dependency
    inversion with InversifyJS. In this section, we are going to learn how to use
    InversifyJS together with Express, using a helper `npm` module known as `inversify-express-utils`.
    We are going to need to install `inversify` and `inversify-express-utils`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分，我们学习了使用 InversifyJS 进行依赖注入和依赖反转。在本节中，我们将学习如何结合使用 InversifyJS 和 Express，利用一个名为
    `inversify-express-utils` 的辅助 `npm` 模块。我们需要安装 `inversify` 和 `inversify-express-utils`：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Please note that to be able to run this example without problems, you must first
    install all dependencies using `npm install` from the `chapter_10` folder in the
    companion source code. Then you can open the `10_inversify_express_utils` folder.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了能够无问题地运行此示例，您必须首先使用 `npm install` 从配套源代码中的 `chapter_10` 文件夹安装所有依赖项。然后您可以打开
    `10_inversify_express_utils` 文件夹。
- en: Model, repository, database, and view
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型、仓库、数据库和视图
- en: We can reuse 100% of the code used for the model, repository, database, and
    view in the preceding example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用前面示例中用于模型、仓库、数据库和视图的 100% 的代码。
- en: Types
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'We need to declare some identifiers required for the InversifyJS type bindings.
    If you don''t know what a type binding is, you should go back to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml),
    *Working with Dependencies*, to learn the basics about InversifyJS. We are going
    to declare a binding for the `MovieRepository` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明一些用于 InversifyJS 类型绑定的标识符。如果你不知道类型绑定是什么，你应该回到[第5章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)，*与依赖项一起工作*，以了解
    InversifyJS 的基础知识。我们将为 `MovieRepository` 类声明一个绑定：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Controller
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: The InversifyJS Express utils allow us to declare controllers using what is
    known as declarative routing. Instead of declaring `Router` instances, we can
    annotate a controller class using some decorators. The metadata generated by the
    decorators is later used by the InversifyJS express utils to generate the `Router`
    instances for us.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: InversifyJS Express 工具允许我们使用所谓的声明式路由来声明控制器。我们不需要声明 `Router` 实例，而是可以使用一些装饰器来注解控制器类。装饰器生成的元数据随后将由
    InversifyJS express 工具用于为我们生成 `Router` 实例。
- en: 'The following example uses the following decorators:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用了以下装饰器：
- en: '`@controller(path)`: It is used to declare the path of a router'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@controller(path)`: 它用于声明路由的路径'
- en: '`@inject(type)`: It is used to inject dependencies into a class'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inject(type)`: 它用于将依赖项注入到类中'
- en: '`@httpGet(subpath)`: It is used to declare a route handler for HTTP GET requests'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@httpGet(subpath)`: 它用于声明 HTTP GET 请求的路由处理器'
- en: '`@httpPost(subpath)`: It is used to declare a route handler for HTTP POST requests'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@httpPost(subpath)`: 它用于声明 HTTP POST 请求的路由处理器'
- en: '`@response()`: It is used to pass the response object to a route handler as
    an argument'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@response()`: 它用于将响应对象作为参数传递给路由处理器'
- en: '`@requestParam(paramName)`: It is used to pass a request parameter to a route
    handler as an argument'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@requestParam(paramName)`: 它用于将请求参数作为参数传递给路由处理器'
- en: '`@requestBody()`: It is used to pass the request body to a route handler as
    an argument'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@requestBody()`: 它用于将请求体作为参数传递给路由处理器'
- en: 'Another interesting feature of the InversifyJS Express utils is that we can
    use `async` methods. InversifyJS will automatically detect whether our methods
    are `async` and use `await` when necessary:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: InversifyJS Express 工具的另一个有趣特性是我们可以使用 `async` 方法。InversifyJS 将自动检测我们的方法是否是 `async`，并在需要时使用
    `await`：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: InversifyJS configuration
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InversifyJS 配置
- en: 'We are going to declare some type bindings. We are going to declare the type
    bindings using `AsyncContainerModule` because we need to wait for the database
    connection to be ready. We are going to declare a binding for `MovieRepository`.
    We don''t need to declare a binding for the `MovieController` because the `@controller(path)`
    annotation will create it for us. However, we need to import the controller to
    ensure that the decorator is executed and, as a result, the binding is declared:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明一些类型绑定。我们将使用 `AsyncContainerModule` 来声明类型绑定，因为我们需要等待数据库连接就绪。我们将为 `MovieRepository`
    声明一个绑定。我们不需要为 `MovieController` 声明绑定，因为 `@controller(path)` 注解会为我们创建它。然而，我们需要导入控制器以确保装饰器被执行，从而声明绑定：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Index
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: 'The index file is also different. Instead of creating a new *Express* app,
    we need to create a new *InversifyExpressServer* app. The `InversifyExpressServer`
    constructor requires an instance of `Container`. The type bindings for the container
    are declared in the bindings object, which is an instance of the `AsyncContainerModule`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 索引文件也有所不同。我们不需要创建一个新的 *Express* 应用，而是需要创建一个新的 *InversifyExpressServer* 应用。`InversifyExpressServer`
    构造函数需要一个 `Container` 实例。容器的类型绑定在绑定对象中声明，该对象是 `AsyncContainerModule` 的一个实例：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, to learn more dependency injection and dependency inversion
    with InversifyJS.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第5章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)，*与依赖项一起工作*，以了解更多关于 InversifyJS
    的依赖注入和依赖反转。
- en: Please refer to the official InversifyJS express utils at [https://github.com/inversify/inversify-express-utils](https://github.com/inversify/inversify-express-utils)
    to learn more about it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://github.com/inversify/inversify-express-utils](https://github.com/inversify/inversify-express-utils)
    上的官方 InversifyJS express 工具以了解更多信息。
- en: Other applications of Node.js
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 的其他应用
- en: Developing command-line applications or REST APIs is not the only real-world
    application of Node.js. For example, we can develop desktop applications using
    Electron. Node.js is also commonly used as a reverse proxy and powers many web
    development tools.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 开发命令行应用程序或REST API并不是Node.js的唯一实际应用。例如，我们可以使用Electron开发桌面应用程序。Node.js也常被用作反向代理，并驱动许多Web开发工具。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have learned the main characteristics of Node.js as a platform
    and its main components. We have also learned a little bit about the Node.js ecosystem
    and the kind of applications that we can create using it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Node.js作为平台的主要特性和其主要组件。我们还了解了一些关于Node.js生态系统以及我们可以使用它创建的应用类型。
- en: Toward the end of the chapter, we implemented a very small REST API. In the
    next two chapters, we are going to learn how we can use TypeScript to create web-based
    user interfaces that consume these APIs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们实现了一个非常小的REST API。在接下来的两个章节中，我们将学习如何使用TypeScript创建基于Web的用户界面，以消费这些API。
