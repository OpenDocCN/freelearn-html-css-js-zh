<html><head></head><body>
  <div><h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-14" class="chapterTitle">The Node.js Platform</h1>
    <p class="normal">Some principles and design patterns literally define the developer experience with the Node.js platform and its ecosystem. The most peculiar one is probably its asynchronous nature, which makes heavy use of asynchronous constructs such as callbacks and promises. In this introductory chapter, we will explore where Node.js gets its asynchronous behavior from. This is not just good-to-know theoretical information: knowing how Node.js works at its core will give you a strong foundation for understanding the reasoning behind more complex topics and patterns that we will cover later in the book.</p>
    <p class="normal">Another important aspect that characterizes Node.js is its philosophy. Approaching Node.js is, in fact, far more than simply learning a new technology: it's also embracing a culture and a community. You will see how this greatly influences the way we design our applications and components, and the way they interact with those created by the community.</p>
    <p class="normal">In this chapter, you will learn about the following:</p>
    <ul>
      <li class="Bullet--PACKT-">The Node.js philosophy or the "Node way"</li>
      <li class="Bullet--PACKT-">The reactor pattern—the mechanism at the heart of the Node.js asynchronous event-driven architecture</li>
      <li class="Bullet-End--PACKT-">What it means to run JavaScript on the server compared to the browser</li>
    </ul>
    <h1 id="_idParaDest-15" class="title">The Node.js philosophy</h1>
    <p class="normal">Every programming platform has its own philosophy, a set of principles and guidelines that are generally accepted<a id="_idIndexMarker000"/> by the community, or an ideology for doing things that influence both the evolution of the platform and how applications are developed and designed. Some of these principles arise from the technology itself, some of them are enabled by its ecosystem, some are just trends in the community, and others are evolutions of ideologies borrowed from other platforms. In Node.js, some of these principles come directly from its creator—Ryan Dahl—while others come from the people who contribute to the core or from charismatic figures in the community, and, finally, some are inherited from the larger JavaScript movement.</p>
    <p class="normal">None of these rules are imposed and they should always be applied with common sense; however, they can<a id="_idIndexMarker001"/> prove to be tremendously useful when we are looking for a source of inspiration while designing our software.</p>
    <div><p class="Information-Box--PACKT-">You can find an<a id="_idIndexMarker002"/> extensive list of software development philosophies on Wikipedia at <a href="http://nodejsdp.link/dev-philosophies">nodejsdp.link/dev-philosophies</a>.</p>
    </div>
    <h2 id="_idParaDest-16" class="title">Small core</h2>
    <p class="normal">The Node.js core—understood as the Node.js runtime and built-in modules—has its foundations built <a id="_idIndexMarker003"/>on a few principles. One of these is having the smallest possible set of functionalities, while leaving the rest to the so-called <strong class="keyword">userland</strong> (or <strong class="keyword">userspace</strong>), which is<a id="_idIndexMarker004"/> the ecosystem of modules living outside the core. This principle has an enormous impact on the Node.js culture, as it gives freedom to the community to experiment and iterate quickly on a broader set of solutions within the scope of the userland modules, instead of having one slowly evolving solution that is built into the more tightly controlled and stable core. Keeping the core set of functionalities to the bare minimum, then, is not only convenient in terms of maintainability, but also in terms of the positive cultural impact that it brings to the evolution of the entire ecosystem.</p>
    <h2 id="_idParaDest-17" class="title">Small modules</h2>
    <p class="normal">Node.js uses the <a id="_idIndexMarker005"/>concept of a <strong class="keyword">module</strong> as the fundamental means for structuring the code of a program. It is the building block for creating applications and reusable libraries. In Node.js, one of the most evangelized principles is designing small modules (and packages), not only in terms of raw code size, but, most importantly, in terms of scope.</p>
    <p class="normal">This principle has its roots in the Unix philosophy, and particularly in two of its precepts, which are as follows:</p>
    <ul>
      <li class="Bullet--PACKT-">"Small is beautiful."</li>
      <li class="Bullet-End--PACKT-">"Make each program do one thing well."</li>
    </ul>
    <p class="normal">Node.js has brought these concepts to a whole new level. Along with the help of its module managers—with <strong class="keyword">npm</strong> and <strong class="keyword">yarn</strong> being the most popular—Node.js helps to solve the <em class="italic">dependency hell</em> problem by making sure that two (or more) packages depending on different versions of the same package will use their own installations of such a package, thus avoiding conflicts. This aspect allows packages to depend on a high number of small, well-focused dependencies without the risk of creating conflicts. While this can be considered unpractical or even totally unfeasible in other platforms, in Node.js, this practice is the norm. This <a id="_idIndexMarker006"/>enables extreme levels of reusability; they are so extreme, in fact, that sometimes we can find packages comprising of a single module containing just a couple of lines of code—for example, a regular expression for matching emails such as <a href="http://nodejsdp.link/email-regex">nodejsdp.link/email-regex</a>.</p>
    <p class="normal">Besides the clear<a id="_idIndexMarker007"/> advantage in terms of reusability, a small module is also:</p>
    <ul>
      <li class="Bullet--PACKT-">Easier to understand and use</li>
      <li class="Bullet--PACKT-">Simpler to test and maintain</li>
      <li class="Bullet-End--PACKT-">Small in size and perfect for use in the browser</li>
    </ul>
    <p class="normal">Having smaller and more focused <a id="_idIndexMarker008"/>modules empowers everyone to share or reuse even the smallest piece of code; it's the <strong class="keyword">Don't Repeat Yourself</strong> (<strong class="keyword">DRY</strong>) principle applied at a whole new level.</p>
    <h2 id="_idParaDest-18" class="title">Small surface area</h2>
    <p class="normal">In addition to being small in size and scope, a desirable characteristic of Node.js modules is exposing a <a id="_idIndexMarker009"/>minimal set of functionalities to the outside world. This has the effect of producing an API that is clearer to use and less susceptible to erroneous usage. In fact, most of the time the user of a component is only interested in a very limited and focused set of features, without needing to extend its functionality or tap into more advanced aspects.</p>
    <p class="normal">In Node.js, a very common pattern for defining modules is to expose only one functionality, such as a function or a class, for the simple fact that it provides a single, unmistakably clear entry point.</p>
    <p class="normal">Another characteristic of many Node.js modules is the fact that they are created to be used, rather than extended. Locking down the internals of a module by forbidding any possibility of an extension might sound inflexible, but it actually has the advantage of reducing use cases, simplifying implementation, facilitating maintenance, and increasing usability. In practice, this means preferring to expose functions instead of classes, and being careful not to expose any internals to the outside world.</p>
    <h2 id="_idParaDest-19" class="title">Simplicity and pragmatism</h2>
    <p class="normal">Have you ever<a id="_idIndexMarker010"/> heard of the <strong class="keyword">Keep It Simple, Stupid</strong> (<strong class="keyword">KISS</strong>) principle? Richard P. Gabriel, a prominent computer scientist, coined the term "worse is better" to describe <a id="_idIndexMarker011"/>the model whereby less and simpler functionality is a good design choice for software. In his essay <em class="italic">The Rise of "Worse is Better"</em> he says:</p>
    <blockquote class="packt_quote"><p>"The design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design."</p></blockquote>
    <p class="normal">Designing simple, as opposed to perfect, fully featured software is a good practice for several reasons: it takes less effort to implement, it allows shipping faster with fewer resources, it's easier to adapt, and, finally, it's easier to maintain and understand. The positive effects of these factors encourage community contributions and allow the software itself to grow and improve.</p>
    <p class="normal">In Node.js, the adoption of this principle is also facilitated by JavaScript, which is a very pragmatic language. In fact, it's common to see simple classes, functions, and closures replacing complex class hierarchies. Pure object-oriented designs often try to replicate the real world using the mathematical terms of a computer system without considering the imperfection and complexity of the real world itself. Instead, the truth is that our software is always an approximation of reality, and we will probably have more success by trying to get something working sooner and with reasonable complexity, instead of trying to create near-perfect software with huge effort and tons of code to maintain.</p>
    <p class="normal">Throughout this book, you will see this principle in action many times. For example, a considerable number of traditional design patterns, such as Singleton or Decorator, can have a trivial, even if sometimes not bulletproof, implementation, and you will see how an uncomplicated, practical approach is (most of the time) preferred to a pure, flawless design.</p>
    <p class="normal">Next, we will take a look inside the Node.js core to reveal its internal patterns and event-driven architecture.</p>
    <h1 id="_idParaDest-20" class="title">How Node.js works</h1>
    <p class="normal">In this section, you will gain <a id="_idIndexMarker012"/>an understanding of how Node.js works internally and be introduced to the reactor pattern, which is the heart of the asynchronous nature of Node.js. We will go through the main concepts behind the pattern, such as the single-threaded architecture and the non-blocking I/O, and you will see how this creates the <a id="_idIndexMarker013"/>foundation for the entire Node.js platform.</p>
    <h2 id="_idParaDest-21" class="title">I/O is slow</h2>
    <p class="normal">I/O (short for input/output) is definitely the slowest among the fundamental operations of a computer. Accessing the <a id="_idIndexMarker014"/>RAM is in the order of nanoseconds (10E-9 seconds), while accessing data on the disk or the network is in the order of milliseconds (10E-3 seconds). The same applies to the bandwidth. RAM has a transfer rate consistently in the order of GB/s, while the disk or network varies from MB/s to optimistically GB/s. I/O is usually not expensive in terms of CPU, but it adds a delay between the moment the request is sent to the device and the moment the operation completes. On top of that, we have to consider the human factor. In fact, in many circumstances, the input of an application comes from a real person—a mouse click, for example—so the speed and frequency of I/O doesn't only depend on technical aspects, and it can be many orders of magnitude slower than the disk or network.</p>
    <h2 id="_idParaDest-22" class="title">Blocking I/O</h2>
    <p class="normal">In traditional blocking I/O programming, the function call corresponding to an I/O request will block <a id="_idIndexMarker015"/>the execution of the thread until the operation completes. This can range from a few milliseconds, in the case of disk access, to minutes or even more, in the case of data being generated from user actions, such as pressing a key. The following pseudocode shows a typical blocking thread performed against a socket:</p>
    <pre class="programlisting code"><code class="hljs-code">// blocks the thread until the data is available
data = socket.read()
// data is available
print(data)
</code></pre>
    <p class="normal">It is trivial to notice that a web server that is implemented using blocking I/O will not be able to handle multiple connections in the same thread. This is because each I/O operation on a socket will block the processing of any other connection. The traditional approach to solving this problem is to use a separate thread (or process) to handle each concurrent connection. </p>
    <p class="normal">This way, a thread blocked on an I/O operation will not impact the availability of the other connections, because they are handled in separate threads.</p>
    <p class="normal">The following illustrates this scenario:</p>
    <figure class="mediaobject"><img src="img/B15729_01_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.1: Using multiple threads to process multiple connections</p>
    <p class="normal"><em class="italic">Figure 1.1</em> lays emphasis on the amount of time each thread is idle and waiting for new data to be received from the associated connection. Now, if we also consider that any type of I/O can possibly block a <a id="_idIndexMarker016"/>request—for example, while interacting with databases or with the filesystem—we will soon realize how many times a thread has to block in order to wait for the result of an I/O operation. Unfortunately, a thread is not cheap in terms of system resources—it consumes memory and causes context switches—so having a long-running thread for each connection and not using it for most of the time means wasting precious memory and CPU cycles.</p>
    <h2 id="_idParaDest-23" class="title">Non-blocking I/O</h2>
    <p class="normal">In addition to blocking I/O, most modern operating systems support another mechanism to access resources, called non-blocking I/O. In this operating mode, the system call always returns<a id="_idIndexMarker017"/> immediately without waiting for the data to be read or written. If no results are available at the moment of the call, the function will simply return a predefined constant, indicating that there is no data available to return at that moment.</p>
    <p class="normal">For example, in Unix operating systems, the <code class="Code-In-Text--PACKT-">fcntl()</code> function is used to manipulate an existing file descriptor (which in Unix represents the reference used to access a local file or a network socket) to change its operating mode to non-blocking (with the <code class="Code-In-Text--PACKT-">O_NONBLOCK</code> flag). Once the resource is in non-blocking mode, any read operation will fail with the return code <code class="Code-In-Text--PACKT-">EAGAIN</code> if the resource doesn't have any data ready to be read.</p>
    <p class="normal">The most basic pattern for dealing with this type of non-blocking I/O is to actively poll the resource within a loop until some actual data is returned. This is called <strong class="keyword">busy-waiting</strong>. The following pseudocode shows you how it's possible to read from multiple resources using non-blocking I/O and an active polling loop:</p>
    <pre class="programlisting code"><code class="hljs-code">resources = [socketA, socketB, fileA]
while (!resources.isEmpty()) {
  for (resource of resources) {
    // try to read
    data = resource.read()
    if (data === NO_DATA_AVAILABLE) {
      // there is no data to read at the moment
      continue
    }
    if (data === RESOURCE_CLOSED) {
      // the resource was closed, remove it from the list
      resources.remove(i)
    } else {
      //some data was received, process it
      consumeData(data)
    }
  }
}
</code></pre>
    <p class="normal">As you can see, with this<a id="_idIndexMarker018"/> simple technique, it is possible to handle different resources in the same thread, but it's still not efficient. In fact, in the preceding example, the loop will only consume precious CPU for iterating over resources that are unavailable most of the time. Polling algorithms usually result in a huge amount of wasted CPU time.</p>
    <h2 id="_idParaDest-24" class="title">Event demultiplexing</h2>
    <p class="normal">Busy-waiting is definitely not an ideal technique for processing non-blocking resources, but luckily, most modern <a id="_idIndexMarker019"/>operating systems provide a native <a id="_idIndexMarker020"/>mechanism to handle concurrent non-blocking resources in an efficient way. We are talking about the <strong class="keyword">synchronous event demultiplexer</strong> (also known as the <strong class="keyword">event notification interface</strong>).</p>
    <p class="normal">If you are unfamiliar with the term, in telecommunications, <strong class="keyword">multiplexing</strong> refers to the method by which multiple signals are combined into one so that they can be easily transmitted over a medium with limited capacity. </p>
    <p class="normal"><strong class="keyword">Demultiplexing</strong> refers to the opposite operation, whereby the signal is split again into its original components. Both terms are used in other areas (for example, video processing) to describe the general operation of combining different things into one and vice versa.</p>
    <p class="normal">The synchronous event demultiplexer that we were talking about watches multiple resources and returns a new event (or set of events) when a read or write operation executed over one of those resources completes. The advantage here is that the synchronous event demultiplexer is, of course, synchronous, so it blocks until there are new events to process. The following is the pseudocode of an algorithm that uses a generic synchronous event <a id="_idIndexMarker021"/>demultiplexer to read from two different resources:</p>
    <pre class="programlisting code"><code class="hljs-code">watchedList.add(socketA, FOR_READ)                            // (1)
watchedList.add(fileB, FOR_READ)
while (events = demultiplexer.watch(watchedList)) {           // (2)
  // event loop
  for (event of events) {                                     // (3)
    // This read will never block and will always return data
    data = event.resource.read()
    if (data === RESOURCE_CLOSED) {
      // the resource was closed, remove it from the watched list
      demultiplexer.unwatch(event.resource)
    } else {
      // some actual data was received, process it
      consumeData(data)
    }
  }
}
</code></pre>
    <p class="normal">Let's see what happens in the preceding pseudocode:</p>
    <ol>
      <li class="numbered">The resources are added to a data structure, associating each one of them with a specific operation (in our example, a <code class="Code-In-Text--PACKT-">read)</code>.</li>
      <li class="numbered">The demultiplexer is set up with the group of resources to be watched. The call to <code class="Code-In-Text--PACKT-">demultiplexer.watch()</code> is synchronous and blocks until any of the watched resources are ready for <code class="Code-In-Text--PACKT-">read</code>. When this occurs, the event demultiplexer returns from the call and a new set of events is available to be processed.</li>
      <li class="numbered">Each event returned by the event demultiplexer is processed. At this point, the resource associated with each event is guaranteed to be ready to read and to not block during the operation. When all the events are processed, the flow will block again on the event demultiplexer until new events are again available to be<a id="_idIndexMarker022"/> processed. This is called the <strong class="keyword">event loop</strong>.</li>
    </ol>
    <p class="normal">It's interesting to see that, with this pattern, we can now handle several I/O operations inside a single thread, without using the busy-waiting technique. It should now be clearer why we are talking about demultiplexing; using just a single thread, we can deal with multiple resources. <em class="italic">Figure 1.2</em> will help you visualize what's happening in a web server that uses a synchronous event demultiplexer and a single thread to handle multiple concurrent connections:</p>
    <figure class="mediaobject"><img src="img/B15729_01_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.2: Using a single thread to process multiple connections</p>
    <p class="normal">As this shows, using only one thread does not impair our ability to run multiple I/O-bound tasks concurrently. The tasks are spread over time, instead of being spread across multiple <a id="_idIndexMarker023"/>threads. This has the clear advantage of minimizing the total idle time of the thread, as is clearly shown in <em class="italic">Figure 1.2</em>.</p>
    <p class="normal">But this is not the only reason for choosing this I/O model. In fact, having a single thread also has a beneficial impact on the way programmers approach concurrency in general. Throughout the book, you will see how the absence of in-process race conditions and multiple threads to synchronize allows us to use much simpler concurrency strategies.</p>
    <h2 id="_idParaDest-25" class="title">The reactor pattern</h2>
    <p class="normal">We can now introduce<a id="_idIndexMarker024"/> the reactor pattern, which is a specialization<a id="_idIndexMarker025"/> of the algorithms presented in the previous sections. The main idea behind the reactor pattern is to have a handler associated with each I/O operation. A handler in Node.js is represented by a <code class="Code-In-Text--PACKT-">callback</code> (or <code class="Code-In-Text--PACKT-">cb</code> for short) function. </p>
    <p class="normal">The handler will be invoked as soon as an event is produced and processed by the event loop. The structure of the reactor pattern is shown in <em class="italic">Figure 1.3</em>:</p>
    <figure class="mediaobject"><img src="img/B15729_01_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.3: The reactor pattern</p>
    <p class="normal">This is what<a id="_idIndexMarker026"/> happens<a id="_idIndexMarker027"/> in an application using the reactor pattern:</p>
    <ol>
      <li class="numbered">The application generates a new I/O operation by submitting a request to the <strong class="keyword">Event Demultiplexer</strong>. The application also specifies a handler, which will be invoked when the operation completes. Submitting a new request to the <strong class="keyword">Event Demultiplexer</strong> is a non-blocking call and it immediately returns control to the application.</li>
      <li class="numbered">When a set of I/O operations completes, the <strong class="keyword">Event Demultiplexer</strong> pushes a set of corresponding events into the <strong class="keyword">Event Queue</strong>.</li>
      <li class="numbered">At this point, the <strong class="keyword">Event Loop</strong> iterates over the items of the <strong class="keyword">Event Queue</strong>.</li>
      <li class="numbered">For each event, the associated handler is invoked.</li>
      <li class="numbered">The handler, which is part of the application code, gives back control to the <strong class="keyword">Event Loop</strong> when its execution completes (<strong class="keyword">5a</strong>). While the handler executes, it can request new asynchronous operations (<strong class="keyword">5b</strong>), causing new items to be added to the <strong class="keyword">Event Demultiplexer</strong> (<strong class="keyword">1</strong>).</li>
      <li class="numbered">When all the items in the <strong class="keyword">Event Queue</strong> are processed, the <strong class="keyword">Event Loop</strong> blocks again on the <strong class="keyword">Event Demultiplexer</strong>, which then triggers another cycle when a new event is available.</li>
    </ol>
    <p class="normal">The asynchronous behavior has now become clear. The application expresses interest in accessing a resource at one point in time (without blocking) and provides a handler, which will <a id="_idIndexMarker028"/>then be<a id="_idIndexMarker029"/> invoked at another point in time when the operation completes.</p>
    <div><p class="Information-Box--PACKT-">A Node.js application will exit when there are no more pending operations in the event demultiplexer, and no more events to be processed inside the event queue.</p>
    </div>
    <p class="normal">We can now define the pattern at the heart of Node.js:</p>
    <div><p class="Information-Box--PACKT-"><strong class="screenText">The reactor pattern</strong></p>
      <p class="Information-Box--PACKT-">Handles I/O by blocking until new events are available from a set of observed resources, and then reacts by dispatching each event to an associated handler.</p>
    </div>
    <h2 id="_idParaDest-26" class="title">Libuv, the I/O engine of Node.js</h2>
    <p class="normal">Each operating system has its own interface for the event demultiplexer: <code class="Code-In-Text--PACKT-">epoll</code> on Linux, <code class="Code-In-Text--PACKT-">kqueue</code> on <a id="_idIndexMarker030"/>macOS, and the I/O completion port (IOCP) API on Windows. On top of that, each I/O operation can <a id="_idIndexMarker031"/>behave quite differently depending on the type of resource, even within the same operating system. In Unix operating systems, for example, regular filesystem files do not support non-blocking operations, so in order to simulate non-blocking behavior, it is necessary to use a separate thread outside the event loop.</p>
    <p class="normal">All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the event demultiplexer. This is exactly why the Node.js core team created a native l<a id="_idIndexMarker032"/>ibrary called <strong class="keyword">libuv</strong>, with the objective to make Node.js compatible with all the major operating systems and normalize the non-blocking behavior of the different types of resource. Libuv represents the low-level I/O engine of Node.js and is probably the most important component that Node.js is built on.</p>
    <p class="normal">Other than abstracting the underlying system calls, libuv also implements the reactor pattern, thus providing an API for creating event loops, managing the event queue, running asynchronous I/O operations, and queuing other types of task.</p>
    <div><p class="Information-Box--PACKT-">A great resource to learn more about libuv is the free online book created by Nikhil Marathe, which<a id="_idIndexMarker033"/> is available at <a href="http://nodejsdp.link/uvbook">nodejsdp.link/uvbook</a>.</p>
    </div>
    <h2 id="_idParaDest-27" class="title">The recipe for Node.js</h2>
    <p class="normal">The reactor pattern and libuv are the basic building blocks of Node.js, but we need three more components to<a id="_idIndexMarker034"/> build the full platform:</p>
    <ul>
      <li class="Bullet--PACKT-">A set of bindings responsible for wrapping and exposing libuv and other low-level functionalities to JavaScript.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">V8</strong>, the JavaScript engine originally developed by Google for the Chrome browser. This is one of the reasons why Node.js is so fast and efficient. V8 is acclaimed for its revolutionary design, its speed, and for its efficient memory management.</li>
      <li class="Bullet-End--PACKT-">A core JavaScript library that implements the high-level Node.js API.</li>
    </ul>
    <p class="normal">This is the recipe for creating Node.js, and the following image represents its final architecture:</p>
    <figure class="mediaobject"><img src="img/B15729_01_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.4: The Node.js internal components</p>
    <p class="normal">This concludes our journey through the internal mechanisms of Node.js. Next, we'll take a look at some important aspects to take into consideration when working with JavaScript in Node.js.</p>
    <h1 id="_idParaDest-28" class="title">JavaScript in Node.js</h1>
    <p class="normal">One important consequence of the architecture we have just analyzed is that the JavaScript we use in Node.js<a id="_idIndexMarker035"/> is somewhat different from the JavaScript we use in the browser.</p>
    <p class="normal">The most obvious difference is that in Node.js we don't have a DOM and we don't have a <code class="Code-In-Text--PACKT-">window</code> or a <code class="Code-In-Text--PACKT-">document</code>. On the other hand, Node.js has access to a set of services offered by the underlying operating system that are not available in the browser. In fact, the browser has to implement a set of safety measures to make sure that the underlying system is not compromised by a rogue web application. The browser provides a higher-level abstraction over the operating system resources, which makes it easier to control and contain the code that runs in it, which will also inevitably limit its capabilities. In turn, in Node.js we can virtually have access to all the services exposed by the operating system.</p>
    <p class="normal">In this overview, we'll take a look at some key facts to keep in mind when using JavaScript in Node.js.</p>
    <h2 id="_idParaDest-29" class="title">Run the latest JavaScript with confidence</h2>
    <p class="normal">One of the main pain points of using JavaScript in the browser is that our code will likely run on a variety of devices <a id="_idIndexMarker036"/>and browsers. Dealing with different browsers means dealing with JavaScript runtimes that may miss some of the newest features of both the language or the web platform. Luckily, today this problem can be somewhat mitigated by the use of transpilers and polyfills. Nonetheless, this brings its own set of disadvantages and not everything can be polyfilled.</p>
    <p class="normal">All these inconveniences don't apply when developing applications on Node.js. In fact, our Node.js applications will most likely run on a system and a Node.js runtime that are well known in advance. This makes a huge difference as it allows us to target our code for a specific JavaScript and Node.js version, with the absolute guarantee that we won't have any surprises when we run it on production.</p>
    <p class="normal">This factor, in combination with the fact that Node.js ships with very recent versions of V8, means that we can use with confidence most of the features of the latest ECMAScript specification (ES for short; this is the standard on which the JavaScript language is based) without the need for any extra transpilation step.</p>
    <p class="normal">Please bear in mind, though, that if we are developing a library meant to be used by third parties, we still have to take into account that our code may run on different versions of Node.js. The general <a id="_idIndexMarker037"/>pattern in this case is to target the oldest active <strong class="keyword">long-term support</strong> (<strong class="keyword">LTS</strong>) release and specify the <code class="Code-In-Text--PACKT-">engines</code> section in our <code class="Code-In-Text--PACKT-">package.json</code>, so that the package manager will warn the user if they are trying to install a package that is not compatible with their<a id="_idIndexMarker038"/> version of Node.js.</p>
    <div><p class="Tip--PACKT-">You can find out <a id="_idIndexMarker039"/>more about the Node.js release cycles at <a href="http://nodejsdp.link/node-releases">nodejsdp.link/node-releases</a>. Also, you can find the reference for the <code class="Code-In-Text--PACKT-">engines</code> section of <code class="Code-In-Text--PACKT-">package.json</code> at <a href="http://nodejsdp.link/package-engines">nodejsdp.link/package-engines</a>. Finally, you can get an idea of what ES feature is supported by each Node.js version at <a href="http://nodejsdp.link/node-green">nodejsdp.link/node-green</a>.</p>
    </div>
    <h2 id="_idParaDest-30" class="title">The module system</h2>
    <p class="normal">From its inception, Node.js shipped with a module system, even when JavaScript still had no official support<a id="_idIndexMarker040"/> for any form of it. The original Node.js module system is called CommonJS and it uses the <code class="Code-In-Text--PACKT-">require</code> keyword to import functions, variables, and classes exported by built-in modules or other modules located on the device's filesystem.</p>
    <p class="normal">CommonJS was a revolution for the JavaScript world in general, as it started to get popular even in the client-side world, where it is used in combination with a module bundler (such as Webpack or Rollup) to produce code bundles that are easily executable by the browser. CommonJS was a necessary component for Node.js to allow developers to create large and better organized applications on a par with other server-side platforms.</p>
    <p class="normal">Today, JavaScript has the so-called ES modules syntax (the <code class="Code-In-Text--PACKT-">import</code> keyword may be more familiar) from which Node.js inherits just the syntax, as the underlying implementation is somewhat different from that of the browser. In fact, while the browser mainly deals with remote modules, Node.js, at least for now, can only deal with modules located on the local filesystem.</p>
    <p class="normal">We'll talk about modules in more detail in the next chapter.</p>
    <h2 id="_idParaDest-31" class="title">Full access to operating system services</h2>
    <p class="normal">As we already mentioned, even if Node.js uses JavaScript, it doesn't run inside the boundaries of a<a id="_idIndexMarker041"/> browser. This allows Node.js to have bindings for all the major services offered by the underlying operating system.</p>
    <p class="normal">For example, we can access any file on the filesystem (subject to any operating system-level permission) thanks to the <code class="Code-In-Text--PACKT-">fs</code> module, or we can write applications that use low-level TCP or UDP sockets thanks to the <code class="Code-In-Text--PACKT-">net</code> and <code class="Code-In-Text--PACKT-">dgram</code> modules. We can create HTTP(S) servers (with the <code class="Code-In-Text--PACKT-">http</code> and <code class="Code-In-Text--PACKT-">https</code> modules) or use the standard encryption and hashing algorithms of OpenSSL (with the <code class="Code-In-Text--PACKT-">crypto</code> module). We can also access some of the V8 internals (the <code class="Code-In-Text--PACKT-">v8</code> module) or run code in a different V8 context (with the <code class="Code-In-Text--PACKT-">vm</code> module).</p>
    <p class="normal">We can also run other processes (with the <code class="Code-In-Text--PACKT-">child_process</code> module) or retrieve our own application's process information using the <code class="Code-In-Text--PACKT-">process</code> global variable. In particular, from the <code class="Code-In-Text--PACKT-">process</code> global variable, we can get a list of the environment variables assigned to the process (with <code class="Code-In-Text--PACKT-">process.env</code>) or the command-line arguments passed to the application at the moment of its launch (with <code class="Code-In-Text--PACKT-">process.argv</code>).</p>
    <p class="normal">Throughout the book, you'll have the opportunity to use many of the modules described here, but for a complete reference, you can check the official Node.js documentation at <a href="http://nodejsdp.link/node-docs">nodejsdp.link/node-docs</a>.</p>
    <h2 id="_idParaDest-32" class="title">Running native code</h2>
    <p class="normal">One of the most powerful capabilities offered by Node.js is certainly the possibility to create userland <a id="_idIndexMarker042"/>modules that can bind to native code. This gives to the platform a tremendous advantage as it allows us to reuse existing or new components written in C/C++. Node.js officially provides great support for implementing native modules thanks to the N-API interface.</p>
    <p class="normal">But what's the advantage? First of all, it allows us to reuse with little effort a vast amount of existing open source libraries, and most importantly, it allows a company to reuse its own C/C++ legacy code without the need to migrate it.</p>
    <p class="normal">Another important consideration is that native code is still necessary to access low-level features such as communicating with hardware drivers or with hardware ports (for example, USB or serial). In fact, thanks to its ability to link to native code, Node.js has become popular in the world of the <strong class="keyword">Internet of things</strong> (<strong class="keyword">IoT</strong>) and homemade robotics.</p>
    <p class="normal">Finally, even though V8 is very (very) fast at executing JavaScript, it still has a performance penalty to pay compared to executing native code. In everyday computing, this is rarely an issue, but for CPU-intensive applications, such as those with a lot of data processing and manipulation, delegating the work to native code can make tons of sense.</p>
    <p class="normal">We should also mention that, nowadays, most JavaScript <strong class="keyword">virtual machines</strong> (<strong class="keyword">VMs</strong>) (and also Node.js) support <strong class="keyword">WebAssembly</strong> (<strong class="keyword">Wasm</strong>), a low-level instruction format that allows us to compile languages other than JavaScript (such as C++ or Rust) into a format that is "understandable" by JavaScript VMs. This brings many of the advantages we have mentioned, without the <a id="_idIndexMarker043"/>need to directly interface with native code.</p>
    <div><p class="Tip--PACKT-">You can learn more about Wasm on<a id="_idIndexMarker044"/> the official website of the project at <a href="http://nodejsdp.link/webassembly">nodejsdp.link/webassembly</a>.</p>
    </div>
    <h1 id="_idParaDest-33" class="title">Summary</h1>
    <p class="normal">In this chapter, you have seen how the Node.js platform is built upon a few important principles that shape both its internal architecture and the code we write. You have learned that Node.js has a minimal core, and that embracing the "Node way" means writing modules that are smaller, simpler, and that expose only the minimum functionality necessary.</p>
    <p class="normal">Next, you discovered the reactor pattern, which is the pulsating heart of Node.js, and dissected the internal architecture of the platform runtime to reveal its three pillars: V8, libuv, and the core JavaScript library.</p>
    <p class="normal">Finally, we analyzed some of the main characteristics of using JavaScript in Node.js compared to the browser.</p>
    <p class="normal">Besides the obvious technical advantages enabled by its internal architecture, Node.js is attracting so much interest because of the principles you have just discovered and the community orbiting around it. For many, grasping the essence of this world feels like returning to the origins, to a more humane way of programming in both size and complexity, and that's why developers end up falling in love with Node.js.</p>
    <p class="normal">In the next chapter, we will go deep into one of the most fundamental and important topics of Node.js, its module system.</p>
  </div>
</body></html>