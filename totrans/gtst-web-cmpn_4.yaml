- en: Building Reusable Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about styling our Web Components, along with
    understanding how accessibility plays a vital role in creating a good component.
    We then talked about the Gold Standard Checklist and looked into unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking deep into reusability and how we can publish
    our Web Components on a platform for maximum reusability. We will also cover a
    few examples on responsive Web Components. We did look into styling, and while
    the concept of responsive CSS is not something new, the use of responsive styles
    could make a component look even better and more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive Web Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing Web Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Web Components - slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we even dive into the concept of reusability in Web Components, let's
    take a look at what reusability is with the help of an example. Let's take an
    example of an operating system, say Windows 10\. Now, we all know there are a
    lot of computers. Some with the same hardware and some with different. But what
    makes this piece of software (Windows 10) reusable is its ability to being used
    again and again and in different scenarios without any issues. The exact same
    thing can be made to work for a Web Component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, Web Components can be made extremely reusable. Let''s say we have a Web
    Component `<custom-header>`. As the name indicates, it is a header. And most of
    the sites that we have ever visited have one or the other version of the same
    functional header. The functionalities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the logo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the logo should drop the user to `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the name of the company.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show user stats, that is, if the user is not logged in, show the login drop-down
    menu. If the user is logged in, show account-related links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show Help links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show About us and Contact us links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a default background for the header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The header can be sticky at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These points all show us various ways a header can be customized and implemented.
    We can very well convert these points to an attribute list while designing the
    Web Component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if the user is not logged in, it can be left empty like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All these attributes make the Web Component extremely reusable. The person who
    is going to use this component will simply need to import it and provide the values
    of these attributes without coding anything extra.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another, but complex, example. Let us say you are building
    a music player. A Web Component `<music-player>` may have a bunch of attributes
    that make it extremely reusable. The common ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the song
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL of the song
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player color/contrast options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is playing, to tell whether the player is playing or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play on load, to tell whether the player should start playing as soon as the
    player loads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show or hide playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the uncommon ones could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Player size could be set to large, medium, or small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom sticky or top sticky, just like `Soundcloud` does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like or dislike song
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing these attributes and being able to implement them plays a very important
    role in creating a reusable component. A user looking for a music player with
    the ability to show liked or disliked songs will end up using the above-mentioned
    `<music-player>` component rather than something else.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of reusability can be and should be applied to all the Web Components.
    It not only allows the Web Component to be used in more scenarios, it also makes
    it more maintainable, since we are making sure that it works in more scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we talked about adding styles to our Web Component to make
    it look beautiful. This time, we will take a look at it from a reusability perspective.
    What if a person who is trying to reuse our Web Component decides to use it in
    an inline tag, or what if the Web Component is used as a full-width component?
    Let us look into how our Web Component would be displayed inside different box
    models and how it would look on different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Building <profile-info> Web Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us take a look at an example Web Component. Let's say we have a Web Component
    called `<profile-info>`. And the purpose of this Web Component is to show information
    about an employee. The information could be name, designation, ID number, profile
    picture, and a card background color to state whether the employee is a full-time
    employee, a part-time employee, or a contractor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML structure for this `<profile-info>` component would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the list of attributes, we can see that it needs a name, designation, ID
    number, picture link, and employee type. This is what it needs to do in terms
    of functionality. In terms of look and feel, it needs to look like a card with
    rounded profile picture, along with all the remaining information. And based on
    the resolution of the screen, it needs be either full-width, or if the screen
    is that of a mobile device, it should be shown in the form of a card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a mobile first approach on the Web Component, and start writing the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the most basic part that we have covered in the previous chapters. We
    are simply creating the component skeleton and making sure that the HTML for the
    shadow DOM is retrieved from the `getTemplate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the mobile view, the card should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d250889-7a41-43d8-84b9-8cabcf4e6ea2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The HTML structure would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you take a look at the class names, they are all using BEM patterns.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no idea as to what BEM is, the full form of BEM is Block Element
    Modifier. It is a methodology of using logical and reusable CSS classes for modular
    HTML blocks. If you would like to look into it, feel free to look at the following
    link: [http://getbem.com/](http://getbem.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us take a look at the CSS required to build this card. I am wrapping
    the CSS inside another method called `getStyles()` and then I am including it
    inside the `getTemplate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s add the `getStyle()` method to the `getTemplate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look inside the `getStyles()` method, we have these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:host(.profile-info__emp-type-ft)`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:host(.profile-info__emp-type-pt)`, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:host(.profile-info__emp-type-ct)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These change the color of the card on the basis of employee type, that is, full-time,
    part-time, or contractor, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we still have no way to add these classes, so we create a new function
    called `updateCardBackground()` that will be responsible for adding the associated
    class to the Web Component. And then we will call this class inside the `render()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is doing nothing but getting the employee type from the attribute and then
    adding it to the class name of the host.
  prefs: []
  type: TYPE_NORMAL
- en: So if the employee is full-time, then the class becomes `.profile-info__emp-type-ft`;
    if the employee is part-time, then the class becomes `.profile-info__emp-type-pt`;
    and if the employee is a contractor, the class becomes `.profile-info__emp-type-ct`.
    Notice how it is grabbing the employee type from the attribute and appending it
    to the end of the string `.profile-info__emp-type-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are done with creating the component and styling it, let''s add
    the CSS for larger screens, say tablet and desktop. For the sake of simplicity,
    we will use the same CSS for desktop and tablet. So, let''s add the following
    CSS to our `getStyles()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sure that the Web Component looks like it''s from a contact book,
    the way we see on desktops. And it will show up only when the screen size is more
    than `650px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c1cdbbf-2229-4c29-b775-83d8518fc7a4.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are building the Web Component along with this tutorial, try changing
    the width of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a similar approach with any of the Web Components and make sure
    that it looks good when moved from one screen size to another.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are developing a Web Component, whether it is for a company, a side project
    or something that is open source and publicly available, you can make it available
    for use by other people or team members very easily by publishing your Web Component
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'But even before you can publish, you need to make sure that the following steps
    are completed:'
  prefs: []
  type: TYPE_NORMAL
- en: Your component can be installed via `npm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proper README file is present in the repository of your component with steps
    to use and attributes that can be changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A demo folder of a working example with `index.html` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s prepare our file for `npm`. In order to do that, let''s do a quick `npm
    init` inside the `repo` directory with the help of a terminal. I am going to do
    it with the `<profile-info>` component that we discussed in the previous section.
    That will generate a `package.json` file that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create a `ReadMe.md` file in our component directory. And add
    the following text at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I added mine with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a published on webcomponents.org site badge that can be viewed
    by people visiting your GitHub or GitLab page. And it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc661f12-04a0-4af5-929b-afff7243dc56.png)'
  prefs: []
  type: TYPE_IMG
- en: Once this is done, we can set up our `Readme.md` file for a demo section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add to the `Readme.md` file about the attributes, and how it can be
    used as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]html'
  prefs: []
  type: TYPE_NORMAL
- en: <profile-info
  prefs: []
  type: TYPE_NORMAL
- en: name="John Doe"
  prefs: []
  type: TYPE_NORMAL
- en: designation="Frontend Engineer - Marketing"
  prefs: []
  type: TYPE_NORMAL
- en: id-number="PRC-1455"
  prefs: []
  type: TYPE_NORMAL
- en: picture-src="img/john-doe.png"
  prefs: []
  type: TYPE_NORMAL
- en: employee-type="ft">
  prefs: []
  type: TYPE_NORMAL
- en: </profile-info>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now you are ready to publish your Web Component on to the NPM JS site. Just
    type `npm publish` and it will push your code onto the site.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `<profile-info>` Web Component here at [https://www.npmjs.com/package/profile-info:](https://www.npmjs.com/package/profile-info)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb14233f-c25c-43e2-8d1b-2499fae8c7b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are done with this, you can simply go to [https://www.webcomponents.org/publish](https://www.webcomponents.org/publish) and
    scroll down to the section where it says Ready To Publish?, and simply put your
    npm package name and click on the Publish button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7303accc-908e-485a-ad10-0ebf72a44249.png)'
  prefs: []
  type: TYPE_IMG
- en: This will publish your Web Component, which can be used by anyone. Now your
    component is available to be distributed across the web.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Web Components – slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Till now, we have used Web Components with no HTML content inside them. That
    is, when we import an HTML tag for a Web Component that we created, we have never
    placed any other HTML tag inside it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a huge limitation on the Web Component that we are creating. In
    the `<custom header>` component, we failed to add dynamic links. You can argue
    that we can place link data in the form of attributes and then we can run a loop
    inside our component definition and build the links. But what if we want a button
    instead of links? What if we want to show user points instead of the button? So,
    not being able to do these things is a limitation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will extend our current knowledge of Web Components and
    use the concept of slots to put HTML content inside our Web Components. A slot
    is a placeholder for any HTML markup that can be placed inside a Web Component.
    A slot can have a name, and this slot can have HTML or plain text that can be
    used inside our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the Web Component that we have already worked on, `<company-header>`.
    The `getTemplate()` method of this component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that there are two links, `Home` and `About
    Us`. If we want to add one more link to this, we will need to modify the definition
    of the Web Component, which will in turn create problems with maintaining it and
    we will have to create a new version of it every time we want to add a new link.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this problem, we will use slots. We will replace that whole
    `div` that contains the links with a slot of name `other-links`. Let''s take a
    look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can create a slot that can be filled when we use the Web Component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And here, we are filling the slot with a `<ul>` tag that has a `slot` attribute
    with a value `other-links`. You can have any HTML you want inside this slot. You
    can even replace it with plain text.
  prefs: []
  type: TYPE_NORMAL
- en: In a Web Component, there can be any number of slots. It totally depends on
    your use case. But, let us take a look at another example, where we use three
    slots.
  prefs: []
  type: TYPE_NORMAL
- en: Creating <my-article> Web Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a Web Component called `<my-article>` that has three slots: `author`,
    `article-heading`, and `article`. The definition of the Web Component is as follows
    starting with the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are three slots. One for heading, one for author name,
    and one for content. The `getStyle()` method looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And when we try to use it, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can of course change the order of the slots while calling the `<my-article>`
    tag and it will still work as per the definition. The output will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc21c5c7-20f5-4976-82cb-475a0cbc8d67.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we do not have to worry about the look and feel of the content,
    as long as the classes inside the Web Component are taking care of the styling.
    This also shows that it is up to the user to use any number of slots.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about reusability and how we can make sure that our
    Web Component is as reusable as possible. We even looked at how responsiveness
    can be incorporated inside a Web Component for maximum reuse.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to publish our Web Component on the internet as well as a new
    way of letting dynamic content inside a Web Component with the help of slots.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into state management, attributes, and how
    event handling works in a Web Component.
  prefs: []
  type: TYPE_NORMAL
