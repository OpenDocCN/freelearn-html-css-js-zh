- en: 'Chapter 6. The App: Trailers via HTML5 Video'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting features that HTML5 introduces is the ability to
    reproduce multimedia without additional plugins. Although this appears to be the
    right solution for any enterprise application that involves media management,
    there are still many factors to consider. This chapter covers the HTML5 `video`
    and `audio` tags, their use to play media, and some caveats related to the current
    state of this technology.
  prefs: []
  type: TYPE_NORMAL
- en: As an example we are going to build a video player for trailers and an audio
    player for podcasts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 video introduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a video player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 audio introduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an audio player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How I learned to stop worrying and love Flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing HTML5 video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, browsers have relied on video reproduction to external plugins
    like Real Player, Quicktime, and Flash. Having 99 percent penetration of the market,
    Flash became a de facto standard for media playback; however, in the last few
    years, mobile devices have replaced this solution with native apps and HTML5 solutions.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 video surged to become a standard and elegant way to embed videos. While
    everything points to HTML5's video solution, the lack of agreement on which video
    formats should be supported has obstructed its use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, there should be at least one format supported across all browsers,
    but every company has its own view on the matter. While Microsoft and Apple support
    MP4 H.264 (because they are patent holders of this format), Google and Mozilla
    back Ogg Theora and VP8 WebM as royalty-free solutions. The following table shows
    the browser support for each video format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Operative System | Ogg Theora | MP4 H.264 | VP8 WebM |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet Explorer** | Windows | Manual install | 9.0 | Manual install |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Phone | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Mozilla Firefox** | Windows | 3.5 | Manual install | 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Unix | No |'
  prefs: []
  type: TYPE_TB
- en: '| Other |'
  prefs: []
  type: TYPE_TB
- en: '| **Google Chrome** | All supported | 3.0 | 3.0 (removal planned) | 6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Safari** | iOS | No | 3.1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| MacOS | Manual install | Manual install |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | Manual install |'
  prefs: []
  type: TYPE_TB
- en: '| **Opera** | All supported | 10.50 | No | 10.60 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new compression standard known as **High Efficiency Video Coding** (**HEVC**)
    or H.265 could be in commercial products by 2013\. It is almost twice as effective
    as the current H.264 standard.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `video` tag supports the use of multiple sources allowing web
    browsers to select the video format supported, but this means each video needs
    to be encoded at least twice. For your enterprise, this translates to extra costs
    of encoding and storage.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some implementations rely on the video file extension too. For example, you
    cannot play a video on iOS devices with the `.f4v` extension even if it is using
    MP4 H.264 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most web browsers support progressive download instead of streaming. While
    Flash has its own proprietary protocol to stream (although an incomplete version
    of the specification has been released for public use) known as **Real Time Messaging
    Protocol** **RTMP**, only Safari, Safari iOS, and some Android browsers support
    a new streaming protocol: **HTTP Live Streaming** (**HLS**) implemented by Apple
    Inc.'
  prefs: []
  type: TYPE_NORMAL
- en: With progressive download, it is fairly easy to copy the video file from the
    browser cache, a facility that will make media pirates thankful. Furthermore,
    with a content delivery network that supports adaptive bitrate streaming, you
    can serve different video qualities depending on user bitrate if you are using
    streaming, but this is not possible using a progressive download.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a video player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MovieNow users would love to have a way to visualize trailers of their favorite
    movies. For that, we are going to create a player with basic functionality: play,
    pause, seek, volume control, and full screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use as an example a trailer of Sintel, an animated movie created
    with a free 3D animation tool known as Blender. This video trailer is hosted on
    the [http://www.w3.org/](http://www.w3.org/) site in three major video formats:
    MP4 (mp4), WebM (webm), and Ogg Theora (ogv).'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a file called `trailer.html` and use our main page structure.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `article` tag, we use the `video` tag, which allows us to specify
    an initial image using the `poster` attribute to specify image path, and to show
    default controls using the `controls` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the `src` property directly for the `video` tag, but to support
    multiple video format files we are going to declare our files using the `source`
    tag inside `video`. The `source` tag's `src` attribute allows us to define the
    video path and the `type` attribute (to specify the format).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://media.w3.org/2010/05/sintel/trailer.mp4](http://media.w3.org/2010/05/sintel/trailer.mp4)
    for Chrome (while it is still supported), Internet Explorer, Safari, and Safari
    iOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://media.w3.org/2010/05/sintel/trailer.webm](http://media.w3.org/2010/05/sintel/trailer.webm)
    for Firefox, Chrome, and Opera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://media.w3.org/2010/05/sintel/trailer.ogv](http://media.w3.org/2010/05/sintel/trailer.ogv)
    for Firefox, Chrome, Opera, and others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, it is possible to use only two formats, but we will use three
    for our example. Finally we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if no video is supported it shows `<p>Video not supported.</p>`.
    This can be whatever HTML content you want.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your content delivery network supports HLS, you can use a video encoded as
    H.264 broken in segments and use a `.m3u8` playlist as an index file. For this,
    you can use a tool like Apple Stream Segmenter.
  prefs: []
  type: TYPE_NORMAL
- en: As every browser has its implementation, our player looks different in Firefox,
    Chrome, Safari, and so on. Our player renders differently on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Firefox our player renders as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a video player](img/5689_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In chrome our player renders as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a video player](img/5689_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chrome
  prefs: []
  type: TYPE_NORMAL
- en: 'In an iPhone our player will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a video player](img/5689_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When it is necessary, reflect the enterprise visual style in the player or add
    custom functionality. It is possible to hide the default controllers and build
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: Custom controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For MovieNow we will be creating play/pause, seek, volume, and full screen
    controls. Our design can be seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom controls](img/5689_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To simplify the task of creating a progress and seek bar as well as a volume
    bar, we use jQuery UI. jQuery UI is a JavaScript library that implements the most
    common user interface elements and interactions like sliders, accordions, tabs,
    and so on. In our case, we created a custom download with the UI Darkness theme
    ([http://jqueryui.com/download)](http://jqueryui.com/download)).
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving our jQuery UI JavaScript file in the `js` folder and stylesheets
    in the `css` folder, we import them as always with JavaScript before the end of
    our `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And `css` in our `head` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To support jQuery UI interactions in touch devices, we import the Touch Punch
    JavaScript library ([http://touchpunch.furf.com/](http://touchpunch.furf.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the libraries we need in place, we can remove the `controls`
    attribute from the `video` tag to hide the default controls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, let us define an HTML structure for our controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three main classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`media-container` – wraps all our players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media-area` – wraps video tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controls` – is the bottom bar that contains our controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside controls we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`play-button` – is the player''s play/pause button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seek` – the progress/seek bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fullscreen-button` – is the full screen functionality button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume-container` – is the container of `volume-button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume-slider` – is used to set the volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timer` – is an indicator of time elapsed in minutes and seconds (mm:ss)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using classes although jQuery selectors work faster using IDs because
    we want to permit the use of multiple players in the same page if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Styling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start, we add some additional styles to `style.css`. We define a black background
    and remove the outline from all elements marked with the `media` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a margin for the **Top 5 Box Office** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We remove that margin for small devices where we hide the **Top 5 Box Office**
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These styles are related to layout and not directly to our player. To make styles
    for our video player, let us create a stylesheet called `mediaplayer.css` and
    import it in the `head` tag of `trailer.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Buttons and image sprites
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define our controls area using the `controls` class, set a black background,
    set a height of `35px` (same line height to center text vertically), and set `position`
    to `relative` (so if we set absolute elements inside the positioning, they will
    be relative to `controls`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have an image sprite with all of our player controls called `player-control.png`.
    You can find it inside the `img` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Buttons and image sprites](img/5689_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The use of sprites is based on masking the visible element to show it and hiding
    the rest. In this case, suppose we want to show only our pause button. Our button
    has 35 x 35 pixels with `player-control.png` as the background image; the only
    part of the image that will be visible is inside our button area, so we can use
    background positioning to show different icons as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Buttons and image sprites](img/5689_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Defining the play, volume, and full screen buttons that we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw before, we move `-35px` on the y axis to show our pause icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We apply the same principle to the full screen button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the volume button, we are going to have a slider to set the
    volume below it, so we set the background color to hide elements below and set
    the `position` to `absolute` with `z-index` of `1000` to be over the slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Styling seek and volume bars
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The seek and volume bars can be styled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us define the font styles in `timer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we position `play-button` by floating it to the left-hand side
    and the timer, volume, and full screen to the right-hand side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can float the `video` tag left with the `media` class to avoid extra spacing
    in some browsers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `overflow:hidden` to wrap `media-area` around `media`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using absolute positioning for the seek bar, we can dynamically expand the
    seek area using the `left` and `right` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we created a flexible player to show some techniques related
    to styles, but it is good practice to define static dimensions for your player.
    Furthermore, it is better to use standard resolutions. The use of standard resolutions
    can improve performance for media reproduction on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Features detection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of the `video` tag features are not available to all browsers via the HTML5
    JavaScript API. For example, iOS devices disallow the use of volume control with
    JavaScript; it is only possible to use the default controls or hardware controls.
    Manipulating full screen controls using JavaScript is only possible in WebKit
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define some classes to hide buttons when full screen or volume capabilities
    are not available. First, we hide our buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we change the `right` spacing of our `seek` bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Styling sliders
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we are using jQuery UI to implement seek and volume sliders, we want
    to override some styles. jQuery UI sliders use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ui-slider-handle`: The circle that we use to drag and seek.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ui-state-active`: The class added to `ui-slider-handle` while we drag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ui-slider-range`: The bar that defines the active area. In our case, it is
    a blue bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the process step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the same color for `ui-slider-handle` even when it is active, so we
    remove the background image used by jQuery UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the cursor pointer and remove the outline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `ui-slider-handle` size, rounded corners, and move it a little to the
    top (only for our `seek` slider):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the rounded corners of the progress bar and add some inner shadows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the seek bar progress color to a blue gradient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the volume progress color to a solid blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Center our volume slider using `margin` and set `width` and `height`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the volume handle dimensions and positioning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To show and hide the volume slider, we set the `volume-container` positioning
    as `relative`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the slider positioning as `absolute`. We set `z-index` to `900` (below
    the volume button), `overflow` to `hidden`, and a CSS transition for all properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then resize `volume-container` on hover and `volume-slider-container`
    with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that our player looks the same, let us add all the interactions needed using
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactions using JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write our JavaScript code, we create a `movienow.mediaplayer.js` file in
    the `js` folder and include it before our body ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Initial settings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start our JavaScript the same way we started with geolocation by adding
    `mediaplayer` to our namespace and defining the `that` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Initializing video controllers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the `ready` document is triggered, we add the click event listeners to
    buttons, detect full screen capabilities, and add the `no-fullscreen` class if
    it is not available; initialize the jQuery UI slider for seeking and for volume
    control if it is available. Notice that we manage Mozilla, WebKit, and standard
    full screen capabilities with different functions. If volume is not available,
    we add the `no-volume` class and finally we bind the events of time update and
    reproduction ended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Setting the seek slider
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To set the seek slider, we set the initial value `value` to `0` and `step`
    to `0.01` to have a fluid movie movement on drag, `orientation` to `horizontal`,
    and `range` to `min` to consider the range between minimum value and current handle
    position value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three events managed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start` is triggered when the slider handle is pressed. Notice that we get
    `video` using the `getPlayer` function (this method will be declared later). We
    can pause the reproduction and add the `seeking` class to indicate that we are
    still dragging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slide` is triggered while we drag. We call the `slideTime` function to set
    the progress bar position and time text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop` is triggered on mouse up. We get the `video` tag and controls using
    the `controls` function, call `sliderTime` and restore the previous state of our
    player (playing or paused) using the `play-button playing` class. Finally, we
    remove `seeking` to indicate that we stop dragging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the volume slider
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If volume is available, we initialize the volume slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the current value of our slider is contained in the `ui.value`
    variable, and to set it in our player we use the `volume` property shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Functions to get DOM objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define two functions to execute jQuery selectors for the main player (the
    `media` class for the `video` tag or the `audio` tag if it is the case) and controls
    (the `controls` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Play and pause
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For `play-button`, we toggle the `playing` class and set our player to the playing
    (`player[0].play()`) or paused (`player[0].pause()`) state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Full screen
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Full screen functionality is managed in different ways by every browser. To
    enter the full screen mode we use `element.requestFullscreen()` and its equivalents
    `element.mozRequestFullScreen()` for Firefox and `element.webkitEnterFullScreen()`
    for Safari and Chrome. To exit full screen mode, we use `document.cancelFullScreen()`
    , `document.mozCancelFullScreen()` for Firefox, and `document.webkitCancelFullScreen()`
    for Safari and Chrome. Finally, to validate if the browser is in full screen mode
    we use `document.fullScreen`, `document.mozfullScreen` for Firefox, and `this.webkitFullScreen`
    for Safari and Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Even user experience-wise the browsers vary; while Chrome and Safari show their
    own video controllers on full screen, Firefox doesn't show any controls by default.
    Full screen capabilities are not available in Internet Explorer. Our implementation
    verifies the mode and toggles between full screen and normal mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using standard calls we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Firefox prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for Safari and Chrome we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the event to exit full screen mode is not being triggered because
    the browsers manage that functionality using the *Esc* key, but depending on future
    implementations of the HTML5 full screen specification on every browser, we could
    show our controller in full screen mode and take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: Format time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define the `timeFormat` function to get the player time in seconds and return
    it in mm:ss format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Controlling time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every time we use the seek slider, we set media player time using the `currentTime`
    property, which triggers the `timeupdate` event calling the `timeUpdate` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`timeUpdate` sets the time in mm:ss and if the player is not in the `seeking`
    state (defined by the `seeking` class in `mediaArea`), it updates the progress/seek
    bar too. This function is invoked when the `timeupdate` event is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Until the end of time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the reproduction ends, `endReproduction` is called and we remove the `playing`
    class from `play-button` to indicate that we have finished the reproduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The final script should look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result we have a video player for multiple platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Until the end of time](img/5689_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Possible improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point we have a fully functional player, but we can add more improvements
    in the future. An interesting functionality to add is a buffering notification.
    To achieve this, you will need to listen to the `loadstart` event to recognize
    the start of loading of a video, `waiting` and `stalled` (depending on the browser:
    [http://www.longtailvideo.com/html5/buffering/](http://www.longtailvideo.com/html5/buffering/))
    to detect a stop in the reproduction because of buffering, and finally `canplay`
    and `canplaythrough` to recognize the end of buffering.'
  prefs: []
  type: TYPE_NORMAL
- en: On `loadstart`, `waiting`, and `stalled` a buffering notification should be
    shown and on `canplay` and `canplaythrough` that notification should be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Still not perfect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML5 video specification is still in progress. Major inconsistencies exist
    because of multiple implementation decisions across browsers and platforms requiring
    different encodings. Nevertheless, it is a standard way of supporting video without
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing HTML5 audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTML5 audio specification—much like HTML5 video—is still in development,
    and there is no audio format supported across all browsers. Motives for this are
    the same ones that have been impeding standardized support of HTML5 video as you
    can see in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Ogg Vorbis | WAV PCM | MP3 | AAC |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet Explorer** | No | No | 9 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| **Mozilla Firefox** | 3.5 | 3.5 | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Google Chrome** | 6 | 6 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| **Safari** | Manual install | 5 | 5 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **Opera** | 10.6 | 10.6 | No | No |'
  prefs: []
  type: TYPE_TB
- en: Implementing an audio player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MovieNow needs an audio podcast player. For that, we are going to use the HTML5
    `audio` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `audio` tag behaves more or less the same as the `video` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `video` tag, the `audio` tag allows you to specify the `src` attribute
    directly inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test, we will be using a sound effect audio from [http://www.w3schools.com/](http://www.w3schools.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.w3schools.com/html5/horse.ogg](http://www.w3schools.com/html5/horse.ogg)
    for Firefox, Google Chrome, and Opera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.w3schools.com/html5/horse.mp3](http://www.w3schools.com/html5/horse.mp3)
    for Internet Explorer, Google Chrome, Safari, and Safari iOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a `podcast.html` file and import the same libraries as `trailer.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our media player is generic enough to use the same HTML structure for audio.
    We only need to replace the `video` tag with the `audio` tag, assign the `media`
    class to `audio` tag, and remove the full screen button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Styling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One last adjustment is related to the `audio` tag. Some browsers have the `height`
    attribute defined by default, so we reset it to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How I learned to stop worrying and love Flash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The awful truth is that HTML5 video and media capabilities are a new technology
    and the browser war makes it even more difficult to adopt these solutions as a
    standard for media playback. While Flash requires the installation of a plugin,
    it is a reliable technology to reproduce media and stream it across multiple browsers.
  prefs: []
  type: TYPE_NORMAL
- en: While Flash support decreases on mobile devices and video and audio specifications
    improve, certainly there will be a future with no Flash media, but for now Flash
    is, at worst, a fallback solution for cross-browser compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Huge media delivery products like YouTube still rely on Flash as the primary
    technology. You can decide to use HTML5 as your primary technology and fall back
    to Flash if the `video` and `audio` tags are not supported or vice versa, but
    the choice should be made based on your application's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5 `video` and `audio` tags are simple and elegant ways to support media
    in your enterprise application, but differences between implementations across
    browsers should be taken into account when it is necessary to use them as a solution.
    For now, the best solution is to use both solutions and define a primary solution
    and a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will focus on the use of another exciting feature of HTML5:
    canvas. We will use the `canvas` tag as a tool to visualize analytics related
    to movie reviews.'
  prefs: []
  type: TYPE_NORMAL
