["```js\n{\n  \"dependencies\": {\n    \"axios\": \"^1.7.2\",\n    \"express\": \"^4.19.2\"\n  }\n}\n```", "```js\nconst express = require('express');\nconst axios = require('axios'); // Requires the axios library for making HTTP requests\nconst app = express();\nconst port = 3001; // Port on which the server will listen\napp.get('/posts/:id', async (req, res) => {\n  const postId = req.params.id; // Extract the ID from the URL parameter\n  try {\n    const response = await axios.get(\n     `https://jsonplaceholder.typicode.com/posts/${postId}`);\n    const post = response.data;\n    if (post) {\n      res.json(post); // Send the retrieved post data as JSON response\n    } else {\n      res.status(404).send('Post not found'); // Respond with 404 if post not found\n    }\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('Internal Server Error'); // Handle errors with 500 status\n  }\n});\napp.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});\n```", "```js\nconst express = require('express');\nconst axios = require('axios'); // Requires the axios library for making HTTP requests\nconst app = express();\nconst port = 3002; // Port on which the server will listen\napp.get('/users/:id', async (req, res) => {\n    const userId = req.params.id; // Extract the ID from the URL parameter\n    try {\n        const response = await\n          axios.get(`https://api.github.com/users/${userId}`);\n        const user = response.data;\n        if (user) {\n            res.json(user); // Send the retrieved employee data as JSON response\n        } else {\n            res.status(404).send('User not found'); // Respond with 404 if employee not found\n        }\n    } catch (error) {\n        console.error(error);\n        res.status(500).send('Internal Server Error'); // Handle errors with 500 status\n    }\n});\napp.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n});\n```", "```js\n{\n  \"dependencies\": {\n    \"apicache\": \"^1.6.3\",\n    \"axios\": \"1.7.2\",\n    \"express\": \"4.19.2\",\n    \"express-rate-limit\": \"7.3.1\"\n  }\n}\n```", "```js\nconst express = require('express');\nconst apicache = require('apicache');\nconst axios = require('axios');\nconst rateLimit = require('express-rate-limit');\n```", "```js\nconst limiter = rateLimit({\n    windowMs: 60000, // 1 minute window\n    max: 100, // 100 requests per minute\n    message: 'Too many requests, please slow down!'\n});\n```", "```js\nasync function getAggregatedData(id) {\n    const postResponse = await axios.get(\n        `http://postmicroservice:3001/posts/${id}`);\n    const userResponse = await axios.get(\n        `http://usermicroservice:3002/users/${id}`);\n    const aggregatedData = {\n        data: {\n            id: userResponse.data.login,\n            followers_url: userResponse.data.followers_url,\n            following_url: userResponse.data.following_url,\n            subscriptions_url:\n              userResponse.data.subscriptions_url,\n            repos_url: userResponse.data.repos_url,\n            post: postResponse.data\n        },\n        location: userResponse.data.location\n    };\n    return aggregatedData;\n}\n```", "```js\napp.get('/users/:id', limiter, async (req, res) => {\n    const id = req.params.id;\n    try {\n        const aggregatedData = await getAggregatedData(id);\n        res.json(aggregatedData);\n    }\n    catch {\n        res.status(400).json({ success: false, message:\n          'Bad request' });\n    }\n});\n```", "```js\nlet cache = apicache.middleware;\napp.use(cache('5 minutes'));\n```", "```js\nFROM node:alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nCMD [ \"node\", \"server.js\" ]\n```", "```js\nservices:\n  post-microservice:\n    build:\n      context: ./post-microservice\n      dockerfile: Dockerfile\n    ports:\n      - 3001:3001\n  user-microservice:\n    build:\n      context: ./user-microservice # Correct the path if necessary\n      dockerfile: Dockerfile\n    ports:\n      - 3002:3002\n  api-Gateway:\n    build:\n      context: ./api-Gateway\n      dockerfile: Dockerfile\n    ports:\n      - 3000:3000\n    depends_on:\n      - post-microservice\n      - user-microservice\n```", "```js\n    npm i @nestjs/cqrs\n    npm i @eventstore/db-client\n    npm i uuid\n    EventStoreDB for Docker. You can easily run it using a simple Dockerfile; however, to operate it with all the necessary infrastructure components, you’ll need to compose them together in the future. Create a docker-compose.yml file with the following content:\n\n    ```", "```js\n\n    ```", "```js\n    import {EventStoreDBClient, FORWARDS, START} from\n      '@eventstore/db-client'\n    const client = EventStoreDBClient.connectionString(\n      'esdb://localhost:2113?tls=false',\n    )\n    const connect = () => {\n      try {\n        client.readAll({\n          direction: FORWARDS,\n          fromPosition: START,\n          maxCount: 1,\n        })\n      } catch (error) {\n        console.error('Failed to connect to\n          EventStoreDB:', error) }\n    }\n    export {client, connect}\n    @eventstore/db-client library to interact with EventStoreDB. It establishes a connection (stored in the client), using a connection string that points to a local EventStoreDB instance (localhost:2113) with EventStoreDB for production is that it provides encryption for data transmitted over a network. Without TLS, data transmitted between the client and EventStoreDB, such as commands, events, and sensitive information, is sent in plain text. This means anyone with access to the network could potentially intercept and read the data, leading to security vulnerabilities, including data theft or man-in-the-middle attacks.\n    ```", "```js\n    import {ICommand} from '@nestjs/cqrs'\n    export class RegisterAccountUnitCommand implements\n      ICommand {\n      constructor(\n        public readonly aggregateId: string,\n        public readonly paymentmechanismCount: string,\n      ) {}\n    }\n    export class DisableAccountUnitCommand implements\n      ICommand {\n      constructor(public readonly aggregateId: string) {}\n    }\n    export class EnableAccountUnitCommand implements\n      ICommand {\n      constructor(public readonly aggregateId: string) {}\n    }\n    ```", "```js\n    import {UUID} from 'uuid'\n    import {IEvent} from \"@nestjs/cqrs\";\n    export class AccountEvent implements IEvent {\n      constructor(\n          public readonly aggregateId: UUID,\n          public readonly paymentmechanismCount: string\n      ) {}\n    }\n    export class AccountRegisteredEvent extends\n      AccountEvent {}\n    export class AccountDisabledEvent extends AccountEvent {}\n    export class AccountEnabledEvent extends AccountEvent {}\n    ```", "```js\n@CommandHandler(RegisterAccountUnitCommand)\nexport class RegisterAccountUnitHandler\n  implements ICommandHandler<RegisterAccountUnitCommand>\n{\n  constructor(private readonly publisher: EventPublisher) {}\n  async execute(command: RegisterAccountUnitCommand): Promise<void> {\n    const aggregate = this.publisher.mergeObjectContext\n      (new AccountAggregate())\n    aggregate.registerAccount(command.aggregateId,\n      command.paymentmechanismCount)\n    aggregate.commit()\n  }\n}\n```", "```js\n@CommandHandler(DisableAccountUnitCommand)\nexport class DisableAccountUnitHandler implements\n  ICommandHandler<DisableAccountUnitCommand> {\n  constructor(private readonly publisher: EventPublisher){}\n  async execute(command: DisableAccountUnitCommand):\n    Promise<void> {\n    const aggregate = this.publisher.mergeObjectContext(\n        await AccountAggregate.loadAggregate\n          (command.aggregateId)\n    );\n    if (!aggregate.disabled) {\n      aggregate.disableAccount();\n      aggregate.commit();\n    }\n  }\n}\n```", "```js\n@CommandHandler(EnableAccountUnitCommand)\nexport class EnableAccountUnitHandler implements\n  ICommandHandler<EnableAccountUnitCommand> {\n  constructor(private readonly publisher: EventPublisher){}\n  async execute(command: EnableAccountUnitCommand):\n    Promise<void> {\n    const aggregate = this.publisher.mergeObjectContext(\n        await AccountAggregate.loadAggregate\n          (command.aggregateId)\n    );\n    if (aggregate.disabled) {\n      aggregate.enableAccount();\n      aggregate.commit();\n    }\n  }\n}\n```", "```js\ninterface AccountEvent {\n  aggregateId: string;\n  paymentmechanismCount: string;\n}\nasync function handleAccountEvent(eventType: string, event:\n  AccountEvent): Promise<void> {\n  const eventData = jsonEvent({\n    type: eventType,\n    data: {\n      id: event.aggregateId,\n      paymentmechanismCount: event.paymentmechanismCount,\n    },\n  });\n  await eventStore.appendToStream(\n    'Account-unit-stream-' + event.aggregateId,\n    [eventData],\n  );\n}\n```", "```js\n@EventsHandler(AccountRegisteredEvent)\nexport class AccountRegisteredEventHandler\n  implements IEventHandler<AccountRegisteredEvent> {\n  async handle(event: AccountRegisteredEvent):\n    Promise<void> {\n    await handleAccountEvent('AccountUnitCreated', event);\n  }\n}\n@EventsHandler(AccountDisabledEvent)\nexport class AccountDisabledEventHandler implements\n  IEventHandler<AccountDisabledEvent> {\n  async handle(event: AccountDisabledEvent): Promise<void> {\n    await handleAccountEvent('AccountUnitDisabled', event);\n  }\n}\n@EventsHandler(AccountEnabledEvent)\nexport class AccountEnabledEventHandler implements\n  IEventHandler<AccountEnabledEvent> {\n  async handle(event: AccountEnabledEvent): Promise<void> {\n    await handleAccountEvent('AccountUnitEnabled', event);\n  }\n}\n```", "```js\nexport class AccountAggregate extends AggregateRoot {\n..........\nstatic async loadAggregate(aggregateId: string):\n  Promise<AccountAggregate> {\n    const events = eventStore.readStream(\n      'Account-unit-stream-' + aggregateId);\n    let count = 0;\n    const aggregate = new AccountAggregate();\n    for await (const event of events) {\n      const eventData: any = event.event.data;\n      try {\n        switch (event.event.type) {\n          case 'AccountUnitCreated':\n            aggregate.applyAccountRegisteredEventToAggregate({\n              aggregateId: eventData.id,\n              paymentmechanismCount:\n                eventData.paymentmechanismCount,\n            });\n            break;\n          case 'AccountUnitDisabled':\n            aggregate.accountDisabled();\n            break;\n          case 'AccountUnitEnabled':\n            aggregate.accountEnabled();\n            break;\n          default:\n            break\n        }\n      } catch(e) {\n        console.error(\"Could not process event\")\n      }\n      count++;\n    }\n    return aggregate;\n}}\n```", "```js\nexport class AccountAggregate extends AggregateRoot {\n……\n registerAccount(aggregateId: string,\n    paymentmechanismCount: string) {\n    this.apply(new AccountRegisteredEvent(aggregateId,\n      paymentmechanismCount));\n  }\n  enableAccount(): void {\n    if(this.disabled) {\n      this.apply(new AccountEnabledEvent(this.id,\n        this.paymentmechanismCount))\n    }\n  }\n  disableAccount() {\n    if (!this.disabled) {\n      this.apply(new AccountDisabledEvent(this.id,\n        this.paymentmechanismCount));\n    }\n  }\n…\n}\n```", "```js\n@EventsHandler(AccountRegisteredEvent,\n  AccountDisabledEvent, AccountEnabledEvent)\nexport class PaymentMechanismProjection implements\n  IEventHandler<AccountRegisteredEvent |\n  AccountDisabledEvent | AccountEnabledEvent> {\n  private currentPaymentMechanismTotal: number = 0;\n  constructor() {\n    console.log('Account info Projection instance created:', this);\n  }\n  handle(event: AccountRegisteredEvent |\n    AccountDisabledEvent | AccountEnabledEvent): void {\n    if (event instanceof AccountRegisteredEvent) {\n      this.handleAccountRegistered(event);\n    } else if (event instanceof AccountDisabledEvent) {\n      this.handleAccountDisabled(event);\n    } else if (event instanceof AccountEnabledEvent) {\n      this.handleAccountEnabled(event);\n    }\n  }\n ........\n .......\n```", "```js\nhandleAccountRegistered(event: AccountRegisteredEvent) {\n    const pmCount = parseInt(event.paymentmechanismCount,\n      10);\n    this.currentPaymentMechanismTotal += pmCount;\n    console.log(\"currentPaymentMechanismTotal\",\n      this.currentPaymentMechanismTotal)\n  }\n  handleAccountDisabled(event: AccountDisabledEvent) {\n    const pmCount = parseInt(event.paymentmechanismCount,\n      10);\n    this.currentPaymentMechanismTotal -= pmCount;\n    console.log(\"currentPaymentMechanismTotal\",\n      this.currentPaymentMechanismTotal)\n  }\n  handleAccountEnabled(event: AccountEnabledEvent) {\n    const pmCount = parseInt(event.paymentmechanismCount,\n      10);\n    this.currentPaymentMechanismTotal += pmCount;\n    console.log(\"currentPaymentMechanismTotal\",\n      this.currentPaymentMechanismTotal)\n  }\n```", "```js\n@Controller('Account')\nexport class AccountUnitController {\n  constructor(private readonly commandBus: CommandBus) {}\n  @Post('/register')\n  async registerAccount(@Query('paymentmechanismCount')\n    paymentmechanismCount: string): Promise<any> {\n    const aggregateId = uuid()\n    await this.commandBus.execute(new\n      RegisterAccountUnitCommand(aggregateId,\n        paymentmechanismCount))\n    return { message: 'Request received as a command',\n      aggregateId };\n  }\n  @Post('/:id/disable')\n  async disableAccount(@Param('id') id: string):\n    Promise<any> {\n    await this.commandBus.execute(new\n      DisableAccountUnitCommand(id))\n    return { message: 'Request received as a command' };\n  }\n  @Post('/:id/enable')\n  async enableAccount(@Param('id') id: string):\n    Promise<any> {\n    await this.commandBus.execute(new\n      EnableAccountUnitCommand(id))\n    return { message: 'Request received as a command' };\n  } }\n```", "```js\nimport {Controller, Param, Post, Query} from\n  '@nestjs/common'\nimport {CommandBus} from '@nestjs/cqrs'\nimport {\n  DisableAccountUnitCommand,\n  EnableAccountUnitCommand,\n  RegisterAccountUnitCommand\n} from '../account/account.commands'\nimport {v4 as uuid} from 'uuid'\n```", "```js\nexport class AccountModule implements OnModuleInit {\n  async onModuleInit() {\n    this.startSubscription();\n  }\n  private startSubscription() {\n    (async (): Promise<void> => {\n      await this.subscribeToAll();\n    })();\n  }\n  private async subscribeToAll() {\n    const subscriptionList = eventStore.subscribeToAll({\n      filter: streamNameFilter({ prefixes: [\"Account-unit-stream-\"] \n        }),\n    });\n    for await (const subscriptionItem of subscriptionList){\n      console.log(\n          `Handled event ${subscriptionItem.event?.revision}@${subscriptionItem.event?.streamId}`\n      );\n      const subscriptionData: any =\n        subscriptionItem.event.data;\n      console.log(\"subscription data:\", subscriptionData);\n    }\n  }\n}\n```"]