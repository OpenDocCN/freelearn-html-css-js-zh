- en: Building the Frontend
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: In this chapter, we will build the web pages of our demo application. The objective
    here is not to teach frontend development, but to demonstrate that you can use
    modern tools along with serverless. For this demo, we will use React, but you
    could use Angular, Vue.js, or any other tool, and still take advantage of the
    serverless features. Also, we will discuss the pros and cons of SPA from a serverless
    perspective and let's take a look at how we can prerender SPA pages for better
    **Search Engine Optimization** (**SEO**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的演示应用的网络页面。这里的目的是不是教授前端开发，而是展示你可以使用现代工具以及无服务器。对于这个演示，我们将使用React，但你也可以使用Angular、Vue.js或其他任何工具，并且仍然可以利用无服务器的功能。此外，我们将从无服务器的角度讨论SPA的优缺点，并看看我们如何预渲染SPA页面以优化**搜索引擎优化**（**SEO**）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to use React to build our web pages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用React构建我们的网页
- en: Pros and cons of Single-Page Applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用（SPA）的优缺点
- en: Prerendering pages for a better SEO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预渲染页面以优化SEO
- en: After this chapter, you'll have built the frontend of our serverless online
    store.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将已经构建了我们无服务器在线商店的前端。
- en: Getting started with React
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React入门
- en: Teaching frontend tools is not the objective of this book, but we need to build
    something useful to see how serverless deals with modern frontend development.
    We will use React here because it is currently one of the most popular tools.
    If you don't know what React is or how to use it, I'll guide you to understand
    the basic concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 教授前端工具不是本书的目标，但我们需要构建一些有用的东西来展示无服务器如何处理现代前端开发。在这里，我们将使用React，因为它目前是最受欢迎的工具之一。如果你不知道React是什么或者如何使用它，我会引导你理解基本概念。
- en: React principles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React原则
- en: The first thing you should note is that React is a library and not a framework.
    The difference is that a library provides a set of functionalities to solve a
    *specific* problem, and a framework provides a set of libraries centered on a
    particular methodology.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意的第一件事是，React是一个库而不是一个框架。区别在于，一个库提供了一套功能来解决一个*特定*的问题，而一个框架提供了一套围绕特定方法的库。
- en: React is only responsible for the view layer of your application. That's the
    problem React solves. If you need to make Ajax calls or handle page routes, you
    need to add other libraries. When you develop with React, you need to think in
    components. Your user interface is a composition of simple components, where each
    one of them has an inner state and an HTML definition. When using React, you don't
    manipulate the web page directly. You change the component's state and React will
    render it again to match the current state. This approach promotes predictability.
    For a given state, you always know how the component will render. This is very
    important for testing and maintaining complex applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React只负责应用视图层。这就是React解决的问题。如果你需要执行Ajax调用或处理页面路由，你需要添加其他库。当你用React开发时，你需要以组件的方式思考。你的用户界面是由简单的组件组成的，其中每个组件都有一个内部状态和HTML定义。在使用React时，你不会直接操作网页。你改变组件的状态，React会重新渲染它以匹配当前状态。这种方法促进了可预测性。对于给定的状态，你总是知道组件将如何渲染。这对于测试和维护复杂的应用程序非常重要。
- en: Another important concept is the virtual DOM. The **Document Object Model**
    (**DOM**) is a representation of all nodes of an HTML page. If something changes
    on a page and you need to render a different view, the DOM needs to be manipulated.
    The problem is when you have hundreds of nodes. Recreating the entire view has
    a performance cost that can be perceived by the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是虚拟DOM。**文档对象模型**（**DOM**）是HTML页面所有节点的表示。如果页面上有变化，你需要渲染不同的视图，DOM就需要被操作。问题是当你有数百个节点时。重新创建整个视图会有性能成本，这是用户可以感知到的。
- en: The virtual DOM is an abstract version of the real DOM. React tracks the state
    of all components and knows when one of them was modified. Instead of rerendering
    the entire view, it compares the modified virtual DOM with the real DOM and makes
    a small patch containing only the differences. This patch is applied with a much
    better performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是真实DOM的抽象版本。React跟踪所有组件的状态，并知道其中任何一个何时被修改。它不会重新渲染整个视图，而是比较修改后的虚拟DOM和真实DOM，并制作一个只包含差异的小补丁。这个补丁以更好的性能应用。
- en: In summary, you need to know that React is a **library** with the specific purpose
    of handling the **view layer,** it is based on **components**, where each one
    of them has an internal **state** and a **view** definition, and you can't modify
    the DOM directly because that's the responsibility of the virtual DOM.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你需要知道React是一个**库**，其特定目的是处理**视图层**，它基于**组件**，其中每个组件都有一个内部的**状态**和**视图**定义，你不能直接修改DOM，因为这属于虚拟DOM的责任。
- en: The Flux pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The Flux pattern
- en: 'Flux is a pattern for application-state management, and Redux is the most popular
    Flux-inspired implementation. If you are building a complex React application,
    you should learn Redux or another Flux-like framework. However, *You Might Not
    Need Redux*, as Dan Abramov, the creator of Redux, has blogged about ([https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367)):
    “*People often choose Redux before they need it*.”'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是一种用于应用程序状态管理的模式，Redux是最受欢迎的Flux灵感实现。如果你正在构建一个复杂的React应用程序，你应该学习Redux或另一个类似Flux的框架。然而，*你可能不需要Redux*，正如Redux的创造者Dan
    Abramov在他的博客中提到的([https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367))：“*人们经常在他们需要Redux之前就选择了Redux*。”
- en: Redux is a great framework, but it adds complexity to your project. As we are
    building a small frontend application, we will not use it here, and this decision
    makes sense for applications that have a short component tree. Again, the objective
    of this book is to focus on serverless and not on frontend development, so Redux
    is out of scope for us. In a real-world application, you need to consider the
    pros and cons. Most of the time, you will choose to use Redux, but not always.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个优秀的框架，但它增加了项目的复杂性。由于我们正在构建一个小型的前端应用程序，我们在这里不会使用它，对于具有短组件树的应用程序，这个决定是有意义的。再次强调，本书的目标是专注于无服务器，而不是前端开发，因此Redux超出了我们的范围。在现实世界的应用程序中，你需要考虑利弊。大多数时候，你会选择使用Redux，但并不总是如此。
- en: React hello-world
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React hello-world
- en: 'React promotes the usage of JSX, a syntax that mixes JavaScript with XML. You
    don''t need to use JSX, but you *should* use it to improve the readability of
    the code. For example, take a look at the following JSX:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React推荐使用JSX，这是一种将JavaScript与XML混合的语法。你不需要使用JSX，但*应该*使用它来提高代码的可读性。例如，看看下面的JSX：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example defines a `<HelloReact/>` HTML element and the rendered output
    will use the value of the `name` property. If the input is `World`, the rendered
    result will be `<div>Hello, World!</div>`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子定义了一个`<HelloReact/>`HTML元素，渲染输出将使用`name`属性的值。如果输入是`World`，渲染结果将是`<div>Hello,
    World!</div>`。
- en: 'However, the browser can''t execute this code because JSX doesn''t have native
    support. You need to use a JSX transpiler that will translate this example into
    the following JavaScript code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览器无法执行这段代码，因为JSX没有原生支持。你需要使用一个JSX编译器，它将这个例子转换成以下JavaScript代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Mixing JavaScript code with HTML sounds strange, but we can get used to it.
    In the end, most people find it more enjoyable and easier to maintain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript代码与HTML混合听起来很奇怪，但我们可以习惯它。最终，大多数人会发现它更令人愉快且更容易维护。
- en: To make this piece of code work, we need to add two dependencies such as React
    and ReactDOM. The former is the core, which lets us create components, and the
    latter is the library that renders the components and attaches them into an HTML
    node.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这段代码工作，我们需要添加两个依赖项，例如React和ReactDOM。前者是核心，它让我们创建组件，后者是库，它渲染组件并将它们附加到HTML节点中。
- en: You can find these dependencies at [https://unpkg.com/react/](https://unpkg.com/react/)
    and [https://unpkg.com/react-dom/](https://unpkg.com/react-dom/). You will find
    the necessary files inside the `dist` folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://unpkg.com/react/](https://unpkg.com/react/)和[https://unpkg.com/react-dom/](https://unpkg.com/react-dom/)找到这些依赖项。你将在`dist`文件夹内找到必要的文件。
- en: 'The following code is a working hello-world example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个工作的hello-world示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Building a shopping cart
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建购物车
- en: 'To understand React, we need to see how props and states work, and how we can
    compose an interface with different components. For a practical example, we will
    build a shopping cart. This example will be the foundation of our Serverless Store
    and the objective now is to achieve the following result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解React，我们需要了解props和states是如何工作的，以及我们如何使用不同的组件来组合一个界面。为了一个实际的例子，我们将构建一个购物车。这个例子将成为我们无服务器商店的基础，现在的目标是实现以下结果：
- en: '![](img/9c362541-15c1-48bf-8da3-c5b107ee0a9c.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c362541-15c1-48bf-8da3-c5b107ee0a9c.png)'
- en: Preparing the development environment
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: One of the criticisms of React is the need of external tools for development.
    In fact, one can use plain JavaScript, but as we saw, JSX is easier to understand.
    So, the first tool that you need to add to your project is a JSX transpiler.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React 的一项批评是需要外部工具进行开发。实际上，人们可以使用纯 JavaScript，但正如我们所看到的，JSX 更容易理解。因此，你需要添加到项目中的第一个工具就是一个
    JSX 编译器。
- en: When you browse a React project or any other modern web project, you will also
    find that people use many other tools such as Babel (ES6 to ES5 transpiler), Webpack
    (module bundler), ESLint (code analysis), and others. Also, each tool has many
    competitors. You may prefer to use Browserify instead of Webpack, for example.
    Understanding and configuring these tools takes a long time. If you are learning
    React, you need to understand first how React works and not how the environment
    is configured.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览React项目或其他现代Web项目时，你也会发现人们使用许多其他工具，例如Babel（ES6到ES5编译器）、Webpack（模块打包器）、ESLint（代码分析）等。每个工具都有许多竞争对手。例如，你可能更喜欢使用Browserify而不是Webpack。理解和配置这些工具需要很长时间。如果你在学习React，你首先需要了解React是如何工作的，而不是环境是如何配置的。
- en: With this in mind, the tool **Create React App** offers an opinionated configuration
    that uses well-established tools and practices. You don't need to worry about
    the environment anymore, you just follow what others have suggested.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**Create React App** 工具提供了一个有见地的配置，它使用经过验证的工具和实践。你不再需要担心环境，只需遵循他人的建议即可。
- en: 'Take a look at the following steps to start a new project using this tool:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤，了解如何使用此工具启动新项目：
- en: 'Install the Create React App tool using the following npm command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下npm命令安装Create React App工具：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `@1.3.1` term means that it will download the exact version that was used
    for this book's examples. If you prefer, you can remove this `@1.3.1` restriction
    to get the latest features, but that may introduce breaking changes to the examples.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`@1.3.1` 这个术语意味着它将下载用于本书示例的确切版本。如果你愿意，你可以移除这个 `@1.3.1` 限制以获取最新功能，但这可能会引入对示例的破坏性更改。'
- en: 'Now, create a new application using the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令创建一个新的应用程序：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change the directory to the new folder and start the application using the
    following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录切换到新文件夹，并使用以下命令启动应用程序：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see the application running at [http://localhost:3000](http://localhost:3000),
    as shown in the following screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 [http://localhost:3000](http://localhost:3000) 上看到运行中的应用程序，如下面的截图所示：
- en: '![](img/3293096b-db79-49c5-88d8-58796decd663.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3293096b-db79-49c5-88d8-58796decd663.png)'
- en: Organizing the solution
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织解决方案
- en: 'This application will create the following structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将创建以下结构：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `public/manifest.json` and `src/registerServiceWorker.js` files are used
    to support **Progressive Web App** (**PWA**), which is a great feature to build
    fast and more reliable web pages as it caches static assets and allows offline
    access. However, PWA is not so useful for an online store and is out of scope
    of this book, so it will be removed from the examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`public/manifest.json` 和 `src/registerServiceWorker.js` 文件用于支持**渐进式Web应用**（**PWA**），这是一个构建快速且更可靠的网页的出色功能，因为它缓存静态资源并允许离线访问。然而，PWA
    对于在线商店来说并不那么有用，并且超出了本书的范围，因此它将从示例中删除。'
- en: 'We will make the following changes here to adapt the example to our project:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此处进行以下更改，以使示例适应我们的项目：
- en: '**Remove PWA support**: Delete the `public/manifest.json` and `src/registerServiceWorker.js`
    files.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除PWA支持**：删除 `public/manifest.json` 和 `src/registerServiceWorker.js` 文件。'
- en: '**Remove src files that won''t be used**: Delete the files `App.css`, `App.js`,
    `App.test.js`, `index.css`, and `logo.svg`'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除未使用的src文件**：删除 `App.css`、`App.js`、`App.test.js`、`index.css` 和 `logo.svg`
    文件。'
- en: '**Create folders**: Under `src/`, create the `css/`, `components/`, and `images/`
    folders.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建文件夹**：在 `src/` 目录下创建 `css/`、`components/` 和 `images/` 文件夹。'
- en: '**Add components**: Under `components/`, add the files `App.js`, `ShoppingCart.js`,
    `ShoppingCartItem.js`, `Product.js`, and `ProductList.js`.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加组件**：在 `components/` 目录下添加 `App.js`、`ShoppingCart.js`、`ShoppingCartItem.js`、`Product.js`
    和 `ProductList.js` 文件。'
- en: '**Add CSS**: Under `css/`, create a file named `site.css` that will serve as
    our custom styles.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加CSS**：在 `css/` 目录下创建一个名为 `site.css` 的文件，该文件将作为我们的自定义样式。'
- en: '**Add images**: Add two images that will be used as our products. I''ve used
    free images (Creative Commons CC0) from Pixabay ([https://pixabay.com](https://pixabay.com)).'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加图片**：添加两张将用作我们产品的图片。我使用了来自Pixabay的免费图片（Creative Commons CC0）（[https://pixabay.com](https://pixabay.com)）。'
- en: You can browse the Packt resources for this chapter ([https://github.com/PacktPublishing/Building-Serverless-Web-Applications](https://github.com/PacktPublishing/Building-Serverless-Web-Applications))
    to see the final result. This project is available under a folder named `react-shopping-cart`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以浏览本章的Packt资源（[https://github.com/PacktPublishing/Building-Serverless-Web-Applications](https://github.com/PacktPublishing/Building-Serverless-Web-Applications)）以查看最终结果。该项目位于名为`react-shopping-cart`的文件夹中。
- en: 'Now you should have the following project tree:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该有以下项目结构：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before starting to code the components, we need to make a few changes in the
    `index.js` file to match the new project tree. Use the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写组件代码之前，我们需要在`index.js`文件中做一些修改，以匹配新的项目结构。使用以下代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For a responsive website, I''ve included the Twitter Bootstrap 3 ([https://getbootstrap.com](https://getbootstrap.com))
    styles in the `public/index.html` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应式网站，我已经在`public/index.html`文件中包含了Twitter Bootstrap 3（[https://getbootstrap.com](https://getbootstrap.com)）样式：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Composing components
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: 'The user interface is a composition of components. To make this clearer, the
    following diagram shows how we will compose our components to create the application
    design:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面是组件的组合。为了使这一点更清晰，以下图表显示了我们将如何组合我们的组件以创建应用程序设计：
- en: '![](img/c8f88913-3138-4d40-8cd6-6a56a565faa7.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8f88913-3138-4d40-8cd6-6a56a565faa7.png)'
- en: The **App** component holds the entire view and is responsible for positioning
    the **Product List** and **Shopping Cart** components. The **Product List** component
    has a list of **Product** components, and the Shopping Cart will list the selected
    products as **Cart Item**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**App**组件持有整个视图，并负责定位**产品列表**和**购物车**组件。**产品列表**组件包含一系列**产品**组件，购物车将列出所选产品作为**购物车项**。'
- en: In React, there is no interaction between components, except by passing properties
    from parent to child components. These properties are called props. The child
    can't pass data to the parent unless the parent gives a handler function as a
    property and the child executes this handler when an event occurs. For example,
    the parent can give a `handleClick` function that will be triggered by the child
    when a button is clicked.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，组件之间没有交互，除非通过从父组件传递属性到子组件。这些属性被称为props。除非父组件提供一个处理函数作为属性，并且子组件在事件发生时执行此处理函数，否则子组件不能向父组件传递数据。例如，父组件可以提供一个`handleClick`函数，当子组件中的按钮被点击时，该函数将被触发。
- en: Due to the restriction that you can have only parent-child interactions, the
    Product List and Shopping Cart components need a common parent. When a product
    is selected, it will trigger a function in Product List, which in turn will trigger
    another in the App component. This handler will change the App component's state,
    and by consequence, the state of the Shopping Cart component will also be changed
    because the App component will be defined to pass data to the cart through `props`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只能有父子交互的限制，产品列表和购物车组件需要一个共同的父组件。当选择一个产品时，它将在产品列表中触发一个函数，这反过来又会在应用程序组件中触发另一个函数。这个处理程序将改变应用程序组件的状态，因此购物车组件的状态也会随之改变，因为应用程序组件将被定义为通过`props`将数据传递到购物车。
- en: Implementing a component
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现组件
- en: 'In the following code extract, the skeleton of a component is presented. This
    format will be used to implement all components. To focus on the content, further
    examples will show only the `constructor()` and `render()` implementations. Full
    code examples can be downloaded from the Packt resources associated with this
    book:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，展示了组件的骨架。此格式将被用于实现所有组件。为了专注于内容，进一步的示例将只显示`constructor()`和`render()`实现。完整的代码示例可以从与本书相关的Packt资源中下载：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The App component
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: 'The App is a component with the responsibility of organizing the page''s layout.
    It uses Bootstrap''s grid system to position the two other main components such
    as Product List and Shopping Cart. It should be rendered with the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是一个负责组织页面布局的组件。它使用Bootstrap的网格系统定位两个其他主要组件，如产品列表和购物车。它应该按照以下方式渲染：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When using JSX, you add a class to an HTML element with the `className` property,
    for example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSX时，你通过`className`属性给HTML元素添加一个类，例如：
- en: '`<div className="container"></div>`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div className="container"></div>`'
- en: 'In this code, we can see the Product List component being set with two properties
    such as `products` and `onSelect`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以看到产品列表组件被设置了两个属性，例如`products`和`onSelect`：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `products` property will receive a list of products that is controlled by
    the state of the App component. The `onSelect` property will receive a handler
    function, which will be used by the children to trigger the parent component when
    a product is selected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`products` 属性将接收一个由 App 组件的状态控制的产品列表。`onSelect` 属性将接收一个处理函数，该函数将由子组件用于在产品被选中时触发父组件。'
- en: 'We can also see that the Shopping Cart component has two properties such as
    `selectedProducts` and `onDeselect`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，购物车组件有两个属性，例如 `selectedProducts` 和 `onDeselect`：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `selectedProducts` property will receive a list of products that were selected,
    while the `onDeselect` property defines a handler function that should be triggered
    by the Shopping Cart component when a product is deselected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectedProducts` 属性将接收一个所选产品的列表，而 `onDeselect` 属性定义了一个处理函数，当产品被取消选中时，购物车组件应该触发此函数。'
- en: 'So, in this component, the App component is sharing its state with the Product
    List and the Shopping Cart components, thus App is responsible for defining the
    products objects and for keeping track of the selected products. The initial list
    of products is defined in the following piece of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个组件中，App 组件正在与产品列表和购物车组件共享其状态，因此 App 负责定义产品对象并跟踪所选产品。产品列表的初始定义如下代码所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code snippet is a simplified example. In the next chapter, we
    will retrieve this list from a Lambda function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个简化的例子。在下一章中，我们将从这个 Lambda 函数中检索这个列表。
- en: 'The initial state is defined inside the class constructor. Also, you need to
    bind the component''s `this` instance to the callback functions. Otherwise, `this.state`
    will not be found when the function gets called inside another component:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态是在类构造函数中定义的。此外，你还需要将组件的 `this` 实例绑定到回调函数上。否则，当函数在另一个组件内部被调用时，将找不到 `this.state`：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `handleSelect` function should be defined inside the class and it will
    receive a product as an argument to set its `isSelected` state:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleSelect` 函数应该在类内部定义，并且它将接收一个产品作为参数来设置其 `isSelected` 状态：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are a couple of things to observe in this example: `slice()` was used
    to create another array, instead of mutating the current array, and `setState()`
    was used instead of directly changing the reference to `products`. This is because
    working with immutable objects has performance benefits. It''s easier to identify
    a modified object by checking whether its reference has changed than by looking
    into all of its property values. Regarding `setState()`, it is used to make React
    aware of the need to rerender the component.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有几个需要注意的地方：使用了 `slice()` 来创建另一个数组，而不是修改当前数组，并且使用了 `setState()` 而不是直接更改
    `products` 的引用。这是因为使用不可变对象有性能优势。通过检查引用是否已更改，比检查所有属性值更容易识别已修改的对象。至于 `setState()`，它用于让
    React 知道需要重新渲染组件。
- en: 'To finish, as the `handleSelect` function is taking the `isSelected` property
    and setting the state, regardless of whether the property is true or false, we
    can use the `handleSelect` function to define the `handleDeselect` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 `handleSelect` 函数正在接受 `isSelected` 属性并设置状态，无论该属性是真是假，我们可以使用 `handleSelect`
    函数来定义 `handleDeselect` 函数：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Product List component
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表组件
- en: 'This component accesses the data provided by its parent through the `props`
    variable. It will use the `products` array to iterate and create a new Product
    component for each item of the array. Also, it will set the `onSelect` handler
    with the function passed by its parent:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件通过 `props` 变量访问其父组件提供的数据。它将使用 `products` 数组迭代并创建一个新的产品组件，为数组的每个项目。它还将设置由其父组件传递的
    `onSelect` 处理函数：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Product component
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品组件
- en: 'This component is responsible for rendering the details of the product, such
    as the image, description, price, and a button that allows the user to add the
    product to the cart. As you can see, the `onClick` event of the button will change
    the `isSelected` state and trigger the `onSelect` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件负责渲染产品的详细信息，例如图片、描述、价格以及一个允许用户将产品添加到购物车的按钮。正如你所看到的，按钮的 `onClick` 事件将改变 `isSelected`
    状态并触发 `onSelect` 函数：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Shopping Cart component
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车组件
- en: 'The Shopping Cart component is responsible for rendering the selected products
    and showing the total value. Let''s take a look at the following code snippet
    to see how this is done:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车组件负责渲染所选产品并显示总价值。让我们看一下以下代码片段，看看这是如何实现的：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `getTotal` function uses a `map`/`reduce` operation to get the aggregated
    total value. The `map` operation will transform the input, creating an array of
    numbers, and `reduce` will sum all values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTotal`函数使用`map`/`reduce`操作来获取聚合的总值。`map`操作将转换输入，创建一个数字数组，而`reduce`将求和所有值：'
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Cart Item component
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车组件
- en: The last component is the Cart Item. For each selected product, a cart item
    will be added to the Shopping Cart component. This component is rendered with
    the product name and value, along with a Glyphicon for an X mark icon. Glyphicon
    is a set of icons that are available through Bootstrap.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组件是购物车组件。对于每个选定的产品，购物车组件将添加一个购物车项。此组件使用产品名称和值进行渲染，以及一个带有X标记的Glyphicon图标。Glyphicon是一组可以通过Bootstrap获取的图标。
- en: 'Also, when the user clicks on the icon, we need to trigger the `onDeselect`
    function. Take a look at the following code snippet to see how it is done:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当用户点击图标时，我们需要触发`onDeselect`函数。查看以下代码片段以了解如何实现：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Publishing our demo
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布我们的演示
- en: Publishing the static files requires a processing phase due to the fact that
    we have used JSX to build the React demo. In this case, the Create React App module
    will help us again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了JSX来构建React演示，发布静态文件需要处理阶段。在这种情况下，Create React App模块将再次帮助我们。
- en: 'Take a look at the following steps to learn about publishing our demo:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤了解如何发布我们的演示：
- en: 'Before publishing, we need to test it locally to confirm that everything is
    working as expected, which can be done using the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发布之前，我们需要在本地测试它以确认一切按预期工作，可以使用以下命令完成：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can prepare our frontend project to be published using the following
    command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令准备我们的前端项目以供发布：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The resulting files will be processed, minimized, and bundled. You can find
    all files inside the `build` folder. Now upload them to Amazon S3 using the following
    command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的文件将被处理、最小化和打包。你可以在`build`文件夹中找到所有文件。现在使用以下命令将它们上传到Amazon S3：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, reupload the `index.html` file, adding the `Cache-Control: no-cache` header
    just to this file using the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，重新上传`index.html`文件，使用以下命令仅为此文件添加`Cache-Control: no-cache`头：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Making Ajax requests
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发起Ajax请求
- en: React is responsible for just the view layer. React is *not* concerned with
    how data is fetched from the server. So, there are no restrictions and you can
    retrieve the server data using many different approaches. Redux offers a pattern
    using *Async Actions* and Relay, which is another JavaScript framework, uses *GraphQL*
    to handle data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: React只负责视图层。React*不关心*数据是如何从服务器获取的。因此，没有限制，你可以使用许多不同的方法来检索服务器数据。Redux提供了一个使用*异步动作*和Relay的模式，而Relay是另一个JavaScript框架，它使用*GraphQL*来处理数据。
- en: 'In our sample application, we will use the simplest approach: the *Root component*.
    This pattern is simple and can be very useful for small projects where you have
    a shallow component tree. What we will do is to concentrate all Ajax requests
    in a single component and the best option for this is to use the Root component
    because it''s the only component that can communicate with all the others.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们将使用最简单的方法：*根组件*。这种模式很简单，对于具有浅层组件树的小型项目非常有用。我们将做的是将所有Ajax请求集中在一个组件中，而最佳选择是使用根组件，因为它是可以与所有其他组件通信的唯一组件。
- en: When the Root component retrieves some data from the server, the children components
    will be updated through *properties,* and React, as expected, will render again
    only the ones that were changed. And whenever a component needs to perform an
    action, it will execute a function that was passed as a property by the parent
    component. This information will go up until it reaches the root level, where
    it can be sent to the server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当根组件从服务器检索一些数据时，子组件将通过*属性*进行更新，React如预期的那样，将仅重新渲染更改的部分。并且每当组件需要执行操作时，它将执行由父组件作为属性传递的函数。此信息将向上传递，直到达到根级别，在那里它可以发送到服务器。
- en: In our examples, we will consider the App component as the Root component. The
    `index.js` file is technically the root since it is the first to load, but `index`
    is only responsible for appending the React application to the HTML page. As the
    App component is loaded by `index` and App is a common parent for all other components,
    it will be defined as our root.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将考虑App组件作为根组件。`index.js`文件在技术上被视为根，因为它是最先加载的，但`index`只负责将React应用程序附加到HTML页面。由于App组件是由`index`加载的，而App是所有其他组件的公共父组件，因此它将被定义为我们的根。
- en: Retrieving data from the server
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: 'In the following example, we will build a page that will request a list of
    products on load. This request will be done in the Root component, but we need
    to define where exactly it will be executed. The `render` function is *never*
    a good choice because `render` is always considered as a *pure function*: for
    a given input, the output will always be the same, which means that side effects
    are not allowed.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将构建一个在加载时请求产品列表的页面。这个请求将在根组件中完成，但我们需要定义它确切地在哪里执行。`render`函数永远不是一个好的选择，因为`render`被认为是一个*纯函数*：对于给定的输入，输出总是相同的，这意味着不允许有副作用。
- en: 'Excluding `render`, we have two candidates: `componentWillMount` and `componentDidMount`,
    both of them execute *just once* and before (`componentWillMount`) or after (`componentDidMount`)
    the first `render` execution. Since the asynchronous call will take some time
    to execute, and the component rendering will take place before the result is received,
    it doesn''t help to use the `componentWillMount` option. The first rendering will
    always be done with empty data. So, it makes more sense to use the `componentWillMount`
    function to set the initial state as empty (and avoid undefined values in your
    properties) and the `componentDidMount` function to fetch data from the server.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 排除`render`，我们有两个候选者：`componentWillMount`和`componentDidMount`，它们都只执行一次，并且在第一次`render`执行之前（`componentWillMount`）或之后（`componentDidMount`）。由于异步调用需要一些时间来执行，而组件渲染将在收到结果之前进行，因此使用`componentWillMount`选项并没有帮助。第一次渲染总是使用空数据完成的。因此，使用`componentWillMount`函数将初始状态设置为空（并避免在属性中存在未定义的值）以及使用`componentDidMount`函数从服务器获取数据更有意义。
- en: Another question is whether the initial state should be set in the `constructor`
    function or the `componentWillMount` function. They are technically equivalent,
    but it is much more common to use the `constructor` function for this task. In
    practice, `componentWillMount` is hardly used at all.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在`constructor`函数还是`componentWillMount`函数中设置初始状态。技术上它们是等效的，但使用`constructor`函数来完成这个任务更为常见。实际上，`componentWillMount`几乎从未被使用过。
- en: 'The last thing to decide is: which Ajax library will be used? I like to use
    **axios** for this task, but if you prefer, you can use another library for this
    such as **Fetch** or **SuperAgent**. Some people like to use **jQuery** for Ajax
    calls, but adding a full-featured library for just one task doesn''t make much
    sense.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要决定的是：将使用哪个Ajax库？我喜欢用**axios**来完成这个任务，但如果您愿意，您可以使用其他库来完成这个任务，例如**Fetch**或**SuperAgent**。有些人喜欢使用**jQuery**进行Ajax调用，但只为一个任务添加一个功能齐全的库并没有太多意义。
- en: 'To install axios, run the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装axios，请运行以下命令：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To include axios in a component, add the following import:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件中包含axios，请添加以下导入：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first part of the example shows how the initial state is defined inside
    the constructor. It sets an empty array of products and a Boolean variable, `ready`,
    with the value `false`. This Boolean will be set to `true` once the request completes.
    Using this approach, we can control the rendering state and display a loading
    icon while the page is still fetching data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的第一部分展示了在构造函数内部如何定义初始状态。它设置了一个空的产品数组和一个布尔变量`ready`，其值为`false`。一旦请求完成，这个布尔值将被设置为`true`。使用这种方法，我们可以控制渲染状态，并在页面仍在获取数据时显示一个加载图标：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Checking the `ready: false` state, we can display a `glyphicon-refresh` icon
    instead of the list of products:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '检查`ready: false`状态，我们可以显示一个`glyphicon-refresh`图标而不是产品列表：'
- en: '![](img/c52b0347-de96-4eec-b2e8-a800b0dce48b.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c52b0347-de96-4eec-b2e8-a800b0dce48b.png)'
- en: 'Take a look at the `componentDidMount` implementation in the following code
    snippet. The API address is used to trigger a Lambda function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码片段中的`componentDidMount`实现。API地址用于触发Lambda函数：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After getting the results, we set the `ready` state with the `true` value and
    the list of products with what we have received:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 获取结果后，我们使用`true`值设置`ready`状态，并使用我们收到的产品列表：
- en: '![](img/f5d14552-fbe7-4592-8f3d-b8ce430dd89e.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5d14552-fbe7-4592-8f3d-b8ce430dd89e.png)'
- en: Sending data to the server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器发送数据
- en: 'In the previous example, we have placed the Ajax request inside the `componentDidMount`
    function because we wanted the data on page load. However, in the following example,
    the Ajax request will be executed when a button is clicked, so we don''t have
    the same restriction. Take a look at the following steps, which describe the process
    step-by-step:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们将 Ajax 请求放置在 `componentDidMount` 函数内部，因为我们希望在页面加载时获取数据。然而，在下面的示例中，Ajax
    请求将在按钮点击时执行，因此我们没有相同的限制。请查看以下步骤，这些步骤将逐步描述该过程：
- en: 'The request will be defined as a function of the component:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求将被定义为组件的一个函数：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `handleSave` function is passed through properties to the children components:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handleSave` 函数通过属性传递给子组件：'
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And, to finish, the children will trigger the `save` function when a button
    is clicked. After the request finishes, the parent component will change the state
    of the `hasSaved` property to `true`, and we can use this value in the children
    components to display a message:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当按钮被点击时，子组件将触发 `save` 函数。请求完成后，父组件将 `hasSaved` 属性的状态更改为 `true`，我们可以在子组件中使用这个值来显示消息：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After saving, the word saved will appear under the button:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存后，按钮下将出现“已保存”字样：
- en: '![](img/5a40098f-4964-472e-8e3b-ae465f27630d.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a40098f-4964-472e-8e3b-ae465f27630d.png)'
- en: Handling the page routes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理页面路由
- en: Later in this chapter, we will discuss the pros and cons of SPA, but first we
    will take a look at how to build one. An SPA is an application that loads just
    one HTML file, but it will dynamically update that page while the user interacts
    with it. Also, the content will render differently to match the URL. For example,
    browsing the `example.com` address will render the `Home` component, while browsing
    `example.com/about` will render the `About` component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论单页应用（SPA）的优缺点，但首先我们将看看如何构建一个。单页应用（SPA）是一个只加载一个 HTML 文件的程序，但在用户与之交互时，它将动态更新该页面。此外，内容将根据
    URL 不同而渲染不同。例如，浏览 `example.com` 地址将渲染 `Home` 组件，而浏览 `example.com/about` 将渲染 `About`
    组件。
- en: 'To implement this, we will use the React Router module. Let''s take a look
    at the following steps to build an SPA:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用 React Router 模块。让我们看看以下步骤来构建一个单页应用（SPA）：
- en: Create a new application using the Create React App tool, or modify the previous
    Shopping Cart application.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Create React App 工具创建一个新的应用程序，或者修改之前的购物车应用程序。
- en: 'Install the React Router module by running the following:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 React Router 模块：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `@4.x` term means that it will download a version that is compatible with
    the one used for this book's examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`@4.x` 这个术语意味着它将下载一个与此书示例兼容的版本。'
- en: 'The `App.js` file will be modified to define the application routes. First,
    we need to import the React Router module components:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.js` 文件将被修改以定义应用程序路由。首先，我们需要导入 React Router 模块组件：'
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we need to import our App components. In this example, we will use the
    following components:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要导入我们的 App 组件。在这个例子中，我们将使用以下组件：
- en: '`Header`: This is the component that will render the text `"Serverless Store"`
    for all pages'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`: 这是将为所有页面渲染文本 `"Serverless Store"` 的组件'
- en: '`Footer`: This is the component that will render a footer text for all pages'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Footer`: 这是将为所有页面渲染页脚文本的组件'
- en: '`ProductList`: This is a list of products, where each product links to the
    `Product` component'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductList`: 这是一个产品列表，其中每个产品都链接到 `Product` 组件'
- en: '`Product`: This component gives details of a specific product'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`: 这个组件提供了特定产品的详细信息'
- en: '`ShoppingCart`: This is a list of products that were selected by the user'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShoppingCart`: 这是用户选择的产品的列表'
- en: '`NoMatch`: This is a component that will render the text "Page not found"'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoMatch`: 这是一个将渲染文本“页面未找到”的组件'
- en: 'The `App` component will render the page using the following components:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App` 组件将使用以下组件渲染页面：'
- en: '`Router`: This is the Root component for the page routing.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Router`: 这是页面路由的根组件。'
- en: '`Switch`: This renders the first child route that matches the URL path. If
    there is no match, it will render the `NoMatch` component.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`: 这将渲染与 URL 路径匹配的第一个子路由。如果没有匹配项，它将渲染 `NoMatch` 组件。'
- en: '`Route`: This renders the component for the specified path.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Route`: 这将渲染指定路径的组件。'
- en: 'Let''s take a look at the preceding mentioned components in the following code
    snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段中提到的先前组件：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the application and test the URLs. If it doesn''t match any path, the `NoMatch`
    component will be rendered and it will display the Page not found message:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并测试URL。如果它不匹配任何路径，`NoMatch`组件将被渲染，并显示“页面未找到”的消息：
- en: '![](img/9a7fb41b-bbb7-41ab-b1cc-42a00d2ccdd3.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a7fb41b-bbb7-41ab-b1cc-42a00d2ccdd3.png)'
- en: Linking pages
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接页面
- en: 'Linking one page to another is done using the React Router''s Link component:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Router的Link组件来链接一个页面到另一个页面：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Link is just a wrapper for the HTML anchor element. In the following example,
    the implementation of the Product List component shows how to link to a page of
    a specific Product:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 链接只是HTML锚元素的包装器。在以下示例中，Product List组件的实现展示了如何链接到特定产品的页面：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This component will be rendered as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将按以下方式渲染：
- en: '![](img/62617504-e3f1-4fdc-b98d-86bb7abb8c34.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62617504-e3f1-4fdc-b98d-86bb7abb8c34.png)'
- en: Using the query parameters
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查询参数
- en: 'When we have declared the routes of our application, we have defined the route
    of the Product component as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明了应用程序的路由时，我们已经定义了Product组件的路由如下：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The colon sign defines the parameter that can be used by the related component.
    In this case, `:id` defines a parameter with the name `id`, which can be used
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号符号定义了可以由相关组件使用的参数。在这种情况下，`:id`定义了一个名为`id`的参数，可以如下使用：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This Product component will render as shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此产品组件将按以下截图所示渲染：
- en: '![](img/157cb9b8-e127-457e-94ec-5cfd0e43d806.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/157cb9b8-e127-457e-94ec-5cfd0e43d806.png)'
- en: Note that the `localhost:3000/product/1` path defined an `id` parameter with
    value `1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`localhost:3000/product/1`路径定义了一个值为`1`的`id`参数。
- en: Single-Page Applications
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用
- en: In a traditional multipage website, each URL loads a different HTML page. If
    you are at the `example.com` page and need to navigate to `example.com/about`,
    the entire view will blink with a page reload because it will need to be rendered
    again. The problem is that, usually, a page reload is a waste of time since both
    pages share similar content, such as the page header and footer. Also, CSS and
    JavaScript dependencies may be exactly the same.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的多页网站中，每个URL都会加载不同的HTML页面。如果你在`example.com`页面，需要导航到`example.com/about`，整个视图会因为页面重新加载而闪烁。问题在于，通常情况下，页面重新加载是浪费时间，因为这两个页面共享相似的内容，例如页面头部和页脚。此外，CSS和JavaScript依赖项可能完全相同。
- en: In a Single-Page Application, there is a base HTML file that will be loaded
    for every URL and, depending on the given URL, the inner content will be dynamically
    loaded to match the address. Also, the URL browsing is controlled at the client-side
    using JavaScript. Changing from one URL to another will not cause a full page
    reload. Instead of loading an entire new file, a request is made to the server
    to retrieve only what is necessary for the new address and just a part of the
    page will be rendered again.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用中，有一个基础HTML文件，对于每个URL都会被加载，并且根据给定的URL，内部内容会动态加载以匹配地址。此外，URL浏览是通过JavaScript在客户端控制的。从一个URL切换到另一个URL不会导致整个页面重新加载。而不是加载整个新文件，服务器会收到一个请求，只检索新地址所需的内容，并且只重新渲染页面的一部分。
- en: Pros and cons of Single-Page Applications
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用的优缺点
- en: SPA is a modern approach that has the objective to provide a better user experience,
    but it's not perfect. There are pros and cons that you need to know before using
    it. While this topic can be extensive, we will highlight only the most relevant.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: SPA是一种现代方法，旨在提供更好的用户体验，但它并不完美。在使用它之前，你需要知道它的优缺点。虽然这个话题可能很广泛，但我们将只突出最相关的部分。
- en: Pros
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'Let''s list the main benefits of this approach:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出这种方法的主要优点：
- en: '**No page refresh**: This is an obvious benefit. When the user changes to another
    view, the page will not blink. The browsing experience becomes more pleasant with
    a fluid navigation.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无页面刷新**：这是一个明显的优势。当用户切换到另一个视图时，页面不会闪烁。流畅的导航使浏览体验更加愉悦。'
- en: '**Decoupling**: You have a better separation of frontend and backend code.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦**：你有一个更好的前端和后端代码的分离。'
- en: '**Reduce the server-side code**: We are building a serverless website, so we
    must consider that cold start delays at the backend may impact the user experience.
    In SPA, there is much more logic at the client side to make the dynamism feasible,
    and we can use this approach to reduce the size of the server-side code and improve
    the performance by reducing the number of requests to the backend.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少服务器端代码**：我们正在构建一个无服务器网站，因此我们必须考虑后端冷启动延迟可能会影响用户体验。在SPA中，客户端有更多的逻辑来实现动态性，我们可以使用这种方法来减少服务器端代码的大小，并通过减少对后端的请求数量来提高性能。'
- en: Cons
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'SPA has a few drawbacks, we can consider the following cons:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: SPA有一些缺点，我们可以考虑以下缺点：
- en: '**Larger file sizes**: As we have more logic at the client side, the applications
    usually have larger JavaScript dependencies. This is a big problem, especially
    with mobile clients with poor network conditions. The first load of the site will
    take more time.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更大的文件大小**：由于我们在客户端有更多的逻辑，应用程序通常有更大的JavaScript依赖。这是一个大问题，尤其是在网络条件较差的移动客户端中。网站的首次加载将花费更多时间。'
- en: '**Requires JavaScript**: There is yet a small percentage of users that disable
    JavaScript due to security reasons. If you have a simple site that doesn''t need
    any fancy features, your SPA is forcing JavaScript support that would otherwise
    be optional.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要JavaScript**：由于安全原因，仍有少数用户禁用了JavaScript。如果你有一个不需要任何花哨功能的简单网站，你的单页应用（SPA）强制要求支持JavaScript，而这是可选的。'
- en: '**Search Engine Optimization**: An SPA application relies heavily on JavaScript.
    Google crawlers can execute some JavaScript code in special conditions, but Bing
    and others won''t execute. If we want the search engines to correctly index our
    website, we need to prerender the content especially for them.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索引擎优化**：SPA应用程序严重依赖于JavaScript。在特定条件下，Google爬虫可以执行一些JavaScript代码，但Bing和其他搜索引擎不会执行。如果我们希望搜索引擎正确索引我们的网站，我们需要为它们特别预渲染内容。'
- en: Considerations
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑事项
- en: Some may argue that a low-end mobile device may have a poor performance with
    SPA because of the increased amount of JavaScript code. While that might have
    been true in the past, it may not be the reality at present and won't be in the
    future. Nowadays, even low-end devices have a powerful CPU that can perfectly
    execute most operations seamlessly. The real issue with mobile devices is not
    the computational power, but the network performance to download a larger size
    of code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，低端移动设备由于JavaScript代码量的增加，可能会在SPA中表现不佳。虽然这在过去可能是真的，但目前在现实中可能不是这样，未来也不会是这样。如今，即使是低端设备也有强大的CPU，可以完美地无缝执行大多数操作。移动设备真正的问题不是计算能力，而是下载更大代码量的网络性能。
- en: In this book, we will stick with SPA, and the main reason is that it fits well
    with the serverless approach. SPA is a modern approach to offload to clients some
    of the computing costs needed to run a website.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将坚持使用SPA，主要原因是因为它与无服务器方法很好地匹配。SPA是一种现代方法，可以将运行网站所需的某些计算成本卸载到客户端。
- en: Lambda is cheap, but not free. On the other hand, client-side executions are
    limitless. Using the premise that more logic at the client won't significantly
    hurt the performance, I prefer avoiding making Lambda requests to handle the application
    state. Lambda should be used only to retrieve or save data and not to control
    UI logic.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda很便宜，但并非免费。另一方面，客户端执行是无限的。基于更多的客户端逻辑不会显著影响性能的假设，我更喜欢避免使用Lambda请求来处理应用程序状态。Lambda应该仅用于检索或保存数据，而不是控制UI逻辑。
- en: However, as with most things in our field, each case should be treated separately.
    You may benefit from a multipage application and there is nothing wrong with it.
    With multipage, you just need to configure the Lambda function to return HTML
    content instead of JSON data, as we saw in an example in [Chapter 3](436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml),
    *Using the Serverless Framework*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们领域中的大多数事情一样，每个案例都应该单独处理。你可能从多页应用中受益，这并没有什么不妥。在使用多页应用时，你只需要配置Lambda函数返回HTML内容而不是JSON数据，就像我们在[第3章](436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml)中看到的，*使用无服务器框架*。
- en: Prerendering pages
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预渲染页面
- en: In our frontend approach, the layout is entirely composed by JavaScript code
    using React components. Prerendering a web page means executing this JavaScript
    code and saving the output HTML file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的前端方法中，布局完全由JavaScript代码使用React组件组成。预渲染网页意味着执行此JavaScript代码并保存输出HTML文件。
- en: As discussed in the previous section, to improve **Search Engine Optimization**
    (**SEO**), we need to prerender pages because the majority of crawlers can't execute
    JavaScript code, and the ones that can, such as Google, won't execute all kinds
    of code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，为了提高**搜索引擎优化**（**SEO**），我们需要预渲染页面，因为大多数爬虫无法执行JavaScript代码，而那些可以执行（如Google）的爬虫也不会执行所有类型的代码。
- en: Using PhantomJS
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PhantomJS
- en: PhantomJS is a headless web browser, based on WebKit, which can be used to make
    HTTP requests and save the HTML output. It is not a Node.js module, but it can
    use Node.js modules. It runs in its own process, which is not the same as a Node
    runtime. You can download it from the official site: [http://phantomjs.org](http://phantomjs.org).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS是一个基于WebKit的无头浏览器，可以用来发送HTTP请求并保存HTML输出。它不是一个Node.js模块，但它可以使用Node.js模块。它在自己的进程中运行，这与Node运行时不同。你可以从官方网站下载它：[http://phantomjs.org](http://phantomjs.org)。
- en: As we discussed in the previous chapter, you can configure the S3 bucket to
    return the `index.html` page whenever an error of HTTP 404 *Not Found* occurs.
    So, when the user browses the address `example.com/page1`, S3 will look for a
    `page1.html` file. It will not find it, but it will load the `index.html` file
    instead. As we have developed an SPA, it will be able to render the contents of
    the corresponding `page1` file, keeping the browser address as `example.com/page1`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，你可以配置S3存储桶，使其在发生HTTP 404 *未找到*错误时返回`index.html`页面。因此，当用户浏览地址`example.com/page1`时，S3将寻找`page1.html`文件。它将找不到，但会加载`index.html`文件。由于我们已经开发了一个SPA，它将能够渲染相应的`page1`文件的内容，同时保持浏览器地址为`example.com/page1`。
- en: When we prerender the `page1` file, the output HTML must be uploaded to the
    S3 bucket. This means that the next time we try to fetch the address `example.com/page1`,
    S3 will find a `page1.html` file and load it directly. Loading a prerendered page
    for a real user is not a problem, it's even better from a performance perspective.
    This user will load the HTML with the React dependencies. After a few instants,
    the React application will take control and further requests will be handled as
    a normal SPA.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们预渲染`page1`文件时，输出HTML必须上传到S3存储桶。这意味着下次我们尝试获取地址`example.com/page1`时，S3将找到`page1.html`文件并直接加载它。为真实用户加载预渲染的页面没有问题，从性能角度来看甚至更好。此用户将加载带有React依赖的HTML。几秒钟后，React应用程序将接管控制权，后续请求将像正常SPA一样处理。
- en: 'The script to prerender a page is quite simple. You can follow this example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 预渲染页面的脚本相当简单。你可以参考以下示例：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To test, add the PhantomJS binary to PATH and execute the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，将PhantomJS二进制文件添加到PATH中，并执行以下命令：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: One of the problems of this approach is that you need to keep track of all the
    pages of your application. If a new page is added, you need to remember to include
    it in this list of pages to process. Also, you need to prerender your application's
    root file (`index.html`) and replace it in the S3 bucket.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，你需要跟踪应用程序的所有页面。如果添加了新页面，你需要记得将其包含在要处理的页面列表中。此外，你还需要预渲染应用程序的根文件（`index.html`），并在S3存储桶中替换它。
- en: Serving the output HTML file will make the content visible for all web crawlers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器输出HTML文件将使内容对所有网络爬虫可见。
- en: Using the Lambda functions for prerendering
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda函数进行预渲染
- en: 'If your application is a static website, you can prerender all pages just once.
    However, for dynamic applications such as our Serverless Store, we need to have
    a routine of prerendering pages to avoid serving outdated content to crawlers.
    For example, the `https://serverless-store.com/products/lonely-bird` page shows
    the details of the Lonely Bird product. If the product is modified or deleted,
    we need to apply the changes to the `/products/lonely-bird.html` file. You have
    the following two options for this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是一个静态网站，你可以一次性预渲染所有页面。然而，对于像我们的Serverless Store这样的动态应用程序，我们需要有一个预渲染页面的常规流程，以避免向爬虫提供过时内容。例如，`https://serverless-store.com/products/lonely-bird`页面显示了Lonely
    Bird产品的详细信息。如果产品被修改或删除，我们需要将这些更改应用到`/products/lonely-bird.html`文件中。你有以下两种选择：
- en: Whenever some content is modified, trigger a Lambda function to update the page
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当某些内容被修改时，触发一个Lambda函数来更新页面
- en: Schedule a Lambda function to execute daily to update all pages
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排Lambda函数每天执行以更新所有页面
- en: In both cases, Lambda functions will be used, but how to call the PhantomJS
    binary if it is not a Node module? For this, we can install the `phantomjs-lambda-pack` Node
    module, which provides binary files compatible with Amazon Linux AMI machines
    to run on Lambda. It can be used as a Node module because it will spawn a child
    process to execute PhantomJS.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，都将使用 Lambda 函数，但如果它不是一个 Node 模块，如何调用 PhantomJS 二进制文件？为此，我们可以安装 `phantomjs-lambda-pack`
    Node 模块，它提供了与 Amazon Linux AMI 机器兼容的二进制文件，以便在 Lambda 上运行。因为它将启动一个子进程来执行 PhantomJS，所以它可以作为一个
    Node 模块使用。
- en: The `prerender.js` file that is loaded in the next example is the code implemented
    in the previous section. It must be placed in the same folder as the `serverless.yml`
    file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中加载的 `prerender.js` 文件是上一节中实现的代码。它必须放在与 `serverless.yml` 文件相同的文件夹中。
- en: 'The following code can be used as our Lambda handler:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用作我们的 Lambda 处理程序：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This PhantomJS wrapper requires the Lambda function to use at least 1,024 MB
    of RAM and a timeout of 180 seconds. So, instead of requiring one Lambda function
    for each page, it's better to call the Lambda to handle multiple pages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 PhantomJS 包装器要求 Lambda 函数至少使用 1,024 MB 的 RAM 和 180 秒的超时时间。因此，与其为每个页面要求一个
    Lambda 函数，不如调用 Lambda 来处理多个页面。
- en: Rendering on the fly
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时渲染
- en: Instead of prerendering a web page, you can also render it on the fly. You need
    to detect that the request was made from a crawler and execute some logic to render
    the HTML page. Detecting a crawler can be done by checking the user-agent string
    and comparing it with a known list of common crawlers. This method works, but
    requires periodic maintenance and will not cover all crawlers, just the most popular.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预渲染网页，您还可以即时渲染。您需要检测请求是否来自爬虫，并执行一些逻辑来渲染 HTML 页面。检测爬虫可以通过检查用户代理字符串并将其与已知常见爬虫列表进行比较来完成。这种方法是有效的，但需要定期维护，并且不会涵盖所有爬虫，只是最流行的那些。
- en: There is a website, [https://prerender.io](https://prerender.io), which offers
    a service to prerender sites on the fly when a crawler is detected. You install
    a middleware in your server and it will be responsible for checking the requests
    to find crawlers and provide them a cached prerendered version of your page. As
    we don't have a server, and we are using CloudFront/S3 to host the frontend, we
    can't execute code on demand.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个网站，[https://prerender.io](https://prerender.io)，当检测到爬虫时会提供即时预渲染网站的服务。您需要在您的服务器上安装一个中间件，它将负责检查请求以找到爬虫，并为它们提供一个缓存的预渲染版本。由于我们没有服务器，并且我们正在使用
    CloudFront/S3 来托管前端，因此我们无法按需执行代码。
- en: To solve problems like this one, AWS released a new service named **Lambda@Edge**,
    which is currently in preview phase. This service will execute Lambda functions
    in edge locations in response to *all* *page requests*. AWS promised a very short
    latency to execute those Lambda functions, and you can use it to prerender on
    the fly if an agent is a crawler. You can also use it for other use cases such
    as modifying response headers or adding content depending on the agent, IP address,
    or referrer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这类问题，AWS 发布了一项名为 **Lambda@Edge** 的新服务，目前处于预览阶段。该服务将在边缘位置响应所有 *页面请求* 执行 Lambda
    函数。AWS 承诺执行这些 Lambda 函数的延迟非常短，如果代理是爬虫，您可以使用它来即时预渲染。您还可以用它来处理其他用例，例如根据代理、IP 地址或引用修改响应头或添加内容。
- en: Rendering on the fly has the obvious drawback that it will be slower to answer
    the requests, but as the Lambda function has direct access to the database, the
    rendered page will always be updated.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即时渲染的明显缺点是它将使响应请求的速度变慢，但 Lambda 函数可以直接访问数据库，因此渲染的页面将始终是最新的。
- en: Building an online store
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建在线商店
- en: 'We will use the previous Shopping Cart demo to begin our application. Now,
    we know how to set page routes and how to make Ajax requests, so we have everything
    to continue. One important difference is that the Shopping Cart component will
    be in a different page than the Product List component. Also, we need to create
    other pages. The following is a list of the pages:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前的购物车演示开始我们的应用程序。现在，我们知道如何设置页面路由和如何进行 Ajax 请求，所以我们有继续进行的一切。一个重要的区别是购物车组件将位于产品列表组件的不同页面中。此外，我们还需要创建其他页面。以下是一张页面列表：
- en: '**Home page**: This presents a list of all available products where the user
    can add them to the Shopping Cart component'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：这展示了所有可用产品的列表，用户可以将它们添加到购物车组件中'
- en: '**Product details**: This is a dedicated page that provides more details of
    a specific product where users can see and add new comments'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品详情**：这是一个专门提供特定产品更多详情的页面，用户可以在此页面上查看和添加新的评论'
- en: '**Shopping Cart**: This shows all of the selected products and is responsible
    for handling payments'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物车**：这显示了所有选定的产品，并负责处理支付'
- en: '**Signup page**: This handles account creation'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册页面**：这处理账户创建'
- en: '**Login page**: This allows the user to log in'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录页面**：这允许用户登录'
- en: '**Page not found**: This is a page that will be displayed when the address
    doesn''t exist'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面未找到**：当地址不存在时，将显示此页面'
- en: '**Error page**: This is a page that will be displayed when an error occurs'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误页面**：当发生错误时，将显示此页面'
- en: 'This book will not cover all the code for the online store sample. There are
    too many parts that are simple to implement or are unrelated to the serverless
    concept. You can find the entire code in the Packt resources associated with this
    book or on my GitHub repo: [https://github.com/zanon-io/serverless-store](https://github.com/zanon-io/serverless-store).
    For a running demo, access: [https://serverless-store.zanon.io](https://serverless-store.zanon.io).
    Instead of dumping all the code here, we are focusing on the important parts.
    The following sections will describe what each page implements along with a screenshot
    of the result.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖在线商店示例的所有代码。有许多部分实现简单或与无服务器概念无关。您可以在本书相关的Packt资源或我的GitHub仓库[https://github.com/zanon-io/serverless-store](https://github.com/zanon-io/serverless-store)中找到整个代码。对于运行演示，请访问[https://serverless-store.zanon.io](https://serverless-store.zanon.io)。我们不是在这里展示所有代码，而是专注于重要部分。以下各节将描述每个页面实现的内容，以及结果的截图。
- en: The Navbar component
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Navbar组件
- en: 'The Navbar component is like the header component that should appear for all
    pages. For its implementation, let''s perform the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Navbar组件类似于所有页面都应该出现的页眉组件。对于其实现，让我们执行以下步骤：
- en: 'First, we need to install two Node modules: `react-bootstrap` and `react-router-bootstrap`.
    Install them using the following npm command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装两个Node模块：`react-bootstrap`和`react-router-bootstrap`。使用以下npm命令安装它们：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Import the necessary components using the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入必要的组件：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement the Navbar component to set the links using the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现Navbar组件以设置链接：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will get the following result:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下结果：
- en: '![](img/3e16e9d5-7817-4700-a5dd-c00e66c29ecc.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e16e9d5-7817-4700-a5dd-c00e66c29ecc.png)'
- en: The last item is a notification icon. We will implement it in [Chapter 9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml),
    *Handling Serverless Notifications*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个项目是一个通知图标。我们将在[第9章](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml)中实现它，*处理无服务器通知*。
- en: The Home page
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首页
- en: 'The Home page will render the Product List component that we have defined in
    this chapter. One important observation is how the page router will select this
    component. Previously, we used the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首页将渲染我们在本章中定义的Product List组件。一个重要的观察点是页面路由器如何选择此组件。之前，我们使用了以下代码：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, we need to pass some properties from the App component to the Product
    List component, since the App component is responsible for managing the application
    state. In this case, we need to use the `render` attribute:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要从App组件传递一些属性到Product List组件，因为App组件负责管理应用程序状态。在这种情况下，我们需要使用`render`属性：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The same applies for all other components that need to share their state with
    the App component.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于所有需要与App组件共享其状态的其他组件。
- en: 'Take a look at the result in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图中的结果：
- en: '![](img/81e7a258-ec13-436e-8c4f-0c207e6ad2f6.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81e7a258-ec13-436e-8c4f-0c207e6ad2f6.png)'
- en: The product details page
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品详情页面
- en: 'The product details page will be accessed by clicking on the image of a product.
    On this page, the user will be able to see the product and customer reviews:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情页面将通过点击产品图片来访问。在此页面上，用户将能够查看产品和客户评价：
- en: '![](img/61478952-bcc3-45e5-86e2-3aa9f9ff1d98.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61478952-bcc3-45e5-86e2-3aa9f9ff1d98.png)'
- en: The *customer reviews* feature will be implemented later in this book, in [Chapter
    9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml), *Handling Serverless Notifications*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户评价*功能将在本书的[第9章](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml)中实现，即*处理无服务器通知*。'
- en: 'To display the product details page, we need to add a link in the product image
    using the `Link` tag, as shown in the following code snippet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示产品详情页面，我们需要在产品图片中使用`Link`标签添加一个链接，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another change that is required is how the page route will be able to identify
    which product to render. In this case, we will modify the `Route` component to
    render the `Product` component using the URL parameter available at the `props.match.param`
    object:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要改变的是页面路由如何能够识别要渲染哪个产品。在这种情况下，我们将修改`Route`组件，使用`props.match.param`对象中可用的URL参数来渲染`Product`组件：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Shopping Cart page
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车页面
- en: 'The Shopping Cart page will be implemented like we did previously in this chapter.
    The only modification here is the addition of a checkout button, which will be
    used to process the request:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车页面将像本章前面所做的那样实现。这里唯一的修改是添加了一个结账按钮，它将被用来处理请求：
- en: '![](img/098ef750-002f-49f9-82a2-ddaf4f33d2e9.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/098ef750-002f-49f9-82a2-ddaf4f33d2e9.png)'
- en: However, handling payments is a complex feature for a restricted audience, thus
    it will not be discussed here. If you need a serverless service for this, I recommend
    that you take a look at Stripe ([https://stripe.com](https://stripe.com)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，处理支付是一个针对受限受众的复杂功能，因此这里不会讨论。如果您需要这个功能的无服务器服务，我建议您查看Stripe（[https://stripe.com](https://stripe.com)）。
- en: 'When the user clicks on this button, we will display a modal, as shown in the
    following screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击此按钮时，我们将显示一个模态框，如下面的截图所示：
- en: '![](img/e24d2e4e-15fb-4c03-b97e-d8f2601d7330.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e24d2e4e-15fb-4c03-b97e-d8f2601d7330.png)'
- en: 'This modal is implemented using the `react-bootstrap` component, as shown in
    the following example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此模态框使用`react-bootstrap`组件实现，如下面的示例所示：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the following code snippet, `closeModal` is a method to set the `showModal`
    state to `false`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`closeModal`是一个将`showModal`状态设置为`false`的方法：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The Login and Signup pages
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录和注册页面
- en: 'The Login and Signup pages will be implemented as simple forms, as shown in
    the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注册页面将实现为简单的表单，如下面的截图所示：
- en: '![](img/b14959ee-7c53-452c-a179-c9b9ba7efa5a.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b14959ee-7c53-452c-a179-c9b9ba7efa5a.png)'
- en: The only difference between them is that the Signup page has an extra field
    to request the user to type the password a second time for confirmation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的唯一区别是注册页面有一个额外的字段，要求用户再次输入密码以进行确认。
- en: Both features will be implemented in [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml),
    *Securing the Serverless Application*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能将在第8章中实现，*Securing the Serverless Application*。
- en: The error pages
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误页面
- en: 'We have to support two types of errors: `HTTP 404 *Not Found*` and `HTTP 500
    *Internal Server Error*`. The `Not Found` status code will be rendered when the
    URL doesn''t match any page and `Internal Server Error` is a page that we can
    display when an error occurs in the backend. Both pages will be implemented to
    show an error message.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须支持两种类型的错误：`HTTP 404 *Not Found*`和`HTTP 500 *Internal Server Error*`。当URL不匹配任何页面时，将渲染`Not
    Found`状态码，而`Internal Server Error`是我们可以在后端发生错误时显示的页面。这两个页面都将实现以显示错误信息。
- en: 'Take a look at the error page in the following screenshot:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的错误页面截图：
- en: '![](img/262d0091-8ad8-4bce-89f1-d57f816e31c2.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/262d0091-8ad8-4bce-89f1-d57f816e31c2.png)'
- en: 'Take a look at the page not found in the following screenshot:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的页面未找到截图：
- en: '![](img/4028c152-ae5a-49c0-a907-935d440dcc98.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4028c152-ae5a-49c0-a907-935d440dcc98.png)'
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the basics of React to demonstrate how to use
    modern tools to build a serverless frontend. We discussed SPA and how to prerender
    pages to improve SEO. We have finished defining how to build the frontend of our
    Serverless Store.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了React的基础知识，以展示如何使用现代工具构建无服务器前端。我们讨论了单页应用（SPA）以及如何预渲染页面以改善搜索引擎优化（SEO）。我们已经完成了定义如何构建我们的无服务器商店的前端。
- en: In the next chapter, we will build the serverless backend of the online store,
    learning more about serverless architectures and RESTful APIs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建在线商店的无服务器后端，学习更多关于无服务器架构和RESTful API的知识。
