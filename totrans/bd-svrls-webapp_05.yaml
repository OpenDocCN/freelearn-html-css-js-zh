- en: Building the Frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build the web pages of our demo application. The objective
    here is not to teach frontend development, but to demonstrate that you can use
    modern tools along with serverless. For this demo, we will use React, but you
    could use Angular, Vue.js, or any other tool, and still take advantage of the
    serverless features. Also, we will discuss the pros and cons of SPA from a serverless
    perspective and let's take a look at how we can prerender SPA pages for better
    **Search Engine Optimization** (**SEO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use React to build our web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros and cons of Single-Page Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerendering pages for a better SEO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you'll have built the frontend of our serverless online
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Teaching frontend tools is not the objective of this book, but we need to build
    something useful to see how serverless deals with modern frontend development.
    We will use React here because it is currently one of the most popular tools.
    If you don't know what React is or how to use it, I'll guide you to understand
    the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: React principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you should note is that React is a library and not a framework.
    The difference is that a library provides a set of functionalities to solve a
    *specific* problem, and a framework provides a set of libraries centered on a
    particular methodology.
  prefs: []
  type: TYPE_NORMAL
- en: React is only responsible for the view layer of your application. That's the
    problem React solves. If you need to make Ajax calls or handle page routes, you
    need to add other libraries. When you develop with React, you need to think in
    components. Your user interface is a composition of simple components, where each
    one of them has an inner state and an HTML definition. When using React, you don't
    manipulate the web page directly. You change the component's state and React will
    render it again to match the current state. This approach promotes predictability.
    For a given state, you always know how the component will render. This is very
    important for testing and maintaining complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept is the virtual DOM. The **Document Object Model**
    (**DOM**) is a representation of all nodes of an HTML page. If something changes
    on a page and you need to render a different view, the DOM needs to be manipulated.
    The problem is when you have hundreds of nodes. Recreating the entire view has
    a performance cost that can be perceived by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM is an abstract version of the real DOM. React tracks the state
    of all components and knows when one of them was modified. Instead of rerendering
    the entire view, it compares the modified virtual DOM with the real DOM and makes
    a small patch containing only the differences. This patch is applied with a much
    better performance.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you need to know that React is a **library** with the specific purpose
    of handling the **view layer,** it is based on **components**, where each one
    of them has an internal **state** and a **view** definition, and you can't modify
    the DOM directly because that's the responsibility of the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The Flux pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flux is a pattern for application-state management, and Redux is the most popular
    Flux-inspired implementation. If you are building a complex React application,
    you should learn Redux or another Flux-like framework. However, *You Might Not
    Need Redux*, as Dan Abramov, the creator of Redux, has blogged about ([https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367)):
    “*People often choose Redux before they need it*.”'
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a great framework, but it adds complexity to your project. As we are
    building a small frontend application, we will not use it here, and this decision
    makes sense for applications that have a short component tree. Again, the objective
    of this book is to focus on serverless and not on frontend development, so Redux
    is out of scope for us. In a real-world application, you need to consider the
    pros and cons. Most of the time, you will choose to use Redux, but not always.
  prefs: []
  type: TYPE_NORMAL
- en: React hello-world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React promotes the usage of JSX, a syntax that mixes JavaScript with XML. You
    don''t need to use JSX, but you *should* use it to improve the readability of
    the code. For example, take a look at the following JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example defines a `<HelloReact/>` HTML element and the rendered output
    will use the value of the `name` property. If the input is `World`, the rendered
    result will be `<div>Hello, World!</div>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the browser can''t execute this code because JSX doesn''t have native
    support. You need to use a JSX transpiler that will translate this example into
    the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Mixing JavaScript code with HTML sounds strange, but we can get used to it.
    In the end, most people find it more enjoyable and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To make this piece of code work, we need to add two dependencies such as React
    and ReactDOM. The former is the core, which lets us create components, and the
    latter is the library that renders the components and attaches them into an HTML
    node.
  prefs: []
  type: TYPE_NORMAL
- en: You can find these dependencies at [https://unpkg.com/react/](https://unpkg.com/react/)
    and [https://unpkg.com/react-dom/](https://unpkg.com/react-dom/). You will find
    the necessary files inside the `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a working hello-world example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Building a shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand React, we need to see how props and states work, and how we can
    compose an interface with different components. For a practical example, we will
    build a shopping cart. This example will be the foundation of our Serverless Store
    and the objective now is to achieve the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c362541-15c1-48bf-8da3-c5b107ee0a9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Preparing the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the criticisms of React is the need of external tools for development.
    In fact, one can use plain JavaScript, but as we saw, JSX is easier to understand.
    So, the first tool that you need to add to your project is a JSX transpiler.
  prefs: []
  type: TYPE_NORMAL
- en: When you browse a React project or any other modern web project, you will also
    find that people use many other tools such as Babel (ES6 to ES5 transpiler), Webpack
    (module bundler), ESLint (code analysis), and others. Also, each tool has many
    competitors. You may prefer to use Browserify instead of Webpack, for example.
    Understanding and configuring these tools takes a long time. If you are learning
    React, you need to understand first how React works and not how the environment
    is configured.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, the tool **Create React App** offers an opinionated configuration
    that uses well-established tools and practices. You don't need to worry about
    the environment anymore, you just follow what others have suggested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to start a new project using this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Create React App tool using the following npm command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `@1.3.1` term means that it will download the exact version that was used
    for this book's examples. If you prefer, you can remove this `@1.3.1` restriction
    to get the latest features, but that may introduce breaking changes to the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the directory to the new folder and start the application using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the application running at [http://localhost:3000](http://localhost:3000),
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3293096b-db79-49c5-88d8-58796decd663.png)'
  prefs: []
  type: TYPE_IMG
- en: Organizing the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This application will create the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `public/manifest.json` and `src/registerServiceWorker.js` files are used
    to support **Progressive Web App** (**PWA**), which is a great feature to build
    fast and more reliable web pages as it caches static assets and allows offline
    access. However, PWA is not so useful for an online store and is out of scope
    of this book, so it will be removed from the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make the following changes here to adapt the example to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remove PWA support**: Delete the `public/manifest.json` and `src/registerServiceWorker.js`
    files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Remove src files that won''t be used**: Delete the files `App.css`, `App.js`,
    `App.test.js`, `index.css`, and `logo.svg`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create folders**: Under `src/`, create the `css/`, `components/`, and `images/`
    folders.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add components**: Under `components/`, add the files `App.js`, `ShoppingCart.js`,
    `ShoppingCartItem.js`, `Product.js`, and `ProductList.js`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add CSS**: Under `css/`, create a file named `site.css` that will serve as
    our custom styles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add images**: Add two images that will be used as our products. I''ve used
    free images (Creative Commons CC0) from Pixabay ([https://pixabay.com](https://pixabay.com)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can browse the Packt resources for this chapter ([https://github.com/PacktPublishing/Building-Serverless-Web-Applications](https://github.com/PacktPublishing/Building-Serverless-Web-Applications))
    to see the final result. This project is available under a folder named `react-shopping-cart`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you should have the following project tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before starting to code the components, we need to make a few changes in the
    `index.js` file to match the new project tree. Use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For a responsive website, I''ve included the Twitter Bootstrap 3 ([https://getbootstrap.com](https://getbootstrap.com))
    styles in the `public/index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Composing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user interface is a composition of components. To make this clearer, the
    following diagram shows how we will compose our components to create the application
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8f88913-3138-4d40-8cd6-6a56a565faa7.png)'
  prefs: []
  type: TYPE_IMG
- en: The **App** component holds the entire view and is responsible for positioning
    the **Product List** and **Shopping Cart** components. The **Product List** component
    has a list of **Product** components, and the Shopping Cart will list the selected
    products as **Cart Item**.
  prefs: []
  type: TYPE_NORMAL
- en: In React, there is no interaction between components, except by passing properties
    from parent to child components. These properties are called props. The child
    can't pass data to the parent unless the parent gives a handler function as a
    property and the child executes this handler when an event occurs. For example,
    the parent can give a `handleClick` function that will be triggered by the child
    when a button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the restriction that you can have only parent-child interactions, the
    Product List and Shopping Cart components need a common parent. When a product
    is selected, it will trigger a function in Product List, which in turn will trigger
    another in the App component. This handler will change the App component's state,
    and by consequence, the state of the Shopping Cart component will also be changed
    because the App component will be defined to pass data to the cart through `props`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code extract, the skeleton of a component is presented. This
    format will be used to implement all components. To focus on the content, further
    examples will show only the `constructor()` and `render()` implementations. Full
    code examples can be downloaded from the Packt resources associated with this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The App is a component with the responsibility of organizing the page''s layout.
    It uses Bootstrap''s grid system to position the two other main components such
    as Product List and Shopping Cart. It should be rendered with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When using JSX, you add a class to an HTML element with the `className` property,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<div className="container"></div>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we can see the Product List component being set with two properties
    such as `products` and `onSelect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `products` property will receive a list of products that is controlled by
    the state of the App component. The `onSelect` property will receive a handler
    function, which will be used by the children to trigger the parent component when
    a product is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the Shopping Cart component has two properties such as
    `selectedProducts` and `onDeselect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `selectedProducts` property will receive a list of products that were selected,
    while the `onDeselect` property defines a handler function that should be triggered
    by the Shopping Cart component when a product is deselected.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this component, the App component is sharing its state with the Product
    List and the Shopping Cart components, thus App is responsible for defining the
    products objects and for keeping track of the selected products. The initial list
    of products is defined in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is a simplified example. In the next chapter, we
    will retrieve this list from a Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial state is defined inside the class constructor. Also, you need to
    bind the component''s `this` instance to the callback functions. Otherwise, `this.state`
    will not be found when the function gets called inside another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleSelect` function should be defined inside the class and it will
    receive a product as an argument to set its `isSelected` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to observe in this example: `slice()` was used
    to create another array, instead of mutating the current array, and `setState()`
    was used instead of directly changing the reference to `products`. This is because
    working with immutable objects has performance benefits. It''s easier to identify
    a modified object by checking whether its reference has changed than by looking
    into all of its property values. Regarding `setState()`, it is used to make React
    aware of the need to rerender the component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, as the `handleSelect` function is taking the `isSelected` property
    and setting the state, regardless of whether the property is true or false, we
    can use the `handleSelect` function to define the `handleDeselect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Product List component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This component accesses the data provided by its parent through the `props`
    variable. It will use the `products` array to iterate and create a new Product
    component for each item of the array. Also, it will set the `onSelect` handler
    with the function passed by its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Product component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This component is responsible for rendering the details of the product, such
    as the image, description, price, and a button that allows the user to add the
    product to the cart. As you can see, the `onClick` event of the button will change
    the `isSelected` state and trigger the `onSelect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Shopping Cart component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Shopping Cart component is responsible for rendering the selected products
    and showing the total value. Let''s take a look at the following code snippet
    to see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getTotal` function uses a `map`/`reduce` operation to get the aggregated
    total value. The `map` operation will transform the input, creating an array of
    numbers, and `reduce` will sum all values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Cart Item component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last component is the Cart Item. For each selected product, a cart item
    will be added to the Shopping Cart component. This component is rendered with
    the product name and value, along with a Glyphicon for an X mark icon. Glyphicon
    is a set of icons that are available through Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, when the user clicks on the icon, we need to trigger the `onDeselect`
    function. Take a look at the following code snippet to see how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Publishing our demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing the static files requires a processing phase due to the fact that
    we have used JSX to build the React demo. In this case, the Create React App module
    will help us again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to learn about publishing our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before publishing, we need to test it locally to confirm that everything is
    working as expected, which can be done using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can prepare our frontend project to be published using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting files will be processed, minimized, and bundled. You can find
    all files inside the `build` folder. Now upload them to Amazon S3 using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, reupload the `index.html` file, adding the `Cache-Control: no-cache` header
    just to this file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Making Ajax requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is responsible for just the view layer. React is *not* concerned with
    how data is fetched from the server. So, there are no restrictions and you can
    retrieve the server data using many different approaches. Redux offers a pattern
    using *Async Actions* and Relay, which is another JavaScript framework, uses *GraphQL*
    to handle data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample application, we will use the simplest approach: the *Root component*.
    This pattern is simple and can be very useful for small projects where you have
    a shallow component tree. What we will do is to concentrate all Ajax requests
    in a single component and the best option for this is to use the Root component
    because it''s the only component that can communicate with all the others.'
  prefs: []
  type: TYPE_NORMAL
- en: When the Root component retrieves some data from the server, the children components
    will be updated through *properties,* and React, as expected, will render again
    only the ones that were changed. And whenever a component needs to perform an
    action, it will execute a function that was passed as a property by the parent
    component. This information will go up until it reaches the root level, where
    it can be sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we will consider the App component as the Root component. The
    `index.js` file is technically the root since it is the first to load, but `index`
    is only responsible for appending the React application to the HTML page. As the
    App component is loaded by `index` and App is a common parent for all other components,
    it will be defined as our root.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we will build a page that will request a list of
    products on load. This request will be done in the Root component, but we need
    to define where exactly it will be executed. The `render` function is *never*
    a good choice because `render` is always considered as a *pure function*: for
    a given input, the output will always be the same, which means that side effects
    are not allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Excluding `render`, we have two candidates: `componentWillMount` and `componentDidMount`,
    both of them execute *just once* and before (`componentWillMount`) or after (`componentDidMount`)
    the first `render` execution. Since the asynchronous call will take some time
    to execute, and the component rendering will take place before the result is received,
    it doesn''t help to use the `componentWillMount` option. The first rendering will
    always be done with empty data. So, it makes more sense to use the `componentWillMount`
    function to set the initial state as empty (and avoid undefined values in your
    properties) and the `componentDidMount` function to fetch data from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Another question is whether the initial state should be set in the `constructor`
    function or the `componentWillMount` function. They are technically equivalent,
    but it is much more common to use the `constructor` function for this task. In
    practice, `componentWillMount` is hardly used at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to decide is: which Ajax library will be used? I like to use
    **axios** for this task, but if you prefer, you can use another library for this
    such as **Fetch** or **SuperAgent**. Some people like to use **jQuery** for Ajax
    calls, but adding a full-featured library for just one task doesn''t make much
    sense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install axios, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To include axios in a component, add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the example shows how the initial state is defined inside
    the constructor. It sets an empty array of products and a Boolean variable, `ready`,
    with the value `false`. This Boolean will be set to `true` once the request completes.
    Using this approach, we can control the rendering state and display a loading
    icon while the page is still fetching data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the `ready: false` state, we can display a `glyphicon-refresh` icon
    instead of the list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52b0347-de96-4eec-b2e8-a800b0dce48b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the `componentDidMount` implementation in the following code
    snippet. The API address is used to trigger a Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting the results, we set the `ready` state with the `true` value and
    the list of products with what we have received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5d14552-fbe7-4592-8f3d-b8ce430dd89e.png)'
  prefs: []
  type: TYPE_IMG
- en: Sending data to the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we have placed the Ajax request inside the `componentDidMount`
    function because we wanted the data on page load. However, in the following example,
    the Ajax request will be executed when a button is clicked, so we don''t have
    the same restriction. Take a look at the following steps, which describe the process
    step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The request will be defined as a function of the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleSave` function is passed through properties to the children components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And, to finish, the children will trigger the `save` function when a button
    is clicked. After the request finishes, the parent component will change the state
    of the `hasSaved` property to `true`, and we can use this value in the children
    components to display a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving, the word saved will appear under the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a40098f-4964-472e-8e3b-ae465f27630d.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling the page routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Later in this chapter, we will discuss the pros and cons of SPA, but first we
    will take a look at how to build one. An SPA is an application that loads just
    one HTML file, but it will dynamically update that page while the user interacts
    with it. Also, the content will render differently to match the URL. For example,
    browsing the `example.com` address will render the `Home` component, while browsing
    `example.com/about` will render the `About` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we will use the React Router module. Let''s take a look
    at the following steps to build an SPA:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application using the Create React App tool, or modify the previous
    Shopping Cart application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the React Router module by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `@4.x` term means that it will download a version that is compatible with
    the one used for this book's examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App.js` file will be modified to define the application routes. First,
    we need to import the React Router module components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to import our App components. In this example, we will use the
    following components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Header`: This is the component that will render the text `"Serverless Store"`
    for all pages'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Footer`: This is the component that will render a footer text for all pages'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductList`: This is a list of products, where each product links to the
    `Product` component'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Product`: This component gives details of a specific product'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShoppingCart`: This is a list of products that were selected by the user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoMatch`: This is a component that will render the text "Page not found"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `App` component will render the page using the following components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Router`: This is the Root component for the page routing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Switch`: This renders the first child route that matches the URL path. If
    there is no match, it will render the `NoMatch` component.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Route`: This renders the component for the specified path.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the preceding mentioned components in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and test the URLs. If it doesn''t match any path, the `NoMatch`
    component will be rendered and it will display the Page not found message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a7fb41b-bbb7-41ab-b1cc-42a00d2ccdd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Linking pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linking one page to another is done using the React Router''s Link component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Link is just a wrapper for the HTML anchor element. In the following example,
    the implementation of the Product List component shows how to link to a page of
    a specific Product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will be rendered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62617504-e3f1-4fdc-b98d-86bb7abb8c34.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have declared the routes of our application, we have defined the route
    of the Product component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The colon sign defines the parameter that can be used by the related component.
    In this case, `:id` defines a parameter with the name `id`, which can be used
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This Product component will render as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/157cb9b8-e127-457e-94ec-5cfd0e43d806.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the `localhost:3000/product/1` path defined an `id` parameter with
    value `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a traditional multipage website, each URL loads a different HTML page. If
    you are at the `example.com` page and need to navigate to `example.com/about`,
    the entire view will blink with a page reload because it will need to be rendered
    again. The problem is that, usually, a page reload is a waste of time since both
    pages share similar content, such as the page header and footer. Also, CSS and
    JavaScript dependencies may be exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: In a Single-Page Application, there is a base HTML file that will be loaded
    for every URL and, depending on the given URL, the inner content will be dynamically
    loaded to match the address. Also, the URL browsing is controlled at the client-side
    using JavaScript. Changing from one URL to another will not cause a full page
    reload. Instead of loading an entire new file, a request is made to the server
    to retrieve only what is necessary for the new address and just a part of the
    page will be rendered again.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of Single-Page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPA is a modern approach that has the objective to provide a better user experience,
    but it's not perfect. There are pros and cons that you need to know before using
    it. While this topic can be extensive, we will highlight only the most relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s list the main benefits of this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No page refresh**: This is an obvious benefit. When the user changes to another
    view, the page will not blink. The browsing experience becomes more pleasant with
    a fluid navigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupling**: You have a better separation of frontend and backend code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce the server-side code**: We are building a serverless website, so we
    must consider that cold start delays at the backend may impact the user experience.
    In SPA, there is much more logic at the client side to make the dynamism feasible,
    and we can use this approach to reduce the size of the server-side code and improve
    the performance by reducing the number of requests to the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SPA has a few drawbacks, we can consider the following cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Larger file sizes**: As we have more logic at the client side, the applications
    usually have larger JavaScript dependencies. This is a big problem, especially
    with mobile clients with poor network conditions. The first load of the site will
    take more time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requires JavaScript**: There is yet a small percentage of users that disable
    JavaScript due to security reasons. If you have a simple site that doesn''t need
    any fancy features, your SPA is forcing JavaScript support that would otherwise
    be optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search Engine Optimization**: An SPA application relies heavily on JavaScript.
    Google crawlers can execute some JavaScript code in special conditions, but Bing
    and others won''t execute. If we want the search engines to correctly index our
    website, we need to prerender the content especially for them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some may argue that a low-end mobile device may have a poor performance with
    SPA because of the increased amount of JavaScript code. While that might have
    been true in the past, it may not be the reality at present and won't be in the
    future. Nowadays, even low-end devices have a powerful CPU that can perfectly
    execute most operations seamlessly. The real issue with mobile devices is not
    the computational power, but the network performance to download a larger size
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will stick with SPA, and the main reason is that it fits well
    with the serverless approach. SPA is a modern approach to offload to clients some
    of the computing costs needed to run a website.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda is cheap, but not free. On the other hand, client-side executions are
    limitless. Using the premise that more logic at the client won't significantly
    hurt the performance, I prefer avoiding making Lambda requests to handle the application
    state. Lambda should be used only to retrieve or save data and not to control
    UI logic.
  prefs: []
  type: TYPE_NORMAL
- en: However, as with most things in our field, each case should be treated separately.
    You may benefit from a multipage application and there is nothing wrong with it.
    With multipage, you just need to configure the Lambda function to return HTML
    content instead of JSON data, as we saw in an example in [Chapter 3](436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml),
    *Using the Serverless Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: Prerendering pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our frontend approach, the layout is entirely composed by JavaScript code
    using React components. Prerendering a web page means executing this JavaScript
    code and saving the output HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous section, to improve **Search Engine Optimization**
    (**SEO**), we need to prerender pages because the majority of crawlers can't execute
    JavaScript code, and the ones that can, such as Google, won't execute all kinds
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Using PhantomJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PhantomJS is a headless web browser, based on WebKit, which can be used to make
    HTTP requests and save the HTML output. It is not a Node.js module, but it can
    use Node.js modules. It runs in its own process, which is not the same as a Node
    runtime. You can download it from the official site: [http://phantomjs.org](http://phantomjs.org).
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, you can configure the S3 bucket to
    return the `index.html` page whenever an error of HTTP 404 *Not Found* occurs.
    So, when the user browses the address `example.com/page1`, S3 will look for a
    `page1.html` file. It will not find it, but it will load the `index.html` file
    instead. As we have developed an SPA, it will be able to render the contents of
    the corresponding `page1` file, keeping the browser address as `example.com/page1`.
  prefs: []
  type: TYPE_NORMAL
- en: When we prerender the `page1` file, the output HTML must be uploaded to the
    S3 bucket. This means that the next time we try to fetch the address `example.com/page1`,
    S3 will find a `page1.html` file and load it directly. Loading a prerendered page
    for a real user is not a problem, it's even better from a performance perspective.
    This user will load the HTML with the React dependencies. After a few instants,
    the React application will take control and further requests will be handled as
    a normal SPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script to prerender a page is quite simple. You can follow this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, add the PhantomJS binary to PATH and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: One of the problems of this approach is that you need to keep track of all the
    pages of your application. If a new page is added, you need to remember to include
    it in this list of pages to process. Also, you need to prerender your application's
    root file (`index.html`) and replace it in the S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the output HTML file will make the content visible for all web crawlers.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Lambda functions for prerendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your application is a static website, you can prerender all pages just once.
    However, for dynamic applications such as our Serverless Store, we need to have
    a routine of prerendering pages to avoid serving outdated content to crawlers.
    For example, the `https://serverless-store.com/products/lonely-bird` page shows
    the details of the Lonely Bird product. If the product is modified or deleted,
    we need to apply the changes to the `/products/lonely-bird.html` file. You have
    the following two options for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever some content is modified, trigger a Lambda function to update the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule a Lambda function to execute daily to update all pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, Lambda functions will be used, but how to call the PhantomJS
    binary if it is not a Node module? For this, we can install the `phantomjs-lambda-pack` Node
    module, which provides binary files compatible with Amazon Linux AMI machines
    to run on Lambda. It can be used as a Node module because it will spawn a child
    process to execute PhantomJS.
  prefs: []
  type: TYPE_NORMAL
- en: The `prerender.js` file that is loaded in the next example is the code implemented
    in the previous section. It must be placed in the same folder as the `serverless.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used as our Lambda handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This PhantomJS wrapper requires the Lambda function to use at least 1,024 MB
    of RAM and a timeout of 180 seconds. So, instead of requiring one Lambda function
    for each page, it's better to call the Lambda to handle multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering on the fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of prerendering a web page, you can also render it on the fly. You need
    to detect that the request was made from a crawler and execute some logic to render
    the HTML page. Detecting a crawler can be done by checking the user-agent string
    and comparing it with a known list of common crawlers. This method works, but
    requires periodic maintenance and will not cover all crawlers, just the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: There is a website, [https://prerender.io](https://prerender.io), which offers
    a service to prerender sites on the fly when a crawler is detected. You install
    a middleware in your server and it will be responsible for checking the requests
    to find crawlers and provide them a cached prerendered version of your page. As
    we don't have a server, and we are using CloudFront/S3 to host the frontend, we
    can't execute code on demand.
  prefs: []
  type: TYPE_NORMAL
- en: To solve problems like this one, AWS released a new service named **Lambda@Edge**,
    which is currently in preview phase. This service will execute Lambda functions
    in edge locations in response to *all* *page requests*. AWS promised a very short
    latency to execute those Lambda functions, and you can use it to prerender on
    the fly if an agent is a crawler. You can also use it for other use cases such
    as modifying response headers or adding content depending on the agent, IP address,
    or referrer.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering on the fly has the obvious drawback that it will be slower to answer
    the requests, but as the Lambda function has direct access to the database, the
    rendered page will always be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Building an online store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the previous Shopping Cart demo to begin our application. Now,
    we know how to set page routes and how to make Ajax requests, so we have everything
    to continue. One important difference is that the Shopping Cart component will
    be in a different page than the Product List component. Also, we need to create
    other pages. The following is a list of the pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Home page**: This presents a list of all available products where the user
    can add them to the Shopping Cart component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product details**: This is a dedicated page that provides more details of
    a specific product where users can see and add new comments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shopping Cart**: This shows all of the selected products and is responsible
    for handling payments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signup page**: This handles account creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Login page**: This allows the user to log in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page not found**: This is a page that will be displayed when the address
    doesn''t exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error page**: This is a page that will be displayed when an error occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book will not cover all the code for the online store sample. There are
    too many parts that are simple to implement or are unrelated to the serverless
    concept. You can find the entire code in the Packt resources associated with this
    book or on my GitHub repo: [https://github.com/zanon-io/serverless-store](https://github.com/zanon-io/serverless-store).
    For a running demo, access: [https://serverless-store.zanon.io](https://serverless-store.zanon.io).
    Instead of dumping all the code here, we are focusing on the important parts.
    The following sections will describe what each page implements along with a screenshot
    of the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The Navbar component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Navbar component is like the header component that should appear for all
    pages. For its implementation, let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install two Node modules: `react-bootstrap` and `react-router-bootstrap`.
    Install them using the following npm command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the necessary components using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the Navbar component to set the links using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e16e9d5-7817-4700-a5dd-c00e66c29ecc.png)'
  prefs: []
  type: TYPE_IMG
- en: The last item is a notification icon. We will implement it in [Chapter 9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml),
    *Handling Serverless Notifications*.
  prefs: []
  type: TYPE_NORMAL
- en: The Home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Home page will render the Product List component that we have defined in
    this chapter. One important observation is how the page router will select this
    component. Previously, we used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to pass some properties from the App component to the Product
    List component, since the App component is responsible for managing the application
    state. In this case, we need to use the `render` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The same applies for all other components that need to share their state with
    the App component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81e7a258-ec13-436e-8c4f-0c207e6ad2f6.png)'
  prefs: []
  type: TYPE_IMG
- en: The product details page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The product details page will be accessed by clicking on the image of a product.
    On this page, the user will be able to see the product and customer reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61478952-bcc3-45e5-86e2-3aa9f9ff1d98.png)'
  prefs: []
  type: TYPE_IMG
- en: The *customer reviews* feature will be implemented later in this book, in [Chapter
    9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml), *Handling Serverless Notifications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the product details page, we need to add a link in the product image
    using the `Link` tag, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Another change that is required is how the page route will be able to identify
    which product to render. In this case, we will modify the `Route` component to
    render the `Product` component using the URL parameter available at the `props.match.param`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The Shopping Cart page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Shopping Cart page will be implemented like we did previously in this chapter.
    The only modification here is the addition of a checkout button, which will be
    used to process the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/098ef750-002f-49f9-82a2-ddaf4f33d2e9.png)'
  prefs: []
  type: TYPE_IMG
- en: However, handling payments is a complex feature for a restricted audience, thus
    it will not be discussed here. If you need a serverless service for this, I recommend
    that you take a look at Stripe ([https://stripe.com](https://stripe.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on this button, we will display a modal, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e24d2e4e-15fb-4c03-b97e-d8f2601d7330.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This modal is implemented using the `react-bootstrap` component, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, `closeModal` is a method to set the `showModal`
    state to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The Login and Signup pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Login and Signup pages will be implemented as simple forms, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b14959ee-7c53-452c-a179-c9b9ba7efa5a.png)'
  prefs: []
  type: TYPE_IMG
- en: The only difference between them is that the Signup page has an extra field
    to request the user to type the password a second time for confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: Both features will be implemented in [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml),
    *Securing the Serverless Application*.
  prefs: []
  type: TYPE_NORMAL
- en: The error pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to support two types of errors: `HTTP 404 *Not Found*` and `HTTP 500
    *Internal Server Error*`. The `Not Found` status code will be rendered when the
    URL doesn''t match any page and `Internal Server Error` is a page that we can
    display when an error occurs in the backend. Both pages will be implemented to
    show an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the error page in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/262d0091-8ad8-4bce-89f1-d57f816e31c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the page not found in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4028c152-ae5a-49c0-a907-935d440dcc98.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the basics of React to demonstrate how to use
    modern tools to build a serverless frontend. We discussed SPA and how to prerender
    pages to improve SEO. We have finished defining how to build the frontend of our
    Serverless Store.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build the serverless backend of the online store,
    learning more about serverless architectures and RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
