- en: Chapter 7. Showing a Social Feed with Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to create a command-line tool that
    uploads photos to Flickr. In this chapter, we will communicate with one of the
    most popular social networks: **Twitter**. We will create an application that
    gets the latest tweets based on a user handle and shows them on the screen. Node.js
    will be responsible for the communication with the Twitter API, and Ember.js will
    take care of the user interface. The following is a short list of the topics that
    we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Ember.js framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with Twitter's API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring Node.js with Ember.js to obtain tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have worked on applications in the previous chapters. For this application,
    we need a Node.js server, which will deliver the necessary HTML, CSS, and JavaScript
    code. The following is the `package.json` file, which we are starting from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There is only one dependency and that's the module that will connect to Twitter.
    After you run `npm install` in the same folder as the `package.json` file, the
    module will appear in the newly created `node_modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the folders for the HTML, CSS, and JavaScript and
    put the necessary files inside these folders. In addition, create the main `index.js`
    file that will contain the code of our Node.js server. At the end, our project
    directory should look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the application](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The CSS styles of the project will go to `css/styles.css`. The templates will
    be placed in the `html/page`. html file and the custom JavaScript code will be
    written to `js/scripts.js`. The other `.js` files are Ember.js itself and its
    two dependencies: jQuery and Handlebars.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the server and delivering the assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](part0042_split_000.html#page "Chapter 5. Creating a To-do Application
    with Backbone.js"), *Creating a To-Do Application with Backbone.js*, we built
    an application with Backbone.js, and we used two helper functions: `serveAssets`
    and `respond`. The purpose of these functions was to read our HTML, CSS, and JavaScript
    files and send them as a response to the browser. We will use them again here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first start by defining the global variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `http` module provides methods to create and run the Node.js server, and
    the `fs` module is responsible for reading the files from the filesystem. We are
    going to listen on port 3000 and the `files` variable will cache the content of
    the read files. When `debug` is set to `true`, the assets will be read on every
    request. If it is `false`, their content will be fetched only the first time,
    but every future response will contain the same code. We are doing this because
    while we are developing the application, we don't want to stop and run our server
    just to see the changes in the HTML script. Reading the file on every request
    guarantees that we are seeing the latest version. However, this is considered
    as a bad practice when we run the application in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue and run the server using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function, which we passed to `http.createServer`, accepts two
    arguments: the `request` and `response` objects. The Node.js part of our application
    will be responsible for two things. The first one is to provide the necessary
    HTML, CSS, and JavaScript, and the second one is to fetch tweets from Twitter.
    So, we are checking whether the URL starts with `/tweets` and if it does, then
    we will process the request differently. Otherwise, `serveAssets` will be called
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we are getting the requested file path, and we will read
    the file from the filesystem. Along with the content of the file, we will also
    get its extension, which is needed to set the response header properly. This is
    done in the `respond` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is important because if we don't provide `Content-Type`, the browser may
    not interpret the response correctly.
  prefs: []
  type: TYPE_NORMAL
- en: And that's everything about the serving of the assets. Let's continue and get
    information from Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting tweets based on a user handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we write the code that requests data from the Twitter''s API, we need
    to register a new Twitter application. First, we should open [https://dev.twitter.com](https://dev.twitter.com)/
    and log in with our Twitter **Name** and **Password**. After that, we need to
    load [https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new) and
    fill in the form. It should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting tweets based on a user handle](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can leave the **Callback URL** field empty. The **Website** field can have
    the address of our personal or company site. We should accept the terms and conditions
    present below the form, and click on **Create your Twitter application**. The
    next page, which we will see, should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting tweets based on a user handle](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The information that we need is located in the third tab: **API Keys**. Once
    we click on it, Twitter will show us the **API key** and **API secret** fields,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting tweets based on a user handle](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, we will generate an access token and access secret by clicking
    on the **Create my access token** button. Normally, the data doesn''t show up
    immediately. So, we should wait a bit and refresh the page, if necessary. The
    resulted document should look like on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting tweets based on a user handle](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will copy the **Access token** and **Access token secret** values. It's a
    good practice to keep such sensitive information out of the application's code
    because our program may be transferred from one place to another. Placing the
    data in an externally configured file will do the job in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have these four strings, we are able to communicate with Twitter''s
    API. The following variables go at the top of our `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `T` variable is actually a Twitter client, which we will use to request
    the data. We left a place in our server to query the Twitter''s API. Let''s now
    put the necessary code in the `index.js` file, which can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The request that we need to perform is `http://localhost:3000/tweets/KrasimirTsonev`.
    The last part of the URL is the Twitter handle of the user. So, the `if` statement
    becomes `true` because the address starts with `/tweets/`. We extract the username
    in a variable called `handle`. After that, this variable is sent to the `statuses/user_timeline`
    resource of the Twitter's API. The result of the request is directly sent to the
    browser via a stringified JSON.
  prefs: []
  type: TYPE_NORMAL
- en: On a concluding note, the Node.js part of our project provides all the HTML,
    CSS, and JavaScript code. Along with that, it accepts a Twitter handle and returns
    the most recent tweets of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember.js is one of the most popular client-side JavaScript frameworks today.
    It has a great community and its features are well-documented. Ember.js gathers
    an increasing number of fans because of its architecture. The library uses the
    Model-View-Controller design pattern, which makes it easy to understand because
    that pattern is widely used in almost every programming language. It also collaborates
    well with the REST APIs (we are going to build such an API in [Chapter 11](part0078_split_000.html#page
    "Chapter 11. Writing a REST API"), *Writing a REST API*) and eliminates the task
    of writing the boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the dependencies of Ember.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ember.js framework has the following two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jQuery**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handlebars**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one is the most used JavaScript tool on the Web today. It provides
    methods to select and manipulate the `DOM` elements and a lot of helper functions
    such as `forEach` or `map`, which help us to work faster. The library also solves
    some **cross-browser** issues by providing only one API. Like, for example, if
    we want to attach an event listener to an element, we need to use `attachEvent`
    in Internet Explorer but `addEventListener` in the other browsers. The simple
    `.on` method is provided by jQuery, which wraps this functionality. It checks
    for the current browser and calls the correct function. Along with all these things,
    we are able to use the `.get` or `.post` functions, which perform AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handlebars** is a template engine library. It extends the HTML syntax by
    adding expressions and custom tags. It''s similar to **Jade**, another template
    language which we used in [Chapter 2](part0023_split_000.html#page "Chapter 2. Developing
    a Basic Site with Node.js and Express"), *Developing a Basic Site with Node.js
    and Express*. The difference is that this time we will use templates at the client-side
    part of the application. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This a template definition that Handlebar uses. It''s defined in a `<script>`
    tag because the content inside is ignored by the browser, and it is not rendered
    as a part of the `DOM` tree. There is one expression: `{{name}}`. Normally, the
    template is populated with information and such parts of the markup are replaced
    with the actual data. What a handlebar does is that it gets the value of the `script`
    tag. Then, it will parse it. The expressions found are executed and the result
    is returned to the developer.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue with the actual coding of our small application, we will
    go through the most important components of Ember.js.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring classes and objects in Ember.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like every framework, Ember.js has predefined objects and classes, which are
    at our disposal. In most cases, we will extend them and write only the custom
    logic, which is a part of your application. All the ready-to-use classes are under
    the `Ember` namespace. This means that whenever we want to use some part of the
    framework, we need to go through the `Ember.` notation. For example, in the class
    extending shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We defined a class called `Person`. It has two properties and only one function,
    which shows a message on the screen. Just after that, we created an instance of
    that class and called the method. The properties of a class in Ember.js are accessed
    via `.get` and `.set` methods. In the previous example, we were still able to
    use `this.firstname` instead of `this.get("firstname")`, but this is not exactly
    right. In the `.set` and `.get` methods, Ember.js does some calculations, which
    are necessary to implement features such as data binding and computed properties.
    If we access the variable directly, the library may not have the chance to do
    its job.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By definition, the **computed** **properties** are properties, which derive
    their value by executing a function. Let''s continue and use the previous example.
    Instead of concatenating both `firstname` and `lastname` every time, we will create
    a computed property `name`, which will return the needed string. We can see this
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will still access a property with the `.get` method, but this time its value
    is calculated by a function. This can be extremely helpful if we need to format
    our data before displaying it. It''s good to know that we can use computed properties
    to set a value. By default, they are read only, but we can transform them to accept
    and process data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The routing processes are more like extensions for the other client-side frameworks.
    However, in Ember.js, everything is built around them. The **Router** is a class,
    which translates the page's URL to a series of nested templates. Each of these
    templates is connected to a model that delivers the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can think about the Router as a starting point of our logic. Every route
    and resource has its own class and controller linked to it. The good news is that
    we don''t really need to define them because the framework does this for us. Very
    often, we will need to modify their implementation by setting some properties;
    however, in general, we are free to leave the default suggested versions. Once
    we start working with Ember.js, we will find out that there are a lot of classes
    that are automatically created. Sometimes, it is a bit difficult to follow them.
    There is a Google Chrome extension called **Ember Inspector**. It''s actually
    a new tab in the Developer Tools panel. The inspector can show us what is going
    on in our application. For example, the previous code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, there are several routes and controllers available. There is
    a default route for the application and for the main **post** resource. The extension
    is really helpful because it shows us the exact names of the classes. Ember.js
    has strict naming conventions, and we should be able to figure out the names by
    ourselves, but it is still a handy extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to put some logic in the controller of the comments section, then
    we should use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We should remember that we are actually modifying the definition of the class.
    The instances of it are automatically created by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Views and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already mentioned that Ember.js uses Handlebars for its templating purposes.
    A simple definition of a template looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a script tag along with the HTML markup. Every template has a `view`
    class associated with itself. Usually, the developers don''t extend the `view`
    class. It is used in cases where we need to heavily handle user events or create
    custom components. Under the hood, the `view` class translates the primitive browser
    events into events that mean something in the context of our application. For
    example, we may have the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Its corresponding View instance is seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are handling the clicking of the text. By using the `.append` method, the
    view is added to the `<body>` element, but there is `.appendTo`, which can add
    our custom HTML to whichever `DOM` element we need.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every route in Ember.js has an associated model, which is an object that stores
    the persistent state. We set our models in the route's class. There is a hook
    called `model`, which should return our data. Very often, we will get the application's
    data asynchronously. For such cases, we can return a JavaScript promise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The template linked to a specific route renders its HTML based on the model.
    So, we are able to use expressions that represent properties from the result of
    that `.model` method. For example, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the context of Ember.js, the **controllers** are classes that decorate your
    models with the display logic. Ideally, they will store the data that doesn''t
    need to be stored in a database. It''s only needed when the information needs
    to be displayed. As with the models, the framework defines a different controller
    class for every route. Let''s say that we are developing an online book store.
    We could have a route like the one in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have only one route, but three controllers are defined. We are able to see
    them by using the Google Chrome''s extension. Check out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controllers](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the `BooksRoute` class, we will define our model, and in `BooksController`,
    we will create computed properties to display the books in a better way. The controllers
    are also the place where we could process any events that come from the browser.
    Initially, such events are caught by the views, but if there is no defined `View`
    or there is no handler for the event, then that is passed to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: These are the most important components of every Ember.js application. Now,
    let's continue to build our small project—a single-page app for getting messages
    from Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client side of the project contains two screens. The first one displays
    an input field and a button where the user should type the Twitter handle. The
    second one shows the tweets. We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing Ember.js](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The left part of the image shows the first page and the right one shows the
    tweets of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The html/page.html file is our main file and is the base of our application
    and will be the first page that the user sees. It contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the basic HTML markup that we are starting from. The dependencies of
    Ember.js are included along with the `js/scripts.js` file, which will contain
    our custom logic. The templates, which we will define afterwards, will be placed
    inside the `<body>` tag. The following template is the first one. It''s the main
    template of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have only one expression: `{{outlet}}`. That''s an Ember.js-specific expression
    and shows the framework where we want our subviews to be rendered. Note the name
    of the template: `social-feed`. We will use the same name during the definition
    of the routes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML code that we will use for the first screen, the one with the input
    field, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the template is `social-feed/index`. With `/index`, we are saying
    that this is the default template of the route with the name `social-feed`. The
    `{{input}}` tag is an Ember.js helper, which is later transformed to an `<input>`
    element. The `type` and `placeholder` attributes have the same meaning as in the
    regular HTML. However, `value` here plays another role. Note that `value` is not
    wrapped in double quotes. That''s because the `handle` keyword is actually a property
    of the Route''s controller, and we have two-way data binding. There is another
    expression used: `{{action}}`, which accepts the name of a method, which is again
    part of the controller. It will respond to a user''s click event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest template that we will define is the one that shows the tweets. We
    can see that template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The`{{{formattedHandle}}}` helper will be replaced with a link to the user's
    profile on Twitter. There are three brackets because the value of `formatedHandle`
    will be in HTML. If we use only double brackets, handlebars will display the data
    as string and not as HTML markup. There is an`{{#each}}` helper used. That's how
    we will loop through the fetched tweets and display their content. And at the
    end, we will use the `{{#link-to}}` helper to generate a link to the first screen.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, the Ember.js applications start with creating a global namespace
    followed by defining the routes. `js/scripts.js` starts with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one resource and one route created. The route responds on a URL that
    contains a dynamic segment. Let''s check the names of the controllers and templates
    in Ember.js Chrome extension. The following screenshot displays the exact created
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the routes](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ember.js defines several routes by default: `application`, `loading`, and `error`.
    The first one is the main project route. `LoadingRoute` and `ErrorRoute` can be
    used if we have asynchronous transition between two routes. These substates are
    very useful if we load the model data from an external resource and want to indicate
    the process somehow.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the user input and moving to the second screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to define a controller for the `social-feed/index` template. It will
    transfer the user to the second screen if the button on the screen is clicked.
    Along with that, we will get the Twitter handle that is entered in the input element.
    We define a controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are clearing the value of the `handle` property—`this.set('handle',
    '')`. We are doing this because the user will later return to that view and will
    want to enter a new username. As an addition, we can extend the view that is responsible
    for that template, and we can bring the browser's focus to the field once the
    template is added to the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a URL address that responds with a JSON-formatted list of tweets. There
    are corresponding controllers and route classes, which are defined by default
    from Ember.js. However, we need to set a model and get the handle from the browser''s
    address, so we will create our own classes. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic segment from the URL comes to the Route's `model` function in the
    `params` argument. We will get the string and set it as a property of the class.
    Later, when we set up the controller, we are able to pass it along with the model.
    The `setupController` function is a hook, which is run during the route's initialization.
    As we said in the beginning of the chapter, the main role of the controller is
    to decorate the model. Ours does only one thing—it defines a computed property
    that prints the Twitter handle of the user in a `<a>` tag. The controller also
    extends `Ember.ArrayController`, which provides a way to publish a collection
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back a few pages and check out the `social-feed/tweets` template,
    we will see that we can show the tweets with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we will use only `{{text}}` and not `{{formatTweet text}}`. What
    we did is used a custom-defined helper, which will format the text of the tweet.
    We need that because the tweet can contain URLs, and we want to transform them
    to valid HTML links. We can do that as part of the controller and define another
    computed property, but we will do it as a Handlebars helper. We can see it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using a regular expression to transform the URLs to the `<a>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: With the latest lines of the code, our `js/script.js` file is finished, and
    we can use the application to fetch the latest tweets of any Twitter user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Node.js with Ember.js. We successfully
    created a fully working application, which shows the messages posted on Twitter.
    Essential work was done by external modules, which again proves that the Node.js
    ecosystem is really flexible and provides everything we need to develop top-notch
    web applications. The modern client-side frameworks such as Ember.js, AngularJS,
    or Backbone.js are expected to receive JSON and Node.js is capable of delivering
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will find out how to use Node.js to optimize our project
    tasks and boost our coding performance.
  prefs: []
  type: TYPE_NORMAL
