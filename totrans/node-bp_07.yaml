- en: Chapter 7. Showing a Social Feed with Ember.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 使用 Ember.js 显示社交动态
- en: 'In the previous chapter, we learned how to create a command-line tool that
    uploads photos to Flickr. In this chapter, we will communicate with one of the
    most popular social networks: **Twitter**. We will create an application that
    gets the latest tweets based on a user handle and shows them on the screen. Node.js
    will be responsible for the communication with the Twitter API, and Ember.js will
    take care of the user interface. The following is a short list of the topics that
    we will cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建一个命令行工具，用于将照片上传到 Flickr。在这一章中，我们将与最受欢迎的社交网络之一：**Twitter** 进行通信。我们将创建一个应用，根据用户名获取最新的推文并在屏幕上显示。Node.js
    将负责与 Twitter API 的通信，而 Ember.js 将负责用户界面。以下是本章我们将涵盖的一些主题的简要列表：
- en: Introduction to the Ember.js framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember.js 框架简介
- en: Communicating with Twitter's API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Twitter 的 API 通信
- en: Wiring Node.js with Ember.js to obtain tweets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Node.js 与 Ember.js 连接以获取推文
- en: Preparing the application
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用
- en: 'We have worked on applications in the previous chapters. For this application,
    we need a Node.js server, which will deliver the necessary HTML, CSS, and JavaScript
    code. The following is the `package.json` file, which we are starting from:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面几章中已经讨论了应用。对于这个应用，我们需要一个 Node.js 服务器，它将提供必要的 HTML、CSS 和 JavaScript 代码。以下是我们从它开始的
    `package.json` 文件：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There is only one dependency and that's the module that will connect to Twitter.
    After you run `npm install` in the same folder as the `package.json` file, the
    module will appear in the newly created `node_modules` directory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个依赖项，那就是将连接到 Twitter 的模块。在 `package.json` 文件所在的同一文件夹中运行 `npm install` 后，该模块将出现在新创建的
    `node_modules` 目录中。
- en: 'The next step is to create the folders for the HTML, CSS, and JavaScript and
    put the necessary files inside these folders. In addition, create the main `index.js`
    file that will contain the code of our Node.js server. At the end, our project
    directory should look like the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 HTML、CSS 和 JavaScript 的文件夹，并将必要的文件放入这些文件夹中。此外，创建包含我们的 Node.js 服务器代码的
    `index.js` 主文件。最后，我们的项目目录应该看起来像以下图示：
- en: '![Preparing the application](img/00021.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![准备应用](img/00021.jpeg)'
- en: 'The CSS styles of the project will go to `css/styles.css`. The templates will
    be placed in the `html/page`. html file and the custom JavaScript code will be
    written to `js/scripts.js`. The other `.js` files are Ember.js itself and its
    two dependencies: jQuery and Handlebars.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的 CSS 样式将存放在 `css/styles.css` 中。模板将放置在 `html/page` html 文件中，自定义 JavaScript
    代码将编写在 `js/scripts.js` 中。其他的 `.js` 文件是 Ember.js 本身及其两个依赖：jQuery 和 Handlebars。
- en: Running the server and delivering the assets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务器并交付资源
- en: 'In [Chapter 5](part0042_split_000.html#page "Chapter 5. Creating a To-do Application
    with Backbone.js"), *Creating a To-Do Application with Backbone.js*, we built
    an application with Backbone.js, and we used two helper functions: `serveAssets`
    and `respond`. The purpose of these functions was to read our HTML, CSS, and JavaScript
    files and send them as a response to the browser. We will use them again here.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](part0042_split_000.html#page "第 5 章. 使用 Backbone.js 创建待办事项应用")，*使用
    Backbone.js 创建待办事项应用*中，我们使用 Backbone.js 创建了一个应用，并使用了两个辅助函数：`serveAssets` 和 `respond`。这些函数的目的是读取我们的
    HTML、CSS 和 JavaScript 文件，并将它们作为响应发送到浏览器。我们在这里将再次使用它们。
- en: 'Let''s first start by defining the global variables, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义全局变量，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `http` module provides methods to create and run the Node.js server, and
    the `fs` module is responsible for reading the files from the filesystem. We are
    going to listen on port 3000 and the `files` variable will cache the content of
    the read files. When `debug` is set to `true`, the assets will be read on every
    request. If it is `false`, their content will be fetched only the first time,
    but every future response will contain the same code. We are doing this because
    while we are developing the application, we don't want to stop and run our server
    just to see the changes in the HTML script. Reading the file on every request
    guarantees that we are seeing the latest version. However, this is considered
    as a bad practice when we run the application in a production environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`http`模块提供了创建和运行Node.js服务器的方法，而`fs`模块负责从文件系统中读取文件。我们将监听端口3000，`files`变量将缓存读取文件的文件内容。当`debug`设置为`true`时，资产将在每次请求时读取。如果它是`false`，其内容只会在第一次请求时获取，但未来的每个响应都将包含相同的代码。我们这样做是因为在我们开发应用程序时，我们不希望停止并运行我们的服务器只是为了看到HTML脚本的更改。每次请求时读取文件确保我们看到的都是最新版本。然而，当我们在生产环境中运行应用程序时，这被认为是一种不良做法。'
- en: 'Let''s continue and run the server using the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，使用以下代码运行服务器：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The callback function, which we passed to `http.createServer`, accepts two
    arguments: the `request` and `response` objects. The Node.js part of our application
    will be responsible for two things. The first one is to provide the necessary
    HTML, CSS, and JavaScript, and the second one is to fetch tweets from Twitter.
    So, we are checking whether the URL starts with `/tweets` and if it does, then
    we will process the request differently. Otherwise, `serveAssets` will be called
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`http.createServer`的回调函数接受两个参数：`request`和`response`对象。我们的Node.js应用程序部分将负责两件事。第一件事是提供必要的HTML、CSS和JavaScript，第二件事是从Twitter获取推文。因此，我们检查URL是否以`/tweets`开头，如果是，我们将以不同的方式处理请求。否则，将调用`serveAssets`，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this function, we are getting the requested file path, and we will read
    the file from the filesystem. Along with the content of the file, we will also
    get its extension, which is needed to set the response header properly. This is
    done in the `respond` method, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们正在获取请求的文件路径，并将从文件系统中读取文件。除了文件内容外，我们还将获取其扩展名，这是正确设置响应头所必需的。这一操作在`respond`方法中完成，如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is important because if we don't provide `Content-Type`, the browser may
    not interpret the response correctly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们如果不提供`Content-Type`，浏览器可能无法正确解释响应。
- en: And that's everything about the serving of the assets. Let's continue and get
    information from Twitter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于资产服务的所有内容就到这里了。让我们继续，从Twitter获取信息。
- en: Getting tweets based on a user handle
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据用户名获取推文
- en: 'Before we write the code that requests data from the Twitter''s API, we need
    to register a new Twitter application. First, we should open [https://dev.twitter.com](https://dev.twitter.com)/
    and log in with our Twitter **Name** and **Password**. After that, we need to
    load [https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new) and
    fill in the form. It should look like the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写从Twitter API请求数据的代码之前，我们需要注册一个新的Twitter应用程序。首先，我们应该打开[https://dev.twitter.com](https://dev.twitter.com/)并使用我们的Twitter**用户名**和**密码**登录。之后，我们需要加载[https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new)并填写表格。它应该看起来像下面的截图：
- en: '![Getting tweets based on a user handle](img/00022.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![根据用户名获取推文](img/00022.jpeg)'
- en: 'We can leave the **Callback URL** field empty. The **Website** field can have
    the address of our personal or company site. We should accept the terms and conditions
    present below the form, and click on **Create your Twitter application**. The
    next page, which we will see, should be similar to the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以留空**回调URL**字段。**网站**字段可以填写我们的个人或公司网站的地址。我们应该接受表格下面的条款和条件，并点击**创建Twitter应用程序**。我们接下来将看到的页面应该类似于下面的截图：
- en: '![Getting tweets based on a user handle](img/00023.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![根据用户名获取推文](img/00023.jpeg)'
- en: 'The information that we need is located in the third tab: **API Keys**. Once
    we click on it, Twitter will show us the **API key** and **API secret** fields,
    as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的信息位于第三个标签页：**API密钥**。一旦点击它，Twitter将显示**API密钥**和**API密钥**字段，如下面的截图所示：
- en: '![Getting tweets based on a user handle](img/00024.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![根据用户名获取推文](img/00024.jpeg)'
- en: 'Additionally, we will generate an access token and access secret by clicking
    on the **Create my access token** button. Normally, the data doesn''t show up
    immediately. So, we should wait a bit and refresh the page, if necessary. The
    resulted document should look like on the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将通过点击**创建我的访问令牌**按钮生成访问令牌和访问令牌密钥。通常，数据不会立即显示。因此，我们应该稍等片刻，并在必要时刷新页面。生成的文档应类似于以下截图：
- en: '![Getting tweets based on a user handle](img/00025.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![基于用户名称获取推文](img/00025.jpeg)'
- en: We will copy the **Access token** and **Access token secret** values. It's a
    good practice to keep such sensitive information out of the application's code
    because our program may be transferred from one place to another. Placing the
    data in an externally configured file will do the job in most cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制**访问令牌**和**访问令牌密钥**的值。将此类敏感信息从应用程序代码中移除是一个好习惯，因为我们的程序可能会从一个地方转移到另一个地方。将数据放置在外部配置文件中通常可以完成这项工作。
- en: 'Once we have these four strings, we are able to communicate with Twitter''s
    API. The following variables go at the top of our `index.js` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这四个字符串，我们就能与 Twitter 的 API 进行通信。以下变量位于我们的 `index.js` 文件顶部：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `T` variable is actually a Twitter client, which we will use to request
    the data. We left a place in our server to query the Twitter''s API. Let''s now
    put the necessary code in the `index.js` file, which can be seen as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 变量实际上是一个 Twitter 客户端，我们将用它来请求数据。我们在服务器上留了一个查询 Twitter API 的位置。现在，让我们将必要的代码放入
    `index.js` 文件中，如下所示：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The request that we need to perform is `http://localhost:3000/tweets/KrasimirTsonev`.
    The last part of the URL is the Twitter handle of the user. So, the `if` statement
    becomes `true` because the address starts with `/tweets/`. We extract the username
    in a variable called `handle`. After that, this variable is sent to the `statuses/user_timeline`
    resource of the Twitter's API. The result of the request is directly sent to the
    browser via a stringified JSON.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的请求是 `http://localhost:3000/tweets/KrasimirTsonev`。URL 的最后一部分是用户的 Twitter
    名称。因此，`if` 语句变为 `true`，因为地址以 `/tweets/` 开头。我们提取用户名到一个名为 `handle` 的变量中。之后，这个变量被发送到
    Twitter API 的 `statuses/user_timeline` 资源。请求的结果直接通过字符串化的 JSON 发送到浏览器。
- en: On a concluding note, the Node.js part of our project provides all the HTML,
    CSS, and JavaScript code. Along with that, it accepts a Twitter handle and returns
    the most recent tweets of the user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结的要点中，我们项目的 Node.js 部分提供了所有 HTML、CSS 和 JavaScript 代码。除此之外，它接受一个 Twitter 名称，并返回用户的最新推文。
- en: Discovering Ember.js
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现 Ember.js
- en: Ember.js is one of the most popular client-side JavaScript frameworks today.
    It has a great community and its features are well-documented. Ember.js gathers
    an increasing number of fans because of its architecture. The library uses the
    Model-View-Controller design pattern, which makes it easy to understand because
    that pattern is widely used in almost every programming language. It also collaborates
    well with the REST APIs (we are going to build such an API in [Chapter 11](part0078_split_000.html#page
    "Chapter 11. Writing a REST API"), *Writing a REST API*) and eliminates the task
    of writing the boilerplate code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 是当今最受欢迎的客户端 JavaScript 框架之一。它拥有庞大的社区，其功能得到了很好的文档记录。Ember.js 因其架构而聚集了越来越多的粉丝。该库使用模型-视图-控制器设计模式，这使得它易于理解，因为该模式几乎在所有编程语言中都被广泛使用。它还与
    REST API 协作良好（我们将在第 11 章[第 11 章。编写 REST API](part0078_split_000.html#page "第 11
    章。编写 REST API")中构建此类 API），并消除了编写样板代码的任务。
- en: Knowing the dependencies of Ember.js
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Ember.js 的依赖项
- en: 'The Ember.js framework has the following two dependencies:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 框架有以下两个依赖项：
- en: '**jQuery**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jQuery**'
- en: '**Handlebars**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Handlebars**'
- en: The first one is the most used JavaScript tool on the Web today. It provides
    methods to select and manipulate the `DOM` elements and a lot of helper functions
    such as `forEach` or `map`, which help us to work faster. The library also solves
    some **cross-browser** issues by providing only one API. Like, for example, if
    we want to attach an event listener to an element, we need to use `attachEvent`
    in Internet Explorer but `addEventListener` in the other browsers. The simple
    `.on` method is provided by jQuery, which wraps this functionality. It checks
    for the current browser and calls the correct function. Along with all these things,
    we are able to use the `.get` or `.post` functions, which perform AJAX requests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是目前 Web 上最常用的 JavaScript 工具。它提供了选择和操作 `DOM` 元素的方法，以及许多辅助函数，如 `forEach` 或
    `map`，这些可以帮助我们更快地工作。该库还通过提供一个单一的 API 解决了一些 **跨浏览器** 问题。例如，如果我们想要向一个元素附加事件监听器，我们需要在
    Internet Explorer 中使用 `attachEvent`，而在其他浏览器中使用 `addEventListener`。jQuery 提供了一个简单的
    `.on` 方法，它封装了这个功能。它会检查当前浏览器并调用正确的函数。除此之外，我们还可以使用 `.get` 或 `.post` 函数，这些函数执行 AJAX
    请求。
- en: '**Handlebars** is a template engine library. It extends the HTML syntax by
    adding expressions and custom tags. It''s similar to **Jade**, another template
    language which we used in [Chapter 2](part0023_split_000.html#page "Chapter 2. Developing
    a Basic Site with Node.js and Express"), *Developing a Basic Site with Node.js
    and Express*. The difference is that this time we will use templates at the client-side
    part of the application. For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Handlebars** 是一个模板引擎库。它通过添加表达式和自定义标签扩展了 HTML 语法。它与我们在 [第 2 章](part0023_split_000.html#page
    "第 2 章。使用 Node.js 和 Express 开发基本网站") 中使用的另一个模板语言 **Jade** 类似，*使用 Node.js 和 Express
    开发基本网站*。不同之处在于这次我们将使用应用程序客户端部分的模板。例如：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This a template definition that Handlebar uses. It''s defined in a `<script>`
    tag because the content inside is ignored by the browser, and it is not rendered
    as a part of the `DOM` tree. There is one expression: `{{name}}`. Normally, the
    template is populated with information and such parts of the markup are replaced
    with the actual data. What a handlebar does is that it gets the value of the `script`
    tag. Then, it will parse it. The expressions found are executed and the result
    is returned to the developer.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Handlebar 使用的模板定义。它定义在一个 `<script>` 标签中，因为浏览器会忽略其中的内容，并且它不会被渲染为 `DOM` 树的一部分。其中有一个表达式：`{{name}}`。通常，模板会填充信息，并将这些标记部分替换为实际数据。Handlebar
    所做的是获取 `script` 标签的值。然后，它将解析它。找到的表达式将被执行，并将结果返回给开发者。
- en: Understanding Ember.js
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Ember.js
- en: Before we continue with the actual coding of our small application, we will
    go through the most important components of Ember.js.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编写我们的小型应用程序的实际代码之前，我们将学习 Ember.js 中最重要的组件。
- en: Exploring classes and objects in Ember.js
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Ember.js 中的类和对象
- en: 'Like every framework, Ember.js has predefined objects and classes, which are
    at our disposal. In most cases, we will extend them and write only the custom
    logic, which is a part of your application. All the ready-to-use classes are under
    the `Ember` namespace. This means that whenever we want to use some part of the
    framework, we need to go through the `Ember.` notation. For example, in the class
    extending shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 和每个框架一样，Ember.js 有预定义的对象和类，这些都在我们的掌控之中。在大多数情况下，我们会扩展它们，并只编写应用程序的一部分自定义逻辑。所有可用的类都在
    `Ember` 命名空间下。这意味着每次我们想要使用框架的某个部分时，我们都需要通过 `Ember.` 语法。例如，在以下代码中展示的类扩展：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We defined a class called `Person`. It has two properties and only one function,
    which shows a message on the screen. Just after that, we created an instance of
    that class and called the method. The properties of a class in Ember.js are accessed
    via `.get` and `.set` methods. In the previous example, we were still able to
    use `this.firstname` instead of `this.get("firstname")`, but this is not exactly
    right. In the `.set` and `.get` methods, Ember.js does some calculations, which
    are necessary to implement features such as data binding and computed properties.
    If we access the variable directly, the library may not have the chance to do
    its job.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `Person` 的类。它有两个属性和一个仅显示屏幕上消息的功能。就在那之后，我们创建了该类的实例并调用了该方法。在 Ember.js
    中，类的属性通过 `.get` 和 `.set` 方法访问。在先前的例子中，我们仍然可以使用 `this.firstname` 而不是 `this.get("firstname")`，但这并不完全正确。在
    `.set` 和 `.get` 方法中，Ember.js 进行了一些必要的计算，以实现数据绑定和计算属性等特性。如果我们直接访问变量，库可能没有机会完成其工作。
- en: Computed properties
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'By definition, the **computed** **properties** are properties, which derive
    their value by executing a function. Let''s continue and use the previous example.
    Instead of concatenating both `firstname` and `lastname` every time, we will create
    a computed property `name`, which will return the needed string. We can see this
    in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，**计算属性**是属性，它们通过执行一个函数来获取其值。让我们继续使用之前的例子。而不是每次都连接 `firstname` 和 `lastname`，我们将创建一个计算属性
    `name`，它将返回所需的字符串。我们可以在以下代码中看到这一点：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will still access a property with the `.get` method, but this time its value
    is calculated by a function. This can be extremely helpful if we need to format
    our data before displaying it. It''s good to know that we can use computed properties
    to set a value. By default, they are read only, but we can transform them to accept
    and process data, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会使用 `.get` 方法访问一个属性，但这次它的值是由一个函数计算得出的。如果我们需要在显示之前格式化数据，这可能会非常有帮助。了解我们可以使用计算属性来设置值是很好的。默认情况下，它们是只读的，但我们可以将它们转换为接受和处理数据，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Router
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: The routing processes are more like extensions for the other client-side frameworks.
    However, in Ember.js, everything is built around them. The **Router** is a class,
    which translates the page's URL to a series of nested templates. Each of these
    templates is connected to a model that delivers the data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 路由过程更像是其他客户端框架的扩展。然而，在 Ember.js 中，所有内容都是围绕它们构建的。**路由器**是一个类，它将页面的 URL 转换为一系列嵌套模板。这些模板中的每一个都与一个提供数据的模型相连接。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can think about the Router as a starting point of our logic. Every route
    and resource has its own class and controller linked to it. The good news is that
    we don''t really need to define them because the framework does this for us. Very
    often, we will need to modify their implementation by setting some properties;
    however, in general, we are free to leave the default suggested versions. Once
    we start working with Ember.js, we will find out that there are a lot of classes
    that are automatically created. Sometimes, it is a bit difficult to follow them.
    There is a Google Chrome extension called **Ember Inspector**. It''s actually
    a new tab in the Developer Tools panel. The inspector can show us what is going
    on in our application. For example, the previous code produces the following result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将路由器视为我们逻辑的起点。每个路由和资源都有自己的类和控制器与之关联。好消息是，我们实际上并不需要定义它们，因为框架会为我们完成这项工作。我们经常需要通过设置一些属性来修改它们的实现；然而，通常情况下，我们可以自由地保留默认建议的版本。一旦我们开始使用
    Ember.js，我们会发现有很多类是自动创建的。有时，跟踪它们可能有点困难。有一个名为 **Ember Inspector** 的 Google Chrome
    扩展程序。它实际上是开发者工具面板中的一个新标签页。检查器可以显示我们的应用程序中正在发生的事情。例如，之前的代码产生了以下结果：
- en: '![Router](img/00026.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![路由器](img/00026.jpeg)'
- en: As we can see, there are several routes and controllers available. There is
    a default route for the application and for the main **post** resource. The extension
    is really helpful because it shows us the exact names of the classes. Ember.js
    has strict naming conventions, and we should be able to figure out the names by
    ourselves, but it is still a handy extension.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有几个路由和控制器可用。应用程序有一个默认路由，以及主 **帖子** 资源的路由。这个扩展程序非常有用，因为它显示了类的确切名称。Ember.js
    有严格的命名约定，我们应该能够自己找出这些名称，但这个扩展程序仍然很方便。
- en: 'If we want to put some logic in the controller of the comments section, then
    we should use the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在评论区的控制器中添加一些逻辑，那么我们应该使用以下代码：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We should remember that we are actually modifying the definition of the class.
    The instances of it are automatically created by the framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，我们实际上正在修改类的定义。框架会自动创建它的实例。
- en: Views and templates
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图和模板
- en: 'We already mentioned that Ember.js uses Handlebars for its templating purposes.
    A simple definition of a template looks like the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到 Ember.js 使用 Handlebars 来实现模板功能。一个简单的模板定义看起来像以下代码：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s a script tag along with the HTML markup. Every template has a `view`
    class associated with itself. Usually, the developers don''t extend the `view`
    class. It is used in cases where we need to heavily handle user events or create
    custom components. Under the hood, the `view` class translates the primitive browser
    events into events that mean something in the context of our application. For
    example, we may have the following template:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个脚本标签以及HTML标记。每个模板都有一个与其关联的`view`类。通常，开发者不会扩展`view`类。它在需要大量处理用户事件或创建自定义组件的情况下使用。在底层，`view`类将原始浏览器事件转换为在应用程序上下文中具有意义的事件。例如，我们可能有以下模板：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Its corresponding View instance is seen as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其对应的视图实例如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are handling the clicking of the text. By using the `.append` method, the
    view is added to the `<body>` element, but there is `.appendTo`, which can add
    our custom HTML to whichever `DOM` element we need.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理文本的点击事件。通过使用`.append`方法，视图被添加到`<body>`元素中，但还有`.appendTo`方法，可以将我们的自定义HTML添加到所需的任何`DOM`元素中。
- en: Models
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: Every route in Ember.js has an associated model, which is an object that stores
    the persistent state. We set our models in the route's class. There is a hook
    called `model`, which should return our data. Very often, we will get the application's
    data asynchronously. For such cases, we can return a JavaScript promise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js中的每个路由都有一个关联的模型，它是一个存储持久状态的对象。我们在路由的类中设置我们的模型。有一个名为`model`的钩子，它应该返回我们的数据。通常，我们将以异步方式获取应用程序的数据。对于此类情况，我们可以返回一个JavaScript承诺。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The template linked to a specific route renders its HTML based on the model.
    So, we are able to use expressions that represent properties from the result of
    that `.model` method. For example, see the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与特定路由链接的模板根据模型渲染其HTML。因此，我们可以使用表示`.model`方法结果的属性的表达式。例如，请看以下代码：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Controllers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'In the context of Ember.js, the **controllers** are classes that decorate your
    models with the display logic. Ideally, they will store the data that doesn''t
    need to be stored in a database. It''s only needed when the information needs
    to be displayed. As with the models, the framework defines a different controller
    class for every route. Let''s say that we are developing an online book store.
    We could have a route like the one in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ember.js的上下文中，**控制器**是装饰你的模型的显示逻辑的类。理想情况下，它们将存储不需要存储在数据库中的数据。只有在信息需要显示时才需要。与模型一样，框架为每个路由定义了一个不同的控制器类。假设我们正在开发一个在线书店。我们可以有一个类似于以下代码的路由：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have only one route, but three controllers are defined. We are able to see
    them by using the Google Chrome''s extension. Check out the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个路由，但定义了三个控制器。我们可以通过使用Google Chrome的扩展程序看到它们。查看以下屏幕截图：
- en: '![Controllers](img/00027.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![控制器](img/00027.jpeg)'
- en: In the `BooksRoute` class, we will define our model, and in `BooksController`,
    we will create computed properties to display the books in a better way. The controllers
    are also the place where we could process any events that come from the browser.
    Initially, such events are caught by the views, but if there is no defined `View`
    or there is no handler for the event, then that is passed to the controller.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BooksRoute`类中，我们将定义我们的模型，并在`BooksController`中创建计算属性以更好地显示书籍。控制器也是处理来自浏览器的事件的地方。最初，这些事件由视图捕获，但如果未定义`View`或没有事件处理程序，则将事件传递给控制器。
- en: These are the most important components of every Ember.js application. Now,
    let's continue to build our small project—a single-page app for getting messages
    from Twitter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是每个Ember.js应用程序最重要的组件。现在，让我们继续构建我们的小型项目——一个用于从Twitter获取消息的单页应用程序。
- en: Writing Ember.js
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Ember.js
- en: 'The client side of the project contains two screens. The first one displays
    an input field and a button where the user should type the Twitter handle. The
    second one shows the tweets. We can see this in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的客户端包含两个屏幕。第一个屏幕显示一个输入字段和一个按钮，用户应在其中输入Twitter用户名。第二个屏幕显示推文。我们可以在以下屏幕截图中看到这一点：
- en: '![Writing Ember.js](img/00028.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![编写Ember.js](img/00028.jpeg)'
- en: The left part of the image shows the first page and the right one shows the
    tweets of the user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的左侧显示第一页，右侧显示用户的推文。
- en: Defining the templates
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模板
- en: 'The html/page.html file is our main file and is the base of our application
    and will be the first page that the user sees. It contains the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`html/page.html` 文件是我们的主文件，是应用程序的基础，也将是用户看到的第一个页面。它包含以下代码：'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That''s the basic HTML markup that we are starting from. The dependencies of
    Ember.js are included along with the `js/scripts.js` file, which will contain
    our custom logic. The templates, which we will define afterwards, will be placed
    inside the `<body>` tag. The following template is the first one. It''s the main
    template of the application:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始的基本 HTML 标记。Ember.js 的依赖项包括 `js/scripts.js` 文件，该文件将包含我们的自定义逻辑。我们将在之后定义的模板将被放置在
    `<body>` 标签内。以下模板是第一个。它是应用程序的主模板：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have only one expression: `{{outlet}}`. That''s an Ember.js-specific expression
    and shows the framework where we want our subviews to be rendered. Note the name
    of the template: `social-feed`. We will use the same name during the definition
    of the routes.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个表达式：`{{outlet}}`。这是一个 Ember.js 特定的表达式，它告诉框架我们希望子视图在哪里渲染。注意模板的名称：`social-feed`。在定义路由时，我们将使用相同的名称。
- en: 'The HTML code that we will use for the first screen, the one with the input
    field, looks as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于第一个屏幕（包含输入字段）的 HTML 代码如下：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The name of the template is `social-feed/index`. With `/index`, we are saying
    that this is the default template of the route with the name `social-feed`. The
    `{{input}}` tag is an Ember.js helper, which is later transformed to an `<input>`
    element. The `type` and `placeholder` attributes have the same meaning as in the
    regular HTML. However, `value` here plays another role. Note that `value` is not
    wrapped in double quotes. That''s because the `handle` keyword is actually a property
    of the Route''s controller, and we have two-way data binding. There is another
    expression used: `{{action}}`, which accepts the name of a method, which is again
    part of the controller. It will respond to a user''s click event.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的名称是 `social-feed/index`。通过 `/index`，我们表示这是名为 `social-feed` 的路由的默认模板。`{{input}}`
    标签是 Ember.js 辅助函数，稍后将被转换为 `<input>` 元素。`type` 和 `placeholder` 属性与常规 HTML 中的含义相同。然而，这里的
    `value` 扮演着另一个角色。注意 `value` 没有被双引号包围。这是因为 `handle` 关键字实际上是路由控制器的属性，并且我们有两个向数据绑定。还使用了另一个表达式：`{{action}}`，它接受一个方法名，这个方法也是控制器的一部分。它将响应用户的点击事件。
- en: 'The latest template that we will define is the one that shows the tweets. We
    can see that template as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义的最新模板是显示推文的模板。我们可以如下看到该模板：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The`{{{formattedHandle}}}` helper will be replaced with a link to the user's
    profile on Twitter. There are three brackets because the value of `formatedHandle`
    will be in HTML. If we use only double brackets, handlebars will display the data
    as string and not as HTML markup. There is an`{{#each}}` helper used. That's how
    we will loop through the fetched tweets and display their content. And at the
    end, we will use the `{{#link-to}}` helper to generate a link to the first screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{{formattedHandle}}}` 辅助函数将被替换为链接到用户的 Twitter 个人资料。因为有三个括号，所以 `formatedHandle`
    的值将包含在 HTML 中。如果我们只使用双括号，handlebars 将显示数据作为字符串，而不是作为 HTML 标记。使用了 `{{#each}}` 辅助函数。这就是我们将遍历获取的推文并显示其内容的方式。最后，我们将使用
    `{{#link-to}}` 辅助函数生成链接到第一个屏幕。'
- en: Defining the routes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由
- en: 'Normally, the Ember.js applications start with creating a global namespace
    followed by defining the routes. `js/scripts.js` starts with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Ember.js 应用程序以创建全局命名空间开始，然后定义路由。`js/scripts.js` 以以下代码开始：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is one resource and one route created. The route responds on a URL that
    contains a dynamic segment. Let''s check the names of the controllers and templates
    in Ember.js Chrome extension. The following screenshot displays the exact created
    classes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个资源和一个路由。该路由对包含动态段的路由做出响应。让我们检查 Ember.js Chrome 扩展中的控制器和模板的名称。以下截图显示了创建的确切类：
- en: '![Defining the routes](img/00029.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![定义路由](img/00029.jpeg)'
- en: 'Ember.js defines several routes by default: `application`, `loading`, and `error`.
    The first one is the main project route. `LoadingRoute` and `ErrorRoute` can be
    used if we have asynchronous transition between two routes. These substates are
    very useful if we load the model data from an external resource and want to indicate
    the process somehow.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 默认定义了几个路由：`application`、`loading` 和 `error`。第一个是主项目路由。如果我们在两个路由之间有异步转换，可以使用
    `LoadingRoute` 和 `ErrorRoute`。如果我们从外部资源加载模型数据并想以某种方式指示这个过程，这些子状态非常有用。
- en: Handling the user input and moving to the second screen
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入并移动到第二个屏幕
- en: 'We need to define a controller for the `social-feed/index` template. It will
    transfer the user to the second screen if the button on the screen is clicked.
    Along with that, we will get the Twitter handle that is entered in the input element.
    We define a controller as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 `social-feed/index` 模板定义一个控制器。如果屏幕上的按钮被点击，它将把用户转移到第二个屏幕。除此之外，我们还将获取输入元素中输入的
    Twitter 句柄。我们定义控制器如下：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that we are clearing the value of the `handle` property—`this.set('handle',
    '')`. We are doing this because the user will later return to that view and will
    want to enter a new username. As an addition, we can extend the view that is responsible
    for that template, and we can bring the browser's focus to the field once the
    template is added to the DOM tree.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在清除 `handle` 属性的值——`this.set('handle', '')`。我们这样做是因为用户稍后将返回该视图并希望输入新的用户名。作为补充，我们可以扩展负责该模板的视图，并在模板添加到
    DOM 树后，将浏览器的焦点带到该字段。
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Displaying the tweets
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示推文
- en: 'We have a URL address that responds with a JSON-formatted list of tweets. There
    are corresponding controllers and route classes, which are defined by default
    from Ember.js. However, we need to set a model and get the handle from the browser''s
    address, so we will create our own classes. This can be seen as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个响应 JSON 格式推文列表的 URL 地址。存在相应的控制器和路由类，这些类默认由 Ember.js 定义。然而，我们需要设置一个模型并从浏览器的地址中获取句柄，因此我们将创建自己的类。这可以从以下内容中看到：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The dynamic segment from the URL comes to the Route's `model` function in the
    `params` argument. We will get the string and set it as a property of the class.
    Later, when we set up the controller, we are able to pass it along with the model.
    The `setupController` function is a hook, which is run during the route's initialization.
    As we said in the beginning of the chapter, the main role of the controller is
    to decorate the model. Ours does only one thing—it defines a computed property
    that prints the Twitter handle of the user in a `<a>` tag. The controller also
    extends `Ember.ArrayController`, which provides a way to publish a collection
    of objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: URL 的动态部分通过 `params` 参数传递到路由的 `model` 函数中。我们将获取字符串并将其设置为类的属性。稍后，当我们设置控制器时，我们能够将它与模型一起传递。`setupController`
    函数是一个钩子，它在路由初始化期间运行。正如我们在本章开头所说，控制器的主要作用是装饰模型。我们的控制器只做了一件事——定义一个计算属性，在 `<a>` 标签中打印用户的
    Twitter 句柄。控制器还扩展了 `Ember.ArrayController`，它提供了一种发布对象集合的方法。
- en: 'If we go back a few pages and check out the `social-feed/tweets` template,
    we will see that we can show the tweets with the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾几页并查看 `social-feed/tweets` 模板，我们会看到我们可以使用以下代码来显示推文：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Normally, we will use only `{{text}}` and not `{{formatTweet text}}`. What
    we did is used a custom-defined helper, which will format the text of the tweet.
    We need that because the tweet can contain URLs, and we want to transform them
    to valid HTML links. We can do that as part of the controller and define another
    computed property, but we will do it as a Handlebars helper. We can see it as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只会使用 `{{text}}` 而不是 `{{formatTweet text}}`。我们所做的是使用自定义定义的辅助函数，它将推文文本格式化。我们需要这样做，因为推文可能包含
    URL，我们希望将它们转换为有效的 HTML 链接。我们可以在控制器中这样做并定义另一个计算属性，但我们将它作为 Handlebars 辅助函数来做。我们可以如下看到：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using a regular expression to transform the URLs to the `<a>` tags.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用正则表达式将 URL 转换为 `<a>` 标签。
- en: With the latest lines of the code, our `js/script.js` file is finished, and
    we can use the application to fetch the latest tweets of any Twitter user.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最新代码行的完成，我们的 `js/script.js` 文件已经完成，我们可以使用该应用程序来获取任何 Twitter 用户的最新推文。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use Node.js with Ember.js. We successfully
    created a fully working application, which shows the messages posted on Twitter.
    Essential work was done by external modules, which again proves that the Node.js
    ecosystem is really flexible and provides everything we need to develop top-notch
    web applications. The modern client-side frameworks such as Ember.js, AngularJS,
    or Backbone.js are expected to receive JSON and Node.js is capable of delivering
    it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Node.js 与 Ember.js。我们成功创建了一个完全工作的应用程序，该应用程序显示了 Twitter 上发布的消息。外部模块完成了基本工作，这再次证明
    Node.js 生态系统确实非常灵活，并提供了我们开发一流网络应用程序所需的一切。现代客户端框架，如 Ember.js、AngularJS 或 Backbone.js，预计将接收
    JSON，而 Node.js 能够提供它。
- en: In the next chapter, we will find out how to use Node.js to optimize our project
    tasks and boost our coding performance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何使用Node.js来优化我们的项目任务并提升我们的编码性能。
