- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The setValue Wrapper – Entering Text and Dynamic Data Replacement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to adapt the functionality from the `click()` method
    in the earlier chapter and extend it to the `setValue()` method. In addition,
    the wrapper method introduces multiple approaches to clear the field before entering
    the data. This chapter shows you how to implement a dynamic data tag replacement
    as an enhancement. This is the focal point where data can be prevented from becoming
    stale. For example, a test might require a future or past date. Lastly, we will
    look at detecting a password field and masking it with the `setPassword()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `setValue` Wrapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalizing the element class description from plain English
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative ways to clear a field and enter data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically replacing `<Today>` tags with a date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking sensitive credential data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, some housekeeping is in order. In the last chapter, we introduced class
    switching for our button. We will do the same thing for our input fields and upcoming
    lists and text elements. While we can deduce the type of element being passed
    to the `getValidElement()` method, we can just as easily pass the type directly
    from the wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can optimize the code for speed by skipping the code that extracts
    the `element` class, by explicitly stating the element type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the explicit `field` string will not match the implicit string type
    of `//input`. To resolve this, we will add a method that will change generic descriptors
    such as `field` or `item` to a suitable class string such as `//input` and “`//li`”.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing the element type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is where we will write a method to normalize all the explicit strings.
    Here, `link` becomes `//a`, `button` becomes `//button`, and so on. Your framework
    can continue to expand with many other element types as needed. The following
    function, `normalizeElementType()`, will take a plain English description of the
    element and translate it into a common `xPath` equivalent. Note that `field` and
    `input` become the same class, while an empty class description becomes a locator
    for all elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of items of note in this function. The first is the pessimistic
    nature of the function, which assumes the locator string passed was empty or `null`.
    `elementText` is initialized to `//*` to return all the elements in the first
    line. This means we assume at some point that a value might get passed a string
    that is yet to be implemented – for example, `list`. For documentation, we output
    the name of the unknown string as a warning to the console log.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we change the element to match all values rather than stopping the test.
    We want the framework to try its best to get to the endpoint without incurring
    more maintenance time. However, it does give a warning that we should be as descriptive
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are now supporting unknown element types, we will add a generic
    locator to the `getValidElement()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we normalize text, we take common English descriptors and replace them
    with `xpath` element or CSS string locator equivalents. However, that’s not just
    applicable in the class. This same concept is leveraged in many attributes as
    well. Let’s take a moment to look at a link before we move on to input fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normalizing text can be seen in XPath locators to allow us to find elements
    that have embedded carriage returns and extraneous transient white space. In this
    example, the “Embedded Carriage Return” web page element has extra spaces and
    a carriage return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B19395_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that this xPath won’t work to recognize the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B19395_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, we can normalize the text with the `normalize-space()` node to remove
    carriage return `<br>` breaks and even stray white space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B19395_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have yet another tool in our utility belt, we can write locators
    that can find elements with extra spaces and line breaks, reducing the maintenance
    time should these be cleaned up by the developers. Let’s take this to the next
    level with input elements and the `setValue` method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the setValue() method wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We begin by adding a new wrapper to our `helpers` file that we will extend
    with several checks, before performing the intrinsic `setValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to begin to enhance the data population aspect of our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Is this trip really necessary?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to do is to check whether any of the following code must be
    executed at all. There is no reason to find and replace a state element with a
    valid one if we don’t have any text to enter. So, we will first check whether
    any data has been passed to be entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has three actions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the text is not null and not empty, the code continues to execute the rest
    of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the text was an empty string it returns `true`, meaning the test can continue.
    This is useful, as we might be populating an entire page, but not every field
    takes a value. We could be searching by any combination of last name, zip code,
    and state. This allows for a page method design that has every input field but
    only interacts with the elements that receive some data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A null value is a special situation. It’s a clue that something is amiss. As
    superheroes, we always want to collect clues to identify the usual suspect who
    is committing the crime. If the clue is in the form of a riddle, we might check
    with the local asylum to see whether the cell adorned with question marks still
    holds an inmate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, a NULL value usually shows that the value was returned from a
    query that found nothing. We send a warning to the console and return `false`
    as the status. Just like with an empty value, it skips the rest of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the input data confirmed, we will take a second step and add the ability
    to keep our data fresh.
  prefs: []
  type: TYPE_NORMAL
- en: Coal into diamonds – replacing dynamic data tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common task in test automation is to populate a field with the current
    date. Now, we don’t want to be changing the date every single day manually, so
    we want something dynamic that provides us with that functionality. If we’re clever,
    that functionality can return the current, past, or future date. Even the date
    format could be modified. This is where the techniques of embedded dynamic data
    tags come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic data tags are a way to keep data that changes at a regular cadence fresh.
    It might be the current day of the week, a unique order number that was created
    by a batch job that needs completion, or a future business date excluding weekends
    and holidays.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many applications that will be unique to each individual project.
    In this case, we will provide a simple example of the most common data replacement
    – replacing a tag name, `"Today is: <today>"`, with the current date (i.e., `"Today`
    `is 6/21/2023`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we won’t stop there. We will also offset the date by any amount of
    days for a future date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do it for a past date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to have the ability to change the formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic format of this `<today>` tag gets replaced with a past or future
    date, with the custom `replaceTags()` function. Next, we add the function that
    detects these tags in every string passed through `setValueAdv()`. This will handle
    all sorts of tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a bit of dark magic called a regular expression, which identifies strings
    encased in square brackets and extracts them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: This is the start delimiter for the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\<`: This matches the opening angle bracket, `<`, in the text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(.*?)`: This is a capturing group that matches any character (represented
    by the dot, `.` ) zero or more times (represented by `*?`) until it encounters
    the next character in the regular expression (in this case, the closing angle
    bracket >). `?` makes the `*` quantifier lazy, meaning it will match as few characters
    as possible to satisfy the regex pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\>`: This matches the closing angle bracket, `>`, in the text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: This is the end delimiter for the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible that multiple tags might need to be replaced in the string.
    So, we will loop through all of them. Tag identification is case-insensitive,
    meaning `<today>` and `<TODAY>` are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This `switch` statement matches the first part of the tag extension to multiple
    tags in the future. In this case, our first match will be a tag that starts with
    `<today` and splits out `+` or `-` with the following value to offset the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the `tag` string. Now, we split the date format, if it exists, to transform
    the date at the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another regular expression here extracts the days to offset the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/` : This is the start delimiter for the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[+-]` : This matches either the `+` or `-` character in the text. The square
    brackets denote a character class, which means that the regular expression will
    match any one of the characters inside the brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(\d+)`: This is a capturing group that matches one or more digits (represented
    by `\d`) in the text). The parentheses surrounding `\d+` capture the matched digits
    as a group. The `+` quantifier means that the regular expression will match one
    or more digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: This is the end delimiter for the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next action is to determine whether there is an offset by a number of days
    to a past or future date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we replace the tag in the string with a function that gets the current
    date offset and custom format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop continues until all the tags have been replaced. If any tags are
    discovered and replaced, the new text is output to the console for logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the ability to extract dynamic date tags, we need to process
    the offset date and formatting with the `getToday()` function. The default, today’s
    date, is empty, and the date format is `MM-dd-yyyy` if the format argument is
    blank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here is our super-secret serum. This code will produce the date based on the
    format passed in. Why write loads of code to support all date formats, from 2-digit
    or 4-digit years and `0` leading dates to a European format, when `Date.toLocalDateString`
    can do it all for us in just these few lines of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our dynamic date tag extractor and formatter are complete! The next trick is
    to populate it in a field. And, as you might guess, there is more than one way
    to do this – the slow way and the fast way.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting versus typing text into a field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may want to override the intrinsic `setValue()` command to populate a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that injecting a value into an element may not necessarily kick
    off any additional JavaScript code behind the element. This might also skip some
    formatting that the developers added when we inject the data. Alternatively, we
    could use `addValue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we might be appending text into a field that already has text. What we
    want is a function that will first clear the field, if populated, and then type
    just as a user would – letter by letter followed by the *Tab* key to move out
    of the field.
  prefs: []
  type: TYPE_NORMAL
- en: This can be accomplished in our framework in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: First, we set the focus on the element and sending keystrokes through the `browser.keys()`
    method. Second, we send keys to the element directly with its `AddValue()` method.
    This would be a backup approach being slightly slower. Regardless of the tool
    used, sometimes an element just does not receive the text correctly when entered
    at a high typing speed. So, the `AddValue` approach would be a backup to ensure
    fields get populated accurately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with the first approach, using the `browser.keys` method to send
    text to the element, with a focus on speed. This is carried out by setting focus
    on the element with a click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The element now has focus, and thanks to the highlight, we can see which element
    will take the input. We should check whether the field needs to be cleared.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the field is pre-populated for speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will clear the field if it has any pre-existing text. The basic way
    to do this is with the `clear()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way to clear the field can also be done by issuing a `Meta-a`
    command to select all the text. The selected text is cleared by sending the backspace
    ASCII key code from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will type the text passed to the wrapper into the field from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Faster is not always better. If you find the speed of WebdriverIO typing text
    is causing issues, you can control how quickly text is typed with this alternative
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the text is entered, the field can be activated by typing the *Tab* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'While the *Tab* key is universal to activate an element, sometimes the *Enter*
    key is needed instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: However, are we about to send our password to the console for everyone to see?
    It’s a bad day in the city when a supervillain is able to take the hero’s supercharged
    crime-fighting vehicle for a joyride. Let’s make that less likely to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the mask – SetValuePassword() to keep data secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Superheroes wear a mask to protect family and friends. In test automation,
    we need to protect our sensitive data such as passwords. In this method, we take
    the extra step to be sure our passwords are not displayed in the console and report
    output by replacing most of the string with asterisks (`Password" = "Pa****rd`).
    However, if the root cause of our issues is that a password expired, we might
    want to have a small clue. So, we need to mask just a part of our credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the original password and the value returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Detecting and masking passwords in your output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to detect a field that might be a password and then scrub
    the data that’s being passed to it. We’ll send the password to the field but output
    a scrubbed version of the data to our results. First, let’s get a scrubbed version
    of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will get the field element name and check whether it includes the
    `ssword` string pattern. This makes it likely that we will scrub any field that
    has the `password` or `Password` string. This is provided by a custom `getFieldName()`
    helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering, why not create a generic method called `getElementName()`
    to return the name of any element? The reason is that the properties and prioritizations
    can be different, depending on whether we are seeking an input field, a button,
    a list, or other elements. This allows us to optimize the code execution based
    on the element type.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve got all the custom-made parts, let’s put together our superpowered
    method. These methods will return a success value of `true` or `false`. We ensure
    that we have a valid element from the earlier chapter. We will replace tags such
    as the date with a future or past offset. We will detect whether the field is
    a password and mask our value output accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the masked credentials in our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of other features we could implement to customize the data input
    of our fields. We could use the same technique to inject SQL statements to always
    pull a valid order number for a search. Strings of random `Corporate Lorem Ipsum`
    filler words could be populated to check exact field length boundaries. Text with
    vulgar words could be tested to make sure they get flagged and notification emails
    are sent to test accounts. Take a few minutes to think about all the types of
    dynamic and special data that might be available to test against with an automated
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added all sorts of custom-made gadgets to our `setValueAdv()`
    method. This method delivers a result indicating the success or failure of `true`
    or `false`. We conducted a background check to ensure that we had a valid element.
    Our approach involved wielding the power of time travel by replacing date-related
    tags with the present, future, or past date offset. We also kept security in mind
    and made sure to mask our output value when the field in question was a likely
    credential input.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will supercharge the `Select()` method with lists and comboboxes.
  prefs: []
  type: TYPE_NORMAL
