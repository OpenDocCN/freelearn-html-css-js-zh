- en: Chapter 6. Views and Event Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed templates and controllers in the previous two chapters. We noted
    that controllers present models that templates render to users. We also learned
    that when users interact with applications, templates usually propagate these
    events back to controllers using action template helpers. In reality, these action
    expressions are views that delegate the events initially to controllers, and later
    to routes. Therefore, in this chapter, we will learn how to integrate views right
    into templates, especially when the following application needs arise:'
  prefs: []
  type: TYPE_NORMAL
- en: A section of the application requires sophisticated event management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a need to build reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application needs to integrate third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, by the end of this chapter, you should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a view instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage events in views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use built-in views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in the first chapter, we will rarely need to define views unless
    we really need a tight control over the DOM structure. In the next chapter, we
    will discuss how to use ember components that are a higher level construct of
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Defining views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Views in an application manage templates through data binding and delegation
    of user-initiated events. Just like controllers, a view class is defined from
    the base `Ember.View` class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of the preceding view can then be created by calling the view''s
    `create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can still create additional views from the already defined class, as illustrated
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, we already know that Ember.js classes can accept any number of mixins
    as shown in the preceding example. However, instances created with mixins always
    use the `createWithMixins` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a view's controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Views are usually backed by an instance of the corresponding controller. Once
    a view is inserted into the DOM, the corresponding controller can be accessed
    by the `controller` property, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a view's template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every view renders a template into the DOM. Views can be assigned the template
    to use in a number of ways. For example, let''s consider the following router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Ember.js will expect a defined `App.NewRoute` class for the new route as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Any visit to this route will use the following Ember.js objects, if defined:'
  prefs: []
  type: TYPE_NORMAL
- en: The `App.NewController` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Ember.TEMPLATES.new` template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App.NewView` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default behavior is where the name of the template dictates the view to
    use. If we wish to use a different template, say `Ember.TEMPLATES.form`, we will
    need to implement it in the `renderTemplates` hook of the route as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this route will use the `App.FormView` view class. The template
    used is usually included into the application as a script tag. For example, we
    can define the new template that will be used by an `App.NewView` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the previous template can still be accessed as `Ember.TEMPLATES.new`.
    Therefore, an alternative way to specify a view''s template is to pragmatically
    update its value with the desired compiled template, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In a production environment, it''s advised to compile these templates server
    side, and then bundle them up for performance reasons. We can still specify the
    template using the `templateName` property on the view class, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a view's element tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A view''s template is usually wrapped in a `div` element by default, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This element type can be altered using the `tagName` property of the `view`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will yield something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Updating a view's element class attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we learned that views are usually wrapped in a configurable
    DOM element. The element''s class attribute can also be specified statically using
    the view''s `classNames` array property. For example, a Twitter Bootstrap button
    can be created as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The element''s classes can also be altered dynamically using the view''s `classNameBindings`
    array property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This example yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These class names are dasherized as per the Ember.js naming conventions. Hence,
    the `btnWarning` property is mapped to the `btn-warning` class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to specify the class name to be used based on a given
    state. This is something we learned in [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `btn-warning` class will be added to the class
    attribute of the element, based on the view's `warn` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can add different classes depending on a certain state. For example,
    imagine we want to display different states of our Bootstrap button. This is possible
    with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, when the view controller''s `warn` property becomes
    `true`, the following will be yielded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, the other class will be used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By now, you will have noticed that the binding behavior is similar to the one
    we learned in [Chapter 4](part0044_split_000.html#page "Chapter 4. Writing Application
    Templates"), *Writing Application Templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Updating other views' element attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to class attributes, all other attributes of a view''s element
    can be altered dynamically. For example, let''s create a thumbnail view, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The attributes'' presence can be altered using bound Boolean properties. For
    example, we can disable a `save` button of a form if the corresponding input has
    not been filled, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the model''s `title` property is undefined, the view''s disabled property
    will come true. Hence, the view''s element will acquire the disabled attribute
    and vice versa. This example lets users submit the form only when it''s valid.
    Note that the defined view can be reimplemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows that any property, in this case, `modelIsValid`, can be
    used to provide the attribute to show or hide when the state changes, as long
    as it''s specified using the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inserting views into DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just learned that views have templates that they render into DOM. Applications
    that need to do this manually will need to utilize the view instance `appendTo`
    method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a jQuery query selector that we are already used to, as shown
    in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that only one matched element is used. Therefore, in the third example,
    the view will be inserted into the last `header` element found.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a convenience, views have an `append` method that can be used to insert
    the views directly into the body section of DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also want to remove a view from DOM using the `remove` method as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that a view is automatically removed from DOM if destroyed, as shown in
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inserting views into templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Views are hierarchical, and hence, they can be inserted into the templates
    of other views constituting the template hierarchy we discussed in [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*.
    For example, consider the following application template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, defined views are inserted into a desired template using the `view`
    expression. These `view` expressions can also be wrapped into block clauses, as
    shown in the following code. Additional views can then be inserted into these
    block expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Specifying view layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already learned that a view''s template is wrapped in an element, which
    is usually specified by the `tagName` property. In addition, this template can
    be wrapped by another template, as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying view layouts](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A template is marked as a layout by adding a `yield` expression, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `outlet` expression, the `yield` expression serves as the portion
    that the template being wrapped will be inserted into. We then specify this layout
    in the view as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose our `book` template is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that views with self-closing HTML elements cannot have
    layouts. These views include `<input>` and `<img>`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering event handlers in views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Views can register event handlers on events emitted from elements in their
    rendered templates, in addition to the use of the `action` template expressions.
    For example, let''s reuse an example from [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This example can easily be reimplemented as a view, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a custom button view that registers a click event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Every view manages only the events invoked from their templates. However, child
    views usually bubble events to parent views up to the root element up until the
    events get handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember.js supports the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Touch events | Keyboard events | Mouse events | Form events | HTML5 drag-and-drop
    events |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `touchStart` | `keyDown` | `mouseDown` | `submit` | `dragStart` |'
  prefs: []
  type: TYPE_TB
- en: '| `touchMove` | `keyUp` | `mouseUp` | `change` | `drag` |'
  prefs: []
  type: TYPE_TB
- en: '| `touchEnd` | `keyPress` | `contextMenu` | `focusIn` | `dragEnter` |'
  prefs: []
  type: TYPE_TB
- en: '| `touchCancel` |   | `click` | `focusOut` | `dragLeave` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `doubleClick` | `input` | `drop` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `mouseMove` |   | `dragEnd` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `focusIn` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `focusOut` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `mouseEnter` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `mouseLeave` |   |   |'
  prefs: []
  type: TYPE_TB
- en: Now is a good opportunity to try and write views that use some of these events.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting actions from views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already learned that views have a reference to the context controller via
    the `controller` property. A view can use the controller''s `send` method to delegate
    user-initiated events to the corresponding routes, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using built-in views (components)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](part0044_split_000.html#page "Chapter 4. Writing Application
    Templates"), *Writing Application Templates*, we promised to discuss the built-in
    views that Ember.js provides. Most of these are high-level views (components)
    from controls that guarantee painless design of forms.
  prefs: []
  type: TYPE_NORMAL
- en: Textfields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The textfield view is used to create a bound text input in a form. It''s usually
    created from the `Ember.TextField` class. We can subscribe to the input''s value
    changes by implementing the view''s `change` event handler, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like any other view, we can insert this view into a template as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a text input that updated the context controller's
    name property whenever its value changes. This is one of the many use cases of
    such views.
  prefs: []
  type: TYPE_NORMAL
- en: Textareas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A textarea is very similar to a textfield, both accept some additional attributes
    such as `rows` and `cols`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Select menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common form control is the select menu. Ember.js provides an `Ember.Select`
    class that can be used to create this control. For example, let''s create a select
    menu that prompts a user to choose their favorite fruit in this control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the user is presented with two fruits to select from.
    They are first prompted with a **Select a fruit** prompt that was passed during
    definition. The view''s `content` property is usually an array of the choices
    that should be displayed, and the `selection` property holds the selected choice.
    Often, these choices are usually objects rather than strings, as seen in the preceding
    example. Therefore, additional customization needs to be done using two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `optionLabelPath` property: This specifies the choice''s label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `optionValuePath` property: This specifies the value to be looked up for
    the selected choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the preceding example specified the fruit's name as the property
    to display and the ID as the property to determine the selection.
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checkboxes can also be implemented in the same way using the `Ember.Cechkbox`
    view class. These controls enable the user to select various choices from a given
    set, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The bound value of an instance of this view is usually a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: The container view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already learned that a view can be inserted into other views using the `view`
    template helper, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, we might want the parent view, in this case, `App.ContentView`,
    to be able to manually manage child views. `Ember.ContainerView` is an enumerable
    view that an application can pragmatically add or remove child views from, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'These child views are usually contained in the `childViews` property. You can,
    therefore, implement the preceding example as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that since container views house other views, they cannot
    have templates or layouts. Therefore, specified templates or layouts will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Other HTML form controls can be abstracted to achieve simpler views. Therefore,
    as an exercise, create an `Ember.Radios` view class that displays a set of HTML
    radio buttons. Note that the implementation will be very similar to that of `Ember.Select`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with third-party DOM manipulation libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many jQuery libraries primarily manipulate DOM in order to achieve a desired
    effect. We all know that you need to initialize these libraries only when DOM
    is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'jQuery is an Ember.js dependency, and it''s thus very easy to integrate such
    libraries into applications. Imagine we had a menu view that we wanted to apply
    to this plugin. Views have the `willInsertElement` and `didInsertElement` hooks
    that we can use to implement such needs, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `didInsertElement` hooks guarantee that the view has been inserted into
    DOM, and therefore, we might apply any plugin to it. Note that calling `this.$()`
    returns a jQuery element selector relative to the view. Also, note that we take
    care to call the `_super` method, as there can be parent implementations we cannot
    afford to lose. We also *schedule* this code to be run after the element is rendered
    into DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a later point in time, we might decide to remove the view from DOM. It will,
    therefore, be necessary that we remove any event that the plugin set up before
    removing the view. Ember.js provides the `willDestroy` hook that can be used to
    accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how views are defined and created as well as how
    they can be customized. We also learned how events in these views can be managed.
    Lastly, we explored the different components Ember.js provides and how third-party
    libraries such as jQuery plugins can be integrated into an application through
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end of this chapter marked the completion of the core concepts of Ember.js.
    In the next chapters, we''ll start building complete sample applications as we
    explore more features. You should, therefore, be well versed in the following
    Ember.js concepts and objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
