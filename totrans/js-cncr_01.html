<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Why JavaScript Concurrency?</h1></div></div></div><p>JavaScript<a id="id0" class="indexterm"/> is not a language associated with <a id="id1" class="indexterm"/>concurrency. In fact, it's frequently associated with the exact opposite—concurrency challenges. This has changed a lot over the past few years, especially with new language features in ES 2015. Promises <a id="id2" class="indexterm"/>have been used in JavaScript for many years; only now, they're a native type. Generators <a id="id3" class="indexterm"/>are another addition to the language that changes the way we think about concurrency in JavaScript. Web workers<a id="id4" class="indexterm"/> have been in browsers for several years, and yet, we don't see them used that often. Perhaps, it has less to do with workers and more about our understanding of the role that concurrency plays in our applications.</p><p>The aim of this chapter is to explore some general concurrency ideas, starting with what, exactly, concurrency is. If you don't have any sort of concurrent programming in your background, it's fine because this chapter is a perfect starting point for you. If you've done concurrent programming in the past using JavaScript or some other language, think of this chapter as a refresher, only with JavaScript as the context.</p><p>We'll wrap up this chapter with some overarching concurrency principles. These are valuable programming tools that we should keep in the back of our heads while writing concurrent code. Once we have learned to apply these principles, they'll tell us whether we're on the right track with our concurrency design, or that we need to take a step back and ask ourselves what we're really trying to achieve. These principles take a top-down approach to the design of our application. This means that they're applicable from the very start, even before we've started writing any code. Throughout the book, we'll be referring to these principles, so if you only read one section in this chapter, make sure it's <em>Concurrency principles</em> at the end.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Synchronous JavaScript</h1></div></div></div><p>Before we start conjuring large-scale<a id="id5" class="indexterm"/> concurrent JavaScript architectures, let's shift our attention to the good old synchronous JavaScript code that we're all familiar with. These are the blocks of JavaScript code that are called as the result of a click event, or run as the result of loading a webpage. Once they start, they don't stop. That is to say, they're <a id="id6" class="indexterm"/>
<strong>run-to-completion</strong>. We'll dig into run-to-completion a little more in the following chapter.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>We'll occasionally see the term <strong>synchronous</strong> and <strong>serial</strong> used interchangeably throughout the chapters. They're both referring to code statements that run one after another until there's nothing more to run.</p></div></div><p>Despite JavaScript <a id="id7" class="indexterm"/>being designed as a single-threaded, run-to-completion environment, the nature of the web complicates this. Think about the web browser, and all it's moving parts. There's the <strong>Document Object Model</strong> (<strong>DOM</strong>)<a id="id8" class="indexterm"/> for rendering user interfaces and <strong>XMLHttpRequest</strong> (<strong>XHR</strong>) <a id="id9" class="indexterm"/>objects for fetching remote data sources, to name a couple. Let's take a look at the synchronous nature of JavaScript and the asynchronous nature of the web.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Synchronicity is easy to understand</h2></div></div></div><p>When code is synchronous, it's <a id="id10" class="indexterm"/>easier to understand. It's easier to mentally map the instructions that we're seeing on the screen to sequential steps in our heads; do this, then do that; check this, if <code class="literal">true</code>, do that, and so on. This type of serial processing is easy enough to understand, because there aren't any surprises, assuming the code isn't completely horrible. Here's an example of how we might visualize a chunk of synchronous code:</p><div><img src="img/B05133_01_01.jpg" alt="Synchronicity is easy to understand"/></div><p>Concurrent programming, on the<a id="id11" class="indexterm"/> other hand, isn't so easy to grasp. This is because there's <a id="id12" class="indexterm"/>no linear logic for us to follow in our code editors. Instead, we constantly jump around, trying to map what this piece of code is doing relative to that piece of code. Time is an important factor with concurrent designs; it is something that goes against the brain's natural way of comprehending code. When we read code, we naturally execute it in our heads. This is how we figure out what it's doing. This approach falls apart when the actual execution doesn't line up with what's in our head. Normally, code reads like a book—concurrent code is like a book where the pages are numbered, but out of order. Let's take a look at some trivial pseudo JavaScript code:</p><div><pre class="programlisting">var collection = [ 'a', 'b', 'c', 'd' ];
var results = [];

for (let item of collection) {
    results.push(String.fromCharCode(item.charCodeAt(0)));
}
//    [ 'b', 'c', 'd', 'e' ]</pre></div><p>In traditional <a id="id13" class="indexterm"/>multi-threading environments, a thread<a id="id14" class="indexterm"/> is something that runs asynchronously <a id="id15" class="indexterm"/>with other threads. We use threads to take advantage of multiple CPUs found on most systems today, resulting in better performance. However, this comes at a cost because it forces us to rethink how our code is executed at runtime. It's no longer the usual step by step execution. This code could be running alongside other code in another CPU, or it could be competing with other threads for time on the same CPU.</p><p>A lot of simplicity goes away when we introduce concurrency to synchronous code—it's the code equivalent of <em>brain freeze</em>. This is why we write concurrent code: code that makes an upfront assumption of concurrency. We'll elaborate on this concept as we progress through the book. With JavaScript, it's important to assume a concurrent design, because that's the way the web works.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Asynchronous is inevitable</h2></div></div></div><p>The reason that <a id="id16" class="indexterm"/>concurrency in JavaScript is such an important idea is because the web is a concurrent place, both from a very high level and an implementation detail level. In other words, the web is concurrent because at any given point in time, there's oodles of data flowing over the miles of fiber, which encase the globe. It has to do with the applications themselves that are deployed to web browsers, and how the back-end servers handle the litany of requests for data.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Asynchronous browsers</h3></div></div></div><p>Let's take a closer look at the<a id="id17" class="indexterm"/> browser and the kinds of asynchronous actions found there. When a user loads a webpage, one of the first actions that the page will perform is to download and evaluate our JavaScript code that goes with the page. This in itself is an asynchronous action, because while our code downloads, the browser will continue doing other things, such as rendering page elements.</p><p>Another asynchronous data source that arrives over the network is the application data itself. Once our page has loaded and our JavaScript code starts running, we'll need to display some data for the user. This is actually one of the first things that our code will do so that the user has something to look at right away. Again, while we're waiting on this data to arrive, the JavaScript engine will move our code right along to it's next set of instructions. Here's a request for remote data that doesn't wait for the response before continuing on with executing code:</p><div><img src="img/B05133_01_02.jpg" alt="Asynchronous browsers"/></div><p>After the page elements <a id="id18" class="indexterm"/>have all been rendered and populated with data, the user starts interacting with our page. This means events are dispatched—clicking an element dispatches a click event. The DOM environment, where these events are dispatched from, is a sand-boxed environment. This means that within the browser, the DOM is a subsystem, separate from the JavaScript interpreter, which runs our code. This separation makes certain JavaScript concurrency scenarios especially difficult. We'll cover these in depth in the next chapter.</p><p>With all these sources of asynchronicity, it's no wonder that our pages can become bloated with special case handling to deal with the edge cases that inevitably pop up. Thinking asynchronously isn't natural, so this type of monkey-patching is the likely result of thinking synchronously. It's best to embrace the asynchronous nature of the web. After all, a synchronous web can lead to unbearable user experiences. Now, let's dig a little further into the types of <a id="id19" class="indexterm"/>concurrency we're likely to face in our JavaScript architectures.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Types of concurrency</h1></div></div></div><p>JavaScript is a run-to-completion language. There's no getting around it, despite any concurrency mechanisms that are thrown <a id="id20" class="indexterm"/>on top of it. In other words, our JavaScript code isn't going to yield control to another thread in the middle of an <code class="literal">if</code> statement. The reason this matters is so that we can pick a level of abstraction that makes sense in helping us think about JavaScript concurrency. Let's look at the two types of concurrent actions found in our<a id="id21" class="indexterm"/> JavaScript code.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Asynchronous actions</h2></div></div></div><p>A defining characteristic of<a id="id22" class="indexterm"/> asynchronous actions is that they do not block other actions that follow. Asynchronous actions don't necessarily mean <em>fire-and-forget</em>. Rather, when the part of the action we're waiting on completes, we run a callback function. This callback function falls out of sync with the rest of our code; hence, the term asynchronous.</p><p>In web front-ends, this generally means fetching data from a remote service. These fetching actions are relatively slow, because they have to traverse the network connection. It makes sense for these actions to be asynchronous, just because our code is waiting on some data to return so that it can fire a callback function, doesn't mean the user should have to sit around and wait too. Furthermore, it's unlikely that any screen that the user is currently looking at depends on only one remote resource. So, serially processing multiple remote fetch requests would have a detrimental effect on the user experience.</p><p>Here's a general idea of what asynchronous code looks like:</p><div><pre class="programlisting">var request = fetch('/foo');

request.addEventListener((response) =&gt; {
    // Do something with "response" now that it has arrived.
});

// Don't wait with the response, update the DOM immediately.
updateUI();</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>We're not limited to fetching remote data, as the single source of asynchronous actions. When we make network requests, these asynchronous control flows actually leave the browser. But what about asynchronous actions that are confined within the browser? Take the <code class="literal">setTimeout()</code> function as an example. It follows the same callback pattern that's used with network <a id="id23" class="indexterm"/>fetch requests. The function is passed a callback, which is executed at a later point. However, nothing ever leaves the browser. Instead, the action is queued behind any number of other actions. This is because asynchronous actions are still just one thread of control, executed by one CPU. This means that as our applications grow in size and complexity, we're faced with a concurrency scaling issue. But then, maybe asynchronous actions weren't meant to solve the single CPU problem.</p><p>Perhaps a better way to think about asynchronous actions performed on a single CPU is to picture a juggler. The juggler's brain is the CPU, coordinating his motor actions. The balls that get tossed around is the data our actions operate on. There's only two fundamental actions we care about—<em>toss</em> and <em>catch</em>:</p><div><img src="img/B05133_01_03.jpg" alt="Asynchronous actions"/></div><p>Since the juggler<a id="id24" class="indexterm"/> only has one brain, he can't possibly devote his mental capacity to perform more than one task at a time. However, the juggler is experienced and knows he doesn't need more than a tiny fraction of attention given to the toss or catch actions. Once the ball is in the air, he's free to return his attention to catching the ball that's about to land.</p><p>To anyone observing this juggler in action, it appears as though he's paying full attention to all six balls, when in reality, he's ignoring five of them at any point in time.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Parallel actions</h2></div></div></div><p>Like asynchronicity, parallelism allows control <a id="id25" class="indexterm"/>flow to continue without waiting on actions to complete. Unlike asynchronicity, parallelism depends on hardware. This is because we can't have two or more flows of control taking place in parallel on a single CPU. However, the main aspect that sets parallelism apart from asynchronicity is the rationale for using it. The two approaches to concurrency solve different problems, and both require different design principles.</p><p>At the end of the day, we want to perform actions in parallel that would otherwise be time prohibitive, if performed synchronously. Think about a user who is awaiting three expensive actions to complete. If each takes 10 seconds to complete (an eternity on a UX timescale), then this means the user will have to wait for 30 seconds. If we're able to perform these tasks in parallel, we can bring the aggregate wait time closer to 10 seconds. We get more for less, leading to a performant user interface.</p><p>None of this is free. Like <a id="id26" class="indexterm"/>asynchronous actions, parallel actions lead to callbacks as a communication mechanism. In general, designing for parallelism is hard, because in addition to communicating with worker threads, we have to worry about the task at hand, that is, what are we hoping to achieve by using worker threads? And how do we break down our problem into smaller actions? The following is a rough idea of what our code starts to look like when we introduce parallelism:</p><div><pre class="programlisting">var worker = new Worker('worker.js');
var myElement = document.getElementById('myElement');

worker.addEventListener('message', (e) =&gt; {
    myElement.textContent = 'Done working!';
});

myElement.addEventListener('click', (e) =&gt; {
    worker.postMessage('work');
});</pre></div><p>Don't worry about the mechanics of what's happening with this code, as they'll all be covered in depth later on. The takeaway is that as we throw workers into the mix, we add more callbacks to an environment that's already polluted with them. This is why we have to design for parallelism in our code, which is a major focus of this book, starting in <a class="link" href="ch05.html" title="Chapter 5. Working with Workers">Chapter 5</a>, <em>Working with Workers</em>.</p><p>Let's think about the juggler analogy from the preceding section. The toss and catch actions are performed asynchronously by the juggler; that is, he has only one brain/CPU. But suppose the environment around us is constantly changing. There's a growing audience for our juggling act and a single juggler can't possibly keep them all entertained:</p><div><img src="img/B05133_01_04.jpg" alt="Parallel actions"/></div><p>The solution is to introduce<a id="id27" class="indexterm"/> more jugglers to the act. This way we add more computing power capable, of performing multiple toss and catch actions in the same instant. This simply isn't possible with a single juggler running asynchronously.</p><p>We're not out of the woods yet, because we can't just have the newly-added jugglers stand in one place, and perform their act the same way our single juggler did. The audience is larger, more diverse, and needs to be entertained. The jugglers need to be able to handle different items. They need to move around on the floor so that the various sections of the audience are kept happy. They might even start juggling with each other. It's up to us to produce a design that's capable of orchestrating this juggling act.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>JavaScript concurrency principles: Parallelize, Synchronize, Conserve</h1></div></div></div><p>Now that we've been through the<a id="id28" class="indexterm"/> basics of what concurrency is, and its role in <a id="id29" class="indexterm"/>front-end web development, let's look at some fundamental concurrency principles of JavaScript development. These principles are merely tools that inform our design choices when we write concurrent JavaScript code.</p><p>When we apply these principles, they force us to step back and ask the appropriate questions before we move forward with implementation. In particular, they're the why and how questions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why are we implementing this concurrent design?</li><li class="listitem" style="list-style-type: disc">What do we hope to get out of it that we couldn't otherwise get out of a simpler synchronous approach?</li><li class="listitem" style="list-style-type: disc">How do we implement concurrency in a way that's unobtrusive to the features of our applications?</li></ul></div><p>Here's a reference visualization of each concurrency principle, feeding on one another during the development <a id="id30" class="indexterm"/>process. And with that, we'll turn our attention to each principle for further exploration:</p><div><img src="img/B05133_01_05.jpg" alt="JavaScript concurrency principles: Parallelize, Synchronize, Conserve"/></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Parallelize</h2></div></div></div><p>The <a id="id31" class="indexterm"/>parallelize principle means taking advantage of modern CPU capabilities to compute results in less time. This is now possible in any modern browser or NodeJS environment. In the browser, we can achieve true parallelism using web workers. In Node, we can achieve true parallelism by spawning new processes. Here's what the CPU looks like from the browser's perspective:</p><div><img src="img/B05133_01_06.jpg" alt="Parallelize"/></div><p>With the goal being more computations in less time, we must now ask <a id="id32" class="indexterm"/>ourselves why we want to do this? Besides the fact that raw performance is super cool in it's own right, there has to be some tangible impact for the user. This principle makes us look at our parallel code and ask—what does the user get out of this? The answer is that we can compute using larger data sets as input, and have a smaller opportunity of an unresponsive user experience due to long-running JavaScript.</p><p>It's important to scrutinize the tangible benefit of going parallel because when we do so, we add complexity to our code that wouldn't otherwise be there. So if the user sees the same result no matter what we do, the parallelize principle probably isn't applicable. On the other hand, if scalability is important and there's a strong possibility of growing data set sizes, the trade off of code simplicity for parallelism is probably worthwhile. Here's a checklist<a id="id33" class="indexterm"/> to follow when thinking about the parallelize principle:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does our application perform expensive computations against large data sets?</li><li class="listitem" style="list-style-type: disc">As our data sets grow in size, is there potential for processing bottlenecks that negatively impact the user experience?</li><li class="listitem" style="list-style-type: disc">Do our users currently experience bottlenecks in our application's performance?</li><li class="listitem" style="list-style-type: disc">How feasible is parallelism in our design, given other constraints? What are the trade-offs?</li><li class="listitem" style="list-style-type: disc">Do the <a id="id34" class="indexterm"/>benefits of our concurrency implementation outweigh the overhead costs, either in terms of user-perceived latency or in terms of code<a id="id35" class="indexterm"/> maintainability?</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Synchronize</h2></div></div></div><p>The synchronize<a id="id36" class="indexterm"/> principle is <a id="id37" class="indexterm"/>about the mechanisms used to coordinate concurrent actions and the abstractions of those mechanisms. Callback functions are a JavaScript notion with deep roots. It's the obvious tool of choice when we need to run some code, but we don't want to run it now. We want to run it when some condition becomes true. By and large, there's nothing inherently wrong with this approach. Used in isolation, the callback pattern is probably the most succinct, readable concurrency pattern that we can use. Callbacks fall apart when there are plenty them, and lots of dependencies between them.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>The Promise API</h3></div></div></div><p>The Promise API <a id="id38" class="indexterm"/>is the core JavaScript language construct, introduced in ECMAScript 6 to address the synchronization woes faced by every application on the planet. It's a simple API that actually makes use of callbacks (yes, we're fighting callbacks with callbacks). The aim of promises isn't to eliminate callbacks, it's to remove the unnecessary callbacks. Here's what a promise that's used to synchronize two network fetch calls looks like:</p><div><img src="img/B05133_01_07.jpg" alt="The Promise API"/></div><p>What's crucial about <a id="id39" class="indexterm"/>promises is that they're a generic synchronization mechanism. This means that they're not specifically made for network requests, web workers, or DOM events. We, the programmers, have to wrap our asynchronous actions with promises and resolve them as necessary. The reason why this is a good thing is because the callers that rely on the promise interface don't care about what's going on inside the promise. As the name implies, it's a promise to resolve a value at some point. This could be in 5 seconds or immediately. The data can come from a network resource or a web worker. The caller doesn't care, because it makes an assumption of concurrency, which means we can fulfill it any in way we like without breaking the application. Here's a modified version of the preceding diagram, which will give us a taste of what promises make possible:</p><div><img src="img/B05133_01_08.jpg" alt="The Promise API"/></div><p>When we learn to treat <a id="id40" class="indexterm"/>values as values at some point in the future, concurrent code is suddenly much more approachable. Promises, and similar mechanisms, can be used to synchronize just network requests, or just web worker events. But they're real power is using them to write concurrent applications, where concurrency is the default. Here's a checklist <a id="id41" class="indexterm"/>to reference when thinking about the synchronize principle:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does our application heavily rely on callback functions as a synchronization mechanism?</li><li class="listitem" style="list-style-type: disc">Do we often have to synchronize more than one asynchronous event such as network requests?</li><li class="listitem" style="list-style-type: disc">Do our callback functions contain more synchronization boilerplate code than application code?</li><li class="listitem" style="list-style-type: disc">What kind of assumptions does our code make about the concurrency mechanisms that drive asynchronous events?</li><li class="listitem" style="list-style-type: disc">If we had a <a id="id42" class="indexterm"/>magic <em>kill concurrency</em> button, would our application still behave as expected?</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Conserve</h2></div></div></div><p>The conserve<a id="id43" class="indexterm"/> principle is about saving on compute and <a id="id44" class="indexterm"/>memory resources. This is done by using lazy evaluation techniques. The name <em>lazy</em> stems from the idea that we don't actually compute a new value until we're sure we actually need it. Imagine an application component that renders page elements. We can pass this component the exact data that it needs to render. This means that several computations take place before the component actually needs it. It also means that the data that's used needs to be allocated into memory, so that we can pass it to the component. There's nothing wrong with this approach. In fact, it's the standard way to pass data around in our JavaScript components.</p><p>The alternative approach uses lazy evaluation to achieve the same result. Rather than computing the values to be rendered, then allocating them in a structure to be passed, we compute one item, and then render it. Think of this as a kind of cooperative multi-tasking, where the larger action is broken down into smaller tasks that pass the focus of control back and forth.</p><p>Here's an eager approach to compute data and pass it to the component that renders UI elements:</p><div><img src="img/B05133_01_09.jpg" alt="Conserve"/></div><p>There's two<a id="id45" class="indexterm"/> undesirable aspects to this approach. First, the <a id="id46" class="indexterm"/>transformation happens up-front, which could be a costly computation. What happens if the component is unable to render it for whatever reason—due to some constraint? Then we've performed this computation to transform data that wasn't needed. As a corollary, we've allocated a new data structure for the transformed data so that we could pass it to our component. This transient memory structure doesn't really serve any purpose, as it's garbage-collected immediately. Let's take a look at what the lazy approach might look like:</p><div><img src="img/B05133_01_10.jpg" alt="Conserve"/></div><p>Using the lazy <a id="id47" class="indexterm"/>approach, we're able to remove the expensive transform computation that happens up-front. Instead, we transform only one item at a time. We're also able to remove the up-front allocation of the transformed data structure. Instead, only the transformed item is passed into the component. Then, the component can ask for another item or stop. The conserve principle uses concurrency as a means to only compute what's needed and only allocate memory that's needed.</p><p>The following checklist <a id="id48" class="indexterm"/>will help us think about the conserve principle when writing concurrent code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Are we computing values that are never used?</li><li class="listitem" style="list-style-type: disc">Do we only allocate data structures as a means to pass them from one component to the next?</li><li class="listitem" style="list-style-type: disc">Do we chain-together data transformation actions?</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, we introduced some motivations for concurrency in JavaScript. While synchronous JavaScript is easy to maintain and understand, asynchronous JavaScript code is inevitable on the web. So it's important to make concurrency our default assumption when writing JavaScript applications.</p><p>There's two main types of concurrency we're interested in—asynchronous actions and parallel actions. Asynchronicity is about the time ordering of actions, which gives the impression that things are happening at the same time. Without this type of concurrency, the user experience would suffer greatly, because it would constantly be waiting on other actions to complete. Parallelism is another type of concurrency that solves a different type of problem, where we want to increase performance by computing results faster.</p><p>Finally, we looked at the three principles of concurrency in JavaScript programming. The parallelize principle is about leveraging the multi-core CPUs found in modern systems. The synchronize principle is about creating abstractions that enable us to write concurrent code, hiding the concurrency mechanisms from our feature code. The conserve principle uses lazy evaluation to only compute what is needed and to avoid unnecessary memory allocations.</p><p>In the next chapter, we'll turn our attention to the JavaScript execution environment. To be effective with JavaScript concurrency, we need a sound understanding of what's actually happening when our code is run.</p></div></body></html>