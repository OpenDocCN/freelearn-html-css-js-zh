- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Producing Functions – Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    we worked with some declarative code so that we could gain understandability and
    more compact, shorter code. In this chapter, we will go further toward **higher-order
    functions** (**HOFs**) and develop our own. We can roughly classify the results
    that we are going to get into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrapped functions**: These keep their original functionality while adding
    some kind of new feature. In this group, we can consider logging (adding log production
    capacity to any function), timing (producing time and performance data for a given
    function), and memoization of functions and promises (caching results to avoid
    future rework).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`once()` function (we covered this in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*), which changes the original function so that it only
    runs once; functions such as `not()` or `invert()`, which alter what the function
    returns; arity-related conversions, which produce a new function with a fixed
    number of parameters; and throttling and debouncing functions for performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other productions**: These provide new operations, turn functions into promises,
    allow enhanced search functions, decouple methods from objects, transform them
    into plain functions, and go the other way around, converting functions into methods.
    We shall leave a special case – *transducers* – for [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping functions – keeping behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll consider some HOFs that provide a wrapper around other
    functions to enhance them in some way but without altering their original objective.
    In terms of design patterns (which we’ll be revisiting in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*), we can also speak of **decorators**. This pattern
    is based on the concept of adding some behavior to an object (in our case, a function)
    without affecting other objects. The term decorator is also popular because of
    its usage in frameworks, such as Angular, or (in an experimental mode) for general
    programming in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for decorators
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are being considered for general adoption in JavaScript. Currently
    (as of December 2022), they are at Stage 3, Candidate level, so it may still be
    a while until they get to Stage 4 (Finished, meaning “officially adopted”). You
    can read more about the proposal for decorators at [tc39.github.io/proposal-decorators/](http://tc39.github.io/proposal-decorators/)
    and about the JavaScript adoption process, called TC39, at [tc39.es/process-document/](http://tc39.es/process-document/).
    See the *Questions* section in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204)*,
    Implementing Design Patterns,* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As for the term *wrapper*, it’s more important and pervasive than you might
    have thought; in fact, JavaScript uses it widely. Where? You already know that
    object properties and methods are accessed through dot notation. However, you
    also know that you can write code such as `myString.length` or `22.9.toPrecision(5)`,
    so where are those properties and methods coming from, given that neither strings
    nor numbers are objects? JavaScript actually creates a *wrapper object* around
    your primitive value. This object inherits all the methods that are appropriate
    to the wrapped value. As soon as the needed evaluation has been done, JavaScript
    throws away the just-created wrapper. We cannot do anything about these transient
    wrappers, but there is a concept we will come back to regarding a wrapper that
    allows methods to be called on things that are not of the appropriate type. This
    is an interesting idea; see [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, for more applications of that!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at three examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting timing information from functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using caching (*memoizing*) to improve the performance of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get to work!
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a common problem. When debugging code, you usually need to
    add some logging information to see whether a function was called, with what arguments,
    what it returned, and so on. (Yes, of course, you can simply use a debugger and
    set breakpoints, but bear with me for this example!) Working normally, this means
    that you’ll have to modify the code of the function itself, both at entry and
    on exit, to produce some logging output. For example, your original code could
    be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you would have to modify it to look like the following. Here,
    we need to add an `auxValue` variable to store the value that we want to log and
    return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the function can return at several places, you’ll have to modify all the
    `return` statements to log the values to be returned. And if you are just calculating
    the return expression on the fly, you’ll need an auxiliary variable to capture
    that value.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn about logging and some special cases, such
    as functions that throw exceptions, and we’ll work more purely.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in a functional way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logging by modifying your functions isn’t difficult, but modifying code is always
    dangerous and prone to accidents. So, let’s put our FP hats on and think of a
    new way of doing this. We have a function that performs some work, and we want
    to know the arguments it receives and the value it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can write an HOF that will have a single parameter – the original
    function – and return a new function that will do the following in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Log the received arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the original function, catching its returned value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log that value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return it to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A possible solution would be as follows, and let’s use plain JavaScript first
    to focus on the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returned by `addLogging()` behaves as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `console.log(...)` line shows the original function’s name and its
    list of arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the original function, `fn()`, is called, and the returned value is stored.
    The second `console.log(...)` line shows the function name (again) and its returned
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the value that `fn()` calculated is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A small comment: If you were doing this for a Node.js application, you would
    probably opt for a better way of logging than `console.log()` by using libraries
    such as *Winston*, *Morgan*, or *Bunyan*, depending on what you wanted to log.
    However, our focus is on how to wrap the original function, and the needed changes
    for using those libraries would be negligible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s turn to a TypeScript implementation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `addLogging()` function applies to a generic function `T` type and returns
    a new function of precisely the same type: its arguments (`Parameters<T>`) are
    those of `T`, and its result (`ReturnType<T>`) is also the same type as `T`’s.
    We will be using this kind of definition many times in this chapter and the rest
    of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have an example now. We can use `addLogging()` with the upcoming functions—which
    are written, I agree, in an overly complicated way, just to have an appropriate
    example! We’ll have a function that accomplishes subtraction by changing the sign
    of the second number and then adding it to the first. And, just to have an error
    case, we’ll have the function throw an error if we attempt to subtract zero. (Yes,
    of course, you can subtract zero from another number! But I wanted to have some
    kind of an error-throwing situation at any cost!) The following code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What’s that `@ts-expect-error` comment? TypeScript rejects the assignment in
    the following line, saying `Cannot assign to 'subtract' because it is a function.ts(2630)`.
    This prohibition keeps code safe, but since we are very sure that we won’t be
    changing the `subtract()` type, we can include the comment, and TypeScript will
    let us get away with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of executing this would be the following lines of logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All the changes we had to make in our code were the reassignments of `subtract()`
    and `changeSign()`, which essentially replaced them everywhere with their new
    log-producing wrapped versions. Any call to those two functions will produce this
    output.
  prefs: []
  type: TYPE_NORMAL
- en: This works fine for most functions, but what would happen if the wrapped function
    threw an exception? Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Taking exceptions into account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s enhance our logging function a bit by considering an adjustment. What
    happens to your log if the function throws an error? Fortunately, this is easy
    to solve. We have to add a `try`/`catch` structure, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, if the function threw an error, you’d also get an appropriate
    logging message, and the exception would be rethrown for processing. The following
    is a quick demo of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Other changes to get an even better logging output would be up to you – adding
    date and time data, enhancing the way parameters are listed, and so on. However,
    our implementation still has an important defect; let’s make it better and purer.
  prefs: []
  type: TYPE_NORMAL
- en: Working in a purer way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we wrote the `addLogging()` function, we ignored some precepts we saw
    in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, because
    we included an impure element (`console.log()`) in our code. With this, not only
    did we lose flexibility (would you be able to select an alternate way of logging?),
    but we also complicated our testing. We could manage to test it by spying on the
    `console.log()` method, but that isn’t very clean: we depend on knowing the internals
    of the function we want to test instead of doing a purely black-box test. Take
    a look at the following example for a clearer understanding of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Running this test shows that `addLogging()` behaves as expected, so this is
    a solution. Our first test just does a simple subtraction and verifies that logging
    was called with appropriate data. The second test checks that our (purposefully
    failing) `subtract()` function throws an error to also verify that the correct
    logs were produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even so, being able to test our function this way doesn’t solve the lack of
    flexibility we mentioned. We should pay attention to what we wrote in the *Injecting
    impure functions* section in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*,
    Behaving Properly*; the logging function should be passed as an argument to the
    wrapper function so that we can change it if we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don’t do anything, the logging wrapper will produce the same results
    as in the previous section. However, we could provide a different logger – for
    example, with Node.js, we could use the *winston* logging tool (see [github.com/winstonjs/winston](http://github.com/winstonjs/winston)
    for more on it), and the results would vary accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The log format is JSON by default. It’s more usual to route it to a file for
    storage, so it isn’t so clear as console output, but we could (if needed) reformat
    it more legibly. However, this suffices for our example, and we won’t do anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have followed our own advice, we can take advantage of stubs. The
    code for testing is practically the same as before; however, we are using a `dummy.logger()`
    stub with no provided functionality or side effects, so it’s safer all around.
    In this case, the real function that was being invoked originally, `console.log()`,
    can’t do any harm, but that’s not always the case, so using a stub is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding tests work exactly like the previous ones we wrote earlier (though,
    for variety, in the *Working in a purer way* section, we used `expect(…).toThrow()`,
    and here we used a `try`/`catch` structure to test error-throwing functions).
    We used and inspected the dummy logger instead of dealing with the original `console.log()`
    calls. Writing the test in this way avoids all possible problems due to side effects,
    so it’s much cleaner and safer.
  prefs: []
  type: TYPE_NORMAL
- en: When applying FP techniques, remember that if you are somehow complicating your
    job – for example, making it difficult to test any of your functions – then you
    must be doing something wrong. In our case, the mere fact that the output of `addLogging()`
    was an impure function should have raised the alarm. Of course, given the simplicity
    of the code, in this particular case, you might decide that it’s not worth a fix,
    that you can do without testing, and that you don’t need to be able to change
    the way logging is produced. However, long experience in software development
    suggests that, sooner or later, you’ll come to regret that sort of decision, so
    try to go with the cleaner solution instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have dealt with logging, we’ll look at another need: timing functions
    for performance reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: Timing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another possible application for wrapped functions is to record and log the
    timing of each function invocation in a fully transparent way. Simply put, we
    want to be able to tell how long a function call takes, most likely for performance
    studies. However, in the same way we dealt with logging, we don’t want to have
    to modify the original function and will use an HOF instead.
  prefs: []
  type: TYPE_NORMAL
- en: The three rules for optimization
  prefs: []
  type: TYPE_NORMAL
- en: 'If you plan to optimize your code, remember the following three rules: *Don’t
    do it*, *Don’t do it yet*, and *Don’t do it without measuring*. It has been mentioned
    that a lot of bad code arises from early attempts at optimization, so don’t start
    by trying to write optimal code, don’t try to optimize until you recognize the
    need for it, and don’t do it haphazardly without trying to determine the reasons
    for the slowdown by measuring all the parts of your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the lines of the preceding example, we can write an `addTiming()` function
    that, given any function, will produce a wrapped version that will write out timing
    data on the console but will otherwise work in exactly the same way. Data types
    are very much what we saw in the previous section, so let’s write TypeScript at
    once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Along the lines of the enhancement we applied in the previous section to the
    logging function, we are providing separate logger and time access functions.
    Writing tests for our `addTiming()` function should prove easy, given that we
    can inject both impure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how this works here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Accuracy matters
  prefs: []
  type: TYPE_NORMAL
- en: Using `performance.now()` provides the highest accuracy. If you don’t need such
    precision as what’s provided by that function (arguably, it is overkill), you
    could use `Date.now()` instead. For more on these alternatives, see [developer.mozilla.org/en-US/docs/Web/API/Performance/now](http://developer.mozilla.org/en-US/docs/Web/API/Performance/now)
    and [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now).
    Consider using `console.time()` and `console.timeEnd()`; see [developer.mozilla.org/en-US/docs/Web/API/Console/time](http://developer.mozilla.org/en-US/docs/Web/API/Console/time)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is quite similar to the previous `addLogging()` function,
    and that’s reasonable: in both cases, we add some code before the actual function
    call and then some new code after the function returns. You might even consider
    writing a *higher* HOF, which would receive three functions and produce a new
    HOF as output (such as `addLogging()` or `addTiming()`) that would call the first
    function at the beginning, and then the second function if the wrapped function
    returned a value, or the third function if an error had been thrown! How about
    that?'
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, we
    considered the case of the Fibonacci function and learned how we could transform
    it, by hand, into a much more efficient version using *memoization*: caching calculated
    values to avoid recalculations. A *memoized* function would avoid redoing a process
    if the result was found earlier. We want to be able to turn any function into
    a memoized one so that we can get a more optimized version. However, a real-life
    memoizing solution should also take into account the available RAM and have some
    ways of avoiding filling it up; however, this is beyond the scope of this book,
    and we won’t be looking into performance issues either; those optimizations are
    also beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Of frameworks and memos
  prefs: []
  type: TYPE_NORMAL
- en: Some memoizing functionality is provided by tools such as React (the `useMemo()`
    hook) or Vue (the `v-memo` directive), but it’s not really the same. In these
    cases, only the previous result is kept, and re-rendering is avoided if a value
    changes. With the kind of memoization we’re discussing, *all* previous values
    are cached for reuse; React and Vue cache just one value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, let’s only consider functions with a single, non-structured
    parameter and leave functions with more complex parameters (objects and arrays)
    or more than one parameter for later. The kind of values we can handle with ease
    are JavaScript’s primitive values: data that aren’t objects and have no methods.
    JavaScript has six of these: `boolean`, `null`, `number`, `string`, `symbol`,
    and `undefined`. Usually, we only see the first four as actual arguments. You
    can find out more by going to [developer.mozilla.org/en-US/docs/Glossary/Primitive](http://developer.mozilla.org/en-US/docs/Glossary/Primitive).'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not aiming to produce the best-ever memoizing solution, but let’s study
    the subject a bit and produce several variants of a memoizing HOF. First, we’ll
    deal with functions with a single parameter and then consider functions with several
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Simple memoization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will work with the Fibonacci function we mentioned previously, which is
    a simple case: it receives a single numeric parameter. This function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution we previously created was general in concept but not particularly
    good in its implementation: we had to directly modify the function’s code to take
    advantage of said memoization. Let’s look into how to do this automatically, in
    the same fashion as other wrapped functions. The solution would be a `memoize()`
    function that wraps any other function to apply memoization. For clarity, let’s
    work with JavaScript first and just for functions with a single numeric parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? The returned function, for any given argument, checks whether
    the argument was already received; that is, whether it can be found as a key in
    the cache object. (See *Question 6.2* for an alternative implementation of the
    cache.) If so, there’s no need for calculation, and the cached value is returned.
    Otherwise, we calculate the missing value and store it in the cache. (We use a
    closure to hide the cache from external access.) Here, we assume that the memoized
    function receives only one argument (`x`) and that it is a numeric value, which
    can then be directly used as a key value for the cache object; we’ll consider
    other cases later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to go to TypeScript; here’s the equivalent version of `memoize()`.
    The generic data typing is along the same lines as what we saw in the *Logging
    in a functional way* section, with the only difference being that now we work
    with functions that get a single numeric argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Is memoization working? We’ll have to time it – and we happen to have a useful
    `addTiming()` function for that! First, we time the original `fib()` function.
    We want to time the complete calculation and not each recursive call, so we write
    an auxiliary `testFib()` function, which is the one we’ll time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should repeat the timing operations and do an average, but since we just
    want to confirm that memoizing works, we’ll tolerate differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, your times will depend on your specific CPU, RAM, and so on. However,
    the results seem logical: the exponential growth we mentioned in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069),
    *Behaving Properly*, appears to be present, and times grow quickly. Now, let’s
    memoize `fib()`. We should get shorter times... shouldn’t we?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Something’s wrong! The times should have gone down, but they are just about
    the same. This is because of a common error, which I’ve even seen in some articles
    and web pages. We are timing `testMemoFib()`, but nobody calls that function except
    for timing, which only happens once! Internally, all recursive calls are to `fib()`,
    which isn’t memoized. If we called `testMemoFib(45)` again, *that* call would
    be cached, and it would return almost immediately, but that optimization doesn’t
    apply to the internal `fib()` calls. This is the reason why the calls for `testMemoFib(40)`
    and `testMemoFib(35)` weren’t optimized – when we did the calculation for `testMemoFib(45)`,
    that was the only value that got cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, when calculating `fib(45)`, all the intermediate Fibonacci values (from
    `fib(0)` to `fib(45)` itself) are stored, so the forthcoming calls have practically
    no work to do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to memoize single-argument functions, let’s look at functions
    with more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: More complex memoization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What can we do if we have to work with a function that receives two or more
    arguments, or can receive arrays or objects as arguments? Of course, like in the
    problem that we looked at in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*, about having a function do its job only once, we could
    simply ignore the question: if the function to be memoized is unary, we go through
    the memoization process; otherwise, we don’t do anything!'
  prefs: []
  type: TYPE_NORMAL
- en: On the length of functions
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of parameters of a function is called the function’s *arity,* or
    *valence*, and JavaScript provides it as the function’s `length` attribute; see
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length).
    You may speak in three different ways: you can say a function has arity one, two,
    three, and so on; you can say that a function is unary, binary, ternary, and so
    on; or you can say it’s monadic, dyadic, triadic, and so on. Take your pick!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first attempt could be just memoizing unary functions and leaving the rest
    alone, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Working more seriously, if we want to be able to memoize any function, we must
    find a way to generate cache keys. To do this, we must find a way to convert any
    argument into a string. We cannot use a non-primitive as a cache key directly.
    We could attempt to convert the value into a string with something such as `strX
    = String(x)`, but we''d have problems. With arrays, it seems this could work.
    However, take a look at the following three cases that involve different arrays
    but with a twist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These three cases produce the same result. If we were only considering a single
    array argument, we’d be able to make do, but when different arrays produce the
    same key, that’s a problem. Things become worse if we have to receive objects
    as arguments because the `String()` representation of any object is, invariably,
    `"[``object Object]"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest solution is to use `JSON.stringify()` to convert whatever arguments
    we have received into a useful, distinct string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For performance, our logic should be as follows: if the function we are memoizing
    receives a single argument that’s a primitive value, we can use that argument
    directly as a cache key. In other cases, we would use the result of `JSON.stringify()`
    that’s applied to the array of arguments. Our enhanced memoizing HOF could be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of universality, this is the safest version. If you are sure about
    the type of parameters in the function you will process, it’s arguable that our
    first version was faster. On the other hand, if you want to have easier-to-understand
    code, even at the cost of some wasted CPU cycles, you could go with a simpler
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Birth of a speeder
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn about the development of a top-performance memoizing function,
    read Caio Gondim’s *How I wrote the world’s fastest JavaScript memoization library*
    article, available online at [blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/](https://blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have achieved several interesting memoizing functions, but how will
    we write tests for them? Let’s analyze this problem now.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing the memoization HOF poses an interesting problem – how would you go
    about it? The first idea would be to look into the cache, but that’s private and
    not visible. Then, of course, we could change `memoize()` so that it uses a global
    cache or somehow allows external access to the cache, but doing that sort of internal
    exam is frowned upon: you should try to do your tests based on external properties
    only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accepting that we shouldn’t try to examine the cache, we could go for a time
    control: calling a function such as `fib(n)` for a large value of `n` should take
    longer if the function isn’t memoized. This is certainly possible, but it’s also
    prone to possible failures: something external to your tests could run at just
    the wrong time, and it could be possible that your memoized run would take longer
    than the original one. Okay, it’s possible, but not probable – but your test isn’t
    entirely reliable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could think about calculating some Fibonacci numbers and testing how many
    times the function was called – once directly and all the other times because
    of recursion. (See *Question 6.3* for more on this.) The preceding code is fairly
    straightforward: we are using the Fibonacci function we developed earlier and
    testing that it produces correct values. For instance, we can find out that calculating
    `fib(6)` requires 25 calls by revisiting the diagram we looked at in [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, and seeing that there
    are 25 nodes (each one representing a call to `fib()`) in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – 25 calls are needed for calculating ﬁb(6)](img/Figure_4.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – 25 calls are needed for calculating ﬁb(6)
  prefs: []
  type: TYPE_NORMAL
- en: The first idea would be counting calls, as shown here – but it won’t work!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We first calculate `fib(6)` – which correctly returns `8` – and then we check
    that there should have been 25 calls to `fib()`, but only one was found; what’s
    going on? The problem is in Jest: when you spy on a function, you are actually
    spying on a wrapper that calls the function you want to check. *This* wrapper
    function is called only once; our `fib()` function was called 25 times, but Jest
    doesn’t see that!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll have to do something else in a very non-functional way! Let’s test a
    modified `fib()` function that will update an external counter; we’ll call it
    `fibM()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the test works out, how about testing the memoized, modified version
    instead? In this case, the count of calls should be lower because of cached results.
    In fact, it should just be `7` because we’ll need all values from `fib(6)` down
    to `fib(0)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve dealt with several examples that implied wrapping functions
    so that they keep working but with some extra features added in. Now, let’s look
    at a different case where we want to change how a function works.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s go a bit further and consider memoizing `async` functions, which return
    promises. In a complex web application with many related components, it may very
    well be the case that redundant, repeated API calls go out for no good reason,
    harming performance and producing a bad user experience. Imagine, for instance,
    a dashboard-style web page with several tabs. Whenever a user selects a tab, several
    API calls go out to get the data that the page needs. However, if the user selects
    a different tab but later returns to the first one, the very same API calls will
    go out again. For many applications, data is basically constant, meaning “not
    changing in real time.” You don’t then need to re-send API calls; re-using previously
    fetched data also works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some solutions are not practical: we could modify the server to enable caching,
    but what if that’s not possible? Or we could work with a cache, checking before
    every call whether that data was already fetched, but that would entail hand-modifying
    every single API call to check the cache first! We want a solution that requires
    no code changes, and memoizing comes to mind.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we call the API with an `async` function that returns a promise. Given
    the `memoize()` function we developed, we could memoize the `async` function,
    and it would be a start. The first time you call the function with some arguments,
    the API call will go out, and a promise will be returned (since that’s what the
    function returns). If you call the function again with the same arguments, the
    memoized promise will be immediately returned. Great! Except there’s a catch…
    what would happen if the API call failed? We need to add some error-catching logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All logic is as before, with a couple of additional details:'
  prefs: []
  type: TYPE_NORMAL
- en: We are now making explicit that the memoized function returns a promise (`Promise<A>`)
    of some generic type `A`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the promise is rejected, we add code to delete the cached promise, so a future
    call will go out again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our new `promiseMemoize()` function can deal with errors, allowing future retries
    of rejected calls; good! Now let’s look at a different case, where we want to
    change the way a function actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Altering a function’s behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we considered some ways of wrapping functions so that
    they maintain their original functionality, even though they’ve been enhanced
    in some way. Now, we’ll turn to modifying what the functions do so that the new
    results will differ from their original ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the problem of having a function work, but just once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negating or inverting a function’s result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the arity of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling and debouncing functions for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Doing things once, revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we went through an example of developing an FP-style solution for a simple problem:
    fixing things so that a given function works only once. We defined `once()` with
    an arrow function then; let’s go with a standard function for variety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a perfectly acceptable solution; it works well, and we have nothing
    to object to. We can, however, think of a variation. We could observe that the
    given function gets called once, but its return value gets lost. This is easy
    to fix: we need to add a `return` statement. However, that wouldn’t be enough;
    what would the function return if it’s called more than once? We can take a page
    from the memoizing solution and store the function’s return value for future calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s store the function’s value in a `result` variable so that we can return
    it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first time the function gets called, its value is stored in `result`; further
    calls just return that value with no further process. You could also think of
    making the function work only once but for each set of arguments. You wouldn’t
    have to do any work for that – `memoize()` would be enough!
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the *Producing an even better solution* section of [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*, we considered a possible alternative to `once()`: another
    HOF that took two functions as parameters and allowed the first function to be
    called only once, calling the second function from that point on. Adding a `return`
    statement to the previous code and rewriting it as a standard function would result
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite this if we remember that functions are first-order objects.
    Instead of using a flag to remember which function to call, we can use a `toCall`
    variable to directly store whichever function needs to be called. Logically, that
    variable will be initialized to the first function but will then change to the
    second one. The following code implements that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toCall` variable is initialized with `f`, so `f()` will get called the
    first time, but then `toCall` gets the `g` value, implying that all future calls
    will execute `g()` instead. The very same example we looked at earlier in this
    book would still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In terms of performance, the difference may be negligible. The reason for showing
    this further variation is to show that you should keep in mind that, by storing
    functions, you can often produce results more simply. Using flags to store state
    is a common technique in procedural programming. However, here, we manage to skip
    that usage and produce the same result. Now, let’s look at some new examples of
    wrapping functions to change their behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Logically negating a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s consider the `filter()` method from [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*. Given a predicate, we can filter the array to only
    include those elements for which the predicate is true. But how would you do a
    reverse filter and exclude the elements for which the predicate is true?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first solution should be pretty obvious: rework the predicate to return
    the opposite of whatever it originally returned. In the mentioned chapter, we
    looked at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: (For the `serviceResult` object, see the *A filter() example* section in the
    previous chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we could write it the other way round, in either of these equivalent fashions.
    Note the different ways of writing the same predicate to test for non-negative
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s perfectly fine, but we could also have had something like the following
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, rewriting the original `isNegativeBalance()` function isn’t possible.
    (Another possibility: the function could be defined in a separate module, which
    you can’t or shouldn’t modify.) However, working in a functional way, we can write
    an HOF that will take any predicate, evaluate it, and then negate its result.
    A possible implementation would be pretty straightforward, thanks to modern JavaScript
    syntax – and for the TypeScript version, check *Question 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Working in this way, we could have rewritten the preceding filter as follows;
    to test for non-negative balances, we use the original `isNegativeBalance()` function,
    which is negated via our `not()` HOF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an additional solution we might want to try out. Instead of reversing
    the condition (as we did), we could write a new filtering method (possibly `filterNot()`?)
    that would work in the opposite way to `filter()`. The following code shows how
    this new function would be written. Given an `arr` array of values and an `fn`
    predicate, we’d have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This solution doesn’t fully match `filter()` since you cannot use it as a method,
    but we could either add it to `Array.prototype` or apply some methods. We’ll look
    at these ideas in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting
    Functions*. However, it’s more interesting to note that we used the negated function,
    so `not()` is necessary for both solutions to the reverse filtering problem. In
    the upcoming *Demethodizing – turning methods into functions* section, we will
    see that we have yet another solution since we can decouple methods such as `filter()`
    from the objects they apply to, thereby changing them into common functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for negating the function versus using a new `filterNot()` function, even
    though both possibilities are equally valid, I think using `not()` is clearer.
    If you already understand how filtering works, then you can practically read the
    code aloud, and it will be understandable: we want those accounts that don’t have
    a negative balance, right? Now, let’s consider a related problem: inverting the
    results of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: Inverting the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same vein as the preceding filtering problem, let’s revisit the sorting
    problem from the *Injection – sorting it out* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*,
    Starting Out with Functions*. Here, we wanted to sort an array with a specific
    method. Therefore, we used `sort()`, providing it with a `comparison` function
    that basically pointed out which of the two strings should go first. To refresh
    your memory, given two strings, the function should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a negative number if the first string should precede the second one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `0` if the strings are the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a positive number if the first string should follow the second one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go back to the code we looked at for sorting in Spanish. We had to write
    a specialized `comparison` function so that sorting would take into account the
    character-ordering rules from Spanish, such as placing the letter *ñ* between
    *n* and *o*, and more. The code for this was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are facing a similar problem: how can we sort in descending order? Given
    what we saw in the previous section, some options should immediately come to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort into ascending order, and afterward reverse the array. While this solves
    the problem, we still only sort into ascending order, and we would want to avoid
    the extra reversing step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a function that will invert the result from the comparing function. This
    will invert the result of all the decisions as to which string should precede,
    and the final result will be an array sorted in exactly the opposite way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `sortDescending()` function or method that does its work in the opposite
    fashion to `sort()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s opt for the second option and write an `invert()` function that will
    change the comparison result. The code itself is quite similar to that of `not()`.
    Again, check *Question 6.5* for the TypeScript equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this HOF, we can sort in descending order by providing a suitably inverted
    `comparison` function. Take a look at the last few lines, where we use `invert()`
    to change the result of the sorting comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as expected: when we `invert()` the `comparison` function, the
    results are in the opposite order. Writing unit tests would be quite easy, given
    that we already have some test cases with their expected results, wouldn’t it?'
  prefs: []
  type: TYPE_NORMAL
- en: Arity changing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the *Parsing numbers tacitly* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, we saw that using `parseInt()` with `reduce()` produces
    problems because of the unexpected arity of that function, which took more than
    one argument—remember the example from earlier?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We have more than one way to solve this. In the mentioned chapter, we went
    with an arrow function. This was a simple solution, with the added advantage of
    being clear to understand. In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*, we will look at yet another, based on partial application.
    For now, let’s go with an HOF We need a function that will take another function
    as a parameter and turn it into a unary function. Using JavaScript’s spread operator
    and an arrow function, this is easy to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the example in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our `unary()` function works with a generic `T` function. It produces a new
    function with just a single argument (the first one, `Parameters<T>[0]`) that
    returns the same type of result (`ReturnType<T>`) as the original function does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this function, our number parsing problem goes away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It goes without saying that it would be equally simple to define further `binary()`
    or `ternary()`functions, and others that would turn any function into an equivalent
    but restricted-arity version. Let’s not go overboard and just look at a couple
    of all the possible functions – see *Question 6.10* for more on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but spelling out all the parameters can become tiresome. We can
    even go one better by using array operations and spreading and make a generic
    function to deal with all of these cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With this generic `arity()` function, we can give alternative definitions for
    `unary()`, `binary()`, and so on. We could even rewrite the earlier functions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You may think that there aren’t many cases in which you would want to apply
    this kind of solution, but there are many more than you would expect. Going through
    all of JavaScript’s functions and methods, you can quickly produce a list starting
    with `apply()`, `assign()`, `bind()`, `concat()`, `copyWithin()`, and many more!
    If you wanted to use any of those in a tacit way, you would probably need to fix
    their arity so that they would work with a fixed, non-variable number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Everything under the sun
  prefs: []
  type: TYPE_NORMAL
- en: If you want a nice list of JavaScript functions and methods, check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index).
    As for tacit programming (or pointfree style), we’ll return to it in [*Chapter
    8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a problem with TypeScript, though. TypeScript deals with static
    typing, but the type of the result of a call to `arity()` is determined at runtime.
    The most we may manage is, by a series of overloads, to say that given a function
    with several parameters, the result of applying `arity()` to it will have zero,
    one, two, and so on different possibilities – but we won’t be able to do more.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to wrap functions while keeping their original behavior
    or changing it in some fashion. Now, let’s consider some other ways of modifying
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Throttling and debouncing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s finish this section with two techniques that limit when and how often
    a function “does its thing”: **debouncing** and **throttling**. Both techniques
    share the same concept, so we’ll tackle them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Debouncing* a function means we delay for some time, doing nothing *until*
    we actually call the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Throttling* a function means we delay for some time, doing nothing *after*
    we actually call the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques are very efficient for web pages and allow for better performance.
    In a sense, they are related to memoizing. With memoization, you modify a function
    so it will get called only once (for some given arguments) but never more. With
    the techniques here, we do not go that far – we will allow a function to do its
    thing again, but in a restricted way, with some delays added in.
  prefs: []
  type: TYPE_NORMAL
- en: Debouncing functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea of debouncing comes from electronics and involves waiting to do something
    until a stable state has been reached. For example, if you write an autocomplete
    component, every time the user types a letter, you could query an API to fetch
    the possible options. However, you wouldn’t want to do this keypress by keypress
    because you’d be generating lots of calls, most of which you won’t even use since
    you’ll only care for the last one you made. Other usual examples involve mouse
    movement or page scrolling events; you don’t want to run associated handlers too
    often since that will negatively impact the page’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you debounced the API-calling function, you could still call it for every
    keypress, but no API call would be made until some time elapsed without any more
    calls. See *Figure 6**.2* for an example of this; events are shown as circles,
    and the actual call goes only given some event-less time after the last event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – A debounced function executes only after a pause in calls to
    it](img/Figure_6.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – A debounced function executes only after a pause in calls to it
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this with a timeout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: A debounced function is a new one that can be called as often as desired but
    won’t do anything until a `timer` has run. If you call the function once and then
    call it again, the timer will be reset and start running again. The only way for
    the function to actually do its thing is if a given `delay` period passes without
    any new calls.
  prefs: []
  type: TYPE_NORMAL
- en: Throttling functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the complementary throttling transformation, imagine a web form with a **FETCH**,
    **APPLY FILTERS**, or **RETRIEVE** button. When you click on it, an API call is
    made to get some data. However, if the user starts clicking again and again, too
    many calls will be made, even if they will get the same results. We want to throttle
    the calls so the first call will go through, but further calls will be disabled
    until some time has passed. A similar use case applies to *infinite scrolling*;
    as the user scrolls down the page, you want to fetch more data, but you neither
    want to do it very often for performance reasons nor wait until the user reaches
    the bottom (as would be the case with debouncing) because then scrolling would
    be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throttling is similar to debouncing, but a throttled function runs but then
    waits until the next run, while a debounced function first waits and then runs.
    *Figure 6**.3* shows how throttling works. As in the previous section, events
    are shown as circles. After a call to the API, no further calls are done unless
    some time has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A throttled function runs the first time it’s called but then
    delays until running again](img/Figure_6.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – A throttled function runs the first time it’s called but then delays
    until running again
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A throttled function is a new one, which you can call as often as desired, but
    it will “do its thing” the first time and not again until a certain `delay`. When
    you call the function, it first checks whether the `timer` is set; if so, it won’t
    do anything. If the timer isn’t set, a timeout will be set to clear the `timer`
    after some `delay`, and the function will be called. We are using the `timer`
    variable both for the timeout and as a flag (“are we waiting?”).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to wrap functions while keeping their original behavior
    or by altering them in some fashion. Now, let’s consider some other ways of modifying
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Changing functions in other ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s end this chapter by considering other sundry functions that provide results,
    such as new finders, decoupling methods from objects, and more. Our examples will
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Turning operations (such as adding with the `+` operator) into functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning functions into promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing objects to get the value of a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning methods into functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A better way of finding optimum values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning operations into functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen several cases where we needed to write a function just
    to add or multiply a pair of numbers. For example, in the *Summing an array* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    we had to write code equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *Working with ranges* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, we wrote this to calculate a factorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It would have been easier if we could just turn a binary operator into a function
    that calculates the same result. The preceding two examples could have been written
    more succinctly, as follows. Can you understand the change we made?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We haven’t looked at how `binaryOp()` is implemented yet, but the key notion
    is that instead of an infix operator (like we use when we write `22+9`), we now
    have a function (as if we could write our sum like `+(22,9)`, which certainly
    isn’t valid JavaScript). Let’s see how we can make this work.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How would we write this `binaryOp()` function? There are at least two ways
    of doing so: a safe but long one and a riskier and shorter alternative. The first
    would require listing each possible operator. The following code does this by
    using a longish switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is perfectly fine but requires too much work. By the way, we
    should have separate `binaryMathOp()` and `binaryLogicalOp()` functions; the first
    would be `(op: string) => ((x: number, y: number) => number)` while the second
    would be `(op: string) => ((x: boolean, y: boolean) => boolean)` because, as in
    the previous section, TypeScript cannot deduce the type of the returned function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a second solution, which is shorter but more dangerous. Please consider
    this only as an example for learning purposes; using `eval()` isn’t recommended
    for security reasons! Our second version would use `Function()` to create a new
    function that uses the desired operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, TypeScript cannot determine the type of the returned function because
    that will be determined only at runtime. So, we need to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t have to specify the type of `binaryOp2()` because TypeScript can work
    it out to be `(o: string) => (x: number, y: number) => number` by itself, given
    the cast that we applied to the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The (easier) way out
  prefs: []
  type: TYPE_NORMAL
- en: Some libraries, such as Lodash, already provide functions such as `_.multiply()`
    and `_.sum()`, so that’s a more straightforward solution! You could quickly whip
    up your own and create your own mini-library of mathematical and logical essential
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow this train of thought, you may also define a `unaryOp()` function,
    even though there are fewer applications for it. (I leave this implementation
    to you; it’s similar to what we already wrote.) In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*, we will look at an alternative way of creating this
    unary function by using a partial application.
  prefs: []
  type: TYPE_NORMAL
- en: A handier implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get ahead of ourselves. Doing FP doesn’t always mean getting down to
    the simplest possible functions. For example, in an upcoming section of this book,
    we will need a function to check whether a number is negative, and we’ll consider
    (see the *Converting to pointfree style* section of [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,
    Connecting Functions*) using `binaryOp2()` to write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t worry about the `curry()` function for now (we’ll get to it soon, in
    the following chapter) – the idea is that it fixes the first argument to `0` so
    that our function will check for a given `n` number if `0>n`. The point is that
    the function we just wrote isn’t very clear. We could do better if we defined
    a binary operation function that lets us specify one of its parameters – the left
    or the right one – in addition to the operator to be used. Here, we can write
    the following couple of functions, which define the functions where the left or
    right operators are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'With these new functions, we could write either of the following two definitions,
    though I think the second is clearer. I’d rather test whether a number is less
    than `0` than whether `0` is greater than the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What is the point of this? Don’t strive for some basic simplicity or go down
    to basics. We can transform an operator into a function, but if you can do better
    and simplify your coding by specifying one of the two parameters for the operation,
    just do it! The idea of FP is to help write better code, and creating artificial
    limitations won’t help anybody.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, for a simple function such as checking whether a number is negative,
    I would never want to complicate things with currying, binary operators, pointfree
    style, or anything else, and I’d write the following with no further ado:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have seen several ways of solving the same problem. Keep in mind
    that FP doesn’t force you to pick one way of doing things; instead, it allows
    you a lot of freedom in deciding which way to go!
  prefs: []
  type: TYPE_NORMAL
- en: Turning functions into promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Node.js, most asynchronous functions require a callback such as `(err,data)=>{...}`:
    if `err` is falsy, the function was successful, and `data` is its result; otherwise,
    the function failed, and `err` gives the cause. (See [nodejs.org/api/errors.html#error-first-callbacks](http://nodejs.org/api/errors.html#error-first-callbacks)
    for more on this.)'
  prefs: []
  type: TYPE_NORMAL
- en: However, you might prefer to work with promises instead. So, we can think of
    writing an HOF that will transform a function that requires a callback into a
    promise that lets you use the `then()` and `catch()` methods. (In [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will see that promises are actually *monads*,
    so this transformation is interesting in yet another way.) This will be an exercise
    for some developers because Node.js (since version 8) already provides the `util.promisify()`
    function, which turns an `async` function into a promise. See [nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original](http://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original)
    for more on that.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we manage this? The transformation is relatively simple. Given
    a function, we produce a new one: this will return a promise that, upon calling
    the original function with some parameters, will either `reject()` or `resolve()`
    the promise appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `promisify()` function does precisely that. Its parameter is an `fn` function
    that returns either an `err` error of generic type `E`, or some `data` of generic
    type `D`. The arguments of `fn` may be any type, except that the last one must
    be a callback; this requires using *variadic* data types, available in TypeScript
    since version 4.0, from 2020:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The given `fn` function is turned into a promise. The promise calls `fn` with
    a special callback: if that callback gets a non-null `err` value, the promise
    is rejected with that error; otherwise, the promise is resolved with `data`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working in Node.js, the following style is fairly common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use promises instead by using our `promisify()` function – or in current
    versions of Node.js, `util.promisify()` (but see the following, by the end of
    this section!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use `fspromise()` instead of the original method. To do so, we
    had to bind `fs.readFile`, as we mentioned in the *An unnecessary mistake* section
    of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out* *with Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, when using Node.js, be aware that many modules already provide a
    promise-based API in addition to the older callback-based API; for example, see
    [nodejs.org/api/fs.html#promises-api](http://nodejs.org/api/fs.html#promises-api)
    and compare it to [nodejs.org/api/fs.html#callback-api](http://nodejs.org/api/fs.html#callback-api).
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property from an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a simple function that we could also produce. Extracting an attribute
    from an object is a commonly required operation. For example, in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, we had to get latitudes and longitudes to calculate
    an average. The code for this was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw another example when we learned how to filter an array; in our example,
    we wanted to get the IDs for all the accounts with a negative balance. After filtering
    out all other accounts, we still needed to extract the `id` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we need? We need an HOF that will receive the name of an attribute
    and produce a new function that can extract an attribute from an object. Using
    the arrow function syntax, this function is easy to write; `f` is the name of
    the field we want, and `obj` is the object from which to get the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The full TypeScript version is a bit longer, but not much; mainly, we need
    to specify that `f` must be a key of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'With this function, the coordinate extraction process could have been written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'But that won’t be accepted! The issue is that TypeScript cannot detect the
    type of the result of the call to `getField()` because that will be decided at
    runtime. We must help by informing it that our two calls will return numbers.
    We can define the type of a generic number-returning function as `NumFn`, and
    then write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For variety, we could have used an auxiliary variable to get the delinquent
    IDs and avoid using an extra type similar to `NumFn`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you fully understand what’s going on here. The result of the
    `getField()` call is a function that will be used in further expressions. The
    `map()` method requires a mapping function and is what `getField()` produces.
  prefs: []
  type: TYPE_NORMAL
- en: Demethodizing – turning methods into functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods such as `filter()` and `map()` are only available for arrays; however,
    you may want to apply them to, say, `NodeList` or `String`, and you’d be out of
    luck. Also, we are focusing on strings, so having to use these functions as methods
    is not exactly what we had in mind. Finally, whenever we create a new function
    (such as `none()`, which we saw in the *Checking negatives* section of [*Chapter
    5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively*), it cannot
    be applied in the same way as its peers (`some()` and `every()`, in this case)
    unless you do some prototype trickery. This is rightly frowned upon and not recommended,
    but we’ll look into it anyhow; another case of “do as I say, not as I do!”
  prefs: []
  type: TYPE_NORMAL
- en: Read the *Extending current data types* section of [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, where we will make `map()` available for most basic
    types.
  prefs: []
  type: TYPE_NORMAL
- en: So, what can we do? We can apply the old saying *If the mountain won’t come
    to Muhammad, then Muhammad must go to the mountain*. Instead of worrying about
    not being able to create new methods, we will turn the existing methods into functions.
    We can do this if we convert each method into a function that will receive, as
    its first parameter, the object it will work on.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling methods from objects can help you because once you achieve this separation,
    everything turns out to be a function, and your code will be simpler. (Remember
    what we wrote in the *Logically negating a function* section, regarding a possible
    `filterNot()` function in comparison to the `filter()` method?) A decoupled method
    works similarly to generic functions in other languages since they can be applied
    to diverse data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important ABC: apply, bind, call'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for explanations on `apply()`, `call()`, and `bind()`. We are going to use these
    for our implementation. Back in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015),
    *Becoming Functional*, we saw the equivalence between `apply()` and `call()` when
    we used the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three distinct but similar ways to implement this decoupling in JavaScript.
    The first argument in the list (`arg0`) will correspond to the object, and the
    other arguments (`...args`) to the actual ones for the called method. The three
    equivalent versions would be as follows, and any of them could be used as a `demethodize()`
    function; pick your favorite! Let’s go with a plain JavaScript version to understand
    how they work; see *Question 6.15* for TypeScript versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: A fourth way
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s yet another way of doing this: `const demethodize = Function.prototype.bind.bind(Function.prototype.call)`.
    If you want to understand how this works, read Leland Richardson’s *Clever Way
    to Demethodize Native JS Methods*, at [www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods](http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some applications of these! Let’s start with a simple one that
    will also serve as a warning. We can make the `sort()` method into a function
    – but don’t think it will be made pure!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use `sort()` as a function – but it still produces the same side
    effect; `a` and `b` are the same array since `sort()` keeps working “in place.”
  prefs: []
  type: TYPE_NORMAL
- en: 'A more contrived case: we can use `map()` to loop over a string without converting
    it into an array of characters first. Say you wanted to separate a string into
    individual letters and make them uppercase; we could achieve this by using `split()`
    and `toUpperCase()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'By demethodizing `map()` and `toUpperCase()`, we can simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Yes, of course, for this particular case, we could have turned the string into
    uppercase and then split it into separate letters, as in `name.toUpperCase().split("")`,
    but it wouldn’t have been such a nice example, with two usages of demethodizing
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we could convert an array of decimal amounts into properly formatted
    strings with thousands separators and decimal points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, given the preceding demethodized `map()` function, we could have
    done the mapping with `map(numbers,` `toLocaleString)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of demethodizing a method to turn it into a function will prove to
    be quite useful in diverse situations. We have already seen some examples where
    we could have applied it, and there will be more such cases in the rest of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Methodizing – turning functions into methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how we could separate methods from objects to
    transform them into independent, standalone functions. Then, for fairness, let’s
    consider the complementary transformation, adding a function (as a method) to
    objects. We should call this operation *methodizing*, shouldn’t we?
  prefs: []
  type: TYPE_NORMAL
- en: We already saw something of this when we defined and worked with polyfills in
    the *Adding missing functions* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*,
    Starting Out with Functions*. Modifying prototypes is usually frowned upon because
    of the possibility of clashes with different libraries, at the very least. However,
    it’s an interesting technique, so let’s study it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example. Back in the *Folding left and right* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively,*
    we defined a `reverseString()` function to reverse a string. Since we already
    have a `reverse()` method that works with arrays, we could implement a `reverse()`
    method for strings. For variety, let’s do a new implementation of the string-reversing
    logic. We’ll add a Boolean parameter; if set to `true`, the function will add
    dashes between letters; this is just to show that methodizing also works with
    functions with more parameters. What we want to achieve is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The needed function is as follows (as a curiosity, note that we are using the
    array `reverse()` method to implement our `reverse()` string one!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a standard function (instead of an arrow one) because of the implicit
    handling of `this`, which wouldn’t be bound otherwise. Another crucial detail:
    the first argument to the function must be the string with which it will operate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must tell TypeScript that we’ll be extending the `String.prototype`
    object with a new method (see [www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html](http://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)
    for more on this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Without this definition (which could also have been in a separate `.d.ts` file),
    when we try to assign the new method, we’ll get the error shown in *Figure 6**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – You cannot add new methods to an existing object without an
    extra definition](img/Figure_6.4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – You cannot add new methods to an existing object without an extra
    definition
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we add a new method to the `String.prototype` object? In essence, we
    want to achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a function that calls our original one. Note that `this` (the current
    string object) is passed as the first argument. Other parameters are passed untouched.
    We can implement all this with a `methodize()` function; let’s see it first in
    JavaScript and then get into typing details. We want to do the following to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we did before. We are using the function’s name for the newly
    added method’s name. In TypeScript, this is a bit more complex, but we need the
    data type checks, so let’s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see the data types we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` is the generic type of the parameters that we’ll pass to our new methodized
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O` is the object’s type to whose prototype we’ll add the new method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F` is the function we’ll be methodizing; the first argument (`arg0`) is key,
    and we’ll be assigned the value of `this`. The other arguments (if any) are of
    a `T` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we use this `methodize()` function? Simple, with just one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can use our new method as planned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Averaging arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see one more example, to highlight a possible detail with typing. We’ll
    take the `average()` function that we wrote in the *Calculating an average* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively,*
    and add it to `Array.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that we want our function to only apply to arrays of numbers.
    We want TypeScript to detect and reject a line such as the following because of
    the wrong data type of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing the global declaration for the added method, an error will pop
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The definition of `Array` must be bound to a generic `Array<T>`. However, our
    definition for `average()` doesn’t depend on `T`. This means we have an unused
    definition to which ESLint objects. Since there’s no way of including `T` in our
    function, we’ll have to tell ESLint to let the error be; no other solution!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s nothing more to this; we can now methodize the `average()` function
    and use it as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You can now extend all base classes as desired – but remember our advice about
    being very, very careful!
  prefs: []
  type: TYPE_NORMAL
- en: Finding the optimum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s end this section by creating an extension of the `find()` method. Suppose
    we want to find the optimum value – let’s suppose it’s the maximum – of an array
    of numbers. We could make do with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now, is this sufficiently general? There are at least a pair of problems with
    this approach. First, are you sure that the optimum of a set will always be the
    maximum? If you were considering several mortgages, the one with the lowest interest
    rate would be the best, right? To assume that you always want the maximum of a
    set is too constrictive.
  prefs: []
  type: TYPE_NORMAL
- en: A negative maximum?
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do a roundabout trick: if you change the signs of all the numbers
    in an array, find its maximum, and change its sign, you actually get the minimum
    of the array. In our case, `-findOptimum(myArray.map((x) => -x))` would correctly
    produce `4`, but it’s not easily understandable code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, this way of finding the maximum depends on each option having a numeric
    value. But how would you find the optimum if such a value didn’t exist? The usual
    way depends on comparing elements with each other and picking the one that comes
    out on top:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the first element with the second and keep the best of those two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then compare that value with the third element and keep the best.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep at it until you have finished going through all the elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The way to solve this problem with more generality is to assume the existence
    of a comparator function, which takes two elements as arguments and returns the
    best of those. If you could associate a numeric value with each element, the comparator
    function could simply compare those values. In other cases, it could do whatever
    logic is needed to decide what element comes out on top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to create an appropriate HOF; our newer version will use `reduce()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This generic function takes a comparator that returns the best of two elements
    of a `T` type and then applies that function to an array of elements of a `T`
    type to produce the optimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can easily replicate the maximum- and minimum-finding functions;
    we only have to provide the appropriate reducing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go one better and compare non-numeric values. Let’s imagine a superhero
    card game: each card represents a hero and has several numeric attributes, such
    as `strength`, `powers`, and `tech`. The corresponding class could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'When two heroes fight each other, the winner is the one with more categories
    with higher values than the other. Let’s implement a comparator for this; a suitable
    `compareHeroes()` function could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can apply this to our tournament of heroes. First, let’s create our
    own league of heroes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'With these definitions, we can write a `findBestHero()` function to get the
    top hero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Order does matter
  prefs: []
  type: TYPE_NORMAL
- en: When you rank elements according to one-to-one comparisons, unexpected results
    may be produced. For instance, with our superheroes comparison rules, you could
    find three heroes where the results show that the first beats the second, the
    second beats the third, but the third beats the first! In mathematical terms,
    the comparison function is *not transitive*, and you don’t have a *total ordering*
    for the set.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have seen several ways of modifying functions to produce newer
    variants with enhanced processing; think of particular cases you might be facing
    and consider whether an HOF might help you out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write HOFs of our own that can either wrap
    another function to provide some new feature, alter a function’s objective so
    that it does something else, or even provide totally new features, such as decoupling
    methods from objects or creating better finders. The main takeaway from this chapter
    is that you have a way of modifying a function’s behavior without actually having
    to modify its own code; HOFs can manage this in an orderly way.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    we’ll keep working with HOFs and learn how to produce specialized versions of
    existing functions with predefined arguments by using currying and partial application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.1 `addLogging()` using a function, and its typing was not simple. Just to
    deal with a different syntax, can you provide an alternate implementation of `addLogging()`
    but using an arrow function?
  prefs: []
  type: TYPE_NORMAL
- en: '6.2 **Mapping for memory**: We implemented our memoizing functions by using
    an object as a cache. However, using a map would be better; make the necessary
    changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 `fib(50)` without memoizing? For example, one call and no further recursion
    were needed to calculate `fib(0)` or `fib(1)`, and 25 calls were required for
    `fib(6)`. Can you find a formula to do this calculation?
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 `randomizer(fn1, fn2, ...)`, that will receive a variable number of functions
    as arguments and return a new function that will, on each call, randomly call
    one of `fn1`, `fn2`, and so on. You could use this to balance calls to different
    services on a server if each function did an AJAX call. For bonus points, ensure
    that no function will be called twice in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 `not()` and `invert()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 `not()` function that worked with Boolean functions and a `negate()` function
    that worked with numerical ones. Can you go one better and write a single `opposite()`
    function that will behave as `not()` or `negate()`, as needed?
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 `invert()`, as suggested.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 `filterNot()` function with a slight change, as shown here, TypeScript will
    object; why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 6.9 `arity()` function works well, but the produced functions don’t have the
    correct `length` attribute. Can you write a different arity-changing function
    without this defect?
  prefs: []
  type: TYPE_NORMAL
- en: 6.10 `binary()` and `ternary()`?
  prefs: []
  type: TYPE_NORMAL
- en: 6.11 `async` function, every time you call it with the same arguments, you’ll
    get the same promise as a result. But imagine we were calling a weather API, which
    updates its data every 5 minutes. We don’t want to call it just once and never
    again (as with memoization), but we don’t want to call it every time either. Can
    you add throttling behavior to our `promiseMemoize()` function so, after a given
    delay, a new call to the API will be made?
  prefs: []
  type: TYPE_NORMAL
- en: 6.12 `binaryOp()` function that would work with numbers, what is the list of
    all the operators you should consider?
  prefs: []
  type: TYPE_NORMAL
- en: 6.13 `getField()` function, we should also have a `setField()` function, so
    can you define it? We’ll need both in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, when we work with getters, setters, and lenses. Note that `setField()`
    shouldn’t directly modify an object; instead, it should return a new object with
    a changed value – it should be a pure function!
  prefs: []
  type: TYPE_NORMAL
- en: 6.14 `getField()` function if we apply it to a null object? What should its
    behavior be? If necessary, modify the function. This question has different answers
    in JavaScript and TypeScript; be careful!
  prefs: []
  type: TYPE_NORMAL
- en: '6.15 `demethodize()` functions. A tip: once you get one of them right, the
    other two will be pretty similar!'
  prefs: []
  type: TYPE_NORMAL
- en: 6.16 `findMaximum()` and `findMinimum()`, we wrote our own functions to compare
    two values – but JavaScript already provides appropriate functions for that! Can
    you figure out alternative versions of our code based on that hint?
  prefs: []
  type: TYPE_NORMAL
- en: '6.17 `const wins2 = 3 – wins1` in our `compareHeroes()` function? Wouldn’t
    that have been faster? Or even better: avoid calculating `wins2` at all, and change
    the final line to `return wins1 >=` `2`?'
  prefs: []
  type: TYPE_NORMAL
