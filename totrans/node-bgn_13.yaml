- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Authentication and Authorization with Passport.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how authentication and authorization work in
    a modern web application. We will explore the cryptography behind many security
    mechanisms and will learn how to implement these concepts in our web applications
    using **JSON Web Tokens** (**JWT**). We will also see how we can extend our authentication
    strategies with third-party providers such as Facebook or Spotify with Passport.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we will implement authentication and authorization
    in our web application project iterating over the code that we generated in the
    previous chapter. We will also learn how to specifically test them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How authentication and authorization work in a web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use JWT to authenticate users in our web application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cryptography basics that we need to know to understand modern authentication
    and authorization mechanisms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Passport.js works and how to use it to implement authentication with third-party
    providers such as Facebook or Spotify in our web application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add authentication and authorization layers to any web project using
    JWT and Express
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow this chapter, the following are some recommendations:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: You should be familiar with the code that we generated in the previous chapter,
    as this is an iteration of the code that we generated
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 20.11.0 installed on your machine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code editor such as Visual Studio Code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have Docker set up and running
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser such as Chrome or Firefox
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/mdE5eXS5enM](https://youtu.be/mdE5eXS5enM)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern authentication and authorization
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** and **authorization** are two different concepts that are
    often confused. Authentication involves confirming the identity of a user, whereas
    authorization involves verifying the specific access privileges they possess.
    In this chapter, we will explore how to implement both concepts in our web application
    in the *Adding authentication and authorization to our web* *application* section.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the big challenges of the HTTP protocol is that it is stateless. This
    means that the server does not keep any information about the client. Each request
    is independent, so we need to design and provide mechanisms that allow us to know
    who the user performing the request is. This is the main goal of the authentication
    process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to implement authentication in a web application. The most
    common way is to use a username and password, and there are many libraries that
    can help us to implement this mechanism as well as different approaches to follow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We can delegate most of it to a third-party provider such as *Auth0* or we can
    implement it ourselves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将大部分工作委托给第三方提供商，例如 *Auth0*，或者我们自己来实现。
- en: In this chapter, we will explore how to implement authentication in our web
    application using the *Passport.js library* and *JSON Web* *Tokens (JWT)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 *Passport.js 库* 和 *JSON Web 令牌 (JWT)* 在我们的 Web 应用程序中实现身份验证。
- en: Authorization
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: We need to implement a clear way to determine whether a user is authorized to
    perform a certain action, such as creating a new post or deleting an old post.
    Even something as simple as accessing a certain page requires us to implement
    a way to determine whether the user is authorized to access it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一种明确的方式来确定用户是否有权执行某些操作，例如创建新帖子或删除旧帖子。即使是访问特定页面这样简单的事情，也需要我们实现一种确定用户是否有权访问的方法。
- en: It is quite common that a lot of effort is put into the authentication part,
    but the authorization aspect gets forgotten about. Historically, web systems were
    less complex at the beginning of the internet and we didn’t have a lot of roles
    assigned to each user, so we tended to focus more on who you are rather than whether
    you should be able to do certain actions. Today, it is quite common to build complex
    systems that end up having access control tables that define the relationships
    between the actions and the roles. As an example, we can take as a reference the
    Role-based Authorization Strategy plugin for Jenkins, described in *Figure 13**.1*.
    Using this, we can easily understand and update relationships between the roles
    and the potential activities to be performed. For example, the **builder** role
    can cancel jobs but not configure them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证部分投入大量精力，但忘记授权方面是很常见的情况。从历史上看，互联网初期的 Web 系统较为简单，我们没有为每个用户分配很多角色，所以我们更关注你是谁，而不是你是否应该能够执行某些操作。今天，构建复杂的系统是很常见的，最终会有访问控制表来定义动作和角色之间的关系。例如，我们可以参考
    *图 13.1* 中描述的基于角色的授权策略插件。使用这个插件，我们可以轻松理解和更新角色与潜在活动之间的关系。例如，**构建者**角色可以取消作业但不能配置它们。
- en: '![Figure 13.1 – Web browser screenshot from https://github.com/jenkinsci/role-strategy-plugin,
    available under the MIT license](img/B21678_13_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 来自 https://github.com/jenkinsci/role-strategy-plugin 的 Web 浏览器截图，可在
    MIT 许可下获得](img/B21678_13_1.jpg)'
- en: Figure 13.1 – Web browser screenshot from [https://github.com/jenkinsci/role-strategy-plugin](https://github.com/jenkinsci/role-strategy-plugin),
    available under the MIT license
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 来自 [https://github.com/jenkinsci/role-strategy-plugin](https://github.com/jenkinsci/role-strategy-plugin)
    的 Web 浏览器截图，可在 MIT 许可下获得
- en: Failing to properly consider authorization is a very common mistake that can
    lead to severe security issues. For example, if we forget to implement the authorization
    part, we can end up with a web application that allows any user to access any
    page, or to perform any action. This is a very dangerous situation that can lead
    to security risks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 没有正确考虑授权是一个非常常见的错误，可能会导致严重的安全问题。例如，如果我们忘记实现授权部分，我们可能会得到一个允许任何用户访问任何页面或执行任何操作的
    Web 应用程序。这是一个非常危险的情况，可能会导致安全风险。
- en: We will explore this topic in practical terms in the *Adding authentication
    and authorization to our web application* section of this chapter, seeing how
    to implement an appropriate authorization strategy in our web application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的 *将身份验证和授权添加到我们的 Web 应用程序* 部分中从实际角度探讨这个主题，看看如何在我们的 Web 应用程序中实现适当的授权策略。
- en: Now that we have a clear understanding of the differences between authentication
    and authorization, let’s explore how to implement them in our web application.
    In the next section, we will learn how we can use JWT to authenticate users in
    our web application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚地理解了身份验证和授权之间的区别，让我们来探讨如何在我们的 Web 应用程序中实现它们。在下一节中，我们将学习如何使用 JWT 在我们的
    Web 应用程序中验证用户。
- en: JWT in a nutshell
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT 简述
- en: One of the most popular ways to implement authentication in a web application
    is to use JWT.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中实现身份验证最流行的方法之一是使用 JWT。
- en: 'So, let’s see some definitions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看一些定义：
- en: JSON Web Token is a proposed internet standard for creating data with optional
    signature and/or optional encryption whose payload holds JSON that asserts some
    number of claims. The tokens are signed either using a private secret or a public/private
    key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token 是一个提议的互联网标准，用于创建带有可选签名和/或可选加密的数据，其有效载荷包含断言一定数量声明的 JSON。这些令牌可以使用私有密钥或公私钥进行签名。
- en: (JSON Web Token, [https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token))
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (JSON Web Token, [https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token))
- en: JSON Web Tokens are an open, industry-standard RFC 7519 method for representing
    claims securely between two parties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens是一种开放、行业标准的RFC 7519方法，用于在双方之间安全地表示声明。
- en: (JWT, [https://jwt.io/](https://jwt.io/))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: (JWT, [https://jwt.io/](https://jwt.io/))
- en: So, basically, a **JWT** is a string (*JSON*) that contains information (*claims*)
    and is signed using a secret key. This process ensures that the information within
    the JWT remains secure and tamper-proof, allowing for verification during subsequent
    requests. Although this may seem like a straightforward concept, delving deeper
    reveals a multitude of intricacies and considerations that must be understood
    first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，**JWT**是一个包含信息（*声明*）的字符串（*JSON*），并使用一个密钥进行签名。这个过程确保JWT内的信息保持安全且不可篡改，允许在后续请求中进行验证。尽管这听起来可能是一个简单的概念，但深入了解会揭示许多复杂性和考虑因素，必须首先理解。
- en: 'Let’s list some of the most critical features that we expect to be supported
    to understand the underlying complexity:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们期望支持的某些最关键的功能，以了解其背后的复杂性：
- en: Anyone can send a request to our server, so we cannot trust any request by default.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以向我们的服务器发送请求，因此我们默认不能信任任何请求。
- en: Anyone can try to manipulate the request, so we need to implement a mechanism
    that allows us to verify that the request has not been manipulated.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以尝试操纵请求，因此我们需要实现一个机制，允许我们验证请求没有被操纵。
- en: We need to implement a mechanism that allows us to verify the request without
    the need to store any information on the server. That way we can scale our application
    without any issues and can even use the same JWT across multiple servers.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要实现一个机制，允许我们验证请求，而无需在服务器上存储任何信息。这样我们就可以无问题地扩展我们的应用，甚至可以在多个服务器上使用相同的JWT。
- en: The process
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 该过程
- en: In plain terms, the user will authenticate using a username and password, and
    then the server will return a JWT. The user will send the JWT in every request
    and the server will verify the JWT to authenticate the user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，用户将使用用户名和密码进行认证，然后服务器将返回一个JWT。用户将在每个请求中发送JWT，服务器将验证JWT以认证用户。
- en: The theory
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: The JWT is a string with information about the user (such as their name, role,
    etc.) and is signed using a secret key. So, the server can verify the JWT using
    the secret key and can then extract the information about the user. Any attempt
    to modify the JWT will invalidate the signature, so the server will reject the
    request.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个包含用户信息（如姓名、角色等）的字符串，并使用一个密钥进行签名。因此，服务器可以使用密钥验证JWT，并从中提取用户信息。任何修改JWT的尝试都将使签名无效，因此服务器将拒绝请求。
- en: So, in order to properly sign the tokens, first we need to understand the basics
    of cryptography.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了正确地签名令牌，我们首先需要了解密码学的基础知识。
- en: Cryptography 101
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学101
- en: 'To make the JWT work, we need to understand two things: hashing and signing.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使JWT工作，我们需要了解两件事：哈希和签名。
- en: Hashing
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希
- en: '**Hashing** is a process that takes a string and returns a fixed-length string.
    This algorithm works as a one-way function, so we can hash a string, but we cannot
    get the original string from the hash.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**是一个过程，它接受一个字符串并返回一个固定长度的字符串。此算法作为一个单向函数工作，因此我们可以对字符串进行哈希，但我们不能从哈希中获取原始字符串。'
- en: 'Here is an example of hashing a string using the `SHA256` algorithm in Node.js:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用Node.js中的`SHA256`算法对字符串进行哈希的示例：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use this algorithm to hash the password of the user later on in this
    chapter, in the *Adding authentication and authorization to our web* *application*
    section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“向我们的Web应用添加认证和授权”部分稍后使用此算法来哈希用户的密码。
- en: Signing
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签名
- en: '**Signing** is a process that takes a string and a secret key and returns a
    new string. This algorithm works as a two-way function, so we can sign a string
    and then we can verify the signature using the secret key.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**是一个过程，它接受一个字符串和一个密钥，并返回一个新的字符串。此算法作为一个双向函数工作，因此我们可以对字符串进行签名，然后我们可以使用密钥验证签名。'
- en: Wide use
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广泛使用
- en: This pattern of using hashing and signing is very common across many different
    software fields. As an example, when a new Node.js version is released, the Node.js
    team will publish the hash of every binary file. This allows us to download the
    binary file and then verify the hash of the file using the hash that the Node.js
    team published. If the hashes are the same, then we can be sure that the file
    has not been modified.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用哈希和签名的模式在许多不同的软件领域都非常常见。例如，当一个新的Node.js版本发布时，Node.js团队将发布每个二进制文件的哈希值。这允许我们下载二进制文件，然后使用Node.js团队发布的哈希值来验证文件的哈希值。如果哈希值相同，那么我们可以确信文件没有被修改。
- en: The hash file is signed prior to publishing it, so we can verify the signature
    using the public key of the Node.js team members. If the signature is valid, then
    we can be sure that the hash file has not been modified.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布哈希文件之前，会对文件进行签名，因此我们可以使用Node.js团队成员的公钥来验证签名。如果签名有效，那么我们可以确信哈希文件没有被修改。
- en: 'As an example, the following link is the file shasum for Node v20.11.0 ([https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc](https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc)).
    The following code block is the content of the file (redacted for space) to understand
    how it works:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下链接是Node v20.11.0的文件shasum ([https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc](https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc))。以下代码块是文件的内容（为了节省空间已省略）以了解其工作原理：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the file contains two parts (the message and the signature)
    and uses `-----BEGIN PGP SIGNED MESSAGE-----` to `-----BEGIN PGP SIGNATURE-----`.
    This helps us to verify the authenticity of the file – basically, we can verify
    that a Node.js releaser has created this file and the content has not been manipulated,
    even if the server from which the file was downloaded was compromised.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，文件包含两部分（消息和签名）并使用`-----BEGIN PGP SIGNED MESSAGE-----`到`-----BEGIN PGP SIGNATURE-----`来分隔。这有助于我们验证文件的真实性——基本上，我们可以验证一个Node.js发布者创建了此文件，并且内容没有被篡改，即使下载文件的服务器被攻破。
- en: The message itself contains the hash of every binary file, so we can download
    the `node-v20.11.0-aix-ppc64.tar.gz` file and check that the content of the file
    is the same as the hash published in the message, `f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f`.
    If the hash is the same, then we can be sure that the file has not been modified.
    This allows us to distribute information securely.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 消息本身包含每个二进制文件的哈希值，因此我们可以下载`node-v20.11.0-aix-ppc64.tar.gz`文件并检查文件内容是否与消息中发布的哈希值相同，即`f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f`。如果哈希值相同，那么我们可以确信文件没有被修改。这允许我们安全地分发信息。
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: With JWT, we will use a similar pattern, but instead of PGP, we will use a different
    algorithm to sign the content. You can find the list of supported algorithms in
    RFC 7518 ([https://tools.ietf.org/html/rfc7518#section-3.1](https://tools.ietf.org/html/rfc7518#section-3.1)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT时，我们将使用类似的模式，但我们将使用不同的算法来签名内容。您可以在RFC 7518中找到支持的算法列表 ([https://tools.ietf.org/html/rfc7518#section-3.1](https://tools.ietf.org/html/rfc7518#section-3.1))。
- en: JWT structure
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT结构
- en: 'JWT is a string that is composed of three parts separated by a dot. Each part
    is encoded in *base64*. The three parts are the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个由点分隔成三部分的字符串。每一部分都使用*base64*编码。这三部分如下：
- en: '**Header**: Contains information about the type of token and the algorithm
    used to sign the token'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：包含有关令牌类型和用于签名令牌的算法的信息'
- en: '**Payload**: Contains the claims (information) that we want to store in the
    token'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**：包含我们想要存储在令牌中的声明（信息）'
- en: '**Signature**: Contains the signature of the token that is used to verify the
    token'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：包含用于验证令牌的令牌签名'
- en: The signature is the result of signing the header and the payload using the
    secret key. The best part is that we can verify the signature using the secret
    key, so we can verify the token without needing to store any information on the
    server. Additionally, the information is encoded in base64, so anyone can decode
    it and read it, but we cannot modify it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 签名是使用密钥对标题和有效载荷进行签名的结果。最好的部分是，我们可以使用密钥来验证签名，因此我们可以在服务器上不需要存储任何信息的情况下验证令牌。此外，信息是使用base64编码的，因此任何人都可以解码并阅读它，但我们无法修改它。
- en: One important thing to mention is that you should never store sensitive information
    in the payload, as anyone can decode it and read it. This includes users’ passwords
    and bank account details, among other sensitive information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要提及，那就是你绝不应该在有效载荷中存储敏感信息，因为任何人都可以解码并读取它。这包括用户的密码和银行账户详情以及其他敏感信息。
- en: JWT.io
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT.io
- en: One of the best tools to work with JWT is the JWT Debugger ([https://jwt.io/](https://jwt.io/))
    (see *Figure 13**.2*). This website allows us to encode and decode JWTs, as well
    as to verify the signature of the token. You can use it to play with or debug
    your JWTs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 JWT 的最佳工具之一是 JWT Debugger ([https://jwt.io/](https://jwt.io/))（见 *图 13**.2*）。这个网站允许我们编码和解码
    JWT，以及验证令牌的签名。你可以用它来尝试或调试你的 JWT。
- en: '![Figure 13.2 – Web browser screenshot showing how to digest and validate an
    encoded token](img/B21678_13_2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 网络浏览器截图，展示如何解析和验证编码后的令牌](img/B21678_13_2.jpg)'
- en: Figure 13.2 – Web browser screenshot showing how to digest and validate an encoded
    token
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 网络浏览器截图，展示如何解析和验证编码后的令牌
- en: Feel free to play with it and explore how it works before moving to the next
    section of this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入本章的下一节之前，你可以随意尝试并探索它的工作原理。
- en: In the next section, we will learn how Passport.js works and how it can be used
    to implement authentication with third-party providers such as Facebook or Spotify
    in our web application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习 Passport.js 的工作原理以及如何在我们 web 应用程序中使用它来实现与第三方提供者（如 Facebook 或 Spotify）的身份验证。
- en: Understanding Passport.js fundamentals
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Passport.js 基础知识
- en: '**Passport.js** is a fantastic library, widely used to implement authentication
    in Node.js applications. The official website of Passport.js defines the library
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Passport.js** 是一个出色的库，广泛用于在 Node.js 应用程序中实现身份验证。Passport.js 的官方网站将这个库定义为如下：'
- en: Passport is authentication middleware for Node.js. Extremely flexible and modular,
    Passport can be unobtrusively dropped in to any Express-based web application.
    A comprehensive set of strategies support authentication using a username and
    password, Facebook, Twitter, and more.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 是 Node.js 的身份验证中间件。它极其灵活且模块化，可以无缝地集成到任何基于 Express 的 web 应用程序中。一套全面的策略支持使用用户名和密码、Facebook、Twitter
    等进行身份验证。
- en: (Passport.js, [http://www.passportjs.org/](http://www.passportjs.org/))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (Passport.js, [http://www.passportjs.org/](http://www.passportjs.org/))
- en: In essence, Passport.js is a middleware ([https://expressjs.com/en/guide/using-middleware.html](https://expressjs.com/en/guide/using-middleware.html))
    that we will include in our Express application to provide many different strategies
    to implement authentication. Having a selection of such strategies allows us to
    choose the one that best fits our needs. We can use the library to easily implement
    social login functionality (such as Facebook, Twitter, Spotify, GitHub, and much
    more in more than 500 strategies) and the typical username/password login.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Passport.js 是一个中间件 ([https://expressjs.com/en/guide/using-middleware.html](https://expressjs.com/en/guide/using-middleware.html))，我们将将其包含到我们的
    Express 应用程序中，以提供多种不同的策略来实现身份验证。拥有这样的策略选择，我们可以选择最适合我们需求的一个。我们可以使用这个库轻松实现社交登录功能（如
    Facebook、Twitter、Spotify、GitHub 以及更多，超过 500 种策略）以及典型的用户名/密码登录。
- en: In the next section, we will iterate the code from our web application to include
    authentication and authorization mechanisms using what we have learned in this
    chapter so far.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将迭代我们的 web 应用程序中的代码，以包含我们在本章中迄今为止所学到的身份验证和授权机制。
- en: Adding authentication and authorization to our web application
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将身份验证和授权添加到我们的 web 应用程序中
- en: In this section, we will add authentication and authorization to our web application.
    We will use the jsonwebtoken library to implement the authentication part and
    will use a custom middleware to implement the authorization part.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的 web 应用程序添加身份验证和授权。我们将使用 jsonwebtoken 库来实现身份验证部分，并使用自定义中间件来实现授权部分。
- en: Clone the base project
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆基础项目
- en: The authentication and authorization additions are not very complex, but it
    is quite long to follow with ease, so for this chapter you can download the project
    from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step4` folder. The implementation is ready to go, but I will comment
    on the most relevant changes that we made since the last chapter (`step3` folder)
    so you can easily follow what we’ve done.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权的添加并不复杂，但跟随起来相当长，所以对于本章，您可以下载项目[https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)并访问`step4`文件夹。实现已就绪，但我将评论自上一章（`step3`文件夹）以来我们所做的最相关更改，以便您能轻松跟踪我们所做的工作。
- en: Setup
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: 'Our first steps are to explore the folder, install the dependencies, configure
    the environment, and start the infrastructure. This can be performed by running
    the following commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是探索文件夹，安装依赖项，配置环境，并启动基础设施。这可以通过运行以下命令来完成：
- en: Install the dependencies with `npm i`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm i`安装依赖项。
- en: 'Update the secrets, adding the `.env` file in the root folder with the following
    content:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新密钥，在根文件夹中添加`.env`文件，内容如下：
- en: '[PRE2]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run `npm run infra:stop && npm` `run infra:start`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm run infra:stop && npm run infra:start`。
- en: Now, the infrastructure and configuration are ready, but before we start making
    more changes to the application, it is recommended to run some tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基础设施和配置已就绪，但在我们开始对应用程序进行更多更改之前，建议运行一些测试。
- en: Run the tests
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: Next, we need to run some tests to ensure that the code is working as expected
    by typing `npm run test` in our terminal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行一些测试以确保代码按预期工作，通过在终端中输入`npm run test`。
- en: New tests added
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新增测试
- en: 'We can see that we have a few new routes related to login/signup and specific
    tests for them. When we execute the tests, we will see that the test messages
    (descriptions) are clear and self-explanatory in terms of what the routes are
    expected to do and what we aim to do with the test, even if we are not yet familiar
    with the code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们有一些与登录/注册相关的新路由以及针对它们的特定测试。当我们执行测试时，我们会看到测试消息（描述）在说明路由预期做什么以及我们希望通过测试做什么方面是清晰且一目了然的，即使我们还不熟悉代码：
- en: '![Figure 13.3 – Terminal screenshot that showcases how the routes are tested](img/B21678_13_3.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 终端截图展示了如何测试路由](img/B21678_13_3.jpg)'
- en: Figure 13.3 – Terminal screenshot that showcases how the routes are tested
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 终端截图展示了如何测试路由
- en: We should recognize these tests as we worked on these routes in the previous
    chapters. But if we keep scrolling through the test output, we should see that
    new tests have been added as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能认出这些测试，因为我们已经在上一章中处理了这些路由。但如果我们继续滚动查看测试输出，我们应该会看到还添加了新的测试。
- en: Updated tests
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新测试
- en: 'The previous tests have been updated to include new test cases related to authentication
    for the routes that require authentication with JWT:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试已更新，包括与JWT进行身份验证的路由的新测试用例：
- en: '![Figure 13.4 – Terminal screenshot shows the tests passing and how easy is
    to follow what is being tested with the descriptions](img/B21678_13_4.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 终端截图显示测试通过以及如何通过描述轻松跟踪正在测试的内容](img/B21678_13_4.jpg)'
- en: Figure 13.4 – Terminal screenshot shows the tests passing and how easy is to
    follow what is being tested with the descriptions
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 终端截图显示测试通过以及如何通过描述轻松跟踪正在测试的内容
- en: As you can see, the use cases in the tests cover more scenarios related to authentication
    and authorization, such as `Should return 401 when the user is not authenticated`
    and `Should return a 403 when the user is not` `the author`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，测试中的用例涵盖了更多与身份验证和授权相关的场景，例如“当用户未进行身份验证时应返回401”和“当用户不是作者时应返回403”。
- en: The UI changes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI更改
- en: But overall, the most significant changes are related to the UI, as now we have
    new routes and views to login/register and so on. So we can start the application
    by running `npm` `run start`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但总体而言，最重要的变化与UI相关，因为我们现在有新的路由和视图用于登录/注册等。因此，我们可以通过运行`npm run start`来启动应用程序
- en: Login
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录
- en: You can enter your credentials to log in at `http://localhost:3000/login`, upon
    which the backend API will return a JWT that you can use to authenticate for any
    CRUD operation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`http://localhost:3000/login`处输入凭据进行登录，此时后端API将返回一个JWT，您可以使用它进行任何CRUD操作的身份验证。
- en: '![Figure 13.5 – Web browser screenshot showing the login page where the user
    can enter their username and password](img/B21678_13_5.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 展示用户可以输入用户名和密码的登录页面的网页浏览器截图](img/B21678_13_5.jpg)'
- en: Figure 13.5 – Web browser screenshot showing the login page where the user can
    enter their username and password
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 展示用户可以输入用户名和密码的登录页面的网页浏览器截图
- en: Register
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册
- en: You can create a new account whenever you please at `http://localhost:3000/signup`.
    This operation will generate a new user in the database and the backend will return
    you a JWT that you can use to perform CRUD operations and authenticate yourself
    against the API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时在 `http://localhost:3000/signup` 创建新账户。此操作将在数据库中生成新用户，并且后端将返回一个JWT，您可以使用它来执行CRUD操作并验证您对API的访问。
- en: '![Figure 13.6 – Web browser screenshot showing where the user can create a
    new account or log in with existing credentials](img/B21678_13_6.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 展示用户可以创建新账户或使用现有凭据登录的网页浏览器截图](img/B21678_13_6.jpg)'
- en: Figure 13.6 – Web browser screenshot showing where the user can create a new
    account or log in with existing credentials
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 展示用户可以创建新账户或使用现有凭据登录的网页浏览器截图
- en: Important note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The server has defined certain rules regarding username, email and password.
    So, as an example you can use the following values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已定义有关用户名、电子邮件和密码的某些规则。因此，例如，您可以使用以下值：
- en: 'Username: `nodejs`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名：`nodejs`
- en: 'Email: `demo@demo.com`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮箱：`demo@demo.com`
- en: 'Password: `aA1#dt$tu`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：`aA1#dt$tu`
- en: CRUD operations
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CRUD操作
- en: 'As remarked on in the previous section, it is important to understand how authorization
    works. So, here are the rules for our business logic:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，了解授权的工作方式非常重要。因此，以下是我们的业务逻辑规则：
- en: Any logged user can see all the whispers available on the Whispering platform
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何已登录的用户都可以看到Whispering平台上的所有whispers。
- en: You can modify or delete only the whispers that you have created
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只能修改或删除您创建的whispers。
- en: These clear rules will help us to build an authorization system that will cover
    all the scenarios, so, for example, you won’t be able to delete a whisper created
    by another user. In some applications, this approach can be very complex, such
    as with Google Drive or Facebook. In those scenarios, it is quite useful to have
    a permission matrix in place and well documented. GitLab offers a great example
    ([https://docs.gitlab.com/ee/user/permissions.html](https://docs.gitlab.com/ee/user/permissions.html))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些明确的规则将帮助我们构建一个涵盖所有场景的授权系统，因此，例如，您将无法删除其他用户创建的whispers。在某些应用程序中，这种方法可能非常复杂，例如Google
    Drive或Facebook。在这些场景中，拥有一个设置良好且文档齐全的权限矩阵非常有用。GitLab提供了一个很好的例子（[https://docs.gitlab.com/ee/user/permissions.html](https://docs.gitlab.com/ee/user/permissions.html)）
- en: '![Figure 13.7 – Web browser screenshot showing the main page with all the whispers
    and the buttons to interact with them from the UI](img/B21678_13_7.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 展示所有whispers及其从UI交互按钮的主页的网页浏览器截图](img/B21678_13_7.jpg)'
- en: Figure 13.7 – Web browser screenshot showing the main page with all the whispers
    and the buttons to interact with them from the UI
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 展示所有whispers及其从UI交互按钮的主页的网页浏览器截图
- en: As you can see, we can modify only the whispers that we created but the option
    is not visually available for other whispers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只能修改我们创建的whispers，但此选项在视觉上对其他whispers不可用。
- en: While the UI is a key factor in managing authorization, we need to ensure that
    the backend is also properly managing authorization on its part, so it won’t allow
    the users to modify or delete whispers from other users. To ensure that the application
    is capable of preventing these scenarios (like modify other’s users whispers)
    it is highly recommended to add specify test case. Check the test suite cases,
    as we have already included these scenarios that cover the `403` `Forbidden` response.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UI是管理授权的关键因素，但我们需要确保后端也正确地管理其部分的授权，因此它不会允许用户修改或删除其他用户的whispers。为了确保应用程序能够防止这些场景（如修改其他用户的whispers），强烈建议添加特定的测试用例。检查测试套件用例，因为我们已经包括了涵盖`403`
    `Forbidden`响应的这些场景。
- en: Added dependencies
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加的依赖项
- en: 'We have included the following dependencies:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了以下依赖项：
- en: '**Bcrypt** ([https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt)):
    This is a library that will help us to store passwords safely in the database.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bcrypt** ([https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt))：这是一个库，将帮助我们安全地将密码存储在数据库中。'
- en: '**Jsonwebtoken** ([https://www.npmjs.com/package/jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)):
    This is a utility that helps us to generate and parse the JWTs.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jsonwebtoken** ([https://www.npmjs.com/package/jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken))：这是一个帮助我们生成和解析JWTs的实用工具。'
- en: '**Validator** ([https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator)):
    This is a library that we use to validate strings. Basically, we can use it to
    sanitize the inputs received from the users, including email addresses, URLs,
    phone numbers, and so on.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Validator** ([https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator))：这是一个我们用来验证字符串的库。基本上，我们可以用它来清理从用户那里接收到的输入，包括电子邮件地址、URL、电话号码等。'
- en: These dependencies will be used later in order to properly build our application.
    It is quite common in Node.js projects to rely on third-party libraries. The most
    important thing to remember is to be sure that we are using good-quality external
    dependencies without known vulnerabilities, as we learned in [*Chapter 6*](B21678_06.xhtml#_idTextAnchor171)*.*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项将在以后用于正确构建我们的应用程序。在Node.js项目中依赖第三方库是很常见的。最重要的是要确保我们使用的是没有已知漏洞的高质量外部依赖项，正如我们在[*第6章*](B21678_06.xhtml#_idTextAnchor171)*.*中学到的。
- en: Changes in the frontend
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端的变化
- en: 'We added a new file called `public/auth.js` to manage the form submissions
    while the user logs in or registers with the platform. After sending the requests,
    we will store the JWT in the local storage, so we can recover the JWT easily even
    if we refresh the page:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`public/auth.js`的新文件来管理用户登录或使用平台注册时的表单提交。在发送请求后，我们将JWT存储在本地存储中，这样我们就可以轻松地恢复JWT，即使我们刷新页面：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the previous changes, we now send the user and password to the `/login`
    route using the `POST` HTTP method. As a response, we expect JSON data that will
    contain the access token that we will store in the local storage in order to keep
    session persistence in case the user refreshes the page. Finally, we will redirect
    the user to the home page as the authentication has been completed successfully.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的更改，我们现在使用`POST` HTTP方法将用户名和密码发送到`/login`路由。作为响应，我们期望包含访问令牌的JSON数据，我们将将其存储在本地存储中，以保持会话持久性，以防用户刷新页面。最后，我们将用户重定向到主页，因为身份验证已成功完成。
- en: 'We also added the JWT to every request made against the API for any CRUD operation
    in `public/app.js`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`public/app.js`中添加了JWT，以针对API的任何CRUD操作进行请求：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, every request includes the `Authentication` header with the
    `Bearer TOKEN` value, which is the expected way to authenticate against the backend.
    We also use the JWT to get the user’s name and display it in the UI in the Whispers
    view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个请求都包含带有`Bearer TOKEN`值的`Authentication`头，这是对后端进行身份验证的预期方式。我们还使用JWT来获取用户名，并在Whispers视图中在UI中显示它。
- en: 'Also, we disabled the edit/delete buttons from the Whisper view if the current
    user is not the user that created them:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还禁用了Whisper视图中当前用户不是创建它们的用户时的编辑/删除按钮：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `controlEdition` function can hide/show the actions depending on the author:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`controlEdition`函数可以根据作者隐藏/显示操作：'
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we are clear on the changes made in the frontend part, it is time to
    jump to the backend part and review the changes needed in order to properly manage
    the users’ authentication data in the databases. We’ll start with the changes
    in the stores.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚前端部分所做的更改，现在是时候跳转到后端部分并审查在数据库中正确管理用户身份验证数据所需进行的更改。我们将从存储的更改开始。
- en: Added a new store for users
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加了新的用户存储
- en: 'The most relevant changes were added to the `database.js` file, where a new
    schema was added for the users. We now include more advanced validations and transformations.
    The user has `username`, `email`, and `password` properties:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最相关的更改添加到了`database.js`文件中，其中为用户添加了一个新的模式。我们现在包括更高级的验证和转换。用户有`username`、`email`和`password`属性：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the case of `password`, we include an additional validation with a new function
    that we added to the utilities file, `utils.js`. This new function uses a regular
    expression to validate the password strength (a minimum of eight characters, at
    least one letter, one number, and one special character):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`password`的情况下，我们通过在`utils.js`工具文件中添加的新函数增加了额外的验证。这个新函数使用正则表达式来验证密码强度（至少八个字符，至少一个字母，一个数字和一个特殊字符）：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the `whisperSchema` schema has a relation with `User`, as each whisper
    is owned by a specific author:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`whisperSchema`模式与`User`有关联，因为每个whisper都属于特定的作者：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see how this relationship takes place in `stores/whisper.js`, as we
    can populate the queries:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `stores/whisper.js` 中看到这种关系是如何发生的，因为我们可以在查询中填充数据：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Password management
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码管理
- en: 'As part of proper password management in the `database.js`, we will use the
    `bcrypt` library, specifically the `pre` middleware, to hash passwords before
    storing them in the database. The `pre` middleware is a function that is triggered
    before we perform a specific action such as a save. You can find great examples
    in the official documentation ([https://mongoosejs.com/docs/middleware.html#pre](https://mongoosejs.com/docs/middleware.html#pre)):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `database.js` 中正确密码管理的一部分，我们将使用 `bcrypt` 库，特别是 `pre` 中间件，在将密码存储到数据库之前对其进行哈希处理。`pre`
    中间件是一个在执行特定操作（如保存）之前被触发的函数。您可以在官方文档([https://mongoosejs.com/docs/middleware.html#pre](https://mongoosejs.com/docs/middleware.html#pre))中找到很好的示例。
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, in the same `database.js` file, we will add a new function to compare
    the saved password of the user with the password that the user is sending in the
    request:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在同一个 `database.js` 文件中，我们将添加一个新的函数来比较用户存储的密码与用户在请求中发送的密码：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That way we can store and compare the password securely, never storing it in
    plain text.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以安全地存储和比较密码，永远不会以纯文本形式存储。
- en: JWT utilities
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT 工具
- en: Our authentication is now done with `jsonwebtoken` library for this purpose.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用 `jsonwebtoken` 库来完成此目的进行身份验证。
- en: 'In the `utils.js` file, we add one function to generate the JWT:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `utils.js` 文件中，我们添加了一个生成 JWT 的函数：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also add another function to parse the JWT; in our case, an Express middleware
    that will parse the JWT and add the user to the request:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个解析 JWT 的函数；在我们的情况下，是一个 Express 中间件，它将解析 JWT 并将用户添加到请求中：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we use the `JWT_SECRET` to sign and verify the JWTs. This environmental
    variable is stored in the `.env` file, so we can change it easily in any environment.
    Also, we set an expiration time of 1 hour for the JWTs, after which time the user
    will need to authenticate again. It is quite common to have short expiration times
    so that if the token did get compromised, the time in which it could be used to
    do harm is limited. This is a very popular secure measurement that can be combined
    with refresh tokens ([https://auth0.com/learn/refresh-tokens](https://auth0.com/learn/refresh-tokens))
    to have an even more solid implementation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `JWT_SECRET` 来签名和验证 JWT。这个环境变量存储在 `.env` 文件中，因此我们可以在任何环境中轻松更改它。此外，我们为
    JWT 设置了 1 小时的过期时间，在此之后，用户将需要再次进行身份验证。短过期时间相当常见，这样如果令牌真的被泄露，它被用于造成伤害的时间就会有限。这是一种非常流行的安全措施，可以与刷新令牌([https://auth0.com/learn/refresh-tokens](https://auth0.com/learn/refresh-tokens))结合使用，以实现更稳健的实现。
- en: If the token has been modified or the secret is not the same, then the `jwt.verify`
    function will throw an error, so we can catch it and return an error to the user.
    The same will happen if the token is expired.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌已被修改或密钥不匹配，那么 `jwt.verify` 函数将抛出错误，因此我们可以捕获它并向用户返回错误。如果令牌已过期，也会发生相同的情况。
- en: If the token is valid, then we will add the user to the request, so we can use
    it in the next middleware or in the route handler.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌有效，我们将用户添加到请求中，这样我们就可以在下一个中间件或路由处理程序中使用它。
- en: This completes the authentication part – we can now authenticate the users in
    our web application! It is important to note that we are not storing any information
    on the server so we can scale our application without any issues, but there are
    some drawbacks to this, as we will explore in [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了身份验证部分——我们现在可以在我们的 Web 应用程序中验证用户了！需要注意的是，我们不会在服务器上存储任何信息，因此我们可以无任何问题地扩展我们的应用程序，但这也存在一些缺点，我们将在[*第15章*](B21678_15.xhtml#_idTextAnchor394)中探讨。
- en: Adding new routes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新路由
- en: 'Now we have all the utilities to implement the authentication, so we can include
    the new routes. In our case, we will include the following routes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了实现身份验证所需的所有工具，因此我们可以包含新的路由。在我们的例子中，我们将包含以下路由：
- en: '`GET /login` to render the login view to the user:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET /login` 向用户渲染登录视图：
- en: '[PRE15]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`POST /login` to process the login request, store the new user, and return
    the JWT:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `POST /login` 处理登录请求，存储新用户，并返回 JWT：
- en: '[PRE16]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`GET /signup` to render the signup view to the user:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET /signup` 向用户渲染注册视图：
- en: '[PRE17]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`POST /signup` to process the signup request and return the JWT:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `POST /signup` 处理注册请求并返回 JWT：
- en: '[PRE18]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we also need to update the routes that require authentication to use
    the `require` **Authentication** middleware and modify the internal logic to ensure
    that the authorizations are properly managed. For example, users shouldn’t be
    able to modify/delete whispers from other users:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们还需要更新需要认证的路由，以使用 `require` **认证** 中间件，并修改内部逻辑以确保授权得到适当管理。例如，用户不应能够修改/删除其他用户的whisper：
- en: '[PRE19]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we use the `requireAuthentication` middleware to ensure that
    the user is authenticated, and then we check that the user is the author of the
    whisper that we are trying to modify. If the user is not the author, then we return
    a `403` `Forbidden` error.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `requireAuthentication` 中间件来确保用户已认证，然后检查用户是否是我们试图修改的whisper的作者。如果用户不是作者，则返回
    `403` `禁止` 错误。
- en: There are other scenarios that we also covered in the tests such as when the
    whisper is not found.In those cases is expected that we to return the proper HTTP
    error code in each case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们还涵盖了其他一些场景，例如当未找到whisper时。在这些情况下，我们预计在每个情况下都应返回适当的HTTP错误代码。
- en: Improved testing utilities
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进的测试工具
- en: We modified the testing utilities to include valid fixtures for the users, so
    we have predefined users that we can use to test the authentication functionality.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了测试工具，包括用户的有效固定值，这样我们就有了预定义的用户，我们可以使用它们来测试认证功能。
- en: Also, we included sample whispers for the tests, so we can use them to test
    the authorization part.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还包含了用于测试的示例whisper，这样我们就可以使用它们来测试授权部分。
- en: And finally, we included some fixtures that include a valid JWT for each user,
    so we can use them to test the authorization part.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们包含了一些包含每个用户有效JWT的固定值，这样我们就可以使用它们来测试授权部分。
- en: You can check the changes in detail in the `tests/utils.js` file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `tests/utils.js` 文件中详细检查更改。
- en: Test case changes
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例更改
- en: Regarding the test cases, we updated them to include the new routes and to test
    the authorization part. You can check the changes in detail in the `tests/server.test.js`
    file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试用例，我们更新了它们以包括新路由并测试授权部分。你可以在 `tests/server.test.js` 文件中详细检查更改。
- en: In general, most of the routes now include specific test cases to test the authorization
    part, ensuring that the authorization is properly managed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，现在大多数路由都包括特定的测试用例来测试授权部分，确保授权得到适当管理。
- en: 'We added test cases for each route to test requests from users that are not
    authenticated:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个路由添加了测试用例来测试未认证用户的请求：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, in some routes, we added test cases to test the authorization part, so
    we can ensure that the authorization is properly managed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些路由中，我们添加了测试用例来测试授权部分，以确保授权得到适当管理：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Overall, many tests were modified to include the JWT with a specific Bearer
    token, in the form of `` .set('Authentication', ` ````Bearer ${firstUser.token}`)``.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，许多测试被修改以包含具有特定Bearer令牌的JWT，形式为 `` .set('Authentication', ` ````Bearer ${firstUser.token}`)``。
- en: Test coverage
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: 'If we run the tests with `npm run test:coverage`, we can see in detail how
    the changes affected the test coverage. If you check the `coverage/lcov-report/index.html`
    file, you can see the details of the coverage:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `npm run test:coverage` 运行测试，我们可以详细看到更改如何影响测试覆盖率。如果你检查 `coverage/lcov-report/index.html`
    文件，你可以看到覆盖的详细信息：
- en: '![Figure 13.8 – Web browser screenshot with the test coverage report](img/B21678_13_8.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 带有测试覆盖率报告的网页浏览器截图](img/B21678_13_8.jpg)'
- en: Figure 13.8 – Web browser screenshot with the test coverage report
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 带有测试覆盖率报告的网页浏览器截图
- en: Overall, the coverage is quite good (between 94-98%), but we can see that we
    have some lines that are not covered. We could improve the tests to cover them,
    but those are edge cases.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，覆盖率相当好（在94-98%之间），但我们可以看到有一些行没有被覆盖。我们可以改进测试以覆盖它们，但这些是边缘情况。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had the opportunity to learn how authentication and authorization
    work in a web application. We implemented the authentication part using JWT and
    the authorization part using a custom middleware.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有机会了解在Web应用程序中认证和授权是如何工作的。我们使用JWT实现了认证部分，使用自定义中间件实现了授权部分。
- en: Additionally, we explored in detail how JWTs work and how to implement them
    in a Node.js application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还详细探讨了JWT的工作原理以及如何在Node.js应用程序中实现它们。
- en: Finally, we added authentication and authorization functionalities to our web
    application, so we can now authenticate users and we can ensure that the users
    can only modify/delete the whispers that they created.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向我们的网络应用添加了身份验证和授权功能，因此我们现在可以验证用户，并确保用户只能修改/删除他们创建的whispers。
- en: In the next chapter, we are going to learn in more detail how to properly manage
    errors in our web application and in any Node.js application or library.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地学习如何正确管理我们的网络应用以及任何Node.js应用或库中的错误。
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Session vs Token Authentication in 100* *Seconds*: [https://www.youtube.com/watch?v=UBUNrFtufWo](https://www.youtube.com/watch?v=UBUNrFtufWo)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*100秒内了解* *Session vs Token Authentication*：[https://www.youtube.com/watch?v=UBUNrFtufWo](https://www.youtube.com/watch?v=UBUNrFtufWo)'
- en: '*Authentication: It’s Easier Than You* *Think*: [https://www.youtube.com/watch?v=h6wBYWWdyYQ](https://www.youtube.com/watch?v=h6wBYWWdyYQ)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份验证：比你想象的要简单*：[https://www.youtube.com/watch?v=h6wBYWWdyYQ](https://www.youtube.com/watch?v=h6wBYWWdyYQ)'
- en: '*JWT Handbook by* *Auth0*: [https://auth0.com/resources/ebooks/jwt-handbook](https://auth0.com/resources/ebooks/jwt-handbook)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JWT 手册》由 *Auth0* 提供*：[https://auth0.com/resources/ebooks/jwt-handbook](https://auth0.com/resources/ebooks/jwt-handbook)*'
- en: '*Auth0 in 100 Seconds // And beyond with a Next.js Authentication* *Tutorial*:
    [https://www.youtube.com/watch?v=yufqeJLP1rI](https://www.youtube.com/watch?v=yufqeJLP1rI)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*100秒了解Auth0 // 以及使用Next.js身份验证教程的进阶*：[https://www.youtube.com/watch?v=yufqeJLP1rI](https://www.youtube.com/watch?v=yufqeJLP1rI)'
