- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Authentication and Authorization with Passport.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how authentication and authorization work in
    a modern web application. We will explore the cryptography behind many security
    mechanisms and will learn how to implement these concepts in our web applications
    using **JSON Web Tokens** (**JWT**). We will also see how we can extend our authentication
    strategies with third-party providers such as Facebook or Spotify with Passport.js.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we will implement authentication and authorization
    in our web application project iterating over the code that we generated in the
    previous chapter. We will also learn how to specifically test them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How authentication and authorization work in a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use JWT to authenticate users in our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cryptography basics that we need to know to understand modern authentication
    and authorization mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Passport.js works and how to use it to implement authentication with third-party
    providers such as Facebook or Spotify in our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add authentication and authorization layers to any web project using
    JWT and Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow this chapter, the following are some recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: You should be familiar with the code that we generated in the previous chapter,
    as this is an iteration of the code that we generated
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 20.11.0 installed on your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code editor such as Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have Docker set up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser such as Chrome or Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/mdE5eXS5enM](https://youtu.be/mdE5eXS5enM)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** and **authorization** are two different concepts that are
    often confused. Authentication involves confirming the identity of a user, whereas
    authorization involves verifying the specific access privileges they possess.
    In this chapter, we will explore how to implement both concepts in our web application
    in the *Adding authentication and authorization to our web* *application* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the big challenges of the HTTP protocol is that it is stateless. This
    means that the server does not keep any information about the client. Each request
    is independent, so we need to design and provide mechanisms that allow us to know
    who the user performing the request is. This is the main goal of the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to implement authentication in a web application. The most
    common way is to use a username and password, and there are many libraries that
    can help us to implement this mechanism as well as different approaches to follow.
  prefs: []
  type: TYPE_NORMAL
- en: We can delegate most of it to a third-party provider such as *Auth0* or we can
    implement it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to implement authentication in our web
    application using the *Passport.js library* and *JSON Web* *Tokens (JWT)*.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to implement a clear way to determine whether a user is authorized to
    perform a certain action, such as creating a new post or deleting an old post.
    Even something as simple as accessing a certain page requires us to implement
    a way to determine whether the user is authorized to access it.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite common that a lot of effort is put into the authentication part,
    but the authorization aspect gets forgotten about. Historically, web systems were
    less complex at the beginning of the internet and we didn’t have a lot of roles
    assigned to each user, so we tended to focus more on who you are rather than whether
    you should be able to do certain actions. Today, it is quite common to build complex
    systems that end up having access control tables that define the relationships
    between the actions and the roles. As an example, we can take as a reference the
    Role-based Authorization Strategy plugin for Jenkins, described in *Figure 13**.1*.
    Using this, we can easily understand and update relationships between the roles
    and the potential activities to be performed. For example, the **builder** role
    can cancel jobs but not configure them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Web browser screenshot from https://github.com/jenkinsci/role-strategy-plugin,
    available under the MIT license](img/B21678_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Web browser screenshot from [https://github.com/jenkinsci/role-strategy-plugin](https://github.com/jenkinsci/role-strategy-plugin),
    available under the MIT license
  prefs: []
  type: TYPE_NORMAL
- en: Failing to properly consider authorization is a very common mistake that can
    lead to severe security issues. For example, if we forget to implement the authorization
    part, we can end up with a web application that allows any user to access any
    page, or to perform any action. This is a very dangerous situation that can lead
    to security risks.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore this topic in practical terms in the *Adding authentication
    and authorization to our web application* section of this chapter, seeing how
    to implement an appropriate authorization strategy in our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of the differences between authentication
    and authorization, let’s explore how to implement them in our web application.
    In the next section, we will learn how we can use JWT to authenticate users in
    our web application.
  prefs: []
  type: TYPE_NORMAL
- en: JWT in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most popular ways to implement authentication in a web application
    is to use JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s see some definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Token is a proposed internet standard for creating data with optional
    signature and/or optional encryption whose payload holds JSON that asserts some
    number of claims. The tokens are signed either using a private secret or a public/private
    key.
  prefs: []
  type: TYPE_NORMAL
- en: (JSON Web Token, [https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token))
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens are an open, industry-standard RFC 7519 method for representing
    claims securely between two parties.
  prefs: []
  type: TYPE_NORMAL
- en: (JWT, [https://jwt.io/](https://jwt.io/))
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, a **JWT** is a string (*JSON*) that contains information (*claims*)
    and is signed using a secret key. This process ensures that the information within
    the JWT remains secure and tamper-proof, allowing for verification during subsequent
    requests. Although this may seem like a straightforward concept, delving deeper
    reveals a multitude of intricacies and considerations that must be understood
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s list some of the most critical features that we expect to be supported
    to understand the underlying complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: Anyone can send a request to our server, so we cannot trust any request by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone can try to manipulate the request, so we need to implement a mechanism
    that allows us to verify that the request has not been manipulated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to implement a mechanism that allows us to verify the request without
    the need to store any information on the server. That way we can scale our application
    without any issues and can even use the same JWT across multiple servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In plain terms, the user will authenticate using a username and password, and
    then the server will return a JWT. The user will send the JWT in every request
    and the server will verify the JWT to authenticate the user.
  prefs: []
  type: TYPE_NORMAL
- en: The theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JWT is a string with information about the user (such as their name, role,
    etc.) and is signed using a secret key. So, the server can verify the JWT using
    the secret key and can then extract the information about the user. Any attempt
    to modify the JWT will invalidate the signature, so the server will reject the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to properly sign the tokens, first we need to understand the basics
    of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the JWT work, we need to understand two things: hashing and signing.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hashing** is a process that takes a string and returns a fixed-length string.
    This algorithm works as a one-way function, so we can hash a string, but we cannot
    get the original string from the hash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of hashing a string using the `SHA256` algorithm in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will use this algorithm to hash the password of the user later on in this
    chapter, in the *Adding authentication and authorization to our web* *application*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Signing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Signing** is a process that takes a string and a secret key and returns a
    new string. This algorithm works as a two-way function, so we can sign a string
    and then we can verify the signature using the secret key.'
  prefs: []
  type: TYPE_NORMAL
- en: Wide use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern of using hashing and signing is very common across many different
    software fields. As an example, when a new Node.js version is released, the Node.js
    team will publish the hash of every binary file. This allows us to download the
    binary file and then verify the hash of the file using the hash that the Node.js
    team published. If the hashes are the same, then we can be sure that the file
    has not been modified.
  prefs: []
  type: TYPE_NORMAL
- en: The hash file is signed prior to publishing it, so we can verify the signature
    using the public key of the Node.js team members. If the signature is valid, then
    we can be sure that the hash file has not been modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following link is the file shasum for Node v20.11.0 ([https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc](https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc)).
    The following code block is the content of the file (redacted for space) to understand
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the file contains two parts (the message and the signature)
    and uses `-----BEGIN PGP SIGNED MESSAGE-----` to `-----BEGIN PGP SIGNATURE-----`.
    This helps us to verify the authenticity of the file – basically, we can verify
    that a Node.js releaser has created this file and the content has not been manipulated,
    even if the server from which the file was downloaded was compromised.
  prefs: []
  type: TYPE_NORMAL
- en: The message itself contains the hash of every binary file, so we can download
    the `node-v20.11.0-aix-ppc64.tar.gz` file and check that the content of the file
    is the same as the hash published in the message, `f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f`.
    If the hash is the same, then we can be sure that the file has not been modified.
    This allows us to distribute information securely.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: With JWT, we will use a similar pattern, but instead of PGP, we will use a different
    algorithm to sign the content. You can find the list of supported algorithms in
    RFC 7518 ([https://tools.ietf.org/html/rfc7518#section-3.1](https://tools.ietf.org/html/rfc7518#section-3.1)).
  prefs: []
  type: TYPE_NORMAL
- en: JWT structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JWT is a string that is composed of three parts separated by a dot. Each part
    is encoded in *base64*. The three parts are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: Contains information about the type of token and the algorithm
    used to sign the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: Contains the claims (information) that we want to store in the
    token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: Contains the signature of the token that is used to verify the
    token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature is the result of signing the header and the payload using the
    secret key. The best part is that we can verify the signature using the secret
    key, so we can verify the token without needing to store any information on the
    server. Additionally, the information is encoded in base64, so anyone can decode
    it and read it, but we cannot modify it.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to mention is that you should never store sensitive information
    in the payload, as anyone can decode it and read it. This includes users’ passwords
    and bank account details, among other sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: JWT.io
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best tools to work with JWT is the JWT Debugger ([https://jwt.io/](https://jwt.io/))
    (see *Figure 13**.2*). This website allows us to encode and decode JWTs, as well
    as to verify the signature of the token. You can use it to play with or debug
    your JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Web browser screenshot showing how to digest and validate an
    encoded token](img/B21678_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Web browser screenshot showing how to digest and validate an encoded
    token
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with it and explore how it works before moving to the next
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how Passport.js works and how it can be used
    to implement authentication with third-party providers such as Facebook or Spotify
    in our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Passport.js fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Passport.js** is a fantastic library, widely used to implement authentication
    in Node.js applications. The official website of Passport.js defines the library
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Passport is authentication middleware for Node.js. Extremely flexible and modular,
    Passport can be unobtrusively dropped in to any Express-based web application.
    A comprehensive set of strategies support authentication using a username and
    password, Facebook, Twitter, and more.
  prefs: []
  type: TYPE_NORMAL
- en: (Passport.js, [http://www.passportjs.org/](http://www.passportjs.org/))
  prefs: []
  type: TYPE_NORMAL
- en: In essence, Passport.js is a middleware ([https://expressjs.com/en/guide/using-middleware.html](https://expressjs.com/en/guide/using-middleware.html))
    that we will include in our Express application to provide many different strategies
    to implement authentication. Having a selection of such strategies allows us to
    choose the one that best fits our needs. We can use the library to easily implement
    social login functionality (such as Facebook, Twitter, Spotify, GitHub, and much
    more in more than 500 strategies) and the typical username/password login.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will iterate the code from our web application to include
    authentication and authorization mechanisms using what we have learned in this
    chapter so far.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication and authorization to our web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add authentication and authorization to our web application.
    We will use the jsonwebtoken library to implement the authentication part and
    will use a custom middleware to implement the authorization part.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the base project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The authentication and authorization additions are not very complex, but it
    is quite long to follow with ease, so for this chapter you can download the project
    from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step4` folder. The implementation is ready to go, but I will comment
    on the most relevant changes that we made since the last chapter (`step3` folder)
    so you can easily follow what we’ve done.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first steps are to explore the folder, install the dependencies, configure
    the environment, and start the infrastructure. This can be performed by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the dependencies with `npm i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the secrets, adding the `.env` file in the root folder with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run `npm run infra:stop && npm` `run infra:start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the infrastructure and configuration are ready, but before we start making
    more changes to the application, it is recommended to run some tests.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need to run some tests to ensure that the code is working as expected
    by typing `npm run test` in our terminal.
  prefs: []
  type: TYPE_NORMAL
- en: New tests added
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can see that we have a few new routes related to login/signup and specific
    tests for them. When we execute the tests, we will see that the test messages
    (descriptions) are clear and self-explanatory in terms of what the routes are
    expected to do and what we aim to do with the test, even if we are not yet familiar
    with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Terminal screenshot that showcases how the routes are tested](img/B21678_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Terminal screenshot that showcases how the routes are tested
  prefs: []
  type: TYPE_NORMAL
- en: We should recognize these tests as we worked on these routes in the previous
    chapters. But if we keep scrolling through the test output, we should see that
    new tests have been added as well.
  prefs: []
  type: TYPE_NORMAL
- en: Updated tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous tests have been updated to include new test cases related to authentication
    for the routes that require authentication with JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Terminal screenshot shows the tests passing and how easy is
    to follow what is being tested with the descriptions](img/B21678_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Terminal screenshot shows the tests passing and how easy is to
    follow what is being tested with the descriptions
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the use cases in the tests cover more scenarios related to authentication
    and authorization, such as `Should return 401 when the user is not authenticated`
    and `Should return a 403 when the user is not` `the author`.
  prefs: []
  type: TYPE_NORMAL
- en: The UI changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But overall, the most significant changes are related to the UI, as now we have
    new routes and views to login/register and so on. So we can start the application
    by running `npm` `run start`
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can enter your credentials to log in at `http://localhost:3000/login`, upon
    which the backend API will return a JWT that you can use to authenticate for any
    CRUD operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Web browser screenshot showing the login page where the user
    can enter their username and password](img/B21678_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Web browser screenshot showing the login page where the user can
    enter their username and password
  prefs: []
  type: TYPE_NORMAL
- en: Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a new account whenever you please at `http://localhost:3000/signup`.
    This operation will generate a new user in the database and the backend will return
    you a JWT that you can use to perform CRUD operations and authenticate yourself
    against the API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Web browser screenshot showing where the user can create a
    new account or log in with existing credentials](img/B21678_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Web browser screenshot showing where the user can create a new
    account or log in with existing credentials
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The server has defined certain rules regarding username, email and password.
    So, as an example you can use the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: `nodejs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Email: `demo@demo.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Password: `aA1#dt$tu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As remarked on in the previous section, it is important to understand how authorization
    works. So, here are the rules for our business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Any logged user can see all the whispers available on the Whispering platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can modify or delete only the whispers that you have created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These clear rules will help us to build an authorization system that will cover
    all the scenarios, so, for example, you won’t be able to delete a whisper created
    by another user. In some applications, this approach can be very complex, such
    as with Google Drive or Facebook. In those scenarios, it is quite useful to have
    a permission matrix in place and well documented. GitLab offers a great example
    ([https://docs.gitlab.com/ee/user/permissions.html](https://docs.gitlab.com/ee/user/permissions.html))
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Web browser screenshot showing the main page with all the whispers
    and the buttons to interact with them from the UI](img/B21678_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Web browser screenshot showing the main page with all the whispers
    and the buttons to interact with them from the UI
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can modify only the whispers that we created but the option
    is not visually available for other whispers.
  prefs: []
  type: TYPE_NORMAL
- en: While the UI is a key factor in managing authorization, we need to ensure that
    the backend is also properly managing authorization on its part, so it won’t allow
    the users to modify or delete whispers from other users. To ensure that the application
    is capable of preventing these scenarios (like modify other’s users whispers)
    it is highly recommended to add specify test case. Check the test suite cases,
    as we have already included these scenarios that cover the `403` `Forbidden` response.
  prefs: []
  type: TYPE_NORMAL
- en: Added dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have included the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bcrypt** ([https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt)):
    This is a library that will help us to store passwords safely in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jsonwebtoken** ([https://www.npmjs.com/package/jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)):
    This is a utility that helps us to generate and parse the JWTs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validator** ([https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator)):
    This is a library that we use to validate strings. Basically, we can use it to
    sanitize the inputs received from the users, including email addresses, URLs,
    phone numbers, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These dependencies will be used later in order to properly build our application.
    It is quite common in Node.js projects to rely on third-party libraries. The most
    important thing to remember is to be sure that we are using good-quality external
    dependencies without known vulnerabilities, as we learned in [*Chapter 6*](B21678_06.xhtml#_idTextAnchor171)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We added a new file called `public/auth.js` to manage the form submissions
    while the user logs in or registers with the platform. After sending the requests,
    we will store the JWT in the local storage, so we can recover the JWT easily even
    if we refresh the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the previous changes, we now send the user and password to the `/login`
    route using the `POST` HTTP method. As a response, we expect JSON data that will
    contain the access token that we will store in the local storage in order to keep
    session persistence in case the user refreshes the page. Finally, we will redirect
    the user to the home page as the authentication has been completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added the JWT to every request made against the API for any CRUD operation
    in `public/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, every request includes the `Authentication` header with the
    `Bearer TOKEN` value, which is the expected way to authenticate against the backend.
    We also use the JWT to get the user’s name and display it in the UI in the Whispers
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we disabled the edit/delete buttons from the Whisper view if the current
    user is not the user that created them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `controlEdition` function can hide/show the actions depending on the author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are clear on the changes made in the frontend part, it is time to
    jump to the backend part and review the changes needed in order to properly manage
    the users’ authentication data in the databases. We’ll start with the changes
    in the stores.
  prefs: []
  type: TYPE_NORMAL
- en: Added a new store for users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most relevant changes were added to the `database.js` file, where a new
    schema was added for the users. We now include more advanced validations and transformations.
    The user has `username`, `email`, and `password` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `password`, we include an additional validation with a new function
    that we added to the utilities file, `utils.js`. This new function uses a regular
    expression to validate the password strength (a minimum of eight characters, at
    least one letter, one number, and one special character):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `whisperSchema` schema has a relation with `User`, as each whisper
    is owned by a specific author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how this relationship takes place in `stores/whisper.js`, as we
    can populate the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Password management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As part of proper password management in the `database.js`, we will use the
    `bcrypt` library, specifically the `pre` middleware, to hash passwords before
    storing them in the database. The `pre` middleware is a function that is triggered
    before we perform a specific action such as a save. You can find great examples
    in the official documentation ([https://mongoosejs.com/docs/middleware.html#pre](https://mongoosejs.com/docs/middleware.html#pre)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in the same `database.js` file, we will add a new function to compare
    the saved password of the user with the password that the user is sending in the
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That way we can store and compare the password securely, never storing it in
    plain text.
  prefs: []
  type: TYPE_NORMAL
- en: JWT utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our authentication is now done with `jsonwebtoken` library for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `utils.js` file, we add one function to generate the JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add another function to parse the JWT; in our case, an Express middleware
    that will parse the JWT and add the user to the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `JWT_SECRET` to sign and verify the JWTs. This environmental
    variable is stored in the `.env` file, so we can change it easily in any environment.
    Also, we set an expiration time of 1 hour for the JWTs, after which time the user
    will need to authenticate again. It is quite common to have short expiration times
    so that if the token did get compromised, the time in which it could be used to
    do harm is limited. This is a very popular secure measurement that can be combined
    with refresh tokens ([https://auth0.com/learn/refresh-tokens](https://auth0.com/learn/refresh-tokens))
    to have an even more solid implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If the token has been modified or the secret is not the same, then the `jwt.verify`
    function will throw an error, so we can catch it and return an error to the user.
    The same will happen if the token is expired.
  prefs: []
  type: TYPE_NORMAL
- en: If the token is valid, then we will add the user to the request, so we can use
    it in the next middleware or in the route handler.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the authentication part – we can now authenticate the users in
    our web application! It is important to note that we are not storing any information
    on the server so we can scale our application without any issues, but there are
    some drawbacks to this, as we will explore in [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).
  prefs: []
  type: TYPE_NORMAL
- en: Adding new routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have all the utilities to implement the authentication, so we can include
    the new routes. In our case, we will include the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /login` to render the login view to the user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`POST /login` to process the login request, store the new user, and return
    the JWT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GET /signup` to render the signup view to the user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`POST /signup` to process the signup request and return the JWT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we also need to update the routes that require authentication to use
    the `require` **Authentication** middleware and modify the internal logic to ensure
    that the authorizations are properly managed. For example, users shouldn’t be
    able to modify/delete whispers from other users:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we use the `requireAuthentication` middleware to ensure that
    the user is authenticated, and then we check that the user is the author of the
    whisper that we are trying to modify. If the user is not the author, then we return
    a `403` `Forbidden` error.
  prefs: []
  type: TYPE_NORMAL
- en: There are other scenarios that we also covered in the tests such as when the
    whisper is not found.In those cases is expected that we to return the proper HTTP
    error code in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Improved testing utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We modified the testing utilities to include valid fixtures for the users, so
    we have predefined users that we can use to test the authentication functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we included sample whispers for the tests, so we can use them to test
    the authorization part.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we included some fixtures that include a valid JWT for each user,
    so we can use them to test the authorization part.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the changes in detail in the `tests/utils.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Test case changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regarding the test cases, we updated them to include the new routes and to test
    the authorization part. You can check the changes in detail in the `tests/server.test.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In general, most of the routes now include specific test cases to test the authorization
    part, ensuring that the authorization is properly managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added test cases for each route to test requests from users that are not
    authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in some routes, we added test cases to test the authorization part, so
    we can ensure that the authorization is properly managed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Overall, many tests were modified to include the JWT with a specific Bearer
    token, in the form of `` .set('Authentication', ` ````Bearer ${firstUser.token}`)``.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we run the tests with `npm run test:coverage`, we can see in detail how
    the changes affected the test coverage. If you check the `coverage/lcov-report/index.html`
    file, you can see the details of the coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Web browser screenshot with the test coverage report](img/B21678_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Web browser screenshot with the test coverage report
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the coverage is quite good (between 94-98%), but we can see that we
    have some lines that are not covered. We could improve the tests to cover them,
    but those are edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to learn how authentication and authorization
    work in a web application. We implemented the authentication part using JWT and
    the authorization part using a custom middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored in detail how JWTs work and how to implement them
    in a Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added authentication and authorization functionalities to our web
    application, so we can now authenticate users and we can ensure that the users
    can only modify/delete the whispers that they created.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn in more detail how to properly manage
    errors in our web application and in any Node.js application or library.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Session vs Token Authentication in 100* *Seconds*: [https://www.youtube.com/watch?v=UBUNrFtufWo](https://www.youtube.com/watch?v=UBUNrFtufWo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authentication: It’s Easier Than You* *Think*: [https://www.youtube.com/watch?v=h6wBYWWdyYQ](https://www.youtube.com/watch?v=h6wBYWWdyYQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JWT Handbook by* *Auth0*: [https://auth0.com/resources/ebooks/jwt-handbook](https://auth0.com/resources/ebooks/jwt-handbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Auth0 in 100 Seconds // And beyond with a Next.js Authentication* *Tutorial*:
    [https://www.youtube.com/watch?v=yufqeJLP1rI](https://www.youtube.com/watch?v=yufqeJLP1rI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
