- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Design Patterns – The Functional Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, we saw
    several functional techniques to solve different problems. However, programmers
    used to employing OOP may find that we have missed some well-known formulas and
    solutions often used in imperative coding. Since design patterns are well known,
    and programmers will likely already be aware of how they are applied in other
    languages, it’s important to look at how a functional implementation would be
    done.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we shall consider the solutions provided by **design patterns**
    that are common in OOP, to see their equivalent in FP. This will help you transition
    from OOP to a more functional approach and learn more about FP’s power and methods,
    by seeing alternative solutions to problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will study the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of *design patterns* and what they apply to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few OOP standard patterns and what alternatives we have in FP if we need one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Observer* pattern, which leads to *reactive programming*, a declarative
    way of dealing with events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FP design patterns, not related to the OOP ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we won’t be worrying much about typing and TypeScript because
    we’ll want to focus on the patterns, minimizing and abstracting everything else.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most relevant books in software engineering is *Design Patterns:
    Elements of Reusable Object-Oriented Software* (1994), written by the **Gang of
    Four** (**GoF**) – Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.
    This book presented about two dozen OOP patterns and has been recognized as highly
    important in computer science.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Patterns* are actually a concept in architectural design, originally defined
    by an architect, Christopher Alexander. Still, in software terms, a *design pattern*
    is a generally applicable, reusable solution to a commonly-seen problem in software
    design. Rather than a specific finished and coded design, it’s a description of
    a solution (the word *template* is also used) that can solve a given problem that
    appears in many contexts. Given their advantages, design patterns are best practices
    that can be used by developers working with different kinds of systems, programming
    languages, and environments.'
  prefs: []
  type: TYPE_NORMAL
- en: The GoF book obviously focused on OOP, and some patterns within cannot be recommended
    for or applied in FP. Other patterns are unnecessary or irrelevant because functional
    languages already provide standard solutions to the corresponding object-oriented
    problems. Even given this difficulty, since most programmers have been exposed
    to OOP design patterns and usually try to apply them even in other contexts such
    as FP, it makes sense to consider the original problems and then take a look at
    how a new solution can be produced. The standard object-based solutions may not
    apply, but the problems can still stand, so seeing how to solve them is still
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns are often described in terms of four essential, basic elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple, short *name,* used to describe the problem, its solutions, and its
    consequences. The name helps when talking with colleagues, explaining a design
    decision, or describing a specific implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *context* to which the pattern applies – specific situations that require
    a solution, possibly with additional conditions that must be met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *solution* that lists the elements (classes, objects, functions, relationships,
    and so on) that you’ll need to solve the given situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *consequences* (results and trade-offs) if you apply the pattern. You may
    derive some gains from the solution, but it may also imply some losses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will assume that you are already aware of the design patterns
    we will describe and use, so we will only provide a few details about them. Rather,
    we will focus on how FP either makes a problem irrelevant (because there is an
    obvious way of applying functional techniques to solve it) or solves it in some
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we won’t be going over all of the GoF patterns; we’ll just focus on the
    ones that are the most interesting, that is, those that bring out more differences
    when FP is applied compared to when OOP is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to their focus, design patterns are usually grouped into several
    distinct categories. The first three in the following list are the ones that appeared
    in the original GoF book, but more categories have since been added. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavioral design patterns** have to do with interactions and communications
    between objects. Rather than focusing on how objects are created or built, the
    key consideration is how to connect them so that they can cooperate when performing
    a complex task, preferably in a way that provides well-known advantages, such
    as diminished coupling or enhanced cohesiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creational design patterns** deal with ways to create objects in a manner
    suitable for the current problem. With them, you can decide between several alternative
    objects, so the program can work differently, depending on parameters that may
    be known at compilation time or runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural design patterns** have to do with the composition of objects,
    forming larger structures from many individual parts and implementing relationships
    between objects. Some of the patterns imply inheritance or implementation of interfaces,
    whereas others use different mechanisms, all geared toward being able to dynamically
    change the way objects are composed at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency patterns** deal with multithreaded programming. Although FP is
    generally quite appropriate for this (given, for example, the lack of assignments
    and side effects), since we are working with JavaScript, these patterns are not
    very relevant to us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architectural patterns** are more high-level oriented, with a broader scope
    than the previous patterns we’ve listed, and provide general solutions to software
    architecture problems. As is, we aren’t considering such problems in this book,
    so we won’t deal with these either.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The categories are not really fixed or set in stone. Fifteen years after the
    original GoF book, three of its authors (see the *Design Patterns 15 Years Later:
    An Interview with Erich Gamma, Richard Helm, and Ralph Johnson* article at [www.informit.com/articles/article.aspx?p=1404056](http://www.informit.com/articles/article.aspx?p=1404056))
    suggested a new list of categories – *Core*, *Creational* (similar to the original
    category, but adding the *Dependency Injection* pattern, which we’ll study later
    on), *Peripheral*, and *Other*.'
  prefs: []
  type: TYPE_NORMAL
- en: Old good practices
  prefs: []
  type: TYPE_NORMAL
- en: Coupling and cohesiveness are terms that were in use even before OOP came into
    vogue; they date back to the late 1960s when the *Structured Design* book by Larry
    Constantine came out. Coupling measures the interdependence between any two modules,
    and cohesiveness has to do with the degree to which all module components really
    belong together. Low coupling and high cohesiveness are worthy goals for software
    design because they imply that related things are nearby and unrelated ones are
    separate.
  prefs: []
  type: TYPE_NORMAL
- en: Following along these lines, you could also classify design patterns as *object
    patterns* (which concern the dynamic relationships between objects) and *class
    patterns* that deal with the relationships between classes and subclasses (which
    are defined statically at compile time). We won’t be worrying much about this
    classification because our point of view has more to do with behaviors and functions,
    rather than classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we can now readily observe that these categories are heavily
    oriented toward OOP, and the first three directly mention objects. However, without
    the loss of generality, we will look beyond the definitions, remember what problem
    we were trying to solve, and then look into analogous solutions with FP, which,
    if not 100% equivalent to the OOP ones, will in spirit solve the same problem
    in a parallel way. Let’s move on and start by considering why we want to deal
    with patterns at all!
  prefs: []
  type: TYPE_NORMAL
- en: Do we need design patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interesting point of view says that design patterns are only needed to patch
    the shortcomings of programming languages. The rationale is that if you can solve
    a problem with a given programming language in a simple, direct, and straightforward
    way, then you may not need a design pattern at all. (For example, if your language
    doesn’t provide recursion, you would have to implement it on your own; otherwise,
    you can just use it without further ado.) However, studying patterns lets you
    think about different ways of solving problems, so that’s a point in their favor.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it’s interesting for OOP developers to understand why FP helps
    solve some problems without needing further tools. In the next section, we shall
    consider several well-known design patterns and examine why we don’t need them
    or how we can easily implement them. It’s also a fact that we have already applied
    several patterns earlier in the text, so we’ll also point out those examples.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t try, however, to express or convert all design patterns into FP terms.
    For example, the Singleton pattern basically requires a single, global object,
    which is sort of opposed to everything that functional programmers are used to.
    Given our approach to FP (remember *Sorta Functional Programming* (SFP), from
    the first chapter of this book?), we won’t mind either, and if a Singleton is
    required, we may consider using it, even though FP doesn’t have an appropriate
    equivalent. (And, as we’ll see soon enough, every time you import from a module
    you’re using a Singleton!)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it must be said that our point of view may affect what is considered
    a pattern and what isn’t. What may be a pattern to some may be considered a trivial
    detail for others. We will find some such situations, given that FP lets us solve
    some particular problems in easy ways, and we have already seen examples of that
    in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll review some of the GoF design patterns, check whether
    they are pertinent to FP, and study how to implement them. Of course, some design
    patterns don’t get an FP solution. As an example, there’s no equivalent for a
    Singleton, which implies the foreign concept of a globally accessed object. Additionally,
    while it’s true that you may no longer need OOP-specific patterns, developers
    will still think in terms of those. Also, since we’re not going fully functional,
    if some OOP pattern fits, why not use it even if it’s not fully functional?
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be considering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Façade** and **Adapter** to provide new interfaces to other code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator** (also known as **Wrapper**) to add new functionality to existing
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**, **Template**, and **Command** to let you fine-tune algorithms
    by passing functions as parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Injection** to help in decoupling components and simplify testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**, which leads to reactive programming, a declarative way of dealing
    with events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other patterns that do not so fully match the corresponding OOP ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin our study by analyzing a couple of similar patterns that let you
    use your code in somewhat different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Facade and Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out of these two patterns, let’s start with the Facade or, more correctly, Façade.
    This is meant to solve the problem of providing a different interface to the methods
    of a class or to a library. The idea is to provide a new interface to a system
    that makes it easier to use. You might say that a Façade provides a better control
    panel to access certain functionalities, removing difficulties for the user.
  prefs: []
  type: TYPE_NORMAL
- en: S or K?
  prefs: []
  type: TYPE_NORMAL
- en: '*Façade* or *facade*? The original word is an architectural term meaning *the
    front of a building* and comes from the French language. According to this source
    and the usual sound of the cedilla (ç) character, its pronunciation is a bit like
    *fuh-sahd*. The other spelling probably has to do with the lack of international
    characters in keyboards and poses the following problem – shouldn’t you read it
    as *fah-Kade*? You may see this problem as the reverse of *Celtic*, which is pronounced
    as *Keltic*, changing the *s* sound to a *k* sound.'
  prefs: []
  type: TYPE_NORMAL
- en: The main problem we want to solve is using external code more easily. (Of course,
    if it were your code, you could handle such problems directly; we must assume
    you cannot – or shouldn’t – Insert space try to modify that other code. This would
    be the case when you use any library available over the web, for example.) The
    key is to implement a module that will provide an interface that better suits
    your needs. Your code will use your module and won’t directly interact with the
    original code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to do Ajax calls, and your only possibility is using
    some hard library with a really complex interface. With modules, you might write
    something like the following, working with an imagined, hard-to-use Ajax library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you need to do `GET` or `POST`, instead of having to go through all
    of the complications of the provided complex Ajax library, you can use the new
    façade that provides a simpler way of working. Developers would write `import
    {getUrl, postUrl} from "simpleAjax"` and work more reasonably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, with `import`/`export` support in browsers, code will work as shown
    previously. Before that (or for backward-compatibility reasons) the implementation
    would require the usage of an **Immediately Invoked Function Expression** (**IIFE**),
    as covered in the *Immediate invocation* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, using a **revealing module** pattern. The way to
    implement the pattern would then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the *revealing module* name should now be apparent. With the
    preceding code, because of the JavaScript scope rules, the only visible attributes
    of `simpleAjax` will be `simpleAjax.getUrl` and `simpleAjax.postUrl`; using an
    IIFE lets us implement the module (and, hence, the façade) safely, making implementation
    details private.
  prefs: []
  type: TYPE_NORMAL
- en: Of modules and singletons
  prefs: []
  type: TYPE_NORMAL
- en: In modern JavaScript, modules are a case of the Singleton pattern. (In math,
    a “singleton” is a set with just one element.) If you import a module in several
    different places of your code, all references will be to the same object, precisely
    as the Singleton pattern requires in object-oriented code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the Adapter pattern is similar, insofar as it is also meant to define a
    new interface. However, while Façade defines a new interface to old code, Adapter
    is used when you need to implement an old interface for new code, so it will match
    what you already have. If you are working with modules, it’s clear that the same
    type of solution that worked for Façade will work here, so we don’t have to study
    it in detail. Now, let’s continue with a well-known pattern, which we saw earlier
    in this book!
  prefs: []
  type: TYPE_NORMAL
- en: Decorator or Wrapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator pattern (also known as Wrapper) is useful when you want to add
    additional responsibilities or functionalities to an object in a dynamic way.
    Let’s consider a simple example, which we will illustrate with some React code.
    (Don’t worry if you do not know this framework; the example will be easy to understand.
    The idea of using React is because it can take advantage of this pattern very
    well. Also, we have already seen pure JavaScript higher-order function examples,
    so it’s good to see something new.) Suppose we want to show some elements on the
    screen, and for debugging purposes, we want to show a thin red border around an
    object. How can you do it?
  prefs: []
  type: TYPE_NORMAL
- en: If you were using OOP, you would have to create a new subclass with the extended
    functionality. For this particular example, you might provide some attribute with
    the name of some CSS class that would provide the required style, but let’s keep
    our focus on OOP; using CSS won’t always solve this software design problem, so
    we want a more general solution. The new subclass would know how to show itself
    with a border, and you’d use this subclass whenever you wanted an object’s border
    to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: With our experience with higher-order functions, we can solve this differently
    by *wrapping* the original function within another one, which would provide extra
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have already seen some examples of wrapping in the *Wrapping functions
    – keeping behavior* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*. For example, in that section, we saw how to wrap functions
    to produce new versions that could log their input and output, provide timing
    information, or even memorize calls to avoid future delays. On this occasion,
    we are applying the concept to decorate a visual component, but the principle
    remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a simple React component, `ListOfNames`, that can display a heading
    and a list of people, and for the latter, we will use a `FullNameDisplay` component.
    The code for those elements would be as shown in the following fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListOfNames` component uses mapping to create a `FullNameDisplay` component
    to show data for each person. The logic for our application could then be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Do as I say...
  prefs: []
  type: TYPE_NORMAL
- en: In real life, you wouldn’t put all the code for every component in the same
    single source code file – and you would probably have a few CSS files. However,
    for our example, having everything in one place and using inline styles is enough,
    so bear with me and keep in mind the saying *“Do as I say, not as* *I do.”*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly test the result in the online React sandbox at [codesandbox.io/](http://codesandbox.io/);
    google `react online sandbox` if you want other options. The interface design
    isn’t much to talk about (so please don’t criticize my poor web page!) because
    we are interested in design patterns right now; refer to *Figure 11**.1*, given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The original version of our components shows a (not much to
    speak about) list of names](img/Figure_11.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The original version of our components shows a (not much to speak
    about) list of names
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, inline components are written in JSX (inline HTML style) and compiled
    into objects, which are later transformed into HTML code to be displayed. Whenever
    the `render()` method is called, it returns a structure of objects. So, we will
    write a function that will take a component as a parameter and return a new JSX,
    a wrapped object. In our case, we’d like to wrap the original component within
    `<div>` with the required border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you wish, you can make this function aware of whether it’s executing in development
    mode or production; in the latter case, it would simply return the original component
    argument without any change, but let’s not worry about that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to change `ListOfNames` to use wrapped components; the new version
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorated version of the code works as expected: each of the `ListOfNames`
    components is now wrapped in another component that adds the desired border to
    them; refer to *Figure 11**.2*, given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The decorated ListOfNames component is still nothing much to
    look at, but now it shows an added border](img/Figure_11.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The decorated ListOfNames component is still nothing much to look
    at, but now it shows an added border
  prefs: []
  type: TYPE_NORMAL
- en: In earlier chapters, we saw how to decorate a function, wrapping it inside of
    another function, so it would perform extra code and add a few functionalities.
    Here, we saw how to apply the same solution style to provide a *higher-order component*
    (as it’s called in React parlance), wrapped in an extra `<div>` to provide some
    visually distinctive details.
  prefs: []
  type: TYPE_NORMAL
- en: A Redux decorator
  prefs: []
  type: TYPE_NORMAL
- en: If you have used Redux and the `react-redux` package, you may note that the
    latter’s `connect()` method is also a decorator in the same sense; it receives
    a component class, and returns a new component class, connected to the store,
    for usage in your forms. Refer to [github.com/reduxjs/react-redux](http://github.com/reduxjs/react-redux)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move to a different set of patterns that will let us change how functions
    perform.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy, Template, and Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strategy pattern applies whenever you want to have the ability to change
    a class, method, or function, possibly in a dynamic way, by changing the way it
    actually does whatever it’s expected to do. For example, a GPS application might
    want to find a route between two places by applying different strategies if the
    person is on foot, rides a bicycle, or goes by car. In that case, the fastest
    or the shortest routes might be desired. The problem is the same, but different
    algorithms must be applied, depending on the given condition.
  prefs: []
  type: TYPE_NORMAL
- en: Does this sound familiar? If so, it is because we have already met a similar
    problem. When we wanted to sort a set of strings in different ways, in [*Chapter
    3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*, we needed
    a way to specify how the ordering was to be applied or, equivalently, how to compare
    two given strings and determine which had to go first. Depending on the language,
    we had to sort applying different comparison methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before trying an FP solution, let’s consider more ways of implementing our
    routing function. You could make do by having a big enough piece of code, which
    would receive an argument declaring which algorithm to use, plus the starting
    and ending points. With these arguments, the function could do a switch or something
    similar to apply the correct path-finding logic. The code would be roughly equivalent
    to the following fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This kind of solution is not desirable, and your function is the sum of many
    distinct other functions, which doesn’t offer a high level of cohesion. If your
    language doesn’t support lambda functions (as was the case with Java, for example,
    until Java 8 came out in 2014), the OOP solution for this requires defining classes
    that implement the different strategies you may want, creating an appropriate
    object, and passing it around.
  prefs: []
  type: TYPE_NORMAL
- en: 'With FP in JavaScript, implementing strategies is trivial; instead of using
    a variable such as `byMeans` to switch, you provide a route-finding function (`routeAlgorithm()`
    in the following code) that will implement the desired path logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You would still have to implement all of the desired strategies (there’s no
    way around that) and decide which function to pass to `findRoute()`, but now that
    function is independent of the routing logic, and if you wanted to add new routing
    algorithms, you wouldn’t touch `findRoute()`.
  prefs: []
  type: TYPE_NORMAL
- en: If you consider the Template pattern, the difference is that Strategy allows
    you to use completely different ways of achieving an outcome, while Template provides
    an overarching algorithm (or template) in which some implementation details are
    left to methods to be specified. In the same way, you can provide functions to
    implement the Strategy pattern; you can also provide them for a Template pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Command pattern also benefits from the ability to be able to pass
    functions as arguments. This pattern is meant to be enabled to encapsulate a request
    as an object, so for different requests, you have differently parameterized objects.
    Given that we can pass functions as arguments to other functions, there’s no need
    for the enclosing object.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw a similar use of this pattern back in the *A React-Redux reducer*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out with
    Functions*. There, we defined a table, each of whose entries was a callback that
    was called whenever needed. We could directly say that the Command pattern is
    just an **object-oriented** (OO) replacement for plain functions working as callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now consider a related pattern, Dependency Injection, that will also let
    us change how a method or function works.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In basic terms, Dependency Injection is a pattern in which an object or function
    receives any other objects or functions that it needs to do its job, leading to
    less coupling and more flexibility. With this technique, a service can work in
    multiple environments or with different configurations, and changing it may be
    achieved without having to modify its code.
  prefs: []
  type: TYPE_NORMAL
- en: To make things clearer, let’s consider a service, implemented in Node plus Express,
    that gets a request, interacts with other entities (maybe it queries a database,
    accesses some file buckets, posts a message to a message queue, calls some other
    services, etc.) and eventually builds a response to send back. What’s wrong with
    this? A quick answer would be “*Nothing!*” because it works, and it’s how many
    services are implemented. However, digging a bit further, we may decide the answer
    should be “*Everything*!” Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'With any piece of code, there always are three primary concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Is it understandable?* Our service’s code may be hard to follow because it
    mixes business logic concerns with implementation details, concerning secondary
    matters such as how to query the database and access the buckets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Is it maintainable?* If we wonder how simple it may be to change our service’s
    code, the question is how many reasons for change there may be. A change in business
    logic is always a possibility; that’s essential. However, other changes (using
    Redis instead of MySQL or adding records to a database table instead of sending
    messages to a queue) that aren’t related to the service’s business objectives
    would also require changes in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Is it testable?* We may or may not need to maintain the code (and, indeed,
    if any changes are needed, that would be in the future), but we have to test our
    code today. How would we go about it? Would it be easy?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last item is the one we care about now. All the interactions with other
    entities are clearly impure functions, so we could set up our tests in three ways.
  prefs: []
  type: TYPE_NORMAL
- en: We could work with separate, special environments. Each developer would need
    to have a complete environment (with databases, queues, servers, etc.) so code
    can run as in reality. To do a test, the developer should first set everything
    up in a known fashion and then check whether the database got modified correctly,
    if the right messages were sent, and so on. All this is possible but costly, hard
    to set up, and mainly slow – before each test, you have to reset everything, and
    after each test, you have to check everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could work with fully mocked external entities. Tools such as Jest or Jasmine
    allow us to mock entities, so our code, instead of dealing with actual databases,
    queues, services, and so on would (transparently) interact with mocks that mimic
    the needed behaviors. This is much more efficient (because no real environments
    are needed, no actual databases get updated, no messages are really sent, and
    so on), but simulating all the required behaviors is still a lot of work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make the service less impure first! We saw this approach back in [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, which allows us to
    easily write tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now get to actual details and consider a possible service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine we have an endpoint that responds to `GET /client/:id` requests by searching
    for the client in a database and posting a message to a queue after the search.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll code our service in terms of *ports* (interfaces) and *adapters* (interface
    implementations) that it will receive. In our case, ports will (abstractly) define
    how our service is meant to interact with other entities, and adapters will (concretely)
    implement the needed functionality. With this in mind, we will be able to provide
    different adapters, allowing flexibility for different environments. In a production
    environment, we’ll provide adapters that work, access databases, post messages,
    and so on, but for testing, we’ll be able to inject mock adapters with trivial
    “do nothing” fake implementations.
  prefs: []
  type: TYPE_NORMAL
- en: An architecture by any other name
  prefs: []
  type: TYPE_NORMAL
- en: This architectural style is naturally known as “Ports and Adapters,” but it
    also goes by “Hexagonal Architecture” – a much catchier name! Don’t try to figure
    out why the word “hexagonal” is used; it just refers to hexagons being used to
    represent services in diagrams, and nothing else!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this would work. If our service needs to look for a client by
    its ID in a database, we must define a suitable interface, a “find client” port.
    We could define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition says that our port will receive a numerical ID as an argument
    and return a promise that will either resolve to a `ClientType` object or `null`.
    (We cannot specify semantic aspects, but it sounds likely that the returned object
    will be the client, if found; `null` would represent a failed search.) We also
    require an actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Naming is important; the port definition does not say where the client will
    come from, but the adapter does. We could have different adapters that would look
    for clients in other places (a key store, a spreadsheet, or the filesystem), but
    they would all implement the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, given our service definition, we’ll also need a port and adapter
    for sending messages. How would we now write our service? The code would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What are we doing? Our service receives `id` and an optional object providing
    two adapters. If this object is omitted, our service will use default adapters
    that work with a database and a message queue. In our server, the code dealing
    with the `/client/:id` endpoint would use `getClientService(req.params.id)` and,
    thus, work with an actual database and a message queue. But how will we test our
    service? That’s what we need to see now.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to call our service in production. However,
    for testing, we would do things differently, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We would first define a couple of mock functions; `findClientMock` would simulate
    a search in the database, and `sendMsgMock` would return whatever a successful
    message-sending operation would return. We can now call our `getClientService()`
    with the mocks, and we would then verify that the (mock) adapters were used properly
    and that the service returns the correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to a classic pattern that implies a new term, *reactive programming*,
    which is being thrown around a lot these days.
  prefs: []
  type: TYPE_NORMAL
- en: Observers and reactive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of the Observer pattern is to define a link between entities so that
    when one changes, all dependent entities are updated automatically. An *observable*
    can publish changes to its state, and its observer (which subscribed to the observable)
    will be notified of such changes.
  prefs: []
  type: TYPE_NORMAL
- en: No observables for now
  prefs: []
  type: TYPE_NORMAL
- en: There is a proposal for adding observables to JavaScript (see [github.com/tc39/proposal-observable](http://github.com/tc39/proposal-observable)),
    but as of January 2023, it’s still stuck at stage one, with no activity since
    late 2020\. Hence, for the time being, using a library will still be mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: There’s an extension to this concept called **reactive programming**, which
    involves asynchronous streams of events (such as mouse clicks or keypresses) or
    data (from APIs or WebSockets), and different parts of the application subscribing
    to observe such streams by passing callbacks that will get called whenever something
    new appears.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t be implementing reactive programming on our own; instead, we’ll use
    RxJS, a JavaScript implementation of Reactive Extensions (*ReactiveX*), initially
    developed by Microsoft. RxJS is widely used in the Angular framework and can also
    be used in other frontend frameworks, such as React or Vue, or the backend with
    Node.js. Learn more about RxJS at [rxjs-dev.firebaseapp.com](http://rxjs-dev.firebaseapp.com)
    and [www.learnrxjs.io](http://www.learnrxjs.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques we will be showing in these sections are, confusingly, called
    both `map()`, `filter()`, and `reduce()` to process those streams and pick which
    events to process and how. Okay, this may be confusing now, so bear with me and
    let’s see some concepts first, and after that, some examples of FRP – or whatever
    you want to call it! We will be seeing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Several basic concepts and terms you’ll need to work with FRP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the many available operators you’ll use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A couple of examples – detecting multi-clicks and providing typeahead searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s proceed to analyze each item, starting with the basic ideas you need to
    know.
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts and terms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using FRP requires getting used to several new terms, so let’s begin with a
    short glossary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`; see [angular.io/guide/rx-library#naming-conventions](http://angular.io/guide/rx-library#naming-conventions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next()`, `error()`, and `complete()`, which will be called by the observable
    when a value is available, when there’s an error, and when the stream is ended
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`, `filter()`, and so on, from [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*) that let you apply transformations to a stream in
    a declarative way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipeline()` function we developed in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe()` method, providing an observer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interesting way of looking at observables is that they complete the lower
    row of this table – check it out. You will probably be quite familiar with the
    *Single* column, but maybe not with the *Multiple* one:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Single** | **Multiple** |'
  prefs: []
  type: TYPE_TB
- en: '| **Pull** | `Function` | `Iterator` |'
  prefs: []
  type: TYPE_TB
- en: '| **Push** | `Promise` | `Observable` |'
  prefs: []
  type: TYPE_TB
- en: 'How do we interpret this table? The rows distinguish between pull (you call
    something) and push (you get called), and the columns represent how many values
    you get – one or many. With these descriptions, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `function` is called and returns a single value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `promise` calls your code (a callback in the `then()` method), also with a
    single value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `iterator` returns a new value each time it’s called – at least until the
    sequence is over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `observable` calls your code (provided you `subscribe()` to the observable)
    for each value in the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Observables and promises can be compared a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: They are both mostly `async` in nature, and your callback will be called at
    an indefinite future time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises cannot be canceled, but you can `unsubscribe()` from an observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises start executing the moment you create them; observables are lazy, and
    nothing happens until an observer does `subscribe()` to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real power of observables derives from the variety of operators you can
    use; let’s see some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Operators for observables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basically, operators are just functions. Creation operators can be used to create
    observables out of many different sources, and pipeable operators can be applied
    to modify a stream, producing a new observable; we’ll see many families of these,
    but for complete lists and descriptions, you should access [www.learnrxjs.io/learn-rxjs/operators](http://www.learnrxjs.io/learn-rxjs/operators)
    and [rxjs.dev/guide/operators](http://rxjs.dev/guide/operators).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we won’t be covering how to install RxJS; see [rxjs.dev/guide/installation](http://rxjs.dev/guide/installation)
    for all the possibilities. In particular, in our examples, meant for a browser,
    we’ll be installing RxJS from a CDN, which creates a global `rxjs` variable, similar
    to jQuery’s `$` or Lodash’s `_` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating observables, and then move on to transforming them.
    For creation, some of the several operators you can use are explained in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Ajax` | Creates an observable for an Ajax request, for which we’ll emit
    the response that is returned |'
  prefs: []
  type: TYPE_TB
- en: '| `from` | Produces an observable out of an array, an iterable, or a promise
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fromEvent` | Turns events (for example, mouse clicks) into an observable
    sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `interval` | Emits values at periodic intervals |'
  prefs: []
  type: TYPE_TB
- en: '| `of` | Generates a sequence out of a given set of values |'
  prefs: []
  type: TYPE_TB
- en: '| `range` | Produces a sequence of values in a range |'
  prefs: []
  type: TYPE_TB
- en: '| `timer` | After an initial delay, emits values periodically |'
  prefs: []
  type: TYPE_TB
- en: 'To give an elementary example, the following three observables will all produce
    a sequence of values from 1 to 10, and we’ll be seeing more practical examples
    a bit later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The available pipeable operators are way too many for this section, so we’ll
    just go over some families and describe their basic idea, with one or two particular
    mentions. The following table lists the most common families, with their most
    often used operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Family** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Combination** | These operators allow us to join information from several
    distinct observables, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`concat()` to put observables in a queue one after the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge()` to create a single observable out of many'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pairWise()` to emit the previous value and the current one as an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startWith()` to inject a value in an observable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Conditional** | These produce values depending on conditions and include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaultIfEmpty()` emits a value if an observable doesn’t emit anything before
    completing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`every()` emits true if all values satisfy a predicate and emits false otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iif()` subscribes to one of two observables, depending on a condition, such
    as the ternary `?` operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Error handling** | These (obviously!) apply to error conditions and include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catchError()` to gracefully process an error from an observable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry()` and `retryWhen()` to retry an observable sequence (most likely, one
    linked to HTTP requests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Filtering** | Probably the most important family, providing many operators
    to process sequences by selecting which elements will get processed or dismissed,
    by applying different types of conditions for your selection. Some of the more
    common ones include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debounce()` and `debounceTime()` to deal with values too close together in
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinctUntilChanged()` to only emit when the new value is diﬀerent from the
    last'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter()` to only emit values that satisfy a given predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find()` to emit only the ﬁrst value that satisﬁes a condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first()` and `last()` to pick only the ﬁrst or last values of a sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip()` plus `skipUntil()` and `skipWhile()` to discard values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()` and `takeLast()` to pick a given number of values from the beginning
    or end of a sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeUntil()` and `takeWhile()` to pick values and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Transforming** | The other very commonly used family, which includes operators
    to transform the values in a sequence. Some of the many possibilities include
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buffer()` and `bufferTime()` to collect values and emit them as an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupBy()` to group values together based on some property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()` to apply a given mapping function to every element in the sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partition()` to split an observable into two, based on a given predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pluck()` to pick only some attributes from each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce()` to reduce a sequence of values to a single one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan()` works like `reduce()` but emits all intermediate values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toArray()` collects all values and emits them as a single array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Utilities** | A sundry collection of operators with different functions,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tap()` to perform a side eﬀect, similar to what we saw in the *Tapping into
    a ﬂow* section in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting
    Functions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay()` to delay sequence values for some time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finalize()` to call a function when an observable completes or produces an
    error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat()` is just like `retry()` but for normal (that is, non-error) cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout()` to produce an error if no value is produced before a given duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Wow, that’s a lot of operators! We have excluded many, and you could even write
    your own, so be sure to look at the documentation. By the way, understanding operators
    is easier with marble diagrams; we won’t be using them here, but read [reactivex.io/documentation/observable.html](http://reactivex.io/documentation/observable.html)
    for a basic explanation, and then check out [rxmarbles.com](http://rxmarbles.com)
    for many interactive examples of operators and how they function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish this section with a couple of examples of the possibility of application
    for your own coding.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting multi-clicks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you decided, for some reason or another, that users should be able to
    triple-click or four-click on something, and the number of clicks would somehow
    be meaningful and produce some kind of result. Browsers do very well detecting
    single- or double-clicks and letting you respond to them, but triple- (or more)
    clicks aren’t available so easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can make do with a bit of FRP. Let’s start with a truly basic layout,
    including a text span that the user should click. The code is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is as plain as can be; you just get a text on screen, urging you to multi-click
    it. See *Figure 11**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – A very plain screen to test detecting triple-clicks](img/Figure_11.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – A very plain screen to test detecting triple-clicks
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect these multi-clicks, we’ll need some RxJS functions, so let’s start
    with those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use these functions soon enough. How do we detect triple- (or more)
    clicks? Let’s go straight on to the code given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an observable with `fromEvent()` to listen to mouse clicks on our
    span.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, a tricky point – we use `buffer()` to join together many events, which
    come from applying `debounceTime()` to the sequence of clicks, so all clicks that
    happen within an interval of 250 milliseconds will get grouped into a single array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then apply `map()` to transform each array of clicks into just its length
    – after all, we care about how many clicks there were, not their specific details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We finish by filtering out values under `3`, so only longer sequences of clicks
    will be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subscription just logs the clicks, but in your application, it should do
    something more relevant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wanted, you could detect multi-clicks by hand, writing your own code;
    see *Question 11.3* in the *Questions* section. Let’s finish with a longer example
    and do some typeahead searches, invoking some external API.
  prefs: []
  type: TYPE_NORMAL
- en: Providing typeahead searches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s do another web example: typeahead searches. The usual setup is that there
    is some sort of textbox, the user types in it, and the web page queries an API
    to provide ways of completing the search. The important thing is when and how
    to do the search, and try to avoid unnecessary calls to the backend server whenever
    possible. A (totally basic) HTML page could be as follows (see *Figure 11**.4*
    later in this section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a single textbox in which the user will type and an area below
    that in which we’ll show whatever the API provides. We’ll use the GeoDB Cities
    API (see [geodb-cities-api.wirefreethought.com](http://geodb-cities-api.wirefreethought.com)),
    which provides many search options, to search for cities starting with whatever
    the user has typed. To get it out of our way, let’s look at the `getCitiesOrNull()`
    function, which will return a promise for search results (if something was typed
    in) or `null` (no cities, if nothing was typed in). The results of this promise
    will be used to fill the `myResults` division on the page. Let’s see how this
    works out in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is simple – if some text was provided, we generate the URL for the
    cities’ search and use `fetch()` to get the API data. With this done, let’s see
    how to generate the needed observable. We will need some RxJS functions, so first,
    let’s have some definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using all of these functions later. Now, we can write the code to
    do the typeahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires going step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `fromEvent()` constructor to observe input events (every time the
    user types something) from the `myText` input field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `map()` to get the event’s target value, the complete text of the input
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `debounceTime(200)` so that the observable won’t emit until the user
    has been 0.2 seconds (200 milliseconds) without typing – what’s the use of calling
    the API if the user isn’t done with their query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `filter()` to discard the input if it was only one, two, or three
    characters long because that’s not long enough for our search. We accept empty
    strings (so we’ll empty the results area) and strings four or more characters
    long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use `distinctUntilChanged()`, so if the search string is the same as
    before (the user possibly added a character but quickly backspaced, deleting it),
    nothing will be emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we change `switchMap()` to cancel the previous subscription to the
    observable and create a new one using `getCitiesOrNull()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How do we use this? We subscribe to the observable, and when we get results,
    we use them to display values. A possible sample code follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An important point – the promise is resolved, and the final value of the sequence
    is, hence, whatever the promise produced. If the result isn’t `null`, we get an
    array of cities, and we use `map()` and `join()` to produce the (very basic!)
    HTML output; otherwise, we empty the results area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out. If you start typing, nothing will happen until you reach
    at least four characters and pause a bit (see *Figure 11**.4*, as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Our search for cities doesn’t trigger for less than four characters](img/Figure_11.4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Our search for cities doesn’t trigger for less than four characters
  prefs: []
  type: TYPE_NORMAL
- en: 'When you reach four characters and pause for a moment, the observable will
    emit an event, and we’ll do a first search – in this case, for cities with names
    starting with `MONT` (see *Figure 11**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – After reaching four characters, searches will be ﬁred](img/Figure_11.5_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – After reaching four characters, searches will be ﬁred
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as you add more characters, new API calls will be made, refining the
    search (see *Figure 11**.6*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Further characters are used to reﬁne the search](img/Figure_11.6_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Further characters are used to reﬁne the search
  prefs: []
  type: TYPE_NORMAL
- en: What can we learn from these examples? Using observables for events lets us
    achieve a good separation of concerns regarding event production and event consumption,
    and the declarative style of the stream process makes the data flow clearer. Note
    that even the HTML code has no reference to click methods or anything like that;
    the complete code is separate from that.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen most of the interesting patterns; let’s finish with some other
    ones, which may or may not be exactly equivalent to their classic OOP partners.
  prefs: []
  type: TYPE_NORMAL
- en: Other patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s end this section by glancing at some other patterns where the equivalence
    may or may not be so good:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currying and partial application** (which we saw in [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*: This can be seen as approximately equivalent to a *Factory*
    for functions. Given a general function, you can produce specialized cases by
    fixing one or more arguments, which is, in essence, what a Factory does – speak
    about functions and not objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()` or `reduce()`): These can be considered an application of the Iterator
    pattern. The traversal of the container’s elements is decoupled from the container
    itself. You can also provide different `map()` methods for different objects to
    traverse all kinds of data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent data structures**: As mentioned in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, these allow for the implementation of the Memento pattern.
    The central idea is, given an object, to be able to go back to a previous state.
    As we saw, each updated version of a data structure doesn’t affect the previous
    one(s), so you could easily add a mechanism to provide an earlier state and *roll
    back* to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `find()` to determine which processor will handle the request (the desired
    one is the first in the list that accepts the request) and then simply doing the
    required process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember the warning at the beginning – with these patterns, the match with
    FP techniques may not be as perfect as with others that we have previously seen.
    However, the idea is to show that some common FP patterns can be applied and will
    produce the same results as the OOP solutions, despite having different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after having seen several OOP equivalent patterns, let’s move on to more
    specific FP ones.
  prefs: []
  type: TYPE_NORMAL
- en: Functional design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen several OOP design patterns, it may seem a cheat to say that there’s
    no approved, official, or even remotely generally accepted similar list of patterns
    for FP. There are, however, several problems for which there are standard FP solutions,
    which can be considered design patterns on their own, and we have already covered
    most of them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the candidates for a possible list of patterns? Let’s attempt to prepare
    one – but remember that it’s just a personal view. Also, I’ll admit that I’m not
    trying to mimic the usual style of pattern definition; I’ll just be mentioning
    a general problem and refer to the way FP in JavaScript can solve it, and I won’t
    be aiming for nice, short, and memorable names for the patterns either:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()`, `map()`, and `reduce()`, as we saw in this chapter and previously
    in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    is a way to remove complexity from the problem. (The usual `MapReduce` web framework
    is an extension of this concept, which allows for distributed processing among
    several servers, even if the implementation and details aren’t exactly the same.)
    Instead of performing looping and processing as a single step, you should think
    about the problem as a sequence of steps, applied in order, and doing transformations
    until obtaining the final, desired result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping in other ways
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript also includes *iterators*, another way of looping through a collection.
    Using iterators isn’t particularly functional, but you may want to look at them,
    since they may be able to simplify some situations. Read more at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation with thunks**: The idea of lazy evaluation is not doing any
    calculations until they are actually needed. In some programming languages, this
    is built in. However, in JavaScript (and most imperative languages), *eager evaluation*
    is applied, in which an expression is evaluated as soon as it is bound to some
    variable. (Another way of saying this is that JavaScript is a *strict programming
    language*, with a *strict paradigm*, which only allows calling a function if all
    of its parameters have been completely evaluated.) This sort of evaluation is
    required when you need to specify the order of evaluation with precision, mainly
    because such evaluations may have side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In FP, which is more declarative and pure, you can delay such evaluation with
    *thunks* (which we used in the *Trampolines and thunks* section of [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172)*,
    Designing Functions*) by passing a thunk that will calculate the needed value
    only when it’s needed, but not earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Generating more results
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to look at JavaScript generators, another way of delaying
    evaluation, though not particularly related to FP. Read more about them at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
    The combination of generators and promises is called an `async` function, which
    may be of interest to you; refer to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistent data structures for immutability**: Having immutable data structures,
    as we saw in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*,
    is mandatory when working with certain frameworks, and in general, it is recommended
    because it helps to reason about a program or to debug it. (Earlier in this chapter,
    we also mentioned how the *Memento* OOP pattern can be implemented in this fashion.)
    Whenever you have to represent structured data, the FP solution of using a persistent
    data structure helps in many ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` before trying to access the corresponding object). This pattern aims
    to wrap a value within an object or function, so direct manipulation won’t be
    possible, and checks can be managed more functionally. We’ll refer to more of
    this in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building* *Better Containers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have said, the power of FP is such that, instead of having a couple of
    dozen standard design patterns (and that’s only in the GoF book; if you read other
    texts, the list grows!), there isn’t yet a standard or acknowledged list of functional
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have made a bridge from the OO way of thinking and the usual
    patterns we use when coding that way to the FP style, by showing how we can solve
    the same basic problems but relatively more easily than with classes and objects.
    We have seen several common design patterns, and we’ve seen that the same concepts
    apply in FP, even if implementations may vary, so now you have a way to apply
    those well-known solution structures to your JavaScript coding.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*,
    we will be working with a potpourri of FP concepts, giving you even more ideas
    about tools you can use. I promised that this book wouldn’t be deeply theoretical
    but, rather, more practical, and we’ll try to keep it this way, even if some of
    the presented concepts may seem abstruse or remote.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11.1 **Decorating methods, the future way**: In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we wrote a decorator to enable logging for any function.
    Currently, method decorators are being considered for upcoming versions of JavaScript:
    refer to [tc39.github.io/proposal-decorators](http://tc39.github.io/proposal-decorators)
    for more information on that. (A Stage 2 Draft means that inclusion of this feature
    in the standard is likely, although there may be some additions or small changes.
    TypeScript provides decorators today, but warns that *“Decorators are an experimental
    feature that may change in future releases”*; see more at [www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html).)
    Study the following code and take a look at what makes the next code tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A working example would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some questions about the code for `logging()`:'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the need for the `savedMethod` variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we use `function()` when assigning a new `descriptor.value`, instead
    of an arrow function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is `.``bind()` used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is `descriptor`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.2 `addBar()` function, which will add some mixins to the `Foo` class so
    that the code will run as shown. The created `fooBar` object should have two attributes
    (`fooValue` and `barValue`) and two methods (`doSomething()` and `doSomethingElse()`)
    that simply show some text and properties, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Could you include a third mixin, `addBazAndQux()`, so that `addBazAndQux(addBar(Foo))`
    would add even more attributes and methods to `Foo`?
  prefs: []
  type: TYPE_NORMAL
- en: '11.3 **Multi-clicking by hand**: Can you write your own multi-click detection
    code, which should work exactly as in our example?'
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 `false` values first and `true` values last?
  prefs: []
  type: TYPE_NORMAL
- en: '11.5 **Finding routes, objectively**: Working in an object-oriented fashion,
    the route-finding problem would have been solved in another way, involving classes
    and subclasses. How? (Tip: the answer to this question is a pattern we have mentioned
    in this chapter.)'
  prefs: []
  type: TYPE_NORMAL
