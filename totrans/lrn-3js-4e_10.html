<html><head></head><body>
		<div><h1 id="_idParaDest-172" class="chapter-number"><a id="_idTextAnchor171"/>10</h1>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Loading and Working with Textures</h1>
			<p>In <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, <em class="italic">Working with Three.js Materials</em>, we introduced you to the various materials that are available in Three.js. However, we didn’t discuss applying textures to the material that’s used when creating a mesh. In this chapter, we’ll look at that subject. Specifically, we’ll discuss the following topics:</p>
			<ul>
				<li>Loading textures in Three.js and applying them to a mesh</li>
				<li>Using bump, normal, and displacement maps to apply depth and detail to a mesh</li>
				<li>Creating fake shadows using a lightmap and an ambient occlusion map</li>
				<li>Using specular, metalness, and roughness maps to set the shininess of specific parts of a mesh</li>
				<li>Applying an alpha map for partial transparency of an object</li>
				<li>Adding detailed reflections to a material using an environment map</li>
				<li>Using the HTML5 Canvas and video element as input for a texture</li>
			</ul>
			<p>Let’s start with a basic example, where we will show you how to load and apply a texture.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Using textures in materials</h1>
			<p>There are different ways that<a id="_idIndexMarker905"/> textures can be used in Three.js. You can use them to define the colors of the mesh, but you can also use them to define shininess, bumps, and<a id="_idIndexMarker906"/> reflections. The first example we will look at, though, is very basic, wherein we will use a texture to define the colors of the individual pixels of a mesh. This is often called a color map or a diffuse map.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>Loading a texture and applying it to a mesh</h2>
			<p>The most basic usage of<a id="_idIndexMarker907"/> a texture is when it’s set as a map on a material. When you use this material to <a id="_idIndexMarker908"/>create a mesh, the mesh will be colored based on the supplied texture. Loading a texture and using it on a mesh can be done in the following manner:</p>
			<pre class="source-code">
const textureLoader = new THREE.TextureLoader(); 
const texture = textureLoader.load
  ('/assets/textures/ground/ground_0036_color_1k.jpg')</pre>
			<p>In this code sample, we are using an instance of <code>THREE.TextureLoader</code> to load an image file from a specific location. Using this loader, you can use PNG, GIF, or JPEG images as input for a texture (later in this chapter, we’ll show you how to load other texture formats). Note that textures are loaded asynchronously: if it is a large texture and you render the scene before the texture is completely loaded, you’ll see your meshes without a texture applied for a short time. If you want to wait until a texture has been loaded, you can provide a callback to the <code>textureLoader.load()</code> function:</p>
			<pre class="source-code">
Const textureLoader = new THREE.TextureLoader(); 
const texture = textureLoader.load
  ('/assets/textures/ground/ground_0036_color_1k.jpg',
            onLoadFunction, 
            onProgressFunction,
            onErrorFunction)</pre>
			<p>As you can see, the <code>load</code> function takes three additional functions as parameters: <code>onLoadFunction</code> is called when the texture is loaded, <code>onProgressFunction</code> can be used to track how much of the texture is loaded, and <code>onErrorFunction</code> is called when something goes wrong while loading or parsing the texture. Now that the texture has been loaded, we can add it to the mesh:</p>
			<pre class="source-code">
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.map = texture</pre>
			<p>Note that the loader also provides a <code>loadAsync</code> function, which returns a <code>Promise</code> instead, just like we<a id="_idIndexMarker909"/> saw in the previous chapter when loading models.</p>
			<p>You can use pretty much <a id="_idIndexMarker910"/>any image you’d like as a texture. However, you’ll get the best results by using a square texture whose dimensions are a power of 2. So, dimensions such as 256 x 256, 512 x 512, 1,024 x 1,024, and so on work the best. If the texture isn’t a power of two, Three.js will scale down the image to the closest power of 2 value.</p>
			<p>One of the textures we’ll be using in the examples in this chapter looks like this:</p>
			<div><div><img src="img/Figure_10.1_B18726.jpg" alt="Figure 10.1 – The color texture of a brick wall"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The color texture of a brick wall</p>
			<p>The pixels of a<a id="_idIndexMarker911"/> texture (also called texels) usually <a id="_idIndexMarker912"/>don’t map one-to-one on the pixels <a id="_idIndexMarker913"/>of the face. If the camera is very close, we need to magnify the texture, and if we’re zoomed out, we probably need to shrink the texture. For this purpose, WebGL and Three.js offer a couple of different options to resize this image. This is done through the <code>magFilter</code> and <code>minFilter</code> properties:</p>
			<ul>
				<li><code>THREE.NearestFilter</code>: This filter uses the color of the nearest texel that it can find. When used for magnification, this will result in blockiness, and when used for minification, the result will lose a lot of detail.</li>
				<li><code>THREE.LinearFilter</code>: This filter is more advanced; it uses the color values of the four neighboring texels to determine the correct color. You’ll still lose a lot of detail in minification, but the magnification will be much smoother and less blocky.</li>
			</ul>
			<p>Aside from these basic <a id="_idIndexMarker914"/>values, we can also use a <strong class="bold">MIP map</strong>. A MIP map is <a id="_idIndexMarker915"/>a set of texture<a id="_idIndexMarker916"/> images, each half the size of the previous one. These are created when you load the texture and allow for much smoother filtering. So, when you have a square texture (as a power of 2), you can use a couple of additional approaches for better filtering. The properties can be set using the following values:</p>
			<ul>
				<li><code>THREE.NearestMipMapNearestFilter</code>: This property selects the MIP map that best maps the required resolution and applies the nearest filter principle, which we discussed in the previous list. Magnification is still blocky, but minification looks much better.</li>
				<li><code>THREE.NearestMipMapLinearFilter</code>: This property selects not just a single MIP map but the two nearest MIP map levels. On both of these levels, the nearest filter is applied, to get two intermediate results. These two results are passed through a linear filter to get the final result.</li>
				<li><code>THREE.LinearMipMapNearestFilter</code>: This property selects the MIP map that best maps the required resolution and applies the linear filter principle, which was discussed in the previous list.</li>
				<li><code>THREE.LinearMipMapLinearFilter</code>: This property selects not a single MIP map, but the two nearest MIP map levels. On both of these levels, a linear filter is applied, to get two intermediate results. These two results are passed through a linear filter to get the final result.</li>
			</ul>
			<p>If you don’t specify the <code>magFilter</code> and <code>minFilter</code> properties explicitly, Three.js uses <code>THREE.LinearFilter</code> as the default for the <code>magFilter</code> property and <code>THREE.LinearMipMapLinearFilter</code> as the default for the <code>minFilter</code> property. </p>
			<p>In our examples, we’ll just <a id="_idIndexMarker917"/>use the default texture properties. An example of such a basic texture <a id="_idIndexMarker918"/>used as a map for a material can be found in <code>texture-basics.html</code>. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_10.2_B18726.jpg" alt="Figure 10.2 – Model with a simple wood texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Model with a simple wood texture</p>
			<p>In this example, you can change the models and select a couple of textures from the menu on the right. You can also change the default material properties to see how the material, in combination with a color map, is affected by the different settings.</p>
			<p>In this example, you can see that the textures wrap nicely around the shapes. When you create geometries in Three.js, it makes sure that any texture that is used is applied correctly. This is done through <a id="_idIndexMarker919"/>something called UV mapping. With UV mapping, we can tell the renderer which part of a texture should be applied to a specific face. We’ll get into the details of UV mapping in <a href="B18726_13.xhtml#_idTextAnchor227"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Blender and Three.js</em>, where we will show you how you can easily use Blender to create custom UV mappings for Three.js.</p>
			<p>Aside from the standard image formats that we can load with <code>THREE.TextureLoader</code>, Three.js also<a id="_idIndexMarker920"/> provides a couple of custom loaders you can use to load textures provided in different formats. If you’ve got a specific image format, you can check out the <code>loaders</code> folder from the Three.js distribution (<a href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders">https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders</a>) to see whether the image<a id="_idIndexMarker921"/> format can be loaded directly by Three.js or whether you need to manually convert it.</p>
			<p>Aside from these normal images, Three.js also supports HDR images.</p>
			<h3>Loading HDR images as textures</h3>
			<p>An HDR image captures a<a id="_idIndexMarker922"/> higher range of luminance levels than standard images, and can more closely match what we see with the human eye. Three.js <a id="_idIndexMarker923"/>supports the <code>EXR</code> and <code>RGBE</code> formats. If you’ve got an HDR image, you can fine-tune how Three.js renders the HDR image since an HDR image contains more luminance information than can be shown on a display. This can be done by setting the following properties in <code>THREE.WebGLRenderer</code>:</p>
			<ul>
				<li><code>toneMapping</code>: This property defines how to map the colors from the HDR image to the display. Three.js provides the following options: <code>THREE.NoToneMapping</code>, <code>THREE.LinearToneMapping</code>, <code>THREE.ReinhardToneMapping</code>, <code>THREE.Uncharted2ToneMapping</code>, and <code>THREE.CineonToneMapping</code>. The default is <code>THREE.LinearToneMapping</code>.</li>
				<li><code>toneMappingExposure</code>: This is the exposure level of <code>toneMapping</code>. This can be used to fine-tune the colors of the rendered texture.</li>
				<li><code>toneMappingWhitePoint</code>: This is the white point used for <code>toneMapping</code>. This can also be used to fine-tune the colors of the rendered texture.</li>
			</ul>
			<p>If you want to load an EXR or RGBE image and use it as a texture, you can use <code>THREE.EXRLoader</code> or <code>THREE.RGBELoader</code>. This works in the same way as we’ve seen for <code>THREE.TextureLoader</code>:</p>
			<pre class="source-code">
const loader = new THREE.EXRLoader(); 
exrTextureLoader.load('/assets/textures/exr/Rec709.exr')
...
const hdrTextureLoader = new THREE.RGBELoader(); 
hdrTextureLoader.load('/assets/textures/hdr/
  dani_cathedral_oBBC.hdr')</pre>
			<p>In the <code>texture-basics.html</code> example, we showed you how the texture can be used to apply colors <a id="_idIndexMarker924"/>to a mesh. In the next section, we’ll look at how to use a<a id="_idIndexMarker925"/> texture to make a model look more detailed by applying fake height information to the mesh.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor175"/>Using a bump map to provide extra details to a mesh</h2>
			<p>A bump map is used to<a id="_idIndexMarker926"/> add more depth to a material. You can see this in action by opening <code>texture-bump-map.html</code>:</p>
			<div><div><img src="img/Figure_10.3_B18726.jpg" alt="Figure 10.3 – Model with a bump map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Model with a bump map</p>
			<p>In this example, you <a id="_idIndexMarker927"/>can see that the model looks much more detailed and seems to have more depth. This was done by setting an additional texture, a so-called bump map, on the material:</p>
			<pre class="source-code">
const exrLoader = new EXRLoader()
const colorMap = exrLoader.load('/assets/textures/brick-wall/brick_wall_001_diffuse_2k.exr', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(4, 4)
})
const bumpMap = new THREE.TextureLoader().load(
  '/assets/textures/brick-wall/brick_wall_001_displacement_2k.png',
  (texture) =&gt; {
    texture.wrapS = THREE.RepeatWrapping
    texture.wrapT = THREE.RepeatWrapping
    texture.repeat.set(4, 4)
  }
)
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.map = colorMap
material.bumpMap = bumpMap</pre>
			<p>In this code, you can see that aside from setting the map property, we have also set the <code>bumpMap</code> property to a<a id="_idIndexMarker928"/> texture. Additionally, with the <code>bumpScale</code> property, which is available through the menu in the previous example, we can set the height (or depth, if set to a negative value) of the bumps. The textures used in this example are shown here:</p>
			<div><div><img src="img/Figure_10.4_B18726.jpg" alt="Figure 10.4 – Textures used for the bump map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Textures used for the bump map</p>
			<p>The bump map is a <a id="_idIndexMarker929"/>grayscale image, but you can also use a color image. The intensity of the pixels defines the height of the bump. A bump map only contains the relative height of a pixel. It doesn’t say anything about the direction of the slope. So, the level of detail and perception of depth that you can reach with a bump map is limited. For more detail, you can use a normal map.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>Achieving more detailed bumps and wrinkles with a normal map</h2>
			<p>In a normal map, the height (displacement) is not stored, but the direction of the normal for each pixel is stored. Without <a id="_idIndexMarker930"/>going into too much detail, with normal maps, you can create very detailed-looking models that use only a small number of vertices and faces. For instance, take a look at the <code>texture-normal-map.html</code> example:</p>
			<div><div><img src="img/Figure_10.5_B18726.jpg" alt="Figure 10.5 – A model using a normal map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – A model using a normal map</p>
			<p>In the preceding screenshot, you can see a very detailed-looking model. And as the model moves around, you <a id="_idIndexMarker931"/>can see that the texture is responding to the light it receives. This provides a very realistic-looking model and only requires a very simple model and a couple of textures. The following code fragment shows how to use a normal map in Three.js:</p>
			<pre class="source-code">
const colorMap = new THREE.TextureLoader().load('/assets/textures/red-bricks/red_bricks_04_diff_1k.jpg', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(4, 4)
})
const normalMap = new THREE.TextureLoader().load(
  '/assets/textures/red-bricks/red_bricks_04_nor_gl_1k.jpg',
  (texture) =&gt; {
    texture.wrapS = THREE.RepeatWrapping
    texture.wrapT = THREE.RepeatWrapping
    texture.repeat.set(4, 4)
  }
)
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.map = colorMap
material.normalMap = normalMap</pre>
			<p>This involves the same approach as the one we used for the bump map. This time, though, we set<a id="_idIndexMarker932"/> the <code>normalMap</code> property to the normal texture. We can also define how pronounced the bumps look by setting the <code>normalScale</code> property (<code>mat.normalScale.set(1,1)</code>). With this property, you can scale along the <em class="italic">X</em> and <em class="italic">Y</em> axes. The best approach, though, is to keep these values the same. In this example, you can play around with these values.</p>
			<p>The following figure shows what the normal map we used here looks like:</p>
			<div><div><img src="img/Figure_10.6_B18726.jpg" alt="Figure 10.6 – Normal texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Normal texture</p>
			<p>The problem with<a id="_idIndexMarker933"/> normal maps, however, is that they aren’t very easy to create. You need to use specialized tools, such as Blender or Photoshop. These programs can use high-resolution renderings or textures as input and can create normal maps from them.</p>
			<p>With a normal or bump map, you don’t change the shape of the model; all of the vertices stay in the same location. These maps just use the lights from the scene to create fake depth and details. However, Three.js provides a third method that you can use to add details to a model using a map, which does change the positions of the vertices. This is done<a id="_idIndexMarker934"/> through a displacement map.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Using a displacement map to alter the position of vertices</h2>
			<p>Three.js also provides a texture that you can use to change the positions of the vertices of your model. While the bump<a id="_idIndexMarker935"/> map and the normal map give an illusion of depth, with a displacement map, we change the model’s shape, based on the information from the texture. We can use a displacement map in the same way as we use other maps:</p>
			<pre class="source-code">
const colorMap = new THREE.TextureLoader().load('/assets/textures/displacement
  /w_c.jpg', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
})
const displacementMap = new THREE.TextureLoader().load('/assets/textures/displacement
  /w_d.png', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
})
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.map = colorMap
material.displacementMap = displacementMap</pre>
			<p>In the preceding code fragment, we loaded a displacement map, which looks as follows:</p>
			<div><div><img src="img/Figure_10.7_B18726.jpg" alt="Figure 10.7 – Displacement map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Displacement map</p>
			<p>The brighter the color, the more<a id="_idIndexMarker936"/> a vertex is displaced. When you run the <code>texture-displacement.html</code> example, you will see that the result of the displacement map is a model where the shape of the model is changed based on the information from the map:</p>
			<div><div><img src="img/Figure_10.8_B18726.jpg" alt="Figure 10.8 – Model using a displacement map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Model using a displacement map</p>
			<p>Aside from setting the <code>displacementMap</code> texture, we can also use <code>displacementScale</code> and <code>displacementOffset</code> to control how pronounced the displacement is. One final thing to mention about using a displacement map is that it will only have good <a id="_idIndexMarker937"/>results if your mesh contains a large number of vertices. If not, the displacement won’t look like the provided texture, since there are too few vertices to represent the required displacement.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Adding subtle shadows with an ambient occlusion map</h2>
			<p>In the previous chapters, you <a id="_idIndexMarker938"/>learned how you can use shadows in Three.js. If you set the <code>castShadow</code> and <code>receiveShadow</code> properties of the correct meshes, add a couple of lights, and configure the shadow camera of the lights correctly, Three.js will render shadows.</p>
			<p>Rendering shadows, however, is a rather expensive operation that is repeated for every render loop. If you have lights or objects that are moving around, this is necessary, but often, some of the lights or models are fixed, so it would be great if we could calculate the shadows once, and then reuse them. To accomplish this, Three.js offers two different maps: the ambient occlusion map and a lightmap. In this section, we’ll look at the ambient occlusion map, and in the next section, we’ll look at the lightmap.</p>
			<p>Ambient occlusion is a technique used to determine how much each part of a model is exposed to the ambient lighting in a scene. In tools such as Blender, ambient light is often modeled through a hemisphere light or a directional light, such as the Sun. While most parts of a model will<a id="_idIndexMarker939"/> receive some of this ambient lighting, not all of the parts will receive the same. If, for instance, you model a person, the top of the head will receive more ambient lighting than the bottom of the arms. This difference in lighting – the shadows – can be rendered (baked, as shown in the following screenshot) into a texture, and we can then apply that texture to our models to give them shadows, without having to calculate the shadows every time:</p>
			<div><div><img src="img/Figure_10.9_B18726.jpg" alt="Figure 10.9 – Ambient occlusion map baked in Blender"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Ambient occlusion map baked in Blender</p>
			<p>Once you have an ambient occlusion map, you can assign it to the <code>aoMap</code> property of the material, and Three.js will take this information into account when applying and calculating how much the lights in the scene should be applied to that specific part of the model. The following code fragment shows how to set the <code>aoMap</code> property:</p>
			<pre class="source-code">
const aoMap = new THREE.TextureLoader().load('/assets/gltf/material_
  ball_in_3d-coat/aoMap.png')
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.aoMap = aoMap
material.aoMap.flipY = false</pre>
			<p>Just like the other kinds of texture maps, we just use <code>THREE.TextureLoader</code> to load the texture and<a id="_idIndexMarker940"/> assign it to the correct property of the material. And like with many of the other maps, we can also tune how much the map affects the lighting of the model by setting the <code>aoMapIntenisty</code> property. In this example, you can also see that we needed to set the <code>flipY</code> property of <code>aoMap</code> to false. Sometimes, external programs store the material in a texture slightly different than Three.js expects. With this property, we flip the orientation of the texture. This is usually something you’ll notice by trial and error when working with the model.</p>
			<p>To make an ambient occlusion map work, we will (usually) need one additional step. We have already mentioned UV mappings (stored in the <code>uv</code> attribute). These define which part of a texture is mapped to a specific face of the model. For the ambient occlusion map, and also for the lightmap in the following example, Three.js uses a separate set of UV mappings (stored in the <code>uv2</code> attribute) because, often, the other textures need to be applied differently than the shadow and lightmap textures. For our example, we are just copying the UV mappings from the model; remember that when we use the <code>aoMap</code> property or the <code>lightMap</code> property, Three.js will use the value of the <code>uv2</code> attribute, instead of the <code>uv</code> attribute. If this attribute isn’t present in the model you load, most often, just copying the <code>uv</code> map property works as well since we didn’t do anything to optimize the ambient occlusion map, which might require a different set of UVs:</p>
			<pre class="source-code">
const k = mesh.geometry
const uv1 = k.getAttribute('uv')
const uv2 = uv1.clone()
k.setAttribute('uv2', uv2)</pre>
			<p>We will provide two examples where we use an ambient occlusion map. In the first one, we are showing the model from <em class="italic">Figure 10</em><em class="italic">.9</em> with <code>aoMap</code> applied (<code>texture-ao-map-model.html</code>):</p>
			<div><div><img src="img/Figure_10.10_B18726.jpg" alt="Figure 10.10 – Ambient occlusion map baked in Blender and then applied to a model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Ambient occlusion map baked in Blender and then applied to a model</p>
			<p>You can use the menu on<a id="_idIndexMarker941"/> the right to set <code>aoMapIntensity</code>. The higher this value is, the more shadows you’ll see from the loaded <code>aoMap</code> texture. As you can see, it is really useful to have an ambient occlusion map as it provides great details for the model, and makes it look much more lifelike. Some of the textures we’ve seen in this chapter already also provide an additional <code>aoMap</code> that you can use. If you open <code>texture-ao-map.html</code>, you will get a simple brick-like texture, but this time with <code>aoMap</code> added as well:</p>
			<div><div><img src="img/Figure_10.11_B18726.jpg" alt="Figure 10.11 – Ambient occlusion map combined with color and normal maps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Ambient occlusion map combined with color and normal maps</p>
			<p>While an ambient occlusion map changes the amount of light received by certain parts of the model, Three.js also<a id="_idIndexMarker942"/> supports <code>lightmap</code>, which do the opposite (approximately) by specifying a map that adds extra lighting to certain parts of the model.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Creating fake lighting using a lightmap</h2>
			<p>In this section, we’ll use a<a id="_idIndexMarker943"/> lightmap. A lightmap is a texture that contains information about how much the lights in the scene will affect the model. In other words, the effect of the lights is baked into a texture. Lightmaps are baked in 3D software, such as Blender, and contain the light values of each part of the model:</p>
			<div><div><img src="img/Figure_10.12_B18726.jpg" alt="Figure 10.12 – Lightmap baked in Blender"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Lightmap baked in Blender</p>
			<p>The lightmap that we’ll use in this example is shown in <em class="italic">Figure 10</em><em class="italic">.12</em>. The right part of the edit window shows a<a id="_idIndexMarker944"/> baked lightmap for the ground plane. You can see that the whole ground plane is illuminated with white light, and parts of it receive less light because there is also a model in the scene. The code for using a lightmap is similar to that of an ambient occlusion map:</p>
			<pre class="source-code">
Const textureLoader = new THREE.TextureLoader()
const colorMap = textureLoader.load('/assets/textures/wood/
  abstract-antique-backdrop-164005.jpg')
const lightMap = textureLoader.load('/assets/gltf/
  material_ball_in_3d-coat/lightMap.png')
const material = new THREE.MeshBasicMaterial({ color: 
  0xffffff })
material.map = colorMap
material.lightMap = lightMap
material.lightMap.flipY = false</pre>
			<p>Once again, we need to provide Three.js with an additional set of <code>uv</code> values called <code>uv2</code> (not shown in the code), and we must use <code>THREE.TextureLoader</code> to load the textures – in this case, a simple texture is used for the colors of the floor and the lightmap created for this example in Blender. The result looks as follows (<code>texture-light-map.html</code>):</p>
			<div><div><img src="img/Figure_10.13_B18726.jpg" alt="Figure 10.13 – Using a lightmap for false shadows"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Using a lightmap for false shadows</p>
			<p>If you look at the preceding<a id="_idIndexMarker945"/> example, you will see that the information from the lightmap is used to create a very nice-looking shadow, which seems to be cast by the model. It is important to remember that baking shadows, lights, and ambient occlusion works great in static scenes with static objects. As soon as objects or light sources change or start to move, you will have to calculate the shadows in real time.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Metalness and roughness maps</h2>
			<p>When discussing the materials available in Three.js, we mentioned that a good default material to use is <code>THREE.MeshStandardMaterial</code>. You can use this to create shiny, metal-like materials, but also to apply roughness, to make the mesh look more like wood or plastic. By using the metalness and roughness properties of the material, we can configure the material to<a id="_idIndexMarker946"/> represent the material that we want. Aside from these two properties, you can also configure these properties by using a texture. So, if we have a rough object and we want to specify that a certain part of that object is shiny, we can set the <code>metalnessMap</code> property of <code>THREE.MeshStandardMaterial</code>, and if we want to indicate that some parts of the mesh should be seen as scratched or rougher, we can set the <code>roughnessMap</code> property. When you use these maps, the value of the texture for a specific part of the model is multiplied by either the <code>roughness</code> property or the <code>metalness</code> property, and that determines how that specific pixel should be rendered. First, we will look at the <code>metalness</code> property in <code>texture-metalness-map.html</code>:</p>
			<div><div><img src="img/Figure_10.14_B18726.jpg" alt="Figure 10.14 – Metalness texture applied to a model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Metalness texture applied to a model</p>
			<p>In this example, we’ve skipped ahead a bit and have also used an environment map, which allows us to render reflections from the environment on top of the objects. An object with a high metalness reflects more, and an object with a high roughness diffuses the reflection more. For<a id="_idIndexMarker947"/> this model, we’ve used <code>metalnessMap</code>; you can see that the object itself is shiny where the <code>metalness</code> property from the texture is high and that some parts are rough where the <code>metalness</code> property from the texture is low. When looking at <code>roughnessMap</code>, we can see pretty much the same but inverted:</p>
			<div><div><img src="img/Figure_10.15_B18726.jpg" alt="Figure 10.15 – Roughness texture applied to a model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Roughness texture applied to a model</p>
			<p>As you can see, based on the<a id="_idIndexMarker948"/> provided texture, certain parts of the model are rougher or more scratched than other parts. For <code>metalnessMap</code>, the value of the material is multiplied by the <code>metalness</code> property of the material; for <code>roughnessMap</code>, the same applies, but in that case, the value is multiplied by the <code>roughness</code> property.</p>
			<p>Loading these textures and setting them to the material can be done like so:</p>
			<pre class="source-code">
const metalnessTexture = new THREE.TextureLoader().load(
  '/assets/textures/engraved/Engraved_Metal_003_ROUGH.jpg',
  (texture) =&gt; {
    texture.wrapS = THREE.RepeatWrapping
    texture.wrapT = THREE.RepeatWrapping
    texture.repeat.set(4, 4)
  }
)
const material = new THREE.MeshStandardMaterial({ color: 
  0xffffff })
material.metalnessMap = metalnessTexture
...
const roughnessTexture = new THREE.TextureLoader().load(
  '/assets/textures/marble/marble_0008_roughness_2k.jpg',
  (texture) =&gt; {
    texture.wrapS = THREE.RepeatWrapping
    texture.wrapT = THREE.RepeatWrapping
    texture.repeat.set(2, 2)
  }
)
const material = new THREE.MeshStandardMaterial({ color: 
  0xffffff })
material.roughnessMap = roughnessTexture</pre>
			<p>Next up is the alpha map. With the alpha map, we can use a texture to change the transparency of parts of<a id="_idIndexMarker949"/> the model.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Using an alpha map to create transparent models</h2>
			<p>An alpha map is a way to control the <a id="_idIndexMarker950"/>opacity of the surface. If the<a id="_idIndexMarker951"/> value of the map is black, that part of the model will be fully transparent, and if it is white, it will be fully opaque. Before we look at the texture and how to apply it, we’ll first look at the example (<code>texture-alpha-map.html</code>):</p>
			<div><div><img src="img/Figure_10.16_B18726.jpg" alt="Figure 10.16 – Alpha map used to give partial transparency"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Alpha map used to give partial transparency</p>
			<p>In this example, we’ve rendered a cube and set the <code>alphaMap</code> property of the material. If you open this example, make sure to set the <code>transparency</code> property of the material to <code>true</code>. You’ll probably notice that you can only see the front-facing part of the cube, unlike the preceding screenshot, where you can look through the cube and see the other side. The reason is that, by default, the side property of the used material is set to <code>THREE.FrontSide</code>. To render the side that is normally hidden, we have to set the side property of the material to <code>THREE.DoubleSide</code>; you will see that the cube is rendered as shown in the<a id="_idIndexMarker952"/> preceding screenshot.</p>
			<p>The texture that we used in this example is a very simple one:</p>
			<div><div><img src="img/Figure_10.17_B18726.jpg" alt="Figure 10.17 – Texture used to create a transparent model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Texture used to create a transparent model</p>
			<p>To load it, we must use the<a id="_idIndexMarker953"/> same approach as that of the other textures:</p>
			<pre class="source-code">
const alphaMap = new THREE.TextureLoader().load('/assets/
  textures/alpha/partial-transparency.png', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(4, 4)
})
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.alphaMap = alphaMap
material.transparent = true</pre>
			<p>In this code fragment, you can also see that we’ve set the <code>wrapS</code>, <code>wrapT</code>, and <code>repeat</code> properties of the texture. We’ll<a id="_idIndexMarker954"/> explain these properties in more detail later in this chapter, but these properties<a id="_idIndexMarker955"/> can be used to determine how often we want to repeat the texture on the mesh. If set to <code>(1, 1)</code>, the whole texture won’t be repeated when applied to the mesh; if set to higher values, the texture will shrink and will be repeated multiple times. In this case, we repeated it in both directions four times.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Using an emissive map for models that glow</h2>
			<p>The emissive map is a texture<a id="_idIndexMarker956"/> that can be used to make certain parts of the model glow, just like the <code>emissive</code> property does for the whole model. Just as for the <code>emissive</code> property, using an emissive map doesn’t mean this object is emitting light – it just makes the part of the model where this texture is applied seem to glow. This is easier to understand by looking at an example. If you open up the <code>texture-emissive-map.html</code> example in your browser, you will see a lava-like object:</p>
			<div><div><img src="img/Figure_10.18_B18726.jpg" alt="Figure 10.18 – Lava-like object using an emissive map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Lava-like object using an emissive map</p>
			<p>When you look closely, though, you might see that while the objects seem to glow, the objects themselves don’t<a id="_idIndexMarker957"/> emit light. This means that you can use this to enhance objects, but the objects themselves don’t contribute to the lighting of the scene. For this example, we used an emissive map that looks as follows:</p>
			<div><div><img src="img/Figure_10.19_B18726.jpg" alt="Figure 10.19 – Lava texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Lava texture</p>
			<p>To load and use <a id="_idIndexMarker958"/>an emissive map, we can use a <code>THREE.TextureLoader</code> to load one and assign it to the <code>emissiveMap</code> property (together with some other maps to get the model shown in <em class="italic">Figure 10</em><em class="italic">.18</em>):</p>
			<pre class="source-code">
const emissiveMap = new   THREE.TextureLoader().load
  ('/assets/textures/lava/lava.png', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(4, 4)
})
const roughnessMap = new THREE.TextureLoader().load
  ('/assets/textures/lava/lava-smoothness.png', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(4, 4)
})
const normalMap = new THREE.TextureLoader().load
  ('/assets/textures/lava/lava-normals.png', (texture) =&gt; {
  texture.wrapS = THREE.RepeatWrapping
  texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(4, 4)
})
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.normalMap = normalMap
material.roughnessMap = roughnessMap
material.emissiveMap = emissiveMap
material.emissive = new THREE.Color(0xffffff)
material.color = new THREE.Color(0x000000)</pre>
			<p>Since the color from <code>emissiveMap</code> is modulated with the emissive property, make sure that you set the <code>emissive</code> property <a id="_idIndexMarker959"/>of the material to something other than black.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/>Using a specular map to determine shininess</h2>
			<p>In the previous examples, we<a id="_idIndexMarker960"/> mostly used <code>THREE.MeshStandardMaterial</code>, and the different maps supported by that material. <code>THREE.MeshStandardMaterial</code> is often your best choice if you need a material since it can be easily configured to represent a large number of different types of real-world materials. In older versions of Three.js, you had to use <code>THREE.MeshPhongMaterial</code> for shiny materials and <code>THREE.MeshLambertMaterial</code> for non-shiny materials. The specular map used in this section can only be used together with <code>THREE.MeshPhongMaterial</code>. With a specular map, you can define which parts of the model should be shiny, and which parts of them should be rough (similar to <code>metalnessMap</code> and <code>roughnessMap</code>, which we saw earlier). In the <code>texture-specular-map.html</code> example, we’ve rendered the Earth and used a specular map to make the oceans shinier than the landmasses:</p>
			<div><div><img src="img/Figure_10.20_B18726.jpg" alt="Figure 10.20 – Specular map showing reflecting oceans"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – Specular map showing reflecting oceans</p>
			<p>By using the menu at the<a id="_idIndexMarker961"/> top right, you can play around with the specular color and the shininess. As you can see, these two properties affect how the oceans reflect light, but they don’t change the landmasses’ shininess. This is because we’ve used the following specular map:</p>
			<div><div><img src="img/Figure_10.21_B18726.jpg" alt="Figure 10.21 – Specular map texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Specular map texture</p>
			<p>In this map, the black color means that those parts of the map have a shininess of 0%, and the white parts have a<a id="_idIndexMarker962"/> shininess of 100%.</p>
			<p>To use a specular map, we must use <code>THREE.TextureLoader</code> to load the map and assign it to the <code>specularMap</code> property of a <code>THREE.MathPhongMaterial</code>:</p>
			<pre class="source-code">
const colorMap = new THREE.TextureLoader().load
  ('/assets/textures/specular/Earth.png')
const specularMap = new THREE.TextureLoader().load
  ('/assets/textures/specular/EarthSpec.png')
const normalMap = new THREE.TextureLoader().load
  ('/assets/textures/specular/EarthNormal.png')
const material = new THREE.MeshPhongMaterial({ color: 
  0xffffff })
material.map = colorMap
material.specularMap = specularMap
material.normalMap = normalMap</pre>
			<p>With the specular map, we’ve <a id="_idIndexMarker963"/>discussed most of the basic textures that you can use to add depth, color, transparency, or additional light effects to your model. In the next two sections, we’ll look at one more type of map, which will allow you to add environment reflections to your model.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>Creating fake reflections using an environment map</h2>
			<p>Calculating environment<a id="_idIndexMarker964"/> reflections is very CPU-intensive, and it usually requires a ray tracer approach. If you want to use reflections in Three.js, you can still do that, but you’ll have to fake it. You can do so by creating a texture of the environment the object is in and applying it to the specific object. First, we’ll show you the result that we’re aiming for (see <code>texture-environment-map.html</code>, which is shown in the following screenshot):</p>
			<div><div><img src="img/Figure_10.22_B18726.jpg" alt="Figure 10.22 – Environment map showing the inside of a car"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Environment map showing the inside of a car</p>
			<p>In the preceding screenshot, you can see that the sphere reflects the environment. If you move your mouse around, you will also see that the reflection corresponds with the camera angle, concerning<a id="_idIndexMarker965"/> the environment you see. To create this example, perform the following steps:</p>
			<ol>
				<li>Create a <code>CubeTexture</code> object. A <code>CubeTexture</code> is a set of six textures that can be applied to each side of a cube.</li>
				<li>Set the skybox. When we have a <code>CubeTexture</code>, we can set it as the background of the scene. If we do this, we effectively create a very large box, inside of which the cameras and objects are placed, so that when we move the camera around, the background of the scene also changes correctly. Alternatively, we could also create a very large cube, apply <code>CubeTexture</code>, and add it to the scene ourselves.</li>
				<li>Set the <code>CubeTexture</code> object as a texture of the <code>cubeMap</code> property of the material. The same <code>CubeTexture</code> object that we used to simulate the environment should be used as a texture on the meshes. Three.js will make sure it looks like a reflection of the environment.</li>
			</ol>
			<p>Creating a <code>CubeTexture</code> is pretty easy, once <a id="_idIndexMarker966"/>you have the source material. What you will need are six images that, together, make up a complete environment. So, you will need the following pictures:</p>
			<ul>
				<li>Looking forward (<code>posz</code>)</li>
				<li>Looking backward (<code>negz</code>)</li>
				<li>Looking up (<code>posy</code>)</li>
				<li>Looking down (<code>negy</code>)</li>
				<li>Looking right (<code>posx</code>)</li>
				<li>Looking left (<code>negx</code>)</li>
			</ul>
			<p>Three.js will patch these together to create a seamless environment map. There are several sites where you can download panoramic images, but they are often in a spherical equirectangular format, which looks as follows:</p>
			<div><div><img src="img/Figure_10.23_B18726.jpg" alt="Figure 10.23 – Equirectangular format cube map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – Equirectangular format cube map</p>
			<p>There are two ways you can use these kinds of maps. First, you can convert it into a cube map format consisting of six separate files. You can convert this online using the following site: <a href="https://jaxry.github.io/panorama-to-cubemap/">https://jaxry.github.io/panorama-to-cubemap/</a>.</p>
			<p>Alternatively, you can use a <a id="_idIndexMarker967"/>different way to load this texture into Three.js, which we’ll show later in this section.</p>
			<p>To load a <code>CubeTexture</code> from six separate files, we can use <code>THREE.CubeTextureLoader</code>, like this:</p>
			<pre class="source-code">
const cubeMapFlowers = new THREE.CubeTextureLoader().load([
  '/assets/textures/cubemap/flowers/right.png',
  '/assets/textures/cubemap/flowers/left.png',
  '/assets/textures/cubemap/flowers/top.png',
  '/assets/textures/cubemap/flowers/bottom.png',
  '/assets/textures/cubemap/flowers/front.png',
  '/assets/textures/cubemap/flowers/back.png'
])
const material = new THREE.MeshPhongMaterial({ color: 
  0x777777 }
material.envMap = cubeMapFlowers
material.mapping = THREE.CubeReflectionMapping</pre>
			<p>Here, you can see that we’ve loaded a <code>cubeMap</code> out of several different images. Once loaded, we assign the texture to the <code>envMap</code> property of a material. Finally, we must inform Three.js of which<a id="_idIndexMarker968"/> kind of mapping we want to use. If you load a texture using <code>THREE.CubeTextureLoader</code>, you can use <code>THREE.CubeReflectionMapping</code> or <code>THREE.CubeRefractionMapping</code>. The first one will make your object show reflections based on the loaded <code>cubeMap</code>, while the second one will turn your model into a more translucent glass-like object that refracts the lights slightly, once again based on the information from <code>cubeMap</code>.</p>
			<p>We can also set this <code>cubeMap</code> as a background for the scene, like this:</p>
			<pre class="source-code">
scene.background = cubeMapFlowers</pre>
			<p>When you’ve got a single image, the process isn’t much different:</p>
			<pre class="source-code">
const cubeMapEqui = new THREE.TextureLoader().load
  ('/assets/equi.jpeg')
const material = new THREE.MeshPhongMaterial({ color: 
  0x777777 }
material.envMap = cubeMapEqui
material.mapping = THREE.EquirectangularReflectionMapping
scene.background = cubeMapFlowers</pre>
			<p>This time, we used the normal texture loader, but by specifying a different <code>mapping</code>, we can inform Three.js how to render this texture. When using this approach, you can set the mapping to either <code>THREE.EquirectangularRefractionMapping</code> or <code>THREE.EquirectangularReflectionMapping</code>.</p>
			<p>The result of both these approaches is a scene where it looks like we’re standing in a wide, outdoor environment, where<a id="_idIndexMarker969"/> the meshes reflect the environment. The menu on the side allows you to set the properties of the material:</p>
			<div><div><img src="img/Figure_10.24_B18726.jpg" alt="Figure 10.24 – Using refraction to create glass-like objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Using refraction to create glass-like objects</p>
			<p>Aside from reflection, Three.js also allows you to use a <code>cubeMap</code> object for refraction (glass-like objects). The following screenshot shows this (you can test this yourself by using the menu on the right):</p>
			<div><div><img src="img/Figure_10.25_B18726.jpg" alt="Figure 10.25 – Using refraction to create glass-like objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Using refraction to create glass-like objects</p>
			<p>To get this effect, we only need to <a id="_idIndexMarker970"/>set the mapping property of <code>cubeMap</code> to <code>THREE.CubeRefractionMapping</code> (the default is the reflection, which can also be set manually by specifying <code>THREE.CubeReflectionMapping</code>):</p>
			<pre class="source-code">
 cubeMap.mapping = THREE.CubeRefractionMapping</pre>
			<p>In this example, we used a static environment map for the meshes. In other words, we only saw the environment’s reflection and not the other meshes in the environment. In the following screenshot, you can see that, with a little bit of work, we can show the reflections of other objects as well:</p>
			<div><div><img src="img/Figure_10.26_B18726.jpg" alt="Figure 10.26 – Using a cubeCamera to create dynamic reflections"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.26 – Using a cubeCamera to create dynamic reflections</p>
			<p>To also show reflections from <a id="_idIndexMarker971"/>the other objects in the scene, we need to use some other Three.js components. The first of them is an additional camera called <code>THREE.CubeCamera</code>:</p>
			<pre class="source-code">
const cubeRenderTarget = new THREE.WebGLCubeRenderTarget
  (128, {
  generateMipmaps: true,
  minFilter: THREE.LinearMipmapLinearFilter
})
const cubeCamera = new THREE.CubeCamera(0.1, 10, cubeRenderTarget)
cubeCamera.position.copy(mesh.position); 
scene.add(cubeCamera);</pre>
			<p>We will use <code>THREE.CubeCamera</code> to take a snapshot of the scene with all of the objects rendered and use that to set up a <code>cubeMap</code>. The first two arguments define the near and far properties of the camera. So, in this case, the camera only renders what it can see from 0.1 to 1.0. The<a id="_idIndexMarker972"/> last property is the target to which we want to render the texture. For that, we’ve created an instance of a <code>THREE.WebGLCubeRenderTarget</code>. The first parameter is the size of the render target. The higher the value, the more detailed the reflection will look. The other two properties are used to determine how the texture is scaled up and down when you zoom in. </p>
			<p>You need to make sure that you position this camera at the exact location of <code>THREE.Mesh</code> on which you want to show the dynamic reflections. In this example, we copied the position from the mesh so that the camera is positioned correctly.</p>
			<p>Now that we have <code>CubeCamera</code> set up correctly, we need to make sure that what <code>CubeCamera</code> sees is applied as a texture to the cube in our example. To do this, we must set the <code>envMap</code> property to <code>cubeCamera.renderTarget</code>:</p>
			<pre class="source-code">
cubeMaterial.envMap = cubeRenderTarget.texture;</pre>
			<p>Now, we have to make sure that <code>cubeCamera</code> renders the scene so that we can use that output as input for the cube. For this, we must update the render loop as follows (or if the scene doesn’t change, we can just call this once):</p>
			<pre class="source-code">
const render = () =&gt; {
...
mesh.visible = false; 
cubeCamera.update(renderer, scene); 
mesh.visible = true;
requestAnimationFrame(render); 
renderer.render(scene, camera);
....
}</pre>
			<p>As you can see, first, we disable the visibility of <code>mesh</code>. We do this because we only want to see reflections from the other objects. Next, we render the scene using <code>cubeCamera</code> by calling the <code>update</code> function. After that, we make <code>mesh</code> visible again and render the scene as normal. The<a id="_idIndexMarker973"/> result is that, in the reflection of <code>mesh</code>, you can see the cubes that we added. For this example, every time you click on the <code>updateCubeCamera</code> button, the <code>envMap</code> property of the mesh will be updated.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>Repeat wrapping</h2>
			<p>When you apply a texture<a id="_idIndexMarker974"/> to a geometry created by Three.js, Three.js will try to apply the texture as optimally as possible. For instance, for cubes, this means that each side will show the complete texture, and for spheres, the complete texture is wrapped around the sphere. However, there are situations where you won’t want the texture to spread around a complete face or the complete geometry, but rather have the texture repeat itself. Three.js provides functionality that allows you to control this. An example where you can play around with the repeat properties is provided in <code>texture-repeat-mapping.html</code>. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_10.27_B18726.jpg" alt="Figure 10.27 – Repeat wrapping on a sphere"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.27 – Repeat wrapping on a sphere</p>
			<p>Before this property has the desired effect, you need to make sure that you set the wrapping of the texture to <code>THREE.RepeatWrapping</code>, as shown in the following code snippet:</p>
			<pre class="source-code">
mesh.material.map.wrapS = THREE.RepeatWrapping; 
mesh.material.map.wrapT = THREE.RepeatWrapping;</pre>
			<p>The <code>wrapS</code> property <a id="_idIndexMarker975"/>defines how you want the texture to wrap along its <em class="italic">X</em>-axis, and the <code>wrapT</code> property defines how the texture should be wrapped along its <em class="italic">Y</em>-axis. Three.js provides three options for this, which are as follows:</p>
			<ul>
				<li><code>THREE.RepeatWrapping</code> allows the texture to repeat itself</li>
				<li><code>THREE.MirroredRepeatWrapping</code> allows the texture to repeat itself, but each repetition is mirrored</li>
				<li><code>THREE.ClampToEdgeWrapping</code> is a default setting where the texture doesn’t repeat as a whole; only the pixels at the edge are repeated</li>
			</ul>
			<p>In this example, you can play around with the various repeat settings and <code>wrapS</code> and <code>wrapT</code> options. Once the wrapping type has been selected, we can set the <code>repeat</code> property, as shown in the following code fragment:</p>
			<pre class="source-code">
mesh.material.map.repeat.set(repeatX, repeatY);</pre>
			<p>The <code>repeatX</code> variable defines <a id="_idIndexMarker976"/>how often the texture is repeated along its <em class="italic">X</em>-axis, and the <code>repeatY</code> variable defines the same for the <em class="italic">Y</em>-axis. If these values are set to 1, the texture won’t repeat itself; if they are set to a higher value, you’ll see that the texture will start to repeat. You can also use values lower than 1. In that case, you’ll zoom in on the texture. If you set the repeat value to a negative value, the texture will be mirrored.</p>
			<p>When you change the <code>repeat</code> property, Three.js will automatically update the textures and render them with this new setting. If you change from <code>THREE.RepeatWrapping</code> to <code>THREE.ClampToEdgeWrapping</code>, you will have to explicitly update the texture using <code>mesh.material.map.needsUpdate = </code><code>true;</code>:</p>
			<div><div><img src="img/Figure_10.28_B18726.jpg" alt="Figure 10.28 – Clamp to edge wrapping on a sphere"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.28 – Clamp to edge wrapping on a sphere</p>
			<p>So far, we’ve only used static <a id="_idIndexMarker977"/>images for our textures. However, Three.js also has the option to use the HTML5 canvas as a texture.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Rendering to a canvas and using it as a texture</h1>
			<p>In this section, we will look at two different examples. First, we will look at how you can use the canvas to create a simple <a id="_idIndexMarker978"/>texture and apply it to a mesh; after that, we’ll go one step further and create a canvas that can be used as a bump map, using a randomly generated pattern.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Using the canvas as a color map</h2>
			<p>In this first example, we’ll render<a id="_idIndexMarker979"/> a fractal to an HTML <code>Canvas</code> element and use that as a <a id="_idIndexMarker980"/>color map for our mesh. The following screenshot shows this example (<code>texture-canvas-as-color-map.html</code>):</p>
			<div><div><img src="img/Figure_10.29_B18726.jpg" alt="Figure 10.29 – Using an HTML canvas as a texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.29 – Using an HTML canvas as a texture</p>
			<p>First, we’ll look<a id="_idIndexMarker981"/> at the<a id="_idIndexMarker982"/> code required to render the fractal:</p>
			<pre class="source-code">
import Mandelbrot from 'mandelbrot-canvas'
...
const div = document.createElement('div')
div.id = 'mandelbrot'
div.style = 'position: absolute'
document.body.append(div)
const mandelbrot = new Mandelbrot(document.getElementById('mandelbrot'), {
  height: 300,
  width: 300,
  magnification: 100
})
mandelbrot.render()</pre>
			<p>We won’t go into too much detail, but this library requires a <code>div</code> element as input and will create a <code>canvas</code> element inside<a id="_idIndexMarker983"/> that <code>div</code>. The preceding code will render the<a id="_idIndexMarker984"/> fractal, as you can see in the previous screenshot. Next, we need to assign this canvas to the <code>map</code> property of our material:</p>
			<pre class="source-code">
const material = new THREE.MeshPhongMaterial({
  color: 0xffffff,
  map: new THREE.Texture(document.querySelector
    ('#mandelbrot canvas'))
})
material.map.needsUpdate = true</pre>
			<p>Here, we just create a new <code>THREE.Texture</code> and pass in the reference to the <code>canvas</code> element. The only thing we need to do is set <code>material.map.needsUpdate</code> to <code>true</code>, which will trigger Three.js to get the latest information from the <code>canvas</code> element, at which point we will see it applied to the mesh.</p>
			<p>We can, of course, use this same idea for all of the different types of maps that we’ve seen so far. In the next example, we’ll use the canvas as a bump map.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>Using the canvas as a bump map</h2>
			<p>As you saw earlier in this chapter, we<a id="_idIndexMarker985"/> can add height to our model using a bump map. The higher the intensity of a pixel in this map, the higher the wrinkling. Since a bump<a id="_idIndexMarker986"/> map is just a simple black-and-white image, nothing keeps us from creating it on a canvas and using that canvas as an input for the bump map.</p>
			<p>In the following example, we will use a canvas to generate a Perlin noise-based grayscale image, and we will use that image as input for the bump map that we apply to the cube. See the <code>texture-canvas-as-bump-map.html</code> example. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_10.30_B18726.jpg" alt="Figure 10.30 – Using an HTML canvas as a bump map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.30 – Using an HTML canvas as a bump map</p>
			<p>The approach for this is pretty much the same as we saw in the previous canvas example. We need to create a <a id="_idIndexMarker987"/>canvas element and fill that canvas with some noise. To do so, we must use Perlin<a id="_idIndexMarker988"/> noise. Perlin noise generates a very natural-looking texture, as you can see in the preceding screenshot. More information on Perlin noise and other noise generators can be found here: <a href="https://thebookofshaders.com/11/">https://thebookofshaders.com/11/</a>. The code to accomplish this is shown here:</p>
			<pre class="source-code">
import generator from 'perlin'
var canvas = document.createElement('canvas')
canvas.className = 'myClass'
const size = 512
canvas.style = 'position:absolute;'
canvas.width = size
canvas.height = size
document.body.append(canvas)
const ctx = canvas.getContext('2d')
for (var x = 0; x &lt; size; x++) {
  for (var y = 0; y &lt; size; y++) {
    var base = new THREE.Color(0xffffff)
    var value = (generator.noise.perlin2(x / 8, y / 8) + 1) / 2
    base.multiplyScalar(value)
    ctx.fillStyle = '#' + base.getHexString()
    ctx.fillRect(x, y, 1, 1)
  }
}</pre>
			<p>We use the <code>generator.noise.perlin2</code> function to create a value from 0 to 1, based on the <code>x</code> and <code>y</code> coordinates of the <code>canvas</code> element. This value is used to draw a single pixel on the <code>canvas</code> element. Doing this for all the pixels creates the random map that you can see in the top-left<a id="_idIndexMarker989"/> corner of the preceding screenshot. This map can<a id="_idIndexMarker990"/> then be used as a bump map:</p>
			<pre class="source-code">
const material = new THREE.MeshPhongMaterial({
  color: 0xffffff,
  bumpMap: new THREE.Texture(canvas)
})
material.bumpMap.needsUpdate = true</pre>
			<p class="callout-heading">Using a THREE.DataTexture for a dynamic texture</p>
			<p class="callout">In this example, we rendered Perlin noise using an HTML <code>canvas</code> element. Three.js also provides an alternative way to<a id="_idIndexMarker991"/> dynamically create a texture: you can create a <code>THREE.DataTexture</code> texture, where you can pass in a <code>Uint8Array</code> where you can directly set the RGB values. More information on how to use a <code>THREE.DataTexture</code> can be found here: <a href="https://threejs.org/docs/#api/en/textures/DataTexture">https://threejs.org/docs/#api/en/textures/DataTexture</a>.</p>
			<p>The final input that we use for the texture is another HTML element: the HTML5 video element.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>Using the output from a video as a texture</h2>
			<p>If you read the preceding<a id="_idIndexMarker992"/> section on rendering to a canvas, you may have thought about rendering video to a canvas and using that as input for a texture. That’s one way to do it, but Three.js already has direct support to use the HTML5 video element (through WebGL). Check out <code>texture-canvas-as-video-map.html</code>:</p>
			<div><div><img src="img/Figure_10.31_B18726.jpg" alt="Figure 10.31 – Using an HTML video as a texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.31 – Using an HTML video as a texture</p>
			<p>Using video as input for<a id="_idIndexMarker993"/> a texture is easy, just like using the canvas element. First, we need a video element to play the video:</p>
			<pre class="source-code">
const videoString = `
&lt;video
  id="video"
  src="img/Big_Buck_Bunny_small.ogv"
  controls="true"
&lt;/video&gt;
`
const div = document.createElement('div')
div.style = 'position: absolute'
document.body.append(div)
div.innerHTML = videoString</pre>
			<p>This creates a basic HTML5 <code>video</code> element, by setting the HTML string directly to the <code>innerHTML</code> property of the <code>div</code> element. While this works great for testing, frameworks and libraries usually provide better options for this. Next, we can configure Three.js to use the video as <a id="_idIndexMarker994"/>an input for a texture, as follows:</p>
			<pre class="source-code">
const video = document.getElementById('video')
const texture = new THREE.VideoTexture(video)
const material = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  map: texture
})</pre>
			<p>The result can be seen in the <code>texture-canvas-as-video-map.html</code> example.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Summary</h1>
			<p>With that, we have completed this chapter on textures. As you’ve seen, a lot of textures are available in Three.js, each with a different use. You can use any image in PNG, JPG, GIF, TGA, DDS, PVR, TGA, KTX, EXR, or RGBE format as a texture. Loading these images is done asynchronously, so remember to either use a rendering loop or add a callback when you load a texture. With the different types of textures available, you can create great-looking objects from low-poly models.</p>
			<p>With Three.js, it is also easy to create dynamic textures, using either the HTML5 <code>canvas</code> element or the <code>video</code> element – just define a texture with these elements as the input, and set the <code>needsUpdate</code> property to <code>true</code> whenever you want the texture to be updated.</p>
			<p>With this chapter out of the way, we’ve pretty much covered all of the important concepts of Three.js. However, we haven’t looked at an interesting feature that Three.js offers: postprocessing. With postprocessing, you can add effects to your scene after it has been rendered. You can, for instance, blur or colorize your scene, or add a TV-like effect using scan lines. In <a href="B18726_11.xhtml#_idTextAnchor192"><em class="italic">Chapter 11</em></a>, <em class="italic">Render Postprocessing</em>, we’ll look at postprocessing and how you can apply it to your scene.</p>
		</div>
	

		<div><h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Part 4: Post-Processing, Physics, and Sounds</h1>
			<p>In this final part, we’ll look at a couple of more advanced topics. We’ll explain how you can set up a post-processing pipeline, which can be used to add different kinds of effects to the final rendered scene. We’ll also introduce the Rapier physics engine, and explain how you can use Three.js and Blender together. We end this part with information on how Three.js can be used together with React, TypeScript, and the Web-XR standard.</p>
			<p>In this part, there are the following chapters:</p>
			<ul>
				<li><a href="B18726_11.xhtml#_idTextAnchor192"><em class="italic">Chapter 11</em></a>, <em class="italic">Render Postprocessing</em></li>
				<li><a href="B18726_12.xhtml#_idTextAnchor212"><em class="italic">Chapter 12</em></a>, <em class="italic">Adding Physics and Sounds to Your Scene</em></li>
				<li><a href="B18726_13.xhtml#_idTextAnchor227"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Blender and Three.js</em></li>
				<li><a href="B18726_14.xhtml#_idTextAnchor240"><em class="italic">Chapter 14</em></a>, <em class="italic">Three.js Together with React, Typescript, and Web-XR</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>