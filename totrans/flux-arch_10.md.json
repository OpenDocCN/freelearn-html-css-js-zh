["```js\n// This is used by stores so that they can register\n// themselves with the dispatcher.\nexport function register(store) {\n\n  // Don't let a store register itself twice...\n  if (stores.includes(store)) {\n    throw `Store ${store} already registered`;\n  }\n\n  // Adds the \"store\" reference to \"stores\".\n  stores.push(store);\n\n  // Sorts our stores based on dependencies. If a store\n  // depends on another store, the other store is\n  // considered \"less than\" the store. This means that\n  // dependencies will be satisfied if the stores are\n  // processed in this sort order.\n  stores.sort((a, b) => {\n    if (a.deps.includes(b)) {\n      return 1;\n    }\n\n    if (b.deps.includes(a)) {\n      return -1;\n    }\n\n    return 0;\n  });\n}\n```", "```js\n// Used by action creator functions to dispatch an\n// action payload.\nexport function dispatch(payload) {\n\n  // The dispatcher is busy, meaning that we've\n  // called \"dispatch()\" while an update round\n  // was already taking place.\n  if (busy) {\n    throw 'Nested dispatch() call detected';\n  }\n\n  // Marks the dispatcher as \"busy\" before we\n  // start calling any store handlers.\n  busy = true;\n\n  // The action \"type\" determines the method\n  // that we'll call on a the store.\n  let { type } = payload;\n\n  // Iterates over each registered store, looking\n  // for a method name that matches \"type\". If found,\n  // then we call it, passing it the \"payload\" that\n  // was dispatched.\n  for (let store of stores) {\n    if (typeof store[type] === 'function') {\n      store[type](payload);\n    }\n  }\n\n  // The dispatcher isn't busy any more, so unmark it.\n  busy = false;\n}\n```", "```js\n// References to registered stores...\nconst stores = [];\n\n// This is true when the dispatcher is performing\n// an update round. By default, it's not busy.\nvar busy = false;\n\n// This is used by stores so that they can register\n// themselves with the dispatcher.\nexport function register(store) {\n\n  // Don't let a store register itself twice...\n  if (stores.includes(store)) {\n    throw `Store ${store} already registered`;\n  }\n\n  // Adds the \"store\" reference to \"stores\".\n  stores.push(store);\n\n  // Sorts our stores based on dependencies. If a store\n  // depends on another store, the other store is\n  // considered \"less than\" the store. This means that\n  // dependencies will be satisfied if the stores are\n  // processed in this sort order.\n  stores.sort((a, b) => {\n    if (a.deps.includes(b)) {\n      return 1;\n    }\n\n    if (b.deps.includes(a)) {\n      return -1;\n    }\n\n    return 0;\n  });\n}\n\n// Used by action creator functions to dispatch an\n// action payload.\nexport function dispatch(payload) {\n\n  // The dispatcher is busy, meaning that we've\n  // called \"dispatch()\" while an update round\n  // was already taking place.\n  if (busy) {\n    throw 'Nested dispatch() call detected';\n  }\n\n  // Marks the dispatcher as \"busy\" before we\n  // start calling any store handlers.\n  busy = true;\n\n  // The action \"type\" determines the method\n  // that we'll call on a the store.\n  let { type } = payload;\n\n  // Iterates over each registered store, looking\n  // for a method name that matches \"type\". If found,\n  // then we call it, passing it the \"payload\" that\n  // was dispatched.\n  for (let store of stores) {\n    if (typeof store[type] === 'function') {\n      store[type](payload);\n    }\n  }\n\n  // The dispatcher isn't busy any more, so unmark it.\n  busy = false;\n}\n```", "```js\nimport { EventEmitter } from 'events';\nimport { register } from './dispatcher';\n\n// Exports the base store for others to extend.\nexport default class Store extends EventEmitter {\n\n  // The constructor sets the initial \"state\" of the\n  // store, as well as any dependencies \"deps\" with\n  // other stores.\n  constructor(state = {}, deps = []) {\n    super();\n\n    // Stores the state and dependencies. The \"deps\"\n    // property is actually required by the\n    // dispatcher.\n    this.state = state;\n    this.deps = deps;\n\n    // Registers the store with the dispatcher.\n    register(this);\n  }\n\n  // This is a simple helper method that changes the\n  // state of the store, by setting the \"state\"\n  // property and then emitting the \"change\" event.\n  change(state) {\n    this.state = state;\n    this.emit('change', state);\n  }\n\n}\n```", "```js\nimport Store from '../store';\nimport second from './second';\nimport third from './third';\n\n// The initial state of the store, we'll\n// pass this to \"super()\" in the constructor.\nconst initialState = {\n  foo: false\n};\n\n// The dependencies this store has on other\n// stores. In this case, it's \"second\" and\n// \"third\". These too, are passed through\n// \"super()\".\nconst deps = [ second, third ];\n\nclass First extends Store {\n\n  // The call to \"super()\" takes care for setting up\n  // the initial store state, and the dependencies\n  // for us.\n  constructor() {\n    super(initialState, deps);\n  }\n\n  // Called in response to the \"FOO\" action\n  // being dispatched...\n  FOO(payload) {\n    this.change({ foo: true });\n  }\n\n  // Called in response to the \"BAR\" action\n  // being dispatched...\n  BAR(payload) {\n    this.change(Object.assign({\n      bar: true\n    }, this.state));\n  }\n}\n\nexport default new First();\n```", "```js\nimport Store from '../store';\nimport third from './third';\n\nclass Second extends Store {\n\n  // The call to \"super()\" sets the initial\n  // state for us.\n  constructor() {\n    super({\n      foo: false\n    });\n  }\n\n  // Called in response to the \"FOO\" action\n  // being dispatched...\n  FOO(payload) {\n    this.change({ foo: true });\n  }\n\n  // Called in response to the \"BAR\" action\n  // being dispatched. Note that we're\n  // dependent on the \"third\" store, yet\n  // we don't make this dependency explicit.\n  // This could lead to trouble.\n  BAR(payload) {\n    this.change({\n      foo: third.state.foo\n    });\n  }\n}\n\nexport default new Second();\n```", "```js\nimport Store from '../store';\n\nclass Third extends Store {\n\n  // The call to \"super()\" sets the initial\n  // state for us...\n  constructor() {\n    super({\n      foo: false\n    });\n  }\n\n  // Called in response to the \"FOO\" action\n  // being dispatched.\n  FOO(payload) {\n    this.change({ foo: 'updated' });\n  }\n}\n\nexport default new Third();\n```", "```js\nimport first from './stores/first';\nimport second from './stores/second';\nimport third from './stores/third';\n\nimport { foo } from './actions/foo';\nimport { bar } from './actions/bar';\n\n// Logs the state of each store as it changes...\nfirst.on('change', (state) => {\n  console.log('first', state);\n});\n\nsecond.on('change', (state) => {\n  console.log('second', state);\n});\n\nthird.on('change', (state) => {\n  console.log('third', state);\n});\n\nfoo();\n// →\n// third {foo: \"updated\"}\n// second {foo: true}\n// first {foo: true}\n\nbar();\n// →\n// second {foo: \"updated\"}\n// first {bar: true, foo: true}\n```"]