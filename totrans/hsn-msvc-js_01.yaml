- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As human beings, we all go through various stages of development. With each
    stage we reach, even if it seems like the best at the time, we later realize we
    still have a long way to go. Each period has its problems, and depending on their
    size and nature, they require different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: We humans tend to simplify things. That is why we build our lives around problems
    and their corresponding solutions. Finding solutions to problems has been our
    main goal throughout history, perhaps due to our instinct to survive.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider each piece of software as an individual, they also have problems
    to solve. Depending on the size and shape of the problems, software has a different
    structure, which we call **architecture**. The size and nature of the problems
    directly affect the architecture of the software. One of these architectural approaches
    we use is called microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices** are important when it comes to building scalable distributed
    applications that respond to modern-day concerns. It is also a de facto requirement
    for most huge companies when they interview you as a developer. The vast majority
    of technologies we use nowadays try to support microservice development out of
    the box. So, being a software engineer without microservice knowledge doesn’t
    make you an ideal candidate in the modern IT world.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this chapter, we’re going to dive into the world of microservices.
    We will build strong theoretical knowledge before moving on to practical sections.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will go back and try to understand what type of popular approaches
    were there before microservices. Microservices are important, but understanding
    the need to apply them is foremost.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the monolith approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is service-oriented architecture?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between SOA and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice architecture decomposes an application into loosely coupled,
    independently deployable services that own their data and communicate through
    lightweight protocols. It breaks down large applications into smaller, self-contained
    business capabilities, enabling faster development, easier scaling, and better
    fault tolerance. Microservices enable continuous delivery and agile development
    by allowing teams to independently build, test, and deploy features. You can imagine
    an application as an orchestra, where each microservice is a musician playing
    their part, but in perfect harmony with the others, to create a beautiful symphony.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve just mentioned sounds like a *silver bullet* but as you know, nothing
    is free and there is no one-size-fits-all solution to the problems we face. The
    same applies to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We, as software developers, love to learn new trends and try to apply them to
    our practice. But after delving into the details, we understand that every trend
    is just an encapsulation of old knowledge. Before applying any architecture to
    software, it is always better to engage in careful planning, discussion, collaboration,
    and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Moving toward microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating software is more than just learning a programming language and applying
    syntactical elements of it to code, to build things. It’s like wielding a hammer
    and nails; having them in your arsenal doesn’t make you a skilled builder. Similarly,
    having all the tools doesn’t make you a good software developer.
  prefs: []
  type: TYPE_NORMAL
- en: As you embark on creating a basic `hello world` type application, it remains
    just that – *basic*. However, it is important to understand that such simple applications
    don’t warrant payment. If you want your application to have value, it must address
    tangible real-world challenges – in short, it should hold business value. Adding
    more business value also brings complexity. In most cases, more business means
    more complexity. After some time, you’ll realize that instead of dealing with
    a business, you’re starting to deal with the complexity that your business brought
    to your application.
  prefs: []
  type: TYPE_NORMAL
- en: In navigating complexity, we aim to break it down into smaller, maintainable,
    extensible, and reusable components. Only by doing so can we effectively handle
    the complexity and future changes. In programming, the only true constant is the
    need to embrace changes, a principle that remains as-is, not just during the process
    of creating the application, but until the end.
  prefs: []
  type: TYPE_NORMAL
- en: This constant change forces us to not only master the selected programming language
    but also to have an understanding of the business domain. Naturally, this leads
    to us adopting a design-oriented mindset. Without having good knowledge of business,
    it is almost impossible to develop valuable software.
  prefs: []
  type: TYPE_NORMAL
- en: Although the simple applications we write to learn a language may seem useless,
    when we connect the dots, we get closer to the truth. Isn’t our whole life spent
    in search of truth? Soon, you’ll realize that the software that meets the customer’s
    business requirements is the software that matters, and that reflects the truth.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start your development process without carefully analyzing and designing,
    you’re going to pay a higher price throughout the development itself. The earlier
    you start with design and analysis, the less likely you are to run into a bigger
    problem at a later stage. We call our first not properly analyzed and designed
    application **a big ball of mud** that uses *spaghetti-driven development*:'
  prefs: []
  type: TYPE_NORMAL
- en: In software design, the phrase *a big ball of mud* is used to draw attention
    to an **anti-pattern** or a design approach that produces undesirable results.
    Let’s understand this phrase in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a big ball of mud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main issue with a big ball of mud is the lack of structure and organization.
    The absence of modularity and distinct issue separation in the code base leads
    to a complex network of interconnected files and functions. Imagine a house that
    is just a disorganized jumble of rooms and materials with no walls or other distinguishing
    features. Because everything in it is connected, changes that are made in one
    part could have a disastrous effect on other parts. It’s like pulling on a loose
    thread in a badly tailored sweater – you run the risk of the entire garment coming
    apart. Similarly code fragments are dispersed throughout the code base, which
    causes inefficiencies when performing maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the absence of structure and documentation, maintaining the code base
    and adding new features is challenging for developers. Imagine attempting to navigate
    a house devoid of layout or labels; it’s nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Because of their close coupling, changes in one area can unintentionally disturb
    seemingly unrelated components. Because of its fragility, the software is prone
    to mistakes and regressions. Imagine a house built with weak, interconnected supports
    so that even a small outside force could result in serious harm.
  prefs: []
  type: TYPE_NORMAL
- en: A big ball of mud may seem like the right choice at first in small, simple projects,
    but as the project grows and develops, its complexity quickly increases. To guarantee
    long-term maintainability, scalability, and developer satisfaction, this design
    approach must be avoided at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what? I already know that you’ve gone through this stage – the stage of
    applying and failing with a big ball of mud. These difficulties helped you learn
    more rather than learn from success.
  prefs: []
  type: TYPE_NORMAL
- en: Every difficulty teaches us something, right? Until one year in my life, I was
    always grateful for the good things in my life. But over time, I realized that
    it was those difficulties that made me who I am. After I changed my way of thinking,
    I began to thank the difficulties in my life and those who made me suffer. If
    you could go back and remove the difficulties in your life, believe me, you would
    also remove your present self. Difficulties strengthen you and make you a strong
    person.
  prefs: []
  type: TYPE_NORMAL
- en: Mankind is a creature that rarely listens to advice. We have to get into trouble
    – we have to experiment with trouble. I know that the downsides I mentioned about
    a big ball of mud in this section only make sense to those who have gone through
    this difficulty. In the end, we all learn through experimenting.
  prefs: []
  type: TYPE_NORMAL
- en: As a novice software developer, it’s beneficial to experiment with a big ball
    of mud at some point. You’ll quickly discover that while it provides a swift start,
    its efficiency dwindles over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to summarize the disadvantages of a big ball of mud:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unplanned and chaotic**: The appearance of a big ball of mud is the result
    of poor design and coding techniques rather than a deliberate architectural decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tight coupling**: The code is tightly interconnected; changes that are made
    to one section run the risk of having unexpected effects in unrelated areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficulty in understanding and maintaining**: The code base is messy and
    lacks documentation, making it hard for developers to grasp and modify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error-prone and fragile**: The code base leads to unpredictable errors and
    regressions with modifications. In a big ball of mud system, everything is tightly
    connected like a big mess of wires. This makes it hard to know what happens when
    you change one part, like trying to fix one loose wire in a tangled mess. This
    can easily lead to unexpected problems and things breaking, like causing a short
    circuit in the tangled wires, making it harder to develop and maintain the system
    in the long run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced developer productivity**: You spend more time on maintaining the
    code base instead of focusing on new features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited scaling and growth**: A rigid code structure makes it difficult to
    introduce new features or adapt to changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.1: A quality diagram of a big ball of mud](img/B09148_01_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: A quality diagram of a big ball of mud'
  prefs: []
  type: TYPE_NORMAL
- en: When writing a program, we see that it becomes more of a problem than a solution
    within a short time (see *Figure 1**.1*). The preceding graph tracks how a project
    progresses over time. Time is on the bottom (X-axis) and features added are on
    the side (Y-axis).
  prefs: []
  type: TYPE_NORMAL
- en: Starting a project without a clear plan, such as using the big ball of mud approach,
    might seem easy at first. Imagine building with blocks – no instructions are needed
    and you can put things together quickly. But for these projects, as they get more
    features (higher Y-axis value), the overall quality suffers (gets worse).
  prefs: []
  type: TYPE_NORMAL
- en: In the short term (a few weeks), both well-designed projects and big ball of
    mud projects might seem similar. But over time, the quality of the messy project
    goes downhill.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, while a big ball of mud approach might seem faster initially, it ultimately
    creates more problems in the long run. It’s like taking a shortcut that might
    save you time now but leads to bigger issues later on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the factors that turned our code into a big ball of mud over time was
    a lack of planning and organization. Planning and organizational structure are
    the attributes we usually use when building microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the software development process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The development process not only covers coding – it is also about business,
    communication, discussion, analyzing, designing, testing, and deploying. Let’s
    call these the **attributes** of the software development process (see *Figure
    1**.2*). Software development is much more than just writing code lines. While
    coding is certainly an important part, it’s only one piece of the puzzle. Because
    of that, it is essential to understand the core needs and goals of the business:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Software development life cycle](img/B09148_01_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Software development life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides comprehensive insights into the software development
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: The need to solve specific problems and think in terms of the business landscape
    is what drives software development. For developers to create software solutions
    that are not only relevant, but also meaningful, they must have a deep understanding
    of market dynamics, industry, and user requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective collaboration and transparent communication are the backbone of success
    at every stage. Developers engage with a range of stakeholders, including business
    analysts, designers, testers, and clients. Clear communication ensures that everyone
    is on the same page regarding objectives, requirements, and project milestones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the ideas, obstacles, and potential solutions is very important.
    Effective brainstorming sessions, code reviews, and attentive user feedback all
    contribute to the quality of software. Open communication makes problem-solving
    more efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is essential to carry out a thorough analysis of the requirements, user behavior
    patterns, and data insights. To create a solid software design strategy, developers
    must carefully analyze existing solutions, identify user needs, and break down
    complex problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Careful consideration must be given to the architecture, functionality, and
    user interface of the software. Software that has been carefully designed is easy
    to use, effective, and maintain. A friendly user experience is the result of close
    collaboration between developers and designers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict testing procedures are essential to guarantee the functionality, dependability,
    and conformity of the software regarding user expectations. Different testing
    approaches address different areas, such as performance benchmarks and core functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that end users can access the software is the last step. This is usually
    called **deployment**. This includes setting up the infrastructure, taking stringent
    security precautions, and, if needed, providing thorough user training to optimize
    usability and adoption rates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the software development process, let’s take a deeper
    look at the monolith approach to software development.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the monolith approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say we have an e-commerce site with a single code base that was developed years
    ago. Over time, features and functionalities were added randomly, leading to messy
    code that contains duplication, is hard to maintain, and is difficult to troubleshoot.
    Here is the first suggested transition so that you can make your application responsive
    or alive again:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyze the current state of your application**: You need to identify key
    pain points affecting developer productivity and user experience. Try to divide
    the problem into smaller pieces. Trying to cover everything at once will lead
    you to more difficulties. Focus on specific modules or functionalities within
    the larger code base for initial refactoring. You need to understand dependencies,
    duplication, and complexity in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication and collaborative planning**: The next steps are identifying
    the areas for improvement and agreeing on common architectural principles. Emphasize
    the phased approach, starting with small, isolated modules and demonstrating progress
    before moving on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choose a monolith architecture**: Decide which architectural style and pattern
    (layered, tiered, MVC, MVVM, and so on) aligns best with your needs in the given
    context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start small and iterate**: Set small goals and apply iterative development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make improvements**: Eliminate code duplication, clean up spaghetti code
    (a term that’s used for unstructured and difficult-to-understand programming code),
    and improve documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: After each refactoring step, it is better to apply unit, integration,
    and regression testing to ensure code functionality and identify potential regression
    in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: Gather feedback from developers and users throughout the process
    to adapt and refine the approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome – you’re in the world of monoliths! But what is the concept of monolith?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Monolith architecture](img/B09148_01_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Monolith architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Many online articles delve into the specifics of monolith architecture but rarely
    touch upon the broader concept, called the monolith approach. This isn’t surprising
    as the architecture has clear-cut characteristics. We love to be concrete and
    as developers, we are rarely theory lovers. However, it’s important to keep in
    mind that the monolith approach covers a greater variety of options.
  prefs: []
  type: TYPE_NORMAL
- en: The **monolith approach** is a broader concept that refers to a general way
    of building software as a single, self-contained unit. It can be implemented using
    various architectures, not just the traditional monolith architectures we know.
    It highlights simplicity, rapid development, and tight integration. The monolith
    approach is architecture-agnostic, meaning it can be implemented using various
    architectural styles or patterns, or even without a specific architectural framework
    at all, so long as the core principle of consolidating components into a single
    unit is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **monolith architecture** (see *Figure 1**.3*) is a specific
    software architecture where everything, from UI to business logic to data access,
    is built as a single, tightly coupled unit. It often uses a single code base,
    programming language, and database.
  prefs: []
  type: TYPE_NORMAL
- en: Monolith architecture refers to the specific architectural design or pattern
    that’s used to implement the monolith approach. It includes all of the technological
    choices and structural design of the monolithic system, including the arrangement
    of modules, the interactions between components, and the data management process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The monolith approach itself doesn’t dictate a specific architecture. However,
    certain architectural styles and patterns naturally align with and support the
    monolith approach more effectively than others. Examples include the layered architecture,
    the MVC architecture, and the N-tier architecture. The monolith approach can also
    be implemented without strictly adhering to a specific architecture, especially
    for smaller projects. The key feature here is to maintain a single code base and
    deployment unit. Whether you choose a structured style or a more organic approach,
    the core principle remains: build a cohesive software unit. Understanding this
    distinction forces you to make informed decisions when navigating the vast world
    of software architectures. So, while the monolith approach promotes the development
    of software as a unified entity, the monolith architecture determines how that
    unity is achieved and maintained. Knowing this difference allows you to navigate
    the wide world of software architectures with knowledge and confidence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While not without its drawbacks, the monolith approach offers several advantages,
    particularly for certain types of projects. These advantages are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity and speed**: Monolith architecture enables faster development
    and deployment cycles by consolidating the entire system into a single codebase,
    reducing the overhead of managing multiple services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability and control**: Having everything in one place allows for
    easier management, control over application performance, and a unified approach
    to maintaining and securing the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and cost**: This architecture offers the advantage of reduced
    complexity, leading to lower infrastructure costs and optimized performance for
    applications with straightforward requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional benefits**: It provides practical advantages for simpler projects,
    making it easier to manage data and application operations, especially for smaller
    teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though the monolithic approach has benefits, such as speed and simplicity,
    not all projects can benefit from it. To help determine whether the monolithic
    approach is right for your project, consider these general guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple and well-defined applications**: A monolith works well in applications
    that have a defined scope and few functionalities. Simple mobile apps, internal
    tools, and basic e-commerce sites are a few examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick product launches and idea testing**: This is made possible by the agility
    of a monolithic architecture, which is useful if your project requires for quick
    development cycles or frequent prototyping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Small teams with limited experience**: Initially, managing and maintaining
    a monolith may be more manageable for teams that lack experience with distributed
    systems or microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tight data coupling and consistency**: Monolithic architectures are advantageous
    for applications that rely heavily on consistent data across multiple functionalities.
    It guarantees data integrity throughout the application and simplifies data management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited scalability requirements**: Without the hassle of scaling microservices,
    a monolithic architecture might be able to satisfy your scalability requirements
    if your application expects stable user traffic and moderate growth projections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best architecture depends on your specific application’s requirements. Here,
    you must consider factors such as scalability, complexity, technology needs, and
    development team structure. As we mentioned previously, there’s no one-size-fits-all
    solution in software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the monolith approach has its benefits, it’s not suitable for every application.
    It’s better not to use monolith when it comes to the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a highly scalable application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications with constantly evolving features, modularity, and independent
    deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application requires integrating diverse technologies or frameworks,
    also referred to as heterogeneous technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If high availability and resilience are critical and one of the important attributes
    for your system is fault-tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If different teams work on distinct functionalities – that is, if there is independent
    development and deployment across teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have large teams and distributed development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides its pros and cons, Monolith is usually a preferable architecture for
    getting started but not the only architecture to build better applications. We
    have another preferable architecture called **service-oriented approach** (**SOA**)
    that we plan to dive into details starting from the next page.
  prefs: []
  type: TYPE_NORMAL
- en: What is service-oriented architecture?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A monolithic architecture unifies all of the components/elements – including
    the user interface and data access – into a single code base, promoting simplicity
    and quick development. Although it’s not impossible, combining different technologies
    into *one system* can be difficult to maintain and unfeasible at times. In the
    absence of contemporary methodologies such as feature flags and blue-green deployment,
    it becomes necessary to deploy the entire application every time you want to update
    a monolithic application. There are difficulties with organizing and delivering
    the application smoothly, which could mess up its launch.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, SOA (see *Figure 1**.4*) focuses on modularity and reuse,
    breaking down functionalities into independent services that communicate with
    each other through **application programming** **interfaces** (**API**s).
  prefs: []
  type: TYPE_NORMAL
- en: SOA can be defined as multiple, smaller, and often coarser-grained services,
    each with a specific function. This modularity offers advantages such as flexibility
    and scalability. Services in SOA can be deployed and scaled independently, meaning
    you can update or scale one service without affecting others. This is a key benefit
    of SOA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The analogy from moving from monolith to SOA can be described like this: You
    have a big method/function that does everything (similar to a monolith). After
    some time, some other parts of your functionalities are required so that these
    functionalities can be reused. Instead of copying it, you’re breaking this giant
    method into reusable parts (similar to SOA). In this case, the method calls are
    going to be our API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: An overview of service-oriented approach](img/B09148_01_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: An overview of service-oriented approach'
  prefs: []
  type: TYPE_NORMAL
- en: Consider multiple applications (as shown in *Figure 1**.4* – account management,
    CRM, and sales management) that need to share common functionalities. Instead
    of duplicating them for every application, we provide a service-oriented approach.
    At first glance, it may look like they are *perfect* grained services, but our
    focus is just to *share* common behavior that supports scaling and reusing.
  prefs: []
  type: TYPE_NORMAL
- en: To encapsulate communication complexity, we may use a service bus, which allows
    us to write additional logic and move the complexity to the outside of the application,
    which acts as a mediator. This is one of the signs that we should use architectural
    mediators in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Think of two functions within a single program and one directly calls the other.
    In SOA, each function becomes a standalone service, communicating through a defined
    interface. This enables independent deployment, updates, and even development
    by different teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine building with Lego bricks instead of monolithic blocks. That’s the
    essence of SOA: breaking down applications into reusable, independent services,
    each focused on a specific task. Instead of hard-coded connections, they communicate
    through standard protocols such as **REST** or **SOAP**, making them platform-agnostic
    and adaptable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SOA offers numerous advantages that can significantly improve the flexibility,
    agility, and efficiency of your organization’s IT infrastructure. Let’s discover
    its key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business agility**: SOA supports fast development and deployment, helping
    businesses quickly adapt to market changes and align their software with evolving
    business objectives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical advantages**: SOA offers flexibility and scalability, allowing
    for easier integration, upgrades, and reuse of components across the system without
    disrupting the overall functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational benefits**: SOA streamlines operations by reducing maintenance
    overhead and improving system reliability, while enhancing security through centralized
    management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although SOA has many advantages, there are drawbacks as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced complexity**: SOA introduces more complexity by requiring careful
    coordination between independent services, demanding skilled personnel, and detailed
    planning for development, testing, and maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Possible problems with performance**: SOA can introduce latency due to network-based
    service interactions, adding complexity when ensuring secure and efficient communication
    between services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other difficulties**: SOA comes with high upfront costs and requires skilled
    professionals, making it challenging to maintain service coordination, manage
    responsibilities, and ensure smooth integration as the system evolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOA is one step toward microservices. Most of the core ideas of microservices
    come from SOA.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we’ll understand the benefits and challenges
    of the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between SOA and microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices architecture simplifies building distributed, flexible, and scalable
    software. Instead of one monolithic system, it divides an application into small,
    standalone services, each of them focused on a specific task. These services communicate
    through simple interfaces, allowing for independent deployment and easy integration.
    When developing properly designed microservices, we get loosely coupled, reusable,
    extensible, and easily maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'When comparing microservices to SOA, they may seem similar in concept. SOA
    and microservices architecture are both architectural styles that are used for
    building distributed systems, but they have some key differences. Let’s compare
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope and granularity**: Services in SOA are like big boxes containing multiple
    functionalities that are meant to be reused across different applications. Microservices
    are like tiny, specialized tools, each focusing on one specific task or feature
    within an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication protocols**: Services in SOA mostly communicate using strict
    protocols, such as **SOAP**, **XML-RPC**, **WSDL**, and **UDDI**. Microservices
    prefer lightweight protocols such as **RESTful HTTP** or messaging queues, allowing
    for more flexible communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology stack**: SOA can work with different technologies and platforms.
    Microservices often use containerization tools such as **Docker** and orchestration
    tools such as **Kubernetes** for easier deployment and management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency management**: Services in SOA can have intricate dependencies
    that require careful coordination. Microservices strive for loose coupling, reducing
    dependencies between services to simplify development and deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment and scaling**: Services in SOA are often centrally deployed and
    scaled at the service level. Microservices are deployed separately, allowing individual
    scaling and better resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organizational impact**: Once SOA is implemented, significant organizational
    changes may be required for coordination and management. Microservices promote
    decentralization of management by giving small, cross-disciplinary teams the autonomy
    to control their services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between *approach* and *architecture*, especially regarding microservices,
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The microservice approach is all about how we think when designing software.
    It’s like having a mindset or philosophy of breaking down big, complicated systems
    into smaller, easier-to-handle parts. Each of these parts focuses on one specific
    task. It’s somewhat abstract and emphasizes concepts such as **modularity** (allowing
    for simple replacement), **scalability** (allowing for increased work), and **flexibility**
    (allowing for change adaptation):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Microservices architecture](img/B09148_01_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Microservices architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Every approach has its pros and cons. Nothing is ideal. To identify it from
    the Microservices perspective, let’s talk about the advantages and disadvantages
    of Microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at the many reasons that make microservices an
    important part of software development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: You can scale each microservice independently based on demand,
    ensuring resources are allocated where needed for optimal performance and cost-effectiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility and agility**: Teams can work on different services simultaneously,
    speeding up development and making updates easier. Being agile is essential to
    adapting to the ever-shifting demands and markets of businesses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault isolation**: If one microservice fails, it doesn’t necessarily affect
    others, thanks to their independence. This isolation improves system reliability
    by minimizing downtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology diversity**: Multiple programming languages and technologies can
    be used in a single application thanks to microservices. Teams are encouraged
    to explore and be creative by selecting the finest tools for each service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy maintenance and updates**: Compared to huge monolithic programs, smaller
    services are easier to comprehend, manage, and update. Risks are decreased because
    modifications to one service won’t inadvertently affect others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable development****teams**: Small, cross-functional teams can now own
    separate services thanks to microservices. This configuration promotes creativity,
    accelerates decision-making, and heightens accountability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved fault tolerance**: Microservices make it simpler to implement redundancy
    and failover techniques at the service level. This increases the system’s ability
    to withstand setbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved deployment practices**: **Continuous integration** and **continuous
    deployment** (**CI/CD**), two contemporary deployment techniques, mesh nicely
    with **microservices** architecture. Time to market is shortened by the release
    process being streamlined by automated deployment pipelines for every service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved use of resources**: Resource allocation based on the unique requirements
    of each service is made possible by granular scaling, which maximizes resource
    efficiency and reduces costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encouragement of cooperation**: Encouraging cooperation between the development
    and operations teams through microservices makes it easier to implement DevOps
    principles. At the service level, feedback loops, automation, and monitoring can
    be put into place to improve overall quality and efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Huge and complicated systems**: Microservices can help you simplify huge
    and complex applications as you can divide them into smaller, more manageable
    parts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handles many users**: Because microservices allow you to scale each component
    individually to effectively handle the load, they are ideal for apps that experience
    high traffic or a large number of users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requires frequent updates or new features**: Microservices allow you to swiftly
    react to changing needs by allowing you to change individual components without
    affecting the entire application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uses different technologies**: Microservices let you use different tools
    and programming languages for different parts of your app so that you can pick
    the best one for each job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built by many teams**: If your app is being worked on by lots of different
    teams, microservices let each team work on their part, without getting in each
    other’s way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Needs to stay running**: Microservices help your app stay up and running,
    even if one part fails. This is because each part is separate. As a result, problems
    in one area don’t crash the whole thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Works in the cloud**: Microservices are a good fit for apps that run in the
    cloud because they’re designed to work well with cloud technology. Plus, tools
    such as containers and orchestrators make it even easier to manage them in the
    cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, microservices provide a modern, flexible method for developing software,
    allowing businesses to innovate rapidly, grow effectively, and release high-caliber
    software products into the market more quickly. However, don’t attempt to use
    them for every kind of application you’re creating.
  prefs: []
  type: TYPE_NORMAL
- en: Although microservices offer many advantages, you should be aware that they
    also come with some additional complexity, such as having to manage several moving
    components and more communication being required between services.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we learned that the main reason for having various
    architectures in software development is a sign that there is no single truth
    and that depending on the requirements, architecture may vary. Every approach
    in design has its disadvantages and before applying any architecture, you should
    carefully analyze and understand them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important disadvantages of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased complexity in development**: Breaking down a system into smaller
    services can lead to increased complexity in development, deployment, and testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interservice communication**: Managing communication between microservices
    can become complex, requiring careful design and implementation of APIs and protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure complexity**: Managing and deploying a large number of microservices
    can introduce operational overhead, including the need for sophisticated orchestration
    and monitoring tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure cost**: The overhead of managing multiple services and the
    associated infrastructure can lead to increased costs, particularly in terms of
    hosting and operational expenses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security issues**: A larger number of services means a larger attack surface,
    potentially increasing the security risk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication security**: Securing communication between microservices requires
    additional attention to prevent unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordination and communication**: Teams need to coordinate effectively to
    ensure that changes in one service do not adversely affect others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data consistency**: Maintaining consistency across microservices can be challenging,
    especially when dealing with distributed databases. Ensuring data integrity and
    consistency becomes a complex task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team expertise**: Developers need expertise in both the domain and technology
    stack of their specific microservice, potentially limiting flexibility in task
    assignments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we should carefully consider if microservices are the correct choice
    for our project based on the expertise of our team, the requirements of our application,
    and the readiness of our organization for the shift.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to microservices. We talked about coding without
    proper design and analysis, which brings us to a big ball of mud. Having no clear
    architecture is similar to having no map in the middle of the ocean.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step was starting with monoliths. We talked about the advantages and
    disadvantages of the monolith approach and tried to understand the differences
    between approach and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, requirements for applications are broader and more complex, and always
    trying to deal with them using a monolith approach may not be a good solution.
    To add important attributes, such as “distributed,” to the architecture, we considered
    SOA while discussing its pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: The final destination for us was microservices. We provided a clear definition
    for it and tried to understand the advantages and disadvantages of using them.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices bring a lot of interesting challenges to our lives and one of
    them is communication. Dividing a big problem into smaller chunks is good but
    making proper communication between the chunks isn’t easy. When you’re ready,
    turn to the next chapter to explore it with me.
  prefs: []
  type: TYPE_NORMAL
