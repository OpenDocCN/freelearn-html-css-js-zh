- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Associating Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than using validations to ensure consistency within our database, we can
    also create associations between two tables to ensure symbiotic relationships
    are maintained and updated. Databases maintain these relationships by creating
    **foreign key references** that hold metadata as to which table and column the
    foreign key is associated with. This metadata is what maintains integrity for
    the database. If we were to update a foreign key’s value without a proper reference,
    we would have to perform a separate query to update all of the rows that contained
    a reference to the foreign key to its new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we have three tables: `customers`, `products`, and `receipts`.
    The `receipts` table would have two columns (in addition to others) with each
    referencing a column on the `customers` and `products` table, respectively. If
    we wanted to update a product’s identification column, we would have to just modify
    the applicable product’s identification value. Then, the rows referencing the
    product within `receipts` would update automatically. Without a foreign reference,
    we would have to explicitly update the `receipts` table after updating the product’s
    identification.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, foreign keys would reference a primary key column or some form
    of identification column, but you are not limited to just those columns.
  prefs: []
  type: TYPE_NORMAL
- en: Relations between models can be managed by Sequelize automatically, or in a
    configurable way, for adopting pre-existing databases. Mapping relations between
    models can help ORMs form efficient queries depending on the environment by **eager
    loading** or **lazy loading**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Association methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationship patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying associations with eager loading and lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced association options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying associations to Avalon Airlines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4)
  prefs: []
  type: TYPE_NORMAL
- en: Association methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few options for creating relational mappings with ORMs. Defining
    the relations through an ORM can help build your database with the proper attributes
    and columns automatically, manage associated validations (for example, checking
    to see whether there is strictly only one related record), and perform optimization
    patterns on queries when fetching or inserting data. Sequelize offers support
    for four association patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HasOne** – A one-to-one association where the *foreign key references the
    child* model. The attribute is defined on the parent model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BelongsTo** – A one-to-one association where the *foreign key references
    the parent* model. The attribute is defined on the child model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HasMany** – A one-to-many association where the *foreign key references the
    parent* model. The attribute is defined on the child model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BelongsToMany** – A many-to-many association where a separate model (called
    a *junction table*) will store the references of the associated models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequelize will follow a pattern for creating methods on models with associations.
    Depending on the relationship, there can be `get`, `set`, `add`, `create`, `remove`,
    and `count` as the prefix for the method’s name following with the association’s
    name (singular or pluralized wherever applicable).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go over the list of associations with their corresponding
    methods. Once we have gone through the association overview, then we can begin
    with the patterns for the relationships overview. Throughout this section, we
    will be using the concept of actors and plays/movies/jobs to help us grasp the
    fundamentals of associative properties and behavior on models. These examples
    are for illustrative purposes only and should not be included within our project’s
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a `where` clause statement (along with other finder parameters)
    within the `get` association methods, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Actor.getJobs({`'
  prefs: []
  type: TYPE_NORMAL
- en: '`where: { category: ''Action'' },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`limit: 10, offset: 20, /* etc. */`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: hasOne
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hasOne` association will generate `get`, `set`, and `create` methods for
    the associating model. Suppose we had the following association and instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `createJob` method to insert and set the job with the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setJob` method will update the association of the actor and the job from
    a `Job` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You may use the `set` prefix method to remove an association as well with a
    `null` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: belongsTo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s change our previous example’s model to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `belongsTo` association will generate the exact same methods on the same
    model as the `hasOne` association. For further explanation, this association will
    not create `setActor` on the `Job` model but will create the `setJob` method on
    the `Actor` model still.
  prefs: []
  type: TYPE_NORMAL
- en: hasMany
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hasMany` association will generate the following prefixed methods: `get`,
    `set`, `create`, `count`, `has`, `add`, and `remove`. The `get` and `set` methods
    are similar to the previous example except that the suffix of the method’s name
    will be a pluralized version of the model’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create` prefix method will still only create one record at a time and
    therefore the model’s name is still singular-cased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check to see whether a relationship already exists with the `has`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add one or multiple associations using the `add` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve how many associations we have for a model, we can invoke the `count`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing the associations can be done with the `remove` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: belongsToMany
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we change the association to `belongsToMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `belongsToMany` association will generate the same methods on the same model
    as the previous `hasMany` example, similar to how `belongsTo` generated the same
    methods as the `hasOne` association.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming associations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can modify how Sequelize will generate the method names by creating an
    alias to the association using the `as` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can manually set the identifier of a relationship directly to the attribute
    and Sequelize will update the value with the `save` method. However, if you have
    made any changes within the associated records, their information will not be
    updated by calling the associating instance’s `save` method. Changes to the actual
    associations would need to be done from their own instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to apply association methods to our models, we can go over
    the various relationship patterns to help us get a better understanding of where,
    and when, these associations are coupled. In the next section, we will go into
    detail on the relationship patterns that Sequelize supports along with examples
    for each pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go over the details of each type of relation (except
    Super-Many-To-Many, which is discussed in a later section), and how to use Sequelize
    to define the associations. After that, we will update the Avalon Airlines project’s
    models with associations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine several association patterns to define a relationship pattern.
    Sequelize supports four relationship patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-to-One** – We would use the *hasOne* and *belongsTo* associations together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-Many** – The *hasMany* and *belongsTo* associations are used for this
    pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-Many** – Two *belongsToMany* associations are used for this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Super-Many-to-Many** – Two *One-to-Many* relations where the *One* models
    are still considered symbiotic. This relationship will be explained in further
    detail in the *Creating Super Many-to-Many relationships* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-One
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The One-to-One relational pattern involves the `hasOne` and `belongsTo` associations
    for the models. The difference between the two associations is which table will
    have the identification column.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we have an `Airplane` and `BoardingTicket` model. Since the `Airplane`
    model would no longer be involved with `BoardingTicket`, after the flight has
    been completed, we can omit the memorization of the boarding ticket from the `Airplane`
    model’s table. This means that `Airplane` would not need a `hasOne` association,
    but `BoardingTicket` will still need a `belongsTo` association.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a One-to-One relationship, we would define our models like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Sequelize’s `sync` command would yield the following queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Without calling `A.hasOne(B)`, Sequelize would not know how to eager load from
    model A to B (but would be able to eager load from model B to A).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several options that you can pass as a second parameter for tuning
    the behavior of the associations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onUpdate` – Tells the DBMS how to handle updated foreign relationships. Possible
    values are `CASCADE`, `RESTRICT`, `NO ACTION`, `SET DEFAULT`, and `SET NULL`.
    The default value for this option is `CASCADE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDelete` – Same as `onUpdate` but for handling deleted foreign relationships.
    The default for this option is `SET NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foreignKey` – Accepts a literal string value or an object with the same options
    as an attribute when defining models (`name`, `allowNull`, `unique`, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sourceKey` – The name of the column, from the source table, to use as identification
    for the foreign key column’s value. By default, Sequelize will use the source
    table’s attribute that has a `primaryKey: true` parameter. If your model contains
    no explicit `primaryKey` attribute, then Sequelize will use the default `id` attribute.
    Applicable to `hasOne` and `hasMany` associations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetKey` – Similar to `sourceKey` except this value will reference the column
    from the target table as opposed to the source table. Applicable to `belongsTo`
    associations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few examples of how to use these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the second options interchangeably between models A and B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Sequelize will make One-to-One relations optional, but if we wanted
    to require a relationship between the two models, then we would define `allowNull`
    as `false` in the association options like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One-to-Many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This relational pattern will only create a foreign reference column on the `belongsTo`
    model. Defining an attribute with the `hasMany` association helps Sequelize with
    data retrieval optimization and adding helper functions to the parent model. The
    options in the second parameter are the same as a One-to-One relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we had `Employees` that belonged to `Organization`. With Sequelize,
    the code would be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This would execute these couple of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Many-to-Many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This relationship will use an associative entity to keep references between
    two models. Some other names for an associative entity are junction table, junction
    model, cross-reference table, and pairing table. With `sequelize.sync()`, Sequelize
    will automatically create a junction model for you, but we still have the option
    of defining our own junction table for situations where we want to add more attributes,
    constraints, life cycle events, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have employees that have tasks assigned to them. Employees
    can work on multiple tasks and tasks can require many employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-Many relationships will use `CASCADE` as the default behavior for managing
    foreign keys and relationships on both updates and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to be more explicit in our definitions or wanted to add a custom
    attribute to the junction model, we can define the junction model and relations
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Other than the `through` parameter, Many-to-Many offers a parameter called `uniqueKey`,
    which will allow you to name a reference column. By default, Sequelize will create
    the junction table with a unique key composed of both referencing columns (`employeeId`
    and `taskId`). If you wish to change this behavior, you may set the `unique` attribute
    parameter to `false` in the junction model’s definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom foreign key definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When, and how, to use `sourceKey` and `targetKey` properly can be confusing
    at first. The `hasOne` and `hasMany` associations will reference themselves from
    the Parent model (target model) to the Child model (source model); another way
    of saying this is, “This child is mine through name, marriage, and so on.” The
    `belongsTo` association will reference the Parent model, or “I belong to this
    parent through name, marriage, and so on.”
  prefs: []
  type: TYPE_NORMAL
- en: We reference these models as *source* and *target* models since parent and child
    could be misleading and would imply some form of hierarchy. Associations do not
    require a hierarchy; they just form relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes that are defined as references are required to have a unique constraint
    applied to them. This can be done by adding `unique: true` to the attribute’s
    options and using Sequelize’s `sync()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of how to configure the source and target keys, we will first
    define our models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using these roles, we will go through examples of using `hasOne`, `hasMany`,
    `belongsTo`, and `belongsToMany` separately.
  prefs: []
  type: TYPE_NORMAL
- en: Using hasOne
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code will create an attribute called `actorName` on the `Roles`
    model, and the value for that attribute will be associated with the actor’s name
    (instead of the actor’s ID attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using hasMany
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We would use the same options for the `hasMany` association. The following
    code will create an attribute called `roleTitle` on the `Costumes` model, which
    will be associated with the role’s title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using belongsTo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `belongsTo` association works a bit differently. Instead of referencing
    from the source model, `belongsTo` will reference from the target model like so
    (this would yield the same results as the previous `Actors.hasOne(Roles, ...)`
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the foreign keys will be placed on the model that is creating
    the association when using `belongsTo`, and for the `hasOne`/`hasMany` associations,
    the foreign keys are placed on the other model that is not invoking the association
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Using belongsToMany
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `belongsToMany` association accepts both the target and the source keys
    as parameters to configure the references. On the movie set, an actor could have
    multiple costumes for all of their different scenes. We can illustrate this relationship
    in Sequelize like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will create a junction table called `actor_costumes` with two reference
    columns being `actorsName` and `costumesWardrobe`, referencing the Actor and Costume
    model, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone over definitions, options, use cases, and examples for
    Sequelize’s association patterns, and the main three relational patterns, we can
    start practicing including those relations for when we select or modify records.
  prefs: []
  type: TYPE_NORMAL
- en: Querying associations with eager loading and lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequelize offers two different methods of querying associations depending on
    how you wish to query the data: eager loading and lazy loading. With eager loading,
    you would load all of the associated data at once. The lazy loading method will
    load the associations per query as they are called upon from the code. It is easier
    to explain eager loading than lazy loading but to see the benefits of eager loading,
    we will need to go over lazy loading first.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of the “N+1 select problem” with other ORM frameworks; this
    is referring to the lazy loading method (although, not mutually exclusive) and
    how selecting an association per row could be hazardous to your application’s
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sequelize tries to make no presumptions about your intent and will initially
    select only the model’s data. We will need to explicitly call the associations
    if we want to transverse through the model’s related data. A good use case for
    lazy loading would be querying related data conditionally (for example, we may
    not want to fetch movie reviews until after the movie is released). Lazy loading
    would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Eager loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, you would use this form of loading when you have a lot of associations
    or a lot of rows returned from the main table. Referencing the previous example,
    let’s say we replaced `getJob` with `getJobs` and called `getReviews` per job,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the actor ever became too famous and had hundreds of jobs, we could see
    how quickly the number of queries could become too cumbersome for the system.
    One way to prevent this is by using the eager loading method, which will include
    the associated data at the top-level query using `JOIN` statements. Let us convert
    the previous example into an eager-loaded query with Sequelize by beginning to
    define our completed jobs association:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This first `include` parameter will load the `Job` model, set an alias to `CompletedJobs`,
    add a `where` clause for the `completed` flag, and then call a nested association
    from `Job` to `Review` (along with a `published` `where` clause for the review).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define our incomplete jobs association:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter is a simpler alias association for `Job` with an inverted
    `where` clause from `CompletedJobs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is to query the completed and incomplete jobs separately since
    we only want to include reviews from jobs that are done. Now, we can query our
    actor with the jobs and reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an SQL query similar to this (some selected columns have
    been omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, concatenate the completed and incomplete jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can iterate through jobs and display the reviews if applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the fundamentals of the two load types for Sequelize, we can
    now start venturing into more advanced concepts when associating data. In the
    next section, we will go over more advanced query patterns for associations: Super
    Many-to-Many associations and polymorphic associations.'
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced association options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequelize offers a variety of tricks to help communicate with your database’s
    relations properly. Some of these methods will help query associations in a more
    organized and ergonomic way. Other methods will offer us a way to compose the
    database’s schematics for more advanced relationship patterns. In this section,
    we will be going over examples of how to manage complex many-to-many relationships
    using the Super Many-to-Many pattern, define scoped associations, and query polymorphic
    associations.
  prefs: []
  type: TYPE_NORMAL
- en: Using scopes with associations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scopes are a way to define a namespace with a default set of parameters, or
    parameters that override previously applied scopes to a query. Associations may
    have defined scopes to help with organization of the code base. A key difference
    between scopes for associations and models is that the association scope’s parameters
    are applicable for the `WHERE` clause. Model scopes can define the `WHERE`, `LIMIT`,
    and `OFFSET` clauses, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of querying associations with scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Sequelize will add a mixin for the `worker` instance called `getCompletedTasks()`,
    which would invoke a query similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `` `task`.`completed` = true `` part was automatically added from Sequelize
    from the scope’s definition. An alternative way of defining the same scope is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating scoped associations, Sequelize will automatically add default
    values for those parameters when calling the `create` or `add` mixins. As an example,
    we know a worker has already completed a task and wanted to insert the association
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Sequelize will execute a similar query when creating a completed task via `worker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `completed` attribute has been automatically set to `true` for when we want
    to add a completed task. The same behavior would be exhibited if we were to use
    the `add` mixin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the scope parameter on a `belongsToMany` association would apply the
    scope to the target model instead of the junction mode. If you wish to apply a
    scope on the junction model instead, you would add the scope parameter inside
    of the `through` configuration like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Creating Super Many-to-Many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we owned a store and wanted to maintain lists of associations between
    employees and customers through transactions. Typically, we can define this sort
    of relationship by adding a `belongsToMany` association on the `Employee` and
    `Customer` model using the `Transaction` model as the junction table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with the definitions of these models to use throughout this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the `Transaction` model has the `id` attribute explicitly
    defined as the primary key. This will prevent Sequelize from using the composition
    keys of `employeeId` and `customerId` as the primary key, which is required for
    establishing Super Many-to-Many relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create a Many-to-Many relationship with these three models.
    The common way would be to use the `belongsToMany` association like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The other method is to use `hasMany` and `belongsTo` on both of the associating
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These two methods will yield the same schematic result for the junction table
    (creating `employeeId` and `customerId` on the junction model). However, when
    you try to eager load the data, you may run into several issues depending on how
    you are trying to query the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `belongsToMany` associations, we may query our models in the following
    way (however, this will not work for the `hasMany` and `belongsTo` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Including the junction model from the associated models would not work for
    the `belongsToMany` approach, but the following code would work for the `hasMany`
    and `belongsTo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to include associated models through the junction model will only work
    with the `hasMany` and `belongsTo` method. The following code will not work for
    the `belongsToMany` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to use all of the various forms of eager loading for these
    models, we can implement the Super Many-to-Many pattern by combining the two associated
    methods such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Declaring our associations like this would allow us to query associative data
    via the junction model, or the associated models themselves, without constraint
    or stipulations. Deeply nested includes are also supported natively with the Super
    Many-to-Many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Using polymorphic associations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have two or more associative models targeting the same foreign key on
    a junction table we can use a polymorphic association pattern for that scenario.
    You may think of polymorphic associations as some type of generic interfacing
    for associated data.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we owned an online retail store and wanted to store reviews for both
    widgets and gizmos under one review table. Initially, we would want to use `hasMany`
    and `belongsTo` associations, but this would cause Sequelize to generate two columns
    on the junction model (`widgetId` and `gizmoId`) instead of one for a generic
    pattern. Semantically, this would not make sense either since a review is not
    associated with a widget *and* a gizmo product.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to define our `Widget` and `Gizmo` models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define our `Review` model like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `instanceMethods` parameter will create a `getEntity` function per instance,
    which will check to see whether `entityType` is null. If there is an entity type,
    then we can call the associated mixin function by adding a `get` prefix to the
    entity type’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can establish our relationships as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For each association, we will use `entityId` as `foreignKey`, and since the
    junction model references more than one table, we cannot set a reference constraint
    on that table (which is why we set `constraints` to `false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To query the associations, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Polymorphism allows us to retrieve the widget or gizmo without being pre-deterministic
    in our queries by calling our instance method, `getEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to load our data eagerly, we would include the associated models like
    any other eager-loaded query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `afterFind` hook will automatically associate the `create` instance to the
    `entity` key for each review.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are referencing more than one table to one target column, we will
    need to be extra careful when querying the junction model. For instance, if both
    `Widget` and `Gizmo` had an ID of `5` and a review had `entityType` of `Gizmo`,
    and we queried reviews with `Review.findAll({ include: Widget })`, then the `Widget`
    instance would be eager loaded into `Review` regardless of `entityType`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize will not automatically infer the entity’s type from the model’s name.
    Luckily, our `afterFind` life cycle event will assign the entity value properly.
    It is recommended to always use the abstracted methods (for example, `getEntity`)
    over Sequelize’s mixins (for example, `getWidget`, `getGizmo`, etc.) in order
    to avoid ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have shown an example of a One-to-Many relationship, but what about
    a Many-to-Many? Using the previous example models, we can add an associated model
    called `Categories`, which would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create our junction model for a Many-to-Many relationship by assigning
    two foreign key columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `ce_unique_constraint` lines will tell Sequelize that all three of these
    attributes belong to the same composited unique key. The null reference for `entityId`
    will ensure that Sequelize will not create a reference constraint for that column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can define our relations for `Widget` and `Gizmo` along with a helper
    method. We will assign a common parameter configuration along with a function
    for amending a scope to the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can assign our relationships to the applicable models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a method such as `widget.getCategories()` would execute a similar query
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned how to operate with associations and relationships
    for Sequelize, we can begin making some modifications to our Avalon Airlines project.
  prefs: []
  type: TYPE_NORMAL
- en: Applying associations to Avalon Airlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Luckily, the models for the project are simple and won’t require the amount
    of effort as defining a Super Many-to-Many relationship. Within these next several
    model updates, this book will demonstrate what to modify only for the `class`
    model block (the rest of the contents within each file should remain the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting in alphabetical order, we will begin modifying the `models/airplane.js`
    file’s `class` block by adding a relationship to `FlightSchedule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can edit the `models/boardingticket.js` file’s `class` block and add
    a `Customer` and `FlightSchedule` relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Customers will now have many boarding tickets; the `models/customer.js` file’s
    `class` block should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Flight schedules will belong to a specific airplane, and they will have many
    boarding tickets. We can edit the `models/flightschedule.js` file’s `class` block
    to match the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are not executing `sync({ force: true })` when initializing Sequelize,
    we will need to generate a migrations file and add the necessary references for
    their respective models. We can use the Sequelize CLI tool to generate a new migrations
    file using the `migration:generate` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Sequelize will notify you on the new file that it has generated a migration
    file with a message similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The prefixed number on the filename will be different from what appears on your
    screen, but if we look into the `migrations` directory, then we will see a newly
    generated file. We can quickly overwrite the file’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, we will want to include `DataTypes` and start our migration’s
    `up` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the `FlightSchedule` model’s reference for the `Airplane` model
    by adding a column first and then adding the constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will want to do the same for `BoardingTicket` and its related models,
    `Customer` and `FlightSchedule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can close the `up` block and start our `down` block for migration reversal
    support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to remove the constraints first, then the columns, and finally,
    close the `down` block and exported object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In our console, we can migrate these new changes with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize will confirm that the migration has been completed, and our models
    are officially related to each other through associations. Throughout this book,
    we will use the lessons learned from this chapter for including associated data
    within our queries, but for now, we will move on to the next lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over defining relations of models using associative
    properties along with some advanced options and relational patterns, and we went
    over the differences between eager loading and lazy loading. At the end of this
    chapter, we took our lessons from the previous chapter, *Validating Models*, and
    added validations, associations, and migrations for our Avalon Airlines project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever get stuck on associations and need a quick reference, the related
    material can be found here: [https://sequelize.org/docs/v6/core-concepts/assocs/](https://sequelize.org/docs/v6/core-concepts/assocs/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over Sequelize’s hook feature (also known as
    a life cycle event), how to define hooks for models, and what would be some good
    use cases for life cycle events.
  prefs: []
  type: TYPE_NORMAL
