- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with the File System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Node.js, JavaScript was predominantly used in the browser. Node.js brought
    JavaScript to the server and enabled us to interact with the operating system
    through JavaScript. Today, Node.js is one of the most popular technologies for
    building server-side applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js interacts with the operating system at a fundamental level: **input
    and output** ( **I/O** ). This chapter will explore the core APIs provided by
    Node.js that allow us to interact with standard I/O, the file system, and the
    network stack.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you how to read and write files both synchronously and
    asynchronously. Node.js was built to handle asynchronous code and enable a non-blocking
    model. Understanding how to read and write asynchronous code is fundamental learning,
    and it will show how to leverage the capabilities of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn about the core modules provided by Node.js. We’ll be focusing
    on the **File System** module, which enables you to interact with the file system
    and files. Newer versions of Node.js have added **Promise** variants of many file
    system APIs, which will also be touched upon in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the file system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a recent version of Node.js 22 installed,
    a **Terminal** or shell, and an editor of your choice. The code for this chapter
    is available on GitHub at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter02** directory.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will use the CommonJS syntax; refer to [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
    for more information on CommonJS and ECMAScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Standard in** ( **stdin** ) refers to an input stream that a program can
    use to read input from a command shell or Terminal. Similarly, **standard out**
    ( **stdout** ) refers to the stream that is used to write the output. **Standard
    error** ( **stderr** ) is a separate stream to **stdout** that is typically reserved
    for outputting errors and diagnostic data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to learn how to handle input with **stdin** , write
    output to **stdout** , and log errors to **stderr** .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, let’s first create a single file named **greeting.js** . The
    program will ask for user input via **stdin** , return a greeting via **stdout**
    , and log an error to **stderr** when invalid input is provided. Let’s create
    a directory to work in, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve set up our directory and file, we’re ready to move on to the
    recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to create a program that can read from **stdin**
    and write to **stdout** and **stderr** :'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to tell the program to listen for user input. This can be done
    by adding the following lines to **greeting.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the file using the following command. Observe that the application
    does not exit because it is continuing to listen for **process.stdin** data events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exit the program using *Ctrl* + *C* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now tell the program what it should do each time it detects a data event.
    Add the following lines below the **// processing on each data** **event** comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now type input to your program. When you press *Enter* , it will return
    a greeting and your name in uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now add a check for whether the input string is empty and log to **stderr**
    if it is. Change your file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program again and hit *Enter* with no input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now created a program that can read from **stdin** and write to **stdout**
    and **stderr** .
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **process.stdin** , **process.stdout** , and **process.stderr** properties
    are all properties on the process object. A global process object provides information
    and control of the Node.js process. For each of the I/O channels (standard in,
    standard out, standard error), they emit data events for every chunk of data received.
    In this recipe, we were running the program in interactive mode where each data
    chunk was determined by the newline character when you hit *Enter* in your shell.
  prefs: []
  type: TYPE_NORMAL
- en: The **process.stdin.on('data', (data) => {...});** instance is what listens
    for these data events. Each data event returns a **Buffer** object. The **Buffer**
    object (typically named **data** ) returns a binary representation of the input.
  prefs: []
  type: TYPE_NORMAL
- en: The **const name = data.toString()** instance is what turns the **Buffer** object
    into a string. The **trim()** function removes all whitespace characters – including
    spaces, tabs, and newline characters – from the beginning and end of a string.
    The whitespace characters include spaces, tabs, and newline characters.
  prefs: []
  type: TYPE_NORMAL
- en: We write to **stdout** and **stderr** using the respective properties on the
    process object ( **process.stdout.write** , **process.stderr.write** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'During the recipe, we also used *Ctrl* + *C* to exit the program in the shell.
    *Ctrl* + *C* sends **SIGINT** , or signal interrupt, to the Node.js process. For
    more information about signal events, refer to the Node.js Process API documentation:
    [https://nodejs.org/api/process.html#process_signal_events](https://nodejs.org/api/process.html#process_signal_events)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Console APIs** : Under the hood, **console.log** and **console.err** are
    using **process.stdout** and **process.stderr** . Console methods are higher-level
    APIs and include automatic formatting. It’s typical to use console methods for
    convenience and lower-level process methods when you require more control over
    the stream.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of Node.js 17.0.0, Node.js provides an Experimental Readline Promises API,
    which is used for reading a file line by line. The Promises API variant of this
    allows you to use **async** / **await** instead of callbacks, providing a more
    modern and cleaner approach to handling asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how the Promises API variant can be used to create a
    similar program to the **greeting.js** file created in the main recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This Node.js script utilizes the **node:readline/promises** module, which provides
    the **Promise** variant of the Readline API. It defines an asynchronous function,
    **greet()** , which prompts the user for their name in the console and then greets
    them with a personalized message – similar to the main recipe program. Using the
    Readline Promises API allows us to use the **async** / **await** syntax for cleaner
    asynchronous code flow. We’ll cover more about the **async** / **await** syntax
    in later recipes and chapters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Decoupling I/O* recipe in [*Chapter 3*](B19212_03.xhtml#_idTextAnchor068)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js provides several core modules, including the **fs** module. **fs** stands
    for File System, and this module provides the APIs to interact with the file system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, and throughout the book, we will make use of the **node:** prefix
    when importing core modules.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to read, write, and edit files using the synchronous
    functions available in the **fs** module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by preparing a directory and files for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another directory for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now, let’s create a file to read. Run the following in your shell to create
    a file containing some simple text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need a file for our program—create a file named **readWriteSync.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **touch** utility is a command-line utility included in Unix-based operating
    systems that is used to update the access and modification date of a file or directory
    to the current time. However, when **touch** is run with no additional arguments
    on a non-existent file, it will create an empty file with that name. The **touch**
    utility is a typical way of creating an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll synchronously read the file named **hello.txt** , manipulate
    the contents of the file, and then update the file using synchronous functions
    provided by the **fs** module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by requiring the **fs** and **path** built-in modules. Add the
    following lines to **readWriteSync.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a variable to store the file path of the **hello.txt** file
    that we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now synchronously read the file contents using the **readFileSync()**
    function provided by the **fs** module. We’ll also print the file contents to
    **stdout** using **console.log()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can edit the content of the file – we will convert the lowercase text
    into uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To update the file, we can use the **writeFileSync()** function. We’ll also
    add a **log** statement afterward indicating that the file has been updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your program with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify the contents were updated, you can open or use **cat** in your Terminal
    to show the contents of **hello.txt** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have a program that, when run, will read the contents of **hello.txt**
    , convert the text content into uppercase, and update the file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As is commonplace, the first two lines of the file require the necessary core
    modules for the program.
  prefs: []
  type: TYPE_NORMAL
- en: The **const fs = require('node:fs');** line will import the core Node.js File
    System module. The API documentation for the Node.js File System module is available
    at [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html) . The **fs**
    module provides APIs to interact with the file system using Node.js. Similarly,
    the core **path** module provides APIs for working with file and directory paths.
    The **path** module API documentation is available at [https://nodejs.org/api/path.html](https://nodejs.org/api/path.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a variable to store the file path of **hello.txt** using the
    **path.join()** and **process.cwd()** functions. The **path.join()** function
    joins the path sections provided as parameters with the separator for the specific
    platform (for example, **/** on Unix and **\** on Windows environments).
  prefs: []
  type: TYPE_NORMAL
- en: The **process.cwd()** function is a function on the global process object that
    returns the current directory of the Node.js process. This program is expecting
    the **hello.txt** file to be in the same directory as the program.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we read the file using the **fs.readFileSync()** function. We pass this
    function the file path to read and the encoding, UTF-8. The encoding parameter
    is optional—when the parameter is omitted, the function will default to returning
    a **Buffer** object.
  prefs: []
  type: TYPE_NORMAL
- en: To perform manipulation of the file contents, we used the **toUpperCase()**
    function available on string objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we updated the file using the **fs.writeFileSync()** function. We passed
    the **fs.writeFileSync()** function two parameters. The first parameter was the
    path to the file we wished to update, and the second parameter was the updated
    file contents.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Both the **readFileSync()** and **writeFileSync()** APIs are synchronous, which
    means that they will block/delay concurrent operations until the file read or
    write is completed. To avoid blocking, you’ll want to use the asynchronous versions
    of these functions, covered in the *There’s more…* section of the current recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this recipe, we were operating on our files synchronously. However,
    Node.js was developed with a focus on enabling the non-blocking I/O model; therefore,
    in many (if not most) cases, you’ll want your operations to be asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Today, there are three notable ways to handle asynchronous code in Node.js—callbacks,
    Promises, and **async** / **await** syntax. The earliest versions of Node.js only
    supported the callback pattern. Promises were added to the JavaScript specification
    with ECMAScript 2015, known as ES6, and subsequently, support for Promises was
    added to Node.js. Following the addition of **Promise** support, **async** / **await**
    syntax support was also added to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: All currently supported versions of Node.js now support callbacks, Promises,
    and **async** / **await** syntax – you may find any of these used in modern Node.js
    development. Let’s explore how we can work with files asynchronously using these
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files asynchronously
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous programming can enable some tasks or processing to continue while
    other operations are happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program from the *Working with files* recipe was written using the synchronous
    functions available in the **fs** module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that the program was blocked waiting for the **readFileSync()** and
    **writeFileSync()** operations to complete. This program can be rewritten to make
    use of asynchronous APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous version of **readFileSync()** is **readFile()** . The general
    convention is that synchronous APIs will have the term “sync” appended to their
    name. The asynchronous function requires a callback function to be passed to it.
    The callback function contains the code that we want to be executed when the asynchronous
    task completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will implement the same behavior as the program from the
    *Working with files* recipe but using asynchronous methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **readFileSync()** function in this recipe could be changed to use the
    asynchronous function with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that all the processing that is reliant on the file read needs to take
    place inside the callback function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **writeFileSync()** function can also be replaced with the **writeFile()**
    asynchronous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we now have an asynchronous function that calls another asynchronous
    function. It’s not recommended to have too many nested callbacks as it can negatively
    impact the readability of the code. Consider the following to see how having too
    many nested callbacks impedes the readability of the code, which is sometimes
    referred to as “ callback hell”:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some approaches can be taken to avoid too many nested callbacks. One approach
    would be to split callbacks into explicitly named functions. For example, our
    file could be rewritten so that the **writeFile()** call is contained within its
    own named function, **updateFile()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another approach would be to use Promises, which we’ll cover in the *Using the
    fs Promises API* section of this chapter. But as the earliest versions of Node.js
    did not support Promises, the use of callbacks is still prevalent in many **npm**
    modules and existing applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To demonstrate that this code is asynchronous, we can use the **setInterval()**
    function to print a string to the screen while the program is running. The **setInterval()**
    function enables you to schedule a function to happen after a specified delay
    in milliseconds. Add the following line to the end of your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the string continues to be printed every millisecond, even in between
    when the file is being read and rewritten. This shows that the file reading and
    writing have been implemented in a non-blocking manner because operations are
    still completing while the file is being handled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Using **unref()** on **setInterval()** means this timer will not keep the Node.js
    event loop active. This means that if it is the only active event in the event
    loop, Node.js may exit. This is useful for timers for which you want to execute
    an action in the future but do not want to keep the Node.js process running solely.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this further, you could add a delay between the reading and
    writing of the file. To do this, wrap the **updateFile()** function in a **setTimeout()**
    function. The **setTimeout()** function allows you to pass it a function and a
    delay in milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the output from our program should have more asterisks printed between
    the file read and write, as this is where we added the 10-millisecond delay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now see that we have converted the program from the *Working with files*
    recipe to handle the file operations asynchronously using the callback syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Using the fs Promises API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **fs** Promises API was released in Node.js v10.0.0. The API provides File
    System functions that return **Promise** objects rather than callbacks. Not all
    the original **fs** module APIs have equivalent **Promise** -based APIs, as only
    a subset of the original APIs were converted to provide **Promise** APIs. Refer
    to the Node.js API documentation for a full list of **fs** functions provided
    via the **fs** Promises API: [https://nodejs.org/docs/latest/api/fs.html#promises-api](https://nodejs.org/docs/latest/api/fs.html#promises-api)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Promise** is an object that is used to represent the completion of an asynchronous
    function. The naming is based on the general definition of the term “promise”—an
    agreement to do something or that something will happen. A **Promise** object
    is always in one of the three following states:'
  prefs: []
  type: TYPE_NORMAL
- en: Pending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fulfilled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rejected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Promise** will initially be in the pending state and will remain pending
    until it becomes either fulfilled—when the task has completed successfully—or
    rejected—when the task has failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will implement the same behavior as the program from the
    recipe again but using **fs** Promises API methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the API, you’ll first need to import it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is then possible to read the file using the **readFile()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also combine the **fs** Promises API with the use of the **async**
    / **await** syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Two notable aspects of this implementation are the use of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**async function run() {...}** : Defines an asynchronous function named **run()**
    . Asynchronous functions enable the use of the **await** keyword for handling
    promises in a more synchronous-looking manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**await fs.readFile(filepath, ''utf8'')** : Uses the **await** keyword to asynchronously
    read the contents of the file specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we’ve learned how we can interact with files using the **fs** Promises
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Owing to using CommonJS in this chapter, it was necessary to wrap the **async**
    / **await** example in a function as **await** must only be called from within
    an asynchronous function with CommonJS. From [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
    onward, we’ll cover ECMAScript modules, where this wrapper function would be unnecessary
    due to **top-level await** being supported with ECMAScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Fetching metadata* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Watching files* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **fs** module generally provides APIs that are modeled around **Portable
    Operating System Interface** ( **POSIX** ) functions. The **fs** module includes
    APIs that facilitate the reading of directories and file metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a small program that returns information about
    a file, using functions provided by the **fs** module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Get started by creating a directory to work in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need to create a file to read and a file for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the files created in the *Getting ready* section, we will create a program
    that gives information about the file we pass to it as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous recipes, we first need to import the necessary core modules.
    For this recipe, we just need to import the **fs** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need the program to be able to read the filename as a command-line
    argument. To read the file argument, we can use **process.argv[2]** . Add the
    following line to your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create our **printMetadata** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a call to the **printMetadata** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now run the program, passing it the **./file.txt** argument. Run your
    program with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can try adding some random text to **file.txt** , saving the file, and then
    rerunning your program; observe that the **size** and **mtime** values have been
    updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s see what happens when we pass a non-existent file to the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The program throws an exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We should catch this exception and output a message to the user saying the
    file path provided does not exist. To do this, change the **printMetadata** function
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program again with a non-existent file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, you should see that the program handled the error rather than throwing
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **process.argv** property is a property on the global process object that
    returns an array containing the arguments that were passed to the Node.js process.
    The first element of the **process.argv** array, **process.argv[0]** , is the
    path of the **node** binary that is running. The second element is the path of
    the file we’re executing – in this case, **metadata.js** . In the recipe, we passed
    the filename as the third command-line argument and, therefore, referenced it
    with **process.argv[2]** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we created a **printMetadata()** function that called **statSync(file)**
    . The **statSync()** function is a synchronous function that returns information
    about the file path that is passed to it. The file path passed can be either a
    file or a directory. The information returned is in the form of a **stats** object.
    The following table lists the information returned on the **stats** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Table listing properties returned on the stats object](img/B19212_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Table listing properties returned on the stats object
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used only the synchronous File System APIs. For most of the
    **fs** APIs, there are both synchronous and asynchronous versions of each function.
    Refer to the *Working with files asynchronously* section of the *Working with
    files* recipe for more information about using asynchronous File System APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the final steps of this recipe, we edited our **printMetadata** function
    to account for invalid file paths. We did this by wrapping the **statSync** function
    in a **try** / **catch** statement.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll look at how we can check file access and modify file permissions
    and how to examine a **symbolic** **link** ( **symlink** ).
  prefs: []
  type: TYPE_NORMAL
- en: Checking file access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that if you’re attempting to read, write, or edit a file,
    you follow the approach of handling the error if the file is not found, as we
    did in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you simply wanted to check the existence of a file, you could use
    the **fs.access()** or **fs.accessSync()** APIs. Specifically, the **fs.access()**
    function tests the user’s permissions for accessing the file or directory passed
    to it. The function also allows an optional argument of **mode** to be passed
    to it, where you can request the function to do a specific access check using
    Node.js file access constants. A list of Node.js file access constants is available
    in the Node.js **fs** module API documentation: [https://nodejs.org/api/fs.html#fs_file_access_constants](https://nodejs.org/api/fs.html#fs_file_access_constants)
    . These enable you to check whether the Node.js process can read, write, or execute
    the file path provided.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There is a legacy API that is now deprecated, called **fs.exists()** . It is
    not recommended you use this function. The reason for deprecation was that the
    method’s interface was found to be error-prone and could lead to accidental race
    conditions. The **fs.access()** or **fs.stat()** APIs should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying file permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Node.js **fs** module provides APIs that can be used to alter the permissions
    on a given file. As with many of the other **fs** functions, there is both an
    asynchronous API, **chmod()** , and an equivalent synchronous API, **chmodSync()**
    . Both functions take a file path and **mode** as the first and second arguments,
    respectively. The **chmod()** function accepts a third parameter, which is the
    callback function to be executed upon completion.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **chmod** command is used to change access permissions of file system objects
    on Unix and similar operating systems. If you’re unfamiliar with Unix file permissions,
    it is recommended you refer to the Unix manual pages ( [https://linux.die.net/man/1/chmod](https://linux.die.net/man/1/chmod)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **mode** argument can be either in the form of a numeric bitmask using
    a series of constants provided by the **fs** module or a sequence of three octal
    digits. The constants that can be used to create a bitmask to define user permissions
    are defined in the Node.js API documentation: [https://nodejs.org/api/fs.html#fs_file_modes](https://nodejs.org/api/fs.html#fs_file_modes)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a file that currently has the following permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: Owner readable and writeable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable only by all other users (sometimes referred to as world readable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we wanted to additionally grant write access to those in the same group,
    we could use the following Node.js code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code is quite verbose. Adding a complex series or permissions
    would require passing many constants to create a numeric bitmask. Alternatively,
    we can pass the **chmodSync()** function an octal representation of file permissions,
    as is commonplace when using the Unix **chmod** command on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to change the permissions using the equivalent of **chmod 664**
    from the command line, but via Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://mason.gmu.edu/~montecin/UNIXpermiss.htm](https://mason.gmu.edu/~montecin/UNIXpermiss.htm)
    for more detailed information on how Unix permissions work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows file permissions** : The Windows operating system does not have as
    refined file permissions as on Unix—it is only possible to denote a file as writeable
    or non-writeable.'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting symbolic links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A symlink is a special file that stores a reference to another file or directory.
    When the **stat()** or **statSync()** function from the *Fetching metadata* recipe
    is run on a symbolic link, the method will return information about the file the
    symbolic link is referencing rather than the symbolic link itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Node.js **fs** module does, however, provide methods named **lstat()**
    and **lstatSync()** that inspect the symbolic link itself. The following steps
    will demonstrate how you can use these methods to inspect a symbolic link that
    we will create:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a symbolic link, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can use the Node.js **Read-Eval-Print Loop** ( **REPL** ) to test the
    **lstatSync()** function. The Node.js REPL is an interactive shell we can pass
    statements to, and it will evaluate them and return the result to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To enter the Node.js REPL, type **node** in your shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then type commands such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can try out the **lstatSync** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we did not need to explicitly import the Node.js **fs** module. The
    REPL automatically loads the core (built-in) Node.js modules so that they are
    available to be used. The REPL is a useful tool for testing out commands without
    having to create files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Watching files* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js’s **fs** module provides functionality that enables you to watch files
    and track when files or directories are created, updated, or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll create a small program named **watch.js** that watches
    for changes in a file using the **watchFile()** API and then prints a message
    when a change has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we’ll want to work inside a new directory. Create and change
    into a directory called **file-watching** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to also create a file that we can watch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a **watch.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have created our directory and file, we can move on to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to create a program that watches for changes in a given file –
    in this case, the **file.txt** file we created earlier. We will be using the **fs**
    module and, specifically, the **watchFile()** method to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, import the required core Node.js modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need the program to access a file we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we call the **fs.watchFile()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run the program in your shell with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your editor, open **file.txt** and make some edits, saving between each
    one. You will notice that each time you save, a log entry appears in the Terminal
    where you’re running **watch.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While we’re here, we can make the timestamp more readable. To do this, we’re
    going to make use of the **Intl.DateTimeFormat** object. It is a built-in JavaScript
    utility to manipulate dates and times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add and change the following lines to format the date using **Intl.DateTimeFormat**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the program and make further edits to **file.txt** —observe that the
    time is now in a more readable format for your time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the recipe, we used the **watchFile()** function to watch for changes on
    a given file. The function accepts three arguments—a filename, an optional list
    of options, and a listener function. The **options** object can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BigInt** : The **BigInt** object is a JavaScript object that allows you to
    represent larger numbers more reliably. This defaults to **false** ; when set
    to **true** , the numeric values returned from the object of **Stats** would be
    specified as **BigInt** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**persistent** : This value indicates whether the Node.js process should continue
    to run while files are still being watched. It defaults to **true** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interval** : The **interval** value controls how often the file should be
    polled for changes, measured in milliseconds. The default value is 5,007 milliseconds
    when no interval is supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The listener function supplied to the **watchFile()** function will execute
    every time a change is detected. The listener function’s arguments, current and
    previous are both **Stats** objects, representing the current and previous state
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Our listener function passed to **watchFile()** is executed each time a change
    has been detected in the file being watched. Every time our **updated** function
    returns **true** , it logs the updated message to **stdout** .
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js **fs** module provides another function, **watch()** , which watches
    for changes in files but can also watch for directories. This function differs
    from **watchFile()** as it utilizes the operating system’s underlying file system
    notification implementation rather than polling for changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although faster and more reliable than the **watchFile()** API, the Watch API
    is not consistent across various platforms. This is because the Watch API is dependent
    on the underlying operating system’s method of notifying file system changes.
    The Node.js API documentation goes into more detail about the limitations of the
    Watch API across different platforms: [https://nodejs.org/docs/latest/api/fs.html#fs_availability](https://nodejs.org/docs/latest/api/fs.html#fs_availability)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **watch()** function similarly accepts three parameters—the filename, an
    array of options, and a listener function. The options that can be passed via
    the **options** parameter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**persistent** : The **persistent** option is a Boolean that indicates whether
    the Node.js process should continue to run while files are still being watched.
    By default, the **persistent** option is set to **true** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**recursive** : The **recursive** option is another Boolean that allows the
    user to specify whether changes in subdirectories should be watched – by default,
    this value is set to **false** . The **recursive** option is only supported on
    macOS and Windows operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**encoding** : The **encoding** option is used to specify which character encoding
    should be used for the filename specified—the default is **utf8** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal** : An **AbortSignal** object that can be used to cancel file watching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The listener function that is passed to the **watch()** API is slightly different
    from the listener function passed to the **watchFile()** API. The arguments to
    the listener function are **eventType** and **trigger** , where **eventType**
    is either **change** or **rename** and **trigger** is the file that triggered
    an event. The following code represents a similar task to what we implemented
    in our recipe but using the Watch API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The final steps of the recipe cover usage of the comprehensive **Intl.DateTimeFormat**
    utility for manipulating dates and times. Refer to *MDN Web Docs* for a list of
    available formats and APIs on **Intl.DateTimeFormat** : [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **moment.js** library was once a go-to library for date manipulation and
    formatting in JavaScript. However, with the advancement of modern JavaScript,
    built-in functionalities such as **Intl.DateTimeFormat** offers similar capabilities
    natively. Additionally, **moment.js** has been put into maintenance mode by its
    maintainers, meaning no new features will be added. Coupled with concerns about
    its bundle size, many developers are finding **moment.js** no longer necessary
    for their projects and are instead using built-in functionalities or more modern
    alternative libraries.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **nodemon** utility is a popular **npm** module utility for Node.js that
    automatically restarts your application when it detects code change. Instead of
    manually stopping and starting the server after each code change, **nodemon**
    handles it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical installation and usage of **nodemon** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'More recent versions of Node.js (later than v18.11.0) have a built-in watch-mode
    capability. To enable watch mode, you supply the **--watch** command-line process
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: While in watch mode, modifications to the observed files trigger a Node.js process
    restart. By default, the built-in watch mode will monitor the main entry file
    and any modules that are required or imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to specify the exact files you wish to watch with the **--watch-path**
    command-line process flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'More information can be found in the Node.js API documentation: [https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch](https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adopting new JavaScript syntax in Node.js 22* recipe in [*Chapter 1*](B19212_01.xhtml#_idTextAnchor019)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
