["```js\nvar projection;\n\nvar margin = { top: 30, right: 30, bottom: 30, left: 30 },\n    width = 900 - margin.left - margin.right,\n    height = 600 - margin.top - margin.bottom;\n\nvar svg = d3.select('#vis')\n  .append('svg')\n    .attr('width', width + margin.left + margin.top)\n    .attr('height', height + margin.top + margin.bottom)\n  .append('g')\n    .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n```", "```js\nd3.queue()\n  .defer(d3.json, 'data/us.json')\n  .await(ready);\n```", "```js\nfunction ready(error, us) {\n  if (error) throw error;\n\n  var us = prepData(us);\n  drawGeo(us);\n\n}\n```", "```js\nfunction prepData(topo) {\n  var geo = topojson.feature(topo, topo.objects.us);\n  return geo;\n}\n```", "```js\nfunction drawGeo(data) {\n  projection = d3.geoAlbers() // note: global\n    .scale(1000).translate([width/2, height/2]);\n\n  var geoPath = d3.geoPath()\n    .projection(projection);\n\n  svg\n    .append('path').datum(data)\n      .attr('d', geoPath)\n      .attr('fill', '#ccc')\n}\n```", "```js\nnpm install -g shapefile \n```", "```js\nnpm install -g topojson\n```", "```js\nshp2json cb_2016_us_nation_20m.shp --out us-geo.json \n```", "```js\ngeo2topo us-geo.json > us-topo.json \n```", "```js\ntopoquantize 1e5 < us-topo.json > us-quant.json \n```", "```js\ntoposimplify -s 1e-5 -f < us-quant.json > us.json \n```", "```js\nvar points = getPointGrid(160);\n```", "```js\nfunction getPointGrid(cols) {\n  var hexDistance = width / cols;\n  var rows = Math.floor(height / hexDistance);\n\n  hexRadius = hexDistance/1.5;\n```", "```js\nreturn d3.range(rows * cols).map(function(el, i) {\n    return {\n      x: Math.floor(i % cols * hexDistance),\n      y: Math.floor(i / cols) * hexDistance,\n      datapoint: 0\n    }\n  });\n} // end of getPointGrid() function\n```", "```js\nfunction drawPointGrid(data) {\n  svg.append('g').attr('id', 'circles')\n    .selectAll('.dot').data(data)\n    .enter().append('circle')\n      .attr('cx', function(d) { return d.x; })\n      .attr('cy', function(d) { return d.y; })\n      .attr('r', 1)\n      .attr('fill', 'tomato');\n}\n```", "```js\nfunction ready(error, us) {\n  var us = prepData(us);\n  drawGeo(us);\n  var points = getPointGrid(160);\n var polygonPoints = getPolygonPoints(us); }\n```", "```js\nfunction getPolygonPoints(data) {\n  var features = data.features[0].geometry.coordinates[7][0];\n\n  var polygonPoints = []\n  features.forEach(function(el) {\n    polygonPoints.push(projection(el));\n  });\n\n  return polygonPoints;\n}\n```", "```js\nvar usPoints = keepPointsInPolygon(points, polygonPoints);\n```", "```js\nfunction keepPointsInPolygon(points, polygon) {\n  var pointsInPolygon = [];\n  points.forEach(function(el) {\n    var inPolygon = d3.polygonContains(polygon, [el.x, el.y]);\n    if (inPolygon) pointsInPolygon.push(el);\n  });\n  return pointsInPolygon;\n}\n```", "```js\nfunction ready(error, us) {\n  //previous steps\n\n  var hexPoints = getHexPoints(usPoints);\n  drawHexmap(hexPoints);\n\n}\n```", "```js\nfunction getHexPoints(points) {\n  hexbin = d3.hexbin() // note: global\n    .radius(hexRadius)\n    .x(function(d) { return d.x; })\n    .y(function(d) { return d.y; });\n\n  var hexPoints = hexbin(points);\n    return hexPoints;\n}\n```", "```js\nfunction drawHexmap(points) {\n  var hexes = svg.append('g').attr('id', 'hexes')\n    .selectAll('.hex').data(points)\n    .enter().append('path')\n      .attr('class', 'hex')\n      .attr('transform', function(d) { \n        return 'translate(' + d.x + ', ' + d.y + ')'; })\n      .attr('d', hexbin.hexagon())\n      .style('fill', '#fff')\n      .style('stroke', '#ccc')\n      .style('stroke-width', 1);\n}\n```", "```js\nd3.queue()\n  .defer(d3.json, 'data/us.json')\n  .defer(d3.json, 'data/markets_overall.json')\n  .await(ready);\n```", "```js\nfunction ready(error, us) {\n  // … previous steps\n  var dataPoints = getDatapoints(markets)\n}\n```", "```js\nfunction getDatapoints(data) {\n\n  return data.map(function(el) {\n    var coords = projection([+el.lng, +el.lat]);\n    return {\n      x: coords[0],\n      y: coords[1],\n      datapoint: 1,\n      name: el.MarketName,\n      state: el.State,\n      city: el.city,\n      url: el.Website\n    }\n  });\n\n}\n```", "```js\nfunction ready(error, us) {\n  // … previous steps\n\n  var dataPoints = getDatapoints(markets)\n var mergedPoints = usPoints.concat(dataPoints)\n}\n```", "```js\nfunction ready(error, us) {\n  // … previous steps\n\n  var hexPointsRolledup = rollupHexPoints(hexPoints);\n}\n```", "```js\nfunction rollupHexPoints(data) {\n  var maxCount = 0;\n```", "```js\n  data.forEach(function(el) {\n\n    for (var i = el.length - 1; i >= 0; --i) {\n      if (el[i].datapoint === 0) {\n        el.splice(i, 1);\n      }\n    }\n```", "```js\n    var count = 0,\n        markets = [];\n\n    el.forEach(function(elt) {\n      count++;\n      var obj = {};\n      obj.name = elt.name;\n      obj.state = elt.state;\n      obj.city = elt.city;\n      obj.url = elt.url;\n      markets.push(obj);\n    });\n\n    el.datapoints = count;\n    el.markets = markets;\n```", "```js\n    maxCount = Math.max(maxCount, count);\n\n  }); // end of loop through hexagons\n\n  colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([maxCount, 1]);\n\n  return data;\n\n} // end of rollupHexPoints()\n```", "```js\nfunction drawHexmap(points) {\n  var hexes = svg.append('g').attr('id', 'hexes')\n   .selectAll('.hex').data(points)\n   .enter().append('path')\n     .attr('class', 'hex')\n     .attr('transform', function(d) { \n        return 'translate(' + d.x + ', ' + d.y +')'; \n     })\n     .attr('d', hexbin.hexagon())\n .style('fill', function(d) { \n        return d.datapoints === 0 ? 'none' : colorScale(d.datapoints); \n     })     .style('stroke', '#ccc')\n     .style('stroke-width', 1);\n}\n```", "```js\ncolorScale = d3.scaleSequential(function(t) {\n\n    var tNew = Math.pow(t,10);\n    return d3.interpolateViridis(tNew)\n\n}).domain([maxCount, 1]);\n```", "```js\n  .attr('d', function(d) { return hexbin.hexagon(d.datapoints); })\n```", "```js\nradiusScale = d3.scaleSqrt().domain([0, maxCount]).range([3.5, 15]);\n```", "```js\nfunction drawHexmap(points) {\n  var hexes = svg.append('g').attr('id', 'hexes')\n    .selectAll('.hex')\n .data(points.sort(function(a,b) { \n        return a.datapoints - b.datapoints;        \n    }))    .enter().append('path')\n      .attr('class', 'hex')\n      .attr('transform', function(d) { \n        return 'translate(' + d.x + ', ' + d.y + ')'; \n      })\n .attr('d', function(d) { \n        return hexbin.hexagon(radiusScale(d.datapoints)); \n      })      .style('fill', function(d) { return \n        d.datapoints === 0 ? 'none' : colorScale(d.datapoints); \n      })\n      .style('stroke', '#ccc')\n      .style('stroke-width', 1);\n}\n```"]