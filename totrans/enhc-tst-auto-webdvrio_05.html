<html><head></head><body>
		<div id="_idContainer072">
			<h1 id="_idParaDest-74" class="chapter-number"><a id="_idTextAnchor088"/>5</h1>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor089"/>Alter Egos – The ClickAdv  Wrapper</h1>
			<p>In this and the next few chapters, we will introduce the concept of adding wrappers for the<strong class="source-inline">.click()</strong>, <strong class="source-inline">.select()</strong>, and <strong class="source-inline">.setValue()</strong> intrinsic methods. These wrappers allow us to add more functionality to these methods to make the framework more robust and less likely to fail during <span class="No-Break">a test.</span></p>
			<p>Wrappers are the easiest way to extend functionality throughout the test suite, eliminating the need to repeatedly add code in the form of multiple test scripts. Sometimes when testing, the page loads slowly and our elements take longer to load. Sometimes, the page is<a id="_idIndexMarker215"/> updated due to <strong class="bold">Asynchronous JavaScript and XML</strong> (<strong class="bold">AJAX</strong>) and the element we found is now stale and must be found again. Our results, shown in both the console window and Allure, should be detailed enough to indicate what is occurring. Wrappers allow us to start handling all that information efficiently, including scrolling an element into view for screen captures, looking for similar replacement objects to reduce maintenance, and burning time during page builds so that elements have time to appear without resorting to slower hardcoded <span class="No-Break">wait methods.</span></p>
			<p>There are three ways that we will explore for injecting superpowers into <span class="No-Break">our framework:</span></p>
			<ul>
				<li><span class="No-Break">Helper commands</span></li>
				<li><span class="No-Break">Browser commands</span></li>
				<li><span class="No-Break">Element commands</span></li>
			</ul>
			<p>We will first start adding a <strong class="source-inline">helpers</strong> file along with <span class="No-Break">its prerequisites.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor090"/>Adding a helpers file</h1>
			<p>We begin by preparing our helper commands, which require the <strong class="source-inline">utility-types</strong> package in order to support optional parameters in TypeScript. This package is installed with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; yarn add utility-types</pre>			<p>We will next add a <strong class="source-inline">\helpers</strong> folder that contains a <strong class="source-inline">helpers.ts</strong> file module. This contains several methods for resolving issues in the framework. This is where we will store the majority of our custom supporting code for <span class="No-Break">the framework.</span></p>
			<p>To create a helpers file in a WebdriverIO project <a id="_idIndexMarker216"/>written in TypeScript, we need to do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create a new directory in our project to store our helper functions. This directory will be called <strong class="source-inline">helpers</strong>, located within our <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> directory.</span></li>
				<li>Within the <strong class="source-inline">helpers</strong> directory, create a new TypeScript file for our helper functions. Let’s call this <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">helpers.ts</strong></span><span class="No-Break">.</span></li>
				<li>At the top of the <strong class="source-inline">helpers.ts</strong> file, we need to import the necessary types and functions to support file paths, global objects, and Allure reports. Some of these will come into play in <span class="No-Break">future chapters:</span><pre class="console">
import * from as fs from "fs"import * as path from "path";
import { ASB } from "./globalObjects.ts";
import allure from "@wdio/allure-reporter";</pre></li>
				<li>Within the <strong class="source-inline">helpers.ts</strong> file, we need to define our helper functions. The structure of the file will include the public method wrappers such as <strong class="source-inline">click()</strong>, <strong class="source-inline">pageSync()</strong>, and <strong class="source-inline">assert()</strong>. It will also contain private supporting methods for finding and replacing data tokens, and <strong class="source-inline">getElementType()</strong> to determine how to handle errors <span class="No-Break">by class:</span><pre class="console">
export const clickElement = async (driver: WebDriver, element: WebDriver.Element) =&gt; {p  try {p
    await driver.click(element)p
  } catch (error) {p
    throw new WebDriverError(`Unable to click element: ${error.message}`)p
  }p
}</pre></li>
				<li>In the files where we want to use the helper functions, we import the functions from the <strong class="source-inline">helpers.ts</strong> file <span class="No-Break">as follows:</span><pre class="console">
import { clickAdv } from './helpers/helpers'pWe can then use the clickAdv function in our test code like this:
await clickAdv(driver, element)</pre></li>
			</ol>
			<p>This is just one example of how<a id="_idIndexMarker217"/> we can create and use helper functions in a WebdriverIO project written in TypeScript. We can define as many helper functions as we need in the <strong class="source-inline">helpers.ts</strong> file and import them into our test code as and <span class="No-Break">when required.</span></p>
			<p>Before we get to the <strong class="source-inline">click()</strong> method, let’s begin with a wrapper of <strong class="source-inline">console.log</strong> so we can customize the detail.  If we happen to call it with a string such as <strong class="source-inline">is blank</strong> or <strong class="source-inline">empty</strong>, or a <strong class="source-inline">null</strong> variable, it does not need to print anything. But if anything other than a string or number is passed, such as a promise or an object, it should output a warning <span class="No-Break">without failing:</span></p>
			<pre class="console">
 p
/**
 * Console.log wrapper
 *    - Does not print if string is empty / null
 *    - Prints trace if not passed string or number
 * @param message
 */
export async function log(message: any): Promise&lt;void&gt; {
  try {
    if (typeof message === "string" || typeof message === "number") {
      if (message) {
        console.log(`---&gt; ${message}`);
      }
    } else {
      console.log(`---&gt;   helpers.console() received: ${message}`);
      console.trace();
    }
  } catch (error: any) {
    console.log(`---&gt;   helpers.console(): ${error.message}`);
  }
}</pre>			<p>Notice there is some extra spacing when the error is output to the console. This is intentional. We will be making<a id="_idIndexMarker218"/> our output visually helpful with spacing and <span class="No-Break">color later.</span></p>
			<p>To utilize the helpers, we add the following import line to our <span class="No-Break">test files:</span></p>
			<pre class="source-code">
import * as helpers from '../../helpers/helpers.ts';</pre>			<p>To call the method, we use <span class="No-Break">this statement:</span></p>
			<pre class="source-code">
helpers.log (`Hello, World!`)
&gt; [0-0] ---&gt; Hello, World!</pre>			<p>If the method is called with a null string, it does not output anything to <span class="No-Break">the console:</span></p>
			<pre class="source-code">
helpers.log (``)</pre>			<p>If anything other than a string or number is passed then the object and a trace is output, something like the following commonly occurs, where a promise object is returned instead of a string due to a missing <span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> keyword:</span></p>
			<pre class="source-code">
helpers.log (Promise)
&gt; [0-0] ---&gt;   helpers.console() received: function Promise() { [native code] }
&gt; [0-0] Trace
&gt; [0-0]     at Module.log (file:///D:/repos/Test-Automation-with-WebdriverIO/helpers/helpers.ts:14:15)
&gt; [0-0]     at UserContext.&lt;anonymous&gt; (file:///D:/repos/Test-Automation-with-WebdriverIO/test/specs/example.e2e.ts:10:17)</pre>			<p>When a problematic element is passed to the <strong class="source-inline">helper.log</strong> wrapper, the second line of code, <strong class="source-inline">UserContext</strong>, will identify where the actual error occurred. Our debugging is now starting to look a little <span class="No-Break">bit better.</span></p>
			<p>Let’s next identify and resolve a potential problem in the <strong class="source-inline">.click</strong> method of the <span class="No-Break"><strong class="source-inline">login.page.ts</strong></span><span class="No-Break"> file.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor091"/>The “Hello, World!” of test automation</h1>
			<p>The test-automation equivalent of <strong class="source-inline">Hello, World!</strong> is usually a test that checks for the presence of a simple element on a web page, such as a heading or a paragraph of text. This can<a id="_idIndexMarker219"/> involve writing a test that does <span class="No-Break">the following:</span></p>
			<ul>
				<li>Navigates to a <span class="No-Break">web page</span></li>
				<li>Locates an element on the page using an XPath or CSS <span class="No-Break">selector method</span></li>
				<li>Verifies that the element is present and displayed on <span class="No-Break">the page</span></li>
			</ul>
			<p> In our first example, we have the following five simple steps to perform <span class="No-Break">a login:</span></p>
			<ol>
				<li>Navigate to a simulated <span class="No-Break">login screen.</span></li>
				<li>Enter <span class="No-Break">the username.</span></li>
				<li>Enter the <span class="No-Break">password credentials.</span></li>
				<li>Click the <span class="No-Break">login button.</span></li>
				<li>Validate that a message appears, indicating the login <span class="No-Break">was successful.</span></li>
			</ol>
			<p>An example can<a id="_idIndexMarker220"/> be found in the <span class="No-Break"><strong class="source-inline">pageObjects\login.page.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
await this.inputUsername.setValue(username);
await this.inputPassword.setValue(password);
await this.btnSubmit.click();</pre>			<p>We have already resolved errors that can arise from lines of code executing out of order by using the <strong class="source-inline">await</strong> statement. However, element locators may become stale over time as developers change the pages we are automating. For example, imagine the class of the login button was initially a <span class="No-Break"><strong class="source-inline">button</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
&lt;button class="radius" type="submit" fdprocessedid="ra4xrd"&gt;p
    &lt;i class="fa fa-2x fa-sign-in"&gt; Login&lt;/i&gt;p
&lt;/button&gt;</pre>			<p>But in the next release, it was changed to an anchor <span class="No-Break">link class:</span></p>
			<pre class="source-code">
&lt;a class="radius" type="submit" fdprocessedid="ra4xrd"&gt;p
    &lt;i class="fa fa-2x fa-sign-in"&gt; Login&lt;/i&gt;p
&lt;/a&gt;p<a id="_idTextAnchor092"/></pre>			<p>Then the <strong class="source-inline">.click</strong> method will throw the <span class="No-Break">following error:</span></p>
			<pre class="source-code">
[0-0] Error: Can't call click on element with selector "button[type="submit"]" because el<a id="_idTextAnchor093"/>ement wasn't found</pre>			<p>We could surround the click with a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> method to capture exceptions and get more detail about what exactly caused an error to be thrown. In this example, if the click method was successful, we output the successful event. However, if the element did not exist, was covered by another element, or otherwise could not be clicked, we output the <strong class="source-inline">captured</strong> error detail and send it to <span class="No-Break">our console:</span></p>
			<pre class="source-code">
    try{
        await this.btnSubmit.click();
        helpers.log(` Clicked button`);
    } catch (err)
        helpers.log(`    Click failed because\n${err)`);
  }</pre>			<p>We would like to<a id="_idIndexMarker221"/> have this for every element, but we do not want to have to add this code repeatedly in all of our test scripts. Fortunately, with wrappers, there is a <span class="No-Break">better way.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor094"/>ES6 helper modules versus overriding intrinsic methods</h1>
			<p>There are multiple ways to<a id="_idIndexMarker222"/> achieve this goal. One way to do this would be to completely override the intrinsic actions<a id="_idTextAnchor095"/> of the <strong class="source-inline">click()</strong> method in every call. Alternatively, we could create our own custom method with its own unique naming convention. Lastly, we can create our own function that takes<a id="_idIndexMarker223"/> the object as a parameter and performs additional functionality. Here is what those three approaches might <span class="No-Break">look like:</span></p>
			<p>We could override all i<a id="_idTextAnchor096"/>ntrinsic <span class="No-Break"><strong class="source-inline">click()</strong></span><span class="No-Break"> methods:</span></p>
			<pre class="source-code">
btnLogin.click() // Customized with overWriteCommand</pre>			<p>We could add a <span class="No-Break">custom method:</span></p>
			<pre class="source-code">
btnLogin.clickAdv()</pre>			<p>Or create a custom function in our <span class="No-Break"><strong class="source-inline">Helpers</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
clickAdv(btnLogin)</pre>			<p>The approach you use is up to you. But the key is to pick one and stick with it consistently, rather than having a mishmash of different approaches. Each one has its own advantages worth considering. Let us look at the pros and cons of the first <span class="No-Break">two approaches.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor097"/>Overriding intrinsic element methods</h2>
			<p>One way we<a id="_idIndexMarker224"/> could enhance the <strong class="source-inline">click()</strong> method is to completely override the intrinsic element methods from the <strong class="source-inline">ts.config.json</strong> file, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
browser.overwriteCommand('click', async(origClick, element)= {
    let success = true;
    try{ p           element = await getValidElement(element, "button");
       await element.click(); // Instrinsic click
       console.log(' Clicked ${element.selector}');
    } catch (err)
        success = false;
        console.log(`$   {element.selector}click failed\n ${err)`);
  }
    return success;
})</pre>			<p>This command will encapsulate features such as checking the object validity, setting the frame, setting the framework to somewhere, and skipping additional methods if called when the element does not exist. The way we do this is with sanity testing. For example, we will attempt to click on a nonexistent button called <strong class="source-inline">btnBogus</strong> and see how the rest of the script executes. Here is an object description of the <span class="No-Break">bogus button:</span></p>
			<pre class="source-code">
await this.btnBogus.click();</pre>			<p>With this approach, the signature stays the same and all our test scripts <span class="No-Break">are enhanced:</span></p>
			<pre class="source-code">
await this.btnSubmit.click();</pre>			<p>T<a id="_idTextAnchor098"/>he custom <strong class="source-inline">click()</strong> method can add more detail as to what <span class="No-Break">is happening:</span></p>
			<pre class="source-code">
[0-0] ---&gt; Clicking button[type="submit"] ...
[0-0] ---&gt;   button clicked.</pre>			<p>This approach efficiently adds enhanced functionality to the <strong class="source-inline">click()</strong> method of every element in the entire suite of tests. But this is also a drawback – an error in this method could break everywhere<a id="_idIndexMarker225"/> the <strong class="source-inline">click()</strong> method is used. There is no easy way to revert a specific line in a test script to the original intrinsic method to see whether the error caused the overridden code. We can only turn it all on or turn it <span class="No-Break">all off.</span></p>
			<p>There must be <span class="No-Break">another way!</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor099"/>Adding a custom element method</h2>
			<p>We can add a custom element <a id="_idIndexMarker226"/>command to the browser object. In this case, let us call it <strong class="source-inline">clickAdv()</strong>. It can be implemented by changing the first and last lines of the preceding code to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
browser.addCommand("clickAdv", async function (){
…
}, true);</pre>			<p>The call to the method <span class="No-Break">becomes this:</span></p>
			<pre class="source-code">
await this.btnSubmit.clickAdv();</pre>			<p>The custom <strong class="source-inline">clickAdv()</strong> method has the same detail as the <span class="No-Break">overridden version:</span></p>
			<pre class="source-code">
[0-0] ---&gt; Clicking button[type="submit"]
[0-0] ---&gt;   button clicked.;</pre>			<p class="callout-heading">Quick tip</p>
			<p class="callout">Avoid “magic” values. These are values known only to the developer and may not be easily found in the documentation. In this preceding example, the last line overrides the implicit <strong class="source-inline">false</strong> with <strong class="source-inline">true</strong>. The meaning is that the custom method is to be added to an element rather than <span class="No-Break">the browser.</span></p>
			<p>Now we have the flexibility of a <strong class="source-inline">clickAdv()</strong> custom method that can be reverted to an intrinsic version by <a id="_idIndexMarker227"/>removing <strong class="source-inline">Adv</strong> at an <span class="No-Break">atomic level:</span></p>
			<pre class="source-code">
await this.btnAddToCart.clickAdv();</pre>			<p>This is done by removing <strong class="source-inline">Adv</strong> from <span class="No-Break">the method:</span></p>
			<pre class="source-code">
await this.btnAddToCart.click();</pre>			<p>This seems perfect! All we need now is to do a little negative testing with a bogus element and see whether the output indicates the <span class="No-Break">click failed.</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor100"/>Who tests the SDET’s code? Sanity testing of the automation framework</h1>
			<p>Unit testing is an important part of any development project. Since it is expected that developers will write unit tests<a id="_idIndexMarker228"/> for the functionality of the application, so too it would be reasonable that the SDETs write unit tests for the framework code base itself. However, the terms “unit testing” and “integration testing” often cause confusion when applied to the automation framework itself. Let us refer to this aspect as “sanity testing of the automation framework”, although it is really unit testing of discreet framework functionality and the integration of those features. These are scripts written to intentionally test the viability of the features in the framework. Like the previous “Hello, World” example, test automation has a version of sanity testing that exercises each of our advanced methods. Since automation is a development project, we should have a short test that intentionally exercises the capabilities of the framework. This may include finding elements with stale XPath or CSS locators, dynamically changing embedded data tags to the current date, or writing detailed logging from the wrapper methods. It might include a negative test on a non-existent element that intentionally fails as its <span class="No-Break">expected result.</span></p>
			<p>As we add more functionality, we should also add sanity testing to our scripts. We will add a non-existent button called <strong class="source-inline">btnBogus</strong> that will force the method <span class="No-Break">to fail:</span></p>
			<pre class="source-code">
    public get btnBogus () {
        return $('button[type="bogus"]');
    }</pre>			<p>To sanity test, we will click the <strong class="source-inline">btnBogus</strong> button followed by the <strong class="source-inline">submit</strong> button in our <strong class="source-inline">login fail</strong> method in the <strong class="source-inline">login </strong><span class="No-Break"><strong class="source-inline">page</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
        await this.btnBogus.clickAdv();</pre>			<p>And our results are not what <span class="No-Break">we expected:</span></p>
			<pre class="source-code">
Error: Can't call clickAdv on element with selector "button[type="bogus"]" because element wasn't found</pre>			<p>WebdriverIO validates the element <a id="_idIndexMarker229"/>before it executes the custom method. The same occurs if the method was overridden. The problem here is that it prevents us from implementing self-healing objects in our framework or replacing a stale element with a <span class="No-Break">viable one.</span></p>
			<p>There must be <span class="No-Break">another way.</span></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor101"/>Extending our ES module helper file with a custom click method</h1>
			<p class="author-quote">There are two ways to write error-free programs; only the third one works.</p>
			<p class="author-quote">– Allen J. Perlis</p>
			<p>Our third option <a id="_idTextAnchor102"/>is to<a id="_idIndexMarker230"/> create a <strong class="source-inline">click(<a id="_idTextAnchor103"/>)</strong> method in the <strong class="source-inline">helpers</strong> file. While it changes our signature, it allows us more control to recover<a id="_idIndexMarker231"/> from issues <span class="No-Break">with elements:</span></p>
			<pre class="source-code">
await helpers.clickAdv(this.btnSubmit);
await helpers.clickAdv(this.btnBogus);</pre>			<p>The output now looks <span class="No-Break">like this:</span></p>
			<pre class="console">
[0-0] ---&gt; Clicking button[type="submit"] ...
[0-0] ---&gt;   button clicked.
[0-0] ---&gt;   pageSync() completed in 25 ms
[0-0] ---&gt; Clicking button[type="bogus"] ...
[0-0] ---&gt;   button[type="submit"] was not clicked.
[0-0] Error: Can't call click on element with selector "button[type="bogus"]" because element wasn't found</pre>			<p class="callout-heading">Quick tip</p>
			<p class="callout">Unlike many coding conventions, there is no common approach for naming wrapper methods. Some teams may use a trailing underscore (<strong class="source-inline">_</strong>) while others might append the word <strong class="source-inline">Wrapper</strong>. The important takeaway here is that teams should agree on an identifiable naming convention that is documented in a Coding Standards document and followed in <span class="No-Break">code reviews.</span></p>
			<p>Now that we are<a id="_idIndexMarker232"/> checking that our button<a id="_idIndexMarker233"/> can be clicked, let’s look at what <span class="No-Break">happens afterward.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor104"/>Why are waits difficult to implement correctly?</h1>
			<p>All automation tools<a id="_idIndexMarker234"/> have ways to determine what to do when an element does not exist. The most common solution is to wait until the object exists. WebdriverIO has an option to adjust the timeout for elements in the <span class="No-Break"><strong class="source-inline">wdio.config.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
// Default timeout for all waitFor* commands.
waitforTimeout: 10_000,</pre>			<p>The default is 10 seconds. For years, the most common choice was to wait 30 seconds. The problem was, depending on our tool, if our script navigated to the wrong page, that timeout might happen on every element. That is a long time to wait for the script to finally end if a lot of elements do <span class="No-Break">not exist.</span></p>
			<p>Back in 2000s, the founder of WorkSoft, Linda Hayes, noted that there is a way to calculate a good wait timeout for our framework. Take the average time for our slowest page to render and triple it. This means we will anticipate a load will be added to our application under test and can be flexible enough to <span class="No-Break">handle it.</span></p>
			<p>Different tools have many ways to wait for elements to appear. Tools such as Selenium, for example, have three: implicit, explicit, and fluent waits. Implicit waits tell Selenium to wait a certain amount <a id="_idIndexMarker235"/>of time before throwing an exception if an element is not found on the page. Explicit waits wait for a specific condition to be met before continuing, such as <strong class="source-inline">enabled</strong> or <strong class="source-inline">clickable</strong>. Fluent waits allow customization of the maximum wait time, the frequency with which the condition should be checked, and the types of exceptions that should <span class="No-Break">be ignored.</span></p>
			<p>But what is the next most common reason that an element does not exist? It is because the page is still building. We could just add a hardcoded wait for an element <span class="No-Break">to appear.</span></p>
			<p>The problem is when these waits are mixed together that the actual wait time of a Selenium script can add up to several minutes and become difficult <span class="No-Break">to debug.</span></p>
			<p>Similarly, WebdriverIO provides several types of waits to handle dynamic elements on a web page. These include commands such as <strong class="source-inline">waitUntil()</strong>, <strong class="source-inline">waitForExist()</strong>, <strong class="source-inline">waitForDisplayed()</strong>, <strong class="source-inline">waitForEnabled()</strong>, and <strong class="source-inline">waitForSelected()</strong>, which allow waiting for specific conditions to be met before continuing with <span class="No-Break">test execution.</span></p>
			<p>Note that the <strong class="source-inline">waitForExist()</strong> command rarely has a use in test automation. It merely means the element exists in the DOM, not that it appears on the page. <strong class="source-inline">waitForDisplayed()</strong> provides the same check and makes it more likely the element can be interacted with by <span class="No-Break">the user.</span></p>
			<p>Again, Linda Hayes noted that to make a framework more robust, each element should be checked to make sure that it exists and is enabled. This provides the breaks for our high-speed car as we make our way down the curvy mountain road <span class="No-Break">at night.</span></p>
			<p>What if, instead of waiting for every element to appear and be enabled, we could wait for the page build to complete after each click? Then it would be more likely that every element on the page is viable. This would eliminate the need to check whether the element exists every time. Only if the element is not found then the framework can get creative about finding it before throwing <span class="No-Break">an error.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor105"/>“I don’t always use Pause(), but when I do, It’s less than 1000 milliseconds”</h2>
			<p>Yes, there will be times <a id="_idIndexMarker236"/>when we need to perform a wait but we want to be smarter about it. For example, the <strong class="source-inline">pageSync()</strong> wrapper method needs a quarter-second wait as it counts how many elements are on the page. This is the code for the custom <strong class="source-inline">pause(ms)</strong> method that will tell us when a hardcoded wait of half a <span class="No-Break">second occurs:</span></p>
			<pre class="source-code">
/**
 * Wrapper for browser.pause
 * @param ms reports if wait is more than 1/2 second
 */
export async function pause(ms: number) {
  if (ms &gt; 500){
  log(`  Waiting ${ms} ms...`); // Custom log
  }
  const start = Date.now();
  let now = start;
  while (now - start &lt; ms) {
    now = Date.now();
  }
}</pre>			<p>The method will write to the console if the delay is more than half a second. This is to remind us to be aware of how much delay is in the framework. <strong class="source-inline">wait</strong> is like adding salt to a soup: a little is okay, but too much spoils it for everyone. We could also count how much time is wasted <span class="No-Break">in total.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor106"/>Highlighting elements</h2>
			<p>Next, we will add a way to highlight an element to make sure we can see what is occurring when we are debugging. These<a id="_idIndexMarker237"/> highlights are also a handy way to check whether an element is visible. This code will highlight an element in green, although we can override that color. It also has a check to see whether the element we are highlighting has gone stale. If that is the case, the element is saved to the automation switchboard and a stale element switch is set to <strong class="source-inline">true</strong>. This allows us to update the element in the calling routines to eliminate the chance of stale elements slowing our test execution. Lastly, the function returns whether the element was visible <span class="No-Break">or not:</span></p>
			<pre class="source-code">
export async function highlightOn(
  element: WebdriverIO.Element,
  color: string = "green"
): Promise&lt;boolean&gt; {
  let elementSelector:any
  let visible: boolean = true;
  try {
      elementSelector = await element.selector;
      try {
        await browser.execute(`arguments[0].style.border = '5px solid ${color}';`, element);
        visible = await isElementVisible(element)
      } catch (error: any) {
        // Handle stale element
        const newElement = await browser.$(elementSelector)
        ASB.set("element", newElement)
        ASB.set("staleElement", true)
        await browser.execute(`arguments[0].style.border = '5px solid ${color}';`, newElement);
        //log (`  highlightOn ${elementSelector} refresh success`)
      }
  } catch (error) {
    // Element no longer exists
    visible = false
  }
  return visible;
}</pre>			<p>Since we have the highlight functionality turned on, we should add something that turns the highlight off, for which<a id="_idIndexMarker238"/> we will use a spinner <span class="No-Break">detection method:</span></p>
			<pre class="source-code">
export async function highlightOff(element: WebdriverIO.Element): Promise&lt;boolean&gt; {
  let visible: boolean = true;
  try {
      await browser.execute(`arguments[0].style.border = "0px";`, element);
  } catch (error) {
      // Element no longer exists
      visible = false;
  }
  return visible;
}</pre>			<p>This method simply tells us whether the element was visible or not when removing <span class="No-Break">the highlight.</span></p>
			<p>Next, let us implement a spinner detection method that waits until a spinner no longer appears on <span class="No-Break">the page:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B19395_05_1.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Note that this element locator <a id="_idIndexMarker239"/>will be different from project to project. In some projects, we look for spinners <span class="No-Break">and loaders:</span></p>
			<pre class="source-code">
export async function waitForSpinner(): Promise&lt;boolean&gt; {
  let spinnerDetected: boolean = false;
  // This spinner locator is unique to each project
  const spinnerLocator: string = `//img[contains(@src,'loader')]`;
  await pause(100); // Let browser begin building spinner on page
  let spinner = await browser.$(spinnerLocator);
  let found = await highlightOn(spinner);
  let timeout = ASB.get("spinnerTimeoutInSeconds")
  const start = Date.now();
  if (found) {
    const startTime = performance.now();
    spinnerDetected = true;
    try {
      while (found) {
        found = await highlightOn(spinner);
        if (!found) break;
        await pause(100);
        found = await highlightOff(spinner);
        if (!found) break;
        await pause(100);
        if  (Date.now() - start &gt; timeout * 1000) {
          log (`ERROR: Spinner did not close after ${timeout}           seconds`)
          break;
        }
      }
    } catch (error) {
      // Spinner no longer exists
    }
    log(`  Spinner Elapsed time: ${Math.floor(performance.now() -     startTime)} ms`);
  }
  return spinnerDetected;
}</pre>			<p>The method utilizes the <strong class="source-inline">highlightOn()</strong> and the <strong class="source-inline">highlightOff()</strong> methods to flash the spinner or <strong class="bold">loading…</strong> element when it is detected. It will log a message if the spinner did not disappear within the<a id="_idIndexMarker240"/> timeout. And finally, it returns a Boolean value if a spinner was detected. This helps us optimize our framework, as we would need to perform a page sync if a <span class="No-Break">spinner appeared.</span></p>
			<p>Now we ca<a id="_idTextAnchor107"/>n proceed to expand the <strong class="source-inline">click()</strong> wrapper. It will require a dynamic method to wait for the page <span class="No-Break">to build.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor108"/>Expanding the click method wrapper</h1>
			<p>Let’s extend the <strong class="source-inline">clickAdv()</strong> method to make it more robust and less likely to fail. First, we will add a <strong class="source-inline">pageSync()</strong> function<a id="_idIndexMarker241"/> to the helper class. This function is an alternative way to determine when the page build has settled. After each click, we will perform the <span class="No-Break">following actions:</span></p>
			<ol>
				<li>Count the number of visible <strong class="source-inline">/span</strong> elements on <span class="No-Break">the page.</span></li>
				<li>Wait 1/4 of <span class="No-Break">a second.</span></li>
				<li>Repeat until either of the <span class="No-Break">following occur:</span><ul><li>The count of /span elements is stable <span class="No-Break">3 times</span></li><li>The timeout <span class="No-Break">is reached</span></li></ul></li>
				<li>Report service-level-agreement metrics on how long it took <span class="No-Break">to complete.</span></li>
				<li>Add the option to customize the length of the <span class="No-Break">wait time.</span></li>
			</ol>
			<p>The page sync method <a id="_idIndexMarker242"/>will dynamically wait for the page to build. It is optimized to spend a minimum of 0.75 seconds detecting when the page is completed. This reduces the chance of throwing an error if our element does not exist as the page is building. But it also gives us the flexibility to wait longer, up to 30 seconds for the page if there is a significant load put on the system slowing <span class="No-Break">everything down.</span></p>
			<p>It is rather large, so let us break <span class="No-Break">it down:</span></p>
			<pre class="source-code">
/**
 * pageSync - Dynamic wait for the page to stabilize.
 * Use after click
 * ms = default time wait between loops 125 = 1/8 sec
 *      Minimum 25 for speed / stability balance
 */
let LAST_URL: String = "";
export async function pageSync(
  ms: number = 25,
  waitOnSamePage: boolean = false
): Promise&lt;boolean&gt; {
  await waitForSpinner();</pre>			<p>We begin by waiting for<a id="_idIndexMarker243"/> any spinner or <strong class="bold">loading…</strong> elements to appear. Then we optimize by executing only when the URL <span class="No-Break">has changed:</span></p>
			<pre class="source-code">
let result = false;
  let skipToEnd = false;
  let thisUrl = await browser.getUrl();
  if (waitOnSamePage === false) {
    if (thisUrl === LAST_URL) {
      //skip rest of function
      result = true;
      skipToEnd = true;
    }
  }</pre>			<p>If the URL has not changed, it is more likely that a spinner simply appeared because a list option was selected, changing<a id="_idIndexMarker244"/> the elements on the page. If the URL is new then we begin by getting the first count of elements. This is a dynamic loop that executes no less than <span class="No-Break">three times:</span></p>
			<pre class="source-code">
  if (skipToEnd === false) {
    LAST_URL = thisUrl;
    const waitforTimeout = browser.options.waitforTimeout;
    let visibleSpans: String = `span:not([style*="visibility: hidden"])`;
    let elements: any = await $$(visibleSpans);
    let exit: boolean = false;
    let count: number = elements.length;
    let lastCount: number = 0;
    let retries: number = 3;
    let retry: number = retries;
    let timeout: number = 20; // 5 second timeout
    const startTime: number = Date.now();
    while (retry &gt; 0) {
      if ((lastCount != count) || (count &lt; 20)) {
        retry = retries; // Reset the count of attempts
      }
      // Exit after 3 stable element counts
      if (retry == 0) {
        break;
      }
      if (timeout-- === 0) {
        log("Page never settled");
        exit = true;
        break;
      }
      lastCount = count;</pre>			<p>After each element count, we let the page continue building for a brief moment. Then we count the elements again until the count is the same for three consecutive attempts. In addition, we keep checking whether the page count is greater than 20 elements. Often, this is the threshold below which lies a blank page without a spinner or <span class="No-Break"><strong class="bold">loading…</strong></span><span class="No-Break"> element.</span></p>
			<p>It is important to note that <a id="_idIndexMarker245"/>we only count <strong class="source-inline">Span</strong> elements. This could be <strong class="source-inline">div</strong> elements, but we should not count all elements with a star wildcard, the reason being that counting every element on the page itself can take longer than <span class="No-Break">a quarter-second:</span></p>
			<pre class="source-code">
      // wait 1/4 sec before next count check
      await pause(ms);
      try {
        elements = await $$(visibleSpans);
      } catch (error: any) {
        exit = true;
        switch (error.name) {
          case "TimeoutError":
            log(`ERROR: Timed out while trying to find visible             spans.`);
            break;
          case "NoSuchElementError":
            log(`ERROR: Could not find any visible spans.`);
            break;
          default:
            if (error.message === `Couldn't find page handle`) {
              log(`WARN: Browser closed. (Possibly missing await)`);
            }
        }
        // Error thrown: Exit loop
        break;
      }
      count = await elements.length;
      retry--;
    }</pre>			<p>The count of elements could throw errors. The function could time out. The page could have no span elements or the<a id="_idIndexMarker246"/> call might have been performed without an <strong class="source-inline">await</strong> keyword. In any case, the <span class="No-Break">function exits:</span></p>
			<pre class="source-code">
    // Metric: Report if the page took more than 3 seconds to build
    const endTime = Date.now();
    const duration = endTime - startTime;
    if (duration &gt; waitforTimeout) {
      log(`  WARN: pageSync() completed in ${duration / 1000}       sec  (${duration} ms) `);
    }
  }
  return result;
}</pre>			<p>This method takes two optional arguments. The first is the amount of milliseconds to wait for between counts of the page elements. The default value can be as low as 25 milliseconds but should not be more than 250. This gives us an optimal amount of time for the page to complete building after a click. If the page has not changed when the click was executed, the synchronization is skipped for speed, and it will exit early if no span element exists. This generally occurs when the page is blank. It will exit if the page did not settle within a few seconds and report this to <span class="No-Break">the console.</span></p>
			<p>It also gives us a warning if the wait time exceeded the expected timeout for the framework. This means that the <a id="_idIndexMarker247"/>page is taking longer to load than a user might be willing to wait. We could call our DBA and check for SQL queries with excessive record <span class="No-Break">retrieval times.</span></p>
			<p>For greater efficiency, <strong class="source-inline">pageSync</strong> will only execute if the page URL has changed. This is a speed optimization. The second parameter is a switch to force a page sync check even if the page URL remains <span class="No-Break">the same.</span></p>
			<p>Lastly, it will indicate whether the browser no longer exists. This can occur if an await statement is missing in the calling method and the test <span class="No-Break">ends early.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor109"/>Supercharged scroll before a click event</h1>
			<p>It is a good practice to check whether<a id="_idIndexMarker248"/> an element is on screen before performing a click. This method returns <strong class="source-inline">true</strong> if the element is in <span class="No-Break">the viewport:</span></p>
			<pre class="source-code">
export async function isElementInViewport(element: WebdriverIO.Element): Promise&lt;boolean&gt; {
  let isInViewport = await element.isDisplayedInViewport();
  return isInViewport;
}</pre>			<p>Using this method, we can optimize our code to scroll an element only if it is off-screen before performing the click event. However, there is a caveat: if an element is moving while WebdriverIO is attempting to click it, it may click the wrong element! So, we need another function to tell us when the element <span class="No-Break">stops moving:</span></p>
			<pre class="source-code">
export async function waitForElementToStopMoving(element: WebdriverIO.Element, timeout: number = 1500): Promise&lt;boolean&gt; {
  let rect = await element.getRect();
  pause (100);
  let isMoving = (rect !== await element.getRect())
  let startTime = Date.now();
  // Keep checking the element's position until it stops moving or the timeout is reached
  while (isMoving) {
    // If the element's position hasn't changed, it is not moving
    if (rect === await element.getRect()) {
      // Element is static
      isMoving = false;
    }else{
      // Element is moving...
      pause (100)
    }
    // If the timeout has been reached, stop the loop
    if (Date.now() - startTime &gt; timeout) {
      break;
    }
    // Wait for a short amount of time before checking the element's position again
    await pause(100);
  }
  return !isMoving;
}</pre>			<p>This method checks to see whether the element location has changed horizontally or vertically. To optimize <a id="_idIndexMarker249"/>speed, this will only be called if it was detected that the element <span class="No-Break">was off-screen.</span></p>
			<p>Let’s now tie all this together into a  <strong class="source-inline">clickAdv()</strong> method to make it less likely <span class="No-Break">to fail.</span></p>
			<p class="callout-heading">Quick tip: accuracy over speed</p>
			<p class="callout">Running a test faster delivers no advantage if the test can’t reach a successful conclusion. The wait between element counts in <strong class="source-inline">pageSync()</strong> can be reduced to 0 milliseconds, but it increases the risk of executing too soon. You can tweak this value for optimal performance, but be careful that the framework doesn’t run <span class="No-Break"><em class="italic">too</em></span><span class="No-Break"> fast.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor110"/>Expanding the click method wrapper</h1>
			<p>We are now ready to add our <strong class="source-inline">clickAdv()</strong> wrapper method. We will have a <strong class="source-inline">pageSync()</strong> method <a id="_idIndexMarker250"/>execute after every click to build in the flexible timing while we wait for the page <span class="No-Break">to complete:</span></p>
			<pre class="source-code">
export async function clickAdv(
  element: ChainablePromiseElement&lt;WebdriverIO.Element&gt;) {
  let success: boolean = false;
  const SELECTOR = await element.selector;
  log(`Clicking ${SELECTOR}`);
  try {
    //await element.waitForDisplayed();
    if (!await isElementInViewport(element)){
      await element.scrollIntoView({ block: "center", inline: "center" });
      await waitForElementToStopMoving(element)
    }
    await highlightOn(element);
    await element.click({ block: "center" });
    await pageSync();
    success = true;
  } catch (error: any) {
    log(`  ERROR: ${SELECTOR} was not clicked.\n           ${error.message}`);
    expect(`to be clickable`).toEqual(SELECTOR);
    // Throw the error to stop the test
    await element.click({ block: "center" });
  }
  return success;
}</pre>			<p>In this code, we get the name of the selector from the element. We use a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> around the click method. Then, we end the test by forcing a failure with our own custom error message indicating<a id="_idIndexMarker251"/> the element could not be clicked. In the automation switchboard, we set the value already failed to true to ensure the execution of the additional methods in the framework is skipped because the click failed. Finally, we return a Boolean value of <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> <span class="No-Break">for success.</span></p>
			<p>Now when we run the test with a bad element, we get more detail on the <span class="No-Break">underlying issue:</span></p>
			<pre class="source-code">
[0-0] ---&gt; Clicking button[type="bogus"]
[0-0] ---&gt;   ERROR: button[type="bogus"] was not clicked. [0-0] Error: element ("button[type="bogus"]") still not displayed after 30000ms</pre>			<p>Notice that we get an error that the element could not be found after 30 seconds. However, our page was built 28 seconds ago. So, let us change our timeout to be more efficient. This can be done by modifying the <strong class="source-inline">waitforTimeout</strong> value in the <strong class="source-inline">wdio.conf.ts</strong> file <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
waitforTimeout: 3000,</pre>			<p>Now when the test runs, no more than three seconds will be used before the test fails, but the test will wait longer for the page <span class="No-Break">to build:</span></p>
			<pre class="source-code">
public get btnBogus() {
  return $('//button[type="bogus"]');
}
await helpers.clickAdv(this.btnBogus);</pre>			<p>Again, this time-out value <a id="_idIndexMarker252"/>will differ from project to project. Next, we need implement functionality to track some information about <span class="No-Break">our execution.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor111"/>The importance of metrics</h1>
			<p>These methods<a id="_idIndexMarker253"/> report how much time they take to execute. <strong class="source-inline">ClickAdv()</strong> also reports a warning if the time taken to build the page was longer than the default timeout of the framework. With this, we can begin to get insights into how much our changes impact the application responsiveness over time, as well as how much the framework itself affects the speed <span class="No-Break">of execution.</span></p>
			<p>For example, using a baseline execution time for a given test, we can see whether framework enhancements are impacting total time positively, or inadvertently slowing down execution. A good page stabilization method will often continue execution sooner than a hardcoded wait. Tracking<a id="_idIndexMarker254"/> to total amount of time added by <strong class="source-inline">Pause()</strong> methods are added to the total <span class="No-Break">execution time.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor112"/>Self-healing elements</h1>
			<p>With custom method wrappers, we can now start to work to reduce the required maintenance in our<a id="_idIndexMarker255"/> framework with self-healing elements. These are elements in a user interface that automatically recover from issues without the need for updating the page object model. This can include link elements that have become invalid because the class has changed since the last release. Self-healing elements are designed to improve the testing experience by reducing the need for manual input and allowing the test a better chance to run <span class="No-Break">to completion.</span></p>
			<p>For example, let’s say the <strong class="source-inline">Login</strong> button in the last release was <span class="No-Break">a link:</span></p>
			<pre class="source-code">
  public get lnkSubmit() {
    return $('//a[text()="submit"]');
  }</pre>			<p>After this, we call the button that is no <span class="No-Break">longer valid:</span></p>
			<pre class="source-code">
    // Class switching
    await helpers.clickAdv(this.lnkSubmit);</pre>			<p>Normally, if this element were clicked, it would throw an error. But if we inject a function that gets a valid element based on the locator, we have a chance of getting through this step even if the underlying class <span class="No-Break">has changed:</span></p>
			<pre class="source-code">
  element = await getValidElement(element);
  const SELE<a id="_idTextAnchor113"/>CTOR = await element.selector;
  await log(`Clicking ${SELECTOR}`);</pre>			<p>In the following code, we will extract the class tag name and the text from the link and generate a button element locator on the fly. While unlikely, the code also covers the reverse case, where the <a id="_idIndexMarker256"/>button class has become <span class="No-Break">a link:</span></p>
			<pre class="source-code">
export async function getValidElement(
  element: WebdriverIO.Element
): Promise&lt;WebdriverIO.Element&gt; {
  let selector: any = await element.selector;
  // Get a collection of matching elements
  let found: boolean = true;
  let newSelector: string = ""
  let newElement: any = element;
  let elements: WebdriverIO.Element[];
  let elementType:string = ""
  let elementText:string = ""
  try {
    elements = await $$(selector);
    if (elements.length === 0) {
      let index: number = selector.indexOf("[");
      elementType = selector.substring(0, index);</pre>			<p>At this point, we have found no elements matching the locator. So we need to get creative based on the element that has gone missing since the last release. In the following code, we will look at a potential change of class from a link anchor to a button or <span class="No-Break">vice versa:</span></p>
			<pre class="source-code">
      switch (elementType) {
        case "//a":
          elementText = selector.match(/=".*"/)[0].slice(2, -1);
          newSelector = `//button[contains(@type,'${elementText}')]`
          break;
        case "//button":
          elementText = selector.match(/=".*"/)[0].slice(2, -1);
          newSelector =`//a[contains(text(),'${elementText}'])`
          break;</pre>			<p>In the following code, we will add <a id="_idIndexMarker257"/>similar class-switching code to handle lists and <span class="No-Break"><strong class="source-inline">Input</strong></span><span class="No-Break"> elements:</span></p>
			<pre class="source-code">
        default:
          found = false;
          newElement = element;
          break;
      }
      newElement = await $(newSelector);
      found = await isElementVisible (newElement)
    }
  } catch (error) {
    found = false;
  }
  // Successful class switch
  if (found) {
    await log(
      `  WARNING: Replaced ${selector}\n with ${newSelector}`
    );
  } else {
    await log(`  ERROR: Unable to find ${selector}`);
  }
  return newElement;
}</pre>			<p>Keep in mind that <strong class="source-inline">getValidElement()</strong> will not solve all of our maintenance issues. The goal is to reduce our maintenance by a significant amount by having a framework that is smart enough to recover <a id="_idIndexMarker258"/>from multiple stale elements and still get to a given endpoint. The code for replacement locators will be unique to each project, but it may be surprising how robust your tests will remain. There is some overhead with extra code and console logging, but it is minor compared to the amount of time required for updating element locators when a new release is pushed to the <span class="No-Break">staging environment.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor114"/>Stubbing out methods with the “alreadyFailed” switchboard key</h1>
			<p>A framework with a single <a id="_idIndexMarker259"/>point of exit can use the switchboard to track the number of pass, fail, and skipped steps. By embedding the <strong class="source-inline">alreadyFailed</strong> switch in the ASB switchboard, methods can be written to be stubbed out, reporting only what the action  had been intended <span class="No-Break">to do:</span></p>
			<pre class="source-code">
   ASB.set(`alreadyFailed`, !found)
   if (ASB.get(`alreadyFailed`) === true)) {
      allure.addStep(`Click '${selector}'`, undefined, 'skipped');
      ASB.set(`skipped`, ASB.get(`skipped`)++)
      return;
    }</pre>			<p>This skips all page sync time and delays while incrementing a counter for the number of steps needed to get the test to <span class="No-Break">its destination.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor115"/>Summary</h1>
			<p>In this chapter, we added a <strong class="source-inline">helpers</strong> library with several methods to enhance our <strong class="source-inline">click</strong> method. We then addressed bringing elements on screen if they are outside the viewport and using page synchronization to wait for flexible amounts of time for the page to build to ensure that our elements do not throw an error when testing. We added highlights as well as a spinner detector. We introduced the concept of class switching to try finding, and also included some details of <span class="No-Break">execution speed.</span></p>
			<p>Now that we have most of<a id="_idTextAnchor116"/> our supporting framework in place for the <strong class="source-inline">click()</strong> method, let us do the same thing with <strong class="source-inline">setValue()</strong>. This includes validating our input elements and using the quickest way to populate a field via the clipboard. Next, we’ll see how to enter text and replace <span class="No-Break">dynamic data.</span></p>
		</div>
	</body></html>