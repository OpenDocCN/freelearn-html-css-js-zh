- en: Chapter 2. Basic Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the basic syntax of Opa. This chapter will
    not cover every little tiny thing about Opa, but it is something you should know.
    It's also assumed that you have some basic knowledge about computer programming.
  prefs: []
  type: TYPE_NORMAL
- en: Basic datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Datatypes are the shapes of data manipulated by an application. Opa uses datatypes
    to perform sanity and security checks on your application. Opa also uses datatypes
    to perform a number of optimizations. There are three basic datatypes in Opa:
    integers, floats, and strings. Also, you can define your type with the keyword
    `type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, thanks to a mechanism of type inference, Opa can work in most cases
    even if you do not provide any type information. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So in the rest of this chapter, we will not address type information before
    variable, but you should know what type it is in your mind. In actual coding,
    a best practice is to provide the datatypes of our main functions and to let the
    inference engine pick up the datatypes of all the local variables and minor functions.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite simple to write integer literals; there are a number of ways to
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tailing semicolon is optional in Opa; you can add it if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opa provides the module `Int` ([http://doc.opalang.org/module/stdlib.core/Int](http://doc.opalang.org/module/stdlib.core/Int))
    to operate on integers. The following are the most used functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is no automatic type conversion between `float`, `int`, and `String`.
    So, use the following functions to convert between `int`, `float`, and `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Floats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also easy to define floats. They can be written in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Opa provides the module `Float` ([http://doc.opalang.org/module/stdlib.core/Float](http://doc.opalang.org/module/stdlib.core/Float))
    to operate on floats. The following are the most used functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Opa, text is represented by immutable utf8-encoded character strings. String
    literals follow roughly the same syntax used in C language, Java, or JavaScript.
    Note that you will have to escape special characters with backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Opa has a feature called string insertions, which can put arbitrary expressions
    into a string. You can do that by embedding an expression between curly braces
    into a string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Opa provides the module `String` ([http://doc.opalang.org/module/stdlib.core/String](http://doc.opalang.org/module/stdlib.core/String))
    to operate on strings. The most commonly used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A value has a sum type `t` or `u`, meaning that the values of this type are
    either of the two variants, a value of type `t` or a value of type `u`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of sum type are Boolean values, which are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, a variable of type `bool` can be either `{true}` or `{false}`. Another
    commonly used sum type is the `option` type, which is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The ``option(`a)`` value is either `none` or `some` (a value x of type `` `a
    ``). Type `` `a `` means any type. This is a type-safe way to deal with possibly
    non-existing values. The `option` type is widely used; let''s take `String.index`
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The return type of `String.index` is the option (`int`), which means it will
    return a `{some:int}` record if a substring appears or a `{none}` record if it
    doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the sum datatypes are not limited to two cases; they can have tens
    of cases.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opa is a functional language. One of its features is that functions are regular
    values, which means a function may be passed as a parameter or returned as a result.
    As such, they follow the same naming rules as any other value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Last expression return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may notice that there is no return inside the body of a function. That''s
    because Opa uses last expression return, which means the last expression of a
    function is the return value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If `x` is greater than or equal to `y`, then `x` is the last expression and
    `x` will be returned; if `y` is greater than `x`, then `y` is the last expression
    and `y` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functionalities are usually regrouped into modules; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can access the content of a module by using the dot operator (`.`); for instance,
    `M.x`, `M.y`, and `M.test`. Actually, the content of a module is not field definitions,
    but bindings. In this example, we bind integer `1` to variable `x`, and bind the
    value of variable `x` to variable `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only way to build data structures in Opa is to use records, which we will
    talk about later on. All other data structures, such as tuples and lists, are
    based on records. Opa provides different modules to help the user to manipulate
    lists and maps. Let's first have a look at records.
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simply speaking, a record is a collection of data. Here is how to build a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The empty record,`{}`, has a synonym, `void`, which means the same thing. There
    are a number of syntactic shortcuts available to write records concisely. First,
    if you give a field name without the field value, it means the value of this field
    is `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second shorthand we always use is the sign `~`. It means if the field value
    is left empty, assign it with a variable having the same name as the field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also build a record deriving from an existing record using the keyword
    `with`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can redefine as many fields as you want. In the example we saw
    just now, the field `a` in `y` is a string, but the field `a` in `x` is an integer.
    Here are some more examples about deriving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An N-tuple is a sequence of *n* elements, where N is a positive integer. In
    Opa, an N-tuple is just a record with fields `f1` to `fN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note the trailing comma in the first case; it differentiates a 1-tuple from
    a parenthesized expression. The trailing comma is allowed for any other tuple,
    although, it makes no difference whether you write it or not in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Opa, a list (linked list) is an immutable data structure, meant to contain
    finite or infinite sets of elements of the same type. Actually, list is just a
    record with special structures, which is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to build lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists in Opa are much like arrays in C language and Java. But there are differences.
    First, lists are immutable in Opa, which means elements of a list cannot be changed
    by assignment. Second, the way we manipulate lists are different. We use the module
    `List` ([http://doc.opalang.org/module/stdlib.core/List](http://doc.opalang.org/module/stdlib.core/List))
    to manage lists in Opa. The following are the most commonly used operations on
    lists (which will be explained in the subsequent sections):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Iterating through a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C language or Java, we use a `for` or a `while` loop to iterate through
    lists or arrays. They look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Opa, it is totally different. To loop through a list, we use `List.fold`
    or `List.foldi`. `List.fold` is a powerful function that you can use to do almost
    anything you want on a list. Here is a simple example of getting the length of
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`List.fold` takes three parameters. The first is a function, the second is
    the list, and the third is an initial value. It loops through the list and applies
    the function on each element. So, if we name the function `f`, it is executed
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, `f("a",0)` will be executed and will return 1, here `0` is the initial
    value and `a` is the first element. Then `f("b",1)` will return 2 and at last
    `f("c",2)` will return 3\. Here is a little more complicated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finding elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have many ways to find an element in a list. `List.index` searches the first
    occurrence of an element and returns its index. `List.index_p` searches the first
    occurrence of any element matching a given function and returns its index. `List.find`
    is the same as `List.index_p`, but returns the element itself but not its index.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Transforming lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to project elements to a new list, for example doubling the number
    in a list or selecting the odd numbers, you can do this with `List.map` and `List.filter`.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Call the function `List.sort` to sort a list in the usual order. The usual
    order means the default order, that is, numbers from small to big and strings
    in alphabetical order. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`List.sort_by` uses the usual order, but it projects elements, for example,
    converting strings to lower-case before comparing them. `List.sort_with` allows
    us to use our own comparing function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that clear, suppose there are three points, P1 (1, 3), P2 (3, 2), and
    P3 (2, 1), and we want to sort them in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By their Y coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By distance from the origin of the coordinates (0, 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to do that in Opa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are an important data structure just like lists. The most common cases
    of maps in Opa are `stringmap` and `intmap`. `stringmap` is a map from string
    to value of some type, while `intmap` is a map from numbers to value of some type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we manipulate maps is almost the same as lists, it is unwise to repeat
    it again. Here are some of the most used operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching is a generalization of C language or Java''s `switch` statement.
    In C language and Java, the `switch` statement only allows you to choose from
    many statements based on an integer (including `char`) or an `enum` value. While
    in Opa, pattern matching is more powerful than that. The more general syntax for
    pattern matching is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When a pattern is executed, `<expr>` is evaluated to a value, which is then
    matched against each pattern in order until a case is found. You can think about
    it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The rules of pattern matching are simple and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**: Any value matches the pattern `_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2**: Any value matches the variable pattern `x`, and the value is bound
    to the identifier `x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3**: An integer/float/string matches an integer/float/string pattern
    when they are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 4**: A record (including tuples and lists) matches a closed record pattern
    when both records have the same fields and the value of the fields matches the
    pattern component-wise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 5**: A record (including tuples and lists) matches an open record pattern
    when the value has all the fields of the pattern (but can have more) and the value
    of the common fields matches the pattern component-wise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 6**: A value matches a pattern as `x` pattern when the value matches
    the pattern, and additionally it binds `x` to the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 7**: A value matches an `OR` pattern if one of the values matches one
    of the two subpatterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 8**: In all the other cases, the matching fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three and the last three rules (rule 1, 2, 3, 6, 7, 8) are easy to
    understand. Let''s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code will not compile, we just used it to illustrate the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 4 and rule 5 are a little more complicated. A close record pattern is
    a record with fixed fields. An open record pattern is a record that ends with
    `…` to indicate that it may have other fields we do not care about. The following
    examples may make that clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also match tuples and lists (since tuples and lists are special records,
    they are not hard to understand). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Text parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parsing is something that web apps need to do quite often. Opa features a built-in
    syntax for building text parsers, which are first class values just as functions.
    The parser is based on parsing expression grammar ([http://en.wikipedia.org/wiki/Parsing_expression_grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar)),
    which may look like regular expressions at first, but do not behave anything like
    them. One big advantage of text parsers over regular expressions is that you can
    easily combine parsers. A good example is parsing URLs. Let''s start right away
    with our first Opa parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For `first_parser`, the expressions are just literal strings, which means this
    parser will succeed only if fed with the string `"Opa"`. Then how to use this
    parser? The module `Parser` ([http://doc.opalang.org/module/stdlib.core.parser/Parser](http://doc.opalang.org/module/stdlib.core.parser/Parser))
    has a bunch of functions to deal with parsers. The most important one is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a parser and a string as parameters and produces an optional value
    of some type. Let''s see how to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s consider the following parsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `digit1` and `digit2` accept a number string like `"5","100"`, and both
    will assign the value to the identifier `x`. If we feed the parser `digit1` with
    the string `"100"`, x will be the parsing result of the string: a list of characters
    [`''1'',''0'',''0''`]. If we feed the string `"100"` to parser `digit2`, `x` will
    be the input string: `100`. So, if we want to get hold of the input string, we
    need to put the expression in parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move it a little further; consider the following parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This parser accepts an integer string and returns the absolute value. You may
    figure out how it works with the previous knowledge. Note that even if the expression
    of PEG looks like a regular expression, they are different.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced you to the basic syntax in Opa programming, including
    datatypes, functions, records, tuples, lists, maps, patterns, and parsers. This
    is the basic knowledge that we should know to make a good Opa program. With the
    previous knowledge, we will see how to develop a web application in the next chapter.
  prefs: []
  type: TYPE_NORMAL
