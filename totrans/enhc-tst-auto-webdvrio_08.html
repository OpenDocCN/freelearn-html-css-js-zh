<html><head></head><body>
		<div><h1 id="_idParaDest-116" class="chapter-number"><a id="_idTextAnchor165"/>8</h1>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor166"/>The Assert Wrapper – the Importance of Embedded Details</h1>
			<p>In this chapter, we will be writing our first assertion wrapper. Assertions allow us to pass or fail a test as well as add detail regarding the expected and actual results. WebdriverIO has at least three ways to implement assertions and each has its own style. First, there is the standard Jest <code>expect-webdriverio</code> for all examples in this book. However, a little background on how these approaches differ should be noted.</p>
			<p>We'll cover the following main topics in this chapter:</p>
			<ul>
				<li>expect, assert, and should </li>
				<li>Timeout</li>
				<li>Hard and soft expect assertions</li>
				<li>Allure reports</li>
			</ul>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor167"/>expect, assert, and should –how did we get here?</h1>
			<p>Let’s take a look at a brief history of <a id="_idIndexMarker339"/>JavaScript assertion libraries to understand why we will be making some of the choices in our custom <code>assert()</code> wrapper.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor168"/>What is Jasmine?</h2>
			<p>Jasmine was first released in 2010. It was designed to provide a simple and flexible way to add assertions. It provides <a id="_idIndexMarker340"/>a set of built-in assertion methods. Note that the interface is <code>expect</code> with chainable methods such as <code>.toBe</code>, <code>.toEq<a id="_idTextAnchor169"/>ual</code>, and <code>.not</code>. Here is a sample assertion in Jasmine:</p>
			<pre class="source-code">
function addNumbers(arg0: number, arg1: number): number {
  return arg0 + arg1;
}
describe('My Math Library', () =&gt; {
  it('should add two numbers correctly', () =&gt; {
    const result = addNumbers(2, 3);
    expect(result).toEqual(5);
    expect(result).toEqual(6); //Intentional fail
  });
});</pre>			<p>The preceding test calls a<a id="_idIndexMarker341"/> simple function that returns the sum of two arguments passed to the <code>AddNumbers()</code> function.</p>
			<p>This is a basic arithmetic assertion. If we run it, we notice the pass result does not report anything. Only the failure is reported. It really does not provide much detail when passing or failing:</p>
			<div><div><img src="img/B19395_08_1.jpg" alt="Figure 8.1: Results of a pass and intentional fail of the AddNumbers() function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Results of a pass and intentional fail of the AddNumbers() function</p>
			<p>In a test automation project, we would need to extract the object properties or values and validate that against <a id="_idIndexMarker342"/>the expected result. The detailed result may only report expected <code>[true]</code> actual <code>[false]</code>. To provide this output would require a lot of additional code to include if we had it performed at the test or feature file level.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor170"/>What is Jest?</h2>
			<p>In 2013, Jest was released by <a id="_idIndexMarker343"/>Facebook and became widely adopted by the React community. It has a similar assertion syntax as Jasmine with additional features including snapshot testing and code coverage reporting. Note the interface is also <code>expect</code>. Here is the same assertion in Jest:</p>
			<pre class="source-code">
describe('My Math Library', () =&gt; {
  test('should add two numbers correctly', () =&gt; {
    let expected = 5
    let actual = 5
    expect(actual).toBe(expected);
    actual = 4
    expect(actual).toBe(expected);
  });</pre>			<p>However, Jest on its own does not support any messages to report the details of the validation. The <code>jest-expect-message</code> package should be included to provide this functionality with <code>npm</code> or <code>yarn</code>:</p>
			<pre class="console">
npm install jest-expect-message
yarn add jest-expect-message</pre>			<p>Now that we have added the <code>expect</code> message package for Jest, we can provide more descriptive results:</p>
			<pre class="source-code">
describe('My Math Library', () =&gt; {
  test('should add two numbers correctly', () =&gt; {
    Let expected = 5
    let actual = 5
    expect(actual,
`Expected: '${expected}' Actual: '${actual}'`).toBe(expected);
expected = 4
expect(actual, `Expected: '${expected}' Actual: '${actual}'`).toBe(expected);
  });
});</pre>			<p>Jest is included as part of the WebdriverIO package, but WDIO has an extended assertion library of its <a id="_idIndexMarker344"/>own. This allows us to pass elements directly for assertions rather than writing our own.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor171"/>What is Chai?</h2>
			<p>Chai is a popular assertion<a id="_idIndexMarker345"/> library for JavaScript that provides three interfaces for making assertions:</p>
			<ul>
				<li><code>should (BDD)</code></li>
				<li><code>expect (BDD)</code></li>
				<li><code>assert (TDD)</code></li>
			</ul>
			<p>Each of these interfaces has its own pros and cons, which we will look into in the subsections.</p>
			<h3>Should</h3>
			<p>The <code>should</code> interface extends all objects<a id="_idIndexMarker346"/> with a <code>should</code> property that can be used to make <a id="_idIndexMarker347"/>assertions. Here is a Chai <code>should</code> sample:</p>
			<pre class="source-code">
import 'chai/register-should'
describe('My App', () =&gt; {
  it('should have the correct title', () =&gt; {
    browser.url('https://example.com');
    browser.getTitle().should.be.equal('Example Domain');
  });
});</pre>			<p>While this interface allows for readable and expressive code, it can lead to unexpected side effects in the way that it modifies object behaviors. For this reason, it will not be a part of our implementation.</p>
			<h3>Assert</h3>
			<p>The <code>assert</code> interface <a id="_idIndexMarker348"/>provides a more classical style of making assertions, using traditional<a id="_idIndexMarker349"/> methods such as <code>assert.equal()</code> and <code>assert.notEqual()</code>. This interface is useful for developers who are already familiar with other testing frameworks or who prefer a more traditional style of testing. However, it can be less readable and expressive than the <code>should</code> or <code>expect</code> interfaces, especially when dealing with more complex assertions:</p>
			<pre class="source-code">
const assert = require('assert');
describe('My App', () =&gt; {
  it('should have the correct title', () =&gt; {
    browser.url('https://example.com');
    const actualTitle = browser.getTitle();
    const expectedTitle = 'Example Domain';
    assert(actualTitle === expectedTitle);
  });
});</pre>			<h3>Expect</h3>
			<p>The Chai <code>expect</code> interface<a id="_idIndexMarker350"/> provides a more flexible and chainable way of making assertions. This interface is<a id="_idIndexMarker351"/> designed to be easy to read and write and provides a fluent syntax that can be used to make complex assertions in a clear and concise way. Here is a Chai <code>should</code> sample:</p>
			<pre class="source-code">
import assert from 'chai';
describe('My App', () =&gt; {
  it('expect to have the correct title with chai', () =&gt; {
    browser.url('https://example.com');
    expect(browser.getTitle()).to.equal('Example Domain');
  });
});</pre>			<p>Using Chai’s <code>expect</code> interface is the preferred way of making assertions. It provides a lot of flexibility without the side effects of <code>should</code> with a similar syntax to the Jest assertions. There is a problem, we don’t get all the details. Consider this:</p>
			<pre class="source-code">
await LoginPage.open();
await expect(browser).toHaveUrlContaining('the-internet.herokuapp.com/login')
[chrome 110.0.0.0 win32 #0-0]    ✓ Chapter 8: expectAdv Wrapper should check if actual is equal to expected
0.0 win32 #0-0] 1 passing (844ms)</pre>			<p>Sure, the tests passed, but what exactly did it do? There is no expected result, actual results, or any detail of <a id="_idIndexMarker352"/>what the assertion is doing. This is why we need wrappers to simplify our reporting <a id="_idIndexMarker353"/>of our results.</p>
			<p>Let us look at a failing assertion:</p>
			<pre class="source-code">
await LoginPage.open();
await expect(browser).toHaveUrlContaining('the-internet.herokuapp.com/bogus')
[chrome 110.0.0.0 win32 #0-0] Error: Expect window to have url containing "the-internet.herokuapp.com/bogus"
<strong class="bold">Expected</strong>: "the-internet.herokuapp.com/bogus"
<strong class="bold">Received</strong>: "https://the-internet.herokuapp.com/login"
[chrome 110.0.0.0 win32 #0-0] error properties: Object({ matcherResult: Object({ pass: false, message: 'Expect window to have url containing
[chrome 110.0.0.0 win32 #0-0]
[chrome 110.0.0.0 win32 #0-0] Expected: "the-internet.herokuapp.com/bogus"
[chrome 110.0.0.0 win32 #0-0] Received: "https://the-internet.herokuapp.com/login"' }) })
[chrome 110.0.0.0 win32 #0-0] Error: Expect window to have url containing
[chrome 110.0.0.0 win32 #0-0] Expected: "the-internet.herokuapp.com/bogus"
[chrome 110.0.0.0 win32 #0-0] Received: https://the-internet.herokuapp.com/login</pre>			<p>Now we are over-reporting as we had one validation. The error was reported three times to the output, and that is a problem.</p>
			<p>There is one problem – all of these assertion packages are designed to perform a hard expect ending the test execution, not a soft expect that will allow the test to perform more validations:</p>
			<pre class="source-code">
Spec Files:      0 passed, 1 failed, 1 total (100% completed) in 00:00:06</pre>			<p>Notice it takes 6 <a id="_idIndexMarker354"/>seconds for the validation to fail. Do we really need to wait that <a id="_idIndexMarker355"/>much time? We already have the <code>pageSync()</code> method consuming all the time needed.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor172"/>Timeout – delay of game</h1>
			<p>The default timeout for a WebdriverIO <code>expect</code> matcher is 3 seconds and the interval is 100 ms. That is 30 checks over 3 seconds, which<a id="_idIndexMarker356"/> is far better than waiting 30 seconds as is the industry standard. Remember we are using the <code>pageSync()</code> method to burn the time that the page uses to build. It makes sense that our assertions should be available almost immediately. To adjust the timeout and interval of the <code>expect-webdriverio</code> assertion, we can make a change in the WebdriverIO hooks section of the <code>wdio.config.ts</code> file:</p>
			<pre class="source-code">
before: function (capabilities, specs){
require('expect-webdriverio').setOptions ({wait:5000, interval: 250});
}</pre>			<p>This code will now change our <code>expect</code> assertions to be executed 20 times. The wait timeout will be 5 seconds. The check will be performed every 1/4 second:</p>
			<p><code>Spec Files: 0 passed, 1 failed, 1 total (100% completed) </code><code>in 00:00:05</code></p>
			<p>The resulting time is now reduced to an optimal amount. It is just a second, but a little here and there saves minutes and hours.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor173"/>What is expect-webdriverio?</h2>
			<p>For the purpose of this<a id="_idIndexMarker357"/> book, we will be using <code>expect-webdriverio</code>.</p>
			<p>WebdriverIO <a id="_idIndexMarker358"/>uses the <code>expect-webdriverio</code> assertion library, which is an extension of the Jest <code>expect</code> interface. It adds browser and element assertions:</p>
			<pre class="source-code">
const expect = require('expect-webdriverio');
describe('My App', () =&gt; {
  it('should have the correct title', () =&gt; {
    browser.url('https://example.com');
    expect(browser).toHaveTitle('Example Domain');
  });
});</pre>			<p>However, all these <a id="_idIndexMarker359"/>libraries are missing the ability to execute a soft assertion. For that, we turn to Chai and the <code>soft-assert</code> package.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor174"/>What are hard and soft expect assertions?</h1>
			<p>By default, all of the<a id="_idIndexMarker360"/> assertion packages perform a <strong class="bold">hard expect assertion</strong>, which is more commonly known as a <strong class="bold">hard assert</strong>. This means that when an assertion fails, the test ends. What<a id="_idIndexMarker361"/> kind of superhero leaves the fight after the first punch? This is problematic as we might have four or five values on a single page that we want to assert. What is the point of failing on the first assertion and leaving the next four out of the results? We want the power to continue the fight even if we take one to the chin along the way.</p>
			<p>That is why we strive to add the ability of a <strong class="bold">soft expect</strong> (more commonly known as <strong class="bold">soft assert</strong>) into the framework. This<a id="_idIndexMarker362"/> feature is built into Java’s TestNG. It seems a shame that it is missing from all the popular JavaScript assertion libraries. If the buttons exist for navigation, the best testing frameworks will be able to get to the end point and have all validations executed, no matter whether they pass or fail. That is our ultimate dual goal: more results in our report and less repetitious piecemeal runs.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor175"/>Putting it all together</h2>
			<p> Now, we need to protect our identities; to accomplish this feat, we use <code>expect-webdriverio</code>, which <a id="_idIndexMarker363"/>extends the Chai <code>expect</code> interface.</p>
			<p>We can now perform a failing soft assertion on our <strong class="bold">Bogus</strong> button and still allow the next assertions to execute:</p>
			<pre class="source-code">
const btnBogus = $('button[name="Bogus"]');
softexpect(btnBogus.isEnabled()).to.be.true;
const btnAddToCart = $('button[name="Add To Cart"]');
softExpect(btnAddToCart.isEnabled()).to.be.true;
expect(addToCartButton.isClickable()).to.be.clickable;</pre>			<p>We have our power rings. When we smash them together, we will take on multiple forms, as a helper <code>expectAdv()</code> wrapper will be used to increase the flexibility in the amount of detail being provided in a consistent format. This section will take us beyond generic fail messages and detail the pass results with the least amount of repeated code.</p>
			<p>The <code>expect-webdriverio</code> library supports 23 different element matcher assertions. Eight are substring matchers of other full-string assertions. Others, such as <code>.toBePresent</code>, <code>.toHaveChildren</code>, and <code>.toBeDisplayedInViewPort</code>, are in the lesser part of the 80/20 relevancy.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor176"/>What are soft assertions and why would we need them?</h2>
			<p>An efficient test<a id="_idIndexMarker364"/> will be able to perform multiple validations on a page, but if the first of three assertions fail, the test will immediately end. Maybe only the first assertion is failing, or maybe all three. We want the full count of assertions, not the least. Otherwise, it becomes a piecemeal process and slows us down.</p>
			<p>Note that <code>Expect.toBeExist</code>, <code>Expect.toBePresent</code>, and <code>Expect.toBeExisting</code> only mean the element is in the DOM. They do not explicitly mean the element is visible to the user, so they are, for the most part, impractical.</p>
			<p>WebdriverIO provides positive<a id="_idIndexMarker365"/> and negative checks of the status of elements:</p>
			<pre class="source-code">
Expect.toBeDisplayed
Expect.toBeFocused
Expect.toBeEnabled
Expect.toBeDisabled
Expect.toBeClickable
Expect.toBeChecked
Expect.toBeSelected</pre>			<p>It also provides two ways to check whether an element contains text or a value:</p>
			<pre class="source-code">
Expect.toHaveText / Expect.toHaveTextContaining
Expect.toHaveValue / Expect.toHaveValueContaining</pre>			<p>It also provides validations of IDs, elements, and attributes, which can be exact or string subsets:</p>
			<pre class="source-code">
Expect.toHaveElementProperty
Expect.toHaveAttribute
Expect.toHaveAttributeContaining
Expect.toHaveElementClass
Expect.toHaveElementClassContaining
Expect.toHaveId
Expect.toHaveLink / Expect.toHaveLinkContaining</pre>			<h2 id="_idParaDest-127"><a id="_idTextAnchor177"/>Soft asserts – allowing a test to continue after an assertion fails</h2>
			<p>In our custom <code>expectAdv</code> wrapper, we<a id="_idIndexMarker366"/> will implement a few concepts that allow it to be read similarly to a plain English sentence. The first parameter, <code>actual</code>, is intentionally assigned the <code>any</code> type. This is because we want the flexibility to validate either an element or a string value:</p>
			<pre class="source-code">
function expectAdv(
actual: any,
assertionType: string,
expected?: any,
Description: string = 'A description of this assertion is recommended.')
}</pre>			<p>Here, <code>assertionType</code> is a string that indicates the assertion to perform. An element might <em class="italic">exist</em>; the element might <em class="italic">equal</em> an expected string.</p>
			<p>The expected argument is optional as it would not be required if an element “is enabled”.</p>
			<p class="callout-heading">Quick tip</p>
			<p class="callout">The description is required. Every validation should have some detail about what is being performed. Thus, if it is missing, a helpful nudge to add transparency to our test case is provided.</p>
			<p>In the case of a soft assertion, the method returns a Boolean <code>true</code> or <code>false</code> value. This means our test cases can be optimized with decision trees. This concept will be used in a later chapter when we discuss how to have steps that continue without failure even if the element does not exist.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor178"/>Introduction to Allure reports</h1>
			<p>Allure is a powerful reporting framework that presents concise and well-organized reports. You can access this <a id="_idIndexMarker367"/>report template by installing the <code>@wdio/allure-reporter</code> and <code>allure-commandline</code> packages:</p>
			<pre class="console">
&gt; yarn add @wdio/allure-reporter</pre>			<p>Allure exports reports in a standardized format called Allure results format. To generate comprehensive reports, you can utilize the Allure framework through the command-line interface:</p>
			<pre class="console">
"node_modules/.bin/allure generate --clean ./reports/allure-results &amp;&amp; allure open -p 5050"</pre>			<p>The Allure Framework is a versatile and lightweight test reporting tool supporting multiple programming languages. It provides a succinct presentation of test results in HTML format, empowering all stakeholders in the development process to extract valuable insights from <a id="_idIndexMarker368"/>routine test executions:</p>
			<pre class="source-code">
<strong class="bold">// Code example using expect-webdriverio</strong>
export async function expectAdv(actual, assertionType, expected) {
  const softAssert = expect;
  const getAssertionType = {
    equals: () =&gt; (softAssert(actual).toEqual(expected)),
    contains: () =&gt; (softAssert(actual).toContain(expected)),
    exist: () =&gt; (softAssert(actual).toBeExisting()),
    isEnabled: () =&gt; (softAssert(actual).toBeEnabled()),
    isDisabled: () =&gt; (softAssert(actual).toBeDisabled()),
    doesNotExist: () =&gt; (softAssert(actual).not.toBeExisting()),
    doesNotContain: () =&gt; (softAssert(actual).not.toContain(expected)),
    default: () =&gt; (console.info('Invalid assertion type:  ', assertionType)),
  };
  (getAssertionType[assertionType] || getAssertionType['default'])();
  if (!getAssertionType[assertionType]){
    allureReporter.addAttachment('Assertion Failure: ', `Invalid Assertion Type = ${assertionType}`, 'text/plain');
    allureReporter.addAttachment('Assertion Error: ', console.error, 'text/plain');
  } else {
    allureReporter.addAttachment('Assertion Passes: ', `Valid Assertion Type = ${assertionType}`, 'text/plain');
 }
  allureReporter.endStep();
}</pre>			<p>By adding these Allure<a id="_idIndexMarker369"/> statements into our framework, we can provide significantly more detail to stakeholders in a way that is visually informative.</p>
			<div><div><img src="img/B19395_08_2.jpg" alt="Figure 8.2: Samples of test results in Allure with historical trends"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Samples of test results in Allure with historical trends</p>
			<p>Allure reports can organize tests into subcategories. This makes it clear whether related tests are failing. It also shows how the runs have been performing over time. This can show both an increase in test case coverage as well trends where results are improving or recently worsening.</p>
			<div><div><img src="img/B19395_08_3.jpg" alt="Figure 8.3: Sample of step-by-step execution with a screen capture of the Login page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: Sample of step-by-step execution with a screen capture of the Login page</p>
			<p>These reports also <a id="_idIndexMarker370"/>provide the option to add screen captures such as X-ray vision. This can give vital clues as to what is occurring when the test fails, particularly if we are running in the cloud without a direct live view into the system as it runs.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor179"/>Summary</h1>
			<p>In this section, we talked about the history of assert, expect, and should assertions. We introduced the concepts of hard and soft assertions, why they are important distinctions, and when they should be implemented. We also introduced Allure reports to provide details of all events being executed and the results of whether they pass or fail. Allure reports will further enhance our view in the future by providing a historical view of tests that pass and fail. In the next chapter, we'll build the page object model.</p>
		</div>
	</body></html>