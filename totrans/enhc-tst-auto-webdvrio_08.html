<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-116" class="chapter-number"><a id="_idTextAnchor165"/>8</h1>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor166"/>The Assert Wrapper – the Importance of Embedded Details</h1>
			<p>In this chapter, we will be writing our first assertion wrapper. Assertions allow us to pass or fail a test as well as add detail regarding the expected and actual results. WebdriverIO has at least three ways to implement assertions and each has its own style. First, there is the standard Jest <strong class="bold">expect</strong> assertion library, which is <a id="_idIndexMarker336"/>basic to evaluate numbers, strings, and even regular expression matchers. Then there is the <strong class="bold">expect-webdriverio</strong> assertion library, which<a id="_idIndexMarker337"/> is an extension of the Jest matchers. These take web objects and perform assertions on both values and states. Lastly, there is<a id="_idIndexMarker338"/> the <strong class="bold">Chai</strong> assertion library, which provides soft assertions and a variety of implementation styles. While the library choice is up to you, we will be using <strong class="source-inline">expect-webdriverio</strong> for all examples in this book. However, a little background on how these approaches differ should <span class="No-Break">be noted.</span></p>
			<p>We'll cover the following main topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>expect, assert, and should </li>
				<li><span class="No-Break">Timeout</span></li>
				<li>Hard and soft <span class="No-Break">expect assertions</span></li>
				<li><span class="No-Break">Allure reports</span></li>
			</ul>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor167"/>expect, assert, and should –how did we get here?</h1>
			<p>Let’s take a look at a brief history of <a id="_idIndexMarker339"/>JavaScript assertion libraries to understand why we will be making some of the choices in our custom <span class="No-Break"><strong class="source-inline">assert()</strong></span><span class="No-Break"> wrapper.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor168"/>What is Jasmine?</h2>
			<p>Jasmine was first released in 2010. It was designed to provide a simple and flexible way to add assertions. It provides <a id="_idIndexMarker340"/>a set of built-in assertion methods. Note that the interface is <strong class="source-inline">expect</strong> with chainable methods such as <strong class="source-inline">.toBe</strong>, <strong class="source-inline">.toEq<a id="_idTextAnchor169"/>ual</strong>, and <strong class="source-inline">.not</strong>. Here is a sample assertion <span class="No-Break">in Jasmine:</span></p>
			<pre class="source-code">
function addNumbers(arg0: number, arg1: number): number {
  return arg0 + arg1;
}
describe('My Math Library', () =&gt; {
  it('should add two numbers correctly', () =&gt; {
    const result = addNumbers(2, 3);
    expect(result).toEqual(5);
    expect(result).toEqual(6); //Intentional fail
  });
});</pre>			<p>The preceding test calls a<a id="_idIndexMarker341"/> simple function that returns the sum of two arguments passed to the <span class="No-Break"><strong class="source-inline">AddNumbers()</strong></span><span class="No-Break"> function.</span></p>
			<p>This is a basic arithmetic assertion. If we run it, we notice the pass result does not report anything. Only the failure is reported. It really does not provide much detail when passing <span class="No-Break">or failing:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B19395_08_1.jpg" alt="Figure 8.1: Results of a pass and intentional fail of the AddNumbers() function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Results of a pass and intentional fail of the AddNumbers() function</p>
			<p>In a test automation project, we would need to extract the object properties or values and validate that against <a id="_idIndexMarker342"/>the expected result. The detailed result may only report expected <strong class="source-inline">[true]</strong> actual <strong class="source-inline">[false]</strong>. To provide this output would require a lot of additional code to include if we had it performed at the test or feature <span class="No-Break">file level.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor170"/>What is Jest?</h2>
			<p>In 2013, Jest was released by <a id="_idIndexMarker343"/>Facebook and became widely adopted by the React community. It has a similar assertion syntax as Jasmine with additional features including snapshot testing and code coverage reporting. Note the interface is also <strong class="source-inline">expect</strong>. Here is the same assertion <span class="No-Break">in Jest:</span></p>
			<pre class="source-code">
describe('My Math Library', () =&gt; {
  test('should add two numbers correctly', () =&gt; {
    let expected = 5
    let actual = 5
    expect(actual).toBe(expected);
    actual = 4
    expect(actual).toBe(expected);
  });</pre>			<p>However, Jest on its own does not support any messages to report the details of the validation. The <strong class="source-inline">jest-expect-message</strong> package should be included to provide this functionality with <strong class="source-inline">npm</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">yarn</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
npm install jest-expect-message
yarn add jest-expect-message</pre>			<p>Now that we have added the <strong class="source-inline">expect</strong> message package for Jest, we can provide more <span class="No-Break">descriptive results:</span></p>
			<pre class="source-code">
describe('My Math Library', () =&gt; {
  test('should add two numbers correctly', () =&gt; {
    Let expected = 5
    let actual = 5
    expect(actual,
`Expected: '${expected}' Actual: '${actual}'`).toBe(expected);
expected = 4
expect(actual, `Expected: '${expected}' Actual: '${actual}'`).toBe(expected);
  });
});</pre>			<p>Jest is included as part of the WebdriverIO package, but WDIO has an extended assertion library of its <a id="_idIndexMarker344"/>own. This allows us to pass elements directly for assertions rather than writing <span class="No-Break">our own.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor171"/>What is Chai?</h2>
			<p>Chai is a popular assertion<a id="_idIndexMarker345"/> library for JavaScript that provides three interfaces for <span class="No-Break">making assertions:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">should (BDD)</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">expect (BDD)</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">assert (TDD)</strong></span></li>
			</ul>
			<p>Each of these interfaces has its own pros and cons, which we will look into in <span class="No-Break">the subsections.</span></p>
			<h3>Should</h3>
			<p>The <strong class="source-inline">should</strong> interface extends all objects<a id="_idIndexMarker346"/> with a <strong class="source-inline">should</strong> property that can be used to make <a id="_idIndexMarker347"/>assertions. Here is a Chai <span class="No-Break"><strong class="source-inline">should</strong></span><span class="No-Break"> sample:</span></p>
			<pre class="source-code">
import 'chai/register-should'
describe('My App', () =&gt; {
  it('should have the correct title', () =&gt; {
    browser.url('https://example.com');
    browser.getTitle().should.be.equal('Example Domain');
  });
});</pre>			<p>While this interface allows for readable and expressive code, it can lead to unexpected side effects in the way that it modifies object behaviors. For this reason, it will not be a part of <span class="No-Break">our implementation.</span></p>
			<h3>Assert</h3>
			<p>The <strong class="source-inline">assert</strong> interface <a id="_idIndexMarker348"/>provides a more classical style of making assertions, using traditional<a id="_idIndexMarker349"/> methods such as <strong class="source-inline">assert.equal()</strong> and <strong class="source-inline">assert.notEqual()</strong>. This interface is useful for developers who are already familiar with other testing frameworks or who prefer a more traditional style of testing. However, it can be less readable and expressive than the <strong class="source-inline">should</strong> or <strong class="source-inline">expect</strong> interfaces, especially when dealing with more <span class="No-Break">complex assertions:</span></p>
			<pre class="source-code">
const assert = require('assert');
describe('My App', () =&gt; {
  it('should have the correct title', () =&gt; {
    browser.url('https://example.com');
    const actualTitle = browser.getTitle();
    const expectedTitle = 'Example Domain';
    assert(actualTitle === expectedTitle);
  });
});</pre>			<h3>Expect</h3>
			<p>The Chai <strong class="source-inline">expect</strong> interface<a id="_idIndexMarker350"/> provides a more flexible and chainable way of making assertions. This interface is<a id="_idIndexMarker351"/> designed to be easy to read and write and provides a fluent syntax that can be used to make complex assertions in a clear and concise way. Here is a Chai <span class="No-Break"><strong class="source-inline">should</strong></span><span class="No-Break"> </span><span class="No-Break">sample:</span></p>
			<pre class="source-code">
import assert from 'chai';
describe('My App', () =&gt; {
  it('expect to have the correct title with chai', () =&gt; {
    browser.url('https://example.com');
    expect(browser.getTitle()).to.equal('Example Domain');
  });
});</pre>			<p>Using Chai’s <strong class="source-inline">expect</strong> interface is the preferred way of making assertions. It provides a lot of flexibility without the side effects of <strong class="source-inline">should</strong> with a similar syntax to the Jest assertions. There is a problem, we don’t get all the details. <span class="No-Break">Consider this:</span></p>
			<pre class="source-code">
await LoginPage.open();
await expect(browser).toHaveUrlContaining('the-internet.herokuapp.com/login')
[chrome 110.0.0.0 win32 #0-0]    ✓ Chapter 8: expectAdv Wrapper should check if actual is equal to expected
0.0 win32 #0-0] 1 passing (844ms)</pre>			<p>Sure, the tests passed, but what exactly did it do? There is no expected result, actual results, or any detail of <a id="_idIndexMarker352"/>what the assertion is doing. This is why we need wrappers to simplify our reporting <a id="_idIndexMarker353"/>of <span class="No-Break">our results.</span></p>
			<p>Let us look at a <span class="No-Break">failing assertion:</span></p>
			<pre class="source-code">
await LoginPage.open();
await expect(browser).toHaveUrlContaining('the-internet.herokuapp.com/bogus')
[chrome 110.0.0.0 win32 #0-0] Error: Expect window to have url containing "the-internet.herokuapp.com/bogus"
<strong class="bold">Expected</strong>: "the-internet.herokuapp.com/bogus"
<strong class="bold">Received</strong>: "https://the-internet.herokuapp.com/login"
[chrome 110.0.0.0 win32 #0-0] error properties: Object({ matcherResult: Object({ pass: false, message: 'Expect window to have url containing
[chrome 110.0.0.0 win32 #0-0]
[chrome 110.0.0.0 win32 #0-0] Expected: "the-internet.herokuapp.com/bogus"
[chrome 110.0.0.0 win32 #0-0] Received: "https://the-internet.herokuapp.com/login"' }) })
[chrome 110.0.0.0 win32 #0-0] Error: Expect window to have url containing
[chrome 110.0.0.0 win32 #0-0] Expected: "the-internet.herokuapp.com/bogus"
[chrome 110.0.0.0 win32 #0-0] Received: https://the-internet.herokuapp.com/login</pre>			<p>Now we are over-reporting as we had one validation. The error was reported three times to the output, and that is <span class="No-Break">a problem.</span></p>
			<p>There is one problem – all of these assertion packages are designed to perform a hard expect ending the test execution, not a soft expect that will allow the test to perform <span class="No-Break">more validations:</span></p>
			<pre class="source-code">
Spec Files:      0 passed, 1 failed, 1 total (100% completed) in 00:00:06</pre>			<p>Notice it takes 6 <a id="_idIndexMarker354"/>seconds for the validation to fail. Do we really need to wait that <a id="_idIndexMarker355"/>much time? We already have the <strong class="source-inline">pageSync()</strong> method consuming all the <span class="No-Break">time needed.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor172"/>Timeout – delay of game</h1>
			<p>The default timeout for a WebdriverIO <strong class="source-inline">expect</strong> matcher is 3 seconds and the interval is 100 ms. That is 30 checks over 3 seconds, which<a id="_idIndexMarker356"/> is far better than waiting 30 seconds as is the industry standard. Remember we are using the <strong class="source-inline">pageSync()</strong> method to burn the time that the page uses to build. It makes sense that our assertions should be available almost immediately. To adjust the timeout and interval of the <strong class="source-inline">expect-webdriverio</strong> assertion, we can make a change in the WebdriverIO hooks section of the <span class="No-Break"><strong class="source-inline">wdio.config.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
before: function (capabilities, specs){
require('expect-webdriverio').setOptions ({wait:5000, interval: 250});
}</pre>			<p>This code will now change our <strong class="source-inline">expect</strong> assertions to be executed 20 times. The wait timeout will be 5 seconds. The check will be performed every <span class="No-Break">1/4 second:</span></p>
			<p><strong class="source-inline">Spec Files: 0 passed, 1 failed, 1 total (100% completed) </strong><span class="No-Break"><strong class="source-inline">in 00:00:05</strong></span></p>
			<p>The resulting time is now reduced to an optimal amount. It is just a second, but a little here and there saves minutes <span class="No-Break">and hours.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor173"/>What is expect-webdriverio?</h2>
			<p>For the purpose of this<a id="_idIndexMarker357"/> book, we will be <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">expect-webdriverio</strong></span><span class="No-Break">.</span></p>
			<p>WebdriverIO <a id="_idIndexMarker358"/>uses the <strong class="source-inline">expect-webdriverio</strong> assertion library, which is an extension of the Jest <strong class="source-inline">expect</strong> interface. It adds browser and <span class="No-Break">element assertions:</span></p>
			<pre class="source-code">
const expect = require('expect-webdriverio');
describe('My App', () =&gt; {
  it('should have the correct title', () =&gt; {
    browser.url('https://example.com');
    expect(browser).toHaveTitle('Example Domain');
  });
});</pre>			<p>However, all these <a id="_idIndexMarker359"/>libraries are missing the ability to execute a soft assertion. For that, we turn to Chai and the <span class="No-Break"><strong class="source-inline">soft-assert</strong></span><span class="No-Break"> package.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor174"/>What are hard and soft expect assertions?</h1>
			<p>By default, all of the<a id="_idIndexMarker360"/> assertion packages perform a <strong class="bold">hard expect assertion</strong>, which is more commonly known as a <strong class="bold">hard assert</strong>. This means that when an assertion fails, the test ends. What<a id="_idIndexMarker361"/> kind of superhero leaves the fight after the first punch? This is problematic as we might have four or five values on a single page that we want to assert. What is the point of failing on the first assertion and leaving the next four out of the results? We want the power to continue the fight even if we take one to the chin along <span class="No-Break">the way.</span></p>
			<p>That is why we strive to add the ability of a <strong class="bold">soft expect</strong> (more commonly known as <strong class="bold">soft assert</strong>) into the framework. This<a id="_idIndexMarker362"/> feature is built into Java’s TestNG. It seems a shame that it is missing from all the popular JavaScript assertion libraries. If the buttons exist for navigation, the best testing frameworks will be able to get to the end point and have all validations executed, no matter whether they pass or fail. That is our ultimate dual goal: more results in our report and less repetitious <span class="No-Break">piecemeal runs.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor175"/>Putting it all together</h2>
			<p> Now, we need to protect our identities; to accomplish this feat, we use <strong class="source-inline">expect-webdriverio</strong>, which <a id="_idIndexMarker363"/>extends the Chai <span class="No-Break"><strong class="source-inline">expect</strong></span><span class="No-Break"> interface.</span></p>
			<p>We can now perform a failing soft assertion on our <strong class="bold">Bogus</strong> button and still allow the next assertions <span class="No-Break">to execute:</span></p>
			<pre class="source-code">
const btnBogus = $('button[name="Bogus"]');
softexpect(btnBogus.isEnabled()).to.be.true;
const btnAddToCart = $('button[name="Add To Cart"]');
softExpect(btnAddToCart.isEnabled()).to.be.true;
expect(addToCartButton.isClickable()).to.be.clickable;</pre>			<p>We have our power rings. When we smash them together, we will take on multiple forms, as a helper <strong class="source-inline">expectAdv()</strong> wrapper will be used to increase the flexibility in the amount of detail being provided in a consistent format. This section will take us beyond generic fail messages and detail the pass results with the least amount of <span class="No-Break">repeated code.</span></p>
			<p>The <strong class="source-inline">expect-webdriverio</strong> library supports 23 different element matcher assertions. Eight are substring matchers of other full-string assertions. Others, such as <strong class="source-inline">.toBePresent</strong>, <strong class="source-inline">.toHaveChildren</strong>, and <strong class="source-inline">.toBeDisplayedInViewPort</strong>, are in the lesser part of the <span class="No-Break">80/20 relevancy.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor176"/>What are soft assertions and why would we need them?</h2>
			<p>An efficient test<a id="_idIndexMarker364"/> will be able to perform multiple validations on a page, but if the first of three assertions fail, the test will immediately end. Maybe only the first assertion is failing, or maybe all three. We want the full count of assertions, not the least. Otherwise, it becomes a piecemeal process and slows <span class="No-Break">us down.</span></p>
			<p>Note that <strong class="source-inline">Expect.toBeExist</strong>, <strong class="source-inline">Expect.toBePresent</strong>, and <strong class="source-inline">Expect.toBeExisting</strong> only mean the element is in the DOM. They do not explicitly mean the element is visible to the user, so they are, for the most <span class="No-Break">part, impractical.</span></p>
			<p>WebdriverIO provides positive<a id="_idIndexMarker365"/> and negative checks of the status <span class="No-Break">of elements:</span></p>
			<pre class="source-code">
Expect.toBeDisplayed
Expect.toBeFocused
Expect.toBeEnabled
Expect.toBeDisabled
Expect.toBeClickable
Expect.toBeChecked
Expect.toBeSelected</pre>			<p>It also provides two ways to check whether an element contains text or <span class="No-Break">a value:</span></p>
			<pre class="source-code">
Expect.toHaveText / Expect.toHaveTextContaining
Expect.toHaveValue / Expect.toHaveValueContaining</pre>			<p>It also provides validations of IDs, elements, and attributes, which can be exact or <span class="No-Break">string subsets:</span></p>
			<pre class="source-code">
Expect.toHaveElementProperty
Expect.toHaveAttribute
Expect.toHaveAttributeContaining
Expect.toHaveElementClass
Expect.toHaveElementClassContaining
Expect.toHaveId
Expect.toHaveLink / Expect.toHaveLinkContaining</pre>			<h2 id="_idParaDest-127"><a id="_idTextAnchor177"/>Soft asserts – allowing a test to continue after an assertion fails</h2>
			<p>In our custom <strong class="source-inline">expectAdv</strong> wrapper, we<a id="_idIndexMarker366"/> will implement a few concepts that allow it to be read similarly to a plain English sentence. The first parameter, <strong class="source-inline">actual</strong>, is intentionally assigned the <strong class="source-inline">any</strong> type. This is because we want the flexibility to validate either an element or a <span class="No-Break">string value:</span></p>
			<pre class="source-code">
function expectAdv(
actual: any,
assertionType: string,
expected?: any,
Description: string = 'A description of this assertion is recommended.')
}</pre>			<p>Here, <strong class="source-inline">assertionType</strong> is a string that indicates the assertion to perform. An element might <em class="italic">exist</em>; the element might <em class="italic">equal</em> an <span class="No-Break">expected string.</span></p>
			<p>The expected argument is optional as it would not be required if an element “<span class="No-Break">is enabled”.</span></p>
			<p class="callout-heading">Quick tip</p>
			<p class="callout">The description is required. Every validation should have some detail about what is being performed. Thus, if it is missing, a helpful nudge to add transparency to our test case <span class="No-Break">is provided.</span></p>
			<p>In the case of a soft assertion, the method returns a Boolean <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> value. This means our test cases can be optimized with decision trees. This concept will be used in a later chapter when we discuss how to have steps that continue without failure even if the element does <span class="No-Break">not exist.</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor178"/>Introduction to Allure reports</h1>
			<p>Allure is a powerful reporting framework that presents concise and well-organized reports. You can access this <a id="_idIndexMarker367"/>report template by installing the <strong class="source-inline">@wdio/allure-reporter</strong> and <span class="No-Break"><strong class="source-inline">allure-commandline</strong></span><span class="No-Break"> packages:</span></p>
			<pre class="console">
&gt; yarn add @wdio/allure-reporter</pre>			<p>Allure exports reports in a standardized format called Allure results format. To generate comprehensive reports, you can utilize the Allure framework through the <span class="No-Break">command-line interface:</span></p>
			<pre class="console">
"node_modules/.bin/allure generate --clean ./reports/allure-results &amp;&amp; allure open -p 5050"</pre>			<p>The Allure Framework is a versatile and lightweight test reporting tool supporting multiple programming languages. It provides a succinct presentation of test results in HTML format, empowering all stakeholders in the development process to extract valuable insights from <a id="_idIndexMarker368"/>routine <span class="No-Break">test executions:</span></p>
			<pre class="source-code">
<strong class="bold">// Code example using expect-webdriverio</strong>
export async function expectAdv(actual, assertionType, expected) {
  const softAssert = expect;
  const getAssertionType = {
    equals: () =&gt; (softAssert(actual).toEqual(expected)),
    contains: () =&gt; (softAssert(actual).toContain(expected)),
    exist: () =&gt; (softAssert(actual).toBeExisting()),
    isEnabled: () =&gt; (softAssert(actual).toBeEnabled()),
    isDisabled: () =&gt; (softAssert(actual).toBeDisabled()),
    doesNotExist: () =&gt; (softAssert(actual).not.toBeExisting()),
    doesNotContain: () =&gt; (softAssert(actual).not.toContain(expected)),
    default: () =&gt; (console.info('Invalid assertion type:  ', assertionType)),
  };
  (getAssertionType[assertionType] || getAssertionType['default'])();
  if (!getAssertionType[assertionType]){
    allureReporter.addAttachment('Assertion Failure: ', `Invalid Assertion Type = ${assertionType}`, 'text/plain');
    allureReporter.addAttachment('Assertion Error: ', console.error, 'text/plain');
  } else {
    allureReporter.addAttachment('Assertion Passes: ', `Valid Assertion Type = ${assertionType}`, 'text/plain');
 }
  allureReporter.endStep();
}</pre>			<p>By adding these Allure<a id="_idIndexMarker369"/> statements into our framework, we can provide significantly more detail to stakeholders in a way that is <span class="No-Break">visually informative.</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B19395_08_2.jpg" alt="Figure 8.2: Samples of test results in Allure with historical trends"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Samples of test results in Allure with historical trends</p>
			<p>Allure reports can organize tests into subcategories. This makes it clear whether related tests are failing. It also shows how the runs have been performing over time. This can show both an increase in test case coverage as well trends where results are improving or <span class="No-Break">recently worsening.</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B19395_08_3.jpg" alt="Figure 8.3: Sample of step-by-step execution with a screen capture of the Login page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: Sample of step-by-step execution with a screen capture of the Login page</p>
			<p>These reports also <a id="_idIndexMarker370"/>provide the option to add screen captures such as X-ray vision. This can give vital clues as to what is occurring when the test fails, particularly if we are running in the cloud without a direct live view into the system as <span class="No-Break">it runs.</span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor179"/>Summary</h1>
			<p>In this section, we talked about the history of assert, expect, and should assertions. We introduced the concepts of hard and soft assertions, why they are important distinctions, and when they should be implemented. We also introduced Allure reports to provide details of all events being executed and the results of whether they pass or fail. Allure reports will further enhance our view in the future by providing a historical view of tests that pass and fail. In the next chapter, we'll build the page <span class="No-Break">object model.</span></p>
		</div>
	</body></html>