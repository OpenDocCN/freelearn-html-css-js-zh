- en: Chapter 5. CoffeeScript and Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ryan Dahl created Node.js in 2009\. His goal was to create a system with which
    one can write network server applications having high performance, using JavaScript.
    At that time, JavaScript was mostly run inside browsers, so a server-side framework
    needed some way to run JavaScript without it. Node uses Google's V8 JavaScript
    engine, originally written for the Chrome browser, but since it's a separate piece
    of software, it can run JavaScript code anywhere. Node.js lets you write JavaScript
    code that can be executed on the server. It can make full use of your operating
    system, databases, and other external network resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about some of the features of Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Node is event-driven
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node.js framework only allows non-blocking, asynchronous I/O. This means
    that any I/O operation that is accessing an external resource, such as the operating
    system, a database, or a network resource must happen asynchronously. This works
    by using events, or callbacks that are fired once the operation succeeds or fails.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this is that your application becomes much more scalable, because
    requests don't have to wait around for slow I/O operations to finish and can instead
    handle more incoming requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Similar frameworks do exist in other languages, such as **Twisted** and **Tornado**
    in Python, and **EventMachine** in Ruby. A big problem with these frameworks is
    that all I/O libraries they use must also be non-blocking. Often, one can end
    up accidentally using code that blocks an I/O operation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Node.js was built from the ground up with an event-driven philosophy and only
    allows non-blocking I/O, thus avoiding this problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Node is fast and scalable
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The V8 JavaScript engine used by Node.js is highly optimized for performance,
    thus making Node.js applications very fast. The fact that Node is non-blocking
    will ensure that your applications will be able to handle many concurrent client
    requests without using a lot of system resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Node is not Rails
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Node and Rails are often used to build similar types of applications,
    they are in fact, quite different. Rails strives to be a full-stack solution to
    building web applications, whereas Node.js is more of a low-level system for writing
    any type of fast and scalable network application. It does not make a lot of assumptions
    on how your application should be structured at all, except for the fact that
    you'll use an event-based architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, Node developers often choose from a variety of frameworks and
    modules that have been built on top of Node for writing web applications, such
    as Express or Flatiron.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Node and CoffeeScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen before, CoffeeScript is available as an npm module. Therefore,
    writing Node.js applications with CoffeeScript couldn't be much easier. In fact,
    the `coffee` command that we discussed earlier will run `.coffee` scripts using
    Node by default. To get Node installed with CoffeeScript, see [Chapter 2](ch02.html
    "Chapter 2. Running CoffeeScript"), *Running CoffeeScript*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '"Hello World" in Node'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write the simplest Node app we can using CoffeeScript. Create a file
    named `hello.coffee` and enter the following code in it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This uses the `http` module of Node.js, which provides capabilities for building
    an HTTP server. The `require('http')` function will return an instance of the
    `http` module, which exports a `createServer` function. This function takes a
    `requestListener` argument, which is a function that will respond to client requests.
    In this case, we respond with an HTTP status code `200` and end the response with
    `Hello World` as the request body. Finally, we call the `listen` method on the
    returned server to start it up. When this method is called, the server will listen
    for and handle requests until we stop it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this file with the coffee command, as shown in the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can test our server by browsing to `http://localhost:8080/`. We should see
    a simple page with only the text as **Hello World**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Express
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, Node out of the box is very low-level and bare-boned. Building
    web applications basically means writing a raw HTTP server. Luckily, a bunch of
    libraries has been developed over the last few years to help out with writing
    web applications on Node and to abstract away a lot of the low-level details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, the most popular of these is **Express** ([http://expressjs.com/](http://expressjs.com/)).
    Similar to Rails, it has quite a lot of nice features that make it easier to perform
    common web application tasks, such as routing, rendering views, and hosting static
    resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be writing a web application in Express using CoffeeScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since I would like to show off some of the scalability features of Node and
    the types of applications that it's normally used for, we'll be making use of
    another interesting modern web technology, known as **WebSocket**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket protocol is a standard for allowing raw, bi-directional, and full-duplex
    (simultaneous in both directions) TCP connections over the standard HTTP port
    **80**. This allows for a client and server to establish a long-running TCP connection
    with which the server can perform push operations, which has traditionally not
    been possible with HTTP. It is often used in applications where there needs to
    be lots of low-latency interaction between the client and server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Jade
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jade is a lightweight, markup templating language that lets you write elegant
    and short HTML in a syntax that closely resembles CoffeeScript. It uses quite
    a few features such as syntactical whitespace to reduce the number of keystrokes
    you need to write HTML documents. It is usually installed by default when you
    run Express, and we'll be using it in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Our application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to build a collaborative to-do list application.
    This means that you'll be able to share your to-do list with other people in real
    time. One or more people will be able to add, complete, or remove to-do list items
    at the same time. Changes to the to-do list will be automatically propagated to
    all users. This is the type of application that Node is perfect for.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Our Node.js code will consist of two distinct parts, the normal web application
    that will serve static HTML, CSS, and JavaScript, and a WebSocket server that
    handles the real-time updating of all the to-do list clients. Together with this,
    we'll have a jQuery-driven client that will look very similar to our application
    in [Chapter 3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript
    and jQuery*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We'll use some of the assets (stylesheets and images) from our existing to-do
    list applications. We'll also re-use the client-side jQuery code from [Chapter
    3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript and jQuery*
    and tweak it to fit our application. If you weren't following along in the previous
    chapters, you should be able to just copy assets from the code for this chapter
    as needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get going, we''ll do the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for our application.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify our app dependencies using a `package.json` file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install our dependencies.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `app.coffee` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run our app for the first time.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: package.json
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new folder named `todo`. Inside this folder, we''ll create a file
    with the name `package.json`. Add the following code to this file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple JSON file that serves as an application manifest and is used
    to tell npm which dependencies you rely on in your application. Here, we're using
    Express as our web framework and Jade as our templating language. Since we're
    going to use WebSocket, we'll pull in `socket.io`. We can also make sure that
    CoffeeScript is installed by adding it to our file. Lastly, we'll use `connect-assets`,
    a module that manages client-side assets in much the same way as the Rails asset
    pipeline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with the Node.js framework, you'll notice that applications are
    often weaved together out of npm modules in this manner. A good place to look
    for npm modules is the Node toolbox site ([nodetoolbox.com](http://nodetoolbox.com)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Installing our modules
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the dependencies in our `package.json` file, navigate to the project
    folder on the command-line tool and run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If all went well, then we should now have all our project dependencies installed.
    To verify this or just to see what npm did, you can run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will output a list of installed modules with their dependencies in a tree-like
    format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All we need to run our application is to create a main, entry point file, which
    is used to hook up our Express application and specify our routes. In the root
    folder, create a file named `app.coffee`, and add the following code to it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks very similar to our "Hello World" example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: First, we load the Express module using the `require` function. Node modules
    are simple; each module corresponds to a single file. Each module can declare
    code, which will be exported when it is required. When you call `require`, and
    the module's name is not that of a native module or a file path, Node will automatically
    look for the file in the `node_modules` folder. This is of course where npm installs
    modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: On the next line, we create our Express app by calling the `express` function
    and assigning it to an `app` variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We then create an index route for our application using the `get` method. We
    specify the path to be `'/'` and then pass in an anonymous function to handle
    the request. It takes two parameters, the `req` and `res` parameters. Right now,
    we just write `Hello Express` to the response and return.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: We then start our app using the `listen` method and tell it to run on port `3000`.
    Lastly, we write to the standard output so that we'll know the app has started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Express magic comes in with setting up routes declaratively.
    With Express you can easily create routes by specifying an HTTP method, URL path,
    and a function to handle the request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run our application to see if everything worked. Inside our app folder,
    type the following on the command-line tool:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see the output as **Listening on port 3000**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Point your browser to `http://localhost:3000/`. You should see the text **Hello
    Express**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To stop the Node process on the command-line tool, just use *Ctrl* + *C*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to other web frameworks such as Rails, Express has the concepts of views,
    which let you separate your UI from your application using separate files. Usually,
    these are written using a templating language such as Jade. Let's create a view
    for our root action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll need to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Create a `views` folder and add a Jade view file.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure our Express application to be aware of a folder where the views will
    be stored, and which templating library we're using.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change our index route to render our view.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a new folder in our project root called `views`. Inside this
    folder, we create a new file named `index.jade`. This is how it should look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, Jade offers a very clean and terse syntax for normal HTML. You
    don't have enclosing tags in angle brackets. Similar to CoffeeScript, it also
    uses indentation to delimit blocks, so that you don't have to enter closing tags.
    The line `p= message` creates a `<p>` tag whose contents will be evaluated to
    be the value of the `message` field, which should be passed into our view options.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `app.coffee` file, we''ll add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we set the `views` folder using the `set` function and assigning the `'views'`
    key. We use the `path` module that we included at the top of the file to create
    and join our current folder name to the `views` subfolder. `__dirname` is a global
    variable that refers to the currently working folder. We also set the view engine
    to `'jade'`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we change our `get '/'` route to render the index template and pass
    in a hash of options, containing the message. This is the value that then gets
    rendered in our view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Once we run our application again and refresh the page, we should now see that
    our page has been updated with the new text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: node-supervisor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you might be wondering if you'll need to restart our Node application
    each time we make a change to our code. Ideally in development, we would like
    our code to be reloaded automatically each time we make a change, similar to how
    it works in Rails.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a neat, open source library that we can use that does exactly
    that: **node-supervisor** ([https://github.com/isaacs/node-supervisor](https://github.com/isaacs/node-supervisor)).
    We install it like any other npm module, we just make sure to pass the `-g` flag
    to install it globally, as shown in the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the terminal, you should now be able to run the supervisor by using the
    following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Keep this process running in a separate window. To see if this worked, let''s
    edit our message that gets sent to our view; the edited message is highlighted
    in the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we now refresh our page, we'll see that it has been updated. From here on,
    we can make sure to keep the supervisor running and we shouldn't need to restart
    our Node process to make changes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The to-do list view
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s expand our view to look like our real to-do application. Edit the
    `index.jade` file to look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is some new Jade syntax that we haven''t seen before. Tag IDs are denoted
    by the `#` symbol, so `header#header` becomes `<header id="header">`. Tag attributes
    are specified within brackets, like so: `tag(name="value")`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re not using the `message` variable in our template anymore, we''ll
    remove it from our `render` call in the `app.coffee` file, as shown in the following
    code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our page will now be updated, but it won't look too good. We'll use the same
    stylesheet that we used in the previous project to style our page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Not working as expected?**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Remember to keep an eye on the output of the supervisor process to see if you
    have any syntax errors in your CoffeeScript or Jade template, especially if you're
    not seeing the expected output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we use the stylesheet, we need to set up Express to serve static files
    for us. Modify the `app.coffee` file to look like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So what's happening in the previous code snippet? We've added support for serving
    static files in a single line, but how does this work? The answer lies in how
    Node uses middleware.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Express framework is built on top of a lower-level framework called **Connect**
    ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)). The
    basic idea of Connect is to provide middleware for web requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Middleware can be chained together to produce a web application stack. Each
    piece of middleware is only concerned in providing a small set of functionality
    by modifying the output response or the control flow of the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we tell our application to use the middleware created by the
    `express.static` function. This function will create a static file server for
    the provided file path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Our stylesheet
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a folder named `public` with a subfolder named `css`. Save the stylesheet
    as `todo.css` in this folder. We still need to include the stylesheet in our `index`
    view. Add the following line—highlighted in the code snippet—to the `index.jade`
    file in the `views` folder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have linked to our stylesheet, we should be able to refresh our view.
    It should now look much nicer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The client side
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our to-do application work, we're going to copy the client-side jQuery
    code that we created in [Chapter 3](ch03.html "Chapter 3. CoffeeScript and jQuery"),
    *CoffeeScript and jQuery*. We're going to put it in a file named `todo.coffee`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Our next decision is, where shall we put this file? How will we compile and
    use its output in our application?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We could do the same thing as we did when we built our application in [Chapter
    3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript and jQuery*,
    that is, create a `src` folder containing the client-side offeeScript code, then
    compile it using the `coffee` command with the `--watch` flag. The outputted JavaScript
    could then go in our `public` folder where we can include it as normal. But this
    would mean we would have two separate background tasks running, the supervisor
    task for running our server and another for compiling our client-side code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Luckily there is a better way. You might recall that we had a reference to the
    `connect-assets` module in our `package.json` file. It provides us with an asset
    pipeline that is very similar to what you get in Rails. It will take care of compilation
    and dependency management transparently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to use the middleware in our `app.coffee` file, as highlighted
    in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `connect-assets` module will, by default, use the `assets` folder to manage
    and serve assets from. Let''s create a folder named `assets/js` inside our root
    folder. We''ll create a new file in this folder named `todo.coffee`, containing
    the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you were following along in [Chapter 3](ch03.html "Chapter 3. CoffeeScript
    and jQuery"), *CoffeeScript and jQuery*, then this code should be familiar. It's
    our complete, client-side application that displays to-do items and creates, updates,
    and destroys items in `localStorage`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: To use this file in our HTML we still need to include a `script` tag. Since
    we're using jQuery, we'll also need to include the library in our HTML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the bottom of the `index.jade` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we include a link to jQuery using the Google CDN. We then use
    the `js` helper function, which is provided by `connect-assets`, to create a `script`
    tag that points to our compiled `todo.js` file (the `connect-assets` module will
    have compiled our CoffeeScript transparently). The `!=` notation is Jade's syntax
    for running a JavaScript function along with its result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: If all went well, we should be able to refresh the page and have a working,
    client-side page for our app. Try adding new items, marking items as complete,
    deleting items, and clearing completed items.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Adding collaboration
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're ready to add collaboration to our to-do list application. We need
    to create a page where multiple users can connect to the same to-do list and can
    edit it simultaneously, seeing the results in real time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: We would like to support the idea of named lists, which you can join with others
    to collaborate on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the functionality, let's tweak our UI a bit to support all
    of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Creating the collaboration UI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we'll add an input field to specify a list name and a button to join
    the specified list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes (highlighted in the code snippet) to our `index.jade`
    file, which will add an `input` element and a `button` element to specify our
    list name and join it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our page should now look like the page displayed in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the collaboration UI](img/9588_05_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: WebSocket on the client
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's add an event handler to connect to a room when the user clicks the
    **Join** button.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `todo.coffee` file, we''ll add the following code to our `cacheElements`
    and `bindEvents` functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We grab the `join-list-name` input and `join` button elements and store them
    in two instance variables. We then set up the `click` handler on the `@$join`
    button to call a new function called `joinList` . Let''s go ahead and define this
    function now. Add it to the end of the class after the `bindEvents` function is
    defined:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is where we start to use Socket.IO. The Socket.IO library comes in two
    parts: the client-side library for opening a WebSocket connection, making requests,
    and receiving responses, as well as the server-side node module for handling the
    requests.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the `joinList` function opens a new socket using the
    `io.connect` function and passing in the URL. It then uses the `on` function to
    pass a handler function that will run after the WebSocket connection has been
    made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The successful connection handler function will in turn use the `socket.emit`
    function, which allows us to send a custom message to the server using `joinList`
    as the identifier. We pass the value of the `@joinListName` input as its value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start implementing the server-side code, we still need to include
    a `script` tag to use the `socket.io` client library. Add the following highlighted
    `script` tag at the bottom of the `index.jade` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might be wondering where this file comes from. Next, we'll set up the Socket.IO
    middleware in our `app.coffee` file. This will host the client-side library for
    us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket on the server
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our client-side code ready to make WebSocket requests; now we can move
    on to our Node backend. First, we'll need to set up our Socket.IO middleware.
    There is a small caveat to this, in that we cannot use Socket.IO as a middleware
    of the Express application directly, since Socket.IO expects a Node.js HTTP server
    and has no direct support for Express. Instead, we'll create a web server using
    the built-in Node.js HTTP module, passing our Express application as `requestListener`
    . We can then use the `listen` function in Socket.IO to connect to the server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the code looks in our `app.coffee` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `io.sockets.on 'connection'` function handles the event when a client connects.
    Here, we log to the console that we're connected to and then set up the `joinList`
    message handler. Right now, we'll just log the value that we receive from the
    client to the console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now be able to test connecting to a list. Refresh our to-do list
    home page and enter a list name to join. After you clicked the **Join** button,
    head over to our background supervisor task. You should see something similar
    to the following message:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**connected**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Joining list Michael''s List**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: It worked! We've successfully created a bi-directional WebSocket connection.
    We still haven't really joined a list so far, so let's go ahead and do that now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Joining a list
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To join a list, we'll use a feature of Socket.IO called **rooms** . It allows
    the Socket.IO server to segment its clients and emit messages to subsets of all
    the connected clients. On the server, we'll keep track of the to-do lists of each
    room and then tell the client to sync its local list when connected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll update the `app.coffee` file with the highlighted code shown in the
    following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We initialize the `@todos` instance variable to be an empty hash. It will hold
    the to-do lists for each room, using the list name as a key. In the `joinList`
    handler function, we set the `list` property of the `socket` variable to equal
    the list name that the client passed in.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `socket.join` function that will join our list to a room with
    that name. If the room doesn't exist yet, it will be created. We then assign an
    empty array value to the item in `@todos` with the key equal to `list`. The `?=`
    operator will only assign the value on the right-hand side to the object on the
    left-hand side if it's `null`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we send a message to the client using the `socket.emit` function. The
    `syncItems` identifier will tell it to sync its local data with the to-do list
    items that we're passing it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the `syncItems` message, we''ll need to update the `todo.coffee`
    file with the following highlighted code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After joining a list, we set up our client connection to handle the `syncItems`
    message. We expect to receive all the to-do items for the list that we have just
    joined. The `syncItems` function will clear all the current items in `localStorage`,
    add all the new items, and then display them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The UI
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, let''s update our UI so that the user will know when they''ve joined
    a list and let them leave it. We''ll modify our `#footer div` tag as follows in
    our `index.jade` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous markup, we've added two new sections to our `footer div` tag.
    Each section will either be hidden or visible depending on which state we are
    in, `connected` or `disconnected` from a list. The `connect` section is the same
    as before. The `disconnect` section will display which list you are currently
    connected to and has a **Leave** button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll add code to our `todo.coffee` file to update the UI when a list is
    joined.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll cache the new elements in our `cacheElements` function, as highlighted
    in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we''ll change the UI to display that we''re in a `connected` state when
    `syncItems` have been called (which gets fired by the server after successfully
    joining a list). We use the `@currentList` function, which we''ll set in the `joinList`
    function; add the code highlighted in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `displayConnected` function will just hide the `connect` section and show
    the `disconnect` section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Leaving a list
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leaving a list should be quite easy. We disconnect the current socket connection
    and then update the UI.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the `disconnect` action when a button is clicked, we add a handler
    in our `bindEvents` function, as shown in the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the handler we''ve added will just call a `leaveList` function.
    We still need to implement it. Add the following two functions to the end of the
    class after the last function defined in our `TodoApp` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing it all
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s test our list joining and leaving code. To see it all in action,
    follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've joined a list, add a few to-do items.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the site again, this time using a second browser. Since `localStorage`
    is unique to a browser, we do this to have a clean list of to-do items.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the list is synced, you should now see the list items you've added in before
    showing up.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, disconnect from a list using the **Leave** button.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Testing it all](img/9588_05_02.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Two lists synced from different browsers
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: This is great! We can now see the power of WebSockets in action. Our client
    is notified when it should sync items without having to poll the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: However, once we're connected to the list, we still cannot add new items to
    have them show up in all the other clients in the room. Let's implement that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Adding to-do items to a shared list
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll handle adding new items on the server. The best place to handle
    this would be in the existing `create` function for creating to-do items. Instead
    of just adding them to `localStorage`, we''ll also emit a message to the server
    telling it that a new to-do item has been created, and pass it as a parameter.
    Modify the `create` function to look like the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We need to handle the `newItem` message on the server. We'll set up the code
    to do so when a client joins a list, in `app.coffee`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `joinList` event handler that we added before; add the highlighted
    code in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code snippet, we set up yet another `socket` event when a user joins
    a list. In this case, it's for the `newItem` event. We add the new to-do item
    to our `@todos` array using the `push` function. Then we emit a new `itemAdded`
    message to all the clients in the current list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: What will happen with this `itemAdded` message? You guessed it; it will get
    handled in the client again. This kind of back and forth messaging is very common
    in WebSocket applications and does take some getting used to. Don't fret though;
    it gets easier once you get the hang of it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile let''s handle the `itemAdded` event on the client. We also set up
    this code in our `joinList` method by adding the highlighted code in the following
    code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We handle the `itemAdded` event by calling `localStorage.setObject` with the
    item ID and value. This will either create a new to-do item if it's not present
    in `localStorage`, or it will update the existing value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s it! We should now be able to add items to all the clients in the
    list. To test it, we''ll follow similar steps to what we did earlier:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the site again, this time using a second browser.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add new to-do items in either browser. You'll see the to-do items appear in
    the other browser immediately.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wow! Isn't this impressive?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Removing to-do items from a shared list
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove to-do items from a shared list, we''ll follow a similar pattern to
    adding items. In the `destroy` function in `todo.coffee`, we''ll emit a `removeItem`
    message to our socket to let the server know that a item should be removed, as
    shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once again, we set up the server-side code to handle this message by removing
    the item from the shared list in memory, and then notify all clients connected
    to the list that the item has been removed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `removeItem` socket event handler gets the ID of the to-do item to remove
    the task passed into it. It removes the to-do item from the list by assigning
    the current value of the shared list to a new value that we create using JavaScript's
    array `filter` function. This will select all the items that don't have the passed
    ID. It then calls `emit` on all the client socket connections in the shared list
    with the `itemRemoved` message.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we''ll need to handle the `itemRemoved` message in our client. Similar
    to when we added items, we''ll set this up in the `joinList` function in `todo.coffee`,
    as shown in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We remove the item from `localStorage` and update the UI.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'To test removing items, follow these steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've connected to the shared list, add a few to-do items.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the site again, this time using a second browser.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**. Your to-do list will be synced with the shared list and will contain
    the items that you have added in the other browser.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the remove icon to delete to-do items in either browser. You'll see the
    deleted to-do items disappear in the other browser immediately.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it's your turn
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final exercise to you, I will ask you to make the **Clear completed** button
    work. As a hint, you should be able to use the existing `destroyItem` method functionality.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed our tour of the CoffeeScript ecosystem by exploring
    Node.js as a fast, event-driven platform that lets you use JavaScript or CoffeeScript
    to write server applications. I hope that you have been given a glimpse of the
    joy of being able to write web applications using CoffeeScript on the server as
    well as in the browser at the same time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We also spent some time with some of the wonderful open source libraries and
    frameworks that have been written for Node.js, like expressjs, connect, and Socket.IO
    and have seen how we can successfully use npm to manage dependencies and modules
    in our applications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Our sample application was exactly the kind of thing that you would use Node.js
    for, and we saw how its event-driven model lends itself to writing applications
    where there are lots of constant interactions between the client and server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've come to an end to our journey, I hope to have instilled in you
    the eagerness and skills to go out and use CoffeeScript to change the world. We've
    spent some time exploring not just the language but also the wonderful tools,
    libraries, and frameworks that enable us to develop powerful applications more
    rapidly using less code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经结束了这段旅程，我希望我已经在你心中种下了渴望和技能，让你能够走出并使用 CoffeeScript 改变世界。我们花了一些时间探索的不仅仅是语言，还有那些奇妙的工具、库和框架，它们使我们能够用更少的代码更快地开发出强大的应用程序。
- en: The future of CoffeeScript and the JavaScript ecosystem is bright, and hopefully
    you'll be a part of it!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 和 JavaScript 生态系统的未来光明，希望你们能成为其中的一员！
