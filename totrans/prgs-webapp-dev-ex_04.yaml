- en: Service Workers – Notification, Synchronization, and Our Podcast App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d), *Introduction
    to Progressive Web Apps*, you read about how the web has fallen short in the mobile
    era and why progressive web applications can level your website to equal or even
    better capabilities than native options. Service workers are the most important
    part of a progressive web application because they are the application's backbone.
  prefs: []
  type: TYPE_NORMAL
- en: The web manifest and the home screen icon enhance the ability to develop a relationship
    with the customer and control the launch experience. Service workers enable a
    programmatic user experience enhancement when a page is loaded and even when it
    isn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service workers sit between the browser and the network and act as a proxy
    server. They provide more than just a caching layer; they are an extensible backbone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.gif)'
  prefs: []
  type: TYPE_IMG
- en: For the coder, **service workers** are JavaScript files, making them familiar
    to most web developers. These scripts are more like Node.js modules than a web
    page script. They execute on a separate thread from the UI service workers, so
    they do not have access to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker programming model is more functional than what you might
    use for the user interface. The node comparison makes sense in that the service
    worker programming is headless and used to perform calculations, with many tasks
    being traditionally reserved for the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers also differ from UI scripts because they are completely asynchronous.
    This means some APIs, such as XHR and localStorage, are not supported. Instead,
    you should use the Fetch API and **IndexedDB** (**IDB**) to connect with APIs
    and persist data. When a browser supports service workers, they must also support
    promises, providing a natural asynchronous interface.
  prefs: []
  type: TYPE_NORMAL
- en: A note about `XMLHttpRequest`, when initiated from the client the request passes
    through the service worker. You cannot initiate an XHR request from a service
    worker.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers are designed to be an extensible platform, allowing for additional
    APIs to be added over time. Cache is the only extension API that the specification
    details. Native push notifications and background sync are examples of additional
    APIs that are enabled by service workers. In the future, you can expect many more
    APIs to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Caching enables offline and instant asset loading. I think the best term to
    describe this feature is a proxy server in the browser. Advanced service workers
    act almost like a complete web server stack. A well-crafted service worker can
    assume rendering responsibilities currently allocated to ASP.NET, Node Express,
    and Ruby, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: The last chapter covered adding HTTPS to your site. If you were not sold on
    the concept yet, you will be now. Service workers also require SSL. The main reason
    service workers require SSL is to enable APIs and other features requiring a higher
    level of trust.
  prefs: []
  type: TYPE_NORMAL
- en: The power service workers that have been enabled could be used for evil purposes.
    In addition to requiring SSL, they are also limited in scope to a single domain.
    They do not have the ability to manipulate anything outside the scope of the domain
    that hosts the script.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good thing because a third-party script cannot register a service
    worker and do bad things to your site.
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, this may seem simple, but there is an art to mastering service
    workers. The following chapters are designed to give you the foundation needed
    to create service workers that enhance any website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The service worker threading model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service worker browser support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the example podcast application works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the fetch API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a basic service worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service worker life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service worker caching basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use push notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to background sync programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service worker thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers run within their own context or thread outside the UI. Because
    the service worker thread is separate from the UI, it does not have access to
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker scope is event driven, meaning the platform (browser or operating
    system, depending on your point of view) initiates the service worker. When the
    service worker initiates, it does so with the intent of responding to an event,
    such as a web page opening, a push notification, or another event.
  prefs: []
  type: TYPE_NORMAL
- en: The process stays alive long enough to service the need. This time is determined
    by the browser and varies by platform. There is no fixed time defined in the service
    worker specification.
  prefs: []
  type: TYPE_NORMAL
- en: Running in a separate context from the normal JavaScript offers many advantages
    to service workers. The first is that a service worker script does not block the
    UI from rendering. You can use this feature to offload non-UI work to the service
    worker. An example we will see in a later chapter shows how to use client-side
    templating to render markup in the service worker and not the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a way to separate tasks into more appropriate threads. Now, you
    can perform calculations such as math or rendering markup in response to an API
    call and return it to the UI thread to update the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker can communicate with the UI thread through the messaging
    API. You can pass text messages back and forth between threads. You can also modify
    responses from the server before they reach the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Features like push notifications are possible because service workers execute
    in their own context. A service worker can spin up in response to an event triggered
    by the operating system and not because a page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, web-based push notifications have been possible by using web workers.
    These are great tools, but only execute when the browser is open. Service workers
    differ because the operating system can spin them up due to an external stimulus.
    The only real requirement is that the client device should be powered on.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker browser support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Service worker is a relatively new technology, leading to a common question:
    is it safe to use service workers? What we are really asking is, how many browsers
    support service workers?'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is all major browsers have shipped basic service worker support.
    Chrome has been the leader as they have been largely responsible for initiating
    the concept and managing the specification. The technology has received enthusiastic
    support from other browser vendors including Microsoft, FireFox, Samsung, and
    Opera.
  prefs: []
  type: TYPE_NORMAL
- en: As of the Spring of 2018 all modern browsers had shipped updates to general
    consumers with at least service worker caching support. Of course, older browsers
    won't support service workers. But their usage is winding down as consumers upgrade
    phones and laptops.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Edge service worker support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the september 2017 Edge Web Summit, Microsoft announced they were shipping
    service worker support behind a flag. The goal is to flesh out any bugs in the
    implementation before general consumer support ships.
  prefs: []
  type: TYPE_NORMAL
- en: In the Spring of 2018 support for service workers was shipped to general consumers
    with when Windows RS4 was released.
  prefs: []
  type: TYPE_NORMAL
- en: Safari service worker support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not familiar with how Apple announces web API support, they don't.
    New features quietly ship and are left for developers to discover, at least in
    most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a surprise release Apple updated Safari in March 2018 to support service
    workers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are some limitations to Safari service worker support. For now, they do
    not support native push notifications or background sync. I don't consider these
    missing features a reason to avoid integrating them in your applications. Remember
    progressive web apps are about taking advantage of features as they are available.
    You can still create viable work around to these features.
  prefs: []
  type: TYPE_NORMAL
- en: Is the service worker ready?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Jake Archibald* maintains a GitHub site that tracks each mainstream browser''s
    support of service worker-related features ([https://jakearchibald.github.io/isserviceworkerready/](https://jakearchibald.github.io/isserviceworkerready/)),
    called is* service worker Ready.*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The site features rows, focusing on each primary service worker feature and
    their requirements with each browser''s icon. The grayscale browser icons indicate
    that support has not shipped. Icons with a yellow background have shipped partial
    support. A green background indicates full support of the feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see the major browser players all support service workers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all modern browsers support service workers you may think there is
    no reason to work about browsers without service worker support. But there are
    still an important percentage of browser sessions using Internet Explorer and
    legacy Android browsers. This means you may want to consider fallback options.
  prefs: []
  type: TYPE_NORMAL
- en: Polyfilling older browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polyfills are libraries or fallbacks you can reference as needed to add support
    for modern features to browsers lacking support. Not all modern features can't
    be polyfilled, but many can. Some are not direct polyfills, but leveraging other
    APIs to create the desired experience.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you can polyfill a service worker caching to a point.
    This can be done using `IndexedDB`. You will need an extra layer of JavaScript
    to manage the site's assets and API calls. We will touch on this technique in
    the advanced caching chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using `IndexedDB` to cache assets, you can also use `appCache`
    as an offline and asset caching fallback.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications cannot be polyfilled, but you can utilize alternative notification
    mediums. SMS texting and web worker notifications can provide ways for the business
    to engage with customers.
  prefs: []
  type: TYPE_NORMAL
- en: The podcast application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces you to different service worker concepts and features
    like the service worker life cycle, caching, and push notifications. To do this,
    we are going to build a simple podcast application. This application will demonstrate
    how to tackle the service worker life cycle and response caching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal podcast application requirements include:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search podcasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Favorite podcasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist episodes for offline listening
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application requires some server-side help, which for our purposes will
    be a set of snapshot data I took from public sources. The data is part of the
    project repository ([https://github.com/docluv/PWAPodcast](https://github.com/docluv/PWAPodcast)),
    so you can recreate the application.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to register a service worker, the basics of the service worker
    life cycle, how service worker caching works, and how to use `IndexedDB` to persist
    data. You will also see how to utilize service worker cache and `IndexedDB` to
    persist MP3 media files.
  prefs: []
  type: TYPE_NORMAL
- en: The podcast application source code is organized by folders that correlate to
    each chapter's progress. The root folder contains common files to define the Grunt
    tasks to run local web servers, just like the 2048 application.
  prefs: []
  type: TYPE_NORMAL
- en: Inside each chapter's folder there are folders for assets, such as CSS, JavaScript,
    and images. Each route also has a folder with a single `index.html` file. This
    allows the application to use extensionless URLs. The data files are stored under
    the API folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application consists of the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each page is a static page, pre-rendered as part of the site build process.
    The logic behind this is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The application's data comes from the iTunes API. It did require some data manipulation
    to make it usable in the application. I have included the raw data files in the
    GitHub repository if you would like to use or study them.
  prefs: []
  type: TYPE_NORMAL
- en: The Apple data model needs to be transformed for the application. Instead of
    standing up a web server to host a formal API, the data is stored in a series
    of JSON files. The application will reference those files as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker is in the application's root folder. This file is the centerpiece
    of this chapter and we will spend most of our time changing it in each chapter.
    It will demonstrate the service worker life cycle and basic caching concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try the finished version at [https://podcast.love2dev.com](https://podcast.love2dev.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Home page of PWA Podstr
  prefs: []
  type: TYPE_NORMAL
- en: 'The home page contains a list of podcasts that the user is subscribed to. This
    is populated by an API call to retrieve the list. It is then rendered in the browser
    using `Mustache`. All API data is a set of JSON files, so there is no messy code
    needed to connect and stand up a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The podcast page displays details about the podcast and a list of recent episodes.
    The podcast data is also retrieved via an API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The episode page lists the title and description of an episode. It includes
    an AUDIO element that plays the mp3 file. Again, the page is rendered after retrieving
    the data from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Fetch API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Way back in 1996, Internet Explorer introduced the *iframe* element as a way
    to load web content asynchronously in a web page. Over the next two years, the
    concept evolved into the first implementation of what we now know as the `XMLHttpReqest`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Back then, it was known as `XMLHTTP` and was first shipped in Internet Explorer
    5.0\. Soon after, Mozilla, Safari, and Opera all shipped implementations of what
    we now call `XMLHttpRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, web pages were static and required an entire reload when a
    user navigated from one page to another inside the same site.
  prefs: []
  type: TYPE_NORMAL
- en: In 2004, Google started making wide use of what we now call **AJAX** in Gmail
    and Google Maps. They showed us how to leverage in-browser requests to the server
    and how to manipulate the DOM in response to the server's payload. This is typically
    done by calling an API that returns JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: As with any technology, as it is used, **implementers** get frustrated dealing
    with issues revealed through usage. In response to new use cases and issues, the
    technology updates, typically by releasing a new version.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, those updates are so major a new technology, product, or implementation
    replaces the first version.
  prefs: []
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` provides a mechanism to make asynchronous calls to the server,
    but does so based on how the web and browsers worked over a decade ago.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, the web has expanded in many ways. One feature we now have ubiquitous
    support for is JavaScript Promises. We also have deeper insight into what types
    of content can be made using asynchronous calls to a server that we did not think
    about when AJAX was first being specified.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After identifying common limitations of the `XMLHttpRequest` object, the Fetch
    API was standardized to provide a new, better thought out way to implement asynchronous
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch API is a brand new way to make AJAX calls. It was created to solve
    many of the problems we developers hack and work around to handle `XMLHttpRequest`
    limitations. The primary difference is that Fetch is asynchronous when using Promises.
  prefs: []
  type: TYPE_NORMAL
- en: It first started seeing browser implementations in the Spring of 2016 and now
    enjoys broad support by all modern browsers. If you have not started using Fetch
    to make asynchronous HTTP requests, you should start migrating as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three key features that make Fetch stand apart from the `XMLHttpRequest` object
    is simpler syntax, native promise support, and the ability to manipulate requests
    and responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Fetch API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because AJAX has become a popular way to drive DOM manipulations, let''s see
    how this is done using Fetch. This will be a slightly contrived example where
    a Podcast''s logo is fetched and set to the corresponding `IMG` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with composing an `XMLHttpRequest`, this example should
    look very clean and simple. The first thing you will notice is that the only parameter
    needed is a URL. This is the simplest form of fetch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code does the same thing, but uses the `XMLHttpRequest` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is not quite as clean and not asynchronous. This example is rather simple.
    In most cases, AJAX requests require more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The fetch method returns a promise, which resolves a response object. This represents
    that response, not the image we wanted. Access to the image is done by calling
    the blob mixin, which also returns a promise.
  prefs: []
  type: TYPE_NORMAL
- en: The blob is the image, which can then be used by the `URL.createObjectUrl` function
    to convert the bytes to a usable image format that can be applied to the image's
    src property.
  prefs: []
  type: TYPE_NORMAL
- en: While contrived, this example demonstrates multiple aspects of the Fetch API
    you should familiarize yourself with. The API provides a simple surface to make
    requests, but allows you to make very complex request handler logic.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the fetch method, the API also specifies request, response, and header
    objects. There is also a collection of body mixins, designed to manipulate different
    response types.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of passing just the URL to the fetch method, you can also pass a composed
    request object. A request object contains the values to make network requests.
  prefs: []
  type: TYPE_NORMAL
- en: The request constructor has two parameters, the URL and an optional options
    object. You can also supply an existing request object, which may sound odd, but
    as you learn how to use service workers, you will realize this will be a common
    starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options parameter can contain the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: The HTTP request method: `GET`, `POST`, `PUT`, `DELETE`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: Custom request headers, which can be either a headers object or
    an object literal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: Any body that you want to add to your request: a `Blob`, `BufferSource`,
    `FormData`, `URLSearchParams`, `USVString`, or `ReadableStream` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: The request mode, for example, `cors`, `no-cors`, `same-origin`, or
    `navigate`. The default is `cors`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`credentials`: The requested credentials you want to use for the request: omit,
    same-origin, or include.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`: Similar to the properties used in the Cache-Control header. This tells
    the browser how to interact with the local cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other, less common properties are cache, redirect, referrer, and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the preceding example and expand it to use a custom request object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should note that the fetch method will only reject when there is a network
    error. When an exception is thrown, the network cannot be reached, for example,
    when the device is offline. It will not fail for a non-2XX status code.
  prefs: []
  type: TYPE_NORMAL
- en: This means you must validate the response as being good, not found, a redirect,
    or a server error. You can build a robust logic tree to handle different status
    codes. If all you need to do is respond to a good request, you can use the `response.ok`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: If the response has a 200-299 status, good, then the ok property is true. Otherwise,
    it is false.
  prefs: []
  type: TYPE_NORMAL
- en: You should handle exceptions differently than responses with status code. For
    example, if a response has a status code of 403, then you could redirect to a
    login form. A 404 status should redirect to a not found page.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a network error, then you could trigger an appropriate visual response
    like an error message or triggering your application’s offline mode experience.
  prefs: []
  type: TYPE_NORMAL
- en: The response object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fetch method resolves a response object. This is similar to the request
    object, with a few differences. It represents a server response for a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response object has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`headers`: The headers object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ok`: Indicates if the status in in the 200-299 range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirected`: Indicates if the response is from a redirect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: The HTTP status code, for example, 200 for good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statusText`: The status message of the corresponding code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: The type of response, for example, cors or basic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: The response URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bodyUsed`: A Boolean indicating whether the body has been used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several methods you should also know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clone`: Makes a clone of the response object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arrayBuffer`: Returns a promise that resolves to an `arrayBuffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blob`: Returns a promise that resolves to a blob'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formData`: Returns a promise that resolves to a `formData` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json`: Returns a promise that resolves the body text to a JSON object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: Returns a promise that resolves the body text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding example showed how to use the blob method to create an image.
    A more common task web apps have is retrieving data from an API. Typically, the
    response is text, containing a JSON.
  prefs: []
  type: TYPE_NORMAL
- en: A common user task in a podcast application is to search for podcasts and episodes.
    Our podcast application has a search form built into the layout header. It has
    logic bound to it to call an API and return a set of results.
  prefs: []
  type: TYPE_NORMAL
- en: The Podstr application uses a single JSON file to serve as an example search
    result. This is done so we do not need to build a server-side search infrastructure.
    A production application would have a more formal setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search results are formatted to contain two arrays, a list of matching
    podcasts, and another for matching episodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The search results are displayed on the search page by rendering the results
    against a template. Retrieving the results is done via a fetch request that uses
    the JSON method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `renderResults` function runs the results object through a `Mustache` template
    and assigns the rendered markup to the `search-results` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with `Mustache`, it is a minimalist template engine.
    The render method takes an HTML template and merges a JSON object to produce markup.
    If you want to know more about using `Mustache`, visit the GitHub page ([https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/)).
  prefs: []
  type: TYPE_NORMAL
- en: The search page demonstrates how to make an API call to dynamically compose
    a page. This is common for web applications today. We don't go back and forth
    and let the server render new markup in response to an action, like submitting
    a form.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we migrated to a model that has evolved to what we commonly call a
    single page application. Pages are no longer static experiences, we can change
    them dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to make an API call to the server without making a complete round
    trip. Fetch makes this possible and simpler than before. Template libraries like
    `Mustache` make it simple to render markup on the client.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with jQuery's ajax method, you will note some similarities
    to fetch. There are few key differences.
  prefs: []
  type: TYPE_NORMAL
- en: The promise returned from `fetch()` won't reject on HTTP error status, even
    if the response is an HTTP 404 or 500 error. Instead, it will resolve normally
    (with the `ok` status set to false), and it will only reject on network failure
    or if anything prevented the request from completing.
  prefs: []
  type: TYPE_NORMAL
- en: By default, fetch won't send or receive any cookies from the server, resulting
    in unauthenticated requests if the site relies on maintaining a user session (to
    send cookies, the credentials init option must be set).
  prefs: []
  type: TYPE_NORMAL
- en: Service worker fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers rely on promises and asynchronous APIs. This eliminates platform
    features such as `XMLHttpRequest` from being used in a service worker. Service
    workers are dependent on the browser supporting promises and the fetch API.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic understanding of using fetch is a fundamental skill required for service
    worker programming. Service workers allow you to intercept all network requests
    before they are sent to the network. This is done by adding a fetch event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The event handler receives a single `FetchEvent` object. There are two members
    of the `FetchEvent` object you need to know, which are `request` and `respondWith`.
  prefs: []
  type: TYPE_NORMAL
- en: The request property is the request object is being sent to the network. The
    `respondWith` method restricts the fetch event handler. It keeps the event handler
    *open* until the response is ready. The method also requires a response object
    to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker fetch event allows you to intercept requests to the network.
    This power allows you to interrogate the request and return a cached response,
    compose a custom response, or return a network response. We will cover ways to
    use this power in the service worker caching chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Polyfilling fetch in legacy browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetch and other modern APIs enjoy broad support by major browsers. However,
    there is still enough users using older browsers. Many enterprises still require
    employees to use obsolete versions of Internet Explorer. Many consumers that are
    happy with older phones and do not upgrade their devices or update software often.
  prefs: []
  type: TYPE_NORMAL
- en: This means we need to make our websites adaptable to these potential scenarios.
    Fortunately, many APIs can be polyfilled with JavaScript libraries. Fetch and
    promises are modern features that can easily be polyfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we feature detect service worker support, we can feature detect fetch
    and promise support. If those features are not supported, we can then load a polyfill.
    It is important that these polyfills are loaded in a dependent order where promises
    are followed by fetch, which is then followed by any site-specific code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a technique of asynchronously loading scripts I borrowed from an HTML5
    Rocks article ([https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread](https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread)).
    Most of the time, the polyfills are not needed, but for those cases where a polyfill
    is needed, you need to control the order the scripts are loaded in.
  prefs: []
  type: TYPE_NORMAL
- en: The technique uses an array of script URLs and loops through them, appending
    each to the DOM while maintaining an order of dependence.
  prefs: []
  type: TYPE_NORMAL
- en: Because the polyfills are not needed all the time, they are only added as necessary.
    This is determined by checking for native support. In the example code, both promise
    and fetch are detected. If they are not supported, then they are added to the
    array of script URLs and are added before the other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are also checked because fetch depends on promise support. The Podstr
    application only needs to potentially use the fetch and promise polyfill.
  prefs: []
  type: TYPE_NORMAL
- en: But there are many API polyfills that your application might need. The HTML5
    Cross Browser polyfill ([https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills)
    ) repository is a great place to find more. You can use the same feature detection
    technique to add them as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service worker shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d), *Introduction
    to Progressive Web Apps*, we created a basic service worker that pre-cached the
    2048 game assets. In this and the following chapters, we will dive deeper into
    the details of a service worker.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker goes through several stages in its overall life cycle. A
    service worker is registered. Once the script is loaded, it triggers the ‘install’
    event. At this point, the service worker is not in control of the client (browser
    tab).
  prefs: []
  type: TYPE_NORMAL
- en: When the service worker is cleared to control client contexts, the activate
    event is triggered. After this, the service worker is fully active and in control
    of any active clients, be they tabs or background processes.
  prefs: []
  type: TYPE_NORMAL
- en: Proper service workers take advantage of the event life cycle to manage data,
    like cached responses, to set the service worker context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The podcast application starts with a simple service worker script containing
    handlers for the install, activate, and fetch events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As these chapters progress, we will fill in code to use each of these handlers.
    These updates will demonstrate the service worker life cycle, common caching techniques,
    and other important service worker concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers obey a known life cycle that allows a new service worker to
    get itself ready without disrupting the current one. The life cycle is designed
    for the best user experience.
  prefs: []
  type: TYPE_NORMAL
- en: When a service worker is registered, it does not immediately seize control of
    the client. There are rules designed to minimize errors due to differences in
    code versions.
  prefs: []
  type: TYPE_NORMAL
- en: If a new service worker just took control of a client’s context when it is expecting
    a previous version’s logic, there could be issues. Even though the service worker
    operates on a separate thread, the UI code could have dependencies on the service
    worker logic or cached assets. If the new version breaks, the front-end your user
    experience could go sideways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The life cycle is designed to ensure that an in-scope page or task is controlled
    by the same service worker (or no service worker) throughout its session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The life cycle consists of the registration, installation, and activation steps.
    The installation and activation events can have handlers bound that perform specific
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle also covers service worker updates and unregistration. These
    last two tasks may not be used as often, but developers should still be familiar
    with how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage can be used for different process phases to manage the service worker,
    cached assets, and possibly state data. The following chapter goes into details
    about the life cycle and how each phase can be used to make your application more
    performant and easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to register, update, and remove a service worker. You will
    also learn the service worker’s scope and the definition of a service worker client.
    The chapter will also cover the install and activate events so that you can add
    code to manage the service worker’s cache and active state.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important progressive web application features is the ability
    to work offline and load instantly. Service worker caching enables this super
    power. In the past, websites could function offline and even gain some performance
    benefits via `appCache`.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker caching supersedes `appCache` and provides a better programmatic
    interface. `AppCache` is notorious for being difficult to manage and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: When your page references an `appCache` manifest file and has a registered service
    worker, the service worker manages cache and the `appCache` is bypassed. This
    makes service worker caching a progressive enhancement from `appCache` and makes
    it safe to use both.
  prefs: []
  type: TYPE_NORMAL
- en: By enabling caching, service workers make the network a progressive enhancement.
    Because the service worker cache API is very low level, it requires the developer
    to apply custom logic to manage how network resources are cached and retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves lots of room for creativity to apply different caching strategies
    in your application. Chapter 6,* Master the Cache API- Manage Web Assets in a
    Podcast Application,* dives into the core service worker caching concepts you
    need to master.
  prefs: []
  type: TYPE_NORMAL
- en: Using push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Businesses have been using push to engage customers, even if their app is not
    open, for about a decade now. And why not? Research shows some impressive numbers
    related to brand engagement and revenue directly correlated with the tiny interruptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Google has shared the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 72% increase in time spent for users visiting via a push notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 26% increase in average spend per visit by members arriving via a push notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: +50% repeat visits within 3 months
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values all point to the reason why brand and product managers love push
    notifications. Unfortunately, up to recent times, the web has been left out of
    this party. Many businesses have opted to go through the hassle of a native app
    solely to send push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: The Push API gives web applications the ability to receive messages pushed to
    them from a server, whether or not the web app is in the foreground, or even currently
    loaded, on a user agent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing push in your application requires a server-based service, typically
    a cloud based service such as Google Cloud Messenger or AWS Pinpoint. There are
    numerous providers available.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about your push provider. Web push notifications are based on an
    IETF standard, Generic Event Delivery Using HTTP Push ([https://tools.ietf.org/html/draft-ietf-webpush-protocol-12](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)).
    Make sure your provider is compliant and you should have no problems.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Chrome, FireFox, Samsung Internet, and Opera
    currently ship push notification support. Microsoft Edge is in the process of
    shipping support. Apple has not released a potential timeline for Safari support.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that each browser or user agent acts independently from
    other browsers. If a customer loads your web page from more than one browser,
    each will register a service worker. If each one also creates a push notification
    subscription, the user could receive multiple notifications.
  prefs: []
  type: TYPE_NORMAL
- en: This makes managing subscription logic in your application’s service logic important.
    This is outside the scope of this book. As part of production logic, it is a good
    idea to query your server before attempting to register a user for push notifications.
    There are several options to handle this potential situation and you will need
    to determine what is best for your application.
  prefs: []
  type: TYPE_NORMAL
- en: If your brand also has a native app that offers push notifications, they will
    also be a separate subscription. This means you should track if the customer already
    receives notifications on the device as best as you can to avoid duplicating messages.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn some fundamentals of implementing push notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: How to subscribe and unsubscribe a user for push messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle incoming push messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to display a notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to respond to notification clicks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is part of the Podstr application. I won't cover how to set up a push
    provider because they vary too much and are prone to changes to their administration
    interfaces. This creates a fluid environment that would only serve to create confusion
    with readers and potential providers. Plus, singling out a single provider could
    create an unwanted bias. Most providers have current documentation and JavaScript
    SDKs to help you create the server-side environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to stand up your own push service, Matt Gaunt, of the Google
    Chrome team, has published an example server you can clone ([https://github.com/web-push-libs/web-push](https://github.com/web-push-libs/web-push)).
    This might serve as a decent test service, but I would not consider it a production
    quality service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, the Chrome developer tools provide enough to trigger the
    client-side logic and experience. You can find a link to the right of a registered
    service workers detail to emulate a push event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This link triggers an emulated push message with a simple payload: Test push
    message from DevTools. The Podstr application will use this event to trigger a
    message we can display to the user about new podcast episodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable push notifications, there are several steps you need to follow. The
    first step is detecting if the browser supports push or not. If so, then you can
    proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since push is something you would configure after you register the service worker,
    you can check for support once the service worker is registered. Just like checking
    for service worker support, you can check if the window object contains a reference
    to the `PushManager`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PushManager` has three methods to manage a user's subscription status.
    The `getSubscription` method returns a promise that resolves a `PushSubscription`
    object. If the user is subscribed, the subscription is an object, otherwise it
    is null.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to you how you surface the state of push notifications in your application.
    My personal advice is to hide any visible queues if the browser does not support
    push notifications because it will confuse the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Most sites will simply prompt for permission to send push notifications. The
    ability to send notifications is gated behind user approval. The browser displays
    a yes or no dialog when you try to initiate the push notification subscription
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also a good practice to allow users to opt out of push notifications.
    This can be done in application settings or on a configuration page. The Podstr
    application has a settings page that includes options to manage push notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The code to manage push notification subscriptions is covered later in this
    section. You can provide an interface for the user either as a passive option,
    like on the configuration page, or actively via a notification.
  prefs: []
  type: TYPE_NORMAL
- en: As Android evolves, Chrome and possible other Android browsers will automatically
    convert progressive web apps that are added to the `homescreen` to `WebAPKs`.
    These are native applications that enjoy almost equal status with store apps.
    One feature they should have is the ability to manage push notifications in the
    app through the platform settings applications, but you should never rely on this
    as the only way to turn notifications off.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Twitter has adopted progressive web applications and can send notifications.
    I turned this on, but found it was pushing notifications for a single account
    (Scott Hanselman) to my phone. While I like Scott, I was expecting a bit more
    variety.
  prefs: []
  type: TYPE_NORMAL
- en: 'It took me a while to discover how to manage Twitter notifications. I found
    out how to block notifications for the site in Chrome faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Twitter has many notification options which require a robust backend to manage.
    The Podstr application uses either an on or off choice. If this were a production
    application, I would build out more logic over time, like Twitter has done.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the user's subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the example code, if the subscription object does not exist, the `subscribeUser`
    function is invoked. The service worker registration object is passed as the only
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `pushManager` subscribe method has a single parameter, an object with two
    properties, `userVisibleOnly` and `applicationServerKey`.
  prefs: []
  type: TYPE_NORMAL
- en: The subscribe function returns a promise that resolves after the user has granted
    permission to send notifications and the browser sends a request to the push service.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the subscribe function work flow, the User Agent is required to prompt
    the user for permission. If this is denied, the promise rejects with a `NotAllowedError`.
    You should always include a catch handler to the subscribe call.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Push Notification specification ([https://w3c.github.io/push-api/#webapp](https://w3c.github.io/push-api/#webapp)):'
  prefs: []
  type: TYPE_NORMAL
- en: User agents MUST NOT provide Push API access to web apps without the express
    permission of the user. User agents MUST acquire consent for permission through
    a user interface for each call to the `subscribe()` method, unless a previous
    permission grant has been persisted, or a prearranged trust relationship applies.
    Permissions that are preserved beyond the current browsing session MUST be revocable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `userVisibleOnly` property is a Boolean that indicates if the push notifications
    will always be visible to the user. Currently, you must set this property to true
    before browsers will let you subscribe a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '"If developers request the ability to use silent push (the ability to receive
    pushes without triggering a user-visible UI change) we currently reject the request,
    but in the future we plan to introduce a permission to enable this use case"'
  prefs: []
  type: TYPE_NORMAL
- en: – https://goo.gl/ygv404
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, for now, you will need to display a message to the end user, even if there
    is no user feedback needed. For example, a caching strategy to update a site’s
    cached assets can be triggered by a push notification. In those scenarios, you
    would display a notification to alert the user to the update.
  prefs: []
  type: TYPE_NORMAL
- en: The `applicationServerKey` property is also known as a WEBPUS-VAPID (voluntary
    application server identification for web push ([https://tools.ietf.org/html/draft-ietf-webpush-vapid-04](https://tools.ietf.org/html/draft-ietf-webpush-vapid-04))).
    This value comes from your push service provider. It will be a rather long string
    of random characters and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The value should be base 64 URL safe encoded. The `urlB64ToUnit8Array` function
    converts it to a UInt8Array, which is expected by the subscribe function. The
    `urlB64ToUnit8Array` is a utility function you can find in the Podstr source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The User Agent should only accept notifications containing the subscribed `applicationServerKey`.
    Per the specification, this is a recommendation and browsers honor that advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a subscription has been made, it cannot be altered. You must unsubscribe
    from the initial subscription and create a new subscription with the new options.
    For example, if you should change your push service, the client will need a new
    `applicationServerKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Like all things in service workers, the subscribe function returns a promise.
    If there is not an exception, it resolves a `PushSubscription` object. This object
    contains various values about the subscription that could be useful to build a
    more robust user experience or management logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties** (all read only):'
  prefs: []
  type: TYPE_NORMAL
- en: '`endpoint`: The subscription endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expirationTime`: Null unless the subscription has an expiration time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: An echo of the options used to create the subscription'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriptionId`: The subscription ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`getKey`: An `ArrayBuffer` representing the client’s public key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toJSON`: A JSON representation of the subscription properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unscubscribe`: Initiates a subscriber unsubscription process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `updateSubscriptionOnServer` function, called upon a successful subscription,
    would normally be used to update the server. However, for our purposes, it is
    used to echo out the subscription object properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Handling push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the consumer has confirmed a push notification subscription, you can send
    messages to the user agent. When a message is sent to the device, it determines
    what service worker to apply the message and trigger a push event.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker needs a push event handler that receives an event parameter.
    The event object contains the message data.
  prefs: []
  type: TYPE_NORMAL
- en: The sever can send any text in the message. It is up to the service worker to
    parse the message and trigger the appropriate work flow.
  prefs: []
  type: TYPE_NORMAL
- en: PodStr only manages a new podcast's episode notifications. But a retailer might
    want to promote sales or remind a customer to complete an order. There is really
    no limit to what prompt you might send to your customer.
  prefs: []
  type: TYPE_NORMAL
- en: The latter message might not be a simple string -- it could be a stringified
    JSON object. If you need to process JSON objects, you will need to test it to
    see if it is a valid object before falling back to a string. The more message
    types you might have, the more complex event handler logic you will need.
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, the Podstr push event handler will compose an `options`
    object that contains details about the new episode. This includes the episode
    title and podcast logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Push messages are handled by extensions to the core `serviceWorkerRegistration`
    object, which are obtained during the registration process or the `getRegistration`
    method. The method we are interested in is the `showNotification` method.
  prefs: []
  type: TYPE_NORMAL
- en: This method has two parameters, a title and an options object. The title should
    be a string that describes the notification. The Podstr application will use the
    episode’s title.
  prefs: []
  type: TYPE_NORMAL
- en: The options object allows you to configure the notification and can be a combination
    of several properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Notification Object:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`actions`: An array of objects that will display action buttons for the user
    to choose from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`badge`: The URL of an image to represent the notification when there is not
    enough space to display the notification itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: A string to display in the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir`: The direction of the notification; it can be auto, ltr, or rtl.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icon`: The URL of the notification icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: A string containing the URL of an image to display in the notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lang`: Must be a valid BCP 47 language tag which is used for the notification
    language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renotify`: If a notification uses a tag for a repeat display, this can be
    set to true to suppress vibrations and audible notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requireInteraction`: On larger screens, if this value is true, the notification
    stays visible until the user dismisses it. Otherwise, Chrome and I assume other
    browsers will minimize the notification after 20 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag`: An ID that allows you to find and replace the notification if needed.
    This can be done by calling the `getNotifications` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vibrate`: An array of numbers specifying a vibration sequence. For example,
    `[300, 100, 400]` would vibrate 300 ms, pause 100 ms, then vibrate 400 ms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is an open field that you can optionally populate anyway you see
    fit. It can be any data type, like a string, number, date, or object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `action` property gives you the ability to add one or more action buttons
    to the notification. You can handle this selection in the `notificationClick`
    event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'An action object has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`: A `DOMString` identifying a user action to be displayed on the notification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: A `DOMString` containing action text to be shown to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icon`: [optional] A String containing the URL of an icon to display with the
    action:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Podstr service worker looks for a simple JSON object in the notification
    event's data field. It parses the object and builds a notification object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful trying to parse the text because it may not be a JSON object. The
    best way to handle this situation is to wrap the parse method and associated logic
    in a try catch statement. Not the best scenario, but the only way, for now, to
    handle valid and invalid JSON object parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the notification contains plain text, a generic notification is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `showNotification` method causes the message on the user's device. The function
    returns a promise that resolves a `NotificationEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the `showNotification` method in a `waitUntil` function keeps the event
    handler open until the promise resolves so that the service worker does not terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `NotificationEvent` object has two properties: notification and action. The
    notification is a copy of the notification object used to create the notification.
    If there are one or more action buttons in the notification, the action value
    is the action object''s action property defined in the notification object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, this value would be either listen or later. You can use this
    value to trigger a different response flow. If the user selects listen, you can
    go directly to the episode page and start playing the episode. If they say later,
    you know to download the episode''s mp3 file and persist it in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `notification.close` method programmatically closes a notification.
  prefs: []
  type: TYPE_NORMAL
- en: That is all it takes to display a push notification. Remember, all the code
    to process a push notification is handled in the service worker. For now, browsers
    require that you display a visible message when you process a notification. This
    does not mean the notification requires user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: A push notification could trigger logic to be executed in the service worker
    like update the cache. If you require a response, you can configure action buttons
    and process the end user’s choice.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only push notification task we need to implement is a way to unsubscribe
    the subscription. This can be done via the `pushManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Before I dive into the details to unsubscribe a user from push notifications,
    I want to look at how we can provide a UI for the user to manage their subscription
    status.
  prefs: []
  type: TYPE_NORMAL
- en: My preference is to include a management interface in the site's settings, configuration
    page, or section. For example, the Twitter PWA has a detailed notification configuration
    experience. It has a high-level page with links to four child pages, each offering
    more granular control over different notification aspects.
  prefs: []
  type: TYPE_NORMAL
- en: They are grouped as either filters or preferences. In the filters group, there
    is also a checkbox to enable a quality filter, which is a very high-level setting.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications are managed in their own group of pages. They have code to
    detect if push notifications are enabled for the site and, if so, give the user
    the option to enable push. Once they enable push, they can then tailor their notifications
    by type of activity.
  prefs: []
  type: TYPE_NORMAL
- en: The default choices can cause a crazy amount of notifications to be sent. So,
    if you are like me, take the time to trim the volume of notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Twitter Lite application can serve as a reference for a detailed push management
    interface. Fortunately, the Podstr application keeps its notifications simple.
    For our purposes, we will provide an interface to either turn notifications on
    or off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notifications can be toggled on or off, which triggers client-side logic to
    manage a subscription. The application must manage both `subscribeUser` and `unsubscribeUser`
    based on the user toggling a choice.
  prefs: []
  type: TYPE_NORMAL
- en: This is why there are separate subscribe and unsubscribe methods. Before I dive
    into the code to handle the toggling UI, let’s review the `unsubscribeUser` method.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the `subscribeUser` method, the `unsubscribeUser` method uses the
    service worker's `pushManager.getSubscription` method to obtain reference to the
    current subscription, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a current subscription, the subscription object''s unsubscribe
    method is called. Unsubscribe returns a promise that resolves a Boolean indicating
    if the subscription was unsubscribed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the service worker is unregistered, then any associated push notification
    subscriptions are deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: When a notification subscription changes outside the control of the application,
    the `pushsubscriptionchange` event fires in the service worker. You can add an
    event handler to this event to handle the change as needed.
  prefs: []
  type: TYPE_NORMAL
- en: A subscription state can change by either the consumer or automatically by the
    service. The service might remove a subscription if it has become stale. In this
    case, you could create an automated resubscription process to renew the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: If you are resubscribing a notification subscription, it must be done with the
    same options as the page used in the initial, frontend JavaScript. You can access
    the previous options by accessing the `oldSubscription` object in the event object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a push subscription change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pushsubscriptionchange` event is particularly handy if the subscription
    is automatically removed due to the subscription becoming stale. This can happen
    because many push services limit the lifetime of a subscription for security and
    due to inactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Just like authentication tokens, push subscriptions can be seamlessly renewed
    without involving the user. This is what you can do in the service worker for
    a push subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pushsubscriptionchange` event includes an `oldSubscription` object that
    contains the details of the original subscription. They can be used to create
    a new subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This saves you the hassle of persisting the values between sessions. Now, you
    can easily resubscribe the user in the service worker without disturbing the end
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Background sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service worker cache enables a site to render offline. But that only helps
    when you have the page and assets available in the cache. What can you do if you
    need to post data or get uncached pages while offline?
  prefs: []
  type: TYPE_NORMAL
- en: This is where background sync can help. It enables you to register a request
    that will be fulfilled when the device is back online.
  prefs: []
  type: TYPE_NORMAL
- en: Background sync executes asynchronous tasks in the background, when a device
    is online. It works by building a queue of requests to fulfill as soon as the
    device is capable of connecting to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The way background sync works is you place a network request with a tag, registered
    with the `SyncManager`. The platform is responsible for checking if the device
    is online or offline.
  prefs: []
  type: TYPE_NORMAL
- en: If it cannot make the request, the sync places the request in a queue for that
    tag. The background sync periodically checks the ability to make a request, but
    not so much that it would drain your battery or consume excessive CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: The background sync model possibly requires a new way to organize your application's
    code. To properly use sync programming, you should separate all requests into
    isolated methods from any event triggers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of making a fetch call directly in a button click event
    handler, you would call a method that fetches the asset from the event handler.
    This allows you to better isolate the call within a background sync registration.
  prefs: []
  type: TYPE_NORMAL
- en: The Podstr application allows the customer to select podcast episodes to listen
    to offline. This requires the user to select the episode, and the application
    will download the audio file and store it for offline consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the application must be online to download the episode. You may also
    want to limit downloading a large file like an audio file for when the device
    is on WiFi and not cellular.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how to register a request using background sync:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because background sync is very new, it is not supported by many browsers yet.
    That should be changing in the near future. For example, Edge has support behind
    the service worker flag.
  prefs: []
  type: TYPE_NORMAL
- en: To be safe, you should employ feature detection before using it. This can be
    done by checking if the service worker registration object supports `"sync"`.
    If so, then you can register the request; otherwise, you can make the request
    as a normal request.
  prefs: []
  type: TYPE_NORMAL
- en: Sync requests are registered in your UI code, not the service worker. The service
    worker has a sync event handler, which is responsible for handling the network
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Background sync works like a cloud-based messaging platform. Instead of placing
    a request directly, you post a message to a queue or buffer that can be accessed
    by both the placing and the responding parties.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, Podstr stores requests for offline episodes in IDB. This is
    chosen because it is an asynchronous data store, available to both the client
    code and service worker. I won't go into the details of how this works in this
    chapter, as I am saving that for Chapter 6, *Master the Cache API- Manage Web
    Assets in a Podcast Application*, when we dive deeper into caching.
  prefs: []
  type: TYPE_NORMAL
- en: To make background sync work, you first need to place a message in the IDB queue.
    When the service worker receives a sync event to process episodes to listen later
    (`get-episode`), it checks the IDB queue for episodes and fetches each file.
  prefs: []
  type: TYPE_NORMAL
- en: You register the request by calling the sync's `register` method. This method
    accepts a simple tag name. This is passed along to the service worker's sync event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service worker registers a single sync event handler. Each time a background
    sync event triggers, the handler receives a `SyncEvent` object. It contains a
    `tag` property that identifies the event by the `tag` value which is supplied
    when you registered the synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that it is checking the value of the tag before
    calling the `getEpisode` function. The `getEpisode` function triggers the tasks
    required to retrieve the episodes in the listen later queue and downloads them
    for offline persistence.
  prefs: []
  type: TYPE_NORMAL
- en: You should notice the method is wrapped in a `waitUntil`. This is to keep the
    event handler live while the background task is being performed. Downloading a
    podcast episode could take a few minutes, and you do not want the service worker
    process terminating.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the podcast episodes will download in response to the background
    sync event being fired. This means the request(s) may not immediately initiate,
    but they will get downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The bonus is that these downloads will happen even if a Podstr page is not loaded
    in the browser. Plus, the download happens in a background thread, freeing up
    the UI from this cumbersome task. Now, the consumer is free to navigate around
    the application without waiting on the audio files to download.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers are exciting and offer a great new context for developers to
    build rich, engaging user experiences while employing background activities. This
    chapter introduced you to different service worker concepts and the Podstr application.
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen how to leverage both push notifications and background sync
    to build engagements, even when the customer is not viewing your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, you will see how the service worker's life cycle
    and caching work. By the end of this section, you will have a modest podcast application,
    demonstrating how to use service worker caching, push notifications, and background
    synchronization to create a user experience that rivals popular native applications
    using web technology.
  prefs: []
  type: TYPE_NORMAL
