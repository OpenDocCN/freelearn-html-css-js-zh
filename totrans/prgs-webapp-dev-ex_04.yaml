- en: Service Workers – Notification, Synchronization, and Our Podcast App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者 – 通知、同步以及我们的播客应用
- en: In [Chapter 1](part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d), *Introduction
    to Progressive Web Apps*, you read about how the web has fallen short in the mobile
    era and why progressive web applications can level your website to equal or even
    better capabilities than native options. Service workers are the most important
    part of a progressive web application because they are the application's backbone.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d)，“渐进式Web应用简介”中，您了解到网络在移动时代的表现不足，以及为什么渐进式Web应用可以使您的网站达到与原生选项相当甚至更好的能力。服务工作者是渐进式Web应用最重要的部分，因为它们是应用的骨架。
- en: The web manifest and the home screen icon enhance the ability to develop a relationship
    with the customer and control the launch experience. Service workers enable a
    programmatic user experience enhancement when a page is loaded and even when it
    isn't.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络清单和主屏幕图标增强了与客户建立关系和控制启动体验的能力。服务工作者在页面加载时以及页面未加载时都允许程序化地增强用户体验。
- en: 'Service workers sit between the browser and the network and act as a proxy
    server. They provide more than just a caching layer; they are an extensible backbone:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者位于浏览器和网络之间，充当代理服务器。它们提供的不仅仅是缓存层；它们是一个可扩展的骨干：
- en: '![](img/00047.gif)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00047.gif)'
- en: For the coder, **service workers** are JavaScript files, making them familiar
    to most web developers. These scripts are more like Node.js modules than a web
    page script. They execute on a separate thread from the UI service workers, so
    they do not have access to the DOM.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，**服务工作者**是JavaScript文件，这使得它们对大多数Web开发者来说都很熟悉。这些脚本更像是Node.js模块，而不是网页脚本。它们在UI服务工作者之外的一个单独线程上执行，因此它们无法访问DOM。
- en: The service worker programming model is more functional than what you might
    use for the user interface. The node comparison makes sense in that the service
    worker programming is headless and used to perform calculations, with many tasks
    being traditionally reserved for the web server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者编程模型比您可能用于用户界面的模型更功能化。将服务工作者编程与无头节点比较是有意义的，因为服务工作者编程用于执行计算，许多任务传统上是为Web服务器保留的。
- en: Service workers also differ from UI scripts because they are completely asynchronous.
    This means some APIs, such as XHR and localStorage, are not supported. Instead,
    you should use the Fetch API and **IndexedDB** (**IDB**) to connect with APIs
    and persist data. When a browser supports service workers, they must also support
    promises, providing a natural asynchronous interface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者与UI脚本也有所不同，因为它们是完全异步的。这意味着一些API，如XHR和localStorage，不支持。相反，您应该使用Fetch API和**索引数据库**（**IDB**）来与API和持久化数据连接。当浏览器支持服务工作者时，它们也必须支持promises，提供自然的异步接口。
- en: A note about `XMLHttpRequest`, when initiated from the client the request passes
    through the service worker. You cannot initiate an XHR request from a service
    worker.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`XMLHttpRequest`的注意事项，当从客户端发起时，请求会通过服务工作者。您不能从服务工作者中发起XHR请求。
- en: Service workers are designed to be an extensible platform, allowing for additional
    APIs to be added over time. Cache is the only extension API that the specification
    details. Native push notifications and background sync are examples of additional
    APIs that are enabled by service workers. In the future, you can expect many more
    APIs to be added.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者被设计成一个可扩展的平台，允许随着时间的推移添加额外的API。缓存是规范中详细说明的唯一扩展API。原生推送通知和后台同步是服务工作者启用的一些额外API示例。未来，您可以期待添加更多API。
- en: Caching enables offline and instant asset loading. I think the best term to
    describe this feature is a proxy server in the browser. Advanced service workers
    act almost like a complete web server stack. A well-crafted service worker can
    assume rendering responsibilities currently allocated to ASP.NET, Node Express,
    and Ruby, and many more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存使得离线和即时资产加载成为可能。我认为描述这个功能的最佳术语是浏览器中的代理服务器。高级服务工作者几乎像是一个完整的Web服务器堆栈。一个精心制作的服务工作者可以承担目前分配给ASP.NET、Node
    Express、Ruby等任务的渲染责任。
- en: The last chapter covered adding HTTPS to your site. If you were not sold on
    the concept yet, you will be now. Service workers also require SSL. The main reason
    service workers require SSL is to enable APIs and other features requiring a higher
    level of trust.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了如何为您的网站添加HTTPS。如果您之前还没有被这个概念说服，现在应该会了。服务工作者也需要SSL。服务工作者需要SSL的主要原因是为了启用需要更高信任级别的API和其他功能。
- en: The power service workers that have been enabled could be used for evil purposes.
    In addition to requiring SSL, they are also limited in scope to a single domain.
    They do not have the ability to manipulate anything outside the scope of the domain
    that hosts the script.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已启用的强大服务工作者可能被用于邪恶目的。除了需要SSL之外，它们的作用域也限制在单个域。它们没有能力操纵域之外的内容。
- en: This is a good thing because a third-party script cannot register a service
    worker and do bad things to your site.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事，因为第三方脚本无法注册服务工作者并对您的网站造成破坏。
- en: On the surface, this may seem simple, but there is an art to mastering service
    workers. The following chapters are designed to give you the foundation needed
    to create service workers that enhance any website.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这可能看起来很简单，但掌握服务工作者需要一定的技巧。以下章节旨在为您提供创建能够增强任何网站的服务工作者所需的基础知识。
- en: 'In this chapter you will learn:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: The service worker threading model
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者线程模型
- en: Service worker browser support
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者浏览器支持
- en: How the example podcast application works
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例播客应用程序的工作原理
- en: An introduction to the fetch API
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fetch API简介
- en: How to create a basic service worker
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建基本服务工作者
- en: The service worker life cycle
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者生命周期
- en: Service worker caching basics
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者缓存基础
- en: How to use push notifications
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用推送通知
- en: An introduction to background sync programming
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景同步编程简介
- en: The service worker thread
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者线程
- en: Service workers run within their own context or thread outside the UI. Because
    the service worker thread is separate from the UI, it does not have access to
    the DOM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者在UI之外自己的上下文或线程中运行。因为服务工作者线程与UI分离，所以它无法访问DOM。
- en: The service worker scope is event driven, meaning the platform (browser or operating
    system, depending on your point of view) initiates the service worker. When the
    service worker initiates, it does so with the intent of responding to an event,
    such as a web page opening, a push notification, or another event.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者的作用域是事件驱动的，这意味着平台（根据您的观点，是浏览器或操作系统）启动服务工作者。当服务工作者启动时，它是以响应某个事件为目的，例如网页打开、推送通知或其他事件。
- en: The process stays alive long enough to service the need. This time is determined
    by the browser and varies by platform. There is no fixed time defined in the service
    worker specification.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进程保持活跃足够长的时间以服务需求。这个时间由浏览器决定，并且因平台而异。服务工作者规范中没有定义固定的时间。
- en: Running in a separate context from the normal JavaScript offers many advantages
    to service workers. The first is that a service worker script does not block the
    UI from rendering. You can use this feature to offload non-UI work to the service
    worker. An example we will see in a later chapter shows how to use client-side
    templating to render markup in the service worker and not the UI thread.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在与正常JavaScript不同的上下文中运行为服务工作者提供了许多优势。首先，服务工作者脚本不会阻止UI渲染。您可以使用此功能将非UI工作卸载到服务工作者。我们将在后面的章节中看到一个示例，展示如何使用客户端模板在服务工作者而不是UI线程中渲染标记。
- en: This gives you a way to separate tasks into more appropriate threads. Now, you
    can perform calculations such as math or rendering markup in response to an API
    call and return it to the UI thread to update the DOM.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了将任务分离到更合适的线程中的方法。现在，您可以在响应API调用时执行计算，如数学或渲染标记，然后将结果返回到UI线程以更新DOM。
- en: The service worker can communicate with the UI thread through the messaging
    API. You can pass text messages back and forth between threads. You can also modify
    responses from the server before they reach the UI thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者可以通过消息API与UI线程通信。您可以在线程之间传递文本消息。您还可以在它们到达UI线程之前修改来自服务器的响应。
- en: Features like push notifications are possible because service workers execute
    in their own context. A service worker can spin up in response to an event triggered
    by the operating system and not because a page is loaded.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 像推送通知这样的功能之所以可行，是因为服务工作者在自己的上下文中执行。服务工作者可以响应操作系统触发的事件而启动，而不是因为页面加载。
- en: In the past, web-based push notifications have been possible by using web workers.
    These are great tools, but only execute when the browser is open. Service workers
    differ because the operating system can spin them up due to an external stimulus.
    The only real requirement is that the client device should be powered on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，基于Web的推送通知可以通过使用Web工作者来实现。这些工具很棒，但只有在浏览器打开时才会执行。服务工作者与之不同，因为操作系统可以因为外部刺激而启动它们。唯一真正的要求是客户端设备应该处于开启状态。
- en: Service worker browser support
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者浏览器支持
- en: 'Service worker is a relatively new technology, leading to a common question:
    is it safe to use service workers? What we are really asking is, how many browsers
    support service workers?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者是一项相对较新的技术，因此人们常常会问：使用服务工作者是否安全？我们真正想问的是，有多少浏览器支持服务工作者？
- en: The good news is all major browsers have shipped basic service worker support.
    Chrome has been the leader as they have been largely responsible for initiating
    the concept and managing the specification. The technology has received enthusiastic
    support from other browser vendors including Microsoft, FireFox, Samsung, and
    Opera.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是所有主要的浏览器都已经发布了基本的服务工作者支持。Chrome一直是领导者，因为他们在很大程度上负责启动这一概念并管理规范。这项技术得到了包括微软、Firefox、三星和Opera在内的其他浏览器厂商的热烈支持。
- en: As of the Spring of 2018 all modern browsers had shipped updates to general
    consumers with at least service worker caching support. Of course, older browsers
    won't support service workers. But their usage is winding down as consumers upgrade
    phones and laptops.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年春季，所有现代浏览器都已向普通消费者发布了更新，至少支持服务工作者缓存功能。当然，旧浏览器不会支持服务工作者。但随着消费者升级手机和笔记本电脑，它们的用量正在减少。
- en: Microsoft Edge service worker support
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软Edge服务工作者支持
- en: At the september 2017 Edge Web Summit, Microsoft announced they were shipping
    service worker support behind a flag. The goal is to flesh out any bugs in the
    implementation before general consumer support ships.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年9月的Edge Web Summit上，微软宣布他们将在标志后发布服务工作者支持。目标是解决实现中的任何错误，在向普通消费者发布支持之前。
- en: In the Spring of 2018 support for service workers was shipped to general consumers
    with when Windows RS4 was released.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年春季，随着Windows RS4的发布，服务工作者的支持被推向了普通消费者。
- en: Safari service worker support
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Safari服务工作者支持
- en: If you are not familiar with how Apple announces web API support, they don't.
    New features quietly ship and are left for developers to discover, at least in
    most cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉苹果如何宣布Web API支持，他们不会这样做。新功能会悄悄发布，至少在大多数情况下，留给开发者去发现。
- en: 'In a surprise release Apple updated Safari in March 2018 to support service
    workers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个令人惊讶的发布中，苹果在2018年3月更新了Safari，以支持服务工作者：
- en: '![](img/00048.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: There are some limitations to Safari service worker support. For now, they do
    not support native push notifications or background sync. I don't consider these
    missing features a reason to avoid integrating them in your applications. Remember
    progressive web apps are about taking advantage of features as they are available.
    You can still create viable work around to these features.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Safari服务工作者支持存在一些限制。目前，它们不支持原生推送通知或后台同步。我不认为这些缺失的功能是避免在您的应用程序中集成它们的原因。记住，渐进式Web应用是关于利用可用功能的。您仍然可以创建可行的解决方案来绕过这些功能。
- en: Is the service worker ready?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者是否准备好了？
- en: '*Jake Archibald* maintains a GitHub site that tracks each mainstream browser''s
    support of service worker-related features ([https://jakearchibald.github.io/isserviceworkerready/](https://jakearchibald.github.io/isserviceworkerready/)),
    called is* service worker Ready.*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*杰克·阿奇博尔德*维护一个GitHub网站，跟踪每个主流浏览器对服务工作者相关功能的支持（[https://jakearchibald.github.io/isserviceworkerready/](https://jakearchibald.github.io/isserviceworkerready/))，称为*is* service
    worker Ready*。'
- en: 'The site features rows, focusing on each primary service worker feature and
    their requirements with each browser''s icon. The grayscale browser icons indicate
    that support has not shipped. Icons with a yellow background have shipped partial
    support. A green background indicates full support of the feature:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站有行，专注于每个主要服务工作者功能和它们的要求，以及每个浏览器的图标。灰度浏览器图标表示支持尚未发布。背景为黄色的图标表示已发布部分支持。绿色背景表示对功能的完全支持：
- en: '![](img/00049.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.jpeg)'
- en: As you can see the major browser players all support service workers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主要的浏览器厂商都支持服务工作者（service workers）。
- en: Now that all modern browsers support service workers you may think there is
    no reason to work about browsers without service worker support. But there are
    still an important percentage of browser sessions using Internet Explorer and
    legacy Android browsers. This means you may want to consider fallback options.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有现代浏览器都支持服务工作者，你可能认为没有必要担心不支持服务工作者的浏览器。但仍有相当一部分浏览器会话使用 Internet Explorer
    和遗留的 Android 浏览器。这意味着你可能需要考虑回退选项。
- en: Polyfilling older browsers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polyfilling 更旧的浏览器
- en: Polyfills are libraries or fallbacks you can reference as needed to add support
    for modern features to browsers lacking support. Not all modern features can't
    be polyfilled, but many can. Some are not direct polyfills, but leveraging other
    APIs to create the desired experience.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfills 是你可以按需引用的库或回退，用于向不支持现代功能的浏览器添加对现代特性的支持。并非所有现代特性都可以通过 Polyfills 实现，但许多可以。有些不是直接的
    Polyfills，而是利用其他 API 来创建所需体验。
- en: The good news is that you can polyfill a service worker caching to a point.
    This can be done using `IndexedDB`. You will need an extra layer of JavaScript
    to manage the site's assets and API calls. We will touch on this technique in
    the advanced caching chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是你可以将服务工作者缓存 Polyfill 到一定程度。这可以通过 `IndexedDB` 实现。你需要额外的 JavaScript 层来管理网站的资产和
    API 调用。我们将在高级缓存章节中涉及此技术。
- en: In addition to using `IndexedDB` to cache assets, you can also use `appCache`
    as an offline and asset caching fallback.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `IndexedDB` 缓存资源外，你还可以使用 `appCache` 作为离线和资源缓存的回退。
- en: Push notifications cannot be polyfilled, but you can utilize alternative notification
    mediums. SMS texting and web worker notifications can provide ways for the business
    to engage with customers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知无法通过 Polyfills 实现，但你可以利用替代的通知媒介。短信文本和 Web Worker 通知可以为业务与客户互动提供方式。
- en: The podcast application
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播客应用程序
- en: 'This chapter introduces you to different service worker concepts and features
    like the service worker life cycle, caching, and push notifications. To do this,
    we are going to build a simple podcast application. This application will demonstrate
    how to tackle the service worker life cycle and response caching:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍不同的服务工作者概念和功能，如服务工作者生命周期、缓存和推送通知。为此，我们将构建一个简单的播客应用程序。此应用程序将展示如何处理服务工作者生命周期和响应缓存：
- en: 'The minimal podcast application requirements include:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的播客应用程序需求包括：
- en: Fast loading
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速加载
- en: Search podcasts
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索播客
- en: Favorite podcasts
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收藏播客
- en: Play audio files
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频文件
- en: Persist episodes for offline listening
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化剧集以供离线收听
- en: The application requires some server-side help, which for our purposes will
    be a set of snapshot data I took from public sources. The data is part of the
    project repository ([https://github.com/docluv/PWAPodcast](https://github.com/docluv/PWAPodcast)),
    so you can recreate the application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要一些服务器端的支持，对于我们来说，这将是一组我从公共来源获取的快照数据。这些数据是项目仓库的一部分 ([https://github.com/docluv/PWAPodcast](https://github.com/docluv/PWAPodcast))，因此你可以重新创建应用程序。
- en: You will learn how to register a service worker, the basics of the service worker
    life cycle, how service worker caching works, and how to use `IndexedDB` to persist
    data. You will also see how to utilize service worker cache and `IndexedDB` to
    persist MP3 media files.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何注册服务工作者、服务工作者生命周期的基本知识、服务工作者缓存的工作原理以及如何使用 `IndexedDB` 持久化数据。你还将看到如何利用服务工作者缓存和
    `IndexedDB` 持久化 MP3 媒体文件。
- en: The podcast application source code is organized by folders that correlate to
    each chapter's progress. The root folder contains common files to define the Grunt
    tasks to run local web servers, just like the 2048 application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 播客应用程序源代码按文件夹组织，这些文件夹与每个章节的进度相关联。根文件夹包含定义运行本地 Web 服务器的 Grunt 任务等常见文件，就像 2048
    应用程序一样。
- en: Inside each chapter's folder there are folders for assets, such as CSS, JavaScript,
    and images. Each route also has a folder with a single `index.html` file. This
    allows the application to use extensionless URLs. The data files are stored under
    the API folder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个章节的文件夹中，有用于资产（如 CSS、JavaScript 和图像）的文件夹。每个路由都有一个包含单个 `index.html` 文件的文件夹。这允许应用程序使用无扩展名的
    URL。数据文件存储在 API 文件夹下。
- en: 'The application consists of the following pages:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由以下页面组成：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each page is a static page, pre-rendered as part of the site build process.
    The logic behind this is beyond the scope of this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面都是一个静态页面，作为网站构建过程的一部分预先渲染。背后的逻辑超出了本书的范围。
- en: The application's data comes from the iTunes API. It did require some data manipulation
    to make it usable in the application. I have included the raw data files in the
    GitHub repository if you would like to use or study them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的数据来自iTunes API。它确实需要一些数据处理才能在应用程序中使用。如果您想使用或研究这些数据，我已经将这些原始数据文件包含在GitHub仓库中。
- en: The Apple data model needs to be transformed for the application. Instead of
    standing up a web server to host a formal API, the data is stored in a series
    of JSON files. The application will reference those files as needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的数据模型需要转换为应用程序。而不是建立一个Web服务器来托管正式的API，数据存储在一系列JSON文件中。应用程序将根据需要引用这些文件。
- en: The service worker is in the application's root folder. This file is the centerpiece
    of this chapter and we will spend most of our time changing it in each chapter.
    It will demonstrate the service worker life cycle and basic caching concepts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者位于应用程序的根目录中。这个文件是本章的核心，我们将花费大部分时间在每个章节中修改它。它将演示服务工作者生命周期和基本缓存概念。
- en: 'You can try the finished version at [https://podcast.love2dev.com](https://podcast.love2dev.com):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试完成的版本，请访问[https://podcast.love2dev.com](https://podcast.love2dev.com)：
- en: '![](img/00050.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: Home page of PWA Podstr
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PWA Podstr的首页
- en: 'The home page contains a list of podcasts that the user is subscribed to. This
    is populated by an API call to retrieve the list. It is then rendered in the browser
    using `Mustache`. All API data is a set of JSON files, so there is no messy code
    needed to connect and stand up a database:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首页包含用户订阅的播客列表。这是通过API调用检索列表来填充的。然后使用`Mustache`在浏览器中渲染。所有API数据都是一组JSON文件，因此不需要编写杂乱的代码来连接和建立数据库：
- en: '![](img/00051.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: 'The podcast page displays details about the podcast and a list of recent episodes.
    The podcast data is also retrieved via an API call:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 播客页面显示了播客的详细信息以及最近集锦的列表。播客数据也是通过API调用检索的：
- en: '![](img/00052.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: 'The episode page lists the title and description of an episode. It includes
    an AUDIO element that plays the mp3 file. Again, the page is rendered after retrieving
    the data from the server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 集锦页面列出了集锦的标题和描述。它包括一个播放mp3文件的AUDIO元素。同样，页面在从服务器检索数据后进行渲染：
- en: '![](img/00053.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: The Fetch API
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fetch API
- en: Way back in 1996, Internet Explorer introduced the *iframe* element as a way
    to load web content asynchronously in a web page. Over the next two years, the
    concept evolved into the first implementation of what we now know as the `XMLHttpReqest`
    object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回到1996年，Internet Explorer引入了*iframe*元素，作为在网页中异步加载网页内容的一种方式。在接下来的两年里，这个概念发展成了我们现在所知道的`XMLHttpRequest`对象的第一种实现。
- en: Back then, it was known as `XMLHTTP` and was first shipped in Internet Explorer
    5.0\. Soon after, Mozilla, Safari, and Opera all shipped implementations of what
    we now call `XMLHttpRequest`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，它被称为`XMLHTTP`，并首次在Internet Explorer 5.0中发布。不久之后，Mozilla、Safari和Opera都发布了我们现在称之为`XMLHttpRequest`的实现。
- en: Up to this point, web pages were static and required an entire reload when a
    user navigated from one page to another inside the same site.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，网页是静态的，当用户在同一个站点内从一个页面导航到另一个页面时，需要整个页面重新加载。
- en: In 2004, Google started making wide use of what we now call **AJAX** in Gmail
    and Google Maps. They showed us how to leverage in-browser requests to the server
    and how to manipulate the DOM in response to the server's payload. This is typically
    done by calling an API that returns JSON data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在2004年，谷歌开始在Gmail和Google Maps中广泛使用我们现在称之为**AJAX**的技术。他们向我们展示了如何利用浏览器对服务器的请求以及如何根据服务器的有效载荷来操作DOM。这通常是通过调用返回JSON数据的API来完成的。
- en: As with any technology, as it is used, **implementers** get frustrated dealing
    with issues revealed through usage. In response to new use cases and issues, the
    technology updates, typically by releasing a new version.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何技术一样，随着它的使用，**实施者**在处理使用过程中暴露的问题时会感到沮丧。为了应对新的用例和问题，技术会更新，通常是通过发布新版本。
- en: Sometimes, those updates are so major a new technology, product, or implementation
    replaces the first version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些更新如此重大，以至于新的技术、产品或实现取代了第一个版本。
- en: '`XMLHttpRequest` provides a mechanism to make asynchronous calls to the server,
    but does so based on how the web and browsers worked over a decade ago.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest`提供了一种机制来对服务器进行异步调用，但它基于十年前网络和浏览器的工作方式。'
- en: Today, the web has expanded in many ways. One feature we now have ubiquitous
    support for is JavaScript Promises. We also have deeper insight into what types
    of content can be made using asynchronous calls to a server that we did not think
    about when AJAX was first being specified.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，网络在许多方面都得到了扩展。我们现在普遍支持的一个特性是JavaScript Promises。我们也对可以使用异步调用服务器的内容类型有了更深入的了解，这些内容类型是我们当初在AJAX最初被指定时没有考虑到的。
- en: Introducing Fetch
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Fetch
- en: After identifying common limitations of the `XMLHttpRequest` object, the Fetch
    API was standardized to provide a new, better thought out way to implement asynchronous
    HTTP requests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了`XMLHttpRequest`对象的常见限制之后，Fetch API被标准化，以提供一种新的、经过深思熟虑的方式来实现异步HTTP请求。
- en: The Fetch API is a brand new way to make AJAX calls. It was created to solve
    many of the problems we developers hack and work around to handle `XMLHttpRequest`
    limitations. The primary difference is that Fetch is asynchronous when using Promises.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API是制作AJAX调用的一种全新的方式。它被创建出来是为了解决我们开发者为了处理`XMLHttpRequest`限制而进行的许多黑客式和绕道工作。主要区别在于，当使用Promises时，Fetch是异步的。
- en: It first started seeing browser implementations in the Spring of 2016 and now
    enjoys broad support by all modern browsers. If you have not started using Fetch
    to make asynchronous HTTP requests, you should start migrating as soon as possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它最初在2016年春季开始看到浏览器实现，现在所有现代浏览器都广泛支持。如果你还没有开始使用Fetch来制作异步HTTP请求，你应该尽快开始迁移。
- en: 'Three key features that make Fetch stand apart from the `XMLHttpRequest` object
    is simpler syntax, native promise support, and the ability to manipulate requests
    and responses:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch与`XMLHttpRequest`对象区别的三个关键特性是更简单的语法、原生的promise支持和能够操作请求和响应：
- en: '![](img/00054.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.jpeg)'
- en: Using the Fetch API
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fetch API
- en: 'Because AJAX has become a popular way to drive DOM manipulations, let''s see
    how this is done using Fetch. This will be a slightly contrived example where
    a Podcast''s logo is fetched and set to the corresponding `IMG` element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AJAX已经成为驱动DOM操作的一种流行方式，让我们看看如何使用Fetch来实现这一点。这将会是一个稍微人为构造的例子，其中Podcast的标志被获取并设置到相应的`IMG`元素中：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are familiar with composing an `XMLHttpRequest`, this example should
    look very clean and simple. The first thing you will notice is that the only parameter
    needed is a URL. This is the simplest form of fetch.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉如何组合`XMLHttpRequest`，这个例子看起来应该非常干净和简单。你首先会注意到，唯一需要的参数是一个URL。这是fetch的最简单形式。
- en: 'This code does the same thing, but uses the `XMLHttpRequest` object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做的是同样的事情，但使用了`XMLHttpRequest`对象：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is not quite as clean and not asynchronous. This example is rather simple.
    In most cases, AJAX requests require more complexity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全干净，也不是异步的。这个例子相当简单。在大多数情况下，AJAX请求需要更多的复杂性。
- en: The fetch method returns a promise, which resolves a response object. This represents
    that response, not the image we wanted. Access to the image is done by calling
    the blob mixin, which also returns a promise.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`方法返回一个promise，它解析一个响应对象。这代表的是响应，而不是我们想要的图片。通过调用blob mixin来访问图片，它也返回一个promise。'
- en: The blob is the image, which can then be used by the `URL.createObjectUrl` function
    to convert the bytes to a usable image format that can be applied to the image's
    src property.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Blob是图片，然后可以使用`URL.createObjectUrl`函数将其字节转换为可用的图片格式，并将其应用于图片的src属性。
- en: While contrived, this example demonstrates multiple aspects of the Fetch API
    you should familiarize yourself with. The API provides a simple surface to make
    requests, but allows you to make very complex request handler logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子是人为构造的，但它展示了Fetch API的多个方面，你应该熟悉这些方面。API提供了一个简单的表面来发起请求，但它允许你实现非常复杂的请求处理逻辑。
- en: Along with the fetch method, the API also specifies request, response, and header
    objects. There is also a collection of body mixins, designed to manipulate different
    response types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`fetch`方法外，API还指定了请求、响应和头对象。还有一个body mixins集合，用于操作不同的响应类型。
- en: Instead of passing just the URL to the fetch method, you can also pass a composed
    request object. A request object contains the values to make network requests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向`fetch`方法传递URL，还可以传递一个组合的请求对象。请求对象包含进行网络请求的值。
- en: The request constructor has two parameters, the URL and an optional options
    object. You can also supply an existing request object, which may sound odd, but
    as you learn how to use service workers, you will realize this will be a common
    starting point.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请求构造函数有两个参数，即URL和一个可选的选项对象。你也可以提供一个现有的请求对象，这听起来可能有些奇怪，但随着你对服务工作者学习的深入，你会意识到这将成为一个常见的起点。
- en: 'The options parameter can contain the following properties:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 选项参数可以包含以下属性：
- en: '`method`: The HTTP request method: `GET`, `POST`, `PUT`, `DELETE`, and so on.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：HTTP请求方法：`GET`、`POST`、`PUT`、`DELETE`等。'
- en: '`headers`: Custom request headers, which can be either a headers object or
    an object literal.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：自定义请求头，可以是头对象或对象字面量。'
- en: '`body`: Any body that you want to add to your request: a `Blob`, `BufferSource`,
    `FormData`, `URLSearchParams`, `USVString`, or `ReadableStream` object.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：你想要添加到请求中的任何主体：一个`Blob`、`BufferSource`、`FormData`、`URLSearchParams`、`USVString`或`ReadableStream`对象。'
- en: '`mode`: The request mode, for example, `cors`, `no-cors`, `same-origin`, or
    `navigate`. The default is `cors`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：请求模式，例如，`cors`、`no-cors`、`same-origin`或`navigate`。默认是`cors`。'
- en: '`credentials`: The requested credentials you want to use for the request: omit,
    same-origin, or include.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`credentials`：你想要用于请求的请求凭据：omit、same-origin或include。'
- en: '`cache`: Similar to the properties used in the Cache-Control header. This tells
    the browser how to interact with the local cache.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`：类似于Cache-Control头中使用的属性。这告诉浏览器如何与本地缓存交互。'
- en: Other, less common properties are cache, redirect, referrer, and integrity.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其他不太常见的属性是cache、redirect、referrer和integrity。
- en: 'We can use the preceding example and expand it to use a custom request object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的示例并扩展它以使用自定义请求对象：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should note that the fetch method will only reject when there is a network
    error. When an exception is thrown, the network cannot be reached, for example,
    when the device is offline. It will not fail for a non-2XX status code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，fetch方法只有在出现网络错误时才会拒绝。当抛出异常时，网络无法访问，例如，当设备离线时。它不会因为非2XX状态码而失败。
- en: This means you must validate the response as being good, not found, a redirect,
    or a server error. You can build a robust logic tree to handle different status
    codes. If all you need to do is respond to a good request, you can use the `response.ok`
    property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须验证响应是良好的、未找到、重定向还是服务器错误。你可以构建一个健壮的逻辑树来处理不同的状态码。如果你只需要响应良好的请求，你可以使用`response.ok`属性。
- en: If the response has a 200-299 status, good, then the ok property is true. Otherwise,
    it is false.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应的状态是200-299，即良好，那么ok属性为真。否则，为假。
- en: You should handle exceptions differently than responses with status code. For
    example, if a response has a status code of 403, then you could redirect to a
    login form. A 404 status should redirect to a not found page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该以不同的方式处理异常和具有状态码的响应。例如，如果一个响应的状态码是403，那么你可以重定向到一个登录表单。404状态应该重定向到一个未找到页面。
- en: If there is a network error, then you could trigger an appropriate visual response
    like an error message or triggering your application’s offline mode experience.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现网络错误，你可以触发适当的视觉响应，如错误消息或触发应用程序的离线模式体验。
- en: The response object
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应对象
- en: The fetch method resolves a response object. This is similar to the request
    object, with a few differences. It represents a server response for a request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: fetch方法解析响应对象。这与请求对象类似，但有几个区别。它代表对请求的服务器响应。
- en: 'The response object has the following properties:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象具有以下属性：
- en: '`headers`: The headers object'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：头对象'
- en: '`ok`: Indicates if the status in in the 200-299 range'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`：指示状态是否在200-299范围内'
- en: '`redirected`: Indicates if the response is from a redirect'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirected`：指示响应是否来自重定向'
- en: '`status`: The HTTP status code, for example, 200 for good'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：HTTP状态码，例如，200表示良好'
- en: '`statusText`: The status message of the corresponding code'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusText`：对应代码的状态消息'
- en: '`type`: The type of response, for example, cors or basic'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：响应类型，例如，cors或basic'
- en: '`url`: The response URL'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：响应URL'
- en: '`bodyUsed`: A Boolean indicating whether the body has been used'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyUsed`：一个布尔值，指示主体是否已被使用'
- en: 'There are several methods you should also know about:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该了解以下几种方法：
- en: '`clone`: Makes a clone of the response object'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone`：创建响应对象的副本'
- en: '`arrayBuffer`: Returns a promise that resolves to an `arrayBuffer`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayBuffer`：返回一个解析为`arrayBuffer`的承诺'
- en: '`blob`: Returns a promise that resolves to a blob'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blob`：返回一个解析为blob的承诺'
- en: '`formData`: Returns a promise that resolves to a `formData` object'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formData`: 返回一个解析为 `formData` 对象的承诺'
- en: '`json`: Returns a promise that resolves the body text to a JSON object'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json`: 返回一个解析正文为 JSON 对象的承诺'
- en: '`text`: Returns a promise that resolves the body text'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`: 返回一个解析正文为承诺'
- en: The preceding example showed how to use the blob method to create an image.
    A more common task web apps have is retrieving data from an API. Typically, the
    response is text, containing a JSON.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何使用 blob 方法创建图像。网络应用程序更常见的任务是从 API 获取数据。通常，响应是文本，包含 JSON。
- en: A common user task in a podcast application is to search for podcasts and episodes.
    Our podcast application has a search form built into the layout header. It has
    logic bound to it to call an API and return a set of results.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在播客应用程序中，一个常见的用户任务是在播客和剧集之间进行搜索。我们的播客应用程序在布局标题中集成了搜索表单。它绑定了一些逻辑来调用 API 并返回一组结果。
- en: The Podstr application uses a single JSON file to serve as an example search
    result. This is done so we do not need to build a server-side search infrastructure.
    A production application would have a more formal setup.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Podstr 应用程序使用单个 JSON 文件作为示例搜索结果。这样做是为了我们不需要构建服务器端搜索基础设施。生产应用程序将有一个更正式的设置。
- en: 'The search results are formatted to contain two arrays, a list of matching
    podcasts, and another for matching episodes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果格式化为包含两个数组，一个是匹配的播客列表，另一个是匹配的剧集列表：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The search results are displayed on the search page by rendering the results
    against a template. Retrieving the results is done via a fetch request that uses
    the JSON method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果通过在模板上渲染结果来在搜索页面上显示。检索结果是通过使用 JSON 方法的 fetch 请求完成的：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `renderResults` function runs the results object through a `Mustache` template
    and assigns the rendered markup to the `search-results` element:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderResults` 函数将结果对象通过 `Mustache` 模板运行，并将渲染的标记分配给 `search-results` 元素：'
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you are not familiar with `Mustache`, it is a minimalist template engine.
    The render method takes an HTML template and merges a JSON object to produce markup.
    If you want to know more about using `Mustache`, visit the GitHub page ([https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 `Mustache`，它是一个极简模板引擎。渲染方法接受一个 HTML 模板，并将 JSON 对象合并以生成标记。如果你想了解更多关于使用
    `Mustache` 的信息，请访问 GitHub 页面 ([https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/))。
- en: The search page demonstrates how to make an API call to dynamically compose
    a page. This is common for web applications today. We don't go back and forth
    and let the server render new markup in response to an action, like submitting
    a form.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索页面展示了如何动态组合页面进行 API 调用。这在今天的网络应用程序中很常见。我们不再来回走动，让服务器根据操作（如提交表单）渲染新的标记。
- en: Instead, we migrated to a model that has evolved to what we commonly call a
    single page application. Pages are no longer static experiences, we can change
    them dynamically.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们迁移到了一个演变成我们通常称为的单页应用程序的模式。页面不再是静态体验，我们可以动态地更改它们。
- en: The ability to make an API call to the server without making a complete round
    trip. Fetch makes this possible and simpler than before. Template libraries like
    `Mustache` make it simple to render markup on the client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不进行完整往返的情况下向服务器发起 API 调用。Fetch 使得这成为可能，并且比之前更简单。模板库如 `Mustache` 使得在客户端渲染标记变得简单。
- en: If you are familiar with jQuery's ajax method, you will note some similarities
    to fetch. There are few key differences.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 jQuery 的 ajax 方法，你会注意到与 fetch 的一些相似之处。但也有一些关键的区别。
- en: The promise returned from `fetch()` won't reject on HTTP error status, even
    if the response is an HTTP 404 or 500 error. Instead, it will resolve normally
    (with the `ok` status set to false), and it will only reject on network failure
    or if anything prevented the request from completing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `fetch()` 返回的承诺不会在 HTTP 错误状态上拒绝，即使响应是 HTTP 404 或 500 错误。相反，它将正常解析（`ok` 状态设置为
    false），并且只有在网络失败或任何阻止请求完成的情况下才会拒绝。
- en: By default, fetch won't send or receive any cookies from the server, resulting
    in unauthenticated requests if the site relies on maintaining a user session (to
    send cookies, the credentials init option must be set).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，fetch 不会从服务器发送或接收任何 cookies，如果网站依赖于维护用户会话（要发送 cookies，必须设置 credentials
    初始化选项），则会导致未认证的请求。
- en: Service worker fetch
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者 fetch
- en: Service workers rely on promises and asynchronous APIs. This eliminates platform
    features such as `XMLHttpRequest` from being used in a service worker. Service
    workers are dependent on the browser supporting promises and the fetch API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者依赖于promises和异步API。这消除了在服务工作者中使用`XMLHttpRequest`等平台功能。服务工作者依赖于浏览器支持promises和fetch
    API。
- en: 'A basic understanding of using fetch is a fundamental skill required for service
    worker programming. Service workers allow you to intercept all network requests
    before they are sent to the network. This is done by adding a fetch event handler:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对fetch的基本理解是服务工作者编程所需的基本技能。服务工作者允许你在网络请求发送到网络之前拦截所有网络请求。这是通过添加一个fetch事件处理器来完成的：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The event handler receives a single `FetchEvent` object. There are two members
    of the `FetchEvent` object you need to know, which are `request` and `respondWith`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器接收一个单一的`FetchEvent`对象。你需要了解`FetchEvent`对象的两个成员，它们是`request`和`respondWith`。
- en: The request property is the request object is being sent to the network. The
    `respondWith` method restricts the fetch event handler. It keeps the event handler
    *open* until the response is ready. The method also requires a response object
    to be returned.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请求属性是正在发送到网络的请求对象。`respondWith`方法限制了fetch事件处理器。它保持事件处理器*打开*，直到响应准备好。该方法还需要返回一个响应对象。
- en: The service worker fetch event allows you to intercept requests to the network.
    This power allows you to interrogate the request and return a cached response,
    compose a custom response, or return a network response. We will cover ways to
    use this power in the service worker caching chapters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者fetch事件允许你拦截对网络的请求。这种力量允许你调查请求并返回一个缓存的响应，组合一个自定义响应，或者返回一个网络响应。我们将在服务工作者缓存章节中介绍如何使用这种力量的方法。
- en: Polyfilling fetch in legacy browsers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在旧版浏览器中polyfill fetch
- en: Fetch and other modern APIs enjoy broad support by major browsers. However,
    there is still enough users using older browsers. Many enterprises still require
    employees to use obsolete versions of Internet Explorer. Many consumers that are
    happy with older phones and do not upgrade their devices or update software often.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch和其他现代API得到了主流浏览器的广泛支持。然而，仍然有足够的用户在使用较旧的浏览器。许多企业仍然要求员工使用过时的Internet Explorer版本。许多消费者对旧手机感到满意，不升级他们的设备或更新软件。
- en: This means we need to make our websites adaptable to these potential scenarios.
    Fortunately, many APIs can be polyfilled with JavaScript libraries. Fetch and
    promises are modern features that can easily be polyfilled.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要使我们的网站适应这些潜在的情景。幸运的是，许多API可以用JavaScript库进行polyfill。Fetch和promises是现代功能，可以轻松地进行polyfill。
- en: 'Just like we feature detect service worker support, we can feature detect fetch
    and promise support. If those features are not supported, we can then load a polyfill.
    It is important that these polyfills are loaded in a dependent order where promises
    are followed by fetch, which is then followed by any site-specific code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们检测服务工作者支持一样，我们也可以检测fetch和promise支持。如果这些功能不受支持，那么我们可以加载一个polyfill。重要的是这些polyfills需要按照依赖顺序加载，其中promise之后是fetch，然后是任何特定于网站的代码：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a technique of asynchronously loading scripts I borrowed from an HTML5
    Rocks article ([https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread](https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread)).
    Most of the time, the polyfills are not needed, but for those cases where a polyfill
    is needed, you need to control the order the scripts are loaded in.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种从HTML5 Rocks文章中借用的异步加载脚本的技巧（[https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread](https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread)）。大多数时候，polyfills是不需要的，但对于那些需要polyfill的情况，你需要控制脚本加载的顺序。
- en: The technique uses an array of script URLs and loops through them, appending
    each to the DOM while maintaining an order of dependence.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用一系列脚本URL，并遍历它们，将每个添加到DOM中，同时保持依赖顺序。
- en: Because the polyfills are not needed all the time, they are only added as necessary.
    This is determined by checking for native support. In the example code, both promise
    and fetch are detected. If they are not supported, then they are added to the
    array of script URLs and are added before the other scripts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于polyfills不是总是需要的，它们只有在必要时才添加。这是通过检查原生支持来确定的。在示例代码中，promise和fetch都被检测到。如果不支持，则将它们添加到脚本URL数组中，并在其他脚本之前添加。
- en: Promises are also checked because fetch depends on promise support. The Podstr
    application only needs to potentially use the fetch and promise polyfill.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺也被检查，因为fetch依赖于promise支持。Podstr应用程序只需要可能使用fetch和promise polyfill。
- en: But there are many API polyfills that your application might need. The HTML5
    Cross Browser polyfill ([https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills)
    ) repository is a great place to find more. You can use the same feature detection
    technique to add them as necessary.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能有许多API polyfill您的应用程序可能需要。HTML5跨浏览器polyfill([https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills)
    )存储库是一个寻找更多资源的好地方。您可以使用相同的功能检测技术根据需要添加它们。
- en: Creating a service worker shell
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务工作者外壳
- en: In [Chapter 1](part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d), *Introduction
    to Progressive Web Apps*, we created a basic service worker that pre-cached the
    2048 game assets. In this and the following chapters, we will dive deeper into
    the details of a service worker.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d)，“渐进式Web应用简介”中，我们创建了一个基本的service
    worker，它预先缓存了2048游戏资源。在本章和接下来的章节中，我们将更深入地探讨service worker的细节。
- en: The service worker goes through several stages in its overall life cycle. A
    service worker is registered. Once the script is loaded, it triggers the ‘install’
    event. At this point, the service worker is not in control of the client (browser
    tab).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者在其整体生命周期中经过几个阶段。服务工作者被注册。一旦脚本被加载，它就会触发“安装”事件。此时，服务工作者不控制客户端（浏览器标签页）。
- en: When the service worker is cleared to control client contexts, the activate
    event is triggered. After this, the service worker is fully active and in control
    of any active clients, be they tabs or background processes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务工作者被清除以控制客户端上下文时，激活事件被触发。在此之后，服务工作者完全活跃并控制任何活跃的客户端，无论是标签页还是后台进程。
- en: Proper service workers take advantage of the event life cycle to manage data,
    like cached responses, to set the service worker context.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 合适的服务工作者利用事件生命周期来管理数据，如缓存的响应，以设置服务工作者上下文。
- en: 'The podcast application starts with a simple service worker script containing
    handlers for the install, activate, and fetch events:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 播客应用程序从包含安装、激活和fetch事件处理器的简单服务工作者脚本开始：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As these chapters progress, we will fill in code to use each of these handlers.
    These updates will demonstrate the service worker life cycle, common caching techniques,
    and other important service worker concepts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些章节的进展，我们将填充代码以使用每个这些处理器。这些更新将展示服务工作者生命周期、常见的缓存技术以及其他重要的服务工作者概念。
- en: The service worker life cycle
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者生命周期
- en: Service workers obey a known life cycle that allows a new service worker to
    get itself ready without disrupting the current one. The life cycle is designed
    for the best user experience.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者遵循一个已知的生命周期，允许新的服务工作者在不干扰当前服务工作者的情况下准备自己。生命周期是为最佳用户体验而设计的。
- en: When a service worker is registered, it does not immediately seize control of
    the client. There are rules designed to minimize errors due to differences in
    code versions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务工作者被注册时，它不会立即控制客户端。有一些规则旨在最小化由于代码版本差异而导致的错误。
- en: If a new service worker just took control of a client’s context when it is expecting
    a previous version’s logic, there could be issues. Even though the service worker
    operates on a separate thread, the UI code could have dependencies on the service
    worker logic or cached assets. If the new version breaks, the front-end your user
    experience could go sideways.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的服务工作者在期望前一个版本逻辑时控制了客户端上下文，可能会出现问题。尽管服务工作者在单独的线程上操作，但UI代码可能依赖于服务工作者逻辑或缓存资源。如果新版本破坏，用户的用户体验可能会受到影响。
- en: 'The life cycle is designed to ensure that an in-scope page or task is controlled
    by the same service worker (or no service worker) throughout its session:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期旨在确保在会话期间，作用域内的页面或任务始终由同一服务工作者（或没有服务工作者）控制：
- en: '![](img/00055.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: The life cycle consists of the registration, installation, and activation steps.
    The installation and activation events can have handlers bound that perform specific
    tasks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期包括注册、安装和激活步骤。安装和激活事件可以绑定处理器以执行特定任务。
- en: The life cycle also covers service worker updates and unregistration. These
    last two tasks may not be used as often, but developers should still be familiar
    with how they work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期还包括服务工作者更新和注销。这两个任务可能不会经常使用，但开发者仍然应该熟悉它们的工作方式。
- en: Each stage can be used for different process phases to manage the service worker,
    cached assets, and possibly state data. The following chapter goes into details
    about the life cycle and how each phase can be used to make your application more
    performant and easier to manage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都可以用于不同的处理阶段来管理服务工作者、缓存资源和可能的状态数据。下一章将详细介绍生命周期以及如何利用每个阶段来提高应用程序的性能并使其更容易管理。
- en: You will learn how to register, update, and remove a service worker. You will
    also learn the service worker’s scope and the definition of a service worker client.
    The chapter will also cover the install and activate events so that you can add
    code to manage the service worker’s cache and active state.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何注册、更新和删除服务工作者。你还将了解服务工作者的作用域和服务工作者客户端的定义。本章还将涵盖安装和激活事件，以便你可以添加代码来管理服务工作者的缓存和活动状态。
- en: Caching
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: One of the most important progressive web application features is the ability
    to work offline and load instantly. Service worker caching enables this super
    power. In the past, websites could function offline and even gain some performance
    benefits via `appCache`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的渐进式网络应用程序功能之一是能够在离线状态下工作并即时加载。服务工作者缓存实现了这种超级功能。在过去，网站可以在离线状态下运行，甚至可以通过`appCache`获得一些性能优势。
- en: Service worker caching supersedes `appCache` and provides a better programmatic
    interface. `AppCache` is notorious for being difficult to manage and maintain.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者缓存取代了`appCache`并提供了更好的程序化接口。`AppCache`因其难以管理和维护而臭名昭著。
- en: When your page references an `appCache` manifest file and has a registered service
    worker, the service worker manages cache and the `appCache` is bypassed. This
    makes service worker caching a progressive enhancement from `appCache` and makes
    it safe to use both.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的页面引用了`appCache`清单文件并且有注册的服务工作者时，服务工作者管理缓存，而`appCache`被绕过。这使得服务工作者缓存成为从`appCache`的渐进式增强，并且使用它们是安全的。
- en: By enabling caching, service workers make the network a progressive enhancement.
    Because the service worker cache API is very low level, it requires the developer
    to apply custom logic to manage how network resources are cached and retrieved.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用缓存，服务工作者使网络成为渐进式增强。因为服务工作者缓存API非常底层，它要求开发者应用自定义逻辑来管理网络资源如何被缓存和检索。
- en: This leaves lots of room for creativity to apply different caching strategies
    in your application. Chapter 6,* Master the Cache API- Manage Web Assets in a
    Podcast Application,* dives into the core service worker caching concepts you
    need to master.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这为在你的应用程序中应用不同的缓存策略留下了很大的空间。第6章，“掌握缓存API - 在播客应用程序中管理Web资源”，深入探讨了你需要掌握的核心服务工作者缓存概念。
- en: Using push notifications
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用推送通知
- en: Businesses have been using push to engage customers, even if their app is not
    open, for about a decade now. And why not? Research shows some impressive numbers
    related to brand engagement and revenue directly correlated with the tiny interruptions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 商业已经使用推送来吸引客户，即使他们的应用程序没有打开，也已经大约十年了。为什么不呢？研究表明，与品牌参与度和收入直接相关的数据相当令人印象深刻，这些数据与微小的中断有关。
- en: 'For example, Google has shared the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，谷歌分享了以下内容：
- en: 72% increase in time spent for users visiting via a push notification
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过推送通知访问的用户时间增加了72%
- en: 26% increase in average spend per visit by members arriving via a push notification
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过推送通知到达的会员平均消费增加了26%
- en: +50% repeat visits within 3 months
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +50% 在3个月内重复访问量增加
- en: These values all point to the reason why brand and product managers love push
    notifications. Unfortunately, up to recent times, the web has been left out of
    this party. Many businesses have opted to go through the hassle of a native app
    solely to send push notifications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值都指向品牌和产品经理为什么喜欢推送通知的原因。不幸的是，直到最近，网络一直被排除在这个派对之外。许多企业选择通过原生应用程序的麻烦来发送推送通知。
- en: The Push API gives web applications the ability to receive messages pushed to
    them from a server, whether or not the web app is in the foreground, or even currently
    loaded, on a user agent.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Push API为网络应用程序提供了从服务器接收消息推送的能力，无论网络应用程序是否在前台，或者当前是否在用户代理上加载。
- en: Implementing push in your application requires a server-based service, typically
    a cloud based service such as Google Cloud Messenger or AWS Pinpoint. There are
    numerous providers available.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中实现推送通知需要基于服务器的服务，通常是云基础服务，如Google Cloud Messenger或AWS Pinpoint。有众多提供商可供选择。
- en: Don't worry about your push provider. Web push notifications are based on an
    IETF standard, Generic Event Delivery Using HTTP Push ([https://tools.ietf.org/html/draft-ietf-webpush-protocol-12](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)).
    Make sure your provider is compliant and you should have no problems.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心您的推送提供商。Web推送通知基于IETF标准，即使用HTTP推送的通用事件交付（[https://tools.ietf.org/html/draft-ietf-webpush-protocol-12](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)）。请确保您的提供商符合标准，您应该不会遇到任何问题。
- en: At the time of writing this book, Chrome, FireFox, Samsung Internet, and Opera
    currently ship push notification support. Microsoft Edge is in the process of
    shipping support. Apple has not released a potential timeline for Safari support.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Chrome、Firefox、Samsung Internet和Opera目前都提供了推送通知支持。Microsoft Edge正在推出支持。苹果尚未发布Safari支持的时间表。
- en: It is important to note that each browser or user agent acts independently from
    other browsers. If a customer loads your web page from more than one browser,
    each will register a service worker. If each one also creates a push notification
    subscription, the user could receive multiple notifications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，每个浏览器或用户代理都独立于其他浏览器。如果客户从多个浏览器加载您的网页，每个浏览器都会注册一个服务工作者。如果每个浏览器还创建了推送通知订阅，用户可能会接收到多个通知。
- en: This makes managing subscription logic in your application’s service logic important.
    This is outside the scope of this book. As part of production logic, it is a good
    idea to query your server before attempting to register a user for push notifications.
    There are several options to handle this potential situation and you will need
    to determine what is best for your application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在您的应用程序服务逻辑中管理订阅逻辑变得很重要。这超出了本书的范围。作为生产逻辑的一部分，在尝试为推送通知注册用户之前查询您的服务器是一个好主意。有几种选项可以处理这种潜在情况，您需要确定最适合您应用程序的方案。
- en: If your brand also has a native app that offers push notifications, they will
    also be a separate subscription. This means you should track if the customer already
    receives notifications on the device as best as you can to avoid duplicating messages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的品牌也有提供推送通知的原生应用，那么它们也将是单独的订阅。这意味着您应该尽可能跟踪客户是否已经在设备上接收到了通知，以避免重复发送消息。
- en: Implementing push notifications
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现推送通知
- en: 'In this section, you will learn some fundamentals of implementing push notifications:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习实现推送通知的一些基础知识：
- en: How to subscribe and unsubscribe a user for push messaging
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何订阅和取消订阅用户的推送消息
- en: How to handle incoming push messages
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理传入的推送消息
- en: How to display a notification
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何显示通知
- en: How to respond to notification clicks
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何响应用户点击通知
- en: The code is part of the Podstr application. I won't cover how to set up a push
    provider because they vary too much and are prone to changes to their administration
    interfaces. This creates a fluid environment that would only serve to create confusion
    with readers and potential providers. Plus, singling out a single provider could
    create an unwanted bias. Most providers have current documentation and JavaScript
    SDKs to help you create the server-side environment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是Podstr应用程序的一部分。我不会介绍如何设置推送提供商，因为它们差异很大，且易于更改其管理界面。这会创造一个流动的环境，只会给读者和潜在提供商带来困惑。此外，单独强调一个提供商可能会产生不希望的偏见。大多数提供商都有当前的文档和JavaScript
    SDK，可以帮助您创建服务器端环境。
- en: If you would like to stand up your own push service, Matt Gaunt, of the Google
    Chrome team, has published an example server you can clone ([https://github.com/web-push-libs/web-push](https://github.com/web-push-libs/web-push)).
    This might serve as a decent test service, but I would not consider it a production
    quality service.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想建立自己的推送服务，Google Chrome团队的马特·高恩（Matt Gaunt）已经发布了一个您可以克隆的示例服务器（[https://github.com/web-push-libs/web-push](https://github.com/web-push-libs/web-push)）。这可能作为一个不错的测试服务，但我不会将其视为生产级别的服务。
- en: 'For our purposes, the Chrome developer tools provide enough to trigger the
    client-side logic and experience. You can find a link to the right of a registered
    service workers detail to emulate a push event:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，Chrome开发者工具提供了足够的功能来触发客户端逻辑和体验。您可以在注册的服务工作者详情右侧找到一个链接来模拟推送事件：
- en: '![](img/00056.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: 'This link triggers an emulated push message with a simple payload: Test push
    message from DevTools. The Podstr application will use this event to trigger a
    message we can display to the user about new podcast episodes.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接触发一个带有简单负载的模拟推送消息：来自DevTools的测试推送消息。Podstr应用程序将使用此事件来触发一个我们可以显示给用户的关于新播客剧集的消息。
- en: Setting up push notifications
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置推送通知
- en: 'To enable push notifications, there are several steps you need to follow. The
    first step is detecting if the browser supports push or not. If so, then you can
    proceed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用推送通知，您需要遵循几个步骤。第一步是检测浏览器是否支持推送。如果是的话，然后您可以继续：
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since push is something you would configure after you register the service worker,
    you can check for support once the service worker is registered. Just like checking
    for service worker support, you can check if the window object contains a reference
    to the `PushManager`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于推送是在注册服务工作者之后配置的，因此您可以在服务工作者注册后检查其支持情况。就像检查服务工作者支持一样，您可以检查窗口对象是否包含对`PushManager`的引用。
- en: The `PushManager` has three methods to manage a user's subscription status.
    The `getSubscription` method returns a promise that resolves a `PushSubscription`
    object. If the user is subscribed, the subscription is an object, otherwise it
    is null.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushManager`有三个方法来管理用户的订阅状态。`getSubscription`方法返回一个解析为`PushSubscription`对象的承诺。如果用户已订阅，则订阅是一个对象，否则为null。'
- en: It is up to you how you surface the state of push notifications in your application.
    My personal advice is to hide any visible queues if the browser does not support
    push notifications because it will confuse the consumer.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在您的应用程序中呈现推送通知的状态取决于您。我个人的建议是，如果浏览器不支持推送通知，则隐藏任何可见的队列，因为这会混淆消费者。
- en: Most sites will simply prompt for permission to send push notifications. The
    ability to send notifications is gated behind user approval. The browser displays
    a yes or no dialog when you try to initiate the push notification subscription
    process.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站会简单地提示用户允许发送推送通知。发送通知的能力受用户批准的限制。当您尝试启动推送通知订阅过程时，浏览器会显示是或否的对话框。
- en: 'It is also a good practice to allow users to opt out of push notifications.
    This can be done in application settings or on a configuration page. The Podstr
    application has a settings page that includes options to manage push notifications:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户选择退出推送通知也是一个好的实践。这可以在应用程序设置或配置页面上完成。Podstr应用程序有一个设置页面，其中包括管理推送通知的选项：
- en: '![](img/00057.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: The code to manage push notification subscriptions is covered later in this
    section. You can provide an interface for the user either as a passive option,
    like on the configuration page, or actively via a notification.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 管理推送通知订阅的代码将在本节后面介绍。您可以为用户提供一个界面，无论是作为被动选项，如配置页面，还是通过通知主动提供。
- en: As Android evolves, Chrome and possible other Android browsers will automatically
    convert progressive web apps that are added to the `homescreen` to `WebAPKs`.
    These are native applications that enjoy almost equal status with store apps.
    One feature they should have is the ability to manage push notifications in the
    app through the platform settings applications, but you should never rely on this
    as the only way to turn notifications off.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Android的发展，Chrome和其他可能的Android浏览器将自动将添加到`homescreen`的渐进式Web应用程序转换为`WebAPKs`。这些是享受与商店应用几乎同等地位的本地应用程序。它们应该具备的一个功能是通过平台设置应用程序在应用程序中管理推送通知的能力，但您永远不应该依赖这是关闭通知的唯一方式。
- en: For example, Twitter has adopted progressive web applications and can send notifications.
    I turned this on, but found it was pushing notifications for a single account
    (Scott Hanselman) to my phone. While I like Scott, I was expecting a bit more
    variety.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Twitter已经采用了渐进式Web应用程序并可以发送通知。我打开了它，但发现它只将通知推送到我的手机上的单个账户（Scott Hanselman）。虽然我喜欢Scott，但我期待有更多的多样性。
- en: 'It took me a while to discover how to manage Twitter notifications. I found
    out how to block notifications for the site in Chrome faster:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了很长时间才发现如何管理Twitter通知。我找到了如何在Chrome中更快地阻止该网站通知的方法：
- en: '![](img/00058.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: Twitter has many notification options which require a robust backend to manage.
    The Podstr application uses either an on or off choice. If this were a production
    application, I would build out more logic over time, like Twitter has done.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter有许多需要强大后端来管理的通知选项。Podstr应用程序使用开或关的选择。如果这是一个生产应用程序，我会随着时间的推移构建出更多的逻辑，就像Twitter所做的那样。
- en: Managing the user's subscription
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户的订阅
- en: 'In the example code, if the subscription object does not exist, the `subscribeUser`
    function is invoked. The service worker registration object is passed as the only
    parameter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，如果订阅对象不存在，将调用`subscribeUser`函数。将服务工作者注册对象作为唯一参数传递：
- en: '[PRE12]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `pushManager` subscribe method has a single parameter, an object with two
    properties, `userVisibleOnly` and `applicationServerKey`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushManager`的订阅方法有一个单一参数，即一个具有两个属性的对象，`userVisibleOnly`和`applicationServerKey`。'
- en: The subscribe function returns a promise that resolves after the user has granted
    permission to send notifications and the browser sends a request to the push service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅函数在用户已授予发送通知的权限并且浏览器向推送服务发送请求后返回一个解析的承诺。
- en: As part of the subscribe function work flow, the User Agent is required to prompt
    the user for permission. If this is denied, the promise rejects with a `NotAllowedError`.
    You should always include a catch handler to the subscribe call.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为订阅函数工作流程的一部分，用户代理需要提示用户许可。如果被拒绝，承诺将因`NotAllowedError`而拒绝。您应该始终为订阅调用包括一个catch处理程序。
- en: 'According to the Push Notification specification ([https://w3c.github.io/push-api/#webapp](https://w3c.github.io/push-api/#webapp)):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[推送通知规范](https://w3c.github.io/push-api/#webapp)：
- en: User agents MUST NOT provide Push API access to web apps without the express
    permission of the user. User agents MUST acquire consent for permission through
    a user interface for each call to the `subscribe()` method, unless a previous
    permission grant has been persisted, or a prearranged trust relationship applies.
    Permissions that are preserved beyond the current browsing session MUST be revocable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理不得在未经用户明确许可的情况下向网络应用提供推送API访问权限。用户代理必须通过用户界面为`subscribe()`方法的每次调用获取同意，除非之前的权限授予已被持久化，或者存在预安排的信任关系。超出当前浏览会话的权限必须是可撤销的。
- en: 'The `userVisibleOnly` property is a Boolean that indicates if the push notifications
    will always be visible to the user. Currently, you must set this property to true
    before browsers will let you subscribe a user:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`userVisibleOnly`属性是一个布尔值，表示推送通知是否始终对用户可见。目前，您必须将此属性设置为true，浏览器才会允许您订阅用户：'
- en: '"If developers request the ability to use silent push (the ability to receive
    pushes without triggering a user-visible UI change) we currently reject the request,
    but in the future we plan to introduce a permission to enable this use case"'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: “如果开发者请求使用静默推送（无需触发用户可见的UI变化的能力）的功能，我们目前会拒绝这一请求，但未来我们计划引入一个权限来启用此用例”
- en: – https://goo.gl/ygv404
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: – https://goo.gl/ygv404
- en: '![](img/00059.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: So, for now, you will need to display a message to the end user, even if there
    is no user feedback needed. For example, a caching strategy to update a site’s
    cached assets can be triggered by a push notification. In those scenarios, you
    would display a notification to alert the user to the update.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目前您需要向最终用户显示一条消息，即使不需要用户反馈。例如，可以通过推送通知触发缓存策略来更新网站的缓存资源。在这些场景中，您将显示一个通知来提醒用户更新。
- en: The `applicationServerKey` property is also known as a WEBPUS-VAPID (voluntary
    application server identification for web push ([https://tools.ietf.org/html/draft-ietf-webpush-vapid-04](https://tools.ietf.org/html/draft-ietf-webpush-vapid-04))).
    This value comes from your push service provider. It will be a rather long string
    of random characters and numbers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`applicationServerKey`属性也称为WEBPUS-VAPID（自愿的网络推送应用服务器标识[https://tools.ietf.org/html/draft-ietf-webpush-vapid-04](https://tools.ietf.org/html/draft-ietf-webpush-vapid-04)）。此值来自您的推送服务提供商。它将是一个相当长的随机字符和数字的字符串。'
- en: The value should be base 64 URL safe encoded. The `urlB64ToUnit8Array` function
    converts it to a UInt8Array, which is expected by the subscribe function. The
    `urlB64ToUnit8Array` is a utility function you can find in the Podstr source code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该值应该是base 64 URL安全编码。`urlB64ToUnit8Array`函数将其转换为`UInt8Array`，这是订阅函数所期望的。`urlB64ToUnit8Array`是您可以在Podstr源代码中找到的实用函数。
- en: 'The User Agent should only accept notifications containing the subscribed `applicationServerKey`.
    Per the specification, this is a recommendation and browsers honor that advice:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理应仅接受包含已订阅的`applicationServerKey`的通知。根据规范，这是一个建议，浏览器会遵守这一建议：
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once a subscription has been made, it cannot be altered. You must unsubscribe
    from the initial subscription and create a new subscription with the new options.
    For example, if you should change your push service, the client will need a new
    `applicationServerKey`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建订阅，就不能更改。您必须从初始订阅中退订，并使用新选项创建新的订阅。例如，如果您应该更改您的推送服务，客户端将需要一个新的`applicationServerKey`：
- en: '![](img/00060.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: Like all things in service workers, the subscribe function returns a promise.
    If there is not an exception, it resolves a `PushSubscription` object. This object
    contains various values about the subscription that could be useful to build a
    more robust user experience or management logic.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务工作者中的所有事物一样，订阅函数返回一个承诺（promise）。如果没有异常，它将解析为一个`PushSubscription`对象。此对象包含有关订阅的各种值，这些值可能有助于构建更稳健的用户体验或管理逻辑。
- en: '**Properties** (all read only):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**（所有为只读）：'
- en: '`endpoint`: The subscription endpoint'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint`：订阅端点'
- en: '`expirationTime`: Null unless the subscription has an expiration time'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expirationTime`：除非订阅有过期时间，否则为null'
- en: '`options`: An echo of the options used to create the subscription'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：创建订阅时使用的选项的回声'
- en: '`subscriptionId`: The subscription ID'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriptionId`：订阅ID'
- en: '**Methods:**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**：'
- en: '`getKey`: An `ArrayBuffer` representing the client’s public key'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getKey`：表示客户端公钥的`ArrayBuffer`'
- en: '`toJSON`: A JSON representation of the subscription properties'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toJSON`：订阅属性的JSON表示'
- en: '`unscubscribe`: Initiates a subscriber unsubscription process'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsubscribe`：启动订阅者退订过程'
- en: 'The `updateSubscriptionOnServer` function, called upon a successful subscription,
    would normally be used to update the server. However, for our purposes, it is
    used to echo out the subscription object properties:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功订阅后调用的`updateSubscriptionOnServer`函数通常用于更新服务器。然而，对于我们的目的，它用于回显订阅对象属性：
- en: '[PRE14]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Handling push notifications
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理推送通知
- en: After the consumer has confirmed a push notification subscription, you can send
    messages to the user agent. When a message is sent to the device, it determines
    what service worker to apply the message and trigger a push event.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者确认推送通知订阅后，您可以向用户代理发送消息。当消息发送到设备时，它将确定应用消息的服务工作者并触发推送事件。
- en: The service worker needs a push event handler that receives an event parameter.
    The event object contains the message data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者需要一个推送事件处理程序，该处理程序接收一个事件参数。事件对象包含消息数据。
- en: The sever can send any text in the message. It is up to the service worker to
    parse the message and trigger the appropriate work flow.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以在消息中发送任何文本。这取决于服务工作者解析消息并触发适当的工作流程。
- en: PodStr only manages a new podcast's episode notifications. But a retailer might
    want to promote sales or remind a customer to complete an order. There is really
    no limit to what prompt you might send to your customer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: PodStr仅管理新播客的剧集通知。但零售商可能想要推广销售或提醒客户完成订单。您可能发送给客户的提示实际上没有限制。
- en: The latter message might not be a simple string -- it could be a stringified
    JSON object. If you need to process JSON objects, you will need to test it to
    see if it is a valid object before falling back to a string. The more message
    types you might have, the more complex event handler logic you will need.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 后者消息可能不是一个简单的字符串——它可能是一个字符串化的JSON对象。如果您需要处理JSON对象，您需要测试它以查看它是否是有效的对象，然后再回退到字符串。您可能有的消息类型越多，您需要的事件处理程序逻辑就越复杂。
- en: 'For demonstration purposes, the Podstr push event handler will compose an `options`
    object that contains details about the new episode. This includes the episode
    title and podcast logo:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，Podstr推送事件处理程序将创建一个包含有关新剧集详细信息的`options`对象。这包括剧集标题和播客标志：
- en: '[PRE15]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Push messages are handled by extensions to the core `serviceWorkerRegistration`
    object, which are obtained during the registration process or the `getRegistration`
    method. The method we are interested in is the `showNotification` method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 推送消息由核心`serviceWorkerRegistration`对象的扩展处理，这些扩展在注册过程中或`getRegistration`方法中获取。我们感兴趣的方法是`showNotification`方法。
- en: This method has two parameters, a title and an options object. The title should
    be a string that describes the notification. The Podstr application will use the
    episode’s title.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有两个参数，一个标题和一个选项对象。标题应是一个描述通知的字符串。Podstr应用程序将使用剧集的标题。
- en: The options object allows you to configure the notification and can be a combination
    of several properties.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 选项对象允许您配置通知，可以是几个属性的组合。
- en: '**Notification Object:**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**通知对象**：'
- en: '`actions`: An array of objects that will display action buttons for the user
    to choose from.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions`：一个对象数组，将显示用户可以选择的动作按钮。'
- en: '`badge`: The URL of an image to represent the notification when there is not
    enough space to display the notification itself.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`badge`：当没有足够空间显示通知本身时，表示通知的图像的 URL。'
- en: '`body`: A string to display in the message.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：要显示在消息中的字符串。'
- en: '`dir`: The direction of the notification; it can be auto, ltr, or rtl.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir`：通知的方向；可以是 auto、ltr 或 rtl。'
- en: '`icon`: The URL of the notification icon.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon`：通知图标的 URL。'
- en: '`image`: A string containing the URL of an image to display in the notification.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：包含要显示在通知中的图像 URL 的字符串。'
- en: '`lang`: Must be a valid BCP 47 language tag which is used for the notification
    language.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lang`：必须是有效的 BCP 47 语言标签，用于通知语言。'
- en: '`renotify`: If a notification uses a tag for a repeat display, this can be
    set to true to suppress vibrations and audible notifications.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renotify`：如果通知使用标签进行重复显示，则可以将此设置为 true 以抑制振动和可听通知。'
- en: '`requireInteraction`: On larger screens, if this value is true, the notification
    stays visible until the user dismisses it. Otherwise, Chrome and I assume other
    browsers will minimize the notification after 20 seconds.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requireInteraction`：在较大屏幕上，如果此值为 true，则通知将保持可见，直到用户将其关闭。否则，Chrome 以及我假设的其他浏览器将在
    20 秒后将通知最小化。'
- en: '`tag`: An ID that allows you to find and replace the notification if needed.
    This can be done by calling the `getNotifications` method.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`：一个 ID，允许您在需要时查找和替换通知。这可以通过调用 `getNotifications` 方法来完成。'
- en: '`vibrate`: An array of numbers specifying a vibration sequence. For example,
    `[300, 100, 400]` would vibrate 300 ms, pause 100 ms, then vibrate 400 ms.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vibrate`：一个包含振动序列的数字数组。例如，`[300, 100, 400]` 将振动 300 毫秒，暂停 100 毫秒，然后振动 400
    毫秒。'
- en: '`data`: This is an open field that you can optionally populate anyway you see
    fit. It can be any data type, like a string, number, date, or object.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是一个开放字段，您可以按需填充。它可以任何数据类型，如字符串、数字、日期或对象。'
- en: The `action` property gives you the ability to add one or more action buttons
    to the notification. You can handle this selection in the `notificationClick`
    event handler.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`action` 属性允许您向通知添加一个或多个动作按钮。您可以在 `notificationClick` 事件处理器中处理此选择。'
- en: 'An action object has the following properties:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 动作对象具有以下属性：
- en: '`action`: A `DOMString` identifying a user action to be displayed on the notification'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：一个 `DOMString`，用于标识要在通知上显示的用户动作。'
- en: '`title`: A `DOMString` containing action text to be shown to the user'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：一个包含要显示给用户的动作文本的 `DOMString`。'
- en: '`icon`: [optional] A String containing the URL of an icon to display with the
    action:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon`：[可选] 包含要显示与动作一起的图标的 URL 的字符串：'
- en: '![](img/00061.jpeg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: The Podstr service worker looks for a simple JSON object in the notification
    event's data field. It parses the object and builds a notification object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Podstr 服务工作者在通知事件的 `data` 字段中查找一个简单的 JSON 对象。它解析对象并构建一个通知对象。
- en: 'Be careful trying to parse the text because it may not be a JSON object. The
    best way to handle this situation is to wrap the parse method and associated logic
    in a try catch statement. Not the best scenario, but the only way, for now, to
    handle valid and invalid JSON object parsing:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试解析文本时要小心，因为它可能不是一个 JSON 对象。处理这种情况的最佳方式是将解析方法和相关逻辑包裹在 try catch 语句中。这不是最好的场景，但现在是处理有效和无效
    JSON 对象解析的唯一方法：
- en: '[PRE16]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the notification contains plain text, a generic notification is displayed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通知包含纯文本，则显示一个通用通知。
- en: The `showNotification` method causes the message on the user's device. The function
    returns a promise that resolves a `NotificationEvent`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`showNotification` 方法在用户的设备上显示消息。该函数返回一个解析为 `NotificationEvent` 的承诺。'
- en: Wrapping the `showNotification` method in a `waitUntil` function keeps the event
    handler open until the promise resolves so that the service worker does not terminate.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `showNotification` 方法包裹在 `waitUntil` 函数中可以保持事件处理器打开，直到承诺解析，这样服务工作者就不会终止。
- en: 'A `NotificationEvent` object has two properties: notification and action. The
    notification is a copy of the notification object used to create the notification.
    If there are one or more action buttons in the notification, the action value
    is the action object''s action property defined in the notification object.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationEvent` 对象有两个属性：通知和动作。通知是创建通知时使用的通知对象的副本。如果通知中有一个或多个动作按钮，动作值是通知对象中定义的动作对象的动作属性。'
- en: 'In our example, this value would be either listen or later. You can use this
    value to trigger a different response flow. If the user selects listen, you can
    go directly to the episode page and start playing the episode. If they say later,
    you know to download the episode''s mp3 file and persist it in the cache:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这个值将是 listen 或 later。你可以使用这个值来触发不同的响应流程。如果用户选择 listen，你可以直接进入剧集页面并开始播放剧集。如果他们选择
    later，你知道要下载剧集的 mp3 文件并将其持久化到缓存中：
- en: '[PRE17]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `notification.close` method programmatically closes a notification.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`notification.close` 方法可以编程关闭一个通知。'
- en: That is all it takes to display a push notification. Remember, all the code
    to process a push notification is handled in the service worker. For now, browsers
    require that you display a visible message when you process a notification. This
    does not mean the notification requires user interaction.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 显示推送通知只需这些步骤。记住，处理推送通知的所有代码都在服务工作者中处理。目前，浏览器要求你在处理通知时显示一个可见的消息。这并不意味着通知需要用户交互。
- en: A push notification could trigger logic to be executed in the service worker
    like update the cache. If you require a response, you can configure action buttons
    and process the end user’s choice.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知可以触发在服务工作者中执行的操作逻辑，如更新缓存。如果你需要响应，你可以配置操作按钮并处理最终用户的选项。
- en: Unsubscribing from push notifications
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消推送通知订阅
- en: The only push notification task we need to implement is a way to unsubscribe
    the subscription. This can be done via the `pushManager`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的唯一推送通知任务是取消订阅的方式。这可以通过 `pushManager` 完成。
- en: Before I dive into the details to unsubscribe a user from push notifications,
    I want to look at how we can provide a UI for the user to manage their subscription
    status.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在我深入探讨取消用户推送通知订阅的细节之前，我想看看我们如何为用户提供一个界面来管理他们的订阅状态。
- en: My preference is to include a management interface in the site's settings, configuration
    page, or section. For example, the Twitter PWA has a detailed notification configuration
    experience. It has a high-level page with links to four child pages, each offering
    more granular control over different notification aspects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢在网站的设置、配置页面或部分中包含一个管理界面。例如，Twitter PWA 有一个详细的推送通知配置体验。它有一个高级页面，包含链接到四个子页面，每个页面都提供了对不同通知方面的更精细控制。
- en: They are grouped as either filters or preferences. In the filters group, there
    is also a checkbox to enable a quality filter, which is a very high-level setting.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被分组为过滤器或偏好设置。在过滤器组中，还有一个复选框来启用质量过滤器，这是一个非常高级的设置。
- en: Push notifications are managed in their own group of pages. They have code to
    detect if push notifications are enabled for the site and, if so, give the user
    the option to enable push. Once they enable push, they can then tailor their notifications
    by type of activity.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知在自己的页面组中管理。它们有代码来检测网站是否启用了推送通知，如果是，则给用户一个选项来启用推送。一旦他们启用了推送，他们就可以根据活动类型定制他们的通知。
- en: The default choices can cause a crazy amount of notifications to be sent. So,
    if you are like me, take the time to trim the volume of notifications.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选项可能会导致发送大量通知。所以，如果你像我一样，花时间减少通知的数量。
- en: 'The Twitter Lite application can serve as a reference for a detailed push management
    interface. Fortunately, the Podstr application keeps its notifications simple.
    For our purposes, we will provide an interface to either turn notifications on
    or off:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter Lite 应用可以作为详细推送管理界面的参考。幸运的是，Podstr 应用保持其通知简单。为了我们的目的，我们将提供一个界面来开启或关闭通知：
- en: '![](img/00062.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00062.jpeg)'
- en: Notifications can be toggled on or off, which triggers client-side logic to
    manage a subscription. The application must manage both `subscribeUser` and `unsubscribeUser`
    based on the user toggling a choice.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可以开启或关闭通知，这会触发客户端逻辑来管理订阅。应用程序必须根据用户切换选择来管理 `subscribeUser` 和 `unsubscribeUser`。
- en: This is why there are separate subscribe and unsubscribe methods. Before I dive
    into the code to handle the toggling UI, let’s review the `unsubscribeUser` method.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么有单独的订阅和取消订阅方法。在我深入处理切换 UI 的代码之前，让我们回顾一下 `unsubscribeUser` 方法。
- en: Just like the `subscribeUser` method, the `unsubscribeUser` method uses the
    service worker's `pushManager.getSubscription` method to obtain reference to the
    current subscription, if any.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `subscribeUser` 方法一样，`unsubscribeUser` 方法使用服务工作者的 `pushManager.getSubscription`
    方法来获取当前订阅的引用（如果有的话）。
- en: 'If there is a current subscription, the subscription object''s unsubscribe
    method is called. Unsubscribe returns a promise that resolves a Boolean indicating
    if the subscription was unsubscribed or not:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在当前订阅，则调用订阅对象的取消订阅方法。取消订阅返回一个解析为布尔值的承诺，指示是否已取消订阅：
- en: '[PRE18]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the service worker is unregistered, then any associated push notification
    subscriptions are deactivated.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务工作者未注册，则任何相关的推送通知订阅都将被停用。
- en: When a notification subscription changes outside the control of the application,
    the `pushsubscriptionchange` event fires in the service worker. You can add an
    event handler to this event to handle the change as needed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当通知订阅在应用程序的控制之外发生变化时，`pushsubscriptionchange` 事件在服务工作者中触发。您可以为该事件添加事件处理器来按需处理更改。
- en: A subscription state can change by either the consumer or automatically by the
    service. The service might remove a subscription if it has become stale. In this
    case, you could create an automated resubscription process to renew the subscription.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅状态可以通过消费者或服务自动更改。如果订阅已经过时，服务可能会删除订阅。在这种情况下，您可以创建一个自动重新订阅过程来续订订阅。
- en: If you are resubscribing a notification subscription, it must be done with the
    same options as the page used in the initial, frontend JavaScript. You can access
    the previous options by accessing the `oldSubscription` object in the event object.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在重新订阅通知订阅，则必须使用与初始前端JavaScript中使用的页面相同的选项进行。您可以通过访问事件对象中的 `oldSubscription`
    对象来访问之前的选项。
- en: Handling a push subscription change
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理推送订阅变更
- en: The `pushsubscriptionchange` event is particularly handy if the subscription
    is automatically removed due to the subscription becoming stale. This can happen
    because many push services limit the lifetime of a subscription for security and
    due to inactivity.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于订阅过时而自动删除订阅，`pushsubscriptionchange` 事件特别有用。这可能会发生，因为许多推送服务出于安全和因不活跃而限制订阅的生存期。
- en: Just like authentication tokens, push subscriptions can be seamlessly renewed
    without involving the user. This is what you can do in the service worker for
    a push subscription.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就像身份验证令牌一样，推送订阅可以无缝续订，无需涉及用户。这就是您可以在服务工作者中为推送订阅做的事情。
- en: 'The `pushsubscriptionchange` event includes an `oldSubscription` object that
    contains the details of the original subscription. They can be used to create
    a new subscription:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushsubscriptionchange` 事件包含一个 `oldSubscription` 对象，其中包含原始订阅的详细信息。它们可以用来创建一个新的订阅：'
- en: '[PRE19]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This saves you the hassle of persisting the values between sessions. Now, you
    can easily resubscribe the user in the service worker without disturbing the end
    user.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您节省了在会话之间持久化值的麻烦。现在，您可以在不干扰最终用户的情况下，轻松地在服务工作者中重新订阅用户。
- en: Background sync
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景同步
- en: The service worker cache enables a site to render offline. But that only helps
    when you have the page and assets available in the cache. What can you do if you
    need to post data or get uncached pages while offline?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者缓存允许网站离线渲染。但只有在您有页面和资源在缓存中可用时才有所帮助。如果您需要在离线状态下发送数据或获取未缓存的页面，您能做什么呢？
- en: This is where background sync can help. It enables you to register a request
    that will be fulfilled when the device is back online.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是背景同步可以帮助的地方。它使您能够注册一个请求，当设备重新上线时将得到满足。
- en: Background sync executes asynchronous tasks in the background, when a device
    is online. It works by building a queue of requests to fulfill as soon as the
    device is capable of connecting to the internet.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 背景同步在设备在线时在后台执行异步任务。它通过建立一个队列，当设备能够连接到互联网时立即满足请求。
- en: The way background sync works is you place a network request with a tag, registered
    with the `SyncManager`. The platform is responsible for checking if the device
    is online or offline.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 背景同步的工作方式是您使用与 `SyncManager` 注册的标签放置一个网络请求。平台负责检查设备是否在线或离线。
- en: If it cannot make the request, the sync places the request in a queue for that
    tag. The background sync periodically checks the ability to make a request, but
    not so much that it would drain your battery or consume excessive CPU cycles.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法发出请求，同步将请求放入该标签的队列中。背景同步定期检查发出请求的能力，但不会过多到耗尽您的电池或消耗过多的CPU周期。
- en: The background sync model possibly requires a new way to organize your application's
    code. To properly use sync programming, you should separate all requests into
    isolated methods from any event triggers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 后台同步模型可能需要一种新的方式来组织您的应用程序代码。为了正确使用同步编程，您应该将所有请求从任何事件触发器中分离成独立的方法。
- en: For example, instead of making a fetch call directly in a button click event
    handler, you would call a method that fetches the asset from the event handler.
    This allows you to better isolate the call within a background sync registration.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您不会在按钮点击事件处理器中直接进行获取调用，而是会调用一个从事件处理器获取资产的方法。这允许您更好地在后台同步注册中隔离调用。
- en: The Podstr application allows the customer to select podcast episodes to listen
    to offline. This requires the user to select the episode, and the application
    will download the audio file and store it for offline consumption.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Podstr 应用程序允许客户选择要离线收听的播客剧集。这需要用户选择剧集，应用程序将下载音频文件并存储以供离线播放。
- en: Of course, the application must be online to download the episode. You may also
    want to limit downloading a large file like an audio file for when the device
    is on WiFi and not cellular.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序必须在线才能下载剧集。您可能还希望限制在设备连接到 WiFi 而不是蜂窝网络时下载大文件，如音频文件。
- en: 'First, let''s see how to register a request using background sync:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用后台同步来注册一个请求：
- en: '[PRE20]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because background sync is very new, it is not supported by many browsers yet.
    That should be changing in the near future. For example, Edge has support behind
    the service worker flag.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后台同步非常新，目前许多浏览器还不支持它。这应该会在不久的将来改变。例如，Edge 在服务工人标志后面提供了支持。
- en: To be safe, you should employ feature detection before using it. This can be
    done by checking if the service worker registration object supports `"sync"`.
    If so, then you can register the request; otherwise, you can make the request
    as a normal request.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，在使用之前应该进行功能检测。这可以通过检查服务工人注册对象是否支持 `"sync"` 来完成。如果是这样，那么您可以注册请求；否则，您可以像普通请求一样发出请求。
- en: Sync requests are registered in your UI code, not the service worker. The service
    worker has a sync event handler, which is responsible for handling the network
    request.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 同步请求是在您的 UI 代码中注册的，而不是在服务工人中。服务工人有一个同步事件处理器，负责处理网络请求。
- en: Background sync works like a cloud-based messaging platform. Instead of placing
    a request directly, you post a message to a queue or buffer that can be accessed
    by both the placing and the responding parties.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 后台同步就像一个基于云的消息平台。您不是直接放置请求，而是向一个队列或缓冲区发送消息，该队列或缓冲区可以被放置请求和响应双方访问。
- en: In our example, Podstr stores requests for offline episodes in IDB. This is
    chosen because it is an asynchronous data store, available to both the client
    code and service worker. I won't go into the details of how this works in this
    chapter, as I am saving that for Chapter 6, *Master the Cache API- Manage Web
    Assets in a Podcast Application*, when we dive deeper into caching.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，Podstr 将离线剧集的请求存储在 IDB 中。这是因为它是一个异步数据存储，可供客户端代码和服务工人使用。我不会在本章中详细介绍它是如何工作的，因为我在第六章
    *掌握缓存 API - 在播客应用程序中管理网络资产* 中会详细介绍，当我们深入探讨缓存时。
- en: To make background sync work, you first need to place a message in the IDB queue.
    When the service worker receives a sync event to process episodes to listen later
    (`get-episode`), it checks the IDB queue for episodes and fetches each file.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要使后台同步工作，您首先需要在 IDB 队列中放置一个消息。当服务工人收到处理稍后收听的剧集的同步事件（`get-episode`）时，它会检查 IDB
    队列中的剧集并获取每个文件。
- en: You register the request by calling the sync's `register` method. This method
    accepts a simple tag name. This is passed along to the service worker's sync event
    handler.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用同步的 `register` 方法来注册请求。此方法接受一个简单的标签名称。这个名称会被传递给服务工人的同步事件处理器。
- en: 'The service worker registers a single sync event handler. Each time a background
    sync event triggers, the handler receives a `SyncEvent` object. It contains a
    `tag` property that identifies the event by the `tag` value which is supplied
    when you registered the synchronization:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工人注册一个单独的同步事件处理器。每次后台同步事件触发时，处理器都会接收到一个 `SyncEvent` 对象。它包含一个 `tag` 属性，通过提供的
    `tag` 值来识别事件：
- en: '[PRE21]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, you can see that it is checking the value of the tag before
    calling the `getEpisode` function. The `getEpisode` function triggers the tasks
    required to retrieve the episodes in the listen later queue and downloads them
    for offline persistence.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到它在调用`getEpisode`函数之前正在检查标签的值。`getEpisode`函数触发了检索收听稍后队列中剧集并为其离线持久化下载所需的任务。
- en: You should notice the method is wrapped in a `waitUntil`. This is to keep the
    event handler live while the background task is being performed. Downloading a
    podcast episode could take a few minutes, and you do not want the service worker
    process terminating.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意这个方法被包裹在`waitUntil`中。这是为了在执行后台任务时保持事件处理器处于活跃状态。下载一集播客可能需要几分钟，你不想服务工作者进程终止。
- en: In this example, the podcast episodes will download in response to the background
    sync event being fired. This means the request(s) may not immediately initiate,
    but they will get downloaded.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，播客剧集将在后台同步事件触发时下载。这意味着请求可能不会立即启动，但它们将会被下载。
- en: The bonus is that these downloads will happen even if a Podstr page is not loaded
    in the browser. Plus, the download happens in a background thread, freeing up
    the UI from this cumbersome task. Now, the consumer is free to navigate around
    the application without waiting on the audio files to download.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励是，即使浏览器中没有加载Podstr页面，这些下载也会发生。此外，下载在后台线程中发生，释放了UI从这项繁琐的任务中。现在，消费者可以自由地在应用程序中导航，无需等待音频文件下载。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Service workers are exciting and offer a great new context for developers to
    build rich, engaging user experiences while employing background activities. This
    chapter introduced you to different service worker concepts and the Podstr application.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者令人兴奋，为开发者提供了一个构建丰富、引人入胜的用户体验的新环境，同时使用后台活动。本章介绍了不同的服务工作者概念和Podstr应用程序。
- en: You have now seen how to leverage both push notifications and background sync
    to build engagements, even when the customer is not viewing your application.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何利用推送通知和后台同步来建立互动，即使客户没有查看你的应用程序。
- en: In the following chapters, you will see how the service worker's life cycle
    and caching work. By the end of this section, you will have a modest podcast application,
    demonstrating how to use service worker caching, push notifications, and background
    synchronization to create a user experience that rivals popular native applications
    using web technology.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到服务工作者生命周期和缓存的工作方式。到本节结束时，你将拥有一个简单的播客应用程序，展示如何使用服务工作者缓存、推送通知和后台同步来创建与使用网络技术构建的流行原生应用程序相媲美的用户体验。
