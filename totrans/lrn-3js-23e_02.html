<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Basic Components That Make Up a Three.js Scene</h1></div></div></div><p>In the previous chapter, you learned the basics of Three.js. We showed a couple of examples, and you created your first complete Three.js scene. In this chapter, we'll dive a bit deeper into Three.js and explain the basic components that make up a Three.js scene. In this chapter, you'll explore the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The components that are used in a Three.js scene</li><li class="listitem" style="list-style-type: disc">What you can do with the <code class="literal">THREE.Scene</code> object</li><li class="listitem" style="list-style-type: disc">How geometries and meshes are related</li><li class="listitem" style="list-style-type: disc">The difference between the orthographic and perspective cameras</li></ul></div><p>We start with looking at how you can create a scene and add objects.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Creating a scene</h1></div></div></div><p>In the<a id="id92" class="indexterm"/> previous chapter, you created <code class="literal">THREE.Scene</code>, so you already know the basics of Three.js. We saw that for a scene to show anything, we need three types of components:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Camera</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id93" class="indexterm"/>determines what is rendered on the screen.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Lights</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id94" class="indexterm"/> have an effect on how materials are shown and used when creating shadow effects (discussed in detail in <a class="link" href="ch03.html" title="Chapter 3. Working with the Different Light Sources Available in Three.js">Chapter 3</a>, <em>Working with the Different Light Sources Available in Three.js</em>).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Objects</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id95" class="indexterm"/>are the main objects that are rendered from the perspective of the camera: cubes, spheres, and the like.</p>
</td></tr></tbody></table></div><p>
<code class="literal">THREE.Scene</code> serves as the container for all these different objects. This object itself doesn't have that many options and functions.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>
<code class="literal">THREE.Scene</code> is a structure that is sometimes also called a scene graph. A scene graph is a structure that can hold all necessary information of a graphical scene. In <a id="id96" class="indexterm"/>Three.js, this means that <code class="literal">THREE.Scene</code> contains<a id="id97" class="indexterm"/> all the objects, lights, and other objects necessary for rendering. What is interesting to note is that a scene graph, as the name implies, isn't just an array of objects; a scene graph consists of a set of nodes in a tree structure. Each object you can add to the scene in Three.js, and even <code class="literal">THREE.Scene</code> itself, extends from a base object named <code class="literal">THREE.Object3D</code>. A <code class="literal">THREE.Object3D</code> object can also have its own children, which you can use to create a tree of objects that Three.js will interpret and render.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Basic functionality of a scene</h2></div></div></div><p>The best<a id="id98" class="indexterm"/> way to explore the functionality of a scene is by looking at an example. In the source code for this chapter, you can find the <code class="literal">01-basic-scene.html</code> example. I'll use this example to explain the various functions and options a scene has. When we open this example in the browser, the output will look somewhat like what's shown in the next screenshot:</p><div><img src="img/2215OS_02_01.jpg" alt="Basic functionality of a scene"/></div><p>This looks <a id="id99" class="indexterm"/>pretty much like the examples we saw in the previous chapter. Even though the scene looks pretty empty, it already contains a couple of objects. Looking at the following source, we can see that we used the <code class="literal">scene.add(object)</code> function from the <code class="literal">THREE.Scene</code> object to add <code class="literal">THREE.Mesh</code> (the ground plane you see), <code class="literal">THREE.SpotLight</code>, and <code class="literal">THREE.AmbientLight</code>. The <code class="literal">THREE.Camera</code> object is added automatically by Three.js when you render the scene, but it is good practice to add it to the scene manually, especially when you're working with multiple cameras. Take a look at the following source code for this scene:</p><div><pre class="programlisting">var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
<strong>scene.add(camera);</strong>
...
var planeGeometry = new THREE.PlaneGeometry(60,40,1,1);
var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
var plane = new THREE.Mesh(planeGeometry,planeMaterial);
...
<strong>scene.add(plane);</strong>
var ambientLight = new THREE.AmbientLight(0x0c0c0c);
<strong>scene.add(ambientLight);</strong>
...
var spotLight = new THREE.SpotLight( 0xffffff );
...
<strong>scene.add( spotLight );</strong>
</pre></div><p>Before we<a id="id100" class="indexterm"/> look deeper into the <code class="literal">THREE.Scene</code> object, I'll first explain what you can do in the demo, and after that, we'll look at some code. Open the <code class="literal">01-basic-scene.html</code> example in your browser and look at the controls in the upper-right corner, as you can see in the following screenshot:</p><div><img src="img/2215OS_02_02.jpg" alt="Basic functionality of a scene"/></div><p>With these controls, you can add a cube to the scene, remove the cube that was last added to the scene, and show all the current objects that the scene contains in the console of your browser. The <a id="id101" class="indexterm"/>last entry in the controls section shows the current number of objects in the scene. What you'll probably notice when you start up the scene is that there are already four objects in the scene. These are the ground plane, the ambient light, and the spotlight, as well as the camera we mentioned earlier. We'll look at each of the functions in the control section and start with the easiest one, <code class="literal">addCube</code>, as follows:</p><div><pre class="programlisting">this.addCube = function() {

  var cubeSize = Math.ceil((Math.random() * 3));
  var cubeGeometry = new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize);
  var cubeMaterial = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff });
  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  cube.castShadow = true;
<strong>  cube.name = "cube-" + scene.children.length;</strong>
  cube.position.x=-30 + Math.round(Math.random() * planeGeometry.width));
  cube.position.y= Math.round((Math.random() * 5));
  cube.position.z=-20 + Math.round((Math.random() * planeGeometry.height));

  scene.add(cube);
<strong>  this.numberOfObjects = scene.children.length;</strong>
};</pre></div><p>This piece of code should already be pretty easy to read by now. Not many new concepts are introduced here. When you hit the <strong>addCube</strong> button, a new <code class="literal">THREE.BoxGeometry</code> object is created whose width, height, and depth are set to a random value between 1 and 3. Besides a random size, the cube also gets a random color and a random position.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>A new element that we introduce here is that we also give the cube a name using its <code class="literal">name</code> attribute. Its name is set to <code class="literal">cube-</code>, appended with the number of objects currently in the scene (<code class="literal">scene.children.length</code>). A name is very useful for debugging purposes but can also be used to directly access an object from your scene. If you use the <code class="literal">THREE.Scene.getObjectByName(name)</code> function, you can directly retrieve a specific object and, for instance, change its location without having to make the JavaScript object a global variable. You might wonder what the last line does. The <code class="literal">numberOfObjects</code> variable is used by our control GUI to list the number of objects in the scene. So, whenever we add or remove an object, we set this variable to the updated count.</p></div></div><p>The next function we can call from the control GUI is <code class="literal">removeCube</code>. As the name implies, clicking on the <strong>removeCube</strong> button removes the last added cube from the scene. In code, it looks like this:</p><div><pre class="programlisting">  this.removeCube = function() {
    var allChildren = scene.children;
    var lastObject = allChildren[allChildren.length-1];
    if (lastObject instanceof THREE.Mesh) {
      scene.remove(lastObject);
      this.numberOfObjects = scene.children.length;
    }
  }</pre></div><p>To add an<a id="id102" class="indexterm"/> object to the scene, we use the <code class="literal">add</code> function. To remove an object from the scene, we use, not very surprisingly, the <code class="literal">remove</code> function. Since Three.js stores its children as a list (new ones are added at the end), we can use the <code class="literal">children</code> property, which contains an array of all the objects in the scene, from the <code class="literal">THREE.Scene</code> object to get the last object that was added. We also need to check whether that object is a <code class="literal">THREE.Mesh</code> object to avoid removing the camera and the lights. After we've removed the object, we once again update the GUI property, <code class="literal">numberOfObjects</code>, that holds the number of objects in the scene.</p><p>The final button on our GUI is labeled <strong>outputObjects</strong>. You probably already clicked on this and nothing seemed to happen. This button prints out all the objects that are currently in our scene to the web browser console, as shown in the following screenshot:</p><div><img src="img/2215OS_02_03.jpg" alt="Basic functionality of a scene"/></div><p>The code <a id="id103" class="indexterm"/>to output information to the console log makes use of the built-in <code class="literal">console</code> object:</p><div><pre class="programlisting">  this.outputObjects = function() {
    console.log(scene.children);
  }</pre></div><p>This is great for debugging purposes, and especially when you name your objects, it's very useful to find issues and problems with a specific object in your scene. For instance, the properties of <code class="literal">cube-17</code> look like this (if you already know the name beforehand, you could also use <code class="literal">console.log(scene.getObjectByName("cube-17")</code> to output only that single object):</p><div><pre class="programlisting">__webglActive: true
__webglInit: true
_listeners: Object
_modelViewMatrix: THREE.Matrix4
_normalMatrix: THREE.Matrix3
castShadow: true
children: Array[0]
eulerOrder: (...)
frustumCulled: true
geometry: THREE.BoxGeometryid: 8
material: THREE.MeshLambertMaterial
matrix: THREE.Matrix4
matrixAutoUpdate: true
matrixWorld: THREE.Matrix4
matrixWorld
NeedsUpdate: false
name: "cube-17"
parent: THREE.Scene
position: THREE.Vector3
quaternion: THREE.Quaternion
receiveShadow: false
renderDepth: null
rotation: THREE.Euler
rotationAutoUpdate: true
scale: THREE.Vector3
type: "Mesh"
up: THREE.Vector3
useQuaternion: (...)
userData: Object
uuid: "DCDC0FD2-6968-44FD-8009-20E9747B8A73"
visible: true</pre></div><p>Until <a id="id104" class="indexterm"/>now, we've seen the following scene-related functionality:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.Scene.Add</code>: This adds an object to the scene</li><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.Scene.Remove</code>: This removes an object from the scene</li><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.Scene.children</code>: This gets a list of all the children in the scene</li><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.Scene.getObjectByName</code>: This gets a specific object, by name, from the scene</li></ul></div><p>These are the most important scene-related functions, and most often, you won't need any more than this. There are, however, a couple of helper functions that could come in handy, and I'd like to show them based on the code that handles the cube rotation.</p><p>As you saw in the previous chapter, we used a <em>render loop</em> to render the scene. Let's look at that loop for this example:</p><div><pre class="programlisting">function render() {
  stats.update();
  scene.traverse(function(obj) {
    if (obj instanceof THREE.Mesh &amp;&amp; obj != plane ) {
      obj.rotation.x+=controls.rotationSpeed;
      obj.rotation.y+=controls.rotationSpeed;
      obj.rotation.z+=controls.rotationSpeed;
   }
  });

  requestAnimationFrame(render);
  renderer.render(scene, camera);
}</pre></div><p>Here, we see the <code class="literal">THREE.Scene.traverse()</code> function being used. We can pass a function to the <code class="literal">traverse()</code> function that will be called for each child of the scene. If a child itself has<a id="id105" class="indexterm"/> children, remember that a <code class="literal">THREE.Scene</code> object can contain a tree of objects. The <code class="literal">traverse()</code> function will also be called for all the children of that object. You traverse through the complete scene graph.</p><p>We use the <code class="literal">render()</code> function to update the rotation for each of the cubes (note that we explicitly ignore the ground plane). We could also have done this by iterating ourselves over the <code class="literal">children</code> property array using a <code class="literal">for</code> loop since we've only added objects to <code class="literal">THREE.Scene</code> and haven't created a nested structure.</p><p>Before we dive into the details of <code class="literal">THREE.Mesh</code> and <code class="literal">THREE.Geometry</code>, I'd like to show two interesting properties that you can set on the <code class="literal">THREE.Scene</code> object: <code class="literal">fog</code> and <code class="literal">overrideMaterial</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Adding fog to the scene</h2></div></div></div><p>The <strong>fog</strong> property lets <a id="id106" class="indexterm"/>you add a fog effect to the complete<a id="id107" class="indexterm"/> scene; the farther off an<a id="id108" class="indexterm"/> object is, the more it will be hidden from sight, as shown in the following screenshot:</p><div><img src="img/2215OS_02_04.jpg" alt="Adding fog to the scene"/></div><p>Enabling<a id="id109" class="indexterm"/> fog is really easy in Three.js. Just add the following<a id="id110" class="indexterm"/> line of code after you've defined your scene:</p><div><pre class="programlisting">scene.fog=new THREE.Fog( 0xffffff, 0.015, 100 );</pre></div><p>Here, we define a white fog (<code class="literal">0xffffff</code>). The preceding two properties can be used to tune how the mist appears. The <code class="literal">0.015</code> value sets the <code class="literal">near</code> property, and the <code class="literal">100</code> value sets the <code class="literal">far</code> property. With these properties, you can determine where the mist starts and how fast it gets denser. With the <code class="literal">THREE.Fog</code> object, the fog increases linearly. There is also a different way to set the mist for the scene; for this, use the following definition:</p><div><pre class="programlisting">scene.fog=new THREE.FogExp2( 0xffffff, 0.01 );</pre></div><p>This time, we don't specify <code class="literal">near</code> and <code class="literal">far</code>, but just the color (<code class="literal">0xffffff</code>) and the mist's density (<code class="literal">0.01</code>). It's best to experiment a bit with these properties to get the effect you want. Note that with <code class="literal">THREE.FogExp2</code>, the fog doesn't increase linearly but grows exponentially denser with the distance.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Using the overrideMaterial property</h2></div></div></div><p>The last <a id="id111" class="indexterm"/>property we discuss for the scene is <strong>overrideMaterial</strong>. When you use this property, all the objects in the scene will use the material <a id="id112" class="indexterm"/>that is set to the <code class="literal">overrideMaterial</code> property and ignore the material that is set on the object itself.</p><p>Use it like this:</p><div><pre class="programlisting">scene.overrideMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});</pre></div><p>Upon using the <code class="literal">overrideMaterial</code> property as shown in the preceding code, the scene will be rendered as shown in the following screenshot:</p><div><img src="img/2215OS_02_05.jpg" alt="Using the overrideMaterial property"/></div><p>In the preceding figure, you can see that all the cubes are rendered using the same material and the same color. In this example, we used a <code class="literal">THREE.MeshLambertMaterial</code> object as the material. With this material type, we can create non-shiny-looking objects that respond to the lights that are present in the scene. In <a class="link" href="ch04.html" title="Chapter 4. Working with Three.js Materials">Chapter 4</a>, <em>Working with Three.js Materials</em>, you'll learn more about this material.</p><p>In this section, we looked at the first of the core concepts of Three.js: <code class="literal">THREE.Scene</code>. The most important thing to remember about the scene is that it is basically a container for all the objects, lights, and cameras you want to use when rendering. The following table summarizes<a id="id113" class="indexterm"/> the most important functions and <a id="id114" class="indexterm"/>attributes of the <code class="literal">THREE.Scene</code> object:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function/Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">add(object)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id115" class="indexterm"/>is used to add an object to the scene. You can also use this function, as we'll see later on, to create groups of objects.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">children</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id116" class="indexterm"/>returns a list of all the objects that have been added to the scene, including the camera and lights.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getObjectByName(name, recursive)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When you create an object, you<a id="id117" class="indexterm"/> can give it a distinct name. The scene object has a function that you can use to directly return an object with a specific name. If you set the recursive argument to <code class="literal">true</code>, Three.js will also search through the complete tree of objects to find the object with the specified name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">remove(object)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If <a id="id118" class="indexterm"/>you have a reference to an object in the scene, you can also remove it from the scene using this function.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">traverse(function)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The children property<a id="id119" class="indexterm"/> returns a list of all the children in the scene. With the traverse function, we can also access these children. With traverse, all the children are passed in to the supplied function one by one.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fog</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id120" class="indexterm"/>property allows you to set the fog for the scene. The fog will render a haze that hides faraway objects.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">overrideMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With this property, you<a id="id121" class="indexterm"/> can force all the objects in the scene to use the same material.</p>
</td></tr></tbody></table></div><p>In the next section, we'll take a closer look at the objects that you can add to the scene.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Geometries and meshes</h1></div></div></div><p>In each <a id="id122" class="indexterm"/>of the examples until now, you've seen geometries <a id="id123" class="indexterm"/>and meshes being used. For instance, to add a sphere to the scene, we did the following:</p><div><pre class="programlisting">var sphereGeometry = new THREE.SphereGeometry(4,20,20);
var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff);
var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);</pre></div><p>We defined the shape of the object and its geometry (<code class="literal">THREE.SphereGeometry</code>), we defined <a id="id124" class="indexterm"/>what this object looks like (<code class="literal">THREE.MeshBasicMaterial</code>) and its material, and we combined these two in a mesh (<code class="literal">THREE.Mesh</code>) that <a id="id125" class="indexterm"/>can be added to a scene. In this section, we'll take a closer look at what a geometry is and what a mesh is. We'll start with the geometry.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>The properties and functions of a geometry</h2></div></div></div><p>Three.js<a id="id126" class="indexterm"/> comes with a large set of geometries out of the box that you <a id="id127" class="indexterm"/>can use in your 3D scene. Just add a material, create a mesh, and you're pretty much done. The following screenshot, from example <code class="literal">04-geometries</code>, shows a couple of the standard geometries available in Three.js:</p><div><img src="img/2215OS_02_06.jpg" alt="The properties and functions of a geometry"/></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>, and <a class="link" href="ch06.html" title="Chapter 6. Advanced Geometries and Binary Operations">Chapter 6</a>, <em>Advanced Geometries and Binary Operations</em>, we'll explore all the basic and advanced geometries that Three.js has to offer. For now, we'll look in greater detail at what a geometry actually is.</p><p>A geometry in Three.js, and in most other 3D libraries, is basically a collection of points in a 3D space, also called vertices, and a number of faces connecting those points together. Take, for example, a cube:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A cube has eight corners. Each of these corners can be defined as an <em>x</em>, <em>y</em>, and <em>z</em> coordinate. So each cube has eight points in a 3D space. In Three.js, these points are called vertices, and a single one is called a vertex.</li><li class="listitem" style="list-style-type: disc">A cube has six sides, with a vertex at each corner. In Three.js, a face always consists of three vertices that make a triangle. So, in the case of a cube, each side consists of two triangles to make the complete side.</li></ul></div><p>When you<a id="id128" class="indexterm"/> use one of the geometries provided by Three.js, you don't have<a id="id129" class="indexterm"/> to define all the vertices and faces yourself. For a cube, you only need to define the width, height, and depth. Three.js uses that information and creates a geometry with eight vertices at the correct position and the correct number of faces (12 in the case of a cube). Even though you'd normally use the geometries provided by Three.js or generate them automatically, you can still create geometries completely by hand using vertices and faces. This is shown in the following lines of code:</p><div><pre class="programlisting">var vertices = [
  new THREE.Vector3(1,3,1),
  new THREE.Vector3(1,3,-1),
  new THREE.Vector3(1,-1,1),
  new THREE.Vector3(1,-1,-1),
  new THREE.Vector3(-1,3,-1),
  new THREE.Vector3(-1,3,1),
  new THREE.Vector3(-1,-1,-1),
  new THREE.Vector3(-1,-1,1)
];

var faces = [
  new THREE.Face3(0,2,1),
  new THREE.Face3(2,3,1),
  new THREE.Face3(4,6,5),
  new THREE.Face3(6,7,5),
  new THREE.Face3(4,5,1),
  new THREE.Face3(5,0,1),
  new THREE.Face3(7,6,2),
  new THREE.Face3(6,3,2),
  new THREE.Face3(5,7,0),
  new THREE.Face3(7,2,0),
  new THREE.Face3(1,3,4),
  new THREE.Face3(3,6,4),
];

var geom = new THREE.Geometry();
geom.vertices = vertices;
geom.faces = faces;
geom.computeFaceNormals();</pre></div><p>This code shows how to create a simple cube. We define the points that make up this cube in the <code class="literal">vertices</code> array. These points are connected to create triangular faces and are stored in the <code class="literal">faces</code> array. For instance, <code class="literal">new THREE.Face3(0,2,1)</code> creates a triangular face using the points <code class="literal">0</code>, <code class="literal">2</code>, and <code class="literal">1</code> from the <code class="literal">vertices</code> array. Note that you have to take care of the<a id="id130" class="indexterm"/> sequence of the vertices used to create <code class="literal">THREE.Face</code>. The <a id="id131" class="indexterm"/>order in which they are defined determines whether Three.js thinks it is a front-facing face (a face facing the camera) or a back-facing face. If you create the faces, you should use a clockwise sequence for front-facing faces and a counterclockwise sequence if you want to create a back-facing face.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>In this example, we used a <code class="literal">THREE.Face3</code> element to define the six sides of the cube, with two triangles for each face. In previous versions of Three.js, you could also use a quad instead of a triangle. A quad uses four vertices instead of three to define the face. Whether using quads or triangles is better is a heated debate raging in the 3D modeling world. Basically though, using quads is often preferred during modeling since they can be more easily enhanced and smoothed than triangles. For render and game engines though, working with triangles is often easier since every shape can be rendered very efficiently as a triangle.</p></div></div><p>Using these vertices and faces, we can now create a new instance of <code class="literal">THREE.Geometry</code> and assign the vertices to the <code class="literal">vertices</code> attribute and the faces to the <code class="literal">faces</code> attribute. The last step that we need to take is call <code class="literal">computeFaceNormals()</code> on the geometry we created. When we call this function, Three.js determines the <em>normal</em> vector for each of the faces. This is the information Three.js uses to determine how to color the faces based on the various lights in the scene.</p><p>With this geometry, we can now create a mesh just as we saw earlier. I've created an example that you can use to play around with the position of the vertices, and which also shows the individual faces. In example <code class="literal">05-custom-geometry</code>, you can change the position of all the vertices of a cube and see how the faces react. This is shown in the following screenshot (should the control GUI be in the way, you can hide it by pressing <em>H</em>):</p><div><img src="img/2215OS_02_07.jpg" alt="The properties and functions of a geometry"/></div><p>This<a id="id132" class="indexterm"/> example, which uses the same setup as all our other examples, has <a id="id133" class="indexterm"/>a render loop. Whenever you change one of the properties in the drop-down control box, the cube is rendered based on the changed position of one of the vertices. This isn't something that works out of the box. For performance reasons, Three.js assumes that the geometry of a mesh won't change during its lifetime. For most geometries and use cases, this is a very valid assumption. To get our example to work, however, we need to make sure the following is added to the code in the render loop:</p><div><pre class="programlisting">mesh.children.forEach(function(e) {
  e.geometry.vertices=vertices;
  e.geometry.verticesNeedUpdate=true;
  e.geometry.computeFaceNormals();
});</pre></div><p>In the first line, we point the vertices of the mesh you see on screen to an array of updated vertices. We don't need to reconfigure the faces since they are still connected to the same points as they were before. After we've set the updated vertices, we need to tell the geometry that the vertices need to be updated. We do this by setting the <code class="literal">verticesNeedUpdate</code> property of the geometry to <code class="literal">true</code>. Finally, we do a recalculation of the faces to update the complete model using the <code class="literal">computeFaceNormals</code> function.</p><p>The last geometry functionality we'll look at is the <code class="literal">clone()</code> function. We mentioned that the geometry defines the form and shape of an object, and combined with a material, we create an <a id="id134" class="indexterm"/>object that can be added to the scene to be rendered by <a id="id135" class="indexterm"/>Three.js. With the <code class="literal">clone()</code> function, as the name implies, we can make a copy of the geometry, and for instance, use it to create a different mesh with a different material. In the same example, <code class="literal">05-custom-geometry</code>, you can see a <strong>clone</strong> button at the top of the control GUI, as can be seen in the following screenshot:</p><div><img src="img/2215OS_02_08.jpg" alt="The properties and functions of a geometry"/></div><p>If you click on this button, a clone (a copy) will be made of the geometry as it currently is, a new object is created with a different material, and it is added to the scene. The code for this is rather simple but is made a bit more complex because of the materials I used. Let's take a step back and first look at how the green material for the cube was created, as shown in the following code:</p><div><pre class="programlisting">var materials = [
  new THREE.MeshLambertMaterial( { opacity:0.6, color: 0x44ff44, transparent:true } ),
  new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true } )
];</pre></div><p>As you can see, I didn't use a single material, but I used an array of two materials. The reason is that besides showing a transparent green cube, I also wanted to show you the wireframe since that shows up very clearly where the vertices and faces are located.</p><p>Three.js, of course, supports using multiple materials when creating a mesh. You can use the <code class="literal">SceneUtils.createMultiMaterialObject</code> function for this, as shown in the following code:</p><div><pre class="programlisting">var mesh = THREE.SceneUtils.createMultiMaterialObject( geom, materials);</pre></div><p>What Three.js does<a id="id136" class="indexterm"/> in this function is that it doesn't create one <code class="literal">THREE.Mesh</code> object, but it creates one for each material you specified and puts these meshes<a id="id137" class="indexterm"/> in a group (a <code class="literal">THREE.Object3D</code> object). This group can be used in the same manner as you've used the scene object. You can add meshes, get objects by name, and so on. For instance, to make sure all the children of the group cast shadows, you do the following:</p><div><pre class="programlisting">mesh.children.forEach(function(e) {e.castShadow=true});</pre></div><p>Now, let's get back to the <code class="literal">clone()</code> function we were discussing:</p><div><pre class="programlisting">this.clone = function() {

  var clonedGeom = mesh.children[0].geometry.clone();
  var materials = [
    new THREE.MeshLambertMaterial( { opacity:0.6, color: 0xff44ff, transparent:true } ),
    new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true } )
  ];

  var mesh2 = THREE.SceneUtils.createMultiMaterialObject(clonedGeom, materials);
  mesh2.children.forEach(function(e) {e.castShadow=true});
  mesh2.translateX(5);
  mesh2.translateZ(5);
  mesh2.name="clone";
  scene.remove(scene.getObjectByName("clone"));
  scene.add(mesh2);
}</pre></div><p>This piece of JavaScript is called when the <strong>clone</strong> button is clicked on. Here, we clone the geometry of the first child of our cube. Remember, the mesh variable contains two children; it contains two meshes, one for each material we specified. Based on this cloned geometry, we create a new mesh, aptly named <code class="literal">mesh2</code>. We move this new mesh using translate functions (more on this in <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>), remove the previous clone (if present), and add the clone to the scene.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>In the previous section, we used <code class="literal">createMultiMaterialObject</code> from the <code class="literal">THREE.SceneUtils</code> object to add a wireframe to the geometry we created. Three.js also provides an alternative way of adding a wireframe using <code class="literal">THREE.WireFrameHelper</code>. To use this helper, first instantiate the helper like this:</p><div><pre class="programlisting">
<strong>var helper = new THREE.WireframeHelper(mesh, 0x000000);</strong>
</pre></div><p>You provide the mesh you want to show the wireframe for and the color of the wireframe. Three.js will now create a helper object that you can add to the scene, <code class="literal">scene.add(helper)</code>. Since this helper internally is just a <code class="literal">THREE.Line</code> object, you can style how the wireframe appears. For instance, to set the width of the wireframe lines, use <code class="literal">helper.material.linewidth = 2;</code>.</p></div></div><p>That's <a id="id138" class="indexterm"/>enough<a id="id139" class="indexterm"/> on geometries for now.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Functions and attributes for meshes</h2></div></div></div><p>We've <a id="id140" class="indexterm"/>already learned that to create a mesh, we need a geometry<a id="id141" class="indexterm"/> and one or more materials. Once we have a mesh, we add it to the scene and it's rendered. There are a couple of properties that you can use to change where and how this mesh appears on the scene. In this first example, we'll look at the following set of properties and functions:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function/Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">position</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id142" class="indexterm"/> determines the position of this object relative to the position of its parent. Most often, the parent of an object is a <code class="literal">THREE.Scene</code> object or a <code class="literal">THREE.Object3D</code> object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">rotation</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With<a id="id143" class="indexterm"/> this property, you can set the rotation of an object around any of its axes. Three.js also provides specific functions for rotations around an axis: <code class="literal">rotateX()</code>, <code class="literal">rotateY()</code>, and <code class="literal">rotateZ()</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">scale</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id144" class="indexterm"/>property allows you to scale the object around its <em>x</em>, <em>y</em>, and <em>z</em> axes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">translateX(amount)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id145" class="indexterm"/> property moves the object the specified amount over the <em>x</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">translateY(amount)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id146" class="indexterm"/>property moves the object the specified amount over the <em>y</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">translateZ(amount)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id147" class="indexterm"/> property moves the object the specified amount over the <em>z</em> axis.</p>
<p>For<a id="id148" class="indexterm"/> the translate functions, you could also use the <code class="literal">translateOnAxis(axis, distance)</code> function, which allows you to translate the mesh a distance along a specific axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">visible</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If you <a id="id149" class="indexterm"/>set this property to <code class="literal">false</code>, <code class="literal">THREE.Mesh</code> won't be rendered by Three.js.</p>
</td></tr></tbody></table></div><p>As always, we have an example ready for you that will allow you to play around with these<a id="id150" class="indexterm"/> properties. If you open up <code class="literal">06-mesh-properties.html</code> in your<a id="id151" class="indexterm"/> browser, you get a drop-down menu where you can alter all these properties and directly see the result, as shown in the following screenshot:</p><div><img src="img/2215OS_02_09.jpg" alt="Functions and attributes for meshes"/></div><p>Let me walk you through them, and I'll start with the position property. We've already seen this property a couple of times, so let's quickly address this. With this property, you set the <em>x</em>, <em>y</em>, and <em>z</em> coordinates of the object. This position is relative to its parent object, which is normally the scene you add the object to, but could also be a <code class="literal">THREE.Object3D</code> object or another <code class="literal">THREE.Mesh</code> object. We'll get back to this in <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>, when we look at grouping objects. We can set an object's position property in three different ways. We can set each coordinate directly:</p><div><pre class="programlisting">cube.position.x=10;
cube.position.y=3;
cube.position.z=1;</pre></div><p>However, we can also set all of them at once, as follows:</p><div><pre class="programlisting">cube.position.set(10,3,1);</pre></div><p>There is also a third option. The <code class="literal">position</code> property is a <code class="literal">THREE.Vector3</code> object. That means, we can also do the following to set this object:</p><div><pre class="programlisting">cube.postion=new THREE.Vector3(10,3,1)</pre></div><p>I want to make a quick sidestep before looking at the other properties of this mesh. I mentioned that this position is set relative to the position of its parent. In the previous section on <code class="literal">THREE.Geometry</code>, we used <code class="literal">THREE.SceneUtils.createMultiMaterialObject</code> to create a multi-material object. I explained that<a id="id152" class="indexterm"/> this doesn't really return a single mesh but a group that <a id="id153" class="indexterm"/>contains a mesh based on the same geometry for each material; in our case, it's a group that contains two meshes. If we change the position of one of these meshes that is created, you can clearly see that it really is two distinct <code class="literal">THREE.Mesh</code> objects. However, if we now move the group around, the offset will remain the same, as shown in the following screenshot. In <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>, we look deeper into parent-child relations and how grouping affects transformation, such as scaling, rotation, and translation.</p><div><img src="img/2215OS_02_10.jpg" alt="Functions and attributes for meshes"/></div><p>OK, next on the list is the <code class="literal">rotation</code> property. You've already seen this property being used a couple of times in this chapter and the previous chapter. With this property, you set the rotation of the object around one of its axes. You can set this value in the same manner as we did the position. A complete rotation, as you might remember from math class, is <em>2 x π</em>. You can configure this in Three.js in a couple of different ways:</p><div><pre class="programlisting">cube.rotation.x = 0.5*Math.PI;
cube.rotation.set(0.5*Math.PI, 0, 0);
cube.rotation = new THREE.Vector3(0.5*Math.PI,0,0);</pre></div><p>If you want to use degrees (from 0 to 360) instead, we'll have to convert those to radians. This can be easily done like this:</p><div><pre class="programlisting">Var degrees = 45;
Var inRadians = degrees * (Math.PI / 180);</pre></div><p>You can play around with this property using the <code class="literal">06-mesh-properties.html</code> example.</p><p>The next <a id="id154" class="indexterm"/>property on our list is one we haven't talked about: <code class="literal">scale</code>. The<a id="id155" class="indexterm"/> name pretty much sums up what you can do with this property. You can scale the object along a specific axis. If you set the scale to values smaller than one, the object will shrink, as shown in the following screenshot:</p><div><img src="img/2215OS_02_11.jpg" alt="Functions and attributes for meshes"/></div><p>When you use values larger than one, the object will become larger, as shown in the following screenshot:</p><div><img src="img/2215OS_02_12.jpg" alt="Functions and attributes for meshes"/></div><p>The next <a id="id156" class="indexterm"/>part of the mesh that we'll look at in this chapter is the <strong>translate</strong> functionality. With translate, you can also change the position of an object, but instead <a id="id157" class="indexterm"/>of defining the absolute position where you want the object <a id="id158" class="indexterm"/>to be, you define where the object should move to, relative to its current position. For instance, we have a sphere that is added to a scene, and its position has been set to <code class="literal">(1,2,3)</code>. Next, we translate the object along its <em>x</em> axis: <code class="literal">translateX(4)</code>. Its position will now be <code class="literal">(5,2,3)</code>. If we want to restore the object to its original position, we do this: <code class="literal">translateX(-4)</code>. In the <code class="literal">06-mesh-properties.html</code> example, there is a menu tab called <strong>translate</strong>. From there, you can experiment with this functionality. Just set the translate values for <em>x</em>, <em>y</em>, and <em>z</em> and hit the <strong>translate</strong> button. You'll see the object being moved to a new position based on these three values.</p><p>The last property you can use from the menu in the top-right corner is the <strong>visible</strong> property. If <a id="id159" class="indexterm"/>you click on the <strong>visible</strong> menu item, you'll see that the cube becomes invisible, as follows:</p><div><img src="img/2215OS_02_13.jpg" alt="Functions and attributes for meshes"/></div><p>When<a id="id160" class="indexterm"/> you <a id="id161" class="indexterm"/>click on it another time, the cube becomes visible again. For more information on meshes, geometries, and what you can do with these objects, look at <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>, and <a class="link" href="ch07.html" title="Chapter 7. Particles, Sprites, and the Point Cloud">Chapter 7</a>, <em>Particles, Sprites, and the Point Cloud</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Different cameras for different uses</h1></div></div></div><p>There are two<a id="id162" class="indexterm"/> different camera types in Three.js: the orthographic camera and the perspective camera. In <a class="link" href="ch03.html" title="Chapter 3. Working with the Different Light Sources Available in Three.js">Chapter 3</a>, <em>Working with the Different Light Sources Available in Three.js</em>, we'll have a much more detailed look at how to work with these cameras, so in this chapter, I'll stick to the basics. The best way to explain the differences between these cameras is by looking at a couple of examples.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Orthographic camera versus perspective camera</h2></div></div></div><p>In <a id="id163" class="indexterm"/>the examples for this chapter, you can find a demo called <code class="literal">07-both-cameras.html</code>. When you open this example, you'll see something like this:</p><div><img src="img/2215OS_02_14.jpg" alt="Orthographic camera versus perspective camera"/></div><p>This is<a id="id164" class="indexterm"/> called a perspective view and is the most natural view. As you can see from this figure, the farther away the cubes are from the camera, the smaller they are rendered.</p><p>If we change the camera to the other type supported by Three.js, the orthographic camera, you'll see the following view of the same scene:</p><div><img src="img/2215OS_02_15.jpg" alt="Orthographic camera versus perspective camera"/></div><p>With<a id="id165" class="indexterm"/> the orthographic camera, all the cubes are rendered the same size; the distance between an object and the camera doesn't matter. This is often used in 2D games such as <em>SimCity 4</em> and old versions of <em>Civilization</em>.</p><div><img src="img/2215OS_02_16.jpg" alt="Orthographic camera versus perspective camera"/></div><p>In <a id="id166" class="indexterm"/>our examples, we'll use the perspective camera the most since it best resembles the real world. Switching cameras is really very easy. The following piece of code is called whenever you hit the switch camera button on the <code class="literal">07-both-cameras</code> example:</p><div><pre class="programlisting">this.switchCamera = function() {
  if (camera instanceof THREE.PerspectiveCamera) {
    camera = new THREE.OrthographicCamera( window.innerWidth / - 16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / - 16, -200, 500 );
    camera.position.x = 120;
    camera.position.y = 60;
    camera.position.z = 180;
    camera.lookAt(scene.position);
    this.perspective = "Orthographic";
  } else {
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    camera.position.x = 120;
    camera.position.y = 60;
    camera.position.z = 180;

    camera.lookAt(scene.position);
    this.perspective = "Perspective";
  }
};</pre></div><p>In this<a id="id167" class="indexterm"/> table, you can see that there is a difference in the way we create the camera. Let's look at <code class="literal">THREE.PerspectiveCamera</code> first. This camera takes the following arguments:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Argument</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fov</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>FOV</strong> stands for <strong>Field Of View</strong>. This is the part of the scene that can<a id="id168" class="indexterm"/> be seen from the <a id="id169" class="indexterm"/>position of the camera. Humans, for instance, have an almost 180-degree FOV, while some birds might even have a complete 360-degree FOV.</p>
<p>But since a normal computer screen doesn't completely fill our vision, normally a smaller value is chosen. Most often, for games, a FOV between 60 and 90 degrees is chosen.</p>
<p>
<em>Good default: 50</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">aspect</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id170" class="indexterm"/>is the aspect ratio between the horizontal and vertical sizes of the area where we're to render the output. In our case, since we use the entire window, we just use that ratio. The aspect ratio determines the difference between the horizontal FOV and the vertical FOV, as you can see in the following image.</p>
<p>
<em>Good default: window.innerWidth / window.innerHeight</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">near</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">near</code> property defines from how close to the camera Three.js should <a id="id171" class="indexterm"/>render the scene. Normally, we set this to a very small value to directly render everything from the position of the camera.</p>
<p>
<em>Good default: 0.1</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">far</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">far</code> property defines how far the camera can see from the position<a id="id172" class="indexterm"/> of the camera. If we set this too low, a part of our scene might not be rendered, and if we set it too high, in some cases, it might affect the rendering performance.</p>
<p>
<em>Good default: 1000</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">zoom</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">zoom</code> property allows you to zoom in and out of the scene. When <a id="id173" class="indexterm"/>you use a number lower than <code class="literal">1</code>, you zoom out of the scene, and if you use a number higher than <code class="literal">1</code>, you zoom in. Note that if you specify a negative value, the scene will be rendered upside down.</p>
<p>
<em>Good default value: 1</em>
</p>
</td></tr></tbody></table></div><p>The following image gives a good overview of how these properties work together to determine what you see:</p><div><img src="img/2215OS_02_17.jpg" alt="Orthographic camera versus perspective camera"/></div><p>The <code class="literal">fov</code> property of the camera determines the horizontal FOV. Based on the <code class="literal">aspect</code> property, the vertical FOV is determined. The <code class="literal">near</code> property is used to determine <a id="id174" class="indexterm"/>the position of the near plane, and the <code class="literal">far</code> property determines the position of the far plane. The area between the near plane and the far plane will be rendered.</p><p>To configure the orthographic camera, we need to use other properties. The orthographic projection isn't interested either in the aspect ratio to use or with what FOV we look at the scene since all the objects are rendered at the same size. What you do when you define an orthographic camera is define the cuboid area that needs to be rendered. The properties for the orthographic camera reflect this, as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Argument</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">left</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id175" class="indexterm"/>described in the Three.js documentation as <em>Camera frustum left plane</em>. You should see this as what is the left-hand border of what will be rendered. If you set this value to <code class="literal">-100</code>, you won't see any objects that are farther to the left-hand side.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">right</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">right</code> property works in a way similar to the <code class="literal">left</code> property, but <a id="id176" class="indexterm"/>this time, to the other side of the screen. Anything farther to the right won't be rendered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">top</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id177" class="indexterm"/> is the top position to be rendered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bottom</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id178" class="indexterm"/> the bottom position to be rendered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">near</code>
</p>
</td><td style="text-align: left" valign="top">
<p>From <a id="id179" class="indexterm"/>this point, based on the position of the camera, the scene will be rendered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">far</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To this <a id="id180" class="indexterm"/>point, based on the position of the camera, the scene will be rendered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">zoom</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id181" class="indexterm"/>allows you to zoom in and out of the scene. When you use a number lower than <code class="literal">1</code>, you'll zoom out of the scene; if you use a number higher than <code class="literal">1</code>, you'll zoom in. Note that if you specify a negative value, the scene will be rendered upside down. The default value is <code class="literal">1</code>.</p>
</td></tr></tbody></table></div><p>All <a id="id182" class="indexterm"/>these properties can be summarized in the following figure:</p><div><img src="img/2215OS_02_18.jpg" alt="Orthographic camera versus perspective camera"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Looking at specific points</h2></div></div></div><p>Until now, you've <a id="id183" class="indexterm"/>seen how to create a camera and what the various arguments mean. In the previous chapter, you also saw that you need to position your camera somewhere in the scene, and that the view from that camera is rendered. Normally, the camera is pointed to the center of the scene: position (0,0,0). We can, however, easily change what the camera is looking at, as follows:</p><div><pre class="programlisting">camera.lookAt(new THREE.Vector3(x,y,z));</pre></div><p>I've added an example where the camera moves, and the point it is looking at is marked with a red dot, as follows:</p><div><img src="img/2215OS_02_19.jpg" alt="Looking at specific points"/></div><p>If you open the <code class="literal">08-cameras-lookat</code> example, you'll see the scene moving from left to right. The scene isn't really moving. The camera is looking at different points (see the red dot in the center), which gives the effect that the scene is moving from left to right. In this example, you <a id="id184" class="indexterm"/>can also switch cameras to the orthographic one. There, you see that changing the point the camera looks at has pretty much the same effect as with <code class="literal">THREE.PerspectiveCamera</code>. The interesting part to notice, though, is that with <code class="literal">THREE.OrthographicCamera</code>, you can clearly see that the sizes of all the cubes stay the same regardless of where the camera is looking.</p><div><img src="img/2215OS_02_20.jpg" alt="Looking at specific points"/></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>When you use the <code class="literal">lookAt</code> function, you point the camera at a specific position. You can also use this to make the camera follow an object around the scene. Since every <code class="literal">THREE.Mesh</code> object has a position that is a <code class="literal">THREE.Vector3</code> object, you can use the <code class="literal">lookAt</code> function to point to a specific mesh in the scene. All you need to do is this: <code class="literal">camera.lookAt(mesh.position)</code>. If you call this in <a id="id185" class="indexterm"/>the render loop, you'll make the camera follow an object as it moves through the scene.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>We discussed a lot of items in this second introduction chapter. We showed all the functions and properties of <code class="literal">THREE.Scene</code> and explained how you can use these properties to configure your main scene. We also showed you how you can create geometries. You can either create them from scratch using a <code class="literal">THREE.Geometry</code> object or use any of the built-in geometries Three.js provides. Finally, we showed you how you can configure the two cameras Three.js provides. <code class="literal">THREE.PerspectiveCamera</code> renders a scene using a real-world perspective, and <code class="literal">THREE.OrthographicCamera</code> provides a fake 3D effect also often seen in games. We've also introduced how geometries work in Three.js. You can now easily create your own geometries.</p><p>In the next chapter, we'll look at the various light sources that are available in Three.js. You'll learn how the various light sources behave, how to create and configure them, and how they affect specific materials.</p></div></body></html>