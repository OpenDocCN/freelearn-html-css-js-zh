- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this final chapter of the book, it is time to wrap up our journey, with
    several vital topics around general JavaScript framework development, and take
    a glimpse into the future of frameworks in this ecosystem. Over the preceding
    chapters, we have dissected real-world examples and built a robust knowledge base
    centered on project maintenance and organization. Harnessing that practical knowledge,
    in this chapter, we will focus on the current status quo of frameworks and examine
    several predictions to see where innovation in this space is heading in the future.
    The overall goal is to understand the best practices of JavaScript framework development
    that are prevalent today, as well as to explore some of the future patterns as
    they emerge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential takeaways from this chapter will be around bridging the gap between
    where we are today in the framework development space and what kind of solutions
    framework authors will build in the near to long-term future. This in-depth exploration
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The common themes of frameworks**: The first part discusses several architectural
    patterns and common choices across many of the framework projects we have seen
    in this book. Elements such as modularity, approaches to code bases, standardization
    of best practices, and performance-based design are cornerstones of effective
    and robust frameworks. With these elements, we will be better equipped to anticipate
    innovation in this sphere of software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Future of frameworks**: We will see what factors will affect how frameworks
    evolve as time passes, focusing on themes dealing with developer experience, addressing
    full-stack complexity, and highlighting potential new approaches to development.
    This section highlights the potential paradigm shifts in development approaches
    poised to redefine the industry’s trajectory. Considering and researching new
    trends and techniques is important as you start building new software for the
    public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional development considerations**: Finally, to wrap up our adventure,
    the section on additional considerations turns the spotlight on important factors
    such as time investment, financial backing, and overall software support. These
    factors, often overlooked as projects progress, significantly shape the process
    and outcome of framework projects. These additional considerations are important
    for any type of framework developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these topics on *best practices*, this chapter highlights the enduring
    principles of JavaScript framework development – taking common themes into account,
    looking into the factors that will shape the future of similar projects, and looking
    at the auxiliary considerations that must be taken into account. Understanding
    these *best practices* is the key to unlocking your potential to comprehend and
    influence the development trajectory of your own JavaScript frameworks. These
    skills will remain future-proof, regardless of the changing tech landscape, as
    you further dive into the development of your project. The first section on common
    themes in development looks at several examples of concepts reused in framework
    development today. Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to [*Chapter 9*](B19014_09.xhtml#_idTextAnchor156), the `chapter10`
    directory consists of several sample projects that showcase tools related to framework
    best practices. Refer to the `chapter10/README.md` files for a guide that documents
    the contents of the child directories of those chapters. The technical requirements
    are similar to the other chapters, such as the use of Node.js 20 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Common themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the current state of framework projects in the JavaScript ecosystem,
    we can see stability, vibrancy, and chaos in the JavaScript framework field. For
    instance, we have seen many projects utilizing an approach to build on existing
    primitives, such as many of the frameworks using the React component library as
    the foundation for component architecture and rendering in the browser. At the
    other end of the spectrum, projects are created from the ground up, reinventing
    the approach to rendering in the browser or solving particular challenges of software
    development with JavaScript. This section explores similar common themes that
    occur across many projects. Knowing these particular commonalities helps framework
    developers stay in touch with the rest of the ecosystem and develop more cohesive
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: When we take a zoomed-out view of the current state of all these projects, at
    one end of the spectrum, we find large, established frameworks that underpin numerous
    high-traffic applications and sophisticated tooling. With every release, these
    frameworks augment their maturity and stability. For instance, Electron sits on
    the throne as the most popular framework for utilizing web technologies for application
    development. Each new version steadily improves its design and addresses its performance
    metrics. Conversely, a set of evolving projects generates fresh, new ideas in
    the JavaScript community. These newcomers, whether introduced as public resources
    or crafted for internal business needs, inject a dose of novelty and versatility
    into the ecosystem. For example, *Svelte* and *SvelteKit* challenge some of the
    established paradigms and sway certain developer mindsets toward a different approach.
    As the approach to web application architecture changes and evolves, this whole
    spectrum entices excitement, opportunities, and new technological advancements
    for all JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Framework showcase* section in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    we charted the evolution of framework development across an expansive timeline.
    From their beginnings as specialized solutions for specific tasks, such as their
    initial focus on single-page apps, frameworks have evolved to become all-encompassing
    development platforms. A modern-day framework’s functionality is exponentially
    broader and richer, including solutions for full stack needs and beyond. In the
    practical example of the development of the *Componium* framework in *Chapters
    6*, *7*, and *8*, we saw a reliance on the diverse set of packages and abstractions
    to construct this comprehensive framework to form a fully fledged full stack system.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modularity is one of the common themes we can devise from many of the projects
    mentioned in this book. The modularity concepts apply to JavaScript projects in
    many ways, and they are also specific to JavaScript projects, compared to projects
    in other programming ecosystems. The modular approach to development has been
    fueled by the structure of web applications and the package structure in registries
    such as `npm`, backed by the `package.json` format. In comparison, when looking
    at programming languages such as Python, they depend on external project dependencies
    but lack a standardized method to effectively handle these dependencies. JavaScript
    is in a unique situation, where the frameworks use many internal and external
    modules. This approach is both beneficial to development velocity and burdensome
    from a maintenance point of view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The modularity of AdonisJS](img/Figure_10.1_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The modularity of AdonisJS'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.1* depicts an example of modularity in *AdonisJS*. The figure
    presents the outline structure of the first-party packages of that framework.
    The AdonisJS framework packages are well-organized and decoupled for the sake
    of developers, who can choose what fits their use cases better. Most of the packages
    are installed from the Adonis namespace – `npm install @adonisjs/ally`. They are
    later configured using the framework’s command line tool, called **Ace**. In the
    AdonisJS core, the code base also relies on several modules for development and
    end user features: [github.com/adonisjs/core/blob/develop/package.json](https://github.com/adonisjs/core/blob/develop/package.json).
    This is just another example of a common theme we see across all of the projects
    in the ecosystem; this approach will likely not change any time soon as new projects
    become more popular in the community. As a framework developer, you would embrace
    the available existing code and structure your projects to consist of modules
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing out the modularity
  prefs: []
  type: TYPE_NORMAL
- en: The `chapter10/adonisjs` directory consists of a sample AdonisJS project. In
    the project directory, you can run `npm install` and then `npm` `run dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is running, you can open the following address in your browser:
    `http://127.0.0.1:3333/`. With the example app running, you can install and use
    additional modules, such as the one listed earlier in this section, via `npm install
    @adonisjs/ally`. You can find more modules and packages at [adonisjs.com](https://adonisjs.com).'
  prefs: []
  type: TYPE_NORMAL
- en: The increased complexity of architectures contrasts with the benefits of modularity.
    For instance, the more isolated the modules that a framework consumes or exposes
    are, the more you have to think about coupling and how all those modules fit together.
    More recent challenges deal with keeping dependencies up to date or tagging new
    releases of a framework’s separated modules. Framework developers have to invest
    a lot more time in managing the dependencies they consume and produce, which is
    not something that is going to change in JavaScript platforms any time soon.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common theme among many JavaScript frameworks is the concept of evolving
    design. Similar to systems in other languages, the frameworks that are built in
    JavaScript need to evolve over time in response to the changing environment. The
    changing factors could include technological changes or advancement, new industry
    trends, or catching up with competing frameworks. In the case of JavaScript, these
    factors are advancements to web browsers, Node.js APIs, runtime improvements,
    and so on. Well-defined abstractions and thoughtful architecture can help you
    to adapt to these changes, without having to do drastic refactoring in framework
    projects. Several examples come to mind that show evidence of such drastic changes
    in environments in which JavaScript frameworks exist, such as the introduction
    of web components and related modern APIs for frontend frameworks. Some of the
    frameworks chose to embrace the new standards or integrate with them to be more
    compatible with the evolving web.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is migration to the **ECMAScript module** (**ESM**) format.
    First, projects had to adapt to a third-party module system, such as CommonJS
    or AMD, or implement their own system. Then, as the official JavaScript module
    definition was created, it was up to the projects to embrace the new ways of structuring
    code bases. With all the benefits of ESM, such as the static module structure
    and improved syntax across all JavaScript environments, there were still intricate
    incompatibilities across some of the use cases. It is up to framework authors
    to determine and evaluate the ESM support for their projects. For example, since
    version 16, the Angular project started off supporting ESM modules as a developer
    preview and offering it as an option. This enabled the project to expand the feature
    set with dynamic import expressions and lazy module loading. In addition, the
    change improved the build-time performance for application builds. It also allowed
    the framework to use more modern tools such as *esbuild*, which was also used
    in the Componium framework.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Partial release notes for Electron.js](img/Figure_10.2_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Partial release notes for Electron.js'
  prefs: []
  type: TYPE_NORMAL
- en: For an application framework such as Electron, the framework feature offers
    changes on every major release. This is because the major releases often track
    changes to the underlying Chromium, Node.js, and V8 changes, as seen in the release
    notes in *Figure 10**.2*. With new fixes and features in those components, what
    the framework offers evolves as new releases get shipped to the public. This is
    a compelling example of how a project leverages continuously evolving improvements
    from external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: New features such as server-side rendering have been added to many frameworks
    as new ways of hydrating and producing views on the server side became available.
    Existing projects add new capabilities to allow features such as server-side rendering
    to fit into the existing API surface and architecture. Across the board, we can
    see these similar changing trends in projects of all kinds. Thoughtfully adapting
    to the latest trends avoids project stagnation and allows us to keep up with the
    latest JavaScript advancements.
  prefs: []
  type: TYPE_NORMAL
- en: Minimalistic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common theme is the minimalistic approach to framework design. Some
    frameworks may choose to focus on simplicity and minimal architectural churn.
    In these instances, the number of dependencies and complexity are greatly reduced.
    The more simplistic frameworks can be effective in low-resource environments and
    for projects that do not require large framework overhead. In JavaScript projects,
    these frameworks usually aim to be a simple API with a tiny file size footprint
    and primarily focus on a specific isolated feature set. If the feature set fits
    the requirements, choosing this type of approach can reduce the amount of resources
    for framework development and produce a much cleaner, simpler interface for stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: To highlight some of the examples, from the frontend perspective, *Preact* ([preactjs.com](https://preactjs.com)),
    as a library, takes a minimalistic approach, offering a 3 kilobyte alternative
    to the React library. It can be used in a minimalistic framework for frontend
    rendering. A backend example would be the *Hapi.js* project from [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015).
    It focuses on the features of building API endpoints really well; if you look
    at the source of the framework, you will find fewer than 20 files within its core.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that you can build minimalistic frameworks for your
    needs and don’t always need complex tooling and a large feature set. This type
    of approach is not always about the final framework size or the number of files
    in a project, and it can also be used as the guiding principle as you make decisions
    during framework development. In many senses, when these types of projects are
    used for real-world projects, they are just as capable of achieving great results.
  prefs: []
  type: TYPE_NORMAL
- en: Build tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19014_03.xhtml#_idTextAnchor051), the *Framework compilers
    and bundlers* section showed examples of build tools. These are commonly shipped
    together with a framework to enable optimized application bundle outputs. Some
    frameworks also utilize different build tooling types or have flexible options
    to allow stakeholders to choose their build tools. Nowadays, the trend is for
    build tools that make it easier to produce outputs for many JavaScript environments,
    with a focus on speed. The other principal aspect around the combination of frameworks
    and build tools is the cooperation of many developers on improving build tooling
    workflows, enabling more use cases that fit different project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The additional benefit of build tools found in popular tools such as **webpack**
    is the enforcement of sound patterns and warning developers when application output
    is not suitable for a client or server environment. For instance, packaging tools
    can warn developers when a packaged bundle is too big for browsers to load or
    when it might not conform to the client environment that it targets.
  prefs: []
  type: TYPE_NORMAL
- en: The build tooling drives constant refinements in frameworks, through optimizations
    and advancements, and contributes to performance improvements for JavaScript applications,
    which is the next common theme that we will highlight.
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The emphasis on continuous performance improvements and benchmarking is another
    theme that is quite typical among JavaScript frameworks. Depending on the framework
    environment, the optimizations focus on consuming fewer computer resources, improving
    load or response times, promoting slicker user interaction, expanding rendering
    capabilities, and so on. These types of optimizations require greater knowledge
    of the JavaScript language and the ability to optimize the existing code. The
    process of optimizations also gets more and more complex for larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the many years since the early JavaScript frameworks, there have been quite
    a few established benchmarks and benchmarking tools. However, in many cases, these
    types of benchmarks cannot truly benchmark real user behaviors or real-world application
    use cases. Just like other types of software benchmarking, these performance testing
    systems establish a standard test to compare implementations in different scenarios.
    Even though, in many cases, the results can be flawed, they can offer some insight
    for stakeholders trying to find a framework useful for their use cases. In addition,
    even after many years of benchmarking battles, frameworks still want to showcase
    that they are ahead in certain feature sets compared to the competition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: An open source js-framework-benchmark](img/Figure_10.3_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: An open source js-framework-benchmark'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.3* previews a filtered example of results from the **js-framework-benchmark**,
    which is a benchmark focused on common list operations. It can be found at [krausest.github.io/js-framework-benchmark](https://krausest.github.io/js-framework-benchmark).
    This particular benchmark focuses on frontend solutions. If you develop a frontend
    framework, you can add your code base to the list of existing frameworks to see
    how it compares. These types of tests can showcase how the framework will work
    for applications that include complex lists of data, including updates to the
    rows of data. This benchmark also dives deep to take into account memory usage,
    load time, and framework size.'
  prefs: []
  type: TYPE_NORMAL
- en: Other types of frameworks require different types of benchmarks. For example,
    there is a comprehensive comparison at [techempower.com/benchmarks](https://techempower.com/benchmarks)
    for backend web frameworks. These tests outline a particular load test for a server-side
    framework and include projects from other programming languages. These types of
    frameworks focus more on the latency of requests, throughput, interaction with
    database queries, and so on. Aspects of the framework, such as the throughput
    of requests, demonstrate how a server running a particular framework will act
    under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of frameworks can utilize similar tests that exist in their
    framework space. If there are no existing types of tests for your kind of framework,
    then you can establish your own benchmarks and keep track of the results from
    release to release, focusing on improving the numbers that are relevant to the
    performance of the most relevant feature sets.
  prefs: []
  type: TYPE_NORMAL
- en: The common themes of today’s frameworks can vastly influence your framework
    project, but to create innovation in the systems you build, there is more to learn
    from upcoming trends. In the following section, we will take a look at future
    types of trends that influence new JavaScript projects.
  prefs: []
  type: TYPE_NORMAL
- en: Future of frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript ecosystem is still one of the most vibrant among other programming
    languages, and it is bound to grow and expand into new areas. As this happens,
    we will start seeing future innovations that will affect how frameworks are built
    and how they are utilized. The patterns used by the developers we see today will
    also change as time progresses. Keeping up with the industry tendencies and looking
    at what is ahead will help you build better systems and incorporate the latest
    trends into what you build. In this part, we take a look at some potential areas
    that framework evolution and improvements can potentially head toward.
  prefs: []
  type: TYPE_NORMAL
- en: Developer experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how important the **developer experience** (**DX**) can be in
    a framework. In the future, the DX factor will even further differentiate good
    frameworks from great ones. Providing additional tooling and finding ways to reduce
    complexity makes it much easier to start building with a framework. In recent
    years, we have seen tactics to enable an end-to-end framework DX, helping stakeholders
    with each step of the process of building applications. In company-backed projects,
    such as Next.js, those who use the framework experience a fully encompassed workflow
    from the beginning of development, all the way up to the deployment of applications.
    The concepts of amazing DX fits really well with the concepts of reducing the
    overall complexity of using a framework. Here are a few themes that will be the
    focus of DX improvements in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reducing the learning curve**: Framework authors will continue investing
    in making interfaces more approachable, especially for new developers. In both
    server and frontend environments, this could mean further aligning with the structure
    of web APIs, which helps avoid introducing new types of abstractions that have
    unique interfaces. A tip to a future framework developer would be to contemplate
    how a learning curve could be simplified for your projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified configuration**: Frameworks will take further steps to simplify
    out-of-the-box configuration, and picking options that are the best fit will help
    with development. These will include more sensible defaults, which we saw in [*Chapter
    7*](B19014_07.xhtml#_idTextAnchor108), where certain parts of the framework focus
    on a simpler configuration. For your own projects, you should take care of every
    configuration option you introduce and avoid overwhelming users with the necessary
    configuration steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved testing**: Projects will continue to make writing and executing
    tests easier, further focusing on simplifying the testing of hard-to-test components.
    For example, as new end-to-end testing frameworks have been developed, these projects
    have addressed the common developer annoyances of flakiness in tests and lack
    of debugging tools in CI environments. An emphasis on simplifying testing in your
    frameworks can help the day-to-day experience of your users, as writing tests
    is a big time sink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json` source code. Future projects will likely abstract away some
    of the tools they use in the background, allowing for more control over the DX.
    Furthermore, projects will also build more of their own tooling, using the existing
    primitives available in the ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus on performance**: Similar to the performance improvements described
    in the *Common themes* section, projects will continue pushing the limits of the
    JavaScript language and runtimes to find ways to deliver improvements on aspects
    such as rendering, latency, and other relevant metrics. With the recent emphasis
    on performance in the frontend space, developers adhere to indications of quality
    that can improve the experience of web applications. These metrics and concepts
    can be found at [web.dev/learn-core-web-vitals](https://web.dev/learn-core-web-vitals).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional flexibility**: Frameworks will continue adding more options to
    support different environments. For instance, backend solutions will expand integrations
    with more databases. Application frameworks, such as Electron, will take advantage
    of the latest APIs available to them in the browser runtime and within the operating
    system. For the frameworks you build, you should aim to strike a balance between
    flexibility and the number of use cases you support. You should only add additional
    support for use cases if you have enough resources to maintain this large set
    of features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packaging and bundling improvements**: There have been significant changes
    in how frameworks package their application code. This focus on improved packaging
    techniques will only continue with a priority on speed and enabling more options
    to bundle code in different ways. For framework developers like yourself, it is
    important to keep up with the latest improvements to these types of bundling tools,
    as they can benefit how you approach the packaging of the system you build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list does not cover all the potential directions of what JavaScript systems
    will head towards in the future. However, following the established trajectory
    of the existing projects helps to highlight where you, as a framework developer,
    can deliver significant impact and make a difference for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing new technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the developer experience improvements, new technologies are made available
    in places where JavaScript applications execute. As highlighted in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    web assembly will play an important role in enabling the next generation of solutions
    for computation-heavy tasks. This has the potential to expand the code base of
    the existing frameworks to include lower-level languages. It will also require
    maintainers to expand their domain knowledge beyond just JavaScript code. On the
    theme of other languages, the usage of TypeScript will continue to grow, as its
    benefits are very worthwhile to framework authors. However, consumers of frameworks
    will still be able to use the *built* versions of frameworks that were originally
    transpiled from TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Additional improvements to browser engines will also drive performance boosts
    and new capabilities in places where a framework relies on web browser engine
    behavior. One outlet to get inspiration from is the `blink-dev` mailing list at
    [groups.google.com/a/chromium.org/g/blink-dev](https://groups.google.com/a/chromium.org/g/blink-dev),
    which highlights the upcoming changes that will end up in Chromium and Chrome
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Package management is also an area where a lot of new technological changes
    will occur. Almost every project relies on package management tooling, such as
    `npm`, to resolve and build its code base. Package managers are so heavily involved
    in the development workflow that any improvement will impact JavaScript development
    drastically. The future will bring better versioning, dependency resolution, enhanced
    security of projects, and so on. The evolution of package managers should also
    make framework organization and development easier, allowing authors to lay out
    their projects in more developer-friendly ways.
  prefs: []
  type: TYPE_NORMAL
- en: Another big new instrument is the use of AI-powered models for the benefit of
    all the framework aspects, explored in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The use of large language models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, the advancement of **large language models** (**LLMs**) powered
    by different neural networks has affected software workflows and tools. As a step
    in framework development, the use of artificial intelligence tooling will likely
    become more prevalent. Similar to the importance of including documentation for
    project releases, developers will bundle a trained model specifically for their
    framework. This model can be aware of the project’s public APIs, internals, and
    documentation. The intertwined models can be involved at different stages of the
    development process. For instance, as you refactor code, an AI assistant powered
    by the trained model can provide you with suggestions for potential changes. As
    these model integrations become increasingly refined, they could also take over
    some of the more repetitive or redundant tasks involved in project maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: An example of the Astro AI framework assistant](img/Figure_10.4_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: An example of the Astro AI framework assistant'
  prefs: []
  type: TYPE_NORMAL
- en: Using a real-world example, as shown in *Figure 10**.4*, the all-in-one framework
    **Astro** specifically trained a model to answer questions about a project. This
    developer tool is made available for public use, solving potential support and
    integration hurdles by allowing users to ask questions about the project. The
    tool is available at [houston.astro.build](https://houston.astro.build). This
    type of tooling can accept a query about certain features of the project, such
    as creating API routes and endpoints. The response consists of a text response
    gathered from a mix of documentation and the conversation model. The final resources
    link directs a user to [docs.astro.build/en/core-concepts/endpoints](https://docs.astro.build/en/core-concepts/endpoints),
    which has information about configuring the endpoints for applications that utilize
    this framework.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting these similar ideas of using trained AI models for the sake of better
    developer experience, trained LLMs can be used for scaffolding purposes and within
    the framework tooling itself. In [*Chapter 8*](B19014_08.xhtml#_idTextAnchor138),
    we have seen examples of generating code within the Componium framework; a potential
    future enhancement can be prompted for a query from an application developer about
    the component they are trying to build. The later generated code can save a lot
    of time for developers, reducing the amount of documentation they have to read
    and the amount of code they have to write. Creating and understanding these LLM-powered
    integrations would be an additional step to the full stack developer paradigm.
    Integrating these types of LLMs at different stages of framework development and
    maintenance will change where framework authors spend most of their time within
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: With the current and future themes covered, let's explore what other aspects
    we should consider that fit into the development of new framework projects.
  prefs: []
  type: TYPE_NORMAL
- en: Additional considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B19014_05.xhtml#_idTextAnchor073), we explored a wide range
    of framework considerations, specifically affecting the technical architecture.
    As creating a new framework project, even with a totally unique technical feature
    set, is a big decision, let's examine a few additional considerations. Outside
    of the technical challenges, this examination will help us decide whether starting
    a project from scratch and maintaining it for a long time is worth an investment.
    Successfully producing a framework project with a lot of stakeholders and targeted
    users will require both time investment and financial backing.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the technical hurdles and architectural challenges, framework developers
    need to consider the probable return on investment when embarking on a new project.
    Looking at some of the established projects in the JavaScript space, many of them
    have been multi-year investments, with a huge number of developers contributing
    paid or open source time to enable the feature set. Let’s focus on the particular
    three pillars of time investment, user support, and financial backing in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Time investment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Framework developers need to consider a new project’s time investment and lifespan.
    It’s not simply about the development phase but also the life cycle commitment
    it entails, which could affect multiple teams within an organization or the company’s
    larger goals. Open source developers have similar commitments to consider but
    with lesser responsibility, especially at the early stages of the project. Unlike
    typical JavaScript application projects, framework development typically doesn’t
    have a linear timeline or a designated end milestone where a deliverable is considered
    complete. Instead, the process is iterative, with development cycles, testing,
    refinement, and updating. These themes link back to the chapters on maintenance
    and the development life cycle of new features.
  prefs: []
  type: TYPE_NORMAL
- en: A framework project will demand more than a sizable initial coding investment
    created by one developer or a whole team. The ongoing updates necessary to adapt
    to ever-evolving requirements and technological conventions will require equally
    weighty commitments. Considering the tasks we saw in [*Chapter 9*](B19014_09.xhtml#_idTextAnchor156),
    the maintenance time investment encompasses the need for a comprehensive workflow,
    involving many developers. When choosing to build a new solution, consider how
    much time you are willing to invest and what size framework you can successfully
    execute on. Making a considerate decision will determine whether your framework
    effort will succeed.
  prefs: []
  type: TYPE_NORMAL
- en: User support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As important as time investment is user support, which often determines the
    success of a project. Besides producing readable and well-organized documentation,
    a deep understanding of the challenges and needs of users spans beyond the code
    base. For all types of framework projects, as a developer, you will find yourself
    or your team acting as support and troubleshooting framework integration aspects.
    To give a public example, the Vue.js project has a discussion forum where users
    publish their technical and architectural questions: [github.com/vuejs/core/discussions](https://github.com/vuejs/core/discussions).
    It is up to the team to respond to these queries and maintain a good community
    posture. In projects that are internal to the company, framework authors often
    set up a similar platform to interact with consumers. For smaller companies, this
    support interaction is much more hands-on and direct. However, in all of these
    scenarios, the support aspects take up important development time.'
  prefs: []
  type: TYPE_NORMAL
- en: The best strategy to reduce this type of churn is to constantly work on improving
    support workflows. Improvements can include organizing frequently asked questions
    for later use, creating guides for complicated framework integrations, and making
    the framework knowledge base as discoverable as possible. Just like the cyclical
    development process seen in [*Chapter 9*](B19014_09.xhtml#_idTextAnchor156), as
    a maintainer, you will find yourself in an ongoing commitment to support new and
    older users of your project. For a project to be successful, you have to put your
    users first and be able to address their needs in an acceptable manner.
  prefs: []
  type: TYPE_NORMAL
- en: All this time investment in additional aspects of framework building requires
    a monetary budget, which we will highlight in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Financial backing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the complex technical challenges, time investment, and logistics of supporting
    a project, there is another factor to consider for a framework – that is, the
    presence of financial backing. Funding a new project will require enduring the
    ongoing expenses for feature development and infrastructure costs. Additional
    costs could arise, depending on the environment of your project – for example,
    if you are trying to promote an enterprise framework to potential customers. In
    a company setting, where the framework powers the foundational services and products
    indirectly, the funding can trickle down from the profits of the products.
  prefs: []
  type: TYPE_NORMAL
- en: Most open source projects are often not fully funded but could be sponsored
    by a larger organization with a big enough budget for projects, which also indirectly
    help development efforts or advance the agenda of the organization. For instance,
    the Cypress open source testing framework has a paid Cypress Cloud service that
    enables a dedicated environment. Conversely, some of the open source developers
    utilize platforms such as Patreon or GitHub Sponsors to fund projects, getting
    direct financial contributions from companies and individual users.
  prefs: []
  type: TYPE_NORMAL
- en: These additional considerations can play an important role in planning and executing
    your project. Depending on your development goals, some of these factors can make
    or break the framework project you are trying to establish.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has brought to attention the three final topics that can help framework
    developers better understand the efforts of creating new frameworks, under the
    common themes of JavaScript development. A look at the future of projects also
    helps developers understand and prepare for what is to come in this particular
    technological space. By exploring the common themes, you gain knowledge of how
    modular projects can be and how their design evolves as time goes on, making it
    easier to make decisions about self-created projects. Similarly, learning about
    approaches to performance optimizations and unique architectural patterns can
    be beneficial to prospective framework authors.
  prefs: []
  type: TYPE_NORMAL
- en: In the second section, the chapter highlighted upcoming trends and looked at
    the future potential of frameworks, offering us a glimpse of what is to come in
    this space. The next generation of framework authors and maintainers gets to experience
    the new challenges of the JavaScript environment and refactor existing solutions
    to make them more capable in new ways. The expectations of a better developer
    experience and the still unknown possibilities of LLMs keep the framework space
    super exciting for both experienced and upcoming JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end, the chapter highlighted additional considerations that can help
    developers make the right decisions in terms of starting new projects. These non-technical
    considerations are much less exciting to the developers, but they are crucial
    to the framework creation process. This final chapter aims to provide further
    insights to bolster your understanding of framework development and prepare you
    for success in your real-world projects.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the goal of this and all the chapters before it was to demystify
    the framework development methods and make the process of building your own JavaScript
    frameworks much more approachable to all. With this acquired knowledge, you now
    have the skills to make better decisions and drive more complex framework-related
    projects to success. We began this book with our journey, looking at existing
    projects, then identified crucial parts of framework development, and later concluded
    by building a full-stack framework from scratch. This includes an exploration
    of architectural patterns and project considerations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize the topics that we learned about in all these chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge of other projects in the JavaScript space**: The initial chapter
    showcased how different types of frameworks have emerged and what problems they
    solve for a larger developer user base. The collection of projects gave us a peek
    into existing solutions that help solve software challenges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework organization and building blocks**: This taught us the basics around
    abstractions in frameworks and the basics of the building blocks applied to backend,
    frontend, and other types of initiatives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architectures and patterns**: This showed us examples of concepts and structures
    behind the existing projects, such as Angular and Vue.js. This included mentions
    of additional tooling that helps put frameworks together for consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensuring framework quality**: This taught us ideas of how frameworks can
    provide a quality experience through creating documentation, ensuring well-tested
    components, and how development tooling can help ensure the delivery of good software
    to its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview of project considerations**: This helped create a plan for development,
    with aspects to consider before starting work on technical problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a new testing framework**: This gave us practical experience in
    creating a practical framework project. This introduced the technical architecture
    behind a testing system with detailed features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developing backend components**: This continued the practical approach with
    a focus on backend development. We outlined an approach to server-side solutions
    and developer experience of Componium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crafting frontend components**: This was the final part of the practical
    approach that specializes in frontend components. It included architectural design,
    with concepts of reactivity, server-side rendering, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The effort it takes to maintain a project**: This taught us about the tasks
    that framework developers have to perform daily and cyclically as new features
    and fixes get added to a project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning about common themes of today and the future**: Finally, this part
    summarized the typical things we see in JavaScript projects today, with additional
    considerations for new projects and the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this newly gathered knowledge will unlock more possibilities for you in
    the JavaScript ecosystem, enabling you to be a more effective and acquainted engineer,
    greatly benefiting your career and the projects you are responsible for. The web
    application development field is constantly evolving in many ways, which powers
    this exciting ecosystem of JavaScript frameworks. Even with the availability of
    flexible building blocks and fully fledged solutions, there is still room for
    further expansion and improvement – it has never been a better time to develop
    a JavaScript framework or contribute to one!
  prefs: []
  type: TYPE_NORMAL
