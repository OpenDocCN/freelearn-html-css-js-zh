<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Using Proxies"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Using Proxies</h1></div></div></div><p>Proxies are used to define the custom behavior for the fundamental operations on objects. Proxies are already available in the programming languages such as C#, C++, and Java, but JavaScript has never had proxies. ES6 introduced the Proxy API, which lets us create proxies. In this chapter, we will look at proxies, their usage, and the proxy traps. Due to the benefits of proxies, the developers are using proxies increasingly and therefore, it's important to learn about proxies in-depth with examples, which we will do in this chapter.</p><p>In this chapter, we'll cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating proxies using the Proxy API</li><li class="listitem" style="list-style-type: disc">Understanding what proxies are and how to use them</li><li class="listitem" style="list-style-type: disc">Intercepting various operations on the objects using traps</li><li class="listitem" style="list-style-type: disc">The different kinds of available traps</li><li class="listitem" style="list-style-type: disc">Some use cases of proxies</li></ul></div><div class="section" title="Proxies in a nutshell"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Proxies in a nutshell</h1></div></div></div><p>A proxy acts like a <a id="id336" class="indexterm"/>wrapper for an object, and defines the custom behavior for the fundamental operations on the object. Some fundamental operations on the objects are property lookup, property assignment, constructor invocation, enumeration, and so on.</p><p>Once an object is wrapped using a proxy, all the operations that are supposed to be done on the object should now be done on the proxy object, so that the custom behavior can take place.</p><div class="section" title="Terminology"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Terminology</h2></div></div></div><p>Here are some important terms that are used while studying proxies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Target: This<a id="id337" class="indexterm"/> is the<a id="id338" class="indexterm"/> object that is wrapped by proxy.</li><li class="listitem" style="list-style-type: disc">Traps: These are <a id="id339" class="indexterm"/>functions that intercept various <a id="id340" class="indexterm"/>operations on the target object, and define the custom behavior for those operations.</li><li class="listitem" style="list-style-type: disc">Handler: This is an <a id="id341" class="indexterm"/>object that holds the traps. A handler<a id="id342" class="indexterm"/> is attached to a proxy object.</li></ul></div></div></div></div>
<div class="section" title="The Proxy API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>The Proxy API</h1></div></div></div><p>The ES6 Proxy API <a id="id343" class="indexterm"/>provides the <code class="literal">Proxy</code> constructor to create proxies. The <code class="literal">Proxy</code> constructor takes two arguments, which are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Target</strong></span>: This is the<a id="id344" class="indexterm"/> object that will be wrapped by the proxy</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Handler</strong></span>: This is an <a id="id345" class="indexterm"/>object that contains the traps for the target object</li></ul></div><p>A trap can be defined for every possible operation on the target object. If a trap is not defined, then the default action takes place on the target.</p><p>Here is a code example that shows how to create a proxy, and do various operations on the target object. In this example, we have not defined any traps:</p><div class="informalexample"><pre class="programlisting">var target = {
  age: 12
};
var handler = {};
var proxy = new Proxy(target, handler);

proxy.name = "Eden";

console.log(target.name);
console.log(proxy.name);
console.log(target.age);
console.log(proxy.age);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">Eden
Eden
12
12</pre></div><p>Here, we can see that the <code class="literal">age</code> property of the <code class="literal">target</code> object can be accessed via the <code class="literal">proxy</code> object. And when we added the <code class="literal">name</code> property to the <code class="literal">proxy</code> object, it was actually added to the <code class="literal">target</code> object.</p><p>As there was no trap attached for the property assignment, the <code class="literal">proxy.name</code> assignment resulted to the default behavior that is simply assigning the value to the property.</p><p>So, we can say a <code class="literal">proxy</code> is just a wrapper for a <code class="literal">target</code> object and traps can be defined to change the default behavior of operations.</p><p>Many developers don't keep a reference variable for the target object to make use of the proxy mandatory for accessing the object. Keep a reference for the handler only when you need to reuse it for multiple proxies. Here is how they rewrite the previous code:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({
  age: 12
}, {});

proxy.name = "Eden";</pre></div><div class="section" title="Traps"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Traps</h2></div></div></div><p>There are different traps<a id="id346" class="indexterm"/> for different operations that can be performed on an object. Some of the traps need to return values. There are some rules they need to follow while returning values. The returned values are intercepted by the proxy to filter, and/or to check if the returned values obey the rules. If a trap doesn't obey rules while returning value, then the proxy throws the <code class="literal">TypeError</code> exception.</p><p>The value of <code class="literal">this</code> inside a trap is always a reference to the handler.</p><p>Lets take a look at the various kinds of traps.</p><div class="section" title="The get(target, property, receiver) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec25"/>The get(target, property, receiver) method</h3></div></div></div><p>The <code class="literal">get</code> trap is executed when <a id="id347" class="indexterm"/>we retrieve a property value using <a id="id348" class="indexterm"/>the dot or bracket notation, or the <code class="literal">Reflect.get()</code> method. It takes three parameters, that is, the target object, the property name, and the proxy.</p><p>It must return a value that represents the property value.</p><p>Here is a code example, which shows how to use the <code class="literal">get</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({
    age: 12
  }, {
    get: function(target, property, receiver){
      if(property in target)
      {
        return target[property];
      }
      else
      {
        return "Not Found";
      }
    }
  }
);

console.log(Reflect.get(proxy, "age"));
console.log(Reflect.get(proxy, "name"));</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">12
Not found</pre></div><p>Here, we can<a id="id349" class="indexterm"/> see that the <code class="literal">get</code> trap looks for the <a id="id350" class="indexterm"/>property in the <code class="literal">target</code> object, and if it finds it, then returns the property value. Otherwise, it returns a string indicating that it was not found.</p><p>The <code class="literal">receiver</code> parameter is the reference of the object whose property we intended to access. Consider this example to better understand the value of the <code class="literal">receiver</code> parameter:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 13}, {
    get: function(target, property, receiver){

      console.log(receiver);

      if(property in target)
      {
        console.log(receiver);
        return target[property];
      }
      else
      {
        return "Not Found";
      }
    }
  }
);

var temp = proxy.name;

var obj = {
  age: 12,
  __proto__: proxy
}

temp = obj.name;</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">{age: 13}
{age: 12}</pre></div><p>Here <code class="literal">obj</code> inherits<a id="id351" class="indexterm"/> the <code class="literal">proxy</code> object. Therefore, when the <code class="literal">name</code> property was not found in the <code class="literal">obj</code> object, it was looked in the <code class="literal">proxy</code> object. As the <code class="literal">proxy</code> object had a <code class="literal">get</code> trap, it provided a value.</p><p>So, the value of the <code class="literal">receiver</code> parameter when we accessed the <code class="literal">name</code> property via the <code class="literal">obj.name</code> expression, is <code class="literal">obj</code>, and when we accessed the <code class="literal">name</code> property via <code class="literal">proxy.name</code> expression is <code class="literal">proxy</code>.</p><p>The value of the <code class="literal">receiver</code> parameter is decided in the same way for all other traps also.</p><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec01"/>Rules</h4></div></div></div><p>These rules <a id="id352" class="indexterm"/>shouldn't be violated while using the <code class="literal">get</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The value returned for a property must be the same as the value of the target object property if the target object property is a non-writable, non-configurable data property.</li><li class="listitem" style="list-style-type: disc">The value returned for a property must be <code class="literal">undefined</code> if the target object property is non-configurable accessor property that has <code class="literal">undefined</code> as its <code class="literal">[[Get]]</code> attribute.</li></ul></div></div></div><div class="section" title="The set(target, property, value, receiver) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec26"/>The set(target, property, value, receiver) method</h3></div></div></div><p>The <code class="literal">set</code> trap is invoked when we set <a id="id353" class="indexterm"/>the value<a id="id354" class="indexterm"/> of a property using the assignment operator, or the <code class="literal">Reflect.set()</code> method. It takes four parameters, that is, the target object, the property name, the new property value, and the receiver.</p><p>The <code class="literal">set</code> trap must return <code class="literal">true</code> if the assignment was successful. Otherwise, it will return <code class="literal">false</code>.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">set</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({}, {
  set: function(target, property, value, receiver){
    target[property] = value;
    return true;
  }
});

Reflect.set(proxy, "name", "Eden");
console.log(proxy.name); //Output "Eden"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec02"/>Rules</h4></div></div></div><p>These rules<a id="id355" class="indexterm"/> shouldn't be violated while using<a id="id356" class="indexterm"/> the <code class="literal">set</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the target object property is a non-writable, non-configurable data property, then it will return as <code class="literal">false</code>, that is, you cannot change the property value</li><li class="listitem" style="list-style-type: disc">If the target object property is a non-configurable accessor property that has <code class="literal">undefined</code> as its <code class="literal">[[Set]]</code> attribute, then it will return as false, that is, you cannot change the property value</li></ul></div></div></div><div class="section" title="The has(target, property) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec27"/>The has(target, property) method</h3></div></div></div><p>The <code class="literal">has</code> trap is executed <a id="id357" class="indexterm"/>when we check if a property exists or not, using <a id="id358" class="indexterm"/>the <code class="literal">in</code> operator. It takes two parameters, that is, the target object and the property name. It must return a Boolean value that indicates whether the property exists or not.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">has</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 12}, {
  has: function(target, property){
    if(property in target)
    {
      return true;
    }
    else
    {
      return false;
    }
  }
});

console.log(Reflect.has(proxy, "name"));
console.log(Reflect.has(proxy, "age"));</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">false
true</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec03"/>Rules</h4></div></div></div><p>These rules <a id="id359" class="indexterm"/>shouldn't<a id="id360" class="indexterm"/> be violated while using the <code class="literal">has</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You cannot return <code class="literal">false</code> if the property exists as a non-configurable own property of the <code class="literal">target</code> object</li><li class="listitem" style="list-style-type: disc">You cannot return <code class="literal">false</code> if the property exists as an own property of the <code class="literal">target</code> object, and the <code class="literal">target</code> object is not extensible</li></ul></div></div></div><div class="section" title="The isExtensible(target) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec28"/>The isExtensible(target) method</h3></div></div></div><p>The <code class="literal">isExtensible</code> trap is executed <a id="id361" class="indexterm"/>when we check if the object is extensible or not, using<a id="id362" class="indexterm"/> the <code class="literal">Object.isExtensible()</code> method. It takes only one parameter, that is, the <code class="literal">target</code> object. It must return a Boolean value indicating whether the object is extensible or not.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">isExtensible</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 12}, {
  isExtensible: function(target){
    return Object.isExtensible(target);
  }
});

console.log(Reflect.isExtensible(proxy)); //Output "true"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec04"/>Rules</h4></div></div></div><p>These rules shouldn't<a id="id363" class="indexterm"/> be violated while using the <code class="literal">isExtensible</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You cannot return <code class="literal">false</code> if the target is extensible. Similarly, you cannot return <code class="literal">true</code> if the target is non-extensible.</li></ul></div></div></div><div class="section" title="The getPrototypeOf(target) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec29"/>The getPrototypeOf(target) method</h3></div></div></div><p>The <code class="literal">getPrototypeOf</code> trap is executed<a id="id364" class="indexterm"/> when we retrieve the value of the <a id="id365" class="indexterm"/>internal <code class="literal">[[prototype]]</code> property, using either the <code class="literal">Object.getPrototypeOf()</code> method or the <code class="literal">__proto__</code> property. It takes only one parameter, that is, the <code class="literal">target</code> object.</p><p>It must return an object or <code class="literal">null</code> value. The <code class="literal">null</code> value indicates that the object doesn't inherit anything else and is the end of the inheritance chain.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">getPrototypeOf</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 12, __proto__: {name: "Eden"}}, {
  getPrototypeOf: function(target){
    return Object.getPrototypeOf(target);
  }
});

console.log(Reflect.getPrototypeOf(proxy).name); //Output "Eden"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec05"/>Rules</h4></div></div></div><p>These rules<a id="id366" class="indexterm"/> shouldn't be violated while using the <code class="literal">getPrototypeOf</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It must either <a id="id367" class="indexterm"/>return an object or return <code class="literal">null </code>value.</li><li class="listitem" style="list-style-type: disc">If the target is not extensible, then this trap must return the actual prototype</li></ul></div></div></div><div class="section" title="The setPrototypeOf(target, prototype) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec30"/>The setPrototypeOf(target, prototype) method</h3></div></div></div><p>The <code class="literal">setPrototypeOf</code> trap<a id="id368" class="indexterm"/> is executed when we set the value of<a id="id369" class="indexterm"/> the internal <code class="literal">[[prototype]]</code> property, using either the <code class="literal">Object.setPrototypeOf()</code> method or the <code class="literal">__proto__</code> property. It takes two parameters, that is, the target object and value of the property to be assigned.</p><p>This trap will return a Boolean, indicating whether it has successfully set the prototype or not.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">setPrototypeOf</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({}, {
  setPrototypeOf: function(target, value){
    Reflect.setPrototypeOf(target, value);
    return true;
  }
});

Reflect.setPrototypeOf(proxy, {name: "Eden"});

console.log(Reflect.getPrototypeOf(proxy).name); //Output "Eden"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec06"/>Rules</h4></div></div></div><p>These rules<a id="id370" class="indexterm"/> shouldn't be violated while using the <code class="literal">setPrototypeOf</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You must return <code class="literal">false</code> if the target is not extensible</li></ul></div></div></div><div class="section" title="The preventExtensions(target) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec31"/>The preventExtensions(target) method</h3></div></div></div><p>The <code class="literal">preventExtensions</code> <a id="id371" class="indexterm"/>trap is <a id="id372" class="indexterm"/>executed when we prevent the addition of new properties using the <code class="literal">Object.preventExtensions()</code> method. It takes only one parameter, that is, the <code class="literal">target</code> object.</p><p>It must return a Boolean, indicating weather it has successfully prevented the extension of the object or not.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">preventExtensions</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({}, {
  preventExtensions: function(target){
    Object.preventExtensions(target);
    return true;
  }
});

Reflect.preventExtensions(proxy);

proxy.a = 12;
console.log(proxy.a); //Output "undefined"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec07"/>Rules</h4></div></div></div><p>These rules <a id="id373" class="indexterm"/>shouldn't be violated while using the <code class="literal">preventExtensions</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This trap<a id="id374" class="indexterm"/> can return <code class="literal">true</code> only if the target is non-extensible, or it has made the target non-extensible</li></ul></div></div></div><div class="section" title="The getOwnPropertyDescriptor(target, property) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec32"/>The getOwnPropertyDescriptor(target, property) method</h3></div></div></div><p>The <code class="literal">getOwnPropertyDescriptor</code> trap is<a id="id375" class="indexterm"/> executed when we <a id="id376" class="indexterm"/>retrieve the descriptor of a property by using the <code class="literal">Object.getOwnPropertyDescriptor()</code> method. It takes two parameters, that is, the target object and the name of the property.</p><p>This trap must return a descriptor object or <code class="literal">undefined</code>. The <code class="literal">undefined</code> value is returned if the property doesn't exist.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">getOwnPropertyDescriptor</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 12}, {
  getOwnPropertyDescriptor: function(target, property){
    return Object.getOwnPropertyDescriptor(target, property);
  }
});

var descriptor = Reflect.getOwnPropertyDescriptor(proxy, "age");

console.log("Enumerable: " + descriptor.enumerable);
console.log("Writable: " + descriptor.writable);
console.log("Configurable: " + descriptor.configurable);
console.log("Value: " + descriptor.value);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">Enumerable: true
Writable: true
Configurable: true
Value: 12</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec08"/>Rules</h4></div></div></div><p>These rules <a id="id377" class="indexterm"/>shouldn't be violated while using the <code class="literal">getOwnPropertyDescriptor</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This trap<a id="id378" class="indexterm"/> must either return an object or return an <code class="literal">undefined</code> property</li><li class="listitem" style="list-style-type: disc">You cannot return the <code class="literal">undefined</code> value if the property exists as a non-configurable own property of the <code class="literal">target</code> object</li><li class="listitem" style="list-style-type: disc">You cannot return the <code class="literal">undefined</code> value if the property exists as an own property of the <code class="literal">target</code> object, and the <code class="literal">target</code> object is not extensible</li><li class="listitem" style="list-style-type: disc">You will have to return <code class="literal">undefined</code>, if the property does not exist as an own property of the <code class="literal">target</code> object, and the <code class="literal">target</code> object is not extensible</li><li class="listitem" style="list-style-type: disc">You cannot make the <code class="literal">configurable</code> property of the returned descriptor object false, if the property exists as an own property of the <code class="literal">target</code> object, or if it exists as a configurable own property of the <code class="literal">target</code> object</li></ul></div></div></div><div class="section" title="The defineProperty(target, property, descriptor) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec33"/>The defineProperty(target, property, descriptor) method</h3></div></div></div><p>The <code class="literal">defineProperty</code> trap is executed when <a id="id379" class="indexterm"/>we define a<a id="id380" class="indexterm"/> property using the <code class="literal">Object.defineProperty()</code> method. It takes three parameters, that is, the <code class="literal">target</code> object, the <code class="literal">property</code> name, and the <code class="literal">descriptor</code> object.</p><p>This trap should return a Boolean indicating whether it has successfully defined the property or not.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">defineProperty</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({}, {
  defineProperty: function(target, property, descriptor){
    Object.defineProperty(target, property, descriptor);
    return true;
  }
});

Reflect.defineProperty(proxy, "name", {value: "Eden"});

console.log(proxy.name); //Output "Eden"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec09"/>Rules</h4></div></div></div><p>These rules<a id="id381" class="indexterm"/> shouldn't be violated while using the <code class="literal">defineProperty</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It must<a id="id382" class="indexterm"/> return <code class="literal">false</code> if the <code class="literal">target</code> object is not extensible, and the property doesn't yet exist</li></ul></div></div></div><div class="section" title="The deleteProperty(target, property) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec34"/>The deleteProperty(target, property) method</h3></div></div></div><p>The <code class="literal">deleteProperty</code> trap<a id="id383" class="indexterm"/> is executed when we delete a <a id="id384" class="indexterm"/>property using either the <code class="literal">delete</code> operator or the <code class="literal">Reflect.deleteProperty()</code> method. It takes two parameters, that is, the <code class="literal">target</code> object and the <code class="literal">property</code> name.</p><p>This trap must return a Boolean, indicating whether the property was deleted successfully or not.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">deleteProperty</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 12}, {
  deleteProperty: function(target, property){
      return delete target[property];
  }
});

Reflect.deleteProperty(proxy, "age");
console.log(proxy.age); //Output "undefined"</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec10"/>Rules</h4></div></div></div><p>This rule <a id="id385" class="indexterm"/>shouldn't be violated while using the <code class="literal">deleteProperty</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This trap must return <code class="literal">false</code> if the property exists as a non-configurable own property of the <code class="literal">target</code> object</li></ul></div></div></div><div class="section" title="The enumerate(target) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec35"/>The enumerate(target) method</h3></div></div></div><p>The <code class="literal">enumerate</code> trap is executed when we <a id="id386" class="indexterm"/>loop over the property keys using either the <code class="literal">for…in</code> loop or the <code class="literal">Reflect.enumerate()</code> method. It takes one parameter, that is, the <code class="literal">target</code> object.</p><p>This trap must return an<a id="id387" class="indexterm"/> iterator object, representing the enumerable keys of the object.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">enumerate</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy({age: 12, name: "Eden"}, {
  enumerate: function(target){
    var arr = [];

    for(var p in target)
    {
      arr[arr.length] = p;
    }

    return arr[Symbol.iterator]();
  }
});

var iterator = Reflect.enumerate(proxy);

console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().done);</pre></div><p>Output is:</p><div class="informalexample"><pre class="programlisting">age
name
true</pre></div><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec11"/>Rules</h4></div></div></div><p>This rule<a id="id388" class="indexterm"/> shouldn't be violated while using the <code class="literal">enumerate</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This trap must return an object</li></ul></div></div></div><div class="section" title="The ownKeys(target) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec36"/>The ownKeys(target) method</h3></div></div></div><p>The <code class="literal">ownKeys</code> trap <a id="id389" class="indexterm"/>is executed<a id="id390" class="indexterm"/> when we retrieve the own property keys using the <code class="literal">Reflect.ownKeys()</code>, <code class="literal">Object.getOwnPropertyNames()</code>, <code class="literal">Object.getOwnPropertySymbols()</code>, and the <code class="literal">Object.keys()</code> methods. It takes only one parameter, that is, the <code class="literal">target</code> object.</p><p>The <code class="literal">Reflect.ownKeys()</code> method is similar to the <code class="literal">Object.getOwnPropertyNames()</code> method, that is, they return the enumerable and non-enumerable property keys of a object. They ignore the inherited properties. The only difference is that the <code class="literal">Reflect.ownKeys()</code> method returns both, the symbol and string keys, whereas the <code class="literal">Object.getOwnPropertyNames()</code> method returns only the string keys.</p><p>The <code class="literal">Object.getOwnPropertySymbols()</code> method returns the enumerable and non-enumerable properties whose keys are symbols. It ignores the inherited properties.</p><p>The <code class="literal">Object.keys()</code> method is similar to the <code class="literal">Object.getOwnPropertyNames()</code> method, but the only difference is that the <code class="literal">Objecy.keys()</code> method returns the enumerable properties only.</p><p>The <code class="literal">ownKeys</code> trap must return an array, representing the own property keys.</p><p>Here is a code <a id="id391" class="indexterm"/>example, which demonstrates how to use the <code class="literal">ownKeys</code> <a id="id392" class="indexterm"/>trap:</p><div class="informalexample"><pre class="programlisting">var s = Symbol();

var object = {age: 12, __proto__: {name: "Eden"}, [s]: "Symbol"};

Object.defineProperty(object, "profession", {
  enumerable: false,
  configurable: false,
  writable: false,
  value: "Developer"
})

var proxy = new Proxy(object, {
  ownKeys: function(target){
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  }
});

console.log(Reflect.ownKeys(proxy));
console.log(Object.getOwnPropertyNames(proxy));
console.log(Object.keys(proxy));
console.log(Object.getOwnPropertySymbols(proxy));</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">["age", "profession", Symbol()]
["age", "profession"]
["age"]
[Symbol()]</pre></div><p>Here, we can see that the values of the array returned by the <code class="literal">ownKeys</code> trap are filtered by the proxy, based on what the caller expected. For example, the <code class="literal">Object.getOwnPropertySymbols()</code> caller expected an array of symbols. Therefore, the proxy removed the <a id="id393" class="indexterm"/>strings from the returned array.</p><div class="section" title="Rules"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec12"/>Rules</h4></div></div></div><p>These rules <a id="id394" class="indexterm"/>shouldn't be violated while using the <code class="literal">ownKeys</code> trap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The elements of the returned array must either be a string or symbol</li><li class="listitem" style="list-style-type: disc">The returned array must contain the keys of all the non-configurable own properties of the <code class="literal">target</code> object</li><li class="listitem" style="list-style-type: disc">If the <code class="literal">target</code> object is not extensible, then the returned array must contain all the keys, of the own properties, of the <code class="literal">target</code> object, and no other values</li></ul></div></div></div><div class="section" title="The apply(target, thisValue, arguments) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec37"/>The apply(target, thisValue, arguments) method</h3></div></div></div><p>If the target is a <a id="id395" class="indexterm"/>function, then calling the proxy will <a id="id396" class="indexterm"/>execute the <code class="literal">apply</code> trap. The <code class="literal">apply</code> trap is also executed for function's <code class="literal">apply()</code> and <code class="literal">call()</code> methods, and the <code class="literal">Reflect.apply()</code> method.</p><p>The <code class="literal">apply</code> trap takes three parameters. The first parameter is the <code class="literal">target</code> object, and the third parameter is an array, representing the arguments of the function call. The second parameter is same as the value of <code class="literal">this</code> of the target function, that is, it's same as the value of <code class="literal">this</code> of the target function, if the target function would have been invoked without the proxy.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">apply</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy(function(){}, {
  apply: function(target, thisValue, arguments){
    console.log(thisValue.name);
    return arguments[0] + arguments[1] + arguments[2];
  }
});

var obj = {
  name: "Eden",
  f: proxy
}

var sum = obj.f(1,2,3);

console.log(sum);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">Eden
6</pre></div></div><div class="section" title="The construct(target, arguments) method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec38"/>The construct(target, arguments) method</h3></div></div></div><p>If the target is a function, then <a id="id397" class="indexterm"/>calling the target as a constructor<a id="id398" class="indexterm"/> using the <code class="literal">new</code> operator or the <code class="literal">Reflect.construct()</code> method will execute the <code class="literal">construct</code> trap.</p><p>The <code class="literal">construct</code> trap takes two parameters. The first parameter is the <code class="literal">target</code> object, and the second parameter is an array, representing the arguments of the constructor call.</p><p>The <code class="literal">construct</code> trap must return an object, representing the newly created instance.</p><p>Here is a code example, which demonstrates how to use the <code class="literal">construct</code> trap:</p><div class="informalexample"><pre class="programlisting">var proxy = new Proxy(function(){}, {
  construct: function(target, arguments){
    return {name: arguments[0]};
  }
});

var obj = new proxy("Eden");
console.log(obj.name); //Output "Eden"</pre></div></div></div><div class="section" title="The Proxy.revocable(target, handler) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>The Proxy.revocable(target, handler) method</h2></div></div></div><p>A revocable <a id="id399" class="indexterm"/>proxy is a proxy that can be revoked (that is, switched off).</p><p>To create the revocable, proxies we have to use the <code class="literal">Proxy.revocable()</code> method. The <code class="literal">Proxy.revocable()</code> method is not a constructor. This method also takes the same arguments as the <code class="literal">Proxy</code> constructor, but instead of returning a revocable proxy instance directly, it returns an object with two properties, which are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">proxy</code>: This is the revocable proxy object</li><li class="listitem" style="list-style-type: disc"><code class="literal">revoke</code>: When this function is called, it revokes the <code class="literal">proxy</code></li></ul></div><p>Once a revocable proxy is revoked, any attempts to use it will throw a <code class="literal">TypeError</code> exception.</p><p>Here is an example to demonstrate how to create a revocable proxy and revoke it:</p><div class="informalexample"><pre class="programlisting">var revocableProxy = Proxy.revocable({
  age: 12
 }, {
  get: function(target, property, receiver){
    if(property in target)
    {
     return target[property];
    }
    else
    {
     return "Not Found";
    }
  }
 }
);


console.log(revocableProxy.proxy.age);

revocableProxy.revoke();

console.log(revocableProxy.proxy.name);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">12
TypeError: proxy is revoked</pre></div><div class="section" title="Use Case"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec39"/>Use Case</h3></div></div></div><p>You can use the <a id="id400" class="indexterm"/>revocable proxies instead of the regular proxies. You can use it when you pass a proxy to a function that runs asynchronously or is parallel so that you can revoke it anytime in case you don't want the function to be able to use that proxy anymore.</p></div></div></div>
<div class="section" title="The uses of proxies"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>The uses of proxies</h1></div></div></div><p>There are several uses of <a id="id401" class="indexterm"/>proxies. Here are some main use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating virtualized objects, such as remote objects, persistent objects, and more</li><li class="listitem" style="list-style-type: disc">The lazy creation of objects</li><li class="listitem" style="list-style-type: disc">Transparent logging, tracing, profiling, and more</li><li class="listitem" style="list-style-type: disc">Embedded domain specific languages</li><li class="listitem" style="list-style-type: disc">Generically interposing <a id="id402" class="indexterm"/>abstractions in order to enforce the access control</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we learned what proxies are and how to use them. We saw the various traps available with examples. We also saw different rules that need to be followed by different traps. This chapter explained everything in-depth about the ES6 Proxy API. Finally, we saw some use cases of proxies.</p><p>In the next chapter, we will walk through the object oriented programming, and the ES6 classes.</p></div></body></html>