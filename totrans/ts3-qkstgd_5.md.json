["```js\nconst a = \"test\";\nlet b: number = 2;\nconst c: boolean = true;\nlet d: number | string = \"test\";\nconsole.log(typeof a); // string\nconsole.log(typeof b); // number\nconsole.log(typeof c); // boolean\nconsole.log(typeof d); // string\n```", "```js\nconst e: number | string | { complex: string, obj: number } = { complex: \"c\", obj: 1 };\nconsole.log(typeof e); // object\n```", "```js\nlet f: number = 2;\nif (typeof f === \"number\") {\nconsole.log(\"This is for sure a number\");\n}\ntype MyNewType = typeof f;\n```", "```js\nlet g: number | undefined = undefined;\nlet h: number | undefined | null = null;\nconsole.log(typeof g);\nconsole.log(typeof h);\n```", "```js\nlet g: number | undefined = undefined;\nlet h: number | undefined | null = null;\nconsole.log(typeof g); // undefined\nconsole.log(typeof h); // object\nconsole.log(g === undefined); // true\nconsole.log(g === null); // false\nconsole.log(h === undefined); // false\nconsole.log(h === null); // true\n```", "```js\nfunction myFunction(value: number | undefined): void {\n console.log(\"Value is number or undefined\");\n if (value === undefined) {\n console.log(\"Value is undefined\");\n } else {\n console.log(\"Value is NOT undefined, hence a number\");\n }\n console.log(\"Value is number or undefined\");\n}\n```", "```js\nfunction myFunction2(value: number | undefined): void {\n console.log(\"Value is number or undefined\");\n if (value === undefined) {\n return;\n }\n console.log(\"Value is NOT undefined, hence a number\");\n}\n\n```", "```js\nclass MyClass1 {\n member1: string = \"default\";\n member2: number = 123;\n}\nclass MyClass2 {\n member1: string = \"default\";\n member2: number = 123;\n}\nconst a = new MyClass1();\nconst b = new MyClass2();\nif (a instanceof MyClass1) {\n console.log(\"a === MyClass1\");\n}\nif (b instanceof MyClass2) {\n console.log(\"b === MyClass2\");\n}\n```", "```js\ntype MyType = instanceOf MyClass1;\n```", "```js\nclass MyClass3 extends MyClass2 {\n member3: boolean = true;\n}\nconst c = new MyClass3();\nif (c instanceof MyClass2) {\n console.log(\"c === MyClass2\");\n}\nif (c instanceof MyClass3) {\n console.log(\"c === MyClass3\");\n}\n```", "```js\ninterface Type1 {\n m1: string;\n}\ninterface Type2 {\n m1: string;\n}\ntype Type3 = { m1: string };\nconst v0 = { m1: \"AllTheSame\" };\nconst v1: Type1 = v0;\nconst v2: Type2 = v0;\nconst v3: Type3 = v0;\n```", "```js\ninterface Type1 {\n kind: \"Type1\";\n m1: string;\n}\n\ninterface Type2 {\n kind: \"Type2\";\n m1: string;\n}\n\ntype Type3 = { kind: \"Type3\"; m1: string };\nconst v0 = { kind: \"Type1\", m1: \"AllTheSame\" };\nconst v1: Type1 = v0; // Does not compile\nconst v2: Type2 = v0; // Does not compile\nconst v3: Type3 = v0; // Does not compile\n```", "```js\nfunction threeLogic(param: Type1 | Type2 | Type3): void {\n switch (param.kind) {\n  case \"Type1\":\n   console.log(param.m1); // param is type Type1\n  break;\n  case \"Type2\":\n   console.log(param.m1); // param is type Type2\n  break;\n  case \"Type3\":\n   console.log(param.m1); // param is type Type3\n  break;\n }\n}\n```", "```js\ninterface Alpha { kind: \"Alpha\", alpha: string }\ninterface Beta { kind: \"Beta\", beta: string }\n\nfunction AlphaBeta(param: Alpha | Beta): void {\n switch (param.kind) {\n  case \"Alpha\":\n   console.log(param.alpha);\n  break;\n  case \"Beta\":\n   console.log(param.beta);\n  break;\n }\n}\n```", "```js\ninterface Type1 extends Type2 {\n  kind: \"Type1\"; // Does not compile, expect “Type2”\n  m1: number;\n}\n\ninterface Type2 {\n  kind: \"Type2\";\n  m2: string;\n}\n```", "```js\ninterface Type2 {\n kind: \"Type2\";\n m2: string;\n}\n\ninterface Type3 {\n kind: \"Type3\";\n m3: string;\n}\n\ntype Type4 = Type2 & Type3;\nconst type4: Type4 = { kind: ???, m2: \"1\", m3: \"2\" }; // Does not compile\n```", "```js\n\ninterface Type1 extends Type2 {\n m1: number;\n}\n\ninterface Type2 {\n m2: string;\n m3: number;\n}\n\nfunction checkInterfaceICheck1(obj: any): obj is Type1 {\n const type1WithMaybeManyUndefinedMembers = (obj as Type1);\n return type1WithMaybeManyUndefinedMembers.m1 !== undefined\n && type1WithMaybeManyUndefinedMembers.m2 !== undefined\n && type1WithMaybeManyUndefinedMembers.m3 !== undefined\n}\n\nfunction checkInterfaceICheck2(obj: any): obj is Type2 {\n const type1WithMaybeManyUndefinedMembers = (obj as Type2);\n return type1WithMaybeManyUndefinedMembers.m2 !== undefined\n && type1WithMaybeManyUndefinedMembers.m3 !== undefined;\n}\n\nfunction codeWithUnionParameter(obj: Type1 | Type2): void {\n if (checkInterfaceICheck1(obj)) {\n console.log(\"Type1\", obj.m1);\n }\n\n if (checkInterfaceICheck2(obj)) {\n console.log(\"Type2\", obj.m2);\n }\n}\n```", "```js\nlet something: any = 1;\nlet variable1: number;\nvariable1 = <number>something;\nvariable1 = something as number;\n```", "```js\nlet variable1: number = 1;\nlet variable2: string = variable1 as string;\n```", "```js\ninterface Type1 {\n m1: number;\n}\n\ninterface Type2 {\n m2: string;\n m3: number;\n}\n\nlet t1: Type1 = { m1: 123 };\nlet t2: Type2 = t1 as Type2; // Property 'm2' is missing in type 'Type1'\nlet t3: Type2 = { m2: \"2\", m3: 3 };\nlet t4: Type1 = t2 as Type1;// Property 'm1' is missing in type 'Type2'\n```", "```js\ninterface Type1 {\n m1: number;\n}\n\ninterface Type2 {\n m1: number;\n m2: string;\n m3: number;\n}\n\nlet t1: Type1 = { m1: 123 };\nlet t2: Type2 = t1 as Type2;\nlet t3: Type2 = { m1: 1, m2: \"2\", m3: 3 };\nlet t4: Type1 = t2 as Type1;\n```", "```js\nlet t3: Type2 = { m1: 1, m2: \"2\", m3: 3 };\nlet t4: Type1 = t2;\n```", "```js\nlet a: number = 1;\nlet b: string = \"2\";\na = b as number; // Doesn't compile\na = b as any as number; //Shortcircuit with any\n```", "```js\ninterface T1 {\n myNumber: number | undefined;\n}\n\ninterface T2 {\n t1: T1 | undefined;\n}\n\ninterface T3 {\n t2: T2 | undefined;\n}\n\nconst myObject: T3 | undefined = {\n t2: {\n t1: {\n  myNumber: 1\n }\n }\n}\n\nif (myObject !== undefined) {\n if (myObject.t2 !== undefined) {\n  if (myObject.t2.t1 !== undefined) {\n   if (myObject.t2.t1.myNumber !== undefined) {\n    console.log(\"My number is :\", myObject.t2.t1.myNumber);\n   }\n  }\n }\n}\n```", "```js\nconsole.log(\"My number is :\", myObject!.t2!.t1!.myNumber);\n```", "```js\nclass LateInitialization {\n m1!: number; // Not initialized (use type assertion)\n constructor() {\n   // No initializing here\n }\n public init(): void {\n   this.m1 = 1;\n }\n}\n```", "```js\nconstructor() {\n   this.m1 + 1; // This will fail\n}\n```", "```js\nlet var1: string | undefined;\nvar1 = ((): string | undefined => \"Not undefined but type is still both\")();\nconsole.log(var1!.substr(0, 5));\n```", "```js\nclass C1 {\n public a: number = 1;\n public funct(): void { }\n}\n\nclass C2 {\n public a: number = 1;\n public funct(): void { }\n}\n\nconst c1: C1 = new C1();\nconst c2: C2 = new C2();\nconst c12: C1 = new C2();\n\nfunction executeClass1(c1: C1): void {\n c1.funct();\n}\n\nexecuteClass1(c1);\nexecuteClass1(c2);\nexecuteClass1(c12);\n```", "```js\nclass C1 {\n public a: number = 1;\n public funct(): void { }\n private p: string = \"p\";\n}\n\nclass C2 {\n public a: number = 1;\n public funct(): void { }\n private p: string = \"p\";\n}\n\nconst c1: C1 = new C1();\nconst c2: C2 = new C2();\nconst c12: C1 = new C2(); // Does not compile\n\nfunction executeClass1(c1: C1): void {\n c1.funct();\n}\n\nexecuteClass1(c1);\nexecuteClass1(c2); // Does not compile\nexecuteClass1(c12);\n```", "```js\nclass B1 {\n  public baseFunct(): void { }\n}\n\nclass C1 extends B1 {\n  public a: number = 1;\n  public funct(): void { }\n}\n\nclass C2 {\n  public a: number = 1;\n  public funct(): void { }\n  public baseFunct(): void { }\n}\n\nconst c1: B1 = new C1();\nconst c2: B1 = new C2();\n```", "```js\nclass B1 {\n private name: string = \"b1\";\n public baseFunct(): void { }\n}\n\nclass C1 extends B1 {\n public a: number = 1;\n public funct(): void { }\n}\n\nclass C2 {\n private name: string = \"c2\";\n public a: number = 1;\n public funct(): void { }\n public baseFunct(): void { }\n}\n\nconst c1: B1 = new C1();\nconst c2: B1 = new C2(); // Does not compile\n```", "```js\nfunction f(p: number | string): boolean | Date {\n if (typeof p === \"number\") {\n  return true;\n }\n return new Date();\n}\n\nconst r1: boolean = f(1); // Does not compile\nconst r2: Date = f(\"string\"); // Does not compile\n```", "```js\nfunction f(p: number): boolean;\nfunction f(p: string): Date;\nfunction f(p: number | string): boolean | Date {\n if (typeof p === \"number\") {\n  return true;\n }\n return new Date();\n}\n\nconst r1: boolean = f(1);\nconst r2: Date = f(\"string\");\n```", "```js\nfunction g(p: number, q: number): boolean;\nfunction g(p: string, q: string): Date;\nfunction g(p: number | string, q: number | string): void {\n}\ng(1, \"123\"); // Doesn't compile\ng(1, 2);\ng(\"1\", \"2\");\n```"]