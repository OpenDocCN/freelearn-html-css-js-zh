<html><head></head><body>
  <div><h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-208" class="chapterTitle">Structural Design Patterns</h1>
    <p class="normal">In this chapter, we will explore some of the most popular structural design patterns and discover how they apply to Node.js. Structural design patterns are focused on providing ways to realize relationships between entities.</p>
    <p class="normal">In particular, in this chapter, we will examine the following patterns:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Proxy</strong>: A pattern that allows us to control access to another object</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Decorator</strong>: A common pattern to augment the behavior of an existing object dynamically</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Adapter</strong>: A pattern that allows us to access the functionality of an object using a different interface</li>
    </ul>
    <p class="normal">Throughout the chapter, we will also explore some interesting concepts such as <strong class="keyword">reactive programming</strong> (<strong class="keyword">RP</strong>), and we will also spend some time playing with LevelDB, a database technology that is commonly adopted in the Node.js ecosystem.</p>
    <p class="normal">By the end of this chapter, you will be familiar with several scenarios in which structural design patterns can be useful and you will be able to implement them effectively in your Node.js applications.</p>
    <h1 id="_idParaDest-209" class="title">Proxy</h1>
    <p class="normal">A <strong class="keyword">proxy</strong> is an object that controls <a id="_idIndexMarker602"/>access to another object, called the <strong class="keyword">subject</strong>. The proxy and the <a id="_idIndexMarker603"/>subject have an identical interface, and this<a id="_idIndexMarker604"/> allows us to swap one for the other transparently; in fact, the alternative <a id="_idIndexMarker605"/>name for this pattern is <strong class="keyword">surrogate</strong>. </p>
    <p class="normal">A proxy intercepts all or some of the operations that are meant to be executed on the subject, augmenting or complementing their behavior. <em class="italic">Figure 8.1</em> shows a schematic representation of this pattern:</p>
    <figure class="mediaobject"><img src="img/B15729_08_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.1: Proxy pattern schematic</p>
    <p class="normal"><em class="italic">Figure 8.1</em> shows us how the <a id="_idIndexMarker606"/>proxy and the subject have the same interface, and how this is transparent to the client, who can use one or the other interchangeably. The proxy forwards each operation to the subject, enhancing its behavior with additional preprocessing or postprocessing.</p>
    <div><p class="Information-Box--PACKT-">It's important to observe that we are not talking about proxying between classes; the Proxy pattern involves wrapping an actual instance of the subject, thus preserving its internal state.</p>
    </div>
    <p class="normal">A proxy can be useful in<a id="_idIndexMarker607"/> several circumstances, for example:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Data validation</strong>: The proxy validates the input before forwarding it to the subject</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Security</strong>: The proxy verifies that the client is authorized to perform the operation, and it passes the request to the subject only if the outcome of the check is positive</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Caching</strong>: The proxy keeps an internal cache so that the proxied operations are executed on the subject only if the data is not yet present in the cache</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Lazy initialization</strong>: If creating the subject is expensive, the proxy can delay it until it's really necessary</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Logging</strong>: The proxy intercepts the method invocations and the relative parameters, recoding them as they happen</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Remote objects</strong>: The proxy can take a remote object and make it appear local</li>
    </ul>
    <p class="normal">There are more Proxy pattern applications, but these should give us an idea of its purpose.</p>
    <h2 id="_idParaDest-210" class="title">Techniques for implementing proxies</h2>
    <p class="normal">When <em class="italic">proxying</em> an object, we can<a id="_idIndexMarker608"/> decide to intercept all of its methods or only some of them, while delegating the rest directly to the subject. There are<a id="_idIndexMarker609"/> several ways in which this can be achieved, and in this section, we will present some of them.</p>
    <p class="normal">We will be working on a simple example, a <code class="Code-In-Text--PACKT-">StackCalculator</code> class that looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class StackCalculator {
  constructor () {
    this.stack = []
  }
  putValue (value) {
    this.stack.push(value)
  }
  getValue () {
    return this.stack.pop()
  }
  peekValue () {
    return this.stack[this.stack.length - 1]
  }
  clear () {
    this.stack = []
  }
  divide () {
    const divisor = this.getValue()
    const dividend = this.getValue()
    const result = dividend / divisor
    this.putValue(result)
    return result
  }
  multiply () {
    const multiplicand = this.getValue()
    const multiplier = this.getValue()
    const result = multiplier * multiplicand
    this.putValue(result)
    return result
  }
}
</code></pre>
    <p class="normal">This class implements a simplified version of a stack calculator. The idea of this calculator is to keep all operands (values) in a stack. When you perform an operation, for example a multiplication, the multiplicand and the multiplier are extracted from the stack and the result of the multiplication is pushed back into the<a id="_idIndexMarker610"/> stack. This is not too different from how the calculator application on your mobile phone is actually implemented.</p>
    <p class="normal">Here's an example of how we might use <code class="Code-In-Text--PACKT-">StackCalculator</code> to perform some multiplications and divisions:</p>
    <pre class="programlisting code"><code class="hljs-code">const calculator = new StackCalculator()
calculator.putValue(3)
calculator.putValue(2)
console.log(calculator.multiply()) // 3*2 = 6
calculator.putValue(2)
console.log(calculator.multiply()) // 6*2 = 12
</code></pre>
    <p class="normal">There are also some utility methods such as <code class="Code-In-Text--PACKT-">peekValue()</code>, which allows us to peek the value at the top of the stack (the last value inserted or the result of the last operation), and <code class="Code-In-Text--PACKT-">clear()</code>, which allows us to reset the stack.</p>
    <p class="normal">Fun fact: In JavaScript, when you perform a division by 0, you get back a mysterious value called <code class="Code-In-Text--PACKT-">Infinity</code>. In many other programming languages dividing by 0 is an illegal operation that results in the program panicking or throwing a runtime exception.</p>
    <p class="normal">Our task in the next few sections will be to leverage the Proxy pattern to enhance a <code class="Code-In-Text--PACKT-">StackCalculator</code> instance by providing a more conservative behavior for division by 0: rather than returning <code class="Code-In-Text--PACKT-">Infinity</code>, we will throw an explicit error.</p>
    <h3 id="_idParaDest-211" class="title">Object composition</h3>
    <p class="normal">Composition is a technique<a id="_idIndexMarker611"/> whereby an object is combined with another object for the purpose of extending or using its functionality. In the specific case of the Proxy pattern, a new object with the same interface as the subject is created, and a reference to the subject is stored internally in the proxy in the form of an instance variable or a closure variable. The subject can be injected from the client at creation time or created by the proxy itself.</p>
    <p class="normal">The following example implements a safe <a id="_idIndexMarker612"/>calculator using object composition:</p>
    <pre class="programlisting code"><code class="hljs-code">class SafeCalculator {
  constructor (calculator) {
    this.calculator = calculator
  }
  // proxied method
  divide () {
    // additional validation logic
    const divisor = this.calculator.peekValue()
    if (divisor === 0) {
      throw Error('Division by 0')
    }
    // if valid delegates to the subject
    return this.calculator.divide()
  }
  // delegated methods
  putValue (value) {
    return this.calculator.putValue(value)
  }
  getValue () {
    return this.calculator.getValue()
  }
  peekValue () {
    return this.calculator.peekValue()
  }
  clear () {
    return this.calculator.clear()
  }
  multiply () {
    return this.calculator.multiply()
  }
}
const calculator = new StackCalculator()
const safeCalculator = new SafeCalculator(calculator)
calculator.putValue(3)
calculator.putValue(2)
console.log(calculator.multiply())     // 3*2 = 6
safeCalculator.putValue(2)
console.log(safeCalculator.multiply()) // 6*2 = 12
calculator.putValue(0)
console.log(calculator.divide())       // 12/0 = Infinity
safeCalculator.clear()
safeCalculator.putValue(4)
safeCalculator.putValue(0)
console.log(safeCalculator.divide())   // 4/0 -&gt; Error
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">safeCalculator</code> object is a proxy for the original <code class="Code-In-Text--PACKT-">calculator</code> instance. By invoking <code class="Code-In-Text--PACKT-">multiply()</code> on <code class="Code-In-Text--PACKT-">safeCalculator</code>, we will end up calling the same method on <code class="Code-In-Text--PACKT-">calculator</code>. The same goes for <code class="Code-In-Text--PACKT-">divide()</code>, but in this case we<a id="_idIndexMarker613"/> can see that, if we try to divide by zero, we will get different outcomes depending on whether we perform the division on the subject or on the proxy.</p>
    <p class="normal">To implement this proxy using composition, we had to intercept the methods that we were interested in manipulating (<code class="Code-In-Text--PACKT-">divide()</code>), while simply delegating the rest of them to the subject (<code class="Code-In-Text--PACKT-">putValue()</code>, <code class="Code-In-Text--PACKT-">getValue()</code>, <code class="Code-In-Text--PACKT-">peekValue()</code>, <code class="Code-In-Text--PACKT-">clear()</code>, and <code class="Code-In-Text--PACKT-">multiply()</code>).</p>
    <p class="normal">Note that the calculator state (the values in the stack) is still maintained by the <code class="Code-In-Text--PACKT-">calculator</code> instance; <code class="Code-In-Text--PACKT-">safeCalculator</code> will only invoke methods on <code class="Code-In-Text--PACKT-">calculator</code> to read or mutate the state as needed.</p>
    <p class="normal">An alternative implementation of the proxy presented in the preceding code fragment might just use an object literal and a factory function:</p>
    <pre class="programlisting code"><code class="hljs-code">function createSafeCalculator (calculator) {
  return {
    // proxied method
    divide () {
      // additional validation logic
      const divisor = calculator.peekValue()
      if (divisor === 0) {
        throw Error('Division by 0')
      }
      // if valid delegates to the subject
      return calculator.divide()
    },
    // delegated methods
    putValue (value) {
      return calculator.putValue(value)
    },
    getValue () {
      return calculator.getValue()
    },
    peekValue () {
      return calculator.peekValue()
    },
    clear () {
      return calculator.clear()
    },
    multiply () {
      return calculator.multiply()
    }
  }
}
const calculator = new StackCalculator()
const safeCalculator = createSafeCalculator(calculator)
   // ...
</code></pre>
    <p class="normal">This implementation is simpler and<a id="_idIndexMarker614"/> more concise than the class-based one, but, once again, it forces us to delegate all the methods to the subject explicitly.</p>
    <p class="normal">Having to delegate many methods for complex classes can be very tedious and might make it harder to implement these techniques. One way to create a proxy that delegates most of its methods is to use a library that generates all the methods for us, such as <code class="Code-In-Text--PACKT-">delegates</code> (<a href="http://nodejsdp.link/delegates">nodejsdp.link/delegates</a>). A more <a id="_idIndexMarker615"/>modern and native alternative is to use the <code class="Code-In-Text--PACKT-">Proxy</code> object, which we will discuss later in this chapter.</p>
    <h3 id="_idParaDest-212" class="title">Object augmentation</h3>
    <p class="normal"><strong class="keyword">Object augmentation</strong> (or <strong class="keyword">monkey patching</strong>) is probably the <a id="_idIndexMarker616"/>simplest and most common way of proxying just a few <a id="_idIndexMarker617"/>methods of an object. It involves modifying the subject directly by replacing a method with its proxied implementation. </p>
    <p class="normal">In the context of our calculator example, this could be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">function patchToSafeCalculator (calculator) {
  const divideOrig = calculator.divide
  calculator.divide = () =&gt; {
    // additional validation logic
    const divisor = calculator.peekValue()
    if (divisor === 0) {
      throw Error('Division by 0')
    }
    // if valid delegates to the subject
    return divideOrig.apply(calculator)
  }
  return calculator
}
const calculator = new StackCalculator()
const safeCalculator = patchToSafeCalculator(calculator)
// ...
</code></pre>
    <p class="normal">This technique is definitely convenient when we need to proxy only one or a few methods. Did you notice that we didn't have to reimplement the <code class="Code-In-Text--PACKT-">multiply()</code> method and all the other delegated methods here?</p>
    <p class="normal">Unfortunately, simplicity comes at the cost of having to mutate the <code class="Code-In-Text--PACKT-">subject</code> object directly, which can be dangerous.</p>
    <div><p class="Tip--PACKT-">Mutations should be avoided at all costs when the subject is shared with other parts of the codebase. In fact, "monkey patching" the subject might create undesirable side effects that affect other components of our application. Use this technique only when the subject exists in a controlled context or in a private scope. If you want to appreciate why "monkey patching" is a dangerous practice, you could try to invoke a division by zero in the original <code class="Code-In-Text--PACKT-">calculator</code> instance. If you do so, you will see that the original instance will now throw an error rather than returning <code class="Code-In-Text--PACKT-">Infinity</code>. The original behavior has been altered, and this might have unexpected effects on other parts of the application.</p>
    </div>
    <p class="normal">In the next section, we<a id="_idIndexMarker618"/> will explore the built-in <code class="Code-In-Text--PACKT-">Proxy</code> object, which is a powerful alternative for implementing the Proxy pattern and more.</p>
    <h3 id="_idParaDest-213" class="title">The built-in Proxy object</h3>
    <p class="normal">The ES2015 specification introduced a native <a id="_idIndexMarker619"/>way to create powerful proxy objects.</p>
    <p class="normal">We are talking about the ES2015 <code class="Code-In-Text--PACKT-">Proxy</code> object, which <a id="_idIndexMarker620"/>consists of a <code class="Code-In-Text--PACKT-">Proxy</code> constructor that accepts a <code class="Code-In-Text--PACKT-">target</code> and a <code class="Code-In-Text--PACKT-">handler</code> as arguments:</p>
    <pre class="programlisting code"><code class="hljs-code">const proxy = new Proxy(target, handler)
</code></pre>
    <p class="normal">Here, <code class="Code-In-Text--PACKT-">target</code> represents the object on which the proxy is applied (the <strong class="keyword">subject</strong> for our canonical definition), while <code class="Code-In-Text--PACKT-">handler</code> is a special object that defines the behavior of the proxy.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">handler</code> object contains a series of optional methods with predefined names called <strong class="keyword">trap methods</strong> (for example, <code class="Code-In-Text--PACKT-">apply</code>, <code class="Code-In-Text--PACKT-">get</code>, <code class="Code-In-Text--PACKT-">set</code>, and <code class="Code-In-Text--PACKT-">has</code>) that are automatically called when the corresponding operations <a id="_idIndexMarker621"/>are performed on the proxy instance.</p>
    <p class="normal">To better understand how this API works, let's see how we can use the <code class="Code-In-Text--PACKT-">Proxy</code> object to implement our safe calculator proxy:</p>
    <pre class="programlisting code"><code class="hljs-code">const safeCalculatorHandler = {
  get: (target, property) =&gt; {
    if (property === 'divide') {
      // proxied method
      return function () {
        // additional validation logic
        const divisor = target.peekValue()
        if (divisor === 0) {
          throw Error('Division by 0')
        }
        // if valid delegates to the subject
        return target.divide()
      }
    }
    // delegated methods and properties
    return target[property]
  }
}
const calculator = new StackCalculator()
const safeCalculator = new Proxy(
  calculator,
  safeCalculatorHandler
)
// ...
</code></pre>
    <p class="normal">In this implementation of the safe calculator proxy using the <code class="Code-In-Text--PACKT-">Proxy</code> object, we adopted the <code class="Code-In-Text--PACKT-">get</code> trap to intercept access to properties and methods of the original object, including calls to the <code class="Code-In-Text--PACKT-">divide()</code> method. When access to <code class="Code-In-Text--PACKT-">divide()</code> is intercepted, the proxy returns a modified version of the function that implements the additional logic to check for possible divisions by <a id="_idIndexMarker622"/>zero. Note that we can simply return all other methods and properties unchanged by using <code class="Code-In-Text--PACKT-">target[property]</code>.</p>
    <p class="normal">Finally, it is important to <a id="_idIndexMarker623"/>mention that the <code class="Code-In-Text--PACKT-">Proxy</code> object inherits the prototype of the subject, therefore running <code class="Code-In-Text--PACKT-">safeCalculator instanceof StackCalculator</code> will return <code class="Code-In-Text--PACKT-">true</code>.</p>
    <p class="normal">With this example, it should be clear that the <code class="Code-In-Text--PACKT-">Proxy</code> object allows us to avoid mutating the subject while giving us an easy way to proxy only the bits that we need to enhance, without having to explicitly delegate all the other properties and methods.</p>
    <h4 class="title">Additional capabilities and limitations of the Proxy object</h4>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Proxy</code> object is a feature deeply<a id="_idIndexMarker624"/> integrated into the JavaScript language itself, which enables developers to intercept and customize many operations that can be performed on objects. This characteristic opens up new and interesting scenarios that were not easily achievable before, such as <em class="italic">meta-programming</em>, <em class="italic">operator overloading</em>, and <em class="italic">object virtualization</em>.</p>
    <p class="normal">Let's see another example to clarify this concept:</p>
    <pre class="programlisting code"><code class="hljs-code">const evenNumbers = new Proxy([], {
  get: (target, index) =&gt; index * 2,
  has: (target, number) =&gt; number % 2 === 0
})
console.log(2 in evenNumbers) // true
console.log(5 in evenNumbers) // false
console.log(evenNumbers[7])   // 14
</code></pre>
    <p class="normal">In this example, we are creating a virtual array that contains all even numbers. It can be used as a regular array, which means we can access items in the array with the regular array syntax (for example, <code class="Code-In-Text--PACKT-">evenNumbers[7]</code>), or check the existence of an element in the array with the <code class="Code-In-Text--PACKT-">in</code> operator (for example, <code class="Code-In-Text--PACKT-">2 in evenNumbers</code>). The array is considered <em class="italic">virtual</em> because we never store data in it.</p>
    <div><pre>Proxy</code> object, it is not implementing the Proxy pattern. This example allows us to see that, even though the <code class="Code-In-Text--PACKT-">Proxy</code> object is commonly used to implement the Proxy pattern (hence the name), it can also be used to implement other patterns and use cases. As an example, we will see later in this chapter how to use the <code class="Code-In-Text--PACKT-">Proxy</code> object—to implement the Decorator pattern.</pre>
    </div>
    <p class="normal">Looking at the implementation, this<a id="_idIndexMarker625"/> proxy uses an empty array as the target and then defines the <code class="Code-In-Text--PACKT-">get</code> and <code class="Code-In-Text--PACKT-">has</code> traps in the handler:</p>
    <ul>
      <li class="Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">get</code> trap intercepts access <a id="_idIndexMarker626"/>to the array elements, returning the even number for the given index</li>
      <li class="Bullet-End--PACKT-">The <code class="Code-In-Text--PACKT-">has</code> trap instead intercepts the usage of the <code class="Code-In-Text--PACKT-">in</code> operator and checks whether the given<a id="_idIndexMarker627"/> number is even or not</li>
    </ul>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Proxy</code> object supports several other interesting traps such as <code class="Code-In-Text--PACKT-">set</code>, <code class="Code-In-Text--PACKT-">delete</code>, and <code class="Code-In-Text--PACKT-">construct</code>, and allows us to create proxies that can be revoked on demand, disabling all the traps and restoring the original behavior of the <code class="Code-In-Text--PACKT-">target</code> object.</p>
    <p class="normal">Analyzing all these features goes beyond the scope of this chapter; what is important here is understanding that the <code class="Code-In-Text--PACKT-">Proxy</code> object provides a powerful foundation for implementing the Proxy design pattern.</p>
    <div><p class="Information-Box--PACKT-">If you are curious to discover all the capabilities and trap methods offered by the Proxy object, you can read more in the related MDN article at <a href="http://nodejsdp.link/mdn-proxy">nodejsdp.link/mdn-proxy</a>. Another good source is this <a id="_idIndexMarker628"/>detailed article from Google at <a href="http://nodejsdp.link/intro-proxy">nodejsdp.link/intro-proxy</a>.</p>
    </div>
    <p class="normal">While the <code class="Code-In-Text--PACKT-">Proxy</code> object is a powerful functionality of the JavaScript language, it suffers from a very important limitation: the <code class="Code-In-Text--PACKT-">Proxy</code> object cannot be fully <em class="italic">transpiled</em> or <em class="italic">polyfilled</em>. This is because some of the <code class="Code-In-Text--PACKT-">Proxy</code> object traps can be implemented only at the runtime level and cannot be simply rewritten in plain JavaScript. This is something to be aware of if you are working with<a id="_idIndexMarker629"/> old browsers or old versions of Node.js that don't support the <code class="Code-In-Text--PACKT-">Proxy</code> object directly.</p>
    <div><p class="Information-Box--PACKT-"><strong class="keyword">Transpilation</strong>: Short for <em class="italic">transcompilation</em>. It indicates the action of compiling source code by translating it from one source <a id="_idIndexMarker630"/>programming language to another. In the case of JavaScript, this technique is used to convert a program using new capabilities of the language into an equivalent program that can also run on older runtimes that do not support these new capabilities.</p>
      <p class="Information-Box--PACKT-"><strong class="keyword">Polyfill</strong>: Code that provides <a id="_idIndexMarker631"/>an implementation for a standard API in plain JavaScript and that can be imported in environments where this API is not available (generally older<a id="_idIndexMarker632"/> browsers or runtimes). <code class="Code-In-Text--PACKT-">core-js</code> (<a href="http://nodejsdp.link/corejs">nodejsdp.link/corejs</a>) is one of the most complete polyfill libraries for JavaScript.</p>
    </div>
    <h3 id="_idParaDest-214" class="title">A comparison of the different proxying techniques</h3>
    <p class="normal">Composition <a id="_idIndexMarker633"/>can be considered a simple and <em class="italic">safe</em> way of creating a proxy because it leaves the subject untouched without mutating its original behavior. Its only drawback is that we have to manually delegate all the methods, even if we want to proxy only one of them. Also, we might have to delegate access to the <a id="_idIndexMarker634"/>properties of the subject.</p>
    <div><p class="Information-Box--PACKT-">Object properties can be delegated using <code class="Code-In-Text--PACKT-">Object.defineProperty()</code>. Find out more at <a href="http://nodejsdp.link/define-prop">nodejsdp.link/define-prop</a>.</p>
    </div>
    <p class="normal">Object augmentation, on the other hand, modifies the subject, which might not always be ideal, but it does not suffer from the various inconveniences related to delegation. For this reason, between these two approaches, object augmentation is generally the preferred technique in all those circumstances in which modifying the subject is an option.</p>
    <p class="normal">However, there is at least one situation where composition is almost necessary; this is when we want to control the initialization of the subject, for example, to create it only when needed (<em class="italic">lazy initialization</em>).</p>
    <p class="normal">Finally, the <code class="Code-In-Text--PACKT-">Proxy</code> object is the go-to <a id="_idIndexMarker635"/>approach if you need to intercept function calls or have different types of access to object attributes, even dynamic ones. The <code class="Code-In-Text--PACKT-">Proxy</code> object provides an advanced level of access control that is simply not available with the other techniques. For example, the <code class="Code-In-Text--PACKT-">Proxy</code> object allows us to intercept the deletion of a key in an object and to perform property existence checks.</p>
    <p class="normal">Once again, it's worth highlighting that the <code class="Code-In-Text--PACKT-">Proxy</code> object does not mutate the subject, so it can be safely used in contexts where the subject is shared between different components of the application. We also saw that with the <code class="Code-In-Text--PACKT-">Proxy</code> object, we can easily perform delegation of all the methods and attributes that we want to leave unchanged.</p>
    <p class="normal">In the next section, we <a id="_idIndexMarker636"/>present a more realistic example leveraging the Proxy pattern and use it to compare the different techniques we have discussed so far for implementing this pattern.</p>
    <h2 id="_idParaDest-215" class="title">Creating a logging Writable stream</h2>
    <p class="normal">To see the Proxy pattern<a id="_idIndexMarker637"/> applied to a real example, we will now build an object that acts as a proxy to a Writable stream, which intercepts all the<a id="_idIndexMarker638"/> calls to the <code class="Code-In-Text--PACKT-">write()</code> method and logs a message every time this happens. We will use the <code class="Code-In-Text--PACKT-">Proxy</code> object to implement our proxy. Let's write our code in a file called <code class="Code-In-Text--PACKT-">logging-writable.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">export function createLoggingWritable (writable) {
  return new Proxy(writable, {                             // (1)
    get (target, propKey, receiver) {                      // (2)
      if (propKey === 'write') {                           // (3)
        return function (...args) {                        // (4)
          const [chunk] = args
          console.log('Writing', chunk)
          return writable.write(...args)
        }
      }
      return target[propKey]                               // (5)
    }
  })
}
</code></pre>
    <p class="normal">In the preceding code, we created a factory that returns a proxied version of the <code class="Code-In-Text--PACKT-">writable</code> object passed as an argument. Let's see what the main points of the implementation are:</p>
    <ol>
      <li class="numbered">We create and return a proxy for the original <code class="Code-In-Text--PACKT-">writable</code> object using the ES2015 <code class="Code-In-Text--PACKT-">Proxy</code> constructor.</li>
      <li class="numbered">We use the <code class="Code-In-Text--PACKT-">get</code> trap to intercept access to the object properties.</li>
      <li class="numbered">We check whether the property accessed is the <code class="Code-In-Text--PACKT-">write</code> method. If that is the case, we return a function to proxy the original behavior.</li>
      <li class="numbered">The proxy implementation logic here is simple: we extract the current <code class="Code-In-Text--PACKT-">chunk</code> from the list of arguments passed to the original function, we log the content of the chunk, and finally, we invoke the original method with the given list of arguments.</li>
      <li class="numbered">We return unchanged any other property.</li>
    </ol>
    <p class="normal">We can now use this newly created function and test our proxy implementation:</p>
    <pre class="programlisting code"><code class="hljs-code">import { createWriteStream } from 'fs'
import { createLoggingWritable } from './logging-writable.js'
const writable = createWriteStream('test.txt')
const writableProxy = createLoggingWritable(writable)
writableProxy.write('First chunk')
writableProxy.write('Second chunk')
writable.write('This is not logged')
writableProxy.end()
</code></pre>
    <p class="normal">The proxy did <a id="_idIndexMarker639"/>not change the original interface of the stream<a id="_idIndexMarker640"/> or its external behavior, but if we run the preceding code, we will now see that every chunk that is written into the <code class="Code-In-Text--PACKT-">writableProxy</code> stream is transparently logged to the console.</p>
    <h2 id="_idParaDest-216" class="title">Change observer with Proxy</h2>
    <p class="normal">The <strong class="keyword">Change Observer pattern</strong> is a <a id="_idIndexMarker641"/>design pattern in<a id="_idIndexMarker642"/> which an object (the subject) notifies one or more observers of any state changes, so that they can "react" to changes as soon as they happen.</p>
    <div><p class="Tip--PACKT-">Although very similar, the Change Observer pattern should not be confused with the Observer pattern discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Callbacks and Events</em>. The Change Observer pattern focuses on allowing the detection of property changes, while the Observer pattern is a more generic pattern that adopts an event emitter to propagate information about events happening in the system.</p>
    </div>
    <p class="normal">Proxies turn out to be quite an effective tool to create observable objects. Let's see a possible implementation with <code class="Code-In-Text--PACKT-">create-observable.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">export function createObservable (target, observer) {
  const observable = new Proxy(target, {
    set (obj, prop, value) {
      if (value !== obj[prop]) {
        const prev = obj[prop]
        obj[prop] = value
        observer({ prop, prev, curr: value })
      }
      return true
    }
  })
  return observable
}
</code></pre>
    <p class="normal">In the previous code, <code class="Code-In-Text--PACKT-">createObservable()</code> accepts a <code class="Code-In-Text--PACKT-">target</code> object (the object to observe for changes) and an <code class="Code-In-Text--PACKT-">observer</code> (a function to invoke every time a change is detected).</p>
    <p class="normal">Here, we create the <code class="Code-In-Text--PACKT-">observable</code> instance through an ES2015 Proxy. The proxy implements the <code class="Code-In-Text--PACKT-">set</code> trap, which is triggered every time a property is set. The implementation<a id="_idIndexMarker643"/> compares the current value with the new one and, if they are different, the target object is mutated, and the <a id="_idIndexMarker644"/>observer gets notified. When the observer is invoked, we pass an object literal that contains information related to the change (the name of the property, the previous value, and the current value).</p>
    <div><p class="Information-Box--PACKT-">This is a simplified implementation of the Change Observer pattern. More advanced implementations support multiple observers and use more traps to catch other types of mutation, such as field deletions or changes of prototype. Moreover, our implementation does not recursively create proxies for nested objects or arrays—a more advanced implementation takes care of these cases as well.</p>
    </div>
    <p class="normal">Let's see now how we can take<a id="_idIndexMarker645"/> advantage of observable objects with a trivial invoice application where the invoice total is updated automatically based on observed changes in the various fields of the invoice:</p>
    <pre class="programlisting code"><code class="hljs-code">import { createObservable } from './create-observable.js'
function calculateTotal (invoice) {                          // (1)
  return invoice.subtotal -
    invoice.discount +
    invoice.tax
}
const invoice = {
  subtotal: 100,
  discount: 10,
  tax: 20
}
let total = calculateTotal(invoice)
console.log(`Starting total: ${total}`)
const obsInvoice = createObservable(                         // (2)
  invoice,
  ({ prop, prev, curr }) =&gt; {
    total = calculateTotal(invoice)
    console.log(`TOTAL: ${total} (${prop} changed: ${prev} -&gt; ${curr})`)
  }
)
                                                             // (3)
obsInvoice.subtotal = 200 // TOTAL: 210
obsInvoice.discount = 20  // TOTAL: 200
obsInvoice.discount = 20  // no change: doesn't notify
obsInvoice.tax = 30       // TOTAL: 210
console.log(`Final total: ${total}`)
</code></pre>
    <p class="normal">In the previous example, an<a id="_idIndexMarker646"/> invoice is composed of a <code class="Code-In-Text--PACKT-">subtotal</code> value, a <code class="Code-In-Text--PACKT-">discount</code> value, and a <code class="Code-In-Text--PACKT-">tax</code> value. The total amount can be calculated from these three values. Let's discuss the implementation in greater detail:</p>
    <ol>
      <li class="numbered">We declare a function that calculates the total for a given invoice, then we create an <code class="Code-In-Text--PACKT-">invoice</code> object and a value to hold the <code class="Code-In-Text--PACKT-">total</code> for it.</li>
      <li class="numbered">Here we create an observable version of the <code class="Code-In-Text--PACKT-">invoice</code> object. Every time there is a change in the original invoice object, we recalculate the total and we also print some logs to keep track of the changes.</li>
      <li class="numbered">Finally, we apply some changes to the observable invoice. Every time we mutate the <code class="Code-In-Text--PACKT-">obsInvoice</code> object the observer function is triggered, the total gets updated, and some logs are printed on the screen.</li>
    </ol>
    <p class="normal">If we run this example, we will see the following output in the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Starting total: 110
TOTAL: 210 (subtotal changed: 100 -&gt; 200)
TOTAL: 200 (discount changed: 10 -&gt; 20)
TOTAL: 210 (tax changed: 20 -&gt; 30)
Final total: 210
</code></pre>
    <p class="normal">In this example, we could make the total calculation logic arbitrarily complicated, for instance, by introducing<a id="_idIndexMarker647"/> new fields in the computation (shipping costs, other taxes, and so on). In this case, it will be fairly trivial to introduce the new fields in the <code class="Code-In-Text--PACKT-">invoice</code> object and update the <code class="Code-In-Text--PACKT-">calculateTotal()</code> function. Once <a id="_idIndexMarker648"/>we do that, every change to<a id="_idIndexMarker649"/> the new properties will be observed and the <code class="Code-In-Text--PACKT-">total</code> will be kept<a id="_idIndexMarker650"/> up to date with every change.</p>
    <div><p class="Information-Box--PACKT-">Observables are the cornerstone of <strong class="keyword">reactive programming</strong> (<strong class="keyword">RP</strong>) and <strong class="keyword">functional reactive programming</strong> (<strong class="keyword">FRP</strong>). If you are curious to know more about these styles of programming check out the <em class="italic">Reactive Manifesto</em>, at <a href="http://nodejsdp.link/reactive-manifesto">nodejsdp.link/reactive-manifesto</a>.</p>
    </div>
    <h2 id="_idParaDest-217" class="title">In the wild</h2>
    <p class="normal">The Proxy pattern and more<a id="_idIndexMarker651"/> specifically the Change Observer pattern are widely adopted patterns, which can be found on backend projects and libraries as well as in the frontend world. Some popular projects that take advantage of these patterns include the following:</p>
    <ul>
      <li class="Bullet--PACKT-">LoopBack (<a href="http://nodejsdp.link/loopback">nodejsdp.link/loopback</a>) is a popular <a id="_idIndexMarker652"/>Node.js web framework that uses the Proxy pattern to provide the capability to intercept and enhance method calls on<a id="_idIndexMarker653"/> controllers. This capability can be used to build custom validation or authentication mechanisms.</li>
      <li class="Bullet--PACKT-">Version 3 of Vue.js (<a href="http://nodejsdp.link/vue">nodejsdp.link/vue</a>), a very <a id="_idIndexMarker654"/>popular JavaScript reactive UI framework, has reimplemented observable properties using the Proxy<a id="_idIndexMarker655"/> pattern with the <code class="Code-In-Text--PACKT-">Proxy</code> object.</li>
      <li class="Bullet-End--PACKT-">MobX (<a href="http://nodejsdp.link/mobx">nodejsdp.link/mobx</a>) is a famous reactive <a id="_idIndexMarker656"/>state management library commonly <a id="_idIndexMarker657"/>used in frontend applications in combination with React or Vue.js. Like Vue.js, MobX implements reactive observables using the <code class="Code-In-Text--PACKT-">Proxy</code> object.</li>
    </ul>
    <h1 id="_idParaDest-218" class="title">Decorator</h1>
    <p class="normal">Decorator is a structural design pattern that <a id="_idIndexMarker658"/>consists in<a id="_idIndexMarker659"/> dynamically augmenting the behavior of an existing object. It's different from classical inheritance, because the behavior is not added to all the objects of the same class, but only to the instances that are explicitly decorated.</p>
    <p class="normal">Implementation-wise, it is very similar to the Proxy pattern, but instead of enhancing or modifying the behavior of the existing interface of an object, it augments it with new functionalities, as described in <em class="italic">Figure 8.2</em>:</p>
    <figure class="mediaobject"><img src="img/B15729_08_02.png" alt="A screenshot of a cell phone  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.2: Decorator pattern schematic</p>
    <p class="normal">In <em class="italic">Figure 8.2</em>, the <code class="Code-In-Text--PACKT-">Decorator</code> object is extending the <code class="Code-In-Text--PACKT-">Component</code> object by adding the <code class="Code-In-Text--PACKT-">methodC()</code> operation. The existing methods are usually delegated to the decorated object without further<a id="_idIndexMarker660"/> processing but, in some cases, they might also be intercepted and augmented with extra behaviors.</p>
    <h2 id="_idParaDest-219" class="title">Techniques for implementing decorators</h2>
    <p class="normal">Although proxy and decorator <a id="_idIndexMarker661"/>are conceptually two different patterns with different intents, they practically share the same implementation <a id="_idIndexMarker662"/>strategies. We will review them shortly. This time we want to use the Decorator pattern to be able to take an instance of our <code class="Code-In-Text--PACKT-">StackCalculator</code> class and "decorate it" so that it also exposes a new method called <code class="Code-In-Text--PACKT-">add()</code>, which we can use to perform additions between two numbers. We will also use the decorator to intercept all the calls to the <code class="Code-In-Text--PACKT-">divide()</code> method and implement the same division-by-zero check that we already saw in our <code class="Code-In-Text--PACKT-">SafeCalculator</code> example.</p>
    <h3 id="_idParaDest-220" class="title">Composition</h3>
    <p class="normal">Using composition, the <a id="_idIndexMarker663"/>decorated component is wrapped around a new object that usually inherits from it. The decorator in this case simply needs to define the new methods, while delegating the existing ones to the original component:</p>
    <pre class="programlisting code"><code class="hljs-code">class EnhancedCalculator {
  constructor (calculator) {
    this.calculator = calculator
  }
  // new method
  add () {
    const addend2 = this.getValue()
    const addend1 = this.getValue()
    const result = addend1 + addend2
    this.putValue(result)
    return result
  }
  // modified method
  divide () {
    // additional validation logic
    const divisor = this.calculator.peekValue()
    if (divisor === 0) {
      throw Error('Division by 0')
    }
    // if valid delegates to the subject
    return this.calculator.divide()
  }
  // delegated methods
  putValue (value) {
    return this.calculator.putValue(value)
  }
  getValue () {
    return this.calculator.getValue()
  }
  peekValue () {
    return this.calculator.peekValue()
  }
  clear () {
    return this.calculator.clear()
  }
  multiply () {
    return this.calculator.multiply()
  }
}
const calculator = new StackCalculator()
const enhancedCalculator = new EnhancedCalculator(calculator)
enhancedCalculator.putValue(4)
enhancedCalculator.putValue(3)
console.log(enhancedCalculator.add())      // 4+3 = 7
enhancedCalculator.putValue(2)
console.log(enhancedCalculator.multiply()) // 7*2 = 14
</code></pre>
    <p class="normal">If you remember our composition implementation for the Proxy pattern, you can probably see that the code here looks quite similar.</p>
    <p class="normal">We created the new <code class="Code-In-Text--PACKT-">add()</code> method and enhanced the behavior of the original <code class="Code-In-Text--PACKT-">divide()</code> method (effectively replicating the<a id="_idIndexMarker664"/> feature we saw in the previous <code class="Code-In-Text--PACKT-">SafeCalculator</code> example). Finally, we delegated the <code class="Code-In-Text--PACKT-">putValue()</code>, <code class="Code-In-Text--PACKT-">getValue()</code>, <code class="Code-In-Text--PACKT-">peekValue()</code>, <code class="Code-In-Text--PACKT-">clear()</code>, and <code class="Code-In-Text--PACKT-">multiply()</code> methods to the original subject.</p>
    <h3 id="_idParaDest-221" class="title">Object augmentation</h3>
    <p class="normal"><strong class="keyword">Object decoration</strong> can also be achieved<a id="_idIndexMarker665"/> by simply attaching new methods directly to the decorated object (monkey patching), as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">function patchCalculator (calculator) {
  // new method
  calculator.add = function () {
    const addend2 = calculator.getValue()
    const addend1 = calculator.getValue()
    const result = addend1 + addend2
    calculator.putValue(result)
    return result
  }
  // modified method
  const divideOrig = calculator.divide
  calculator.divide = () =&gt; {
    // additional validation logic
    const divisor = calculator.peekValue()
    if (divisor === 0) {
      throw Error('Division by 0')
    }
    // if valid delegates to the subject
    return divideOrig.apply(calculator)
  }
  return calculator
}
const calculator = new StackCalculator()
const enhancedCalculator = patchCalculator(calculator)
// ...
</code></pre>
    <p class="normal">Note that in this example, <code class="Code-In-Text--PACKT-">calculator</code> and <code class="Code-In-Text--PACKT-">enhancedCalculator</code> reference the same object (<code class="Code-In-Text--PACKT-">calculator == enhancedCalculator</code>). This is because <code class="Code-In-Text--PACKT-">patchCalculator()</code> is mutating the original <code class="Code-In-Text--PACKT-">calculator</code> object and <a id="_idIndexMarker666"/>then returning it. You can confirm this by invoking <code class="Code-In-Text--PACKT-">calculator.add()</code> or <code class="Code-In-Text--PACKT-">calculator.divide()</code>.</p>
    <h3 id="_idParaDest-222" class="title">Decorating with the Proxy object</h3>
    <p class="normal">It's possible<a id="_idIndexMarker667"/> to implement object decoration by using the <code class="Code-In-Text--PACKT-">Proxy</code> object. A generic example might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">const enhancedCalculatorHandler = {
  get (target, property) {
    if (property === 'add') {
      // new method
      return function add () {
        const addend2 = target.getValue()
        const addend1 = target.getValue()
        const result = addend1 + addend2
        target.putValue(result)
        return result
      }
    } else if (property === 'divide') {
      // modified method
      return function () {
        // additional validation logic
        const divisor = target.peekValue()
        if (divisor === 0) {
          throw Error('Division by 0')
        }
        // if valid delegates to the subject
        return target.divide()
      }
    }
    // delegated methods and properties
    return target[property]
  }
}
const calculator = new StackCalculator()
const enhancedCalculator = new Proxy(
  calculator,
  enhancedCalculatorHandler
)
// ...
</code></pre>
    <p class="normal">If we were to<a id="_idIndexMarker668"/> compare these different implementations, the same caveats discussed during the analysis of the Proxy pattern would also apply for the decorator. Let's focus instead on practicing the pattern with a real-life example!</p>
    <h2 id="_idParaDest-223" class="title">Decorating a LevelUP database</h2>
    <p class="normal">Before we start coding the <a id="_idIndexMarker669"/>next example, let's say<a id="_idIndexMarker670"/> a few words about <strong class="keyword">LevelUP</strong>, the module that we are now going to work with.</p>
    <h3 id="_idParaDest-224" class="title">Introducing LevelUP and LevelDB</h3>
    <p class="normal"><strong class="keyword">LevelUP</strong> (<a href="http://nodejsdp.link/levelup">nodejsdp.link/levelup</a>) is a Node.js wrapper<a id="_idIndexMarker671"/> around Google's <strong class="keyword">LevelDB</strong>, a key-value store <a id="_idIndexMarker672"/>originally built to implement IndexedDB in the Chrome <a id="_idIndexMarker673"/>browser, but it's much more than that. LevelDB has been defined as the "Node.js of databases" because of its minimalism and extensibility. Like Node.js, LevelDB provides blazingly fast performance and only the most basic set of features, allowing developers to build any kind of database on top of it.</p>
    <p class="normal">The Node.js community, and in this case Rod Vagg, did not miss the chance to bring the power of this database into the Node.js world by creating LevelUP. Born as a wrapper for LevelDB, it then evolved to support several kinds of backends, from in-memory stores, to other NoSQL databases such as Riak and Redis, to web storage engines such as IndexedDB and localStorage, allowing us to use the same API on both the server and the client, opening up some really interesting scenarios.</p>
    <p class="normal">Today, there is a vast ecosystem around LevelUP made of plugins and modules that extend the tiny core to implement features such as replication, secondary indexes, live updates, query engines, and more. Complete databases were also built on top of LevelUP, including CouchDB clones <a id="_idIndexMarker674"/>such as PouchDB (<a href="http://nodejsdp.link/pouchdb">nodejsdp.link/pouchdb</a>), and even a <a id="_idIndexMarker675"/>graph database, LevelGraph (<a href="http://nodejsdp.link/levelgraph">nodejsdp.link/levelgraph</a>), which can work both on <a id="_idIndexMarker676"/>Node.js and the browser!</p>
    <div><p class="Information-Box--PACKT-">Find out more about the LevelUP ecosystem at <a href="http://nodejsdp.link/awesome-level">nodejsdp.link/awesome-level</a>.</p>
    </div>
    <h3 id="_idParaDest-225" class="title">Implementing a LevelUP plugin</h3>
    <p class="normal">In the next example, we are<a id="_idIndexMarker677"/> going to show you how we can create a simple plugin for LevelUP using the Decorator pattern, and in particular, the object augmentation technique, which is the simplest but also the most pragmatic and effective way to decorate objects with additional capabilities.</p>
    <div><p class="Information-Box--PACKT-">For convenience, we are going to use the <code class="Code-In-Text--PACKT-">level</code> package (<a href="http://nodejsdp.link/level">nodejsdp.link/level</a>), which bundles both <code class="Code-In-Text--PACKT-">levelup</code> and the default adapter called <code class="Code-In-Text--PACKT-">leveldown</code>, which uses LevelDB as the backend.</p>
    </div>
    <p class="normal">What we want to build is a <a id="_idIndexMarker678"/>plugin for LevelUP that allows us to receive notifications every time an object with a certain pattern is saved into the database. For example, if we subscribe to a pattern such as <code class="Code-In-Text--PACKT-">{a: 1}</code>, we want to receive a notification when objects such as <code class="Code-In-Text--PACKT-">{a: 1, b: 3}</code> or <code class="Code-In-Text--PACKT-">{a: 1, c: 'x'}</code> are saved into the database.</p>
    <p class="normal">Let's start to build our small plugin by creating a new module called <code class="Code-In-Text--PACKT-">level-subscribe.js</code>. We will then insert the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">export function levelSubscribe (db) {
  db.subscribe = (pattern, listener) =&gt; {                // (1)
    db.on('put', (key, val) =&gt; {                         // (2)
      const match = Object.keys(pattern).every(
        k =&gt; (pattern[k] === val[k])                     // (3)
      )
      if (match) {
        listener(key, val)                               // (4)
      }
    })
  }
  return db
}
</code></pre>
    <p class="normal">That's it for our plugin; it's extremely simple. Let's briefly analyze the preceding code:</p>
    <ol>
      <li class="numbered">We decorate the <code class="Code-In-Text--PACKT-">db</code> object with a new method named <code class="Code-In-Text--PACKT-">subscribe()</code>. We simply attach the method directly to the provided <code class="Code-In-Text--PACKT-">db</code> instance (object augmentation).</li>
      <li class="numbered">We listen for any <code class="Code-In-Text--PACKT-">put</code> operation performed on the database.</li>
      <li class="numbered">We perform a very simple pattern-matching algorithm, which verifies that all the properties in the provided pattern are also available in the data being inserted.</li>
      <li class="numbered">If we have a match, we notify the listener.</li>
    </ol>
    <p class="normal">Let's now write some code to try<a id="_idIndexMarker679"/> out our new plugin:</p>
    <pre class="programlisting code"><code class="hljs-code">import { dirname, join } from 'path'
import { fileURLToPath } from 'url'
import level from 'level'
import { levelSubscribe } from './level-subscribe.js'
const __dirname = dirname(fileURLToPath(import.meta.url))
const dbPath = join(__dirname, 'db')
const db = level(dbPath, { valueEncoding: 'json' })      // (1)
levelSubscribe(db)                                       // (2)
db.subscribe(                                            // (3)
  { doctype: 'tweet', language: 'en' },
  (k, val) =&gt; console.log(val)
)
db.put('1', {                                            // (4)
  doctype: 'tweet',
  text: 'Hi',
  language: 'en'
})
db.put('2', {
  doctype: 'company',
  name: 'ACME Co.'
})
</code></pre>
    <p class="normal">This is how the preceding code works:</p>
    <ol>
      <li class="numbered">First, we initialize our LevelUP database, choosing the directory where the files are stored and the default encoding for the values.</li>
      <li class="numbered">Then, we attach our plugin, which decorates the original <code class="Code-In-Text--PACKT-">db</code> object.</li>
      <li class="numbered">At this point, we are ready to use the new feature provided by our plugin, which is the <code class="Code-In-Text--PACKT-">subscribe()</code> method, where we specify that we are interested in all the objects with <code class="Code-In-Text--PACKT-">doctype: 'tweet'</code> and <code class="Code-In-Text--PACKT-">language: 'en'</code>.</li>
      <li class="numbered">Finally, we save some values in the database using <code class="Code-In-Text--PACKT-">put</code>. The first call triggers the callback associated with our subscription and we should see the stored object printed to the console. This is because, in this<a id="_idIndexMarker680"/> case, the object matches the subscription. The second call does not generate any output because the stored object does not match the subscription criteria.</li>
    </ol>
    <p class="normal">This example shows a real application of the Decorator pattern in its simplest implementation, which is object augmentation. It may look like a trivial pattern, but it has undoubted power if used <a id="_idIndexMarker681"/>appropriately.</p>
    <div><p class="Information-Box--PACKT-">For simplicity, our plugin works only in combination with <code class="Code-In-Text--PACKT-">put</code> operations, but it can be easily expanded to work even with <code class="Code-In-Text--PACKT-">batch</code> operations (<a href="http://nodejsdp.link/levelup-batch">nodejsdp.link/levelup-batch</a>).</p>
    </div>
    <h2 id="_idParaDest-226" class="title">In the wild</h2>
    <p class="normal">For more examples of how decorators are used in the real world, you can inspect the code of some more LevelUP plugins:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">level-inverted-index</code> (<a href="http://nodejsdp.link/level-inverted-index">nodejsdp.link/level-inverted-index</a>): This is a plugin that adds<a id="_idIndexMarker682"/> inverted indexes to a LevelUP database, allowing us to perform simple text searches across the values stored in the database</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">levelplus</code> (<a href="http://nodejsdp.link/levelplus">nodejsdp.link/levelplus</a>): This is a plugin that <a id="_idIndexMarker683"/>adds atomic updates to a LevelUP database</li>
    </ul>
    <p class="normal">Aside from LevelUP plugins, the following projects are also good examples of the adoption of the Decorator pattern:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">json-socket</code> (<a href="http://nodejsdp.link/json-socket">nodejsdp.link/json-socket</a>): This module <a id="_idIndexMarker684"/>makes it easier to send JSON data over a TCP (or a Unix) socket. It is designed to decorate an <a id="_idIndexMarker685"/>existing instance of <code class="Code-In-Text--PACKT-">net.Socket</code>, which gets enriched with additional methods and behaviors.</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">fastify</code> (<a href="http://nodejsdp.link/fastify">nodejsdp.link/fastify</a>) is a web <a id="_idIndexMarker686"/>application framework that exposes an API to<a id="_idIndexMarker687"/> decorate a Fastify server instance with additional functionality or configuration. With this approach, the additional functionality is made accessible to different parts of the application. This is a quite generalized implementation of the Decorator pattern. Check out the dedicated documentation page to find out more at <a href="http://nodejsdp.link/fastify-decorators">nodejsdp.link/fastify-decorators</a>.</li>
    </ul>
    <h1 id="_idParaDest-227" class="title">The line between proxy and decorator</h1>
    <p class="normal">At this point in the book, you might have some legitimate doubts about the differences between the Proxy <a id="_idIndexMarker688"/>and the Decorator patterns. These two<a id="_idIndexMarker689"/> patterns are indeed very similar and they can sometimes be used interchangeably.</p>
    <p class="normal">In its classic incarnation, the Decorator pattern is defined as a mechanism that allows us to enhance an existing object with new behavior, while the Proxy pattern is used to control access to a concrete or virtual object.</p>
    <p class="normal">There is a conceptual difference between the two patterns, and it's mostly based on the way they are used at runtime.</p>
    <p class="normal">You can look at the Decorator pattern as a wrapper; you can take different types of objects and decide to wrap them with a decorator to enhance their capabilities with extra functionality. A proxy, instead, is used to control the access to an object and it does not change the original interface. For this reason, once you have created a proxy instance, you can pass it over to a context that expects the original object.</p>
    <p class="normal">When it comes to implementation, these differences are generally much more obvious with strongly typed languages where the type of the objects you pass around is checked at compile time. In the Node.js ecosystem, given the dynamic nature of the JavaScript language, the line between the Proxy and the Decorator patterns is quite blurry, and often the two names are used interchangeably. We have also seen how the same techniques can be used to implement both patterns.</p>
    <p class="normal">When dealing with JavaScript and Node.js, our advice is to avoid getting bogged down with the nomenclature and the canonical definition of these two patterns. We encourage you to look at the class of problems that proxy and decorator solve as a whole and treat these two patterns as complementary and sometimes interchangeable tools.</p>
    <h1 id="_idParaDest-228" class="title">Adapter</h1>
    <p class="normal">The Adapter pattern allows<a id="_idIndexMarker690"/> us to access the functionality of an object using a different interface.</p>
    <p class="normal">A real-life example of an adapter <a id="_idIndexMarker691"/>would be a device that allows you to plug a USB Type-A cable into a USB Type-C port. In a generic sense, an adapter converts an object with a given interface so that it can be used in a context where a different interface is expected.</p>
    <p class="normal">In software, the Adapter pattern is used to take<a id="_idIndexMarker692"/> the interface of an object (the <strong class="keyword">adaptee</strong>) and make it compatible with another interface that is expected by a given client. Let's have a look at <em class="italic">Figure 8.3</em> to clarify this idea:</p>
    <figure class="mediaobject"><img src="img/B15729_08_03.png" alt="A screenshot of a cell phone  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.3: Adapter pattern schematic</p>
    <p class="normal">In <em class="italic">Figure 8.3</em>, we can see how the adapter is essentially a wrapper for the adaptee, exposing a different interface. The diagram also highlights the fact that the operations of the adapter can also be a composition of one or more method invocations on the adaptee. From an implementation perspective, the most common technique is composition, where the methods of the adapter provide a bridge to the methods of the adaptee. This pattern is pretty straightforward, so let's immediately work on an example.</p>
    <h2 id="_idParaDest-229" class="title">Using LevelUP through the filesystem API</h2>
    <p class="normal">We are now going to build an <a id="_idIndexMarker693"/>adapter around the LevelUP API, transforming it into an interface that is compatible with the core <code class="Code-In-Text--PACKT-">fs</code> module. In <a id="_idIndexMarker694"/>particular, we will make sure that every call to <code class="Code-In-Text--PACKT-">readFile()</code> and <code class="Code-In-Text--PACKT-">writeFile()</code> will translate into calls to <code class="Code-In-Text--PACKT-">db.get()</code> and <code class="Code-In-Text--PACKT-">db.put()</code>. This way we will be able to use a LevelUP database as a storage backend for simple filesystem operations.</p>
    <p class="normal">Let's start by creating a new module named <code class="Code-In-Text--PACKT-">fs-adapter.js</code>. We will begin by loading the dependencies and exporting the <code class="Code-In-Text--PACKT-">createFsAdapter()</code> factory that we are going to use to build the adapter:</p>
    <pre class="programlisting code"><code class="hljs-code">import { resolve } from 'path'
export function createFSAdapter (db) {
  return ({
    readFile (filename, options, callback) {
      // ...
    },
    writeFile (filename, contents, options, callback) {
      // ...
    }
  })
}
</code></pre>
    <p class="normal">Next, we will implement the <code class="Code-In-Text--PACKT-">readFile()</code> function inside the factory and ensure that its interface is compatible with the<a id="_idIndexMarker695"/> one of the original <a id="_idIndexMarker696"/>function from the <code class="Code-In-Text--PACKT-">fs</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code">    readFile (filename, options, callback) {
      if (typeof options === 'function') {
        callback = options
        options = {}
      } else if (typeof options === 'string') {
        options = { encoding: options }
      }
      db.get(resolve(filename), {                           // (1)
        valueEncoding: options.encoding
      },
      (err, value) =&gt; {
        if (err) {
          if (err.type === 'NotFoundError') {               // (2)
            err = new Error(`ENOENT, open "${filename}"`)
            err.code = 'ENOENT'
            err.errno = 34
            err.path = filename
          }
          return callback &amp;&amp; callback(err)
        }
        callback &amp;&amp; callback(null, value)                   // (3)
      })
    }
</code></pre>
    <p class="normal">In the preceding code, we had to do some extra work to make sure that the behavior of our new function is as close as possible to the original <code class="Code-In-Text--PACKT-">fs.readFile()</code> function. The steps performed by the function are described as follows:</p>
    <ol>
      <li class="numbered">To retrieve a file from the <code class="Code-In-Text--PACKT-">db</code> instance, we invoke <code class="Code-In-Text--PACKT-">db.get()</code>, using <code class="Code-In-Text--PACKT-">filename</code> as a key, by making sure to always use its full path (using <code class="Code-In-Text--PACKT-">resolve()</code>). We set the value of the <code class="Code-In-Text--PACKT-">valueEncoding</code> option used<a id="_idIndexMarker697"/> by the database to be equal to any eventual <code class="Code-In-Text--PACKT-">encoding</code> option received as an input.</li>
      <li class="numbered">If the key is not found in the database, we create an error with <code class="Code-In-Text--PACKT-">ENOENT</code> as the error code, which is the code used by the original <code class="Code-In-Text--PACKT-">fs</code> module to indicate a missing file. Any other type<a id="_idIndexMarker698"/> of error is forwarded to <code class="Code-In-Text--PACKT-">callback</code> (for the scope of this example, we are adapting only the most common error condition).</li>
      <li class="numbered">If the key-value pair is retrieved successfully from the database, we will return the value to the caller using the <code class="Code-In-Text--PACKT-">callback</code>.</li>
    </ol>
    <p class="normal">The function that we created does not want to be a perfect replacement for the <code class="Code-In-Text--PACKT-">fs.readFile()</code> function, but it definitely does its job in the most common situations.</p>
    <p class="normal">To complete our small adapter, let's now see how to implement the <code class="Code-In-Text--PACKT-">writeFile()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">    writeFile (filename, contents, options, callback) {
      if (typeof options === 'function') {
        callback = options
        options = {}
      } else if (typeof options === 'string') {
        options = { encoding: options }
      }
      db.put(resolve(filename), contents, {
        valueEncoding: options.encoding
      }, callback)
    }
</code></pre>
    <p class="normal">As we can see, we don't have a perfect wrapper in this case either. We are ignoring some options such as file permissions (<code class="Code-In-Text--PACKT-">options.mode</code>), and we are forwarding any error that we receive from the database as is.</p>
    <p class="normal">Our new adapter is now ready. If we now write a small test module, we can try to use it:</p>
    <pre class="programlisting code"><code class="hljs-code">import fs from 'fs'
fs.writeFile('file.txt', 'Hello!', () =&gt; {
  fs.readFile('file.txt', { encoding: 'utf8' }, (err, res) =&gt; {
    if (err) {
      return console.error(err)
    }
    console.log(res)
  })
})
// try to read a missing file
fs.readFile('missing.txt', { encoding: 'utf8' }, (err, res) =&gt; {
  console.error(err)
})
</code></pre>
    <p class="normal">The preceding code uses the original <code class="Code-In-Text--PACKT-">fs</code> API to<a id="_idIndexMarker699"/> perform a few read<a id="_idIndexMarker700"/> and write operations on the filesystem, and should print something like the following to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Error: ENOENT, open "missing.txt"
Hello!
</code></pre>
    <p class="normal">Now, we can try to replace the <code class="Code-In-Text--PACKT-">fs</code> module with our adapter, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">import { dirname, join } from 'path'
import { fileURLToPath } from 'url'
import level from 'level'
import { createFSAdapter } from './fs-adapter.js'
const __dirname = dirname(fileURLToPath(import.meta.url))
const db = level(join(__dirname, 'db'), {
  valueEncoding: 'binary'
})
const fs = createFSAdapter(db)
// ...
</code></pre>
    <p class="normal">Running our program again should produce the same output, except for the fact that no parts of the file that we specified are read or written using the filesystem API directly. Instead, any operation performed using our adapter will be converted into an operation performed on a LevelUP<a id="_idIndexMarker701"/> database.</p>
    <p class="normal">The adapter that we just created might look silly; what's the purpose of using a database in place of the real filesystem? However, we should remember that LevelUP itself has adapters that enable the database to also run in the browser. One of these adapters is <code class="Code-In-Text--PACKT-">level-js</code> (<a href="http://nodejsdp.link/level-js">nodejsdp.link/level-js</a>). Now our adapter makes perfect sense. We could use something similar to allow code leveraging the <code class="Code-In-Text--PACKT-">fs</code> module to run on both Node.js and a browser. We will soon realize that Adapter is an extremely important pattern when it comes to sharing code with the browser, as we will see in more detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Universal JavaScript for Web Applications</em>.</p>
    <h2 id="_idParaDest-230" class="title">In the wild</h2>
    <p class="normal">There are plenty of real-world examples of the Adapter pattern. We've listed some of the most notable <a id="_idIndexMarker702"/>examples here for you to explore and analyze:</p>
    <ul>
      <li class="Bullet--PACKT-">We already know that LevelUP is able to run with different storage backends, from the default LevelDB to IndexedDB in the browser. This is made possible by the various adapters that are created to replicate the internal (private) LevelUP API. Take a look at some of them to see how they are implemented at <a href="http://nodejsdp.link/level-stores">nodejsdp.link/level-stores</a>.</li>
      <li class="Bullet--PACKT-">JugglingDB is a multi-database <a id="_idIndexMarker703"/>ORM and of course, multiple adapters are <a id="_idIndexMarker704"/>used to make it compatible with different databases. Take a look at some of them at <a href="http://nodejsdp.link/jugglingdb-adapters">nodejsdp.link/jugglingdb-adapters</a>.</li>
      <li class="Bullet--PACKT-">nanoSQL (<a href="http://nodejsdp.link/nanosql">nodejsdp.link/nanosql</a>) is a modern multi-model database abstraction library that makes heavy<a id="_idIndexMarker705"/> usage of the Adapter pattern to <a id="_idIndexMarker706"/>support a significant variety of databases.</li>
      <li class="Bullet-End--PACKT-">The perfect complement to the example that we <a id="_idIndexMarker707"/>created is <code class="Code-In-Text--PACKT-">level-filesystem</code> (<a href="http://nodejsdp.link/level-filesystem">nodejsdp.link/level-filesystem</a>), which is the proper implementation of the <code class="Code-In-Text--PACKT-">fs</code> API on top of LevelUP.</li>
    </ul>
    <h1 id="_idParaDest-231" class="title">Summary</h1>
    <p class="normal">Structural design patterns are definitely some of the most widely adopted design patterns in software engineering and it is important to be confident with them. In this chapter, we explored the Proxy, the Decorator, and the Adapter patterns and we discussed different ways to implement these in the context of Node.js.</p>
    <p class="normal">We saw how the Proxy pattern can be a very valuable tool to control access to existing objects. In this chapter, we also mentioned how the Proxy pattern can enable different programming paradigms such as reactive programming using the Change Observer pattern.</p>
    <p class="normal">In the second part of the chapter, we found out that the Decorator pattern is an invaluable tool to be able to add additional functionality to existing objects. We saw that its implementation doesn't differ much from the Proxy pattern and we explored some examples built around the LevelDB ecosystem.</p>
    <p class="normal">Finally, we discussed the Adapter pattern, which allows us to wrap an existing object and expose its functionality through a different interface. We saw that this pattern can be useful to expose a piece of existing functionality to a component that expects a different interface. In our examples, we saw how this pattern can be used to implement an alternative storage layer that is compatible with the interface provided by the <code class="Code-In-Text--PACKT-">fs</code> module to interact with files.</p>
    <p class="normal">Proxy, decorator and adapter are very similar, the difference between them can be appreciated from the perspective of the interface consumer: proxy provides the same interface as the wrapped object, decorator provides an enhanced interface, and adapter provides a different interface.</p>
    <p class="normal">In the next chapter, we will complete our journey through traditional design patterns in Node.js by exploring the category of behavioral design patterns. This category includes important patterns such as the Strategy pattern, the Middleware pattern, and the Iterator pattern. Are you ready to discover behavioral design patterns?</p>
    <h1 id="_idParaDest-232" class="title">Exercises</h1>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">8.1 HTTP client cache</strong>: Write a proxy for your favorite HTTP client library that caches the response of a given HTTP request, so that if you make the same request again, the response is immediately returned from the local cache, rather than being fetched from the remote URL. If you need inspiration, you can check out the <code class="Code-In-Text--PACKT-">superagent-cache</code> module (<a href="http://nodejsdp.link/superagent-cache">nodejsdp.link/superagent-cache</a>).</li>
      <li class="Bullet--PACKT-"><strong class="keyword">8.2 Timestamped logs</strong>: Create a proxy for the <code class="Code-In-Text--PACKT-">console</code> object that enhances every logging function (<code class="Code-In-Text--PACKT-">log()</code>, <code class="Code-In-Text--PACKT-">error()</code>, <code class="Code-In-Text--PACKT-">debug()</code>, and <code class="Code-In-Text--PACKT-">info()</code>) by prepending the current timestamp to the message you want to print in the logs. For instance, executing <code class="Code-In-Text--PACKT-">consoleProxy.log('hello')</code> should print something like <code class="Code-In-Text--PACKT-">2020-02-18T15:59:30.699Z hello</code> in the console.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">8.3 Colored console output</strong>: Write a decorator for the console that adds the <code class="Code-In-Text--PACKT-">red(message)</code>, <code class="Code-In-Text--PACKT-">yellow(message)</code>, and <code class="Code-In-Text--PACKT-">green(message)</code> methods. These methods will have to behave like <code class="Code-In-Text--PACKT-">console.log(message)</code> except they will print the message in red, yellow, or green, respectively. In one of the exercises from the previous chapter, we already pointed you to some useful packages to to create colored console output. If you want to try something different this time, have a look at <code class="Code-In-Text--PACKT-">ansi-styles</code> (<a href="http://nodejsdp.link/ansi-styles">nodejsdp.link/ansi-styles</a>).</li>
      <li class="Bullet--PACKT-"><strong class="keyword">8.4 Virtual filesystem</strong>: Modify our LevelDB filesystem adapter example to write the file data in memory rather than in LevelDB. You can use an object or a <code class="Code-In-Text--PACKT-">Map</code> instance to store the key-value pairs of filenames and the associated data.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">8.5 The lazy buffer</strong>: Can you implement <code class="Code-In-Text--PACKT-">createLazyBuffer(size)</code>, a factory function that generates a virtual proxy for a <code class="Code-In-Text--PACKT-">Buffer</code> of the given size? The proxy instance should instantiate a <code class="Code-In-Text--PACKT-">Buffer</code> object (effectively allocating the given amount of memory) only when <code class="Code-In-Text--PACKT-">write()</code> is being invoked for the first time. If no attempt to write into the buffer is made, no <code class="Code-In-Text--PACKT-">Buffer</code> instance should be created.</li>
    </ul>
  </div>
</body></html>