<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introducing PostCSS</h1></div></div></div><p>A key part of any website is styling—it doesn't matter if this is for a simple element tag or a complex animation; a website is not a website without color and action. Building styles for any online presence takes time and effort—we can reduce development time by using a preprocessor to automate the creation of styles, automatically apply vendor prefixes and the like, but the extra dependency of a library can be like using a sledgehammer to crack a nut!</p><p>Enter PostCSS—its unique modular style allows us to create a leaner, faster CSS processor, with no external dependencies. In this chapter, we look at installing PostCSS, understanding its architecture, and learn how to use its speed and power to compile code into valid CSS. We will cover a number of topics throughout this chapter, which will include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Considering the benefits of creating our own preprocessor</li><li class="listitem" style="list-style-type: disc">Introducing PostCSS and exploring its features</li><li class="listitem" style="list-style-type: disc">Setting up a development environment using PostCSS</li><li class="listitem" style="list-style-type: disc">Creating a simple example using PostCSS</li><li class="listitem" style="list-style-type: disc">Exploring how PostCSS works and its architecture</li></ul></div><p>Let's make a start…!</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>All of the exercises in this book are written for the Windows platform; please adjust accordingly if you use a different operating system.</p></div></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Discovering the art of processing</h1></div></div></div><p>A question: what do <a id="id0" class="indexterm"/>SASS, Stylus, Haml, and Less all have in common?</p><p>The answer is, they are all <a id="id1" class="indexterm"/>compilers, source to source compiling, or <strong>transpilers</strong> (to give them their official name), that have been around since the 1980s. They have appeared in many different formats, with Digital Research's XLT86 being one of the earliest versions, dating from 1981.</p><p>More recently, the well-known SASS processor arrived in 2006; this was followed by Less, created by Alexis Sellier in 2009. Both work in a similar fashion: they take a set of rules and compile it into valid CSS. We can extend CSS with all manner of features, such as variables, mixins, functions, and more. Although processors may not help cut down the physical number of lines we have to write, they help us reorganize code into more manageable blocks that we can reuse in future projects, which helps make CSS easier to maintain.</p><p>But, as is nearly always the case, there are some drawbacks to using processors:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is nearly always a dependency involved, in some form or other—with SASS, it's Ruby; if you're using Less, it's a library, even though it is written in JavaScript</li><li class="listitem" style="list-style-type: disc">Our project may only use a small amount of preprocessed code, yet we are forced to rely on what can be a large library, such as SASS</li><li class="listitem" style="list-style-type: disc">Processing style sheets using a preprocessor is slow; it may only be a few seconds, but this builds up over time to become a significant amount of time spent waiting for processes to complete</li></ul></div><p>Hmm, this doesn't make processing so attractive! But what if there were a way to alleviate all of these issues, and remove the need for dependencies at the same time?</p><p>Well, there is: let's build our own <a id="id2" class="indexterm"/>processor! Okay, this might sound a little crazy, but as someone once said, there is method in this madness, so bear with me while I explain why this may be a better option.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introducing PostCSS</h1></div></div></div><p>At the beginning of this <a id="id3" class="indexterm"/>chapter, I mentioned that we would focus on creating our own preprocessor, right? Well, I have a little confession to make: we're not. Hold on, what gives?</p><p>Well, we will create a preprocessor…but we will also create a postprocessor too. Let me explain why—our alternative "option" allows us to create both at the same time. Our alternative option is PostCSS, which can be downloaded from <a class="ulink" href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a>. PostCSS is used by some major companies, such as Twitter, Google, Bootstrap and <a id="id4" class="indexterm"/>CodePen, and even WordPress (in a limited capacity).</p><p>PostCSS was built as a Node.js module, so will work with any number of the existing plugins already available for Node.js—we will be using a number of these plugins throughout the book. Let's take a moment to explore some of the benefits of this tool.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Exploring the benefits of using PostCSS</h2></div></div></div><p>What do we mean by <a id="id5" class="indexterm"/>PostCSS? In a nutshell, it can be used to refer to one of two things—the PostCSS core tool or the plugin ecosystem that is powered by the tool. On its own, it doesn't actually do a lot; once we start adding plugins, we can achieve a great deal. Let's explore what this means in practice:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Its modular architecture means we can pick and choose what we use; this allows us to keep the size of the library very small and responsive.</li><li class="listitem" style="list-style-type: disc">Existing processors tend to fall into one of two camps—pre- or post-processing—which is a limiting factor when choosing which to use. PostCSS allows us to perform both operations within the same process, meaning we get the benefits of both worlds of processing!</li><li class="listitem" style="list-style-type: disc">PostCSS comes with seamless support for all of the common task runners such as Gulp, Grunt, or Broccoli; we can combine it with a number of other tasks that can be automated.</li><li class="listitem" style="list-style-type: disc">There are no dependencies for compiling, PostCSS is written entirely in JavaScript, so no need for Ruby, or libraries such as <code class="literal">libsass</code>, in order to compile code. The only dependency (as such) is Node.js—many developers will likely already have this installed.</li><li class="listitem" style="list-style-type: disc">There is no need to learn any new languages; every developer will be familiar with JavaScript, and use it in their development process.</li><li class="listitem" style="list-style-type: disc">We can change any plugin in use for something else when needed; we do not get this choice when using a larger library.</li><li class="listitem" style="list-style-type: disc">Its relatively low barrier of entry means we can create any plugins we need very easily, or potentially modify existing ones to better suit our needs.</li><li class="listitem" style="list-style-type: disc">PostCSS is quick—in a test <a id="id6" class="indexterm"/>using the <code class="literal">postcss-benchmark</code> plugin (available from <a class="ulink" href="https://github.com/postcss/benchmark">https://github.com/postcss/benchmark</a>), which contained parsed code, nested rules, mixins, variables, and math, PostCSS came out a clear winner:<div><img src="img/BO5194_01_01.jpg" alt="Exploring the benefits of using PostCSS"/></div></li><li class="listitem" style="list-style-type: disc">Perfect—no need to continually update SASS, or have to download a new version of the <a id="id7" class="indexterm"/><code class="literal">libsass</code> library, right?</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Considering some of the pitfalls</h2></div></div></div><p>Well, there are some <a id="id8" class="indexterm"/>considerations to using a custom processor; the key thing to remember is that PostCSS is neither a pre- nor post-processor, but more of a Swiss Army Knife of a toolbox that we can use to process our CSS code. Let's take a look at some of these drawbacks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Although we don't need to learn a new language in order to use PostCSS, creating a custom processor will add a layer of complexity to our development process.</li><li class="listitem" style="list-style-type: disc">Its flexible approach means some may treat PostCSS as either a preprocessor or a postprocessor; this short-sighted approach means that you will miss opportunities, so it is crucial to keep an open mind in terms of what PostCSS can offer your development process.</li><li class="listitem" style="list-style-type: disc">Converting code from an existing preprocessor to using PostCSS can be painful; this process only works if we don't try to convert explicitly, but use it as a basis for progressively moving to using PostCSS.</li><li class="listitem" style="list-style-type: disc">PostCSS requires syntactically correct CSS from the start; although we could use any syntax (as PostCSS files are just plain text), compilation can easily fail, even through use of a single line comment!</li><li class="listitem" style="list-style-type: disc">The real benefit of using PostCSS, though, is in its seamless integration into tools such as Gulp—imagine this scenario if you will:</li></ul></div><p>You already develop sites using a preprocessor such as SASS. You can compile code using a standalone processor, but normally prefer to use Node.js and Gulp to complete the task. Sound about right? What about making the move to using PostCSS?</p><p>No problem, we can include a section for processing CSS files using PostCSS. The key here is to not use PostCSS to perform the initial compilation, but to perform the post-processing, such as adding vendor prefixes or minifying the results. Once this is established, we can start to incorporate some of the plugins available for PostCSS that allow us to replicate functionality, such as from within SASS. Once we've adjusted existing code to use the format required by the plugins, we can then switch to using PostCSS, and begin to remove our dependency on using SASS.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Clearing up some misconceptions</h2></div></div></div><p>At this point, it is worth <a id="id9" class="indexterm"/>spending a few minutes to help clear up some common misconceptions about PostCSS, although many associate it as being a preprocessor, or even a postprocessor, this isn't what was intended:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Classing PostCSS as a postprocessor, as opposed to a preprocessor (such as Less or SASS) is misguided; PostCSS is capable of compiling in a variety of different use-case scenarios, working on code compiled using any preprocessor, or just plain CSS.</li><li class="listitem" style="list-style-type: disc">PostCSS should not be classed as a tool that should be tied in to any one process (such as writing SASS-based loops or conditionals). There are plugins available to do both, but this is just a small part of the role that PostCSS can play in your development workflow.</li><li class="listitem" style="list-style-type: disc">If you find yourself in a position where "PostCSS" doesn't appear to perform as expected, it is unlikely to be PostCSS itself, but more likely to be a plugin being used that is causing the issue. Although PostCSS is still relatively young, there are plenty of plugins available, so it is worth trying alternatives if you can as a first port of call.</li></ul></div><p>Okay, let's move on, I think it's <a id="id10" class="indexterm"/>time for less chat and more action, right? Let's get stuck in to producing something; there's no better time than now to get PostCSS installed and ready for use.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Preparing for exercises in this book</h2></div></div></div><p>Before we do so, we just need to cover a couple of requirements. First, we need to set up a local web server. It's not <a id="id11" class="indexterm"/>critical, but gives a better effect. I personally use WAMP Server (for PC, from <a class="ulink" href="http://www.wampserver.com/en">http://www.wampserver.com/en</a>), otherwise, Mac users can try <a id="id12" class="indexterm"/>MAMP (<a class="ulink" href="http://www.mamp.info/en">http://www.mamp.info/en</a>), or the <a id="id13" class="indexterm"/>cross-platform Apache web server (from <a class="ulink" href="http://www.apachefriends.org">http://www.apachefriends.org</a>). In each case, default settings should be sufficient.</p><p>The second requirement is to set up a project area; assuming you have set up a WAMP as a local web server, go ahead and set up a folder called <code class="literal">postcss</code> in <code class="literal">c:\wamp\www</code>, as shown in this screenshot:</p><div><img src="img/BO5194_01_02.jpg" alt="Preparing for exercises in this book"/></div><p>Right, with that out of the way, let's make a start on getting PostCSS installed!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up a development environment</h1></div></div></div><p>The first step on our <a id="id14" class="indexterm"/>journey is to get PostCSS installed—this runs from Node.js; we can use any one of several task runner plugins to install it. For the purpose of the exercises throughout this book, we will use Gulp; if you prefer, alternatives such as Grunt or Broccoli can be used.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>When using Node.js, make sure you use the Node.js command prompt, and not <code class="literal">node.exe</code>; the exercises will not work when using the latter!</p></div></div><p>Let's make a start with installing Node and Gulp:</p><div><ol class="orderedlist arabic"><li class="listitem">We first need to install <a id="id15" class="indexterm"/>Node.js; this is available at <a class="ulink" href="http://nodejs.org">http://nodejs.org</a>. Make sure you select the right version that is appropriate for your platform:<div><img src="img/BO5194_01_03.jpg" alt="Setting up a development environment"/></div><p>When installing, accept all defaults; this will be sufficient for the exercises throughout this book.</p></li><li class="listitem">Next, bring up a <a id="id16" class="indexterm"/>Node.js command prompt, enter the following command, and press <em>Enter</em>:<div><pre class="programlisting"><strong>node –v</strong>
</pre></div><p>The output shown is the version of Node that is installed; this is a quick check to ensure Node.js has indeed been installed correctly:</p><div><img src="img/BO5194_01_04.jpg" alt="Setting up a development environment"/></div></li><li class="listitem">Now that Node is installed, we need to create a <code class="literal">package.json</code> file to store our dependencies for projects. Run this command at the command prompt, and press <em>Enter</em>:<div><pre class="programlisting"><strong>npm init</strong>
</pre></div></li><li class="listitem">Node will prompt for information when creating the <code class="literal">package.json</code> file; enter the details as <a id="id17" class="indexterm"/>shown in the screenshot, or press <em>Enter</em> to accept the given default (shown in brackets, after each question):<div><img src="img/BO5194_01_05.jpg" alt="Setting up a development environment"/></div></li></ol></div><p>We now have Node configured and an empty <code class="literal">package.json</code> file in place, so let's add our dependencies. We will start by adding Gulp first:</p><div><ol class="orderedlist arabic"><li class="listitem">Revert back to the Node.js command prompt (or bring up a new one if you closed off the previous session).</li><li class="listitem">Go ahead and change the working directory to <code class="literal">c:\wamp\www\postcss</code>.</li><li class="listitem">At the command prompt, enter the following command, then press <em>Enter</em>. This installs Gulp globally and makes it available for use:<div><pre class="programlisting"><strong>npm install --global gulp</strong>
</pre></div></li><li class="listitem">Once done, we need to <a id="id18" class="indexterm"/>install Gulp for use in our project area—go ahead and run this command, which will add an entry to the<code class="literal"> package.json</code> file we created earlier in step <em>3</em> and step <em>4</em>:<div><pre class="programlisting"><strong>npm install --save-dev gulp</strong>
</pre></div></li></ol></div><p>Once completed, Gulp is now ready for use; we can go ahead and install PostCSS.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>A small point on the use of <code class="literal">--save-dev</code>: this installs any dependencies required to develop using a specific plugin; if we simply need the dependencies for <em>running</em> the plugin (in a production environment), then we can simply use <code class="literal">--save</code> instead.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Installing PostCSS</h2></div></div></div><p>We're at the interesting <a id="id19" class="indexterm"/>stage now—installing PostCSS. PostCSS is available from <a class="ulink" href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a>, and can be installed into Node using a Gulp plugin. Let's do that now:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by reverting back to the Node.js command prompt session we've just used (or a new one, if the previous one is closed).</li><li class="listitem">At the prompt, go ahead and enter this command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install --save-dev gulp-postcss</strong>
</pre></div><p>If all is well, we should see something akin to this screenshot:</p><div><img src="img/BO5194_01_06.jpg" alt="Installing PostCSS"/></div></li></ol></div><p>On its own, PostCSS doesn't do anything; to make it more useful, we are going to install three plugins. We will explore using plugins in greater detail later in the book, but for now, don't worry too much about what is happening:</p><div><ol class="orderedlist arabic"><li class="listitem">Enter these commands <a id="id20" class="indexterm"/>one by one on the Node.js command prompt, pressing <em>Enter</em> after each one:<div><pre class="programlisting"><strong>npm install --save-dev autoprefixer</strong>
</pre></div></li><li class="listitem">Let's check our <code class="literal">package.json</code> file; if all is well, we should see something akin to this screenshot:<div><img src="img/BO5194_01_07.jpg" alt="Installing PostCSS"/></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>To make it easier to view JSON files in Sublime Text, try installing and activating a custom theme, such as MonokaiJSON Plus, available to install from <a class="ulink" href="https://github.com/ColibriApps/MonokaiJsonPlus">https://github.com/ColibriApps/MonokaiJsonPlus</a>.</p></div></div></li></ol></div><p>PostCSS is now installed for use, but if we try to use it, we probably won't get very far, as it needs to be configured for use! Let's take a look at doing that now, by creating a simple example that will add vendor <a id="id21" class="indexterm"/>prefixes to some sample CSS rules, and automatically minify the results.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Creating a simple example using PostCSS</h1></div></div></div><p>PostCSS is a <a id="id22" class="indexterm"/>fascinating tool; its modular architecture leaves it wide open to being used in a variety of different use-case scenarios, or even a mix <a id="id23" class="indexterm"/>of several! Throughout this book, we'll touch on different uses, before bringing them all together to create a processor that can both pre- and post-process files within the same workflow.</p><p>To give you a taste of how well it works, we're going to build a simple processor now; this will automatically add vendor prefixes and spit out minified versions during compilation.</p><p>Let's make a start, we've installed the relevant plugins, so let's go create our Gulp task file:</p><div><ol class="orderedlist arabic"><li class="listitem">In a new file, add the following code, saving it as <code class="literal">gulpfile.js</code> at the root of our project area:<div><img src="img/BO5194_01_08.jpg" alt="Creating a simple example using PostCSS"/></div></li><li class="listitem">In the project area, create a folder called <code class="literal">dest</code>; other folders will be created, but these will be done automatically during compilation.</li><li class="listitem">In a new file, add the following code, saving it as <code class="literal">example.css</code> in the <code class="literal">src</code> folder of our project area:<div><pre class="programlisting">body {
  display: flex;
  background: green;
}</pre></div></li><li class="listitem">Revert back to the Node.js command prompt, then at the command prompt, enter the following command and press <em>Enter</em>:<div><pre class="programlisting"><strong>gulp styles</strong>
</pre></div><p>Gulp <a id="id24" class="indexterm"/>will now process the <a id="id25" class="indexterm"/>instructions in <code class="literal">gulpfile.js</code>:</p><div><img src="img/BO5194_01_09.jpg" alt="Creating a simple example using PostCSS"/></div></li><li class="listitem">Within a matter of seconds (almost instantaneously), we should see a compiled <code class="literal">example.css</code> appear in the<code class="literal"> dest</code> folder of our project area.</li><li class="listitem">We can prove PostCSS has done its job properly; go ahead and open up <code class="literal">example.css</code> in a text editor: if all is well, we should see this:<div><img src="img/BO5194_01_11.jpg" alt="Creating a simple example using PostCSS"/></div></li></ol></div><p>Perfect, we now have a working PostCSS installation; any time we need to add vendor prefixes, we can <a id="id26" class="indexterm"/>just fire up our compilation <a id="id27" class="indexterm"/>process, and away we go…</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Adding source map support</h2></div></div></div><p>Or do we? Ah, there is <a id="id28" class="indexterm"/>much more to PostCSS than simply adding vendor prefixes! Remember how I mentioned that PostCSS is often (incorrectly) labelled as a pre- or post-processor?</p><p>Well, there is much more we can do; one of the key benefits of PostCSS is being selective about how we process our code. We're not forced to rely on dependencies (such as Ruby for SASS); we can instead produce something that is very light and quick. In our previous example, we created a task called <code class="literal">styles</code>; we'll change this to use the task name <code class="literal">default</code>, which will allow us to run multiple tasks from one command. This means we can simply call <code class="literal">gulp</code>, instead of needing to supply the task name.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>All of our examples from this point onwards will use this convention by default.</p></div></div><p>Let's put this to the test and start to expand on our compilation process by adding source map support—we'll use the <a id="id29" class="indexterm"/>source map plugin for Gulp by Florian Reiterer, available from <a class="ulink" href="https://github.com/floridoo/gulp-sourcemaps">https://github.com/floridoo/gulp-sourcemaps</a>:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start, as always, by installing the plugin using Node—fire up a Node.js command prompt, then change to our project area.</li><li class="listitem">Next, enter this at the command line and press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install --save-dev gulp-sourcemaps</strong>
</pre></div></li><li class="listitem">Open up the <code class="literal">gulp</code> file we created back in the <em>Creating a simple example using PostCSS</em> section, then add a reference to <code class="literal">gulp-sourcemaps</code> as a variable:<div><pre class="programlisting">var autoprefixer = require('autoprefixer');
<strong>var sourcemaps = require('gulp-sourcemaps');</strong>
</pre></div></li><li class="listitem">We then need to add the commands to create the source maps—in the same file, alter the code as shown:<div><pre class="programlisting">.pipe(postcss([ autoprefixer ]))
<strong>.pipe(sourcemaps.init())</strong>
<strong>.pipe(sourcemaps.write('maps/'))</strong>
.pipe(gulp.dest('dest/'));</pre></div></li><li class="listitem">Save the results, then <a id="id30" class="indexterm"/>from the Node.js command prompt, run this command, and press <em>Enter</em>:<div><pre class="programlisting"><strong>gulp styles</strong>
</pre></div></li><li class="listitem">If all is well, we should see a new source map appear in the <code class="literal">dest</code> folder, under a subfolder called <code class="literal">maps</code>.<p>We're a step further in the right direction; we now have a map file for our style sheet in the maps folder, created automatically during the compilation process.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>It's worth noting that we will make full use of this area—if you see any reference to <code class="literal">project area</code> throughout the book, this will be our given name for this folder.</p></div></div><p>But, we can do more: although we only have a small CSS file here, it's still important to compress it to save on unnecessary bandwidth usage. We can easily fix that using PostCSS—let's take a look at how, using the <code class="literal">cssnano</code> plugin.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Creating minified style sheets</h2></div></div></div><p>A key <a id="id31" class="indexterm"/>part of producing style sheets is minifying the output; this should feature as standard in any developer's workflow. Minifying the results will cut down on bandwidth usage. In an age of broadband or cable use, this is less critical for smaller sites, but should not attract any less importance than for larger sites!</p><p>Thankfully, minifying files is a cinch to achieve when working with PostCSS. For this next exercise, we will use the <a id="id32" class="indexterm"/>
<code class="literal">cssnano</code> and <code class="literal">gulp-rename</code> plugins, available from <a class="ulink" href="http://cssnano.co/">http://cssnano.co/</a> and <a class="ulink" href="https://github.com/hparra/gulp-rename">https://github.com/hparra/gulp-rename</a>, respectively. Let's go ahead and get them <a id="id33" class="indexterm"/>installed:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by firing up a Node.js command prompt, then entering the following and pressing <em>Enter</em>:<div><pre class="programlisting"><strong>npm install -–save-dev cssnano</strong>
<strong>npm install -–save-dev gulp-rename</strong>
</pre></div><p>Don't close the session window, we will use it later in this exercise.</p></li><li class="listitem">Switch to the <code class="literal">gulpfile.js</code> file we created earlier (it's stored at the root of our project folder), then add the following lines immediately after the last closing <code class="literal">})</code> on or around line 12:<div><pre class="programlisting">gulp.task('rename', ['styles'], function () {
  return gulp.src('dest/example.css')
   .pipe(postcss([ cssnano ]))
   .pipe(rename('example.min.css'))
    .pipe(gulp.dest("dest/"));
});

gulp.task('default', ['styles', 'rename']);</pre></div></li><li class="listitem">At the top of the file, we need to add two declarations, otherwise our code will fail; go ahead and add the following two lines, as highlighted:<div><pre class="programlisting">var sourcemaps = require('gulp-sourcemaps');
<strong>var rename = require('gulp-rename');</strong>
<strong>var cssnano = require('cssnano');</strong>
</pre></div></li><li class="listitem">Any sharp-eyed readers may now spot a problem—in the last line, we have a reference to <code class="literal">styles</code>, yet nothing is shown in the code for this! To fix it, we need to change our code. In line 8, change the line as shown:<div><pre class="programlisting">gulp.task('<strong>styles</strong>', function() {</pre></div></li><li class="listitem">Save the file, then switch back to the Node.js command prompt window and enter this command, followed by <em>Enter</em>:<div><pre class="programlisting"><strong>gulp</strong>
</pre></div></li><li class="listitem">Gulp will now compile:<div><img src="img/BO5194_01_12.jpg" alt="Creating minified style sheets"/></div><p>If all is <a id="id34" class="indexterm"/>well, we should see the compiled output appear in the <code class="literal">dest</code> folder of our project area:</p><div><img src="img/BO5194_01_13.jpg" alt="Creating minified style sheets"/></div></li></ol></div><p>In our project area, we not only have the source map file created under maps, but now also have a minified style sheet, the latter created by renaming the output from <code class="literal">cssnano </code>(<code class="literal">cssnano</code> does not do this renaming natively, hence use of the <code class="literal">rename</code> plugin).</p><p>Unfortunately though, we still have one small issue—take a look at the contents of the <code class="literal">maps</code> folder: notice anything? Hopefully, you may spot that the source map file is there for the uncompressed version of our style sheet, but not the compressed one! Let's fix that now. To do so, we just need to use the <code class="literal">rename</code> task in our Gulp file, as shown:</p><div><pre class="programlisting">    .pipe(rename('example.min.css'))
    <strong>.pipe(sourcemaps.init())</strong>
    <strong>.pipe(sourcemaps.write('maps/'))</strong>
    .pipe(gulp.dest("dest/"));</pre></div><p>Try running Gulp now. If all is well we should see the source map appear for our minified style sheet:</p><div><img src="img/BO5194_01_14.jpg" alt="Creating minified style sheets"/></div><p>Let's finish off our <code class="literal">gulp</code> file; the last stage is to add a <code class="literal">watch</code> facility, so that changes are compiled <a id="id35" class="indexterm"/>automatically as soon as files are modified.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Altering to compile automatically</h2></div></div></div><p>Adding a <a id="id36" class="indexterm"/>
<code class="literal">watch</code> facility is simple when using Gulp. It helps reduce the manual effort required when using Gulp, as we only need to fire off the Gulp task file once, and it will continue to apply the tasks each time files are changed.</p><p>Unlike other plugins, we don't need to install any plugins for this; simply add the highlighted lines from the following to the <code class="literal">gulpfile.js </code>file:</p><div><pre class="programlisting">gulp.task('default', ['styles', 'rename', 'sourcemaps']);

<strong>var watcher = gulp.watch('src/*.css', ['default']);</strong>
<strong>watcher.on('change', function(event) {</strong>
  <strong>console.log('File ' + event.path + ' was ' + event.type + ', </strong>    <strong>running tasks...');</strong>
<strong>});</strong>
</pre></div><p>We can see the results of the addition to our gulp task file, and how it all comes together, in this screenshot:</p><div><img src="img/BO5194_01_15.jpg" alt="Altering to compile automatically"/></div><p>At this point, we can save the file then re-run the <code class="literal">gulp</code> command as before; this time it will automatically recompile any file that has changed, from within the <code class="literal">src</code> folder. In this instance, we've added an event handler to log an indication into the session so we can tell what is happening; we can easily modify this if needed.</p><p>We now have a <a id="id37" class="indexterm"/>basic working system; we will begin to add to this over the next few chapters, toward building up our own processor. There is one small thing we should cover though: it's not essential, but a useful tip for developing with PostCSS. I'm talking about linting your code, to ensure it is valid; let's dive in and get this set up for use.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Linting code using plugins</h1></div></div></div><p>It goes without <a id="id38" class="indexterm"/>saying that linting code should be part of any developer's workflow. There are lots of different ways to achieve this, depending on the tools you use. The beauty <a id="id39" class="indexterm"/>of PostCSS is that we can easily add a suitable linting capability to our processor, using the <code class="literal">stylelint</code> plugin for PostCSS (available from <a class="ulink" href="http://stylelint.io/">http://stylelint.io/</a>).</p><p>Why would we do this? Easy: we can get a single consistent result throughout. This becomes essential if you work as part of a team; instead as different team members using inconsistent settings, we can set up a central point for processing, to retain a consistent output. Moving the linting process to our central workflow means the server can do the grunt work for us, and provide a consistent result anytime for anyone running the process.</p><p>With this in mind, let's take a look at how we can set up our linting capability:</p><div><ol class="orderedlist arabic"><li class="listitem">We start as always by installing our plugin. For this, fire up a Node.js command prompt, then change to the root of our project area.</li><li class="listitem">At the command prompt, enter this command, followed by <em>Enter</em>:<div><pre class="programlisting"><strong>npm install stylelint</strong>
</pre></div><p>If all is well, we should see this appear at the prompt:</p><div><img src="img/BO5194_01_16.jpg" alt="Linting code using plugins"/></div></li><li class="listitem">Next up, we need to install a second plugin—there is a reporter function within <code class="literal">stylelint</code> that posts any messages to console (or in this case, screen). The plugin is <code class="literal">postcss-reporter</code>, and is available at <a class="ulink" href="https://github.com/postcss/postcss-reporter">https://github.com/postcss/postcss-reporter</a>. We can install it thus:<div><img src="img/BO5194_01_17.jpg" alt="Linting code using plugins"/></div></li><li class="listitem">With the plugins <a id="id40" class="indexterm"/>installed, we need to update our <code class="literal">gulp</code> file; add <a id="id41" class="indexterm"/>the following lines immediately below the last <code class="literal">var</code> line shown:<div><pre class="programlisting">var cssnano = require('cssnano');
<strong>var stylelint = require('stylelint');</strong>
<strong>var reporter = require('postcss-reporter');</strong>
</pre></div></li><li class="listitem">Immediately, below the rename task in the Gulp file, add this task—this takes care of linting our code, and flagging any errors on-screen:<div><pre class="programlisting">gulp.task("lint-styles", function() {
  return gulp.src("src/*.css")
    .pipe(postcss([ stylelint({ 
      "rules": {
        "color-no-invalid-hex": 2,
        "declaration-colon-space-before": [2, "never"],
        "indentation": [2, 2],
        "number-leading-zero": [2, "always"]
      }
    }),
    reporter({
      clearMessages: true,
    })
  ]))
});</pre></div></li><li class="listitem">Open a copy of <code class="literal">example.css</code> from the root area of our project folder and change the <code class="literal">color</code> to <code class="literal">#fff1az</code>.</li><li class="listitem">Back in the Node.js command prompt, enter this command and press <em>Enter</em>:<div><pre class="programlisting"><strong>gulp</strong>
</pre></div></li><li class="listitem">Gulp will begin to <a id="id42" class="indexterm"/>process our code; if all is well, it <a id="id43" class="indexterm"/>should flag a warning:<div><img src="img/BO5194_01_18.jpg" alt="Linting code using plugins"/></div></li></ol></div><p>It shouldn't take much effort to spot that <code class="literal">#fff1az</code> is clearly not a valid number! Stylelint has correctly identified it, using the highlighted rule from our configuration:</p><div><pre class="programlisting">    .pipe(postcss([ stylelint({ 
        "rules": {
          <strong>"color-no-invalid-hex": true,</strong>
          …
        }
      }),</pre></div><p>Let's explore how this plugin works for a moment—the great thing about it is that there are simply dozens of rules available (which you can see at <a class="ulink" href="https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md">https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md</a>). It works by concatenating together what is being checked (in this case, <code class="literal">color</code>) and the check being run against it (in our case, <strong>-no-invalid-hex</strong>, or checking for invalid hex numbers). We can apply any number of rules in our configuration object, to ensure that the output is consistent for all projects.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>If you would like to get a feel for how the rules can be put together, then check out the user guide at <a class="ulink" href="https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/user-guide.md">https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/user-guide.md</a>, with more examples of rules available at <a class="ulink" href="https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md">https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md</a>.</p></div></div><p>Okay, let's move on: we will <a id="id44" class="indexterm"/>begin to look at compiling code in more detail <a id="id45" class="indexterm"/>from the next chapter, but for now, let's take a look at how PostCSS works in more detail, and how we can begin to make the move from our existing processor to PostCSS.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Exploring how PostCSS works</h1></div></div></div><p>So far, we've covered the <a id="id46" class="indexterm"/>basics of setting up and using PostCSS. It's worth taking a moment to learn about how it works, to better understand how we can use it and develop our own plugins for the platform.</p><p>PostCSS is like me on a Saturday morning after a good night out: it does nothing! Yes, it's true, by itself, the application doesn't do anything at all; it's when we add plugins into the mix that it starts to become useful.</p><p>The key to PostCSS is treating it as an enabler, it is not meant as a direct replacement for your existing preprocessor, or even postprocessor, but to complement them. It works on the basis of parsing code, processing it with any assigned plugins, and rendering the results:</p><div><img src="img/BO5194_01_19.jpg" alt="Exploring how PostCSS works"/></div><p>It works by parsing content into an <a id="id47" class="indexterm"/>
<strong>Abstract Syntax Tree</strong> (or AST) with a series of nodes. Each node in the tree contains a symbolic representation of an element in <a id="id48" class="indexterm"/>your code. In other words, if you had a condition statement that pointed to three possible outcomes, then the AST would have a single node, with three branches representing the possible outcomes.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>For an example of <a id="id49" class="indexterm"/>an AST, take a look at <a class="ulink" href="http://jointjs.com/demos/javascript-ast">http://jointjs.com/demos/javascript-ast</a>, which shows the breakdown of a simple arithmetic function using plain JavaScript.</p></div></div><p>Our AST is then sent through one or more plugins (we must always use one plugin, but can have many in our <code class="literal">gulp</code> file). It then converts the code to a long string, before processing it through any assigned plugins and spitting out the result in the form of valid CSS. We can use this as a basis for creating our own plugins, using the boilerplate code and API that are both available from the main PostCSS site on GitHub.</p><p>The trick to the plugin stage is in the mix of plugins we must use to satisfy our needs; the better ones should only perform one role. Any that perform multiple tasks are less ideal, as they are likely to contain excess functionality that we don't need in our projects.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Making the move from SASS</h2></div></div></div><p>Assuming we decided to use <a id="id50" class="indexterm"/>PostCSS, there is almost always one question at the top of everyone's mind: how do we make the move?</p><p>In short, the key here is <em>not</em> to simply assume existing code can be put through the PostCSS process, as it will likely not work. Instead, we should take an iterative process, and begin to convert low-hanging fruit to using PostCSS. The process will of course require some work, but there are tips on how we can reduce the pain involved in making the switch to PostCSS.</p><p>The key to making the transfer is to work out what functionality needs to be processed, then to create the initial framework for a build process (for example, a Gulp or Grunt task file), then to gradually add in plugin support one by one, until you have a fully working compiler.</p><p>We can take this a step further, and use plugins that replicate SASS code format into PostCSS; an ideal plugin to start with is Autoprefixer, followed by plugins such as <code class="literal">postcss-mixins</code> or <code class="literal">postcss-partial-import</code>. We will explore using SASS as a basis for a custom syntax in <a class="link" href="ch11.html" title="Chapter 11. Manipulating Custom Syntaxes">Chapter 11</a>, <em>Manipulating Custom Syntaxes</em>, where we will use these two plugins, and more, to help make the transition process easier and help remove the dependencies on preprocessors such as SASS or Less. Oh, and above all, being based on JavaScript makes it portable; what more could a developer ask for, I wonder?</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Many of the SASS format plugins for PostCSS now come in the <code class="literal">PreCSS</code> pack. We will explore using this in <a class="link" href="ch10.html" title="Chapter 10. Building a Custom Processor">Chapter 10</a>, <em>Building a Custom Preprocessor</em>.</p></div></div><p>Okay, on we go. Over the course of the next few chapters, we will take a look at different processor elements that are commonly used to create build processors, such as variables or mixins. We'll see how they might typically be written in processors such as SASS or Less, then work on converting our code to use PostCSS equivalents before processing to produce valid CSS. We will then finish up with pulling everything together to build your own custom processor for use in future projects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>Writing valid CSS is an art that has been present since the dawn of the Internet; this takes skill, patience, and time to produce and perfect any masterpiece. Processors such as SASS or Less have helped to make the process more efficient, but are not without their drawbacks; PostCSS allows for a more customized approach, but without the extra baggage. We've covered a few key points around PostCSS throughout this chapter, so let's take a moment to review what we've learned.</p><p>We began with a brief look at the art of processing, before introducing PostCSS as a tool. We then explored some of the benefits and drawbacks of using it, and how it can fit in seamlessly with your existing development workflow, with a little careful planning.</p><p>Next up, we covered the installation of PostCSS along with Gulp as the task runner/host process, before embarking on a simple demo to introduce how the compilation process works, and that with the right choice of plugins, we can take out some of the manual grunt work required to manage our code (pun intended!). With our code compiling, we then turned our attention to adding a watch facility, and automatic support for linting our code, to ensure we maintain consistent standards.</p><p>We then rounded out the chapter with a look at how PostCSS works, and understanding something of its architecture, so that we can begin to make the move from using plain CSS or an existing preprocessor, to using PostCSS.</p><p>Phew, we've certainly covered a lot; it's time to really get stuck in now, and start to use PostCSS in earnest. Over the next few chapters, we will explore a number of different concepts that are common to existing preprocessors, and explore how we can benefit from making the transition to using PostCSS. We have to start somewhere, so we'll kick off with using variables, functions, and mixins in the next chapter, and see how we can use some of the techniques from processors, but without the associated baggage!</p></div></body></html>