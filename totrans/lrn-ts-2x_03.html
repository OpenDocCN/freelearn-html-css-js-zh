<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Functions</h1>
                </header>
            
            <article>
                
<p class="mce-root"/>
<p>In <a href="25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml">Chapter 1</a>, <em>Introducing TypeScript</em>, we learned the basics of functions. Functions are the fundamental building blocks of any application in TypeScript, and they are powerful enough to deserve the dedication of an entire chapter to explore their potential.</p>
<p>In this chapter, we are going to learn how to work with functions in depth. The chapter is divided into two main sections. The first section starts with a quick recap of some basic concepts, and then moves on to some less commonly known <span>features of</span><span> </span><span>functions and their use cases. The first section covers the following concepts:</span></p>
<ul>
<li>Function declarations and function expressions</li>
<li>Function types</li>
<li>Functions with optional parameters</li>
<li>Functions with default parameters</li>
<li>Functions with REST parameters</li>
<li>Function overloading</li>
<li>Specialized overloading signatures</li>
<li>Function scope</li>
<li>Immediately invoked functions</li>
<li>Tag functions and tagged templates</li>
</ul>
<p>The second section focuses on TypeScript's asynchronous programming capabilities and includes the following concepts:</p>
<ul>
<li>Callbacks and higher-order functions</li>
<li>Arrow functions</li>
<li>Callback hell</li>
<li>Promises</li>
<li>Generators</li>
<li>Asynchronous functions (<kbd>async</kbd> and <kbd>await</kbd>)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with functions in TypeScript</h1>
                </header>
            
            <article>
                
<p>This section focuses on the declaration and use of functions, parameters, and arguments.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function declarations and function expressions</h1>
                </header>
            
            <article>
                
<p>In the first chapter, we introduced the possibility of declaring functions with (named functions) or without (unnamed or anonymous functions) explicitly indicating their name, but we didn't mention that we were also using two different types of functions.</p>
<p>In the following example, the named function <kbd>greetNamed</kbd> is a <strong>function declaration</strong>, while <kbd>greetUnnamed</kbd> is a <strong>function expression</strong>. F<span>or now, pl</span><span>ease ignore the first two lines, which contain two</span> <kbd>console.log</kbd> <span>statements:</span></p>
<pre>console.log(greetNamed("John")); // OK 
console.log(greetUnnamed("John")); // Error 
 
function greetNamed(name: string): string { 
    return `Hi! ${name}`; 
} 
 
let greetUnnamed = function(name: string): string { 
    return `Hi! ${name}`; 
}; </pre>
<p>We might think that the preceding functions are identical, but they behave differently. The JavaScript interpreter can evaluate a function declaration as it is being parsed. On the other hand, the function expression is part of an assignment and will not be evaluated until the assignment has been completed.</p>
<div class="packt_infobox">The main cause of the different behavior of these functions is a process known as <strong>variable hoisting</strong>. We will learn more about the variable hoisting process later in this chapter.</div>
<p>If we compile the preceding TypeScript code snippet into JavaScript and try to execute it in a web browser, we will observe that the first <kbd>console.log</kbd> call works. This is because JavaScript knows about the declaration function and can parse it before the program is executed.</p>
<p>However, the second alert statement will throw an exception, which indicates that <kbd>greetUnnamed</kbd> is not a function. The exception is thrown because the <kbd>greetUnnamed</kbd> assignment must be completed before the function can be evaluated.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function types</h1>
                </header>
            
            <article>
                
<p>We already know that it is possible to explicitly declare the type of an element in our application by using optional type annotations:</p>
<pre>function greetNamed(name: string): string { 
    return `Hi! ${name}`; 
} </pre>
<p>In the preceding function, we have specified the type of the parameter name (string) and its return type (string). Sometimes, we will need to not just specify the types of the function elements, but the function itself. Let's look at an example:</p>
<pre>let greetUnnamed: (name: string) =&gt; string; 
 
greetUnnamed = function(name: string): string { 
    return `Hi! ${name}`; 
}; </pre>
<p>In the preceding example, we have declared the <kbd>greetUnnamed</kbd> <span>variable</span><span> </span><span>and its type. The</span> <kbd>greetUnnamed </kbd><span>type</span><span> </span><span>is a function type that takes a string variable called</span> <kbd>name</kbd> <span>as its only parameter and returns a string after being invoked. After declaring the variable, a function, whose type must be equal to the variable type, is assigned to it.</span></p>
<p>We can also declare the <kbd>greetUnnamed</kbd> type and assign a function to it in the same line rather than declaring it in two separate lines as we did in the previous example:</p>
<pre>let greetUnnamed: (name: string) =&gt; string = function(name: string): string { 
    return `Hi! ${name}`; 
}; </pre>
<p>Just like in the previous example, the preceding code snippet also declares a variable, <kbd>greetUnnamed</kbd>, and its type. The <kbd>greetUnnamed </kbd><span>type</span><span> </span><span>is a function type that takes a string variable called</span> <kbd>name</kbd> <span>as its only parameter and will return a string after being invoked. We will assign a function to this variable in the same line in which it is declared. The type of the assigned function must match the type of the variable.</span></p>
<div class="packt_infobox">In the preceding example, we have declared the type of the <kbd>greetUnnamed</kbd> variable and then assigned a function as its value. The type of the function can be inferred from the assigned function, and for this reason, it is unnecessary to add a redundant type annotation. We have done this to help you understand this section, but it is important to mention that adding redundant type annotations can make our code harder to read, and it is considered bad practice.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trailing commas in function arguments</h1>
                </header>
            
            <article>
                
<p>Trailing commas are the commas that are used after the last argument of a function. Using a comma after the last parameter of a function can be useful because it is very common for programmers to forget to add a comma when they modify an existing function by adding additional parameters.</p>
<p>For example, the following function only takes one parameter and doesn't use trailing commas:</p>
<pre>function greetWithoutTralingCommas( 
    name: string 
): string { 
    return `Hi! ${name}`; 
} </pre>
<p>After some time, we might be required to add a parameter to the preceding function. A common mistake is to declare the new parameter and forget to add a comma after the first parameter:</p>
<pre>function updatedGreetWithoutTralingCommas( 
    name: string 
    surname: string, // Error 
): string { 
    return `Hi! ${name} ${surname}`; 
} </pre>
<p>Using a trailing comma in the first version of the function could have helped us to prevent this common mistake:</p>
<pre>function greetWithTralingCommas( 
    name: string, 
): string { 
    return `Hi! ${name}`; 
} </pre>
<p>Using a trailing comma eliminates the possibility of forgetting the comma when adding a new argument:</p>
<pre>function updatedGreetWithTralingCommas( 
    name: string, 
    surname: string, 
): string { 
    return `Hi! ${name} ${surname}`; 
} </pre>
<div class="packt_infobox">TypeScript will throw an error if we forget a comma, so trailing commas are not needed as much as they are when working with JavaScript. Trailing commas are optional, but using them is considered a good practice by many JavaScript and TypeScript engineers.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions with optional parameters</h1>
                </header>
            
            <article>
                
<p>Unlike JavaScript, the TypeScript compiler will throw an error if we attempt to invoke a function without providing the exact number and types of parameters that its signature declares. Let's look at a code sample to demonstrate this:</p>
<pre>function add(foo: number, bar: number, foobar: number): number { 
    return foo + bar + foobar; 
} </pre>
<p>The preceding function is called <kbd>add</kbd> and will take three numbers as parameters, named <kbd>foo</kbd>, <kbd>bar</kbd>, and <kbd>foobar</kbd>. If we attempt to invoke this function without providing exactly three numbers, we will get a compilation error indicating that the supplied parameters do not match the function's signature:</p>
<pre>add(); // Error, expected 3 arguments, but got 0. 
add(2, 2); // Error, expected 3 arguments, but got 2. 
add(2, 2, 2); // OK, returns 6 </pre>
<p>There are scenarios in which we might want to be able to call the function without providing all its arguments. TypeScript features optional parameters in functions to help us to increase the flexibility of our functions and overcome such scenarios.</p>
<p>We can indicate to the TypeScript compiler that we want a function's parameter to be optional by appending the <kbd>?</kbd> <span>character</span><span> </span><span>to its name. Let's update the previous function to transform the required</span> <kbd>foobar</kbd><span> </span><span>parameter</span><span> </span><span>into an optional parameter:</span></p>
<pre>function add(foo: number, bar: number, foobar?: number): number { 
    let result = foo + bar; 
    if (foobar !== undefined) { 
        result += foobar; 
    } 
    return result; 
} </pre>
<p>Note how we have changed the <kbd>foobar</kbd> parameter name to <kbd>foobar?</kbd>, and how we are checking the type of <kbd>foobar</kbd> inside the function to identify whether the parameter was supplied as an argument to the function or not. After implementing these changes, the TypeScript compiler will allow us to invoke the function without errors when we supply two or three arguments to it:</p>
<pre>add(); // Error, expected 2-3 arguments, but got 0. 
add(2, 2); // OK, returns 4 
add(2, 2, 2); // OK, returns 6 </pre>
<p>It is important to note that the optional parameters must always be located after the required parameters in the function's parameter list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions with default parameters</h1>
                </header>
            
            <article>
                
<p>When a function has some optional parameters, we must check whether an argument has been passed to the function (just like we did in the previous example) to prevent potential errors.</p>
<p>There are some scenarios where it would be more useful to provide a default value for a parameter when it is not supplied than making it an optional parameter. Let's rewrite the <kbd>add</kbd> function (from the previous section) using the inline <kbd>if</kbd> structure:</p>
<pre>function add(foo: number, bar: number, foobar?: number): number { 
    return foo + bar + (foobar !== undefined ? foobar : 0); 
} </pre>
<p>There is nothing wrong with the preceding function, but we can improve its readability by providing a default value for the <kbd>foobar</kbd> parameter instead of using an optional parameter:</p>
<pre>function add(foo: number, bar: number, foobar: number = 0): number { 
    return foo + bar + foobar; 
} </pre>
<p>To indicate that a function parameter is optional, we need to provide a default value using the <kbd>=</kbd> operator when declaring the function's signature. After compiling the preceding code examples, the TypeScript compiler will generate an <kbd>if</kbd> structure in the JavaScript output to set a default value for the <kbd>foobar</kbd> parameter if it is not passed as an argument to the function:</p>
<pre>function add(foo, bar, foobar) { 
    if (foobar === void 0) { foobar = 0; } 
    return foo + bar + foobar; 
} </pre>
<p>This is great because the TypeScript compiler generated the code necessary <span>for us</span><span> to prevent potential runtime errors.</span></p>
<div class="packt_infobox">The <kbd>void 0</kbd> parameter is used by the TypeScript compiler to check whether a variable is undefined. While most developers use the undefined variable to perform this kind of check, most compilers use <kbd>void 0</kbd> because it will always evaluate as undefined. Checking against an undefined variable is less secure because its value could have been modified, as demonstrated by the following code snippet:<br/>
<span><br/>
<kbd>function test() {</kbd><br/></span><kbd><span>    var undefined = 2; // 2</span></kbd><br/>
<kbd>    console.log(undefined === 2); // true</kbd><br/>
<span><kbd>}</kbd></span></div>
<p>Just like optional parameters, default parameters must always <span>be</span><span> </span><span>located after any required parameters in the function's parameter list.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions with REST parameters</h1>
                </header>
            
            <article>
                
<p>We have learned how to use optional and default parameters to increase the number of ways that we can invoke a function. Let's return one more time to the previous example:</p>
<pre>function add(foo: number, bar: number, foobar: number = 0): number { 
    return foo + bar + foobar; 
} </pre>
<p>We have learned how to invoke the <kbd>add</kbd> function with two or three parameters, but what if we wanted to allow other developers to pass four or five parameters to our function? We would have to add two extra default or optional parameters. And what if we wanted to allow them to pass as many parameters as they need? The solution to this possible scenario is the use of REST parameters. The REST parameter syntax allows us to represent an indefinite number of arguments as an array:</p>
<pre>function add(...foo: number[]): number { 
    let result = 0; 
    for (let i = 0; i &lt; foo.length; i++) { 
        result += foo[i]; 
    } 
    return result; 
} </pre>
<p>As we can see in the preceding code snippet, we have replaced the function parameters <kbd>foo</kbd>, <kbd>bar</kbd>, and <kbd>foobar</kbd> with just one parameter named <kbd>foo</kbd>. Note that the name of the parameter <kbd>foo</kbd> is preceded by an ellipsis (a set of three periods—not the actual ellipsis character). A <span><span>REST </span></span>parameter must be of an array type or we will get a compilation error. We can now invoke the <kbd>add</kbd> function with as many parameters as we need:</p>
<pre>add(); // 0 
add(2); // 2 
add(2, 2); // 4 
add(2, 2, 2); // 6 
add(2, 2, 2, 2); // 8 
add(2, 2, 2, 2, 2); // 10 
add(2, 2, 2, 2, 2, 2); // 12 </pre>
<p>Although there is no specific limit to the theoretical maximum number of arguments that a function can take, there are, of course, practical limits. These limits are entirely implementation-dependent and, most likely, will also depend on <span>exactly</span><span> </span><span>how we are calling the function.</span></p>
<p>JavaScript functions have a built-in object called the <kbd>arguments</kbd> object. This object is available as a local variable named <kbd>arguments</kbd>. The <kbd>arguments</kbd> variable contains an object like an array that contains the arguments used when the function was invoked.</p>
<div class="packt_infobox">The <kbd>arguments</kbd> object exposes some of the methods and properties provided by a standard array, but not all of them. Refer to the documentation at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments"><span class="URLPACKT">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments</span></a> to learn more about its peculiarities.</div>
<p>If we examine the JavaScript output, we will notice that TypeScript iterates the <kbd>arguments</kbd> object to add the values to the <kbd>foo</kbd> variable:</p>
<pre>function add() { 
    var foo = []; 
    for (var _i = 0; _i &lt; arguments.length; _i++) { 
        foo[_i - 0] = arguments[_i]; 
    } 
    var result = 0; 
    for (var i = 0; i &lt; foo.length; i++) { 
        result += foo[i]; 
    } 
    return result; 
} </pre>
<p>We can argue that this is an extra, unnecessary iteration over the function's parameters. Even though it is hard to imagine this extra iteration becoming a performance issue, if you think that this could be a problem for the performance of your application, you may want to consider avoiding the use of REST parameters and use an array as the only parameter of the function instead:</p>
<pre>function add(foo: number[]): number { 
    let result = 0; 
    for (let i = 0; i &lt; foo.length; i++) { 
        result += foo[i]; 
    } 
    return result; 
} </pre>
<p>The preceding function takes an array of numbers as its only parameter. The invocation API will be a little bit different from the REST parameters, but we will effectively avoid the extra iteration over the function's argument list:</p>
<pre>add(); // Error, expected 1 arguments, but got 0. 
add(2); // Error, '2' is not assignable to parameter of type 'number[]'. 
add(2, 2); // Error, expected 1 arguments, but got 2. 
add(2, 2, 2); // Error, expected 1 arguments, but got 3. 
 
add([]); // returns 0 
add([2]); // returns 2 
add([2, 2]); // returns 4 
add([2, 2, 2]); // returns 6 </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function overloading</h1>
                </header>
            
            <article>
                
<p>Function overloading, or method overloading, is the ability to create multiple methods with the same name and a different number of parameters or types. In TypeScript, we can overload a function by specifying all function signatures (known as the <strong>overload signatures</strong>) of a function, followed by a signature (known as the <strong>implementation signature</strong>). Let's look at an example:</p>
<pre>function test(name: string): string; // overloaded signature 
function test(age: number): string; // overloaded signature 
function test(single: boolean): string; // overloaded signature 
function test(value: (string|number|boolean)): string { // implementation signature 
    switch (typeof value) { 
        case "string": 
            return `My name is ${value}.`; 
        case "number": 
            return `I'm ${value} years old.`; 
        case "boolean": 
            return value ? "I'm single." : "I'm not single."; 
        default: 
            throw new Error("Invalid Operation!"); 
    } 
} </pre>
<p>As we can see in the preceding example, we have overloaded the function test three times by adding a signature that takes a string as its only parameter, another function that takes a number, and a final signature that takes a boolean as its unique parameter. It is important to note that all function signatures must be compatible; so if, for example, one of the signatures tries to return a number while another tries to return a string, we will get a compilation error:</p>
<pre>function test(name: string): string; 
function test(age: number): number; // Error 
function test(single: boolean): string; 
function test(value: (string|number|boolean)): string { 
    switch (typeof value) { 
        case "string": 
            return `My name is ${value}.`; 
        case "number": 
            return `I'm ${value} years old.`; 
        case "boolean": 
            return value ? "I'm single." : "I'm not single."; 
        default: 
            throw new Error("Invalid Operation!"); 
    } 
} </pre>
<p>The implementation signature must be compatible with all the overloaded signatures, always be the last in the list, and take the <kbd>any</kbd> type or a union type as the type of its parameters.</p>
<p>Invoking the function providing arguments that don't match any of the types that are declared by the overload signatures will lead us to a compilation error:</p>
<pre>test("Remo"); // returns "My name is Remo." 
test(26); // returns "I'm 26 years old."; 
test(false); // returns "I'm not single."; 
test({ custom: "custom" }); // Error </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Specialized overloading signature</h1>
                </header>
            
            <article>
                
<p>We can use a specialized signature to create multiple methods with the same name and number of parameters, but a different return type. To create a specialized signature, we must indicate the type of function parameter using a string. The string literal is used to identify which of the function overloads is invoked:</p>
<pre>interface Document { 
    createElement(tagName: "div"): HTMLDivElement; // specialized 
    createElement(tagName: "span"): HTMLSpanElement; // specialized 
    createElement(tagName: "canvas"): HTMLCanvasElement; // specialized 
    createElement(tagName: string): HTMLElement; // non-specialized 
} </pre>
<p>In the preceding example, we have declared three <strong>specialized overloaded signatures</strong> and one <strong>nonspecialized signature</strong> for the function named <kbd>createElement</kbd>.</p>
<p>When we declare a specialized signature in an object, it must be assignable to at least one nonspecialized signature in the same object. This can be observed in the preceding example, as the <kbd>createElement</kbd> property belongs to a type that contains three specialized signatures, all of which are assignable to the nonspecialized signature in the type.</p>
<p>When writing overloaded declarations, we must list the nonspecialized signature last.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function scope</h1>
                </header>
            
            <article>
                
<p>Low-level languages, such as C, have low-level memory management features. In programming languages with a higher level of abstraction, such as TypeScript, values are allocated when variables are created and automatically cleared from memory when they are not used anymore. The process that cleans the memory is known as <strong>garbage collection</strong> and is performed by the JavaScript runtime garbage collector.</p>
<p>The garbage collector does a great job, but it is a mistake to assume that it will always prevent us from facing a memory leak. The garbage collector will clear a variable from the memory whenever the variable is out of the scope. It is important to understand how the TypeScript scope works, so we will now look at the life cycle of the variables.</p>
<p>Some programming languages use the structure of the program source code to determine what variables we are referring to (<strong>lexical scoping</strong>), while others use the runtime state of the program stack to determine what variable we are referring to (<strong>dynamic scoping</strong>). The majority of modern programming languages use lexical scoping (including TypeScript). Lexical scoping tends to be dramatically easier to understand for both humans and analysis tools than dynamic scoping.</p>
<p>While in most lexical-scoped programming languages, variables are scoped to a block (a section of code delimited by curly braces <kbd>{}</kbd>), in TypeScript (and JavaScript), variables are scoped to a function, as demonstrated by the following code snippet:</p>
<pre>function foo(): void { 
    if (true) { 
        var bar: number = 0; 
    } 
    console.log(bar); 
} 
 
foo(); // 0 </pre>
<p>The preceding function named <kbd>foo</kbd> contains an <kbd>if</kbd> structure. We have declared a numeric variable named <kbd>bar</kbd> inside the <kbd>if</kbd> structure, and later, we have attempted to show the value of the <kbd>bar</kbd> <span>variable</span><span> </span><span>using the</span> <kbd>log</kbd> <span>function.</span></p>
<p>We might think that the preceding code sample would throw an error in the fifth line because the <kbd>var</kbd> variable should be out of the scope when the <kbd>log</kbd> function is invoked. However, if we invoke the <kbd>foo</kbd> function, the <kbd>log</kbd> function will be able to display the <kbd>bar</kbd> <span>variable</span><span> </span><span>without errors because all the variables inside a function will be in the scope of the entire function body, even if they are inside another block of code (except a function block).</span></p>
<p>This might seem confusing, but it is easy to understand once we know that at runtime, all the variable declarations are moved to the top of a function before the function is executed. This behavior is known as <strong>hoisting</strong>.</p>
<div class="packt_infobox">TypeScript is compiled to JavaScript and then executed—this means that a TypeScript application is a JavaScript application at runtime, and for this reason, when we refer to the TypeScript runtime, we are talking about the JavaScript runtime. We will learn in depth about the runtime in <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Understanding the Runtime</em>.</div>
<p>Before the preceding code snippet is executed, the runtime will move the declaration of the <kbd>bar </kbd><span>variable</span><span> </span><span>to the top of our function:</span></p>
<pre>function foo() { 
    var bar; 
    if (true) { 
        bar = 0; 
    } 
    console.log(bar); 
} 
 
foo(); // 0 </pre>
<p>This explains why it is possible to use a variable before it is declared. Let's look at an example:</p>
<pre>function foo(): void { 
    bar = 0; 
    var bar: number; 
    console.log(bar); 
} 
 
foo(); // 0 </pre>
<p>In the preceding code snippet, we have declared a <kbd>foo </kbd><span>function,</span><span> </span><span>and in its body, we have assigned the value</span> <kbd>0</kbd> <span>to a variable named <kbd>bar</kbd>. At this point, the variable has not been declared. In the second line, we are declaring the variable <kbd>bar</kbd> and its type. In the last line, we are displaying the value of <kbd>bar</kbd> using the</span> alert <span>function.</span></p>
<p>Because declaring a variable anywhere inside a function (except another function) is equivalent to declaring it at the top of the function, the <kbd>foo</kbd> function is transformed into the following at runtime:</p>
<pre>function foo(): void { 
    var bar: number; 
    bar = 0; 
    console.log(bar); 
} 
 
foo(); // 0 </pre>
<p>Because developers with a background in programming languages with block scope, such as Java or C#, are not used to the function scope, it is one of the most criticized characteristics of JavaScript. The people in charge of the development of the ECMAScript 6 specification are aware of this, and as a result, they have introduced the keywords <kbd>let</kbd> and <kbd>const</kbd>.</p>
<p>The <kbd>let</kbd> keyword allows us to set the scope of a variable to a block (<kbd>if</kbd>, <kbd>while</kbd>, <kbd>for</kbd>, and so on) rather than a function. We can update the first example in this section to showcase how <kbd>let</kbd> works:</p>
<pre>function foo(): void { 
    if (true) { 
        let bar: number = 0; 
        bar = 1; 
    } 
    console.log(bar); // Error 
} </pre>
<p>The <kbd>bar</kbd> variable is now declared using the <kbd>let</kbd> keyword, and as a result, it is only accessible inside the <kbd>if</kbd> block. The variable is not hoisted to the top of the <kbd>foo</kbd> function and cannot be accessed by the <kbd>alert</kbd> function outside the <kbd>if</kbd> statement.</p>
<p>While variables defined with <kbd>const</kbd> follow the same scope rules as variables declared with <kbd>let</kbd>, they can't be reassigned:</p>
<pre>function foo(): void { 
    if (true) { 
        const bar: number = 0; 
        bar = 1; // Error 
    } 
    alert(bar); // Error 
} </pre>
<p>If we attempt to compile the preceding code snippet, we will get an error because the <kbd>bar</kbd> variable is not accessible outside the <kbd>if</kbd> statement (just like when we used the <kbd>let</kbd> keyword), and a new error will occur when we try to assign a new value to the <kbd>bar</kbd> variable. The second error occurs because it is not possible to assign a new value to a constant variable once the variable has already been initialized.</p>
<div class="packt_infobox">Variables declared with the <kbd>const</kbd> keyword cannot be reassigned, but are not immutable. When we say that a variable is immutable, we means that it cannot be modified. We will learn more about immutability in <a href="72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml">Chapter 7</a>, <em>Functional Programming with TypeScript</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Immediately invoked functions</h1>
                </header>
            
            <article>
                
<p>An <strong>immediately invoked function expression</strong> (<strong>IIFE</strong>) is a design pattern that produces a lexical scope using function scoping. An IIFE can be used to avoid variable hoisting from within blocks, or to prevent us from polluting the global scope—for example:</p>
<pre>let bar = 0; // global 
 
(function() { 
    let foo: number = 0; // In scope of this function 
    bar = 1; // Access global scope 
    console.log(bar); // 1 
    console.log(foo); // 0 
})(); 
 
console.log(bar); // 1 
console.log(foo); // Error </pre>
<p>In the preceding example, we have wrapped the declaration of a variable (<kbd>foo</kbd>) with an IIFE. The <kbd>foo</kbd> variable is scoped to the IIFE function and is not available in the global scope, which explains the error that is thrown when we try to access it on the last line.</p>
<p>The <kbd>bar</kbd> variable is a global. Therefore, it can be accessed from both the inside and the outside of the IIFE function.</p>
<p>We can also pass a variable to the IIFE to have better control over the creation of variables outside its scope:</p>
<pre><a>let bar = 0; // global</a> 
let topScope = window; 
 
(function(global: any) { 
    let foo: number = 0; // In scope of this function 
    console.log(global.bar); // 0 
    global.bar = 1; // Access global scope 
    console.log(global.bar); // 1 
    console.log(foo); // 0 
})(topScope); 
 
console.log(bar); // 1 
console.log(foo); // Error </pre>
<p>Furthermore, IIFE can help us to simultaneously allow public access to methods while retaining privacy for variables defined within the function. Let's look at an example:</p>
<pre><a>class Counter {</a> 
    private _i: number; 
    public constructor() { 
        this._i = 0; 
    } 
    public get(): number { 
        return this._i; 
    } 
    public set(val: number): void { 
        this._i = val; 
    } 
    public increment(): void { 
        this._i++; 
    } 
} 
 
let counter = new Counter(); 
console.log(counter.get()); // 0 
counter.set(2); 
console.log(counter.get()); // 2 
counter.increment(); 
console.log(counter.get()); // 3 
console.log(counter._i); // Error: Property '_i' is private </pre>
<p>We have defined a class named <kbd>Counter</kbd>, which has a private numeric attribute named <kbd>_i</kbd>. The class also has methods to get and set the value of the private <kbd>_i </kbd><span>property</span><span>.</span></p>
<div class="packt_infobox">By convention, TypeScript and JavaScript developers usually name private variables with names preceded by an underscore (<kbd>_</kbd>).</div>
<p>We have also created an instance of the <kbd>Counter</kbd> class and invoked the <kbd>set</kbd>, <kbd>get</kbd>, and <kbd>increment</kbd> <span>methods</span><span> </span><span>to observe that everything is working as expected. If we attempt to access the</span> <kbd>_i</kbd> <span>property in an instance of</span> <kbd>Counter</kbd><span>, we will get an error because the variable is</span> <kbd>private</kbd><span>.</span></p>
<p>If we compile the preceding TypeScript code (only the class definition) and examine the generated JavaScript code, we will see the following:</p>
<pre>var Counter = (function() { 
    function Counter() { 
        this._i = 0; 
    } 
    Counter.prototype.get = function() { 
        return this._i; 
    }; 
    Counter.prototype.set = function(val) { 
        this._i = val; 
    }; 
    Counter.prototype.increment = function() { 
        this._i++; 
    }; 
    return Counter; 
})(); </pre>
<p>This generated JavaScript code will work perfectly in most scenarios, but if we execute it in a browser and try to create an instance of <kbd>Counter</kbd> and access its <kbd>_i </kbd><span>property</span><span>, we will not get any errors because TypeScript will not generate runtime private properties for us. Sometimes we will need to write our classes in such a way that some properties are private at runtime—for example, if we release a library that will be used by JavaScript developers.</span></p>
<p>We can also use IIFE to simultaneously allow public access to methods while retaining privacy for variables defined within the function:</p>
<pre>var Counter = (function() { 
    var _i: number = 0; 
    function Counter() { 
        // 
    } 
    Counter.prototype.get = function() { 
        return _i; 
    }; 
    Counter.prototype.set = function(val: number) { 
        _i = val; 
    }; 
    Counter.prototype.increment = function() { 
        _i++; 
    }; 
    return Counter; 
})(); </pre>
<p>In the preceding example, everything is almost identical to the TypeScript's generated JavaScript, except now the variable <kbd>_i</kbd> is an object in the <kbd>Counter</kbd> closure instead of a property of the <kbd>Counter</kbd> class.</p>
<div class="packt_infobox">Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure <em>remembers</em> the environment (variables in the scope) in which it was created. We will discover more about closures in <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Understanding the Runtime</em>.</div>
<p>If we run the generated JavaScript output in a browser and try to invoke the <kbd>_i</kbd> property directly, we will notice that the property is now private at runtime:</p>
<pre>let counter = new Counter(); 
console.log(counter.get()); // 0 
counter.set(2); 
console.log(counter.get()); // 2 
counter.increment(); 
console.log(counter.get()); // 3 
console.log(counter._i); // undefined </pre>
<div class="packt_infobox">In some cases, we will need to have precise control over scope and closures, and our code will end up looking much more like JavaScript. As long as we write our application components (classes, modules, and so on) to be consumed by other TypeScript components, we will rarely have to worry about implementing runtime private properties. We will look in depth at the TypeScript runtime in <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Understanding the Runtime</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tag functions and tagged templates</h1>
                </header>
            
            <article>
                
<p>In TypeScript, we can use template strings such as the following:</p>
<pre>let name = "remo"; 
let surname = "jansen"; 
let html = `&lt;h1&gt;${name} ${surname}&lt;/h1&gt;`; </pre>
<p>We can use a template string to create a special kind of function known as a <strong>tag function</strong>.</p>
<p>We can use a tag function to extend or modify the standard behavior of template strings. When we apply a tag function to a template string, the template string becomes a tagged template.</p>
<p>We are going to implement a tag function named <kbd>htmlEscape</kbd>. To use a tag function, we must use the name of the function followed by a template string:</p>
<pre>    
    <a>let html = htmlEscape `&lt;h1&gt;${name} ${surname}&lt;/h1&gt;`;</a>
  </pre>
<p>A tag template must return a string and take the following arguments:</p>
<ul>
<li>A <kbd>TemplateStringsArray</kbd> that contains all the static literals in the template string (<kbd>&lt;h1&gt;</kbd> and <kbd>&lt;/h1&gt;</kbd> in the preceding example) is passed as the first argument.</li>
</ul>
<div class="packt_infobox">The <kbd>TemplateStringsArray</kbd> type is declared by the <kbd>lib.d.ts</kbd> file. We will learn more about the <kbd>lib.d.ts</kbd> file in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>.</div>
<ul>
<li>A REST parameter is passed as the second parameter. The <span>REST </span>parameter contains all the values in the template string (<kbd>name</kbd> and <kbd>surname</kbd>, in the preceding example).</li>
</ul>
<p>The signature of a tag function looks as follows:</p>
<pre>tag(literals: TemplateStringsArray, ...placeholders: any[]): string; </pre>
<p>Let's implement the <kbd>htmlEscape</kbd> tag function:</p>
<pre><a>function htmlEscape(literals: TemplateStringsArray, ...placeholders: any[]) {</a> 
    let result = ""; 
    for (let i = 0; i &lt; placeholders.length; i++) { 
        result += literals[i]; 
        result += placeholders[i] 
            .replace(/&amp;/g, "&amp;amp;") 
            .replace(/"/g, "&amp;quot;") 
            .replace(/"/g, "'") 
            .replace(/&lt;/g, "&amp;lt;") 
            .replace(/&gt;/g, "&amp;gt;"); 
    } 
    result += literals[literals.length - 1]; 
    return result; 
} </pre>
<p>We can then invoke the function as follows:</p>
<pre>let html = htmlEscape `&lt;h1&gt;${name} ${surname}&lt;/h1&gt;`; </pre>
<p>The template string contains values and literals. The <kbd>htmlEscape</kbd> function iterates through them and ensures that the HTML code is escaped in the values to avoid possible code injection attacks.</p>
<p>The main benefit of using a tagged function is that it allows us to create custom template string processors.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asynchronous programming in TypeScript</h1>
                </header>
            
            <article>
                
<p>Now that we have seen how to work with functions, we will explore how we can use them, together with some native APIs, to write asynchronous applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Callbacks and higher-order functions</h1>
                </header>
            
            <article>
                
<p>In TypeScript, functions can be passed as arguments to another function. Functions can also be returned by another function. A function passed to another as an argument is known as a <strong>callback</strong>. Functions that accept functions as parameters (callbacks) or return functions are known as <strong>higher-order functions</strong>.</p>
<p>Callbacks are usually anonymous functions. They can be declared before they are passed to the higher-order function, as demonstrated by the following example:</p>
<pre>var foo = function() { // callback 
  console.log("foo"); 
} 
 
function bar(cb: () =&gt; void) { // higher order function 
  console.log("bar"); 
  cb(); 
} 
 
bar(foo); // prints "bar" then prints "foo" </pre>
<p>However, callbacks are declared inline, at the same point at which they are passed to the higher-order function, as demonstrated by the following example:</p>
<pre>bar(() =&gt; { 
  console.log("foo"); 
}); // prints "bar" then prints "foo" </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Arrow functions</h1>
                </header>
            
            <article>
                
<p>In TypeScript, we can declare a function using a <kbd>function</kbd> expression or an arrow function. An arrow function has a shorter syntax than a function expression, and lexically binds the value of the <kbd>this</kbd> operator.</p>
<p>The <kbd>this</kbd> operator behaves a little differently in TypeScript and JavaScript compared to other popular programming languages. When we define a class in TypeScript, we can use the <kbd>this</kbd> operator to refer to the class. Let's look at an example:</p>
<pre>class Person { 
    private _name: string; 
    constructor(name: string) { 
        this._name = name; 
    } 
    public greet() { 
        console.log(`Hi! My name is ${this._name}`); 
    } 
} 
 
let person = new Person("Remo"); 
person.greet(); // "Hi! My name is Remo" </pre>
<p>We have defined a <kbd>Person</kbd> class that contains a property of a <span>string</span><span> </span><span>type called</span> <kbd>name</kbd><span>. The class has a constructor and a</span> <kbd>greet </kbd><span>method</span><span>.</span><span> We have created an instance named</span> <kbd>person</kbd> <span>and invoked the </span><span><kbd>greet</kbd> </span><span>method</span><span>, which uses the</span> <kbd>this</kbd> <span>operator </span><span>internally</span><span> </span><span>to access the</span> <kbd>_name </kbd><span>property</span><span>.</span><span> Inside the</span> <kbd>greet</kbd> <span>method, the</span> <kbd>this</kbd> <span>operator points to the object that encloses the</span> <kbd>greet</kbd> <span>method.</span></p>
<p>We must be careful when using the <kbd>this</kbd> operator, because in some scenarios it can point to the wrong value. Let's add an extra method to the previous example:</p>
<pre>class Person { 
    private _name: string; 
    constructor(name: string) { 
        this._name = name; 
    } 
    public greet() { 
        alert(`Hi! My name is ${this._name}`); 
    } 
    public greetDelay(time: number) { 
        setTimeout(function() { 
            alert(`Hi! My name is ${this._name}`); // Error 
        }, time); 
    } 
} </pre>
<p>In the <kbd>greetDelay</kbd> method, we perform an almost identical operation to the one performed by the <kbd>greet</kbd> method. This time, the function takes a parameter named <kbd>time</kbd>, which is used to delay the <kbd>greet</kbd> message.</p>
<p>To delay a message, we use the <kbd>setTimeout</kbd> function and a callback. As soon as we define an anonymous function (the callback), the <kbd>this</kbd> keyword changes its value and starts pointing to the anonymous function, which explains why the TypeScript compiler will throw an error.</p>
<p>As mentioned, an arrow function expression lexically binds the value of the <kbd>this</kbd> operator. This means that it <kbd>allows</kbd> us to add a function without altering the value of the <kbd>this</kbd> operator. Let's replace the function expression from the previous example with an arrow function:</p>
<pre><a>class Person {</a> 
    private _name: string; 
    constructor(name: string) { 
        this._name = name; 
    } 
    public greet() { 
        alert(`Hi! My name is ${this._name}`); 
    } 
    public greetDelay(time: number) { 
        setTimeout(() =&gt; { 
            alert(`Hi! My name is ${this._name}`); // OK 
        }, time); 
    } 
} 
 
let person = new Person("Remo"); 
person.greet(); // "Hi! My name is Remo" 
person.greetDelay(1000); // "Hi! My name is Remo" </pre>
<p>By using an arrow function, we can ensure that the <kbd>this</kbd> operator still points to the <kbd>Person</kbd> instance and not to the <kbd>setTimeout</kbd> callback. If we execute the <kbd>greetDelay</kbd> function, the name property will be displayed as expected.</p>
<p>The following piece of code is generated by the TypeScript compiler. When compiling an arrow function, the TypeScript compiler will generate an alias for the <kbd>this</kbd> operator named <kbd>_this</kbd>. The alias is used to ensure that the <kbd>this</kbd> operator points to the right object:</p>
<pre>Person.prototype.greetDelay = function (time) { 
  var _this = this; 
  setTimeout(function () { 
    alert("Hi! My name is " + _this._name); 
  }, time); 
}; </pre>
<div class="packt_infobox">We will look at the <kbd>this</kbd> operator <span>in depth</span><span> </span><span>in <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>,</span> <em>Understanding the Runtime</em><span>.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Callback hell</h1>
                </header>
            
            <article>
                
<p>We have learned that callbacks and higher-order functions are two powerful and flexible JavaScript and TypeScript features. However, the use of callbacks can lead to a maintainability issue known as <strong>callback hell</strong>.</p>
<p>We are now going to write an example to showcase callback hell. We are going to write three functions with the same behavior, named <kbd>doSomethingAsync</kbd>, <kbd>doSomethingElseAsync</kbd>, and <kbd>doSomethingMoreAsync</kbd>:</p>
<pre><a>function doSomethingAsync(</a> 
    arr: number[], 
    success: (arr: number[]) =&gt; void, 
    error: (e: Error) =&gt; void 
) { 
    setTimeout(() =&gt; { 
        try { 
            let n = Math.ceil(Math.random() * 100 + 1); 
            if (n &lt; 25) { 
                throw new Error("n is &lt; 25"); 
            } 
            success([...arr, n]); 
        } catch (e) { 
            error(e); 
        } 
    }, 1000); 
} 
 
function doSomethingElseAsync( 
    arr: number[], 
    success: (arr: number[]) =&gt; void, 
    error: (e: Error) =&gt; void 
) { 
    setTimeout(() =&gt; { 
        try { 
            let n = Math.ceil(Math.random() * 100 + 1); 
            if (n &lt; 25) { 
                throw new Error("n is &lt; 25"); 
            } 
            success([...arr, n]); 
        } catch (e) { 
            error(e); 
        } 
    }, 1000); 
} 
 
function doSomethingMoreAsync( 
    arr: number[], 
    success: (arr: number[]) =&gt; void, 
    error: (e: Error) =&gt; void 
) { 
    setTimeout(() =&gt; { 
        try { 
            let n = Math.ceil(Math.random() * 100 + 1); 
            if (n &lt; 25) { 
                throw new Error("n is &lt; 25"); 
            } 
            success([...arr, n]); 
        } catch (e) { 
            error(e); 
        } 
    }, 1000); 
} </pre>
<p>The preceding functions simulate an asynchronous operation by using the <kbd>setTimeout</kbd> function. Each function takes a success callback, which is invoked if the operation is successful, and an error callback, which is invoked if something goes wrong.</p>
<p>In real-world applications, asynchronous operations usually involve some interaction with hardware (for example, filesystems, networks, and so on). The interactions are known as <strong>input/output</strong> (<strong>I</strong>/<strong>O</strong>) operations. I/O operations can fail for many different reasons (for example, we get an error when we try to interact with the filesystem to save a new file and there is not enough space available on the hard disk).</p>
<p>The preceding functions generate a random number and throw an error if the number is lower than 25; we do this to simulate potential I/O errors.</p>
<p>The preceding functions add the random number to an array that is passed as an argument to each of the functions. If no errors take place, the result of the final function (<kbd>doSomethingMoreAsync</kbd>) should be an array with three random numbers.</p>
<p>Now that the three functions have been declared, we can try to invoke them in order. We are going to use callbacks to ensure that <kbd>doSomethingMoreAsync</kbd> is invoked after <kbd>do</kbd><kbd>SomethingElseAsync</kbd>, and <kbd>doSomethingElseAsync</kbd> is invoked after <kbd>do</kbd><kbd>SomethingAsync</kbd>:</p>
<pre><a>doSomethingAsync([], (arr1) =&gt; {</a> 
    doSomethingElseAsync(arr1, (arr2) =&gt; { 
        doSomethingMoreAsync(arr2, (arr3) =&gt; { 
            console.log( 
                ` 
                doSomethingAsync: ${arr3[0]} 
                doSomethingElseAsync: ${arr3[1]} 
                doSomethingMoreAsync: ${arr3[2]} 
                ` 
            ); 
        }, (e) =&gt; console.log(e)); 
    }, (e) =&gt; console.log(e)); 
}, (e) =&gt; console.log(e)); </pre>
<p>The preceding example used a few nesting callbacks. The use of these kinds of nested callbacks is known as <strong>callback hell</strong> because they can lead to the following maintainability issues:</p>
<ul>
<li>Making the code harder to follow and understand</li>
<li>Making the code harder to maintain (refactor, reuse, and so on)</li>
<li>Making exception handling more difficult</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Promises</h1>
                </header>
            
            <article>
                
<p>After seeing how the use of callbacks can lead to some maintainability problems, we are now going to learn about promises and how they can be used to write better asynchronous code. The core idea behind promises is that a promise represents the result of an asynchronous operation. A promise must be in one of the following three states:</p>
<ul>
<li><strong>Pending</strong>: The initial state of a promise.</li>
<li><strong>Fulfilled</strong><strong>/resolved</strong>: The state of a promise representing a successful operation. The terms "fulfilled" and "resolved" are both commonly used to refer to this state.</li>
<li><strong>Rejected</strong>: The state of a promise representing a failed operation.</li>
</ul>
<p>Once a promise is fulfilled or rejected, its state can never change again. Let's look at the basic syntax of a promise:</p>
<pre>function foo() { 
    return new Promise&lt;string&gt;((fulfill, reject) =&gt; { 
        try { 
            // do something 
            fulfill("SomeValue"); 
        } catch (e) { 
            reject(e); 
        } 
    }); 
} 
 
foo().then((value) =&gt; { 
    console.log(value); 
}).catch((e) =&gt; { 
    console.log(e); 
}); </pre>
<div class="packt_infobox">A <kbd>try...catch</kbd> statement is used here to showcase how we can explicitly fulfill or reject a promise. The <kbd>try...catch</kbd> statement is not needed for a <kbd>Promise</kbd> function because when an error is thrown in a promise callback, the promise will automatically be rejected.</div>
<p>The preceding code snippet declares a function named <kbd>foo</kbd> that returns a promise. The promise contains a method named <kbd>then</kbd>, which accepts a function to be invoked when the promise is fulfilled. Promises also provide a method named <kbd>catch</kbd>, which is invoked when a promise is rejected.</p>
<div class="packt_infobox">Promises will not be recognized by the TypeScript compiler if we are targeting ES5, because the promises API is part of ES6. We can solve this by enabling the <kbd>es2015.promise</kbd> type using the <kbd>lib</kbd> option in the <kbd>tsconfig</kbd><kbd>.json</kbd> file. Note that enabling this option will disable some types that are included by default and therefore break some of the examples. You will be able to solve the problems by including the <kbd>dom</kbd> and <kbd>es5</kbd> types, as well as by using the <kbd>lib</kbd> option in the <kbd>tsconfig</kbd><kbd>.json</kbd> file:<br/>
<kbd>"lib": [</kbd><br/>
<kbd>    "es2015.promise",</kbd><br/>
<kbd>    "dom",</kbd><br/>
<kbd>    "es5",</kbd><br/>
<kbd>    "es2015.generator", // new</kbd><br/>
<kbd>    "es2015.iterable" // new</kbd><br/>
<kbd>]</kbd> <br/>
<span>We will learn more about the</span> <kbd>lib</kbd> <span>setting in</span> <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a><span>,</span> <em>Automating Your Development Workflow</em><span>.</span></div>
<p>We are now going to rewrite the <kbd>doSomethingAsync</kbd>, <kbd>doSomethingElseAsync</kbd>, and <kbd>doSomethingMoreAsync</kbd> <span>functions</span><span> </span><span>that we wrote during the callback hell example, using promises instead of callbacks:</span></p>
<pre><a>function doSomethingAsync(arr: number[]) {</a> 
    return new Promise&lt;number[]&gt;((resolve, reject) =&gt; { 
        setTimeout(() =&gt; { 
            try { 
                let n = Math.ceil(Math.random() * 100 + 1); 
                if (n &lt; 25) { 
                    throw new Error("n is &lt; 25"); 
                } 
                resolve([...arr, n]); 
            } catch (e) { 
                reject(e); 
            } 
        }, 1000); 
    }); 
} 
 
function doSomethingElseAsync(arr: number[]) { 
    return new Promise&lt;number[]&gt;((resolve, reject) =&gt; { 
        setTimeout(() =&gt; { 
            try { 
                let n = Math.ceil(Math.random() * 100 + 1); 
                if (n &lt; 25) { 
                    throw new Error("n is &lt; 25"); 
                } 
                resolve([...arr, n]); 
            } catch (e) { 
                reject(e); 
            } 
        }, 1000); 
    }); 
} 
 
function doSomethingMoreAsync(arr: number[]) { 
    return new Promise&lt;number[]&gt;((resolve, reject) =&gt; { 
        setTimeout(() =&gt; { 
            try { 
                let n = Math.ceil(Math.random() * 100 + 1); 
                if (n &lt; 25) { 
                    throw new Error("n is &lt; 25"); 
                } 
                resolve([...arr, n]); 
            } catch (e) { 
                reject(e); 
            } 
        }, 1000); 
    }); 
} 
 </pre>
<p>We can chain the promises that are returned by each of the preceding functions using the promises API:</p>
<pre><a>doSomethingAsync([]).then((arr1) =&gt; {</a> 
    doSomethingElseAsync(arr1).then((arr2) =&gt; { 
        doSomethingMoreAsync(arr2).then((arr3) =&gt; { 
            console.log( 
                ` 
                doSomethingAsync: ${arr3[0]} 
                doSomethingElseAsync: ${arr3[1]} 
                doSomethingMoreAsync: ${arr3[2]} 
                ` 
            ); 
        }); 
    }); 
}).catch((e) =&gt; console.log(e)); </pre>
<p>The preceding code snippet is a little bit better than the one used in the callback example because we only needed to declare one exception handler instead of three exception handlers. This is possible because errors are propagated through the chain of promises.</p>
<p>The preceding example has introduced some improvements. However, the promises API allows us to chain promises in a much less verbose way:</p>
<pre><a>doSomethingAsync([])</a> 
    .then(doSomethingElseAsync) 
    .then(doSomethingMoreAsync) 
    .then((arr3) =&gt; { 
        console.log( 
            ` 
            doSomethingAsync: ${arr3[0]} 
            doSomethingElseAsync: ${arr3[1]} 
            doSomethingMoreAsync: ${arr3[2]} 
            ` 
        ); 
    }).catch((e) =&gt; console.log(e)); </pre>
<p>The preceding code is much easier to read and follow than the one used during the callback examples, but this is not the only reason to prefer promises over callbacks. Using promises also gives us better control over the execution flow of operations. Let's look at a couple of examples.</p>
<p>The promises API includes a method named <kbd>all</kbd>, which allows us to execute a series of promises in parallel and get all the results of each of the promises at once:</p>
<pre>Promise.all([ 
    new Promise&lt;number&gt;((resolve) =&gt; { 
        setTimeout(() =&gt; resolve(1), 1000); 
    }), 
    new Promise&lt;number&gt;((resolve) =&gt; { 
        setTimeout(() =&gt; resolve(2), 1000); 
    }), 
    new Promise&lt;number&gt;((resolve) =&gt; { 
        setTimeout(() =&gt; resolve(3), 1000); 
    }) 
]).then((values) =&gt; { 
    console.log(values); // [ 1 ,2, 3] 
}); </pre>
<p>The promises API also includes a method named <kbd>race</kbd>, which allows us to execute a series of promises in parallel and get the result of the first promise resolved:</p>
<pre>Promise.race([ 
    new Promise&lt;number&gt;((resolve) =&gt; { 
        setTimeout(() =&gt; resolve(1), 3000); 
    }), 
    new Promise&lt;number&gt;((resolve) =&gt; { 
        setTimeout(() =&gt; resolve(2), 2000); 
    }), 
    new Promise&lt;number&gt;((resolve) =&gt; { 
        setTimeout(() =&gt; resolve(3), 1000); 
    }) 
]).then((fastest) =&gt; { 
    console.log(fastest); // 3 <br/>});</pre>
<p>We can use many different types of asynchronous flow control when working with promises:</p>
<ul>
<li><strong>Concurrent</strong>: The tasks are executed in parallel (like in the <kbd>Promise.all</kbd> example)</li>
<li><strong>Race</strong>: The tasks are executed in parallel, and only the result of the fastest promise is returned</li>
<li><strong>Series</strong>: A group of tasks is executed in sequence, but the preceding tasks do not pass arguments to the next task</li>
<li><strong>Waterfall</strong>: A group of tasks is executed in sequence, and each task passes arguments to the next task (like in the example that preceded the <kbd>Promise.all</kbd> and <kbd>Promise.race</kbd> examples)</li>
<li><strong>Composite</strong>: This is any combination of the preceding concurrent, series, and waterfall approaches</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Covariant checking in callback parameters</h1>
                </header>
            
            <article>
                
<p>TypeScript 2.4 changed the way the type system behaves internally to improve the error detection in nested callbacks and promises:</p>
<div class="packt_quote">TypeScript's checking of callback parameters is now covariant concerning immediate signature checks. Previously it was bivariant, which could sometimes let incorrect types through. Basically, this means that callback parameters and classes that contain callbacks are checked more carefully, so TypeScript will require stricter types in this release. This is particularly true of Promises and Observables due to the way in which their APIs are specified.</div>
<p>In TypeScript versions before 2.4, the following example was considered valid, and no errors were thrown:</p>
<pre>declare function someFunc( 
    callback: ( 
    nestedCallback: (error: number, result: any) =&gt; void 
    ) =&gt; void 
): void; 
 
someFunc( 
    ( 
        nestedCallback: (e: number) =&gt; void // Error 
    ) =&gt; { 
        nestedCallback(1); 
    } 
); </pre>
<p>In TypeScript versions following the 2.4 release, we need to add the complete signature of <kbd>nestedCallback</kbd> to solve this error:</p>
<pre>someFunc( 
    ( 
        nestedCallback: (e: number, result: any) =&gt; void // OK 
    ) =&gt; { 
        nestedCallback(1, 1); 
    } 
); </pre>
<p>Thanks to the internal change in the TypeScript type system, the following error is also detected:</p>
<pre>let p: Promise&lt;number&gt; = new Promise((res, rej) =&gt; { 
    res("error"); // Error 
}); </pre>
<p>Before TypeScript 2.4, the preceding promise would have been inferred as <kbd>Promise&lt;{}&gt;</kbd> because we forgot to add the generic <kbd>&lt;number&gt;</kbd> <span>argument</span><span> </span><span>when we created an instance of the</span> <kbd>Promise</kbd> <span>class. The</span> <kbd>error</kbd><span> </span><span>string</span><span> </span><span>would then have been considered a valid instance of</span> <kbd>{}</kbd><span>.</span></p>
<p>This is a clear example of why it is recommended that you upgrade TypeScript regularly. Each new version of TypeScript introduces new features that are able to detect new errors for us.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generators</h1>
                </header>
            
            <article>
                
<p>If we invoke a function in TypeScript, we can assume that once the function starts running, it will always run to completion before any other code can run. However, a new kind of function that may be paused in the middle of execution—one or many times—and resumed later, allowing other code to run during these paused periods, has recently <span>been</span><span> </span><span>added to the ECMAScript specification. These new kinds of functions are known as</span> <strong>generators</strong><span>.</span></p>
<p>A generator represents a sequence of values. The interface of a <kbd>generator</kbd> object is just an <strong>iterator</strong>. An iterator implements the following interface:</p>
<pre>interface Iterator&lt;T&gt; { 
  next(value?: any): IteratorResult&lt;T&gt;; 
  return?(value?: any): IteratorResult&lt;T&gt;; 
  throw?(e?: any): IteratorResult&lt;T&gt;; 
} </pre>
<p>The <kbd>next()</kbd>function can be invoked until it runs out of values.</p>
<p>We can define a generator by using the <kbd>function</kbd> keyword followed by an asterisk (<kbd>*</kbd>). The <kbd>yield</kbd> keyword is used to stop the execution of the function and return a value. Let's look at an example:</p>
<pre><a>function *foo() {</a> 
    yield 1; 
    yield 2; 
    yield 3; 
    yield 4; 
    return 5; 
} 
 
let bar = foo(); 
bar.next(); // Object {value: 1, done: false} 
bar.next(); // Object {value: 2, done: false} 
bar.next(); // Object {value: 3, done: false} 
bar.next(); // Object {value: 4, done: false} 
bar.next(); // Object {value: 5, done: true} 
bar.next(); // Object { done: true } </pre>
<div class="packt_infobox">Note that some additional types are required by generators if you are targeting ES5. You will need to add <kbd>es2015.generator</kbd> and <kbd>es2015.iterable</kbd> to your <kbd>tsconfig.json</kbd> file:
<pre>"lib": [ 
      "es2015.promise", 
      "dom",  
      "es5", 
      "es2015.generator", // new 
      "es2015.iterable" // new 
] </pre>
We will learn more about the <kbd>lib</kbd> setting in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em><em>Automating Your Development Workflow</em></em>.</div>
<p>As we can see, the preceding iterator has five steps. The first time we call <kbd>next</kbd>, the function will be executed until it reaches the first <kbd>yield</kbd> statement, and then it will return the value <kbd>1</kbd> and stop the execution of the function until we invoke the generator's <kbd>next</kbd> method again. As we can see, we are now able to stop the function's execution at a given point. This allows us to write infinite loops without causing a stack overflow, as demonstrated in the following example:</p>
<pre>function* foo() { 
<a>let i = 1;</a> 
    while (true) { 
        yield i++; 
    } 
} 
 
let bar = foo(); 
bar.next(); // Object {value: 1, done: false} 
bar.next(); // Object {value: 2, done: false} 
bar.next(); // Object {value: 3, done: false} 
bar.next(); // Object {value: 4, done: false} 
bar.next(); // Object {value: 5, done: false} 
bar.next(); // Object {value: 6, done: false} 
bar.next(); // Object {value: 7, done: false} </pre>
<p>The generator will open possibilities for synchronicity, as we can call the generator's <kbd>next</kbd> method after an asynchronous event has occurred.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asynchronous functions – async and await</h1>
                </header>
            
            <article>
                
<p><strong>Asynchronous functions</strong> are a TypeScript feature that arrived with the TypeScript 1.6 release. Developers can use the <kbd>await</kbd> keyword to wait for the function results without blocking the normal execution of the program.</p>
<p>Using asynchronous functions helps to increase the readability of a piece of code when compared with the use of promises or callbacks, but technically, we can achieve the same features using both promises and synchronous code.</p>
<p>Let's take a look at a basic <kbd>async</kbd>/<kbd>await</kbd> example:</p>
<pre>let p = Promise.resolve(3); 
 
async function fn(): Promise&lt;number&gt; { 
    let i = await p; // 3 
    return 1 + i; // 4 
} 
 
fn().then((r) =&gt; console.log(r)); // 4 </pre>
<p>The preceding code snippet declares a promise named <kbd>p</kbd>. This promise is the piece of code whose execution we will wait for. While waiting, the program execution will not be blocked because JavaScript allows us to wait for an asynchronous function named <kbd>fn</kbd> without blocking it. As we can see, the <kbd>fn</kbd> function is preceded by the <kbd>async</kbd> keyword, which is used to indicate to the compiler that it is an asynchronous function.</p>
<p>Inside the function, the <kbd>await</kbd> keyword is used to suspend execution until the promise <kbd>p</kbd> is fulfilled or rejected. As we can see, the syntax is less verbose and cleaner than it would have been if we used the promises API or callbacks.</p>
<p>The <kbd>fn </kbd><span>function</span><span> </span><span>returns a promise at runtime because it is an</span> <kbd>async</kbd> <span>function. This should explain why we need to use the</span> <kbd>then</kbd> <span>callback to invoke it at the end of the code snippet.</span></p>
<p>The following code snippet showcases how we can declare an asynchronous function named <kbd>invokeTaskAsync</kbd>. The asynchronous function uses the <kbd>await</kbd> keyword to wait for the result of the <kbd>doSomethingAsync</kbd>, <kbd>doSomethingElseAsync</kbd>, and <kbd>doSomethingMoreAsync</kbd> functions that we declared during the promises example:</p>
<pre><a>async function invokeTaskAsync() {</a> 
    let arr1 = await doSomethingAsync([]); 
    let arr2 = await doSomethingElseAsync(arr1); 
    return await doSomethingMoreAsync(arr2); 
} </pre>
<p>The <kbd>invokeTaskAsync</kbd> function is asynchronous, and therefore, it will return a promise at runtime. This means that we can use the promises API to await a result or catch potential errors respectively:</p>
<pre><a>invokeTaskAsync().then((result) =&gt; {</a> 
    console.log( 
        ` 
        doSomethingAsync: ${result[0]} 
        doSomethingElseAsync: ${result[1]} 
        doSomethingMoreAsync: ${result[2]} 
        ` 
    ); 
}).catch((e) =&gt; { 
    console.log(e); 
}); </pre>
<p>We can also define asynchronous IIFE as a convenient way to use the <kbd>async</kbd> and <kbd>await</kbd> keywords:</p>
<pre>(async () =&gt; { 
    try { 
        let arr1 = await doSomethingAsync([]); 
        let arr2 = await doSomethingElseAsync(arr1); 
        let arr3 = await doSomethingMoreAsync(arr2); 
        console.log( 
            ` 
            doSomethingAsync: ${arr3[0]} 
            doSomethingElseAsync: ${arr3[1]} 
            doSomethingMoreAsync: ${arr3[2]} 
            ` 
        ); 
    } catch (e) { 
        console.log(e); 
    } 
})(); </pre>
<p>Using an async IIFE is very useful because it is very common to not be able to use the <kbd>await</kbd> keyword outside of a function—for example, in the entry point of an application. We can use the async IIFE to overcome this limitation:</p>
<pre>(async () =&gt; { 
    await main(); 
})(); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asynchronous generators</h1>
                </header>
            
            <article>
                
<p>We have already learned about the interface that is implemented by all iterators:</p>
<pre>interface Iterator&lt;T&gt; { 
  next(value?: any): IteratorResult&lt;T&gt;; 
  return?(value?: any): IteratorResult&lt;T&gt;; 
  throw?(e?: any): IteratorResult&lt;T&gt;; 
} </pre>
<p>However, we haven't <span>yet</span><span> learned about the interface that is implemented by all asynchronous iterators:</span></p>
<pre>interface AsyncIterator&lt;T&gt; { 
  next(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;; 
  return?(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;; 
  throw?(e?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;; 
} </pre>
<p>An asynchronous iterator returns a promise every time we invoke the <kbd>next</kbd> method. The following code snippet demonstrates how asynchronous iterators can be very useful when used in conjunction with asynchronous functions:</p>
<pre><a>let counter = 0;</a> 
 
function doSomethingAsync() { 
    return new Promise&lt;number&gt;((r) =&gt; { 
        setTimeout(() =&gt; { 
            counter += 1; 
            r(counter); 
        }, 1000); 
    }); 
} 
 
async function* g1() { 
    yield await doSomethingAsync(); 
    yield await doSomethingAsync(); 
    yield await doSomethingAsync(); 
} 
 
let i = g1(); 
i.next().then((n) =&gt; console.log(n)); // 1 
i.next().then((n) =&gt; console.log(n)); // 2 
i.next().then((n) =&gt; console.log(n)); // 3 </pre>
<div class="packt_infobox">Some additional types are required by asynchronous iterators if we are targeting ES5. You will need to add <kbd>esnext.asynciterable</kbd> to your <kbd>tsconfig.json</kbd> file. We are also going to need to enable an additional setting in our <kbd>tsconfig.json</kbd> to provide full support for iterables (for example, using <kbd>for...of</kbd> control flow statements, the spread operator or object destructuring) when targeting ES3 or ES5:<br/>
<br/>
<kbd>"lib": [</kbd><br/>
<kbd>"es2015.promise",</kbd><br/>
<kbd>"dom",</kbd><br/>
<kbd>"es5",</kbd><br/>
<kbd>"es2015.generator",</kbd><br/>
<kbd>"es2015.iterable",</kbd><br/>
<kbd>"esnext.asynciterable" // new</kbd><br/>
<kbd>] </kbd><br/>
<br/>
<span>We will learn more about the</span> <kbd>lib</kbd> <span>setting in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>,</span> <em>Automating Your Development Workflow</em><span>.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asynchronous iteration (for await...of)</h1>
                </header>
            
            <article>
                
<p>We can use the new <kbd>for...await...of</kbd> expression to iterate and await each of the promises returned by an asynchronous iterator:</p>
<pre>async function func() { 
    for await (const x of g1()) { 
        console.log(x); 
    } 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Delegating to another generator (yield*)</h1>
                </header>
            
            <article>
                
<p>We can use the <kbd>yield*</kbd> expression to delegate from one generator to another. The following code snippet defines two generator functions named <kbd>g1</kbd> and <kbd>g2</kbd>. The <kbd>g2</kbd> generator uses the <kbd>yield*</kbd> expression to delegate the iteration to the iterator created by <kbd>g1</kbd>:</p>
<pre><a>function* g1() {</a> 
    yield 2; 
    yield 3; 
    yield 4; 
} 
 
function* g2() { 
    yield 1; 
    yield* g1(); 
    yield 5; 
} 
 
var iterator1 = g2(); 
 
console.log(iterator1.next()); // {value: 1, done: false} 
console.log(iterator1.next()); // {value: 2, done: false} 
console.log(iterator1.next()); // {value: 3, done: false} 
console.log(iterator1.next()); // {value: 4, done: false} 
console.log(iterator1.next()); // {value: 5, done: false} 
console.log(iterator1.next()); // {value: undefined, done: true} </pre>
<p>The <kbd>yield*</kbd> expression can also be used to delegate the iteration to iterables, such as arrays:</p>
<pre><a>function* g2() {</a> 
    yield 1; 
    yield* [2, 3, 4]; 
    yield 5; 
} 
 
var iterator = g2(); 
 
console.log(iterator.next()); // {value: 1, done: false} 
console.log(iterator.next()); // {value: 2, done: false} 
console.log(iterator.next()); // {value: 3, done: false} 
console.log(iterator.next()); // {value: 4, done: false} 
console.log(iterator.next()); // {value: 5, done: false} 
console.log(iterator.next()); // {value: undefined, done: true} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to work with functions in depth. We started with a quick recap of some basic concepts and then moved on to some lesser-known function features and use cases.</p>
<p>Once we learned how to work with functions, we focused on the use of callbacks, promises, and generators to take advantage of the asynchronous programming capabilities of TypeScript.</p>
<p>In the next chapter, we will look at how to work with classes, interfaces, and other object-oriented programming features of the TypeScript programming language.</p>


            </article>

            
        </section>
    </div>



  </body></html>