- en: The Runtime &#x2013; The Event Loop and the this Operator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时 —— 事件循环和this操作符
- en: Over the next two chapters, we are going to learn about some concepts that are
    closely related to the TypeScript runtime. TypeScript is only used at design time;
    the TypeScript code is then compiled into JavaScript and finally executed at runtime.
    The JavaScript runtime oversees the execution of the JavaScript code. It is essential
    to understand that we will never execute TypeScript code and we will always execute
    JavaScript code; for this reason, when we refer to the TypeScript runtime, we
    will, in fact, be talking about the JavaScript runtime.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将学习一些与TypeScript运行时密切相关的概念。TypeScript仅在设计时使用；TypeScript代码随后被编译成JavaScript，并在运行时执行。JavaScript运行时负责JavaScript代码的执行。我们必须理解，我们永远不会执行TypeScript代码，我们总是执行JavaScript代码；因此，当我们提到TypeScript运行时，我们实际上是在谈论JavaScript运行时。
- en: Understanding the runtime is crucial because it will help us to understand the
    implementation of a number of functional programming techniques that we will explore
    later in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解运行时至关重要，因为它将帮助我们理解本书后面将要探索的许多函数式编程技术的实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: The `event` loop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: The `this` operator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: this操作符
- en: Let's start by learning about the environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解环境开始。
- en: The environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境
- en: The runtime environment is one of the first things that we must think about
    before we can start developing a TypeScript application. Once we have compiled
    our TypeScript code into JavaScript, it can be executed in many different environments.
    While most of those environments will be part of a web browser such as Chrome,
    Internet Explorer, or Firefox, we might also want to be able to run our code on
    the server side or, in a desktop application, in environments such as Node.js,
    RingoJS, or Electron.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始开发TypeScript应用程序之前，我们必须首先考虑运行时环境。一旦我们将TypeScript代码编译成JavaScript，它就可以在许多不同的环境中执行。虽然这些环境中的大多数将是Web浏览器的一部分，如Chrome、Internet
    Explorer或Firefox，但我们可能还希望能够在服务器端或桌面应用程序中运行我们的代码，例如Node.js、RingoJS或Electron。
- en: It is essential to keep in mind that there are some variables and objects available
    at runtime that are environment-specific. For example, we could create a library
    and access the `document.layers` variable. While `document` is part of the W3C
    **Document Object Model** (**DOM**) standard, the `layers` property is only available
    in Internet Explorer and is not part of the W3C DOM standard.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 必须牢记，在运行时有一些变量和对象是特定于环境的。例如，我们可以创建一个库并访问`document.layers`变量。虽然`document`是W3C
    **文档对象模型**（**DOM**）标准的一部分，但`layers`属性仅在Internet Explorer中可用，并且不是W3C DOM标准的一部分。
- en: 'The *W3C* defines the DOM as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*W3C*将DOM定义为：'
- en: The Document Object Model is a platform- and language-neutral interface that
    will allow programs and scripts to dynamically access and update the content,
    structure, and style of documents. The document can be further processed, and
    the results of that processing can be incorporated back into the presented page.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型是一个平台和语言中立的接口，它将允许程序和脚本动态访问和更新文档的内容、结构和样式。文档可以进一步处理，并且处理结果可以合并回显示的页面。
- en: Similarly, we can also access a set of objects known as the **Browser Object
    Model** (**BOM**) from a web browser runtime environment. The BOM consists of
    the `navigator`, `history`, `screen`, `location`, and `document` objects, which
    are properties of the `window` object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以从浏览器运行时环境中访问一组称为**浏览器对象模型**（**BOM**）的对象。BOM包括`navigator`、`history`、`screen`、`location`和`document`对象，这些都是`window`对象的部分属性。
- en: We need to keep in mind that the DOM is only available in web browsers. If we
    want to run our application in a web browser, we will be able to access the DOM
    and BOM. However, in environments such as Node.js or RingoJS, these APIs will
    not be available since they are standalone JavaScript environments completely
    independent of a web browser. We can also find other objects in the server-side
    environments (such as `process.stdin` in Node.js) that will not be available if
    we attempt to execute our code in a web browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，DOM仅在Web浏览器中可用。如果我们想在Web浏览器中运行我们的应用程序，我们将能够访问DOM和BOM。然而，在Node.js或RingoJS等环境中，这些API将不可用，因为它们是完全独立于Web浏览器的独立JavaScript环境。我们还可以在服务器端环境中找到其他对象（例如Node.js中的`process.stdin`），如果我们尝试在Web浏览器中执行我们的代码，这些对象将不可用。
- en: 'We also need to keep in mind the existence of multiple versions of these JavaScript
    environments. In some cases, we will have to support multiple browsers and various
    versions of Node.js. The recommended practice when dealing with this problem is
    to use conditional statements that check for the availability of features:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑到这些JavaScript环境存在多个版本。在某些情况下，我们必须支持多个浏览器和Node.js的各种版本。处理此问题时推荐的做法是使用条件语句来检查功能的可用性：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is executed instead of checking the availability of an environment or
    version:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在检查环境或版本可用性之前执行的：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An excellent library is available that can help us to implement feature detection
    when developing for web browsers. The library is called **Modernizr**, and can
    be downloaded at [http://modernizr.com/](http://modernizr.com/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个出色的库可以帮助我们在为浏览器开发时实现功能检测。这个库叫做**Modernizr**，可以在[http://modernizr.com/](http://modernizr.com/)下载。
- en: Understanding the event loop
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: The TypeScript runtime (JavaScript) has a concurrency model based on an `event`
    loop. This model is quite different from the model in other languages, such as
    C or Java. Before focusing on the `event` loop itself, we must first understand
    a number of runtime concepts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript运行时（JavaScript）基于`事件循环`的并发模型。这个模型与其他语言（如C或Java）中的模型相当不同。在专注于`事件循环`本身之前，我们必须首先理解一系列运行时概念。
- en: 'What follows is a visual representation of some critical runtime concepts:
    **HEAP**, **STACK**, **QUEUE**, and **FRAME**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键运行时概念的视觉表示：**堆（HEAP**），**栈（STACK**），**队列（QUEUE**）和**帧（FRAME**）：
- en: '![](img/8e641809-0c6f-4ed4-92d5-fe712fe54760.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e641809-0c6f-4ed4-92d5-fe712fe54760.png)'
- en: We will now look at the role of each of these runtime concepts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨这些运行时概念各自的作用。
- en: Frames
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧结构
- en: A **frame** is a sequential unit of work. In the preceding diagram, frames are
    represented by the blocks inside the stack.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧**是工作的一个顺序单元。在上面的图中，帧由栈内的块表示。'
- en: 'When a `function` is invoked in JavaScript, the runtime creates a frame in
    the stack. The frame holds that function''s arguments and local variables. When
    the function returns, the frame is removed from the stack. Let''s look at an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当在JavaScript中调用`函数`时，运行时会创建一个帧在栈中。该帧包含该函数的参数和局部变量。当函数返回时，该帧将从栈中移除。让我们看一个例子：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After declaring the `foo` and `bar` functions, we invoke the `bar` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了`foo`和`bar`函数之后，我们调用`bar`函数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the `bar` function is executed, the runtime will create a new frame containing
    the arguments of `bar` and all its local variables (`b` and `localBarValue`).
    The frame (represented as a black square in the preceding diagram) is then added
    to the top of the stack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当`bar`函数执行时，运行时将创建一个新的帧，包含`bar`的参数以及所有局部变量（`b`和`localBarValue`）。然后，该帧（在上面的图中表示为黑色方块）被添加到栈的顶部。
- en: Internally, the `bar` function invokes the `foo` function. When `foo` is invoked,
    a new frame is created and allocated to the top of the stack. When the execution
    of `foo` is finished (`foo` has returned), the top frame is removed from the stack.
    When the execution of `bar` is also completed, it is removed from the stack as
    well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`bar`函数调用了`foo`函数。当`foo`被调用时，会创建一个新的帧并将其分配到栈的顶部。当`foo`的执行完成（`foo`已返回）时，顶部帧将从栈中移除。当`bar`的执行也完成时，它也将从栈中移除。
- en: 'Now, let''s imagine what would happen if the `foo` function invoked the `bar`
    function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下如果`foo`函数调用了`bar`函数会发生什么：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet creates a never-ending `function call` loop. With
    each function call, a new frame is added to the stack, and eventually there will
    be no more space in the stack and an error will be thrown. Most software engineers
    are familiar with this error, known as a **stack overflow** error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个永无止境的`函数调用`循环。每次函数调用都会向栈中添加一个新的帧，最终栈中将没有更多空间，并会抛出错误。大多数软件工程师都熟悉这种错误，称为**栈溢出（stack
    overflow）**错误。
- en: Stack
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: The **stack** contains sequential steps (frames). A stack is a data structure
    that represents a simple **Last-in-first-out** (**LIFO**) collection of objects.
    Therefore, when a frame is added to the stack, it is always added to the top of
    the stack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**包含顺序步骤（帧）。栈是一种表示简单**后进先出（Last-in-first-out，LIFO）**对象集合的数据结构。因此，当帧被添加到栈中时，它总是被添加到栈的顶部。'
- en: Since the stack is a LIFO collection, the `event` loop processes the frames
    stored in it from top to bottom. The dependencies of a frame are added to the
    top of it in the stack to ensure that all the dependencies of each of the frames
    are met.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **queue** contains a list of waiting to be processed. Each is associated
    with a function. When the stack is empty, a message is taken out of the queue
    and processed. The processing consists of calling the associated function and
    adding the frames to the stack. Message processing ends when the stack becomes
    empty again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In the previous runtime diagram, the blocks inside the queue represent the messages.
    The messages are usually generated by user or applications events. For example,
    when the user clicks in an element with an event handler, a new message is added
    to the queue.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **heap** is a memory container that is not aware of the order of the items
    stored in it. The heap contains all the variables and objects currently in use.
    It may also contain frames that are currently out of scope but have not yet been
    removed from the memory by the garbage collector.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The event loop
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency is the ability to execute two or more operations simultaneously.
    The JavaScript runtime execution takes place on a single thread, which means that
    we cannot achieve real concurrency.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The **event loop** follows a run-to-completion approach, which means that it
    will process a message from beginning to end before any other message is processed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 3](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml), *Mastering
    Asynchronous Programming*, we can use the `yield` keyword and generators to pause
    the execution of a function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Every time a function is invoked, a new message is added to the queue. If the
    stack is empty, the function is processed (the frames are added to the stack).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: When all the frames have been added to the stack, the stack is cleared from
    top to bottom. At the end of the process, the stack is empty, and the next message
    is processed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Web workers can perform background tasks in a different thread. They have their
    queue, heap, and stack.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of the `event` loop is that the execution order is quite
    predictable and easy to follow. A disadvantage of this approach is that, if a
    message takes too long to complete, the application becomes unresponsive. A good
    practice to follow is to make message processing short and, if possible, split
    one message into several messages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js runtime features a non-blocking I/O model in combination with a
    single-thread event loop model, which means that, when the application is waiting
    for an I/O operation to finish, it can still process other things, such as user
    input.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The this operator
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, the `this` operator behaves a little differently compared to
    other languages. The value of the `this` operator is often determined by the way
    a function is invoked. Its value cannot be set by assignment during execution,
    and it may be different each time a function is invoked.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`this` 操作符的行为与其他语言略有不同。`this` 操作符的值通常由函数的调用方式决定。它的值在执行期间不能通过赋值来设置，并且每次函数调用时可能不同。
- en: The `this` operator also has some differences when using **strict** and **non-strict**
    modes. ECMAScript 5's strict mode is a way to opt into a restricted variant of
    JavaScript. You can learn more about strict mode at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **strict** 和 **non-strict** 模式时，`this` 操作符也有一些不同之处。ECMAScript 5 的严格模式是一种选择进入
    JavaScript 限制变体的方式。您可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
    上了解更多关于严格模式的信息。
- en: The this operator in the global context
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局上下文中的 this 操作符
- en: 'In the global context, the `this` operator will always point to the global
    object. In a web browser, the `window` object is the global object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局上下文中，`this` 操作符始终指向全局对象。在网页浏览器中，`window` 对象是全局对象：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding example should be implemented using JavaScript. The preceding
    code will fail in TypeScript if the `strict` compilation flag is enabled because
    the `strict` flag enables the `noImplicitThis `flag, which prevents us from using
    the `this` operator in a scope in which its value is not clear, such as a global
    scope.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 JavaScript 实现。如果启用了 `strict` 编译标志，TypeScript 中的前述代码将失败，因为 `strict`
    标志启用了 `noImplicitThis` 标志，这阻止我们在值不明确的范围内使用 `this` 操作符，例如全局范围。
- en: The this operator in the function context
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数上下文中的 this 操作符
- en: 'The value of `this` inside a function depends on how the function is invoked.
    If we invoke a function in non-strict mode, the value of `this` within the function
    will point to the global object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部 `this` 的值取决于函数的调用方式。如果我们以非严格模式调用一个函数，函数内部的 `this` 值将指向全局对象：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding example should be implemented using JavaScript. The preceding
    code will fail in TypeScript when the `strict` compilation flag is enabled because
    it also enables the `noImplicitThis` flag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 JavaScript 实现。如果启用了 `strict` 编译标志，TypeScript 中的前述代码将失败，因为它也启用了 `noImplicitThis`
    标志。
- en: 'However, if we invoke a function in strict mode, the value of `this` within
    the function''s body will be `undefined`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们以严格模式调用一个函数，函数体内的 `this` 值将是 `undefined`：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example should be implemented using JavaScript.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 JavaScript 实现。
- en: 'However, the value of the `this` operator inside a function invoked as an instance
    method points to the instance. In other words, the value of the `this` operator
    within a function that is part of a class (a method) points to the class instance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在作为实例方法调用的函数内部，`this` 操作符的值指向实例。换句话说，在类（一个方法）中的函数内部的 `this` 操作符的值指向类实例：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example should be implemented using JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 JavaScript 实现。
- en: 'In the preceding example, we have used object literal notation to define an
    object named `person`, but the same applies when declaring objects using classes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述示例中，我们使用了对象字面量表示法来定义一个名为 `person` 的对象，但使用类声明对象时也适用：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding example should be implemented using TypeScript.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 TypeScript 实现。
- en: 'At runtime, classes are implemented (using what are known as prototypes) as
    a prototype chain. Don''t worry if you don''t know much about prototypes because
    we will learn more about them in the next chapter. All we need to know for now
    is that the behavior described in the preceding section takes place when working
    with prototypes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，类（使用所谓的原型）作为原型链实现。如果您对原型了解不多，请不要担心，因为我们在下一章中会了解更多关于它们的内容。现在我们只需要知道，前述章节中描述的行为是在与原型一起工作时发生的：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding example should be implemented using JavaScript.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 JavaScript 实现。
- en: 'When a function is used as a constructor (with the `new` keyword), the `this`
    operator points to the object being constructed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数用作构造函数（使用 `new` 关键字）时，`this` 操作符指向正在构造的对象：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding example should be implemented using JavaScript.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例应该使用 JavaScript 实现。
- en: The call, apply, and bind methods
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: call、apply 和 bind 方法
- en: All functions inherit the `call`, `apply`, and `bind` methods from `Function.prototype`.
    We can use these methods to set the value of `this`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数都从`Function.prototype`继承了`call`、`apply`和`bind`方法。我们可以使用这些方法来设置`this`的值。
- en: The `call` and `apply` methods are almost identical; both methods allow us to
    invoke a function and set the value of the `this` operator within the function.
    The main difference between `call` and `apply` is that, while `apply` lets us
    invoke the function with arguments as an array, `call` requires that function
    parameters be listed explicitly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`和`apply`方法几乎相同；两种方法都允许我们调用一个函数并在函数内部设置`this`操作符的值。`call`和`apply`之间的主要区别在于，虽然`apply`允许我们将参数作为数组传递给函数，但`call`要求显式列出函数参数。'
- en: A useful mnemonic is A (apply) for an array and C (call) for a comma.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的记忆法是A（apply）代表数组，C（call）代表逗号。
- en: 'Let''s look at an example. We will start by declaring a class named `Person`.
    This class has two properties (`name` and `surname`) and one method (`greet`).
    The `greet` method uses the `this` operator to access the `name` and `surname`
    instance properties:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们首先声明一个名为`Person`的类。这个类有两个属性（`name`和`surname`）和一个方法（`greet`）。`greet`方法使用`this`操作符来访问实例属性`name`和`surname`：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After declaring the `Person` class, we will create an instance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了`Person`类之后，我们将创建一个实例：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we invoke the `greet` method, it will work as expected:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`greet`方法，它将按预期工作：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, we can invoke the method using the `call` and `apply` functions.
    We have supplied the `person` object as the first parameter of both functions
    because we want the `this` operator (inside the `greet` method) to take `person`
    as its value:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`call`和`apply`函数来调用该方法。我们在两个函数中都提供了`person`对象作为第一个参数，因为我们想让`this`操作符（在`greet`方法内部）将`person`作为其值：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we provide a different value to be used as the value of `this`, we will
    not be able to access the `name` and `surname` properties within the `greet` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供一个不同的值作为`this`的值，我们就无法在`greet`函数内访问`name`和`surname`属性：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The two preceding examples may seem useless because the first one invoked the
    function directly and the second one caused unexpected behavior. The `apply` and
    `call` methods only make sense when we want the `this` operator to take a different
    value when a function is invoked:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个例子可能看起来没有用，因为第一个直接调用了函数，而第二个导致了意外的行为。`apply`和`call`方法只有在我们需要在函数调用时让`this`操作符取不同的值时才有意义：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `bind` method can be used to set the value of the `this` operator (within
    a function), regardless of how it is invoked.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`方法可以用来设置`this`操作符（在函数内部）的值，无论它是如何被调用的。'
- en: When we invoke a function's `bind` method, it returns a new function with the
    same body and scope as the original function, but the `this` operator (within
    the body function) is permanently bound to the first argument of `bind`, regardless
    of how the function is being used.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个函数的`bind`方法时，它返回一个与原始函数具有相同主体和作用域的新函数，但`this`操作符（在主体函数内部）将永久绑定到`bind`的第一个参数，无论函数是如何被使用的。
- en: 'Let''s look at an example. We will start by creating an instance of the `Person`
    class that we declared in the previous example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们首先将创建一个实例，这个实例是我们之前声明的`Person`类：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we can use `bind` to set the `greet` function as a new function with the
    same scope and body:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`bind`将`greet`函数设置为具有相同作用域和主体的新函数：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we try to invoke the `greet` function using `bind` and `apply`, just like
    we did in the previous example, we will be able to observe that, this time, the
    `this` operator will always point to the object instance, irrespective of how
    the function is invoked:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`bind`和`apply`调用`greet`函数，就像我们之前的例子中做的那样，我们将能够观察到，这次`this`操作符将始终指向对象实例，无论函数是如何被调用的：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `apply`, `call`, and `bind` methods is not recommended unless you
    are very familiar with what you are doing, because they can result in other developers
    encountering complex and hard-to-debug runtime issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你非常熟悉你在做什么，否则不建议使用`apply`、`call`和`bind`方法，因为它们可能会导致其他开发者遇到复杂且难以调试的运行时问题。
- en: 'Once we bind an object to a function with `bind`, we cannot override it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用`bind`将一个对象绑定到一个函数上，我们就不能覆盖它：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The use of `bind`, `apply`, and `call` is discouraged in JavaScript because
    it can lead to confusion. Modifying the default behavior of the `this` operator
    can lead to unexpected results. Remember to use these methods only when strictly
    necessary and to document your code correctly to reduce the risk caused by potential
    maintainability issues. However, TypeScript 3.2.0 introduces a new compilation
    flag, known as `strictBindCallApply`, that makes the `bind`, `apply`, and `call` methods
    safer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，不建议使用`bind`、`apply`和`call`方法，因为这可能会导致混淆。修改`this`操作符的默认行为可能会导致意外结果。请记住，只有在绝对必要时才使用这些方法，并正确记录代码，以减少由潜在的可维护性问题引起的风险。然而，TypeScript
    3.2.0引入了一个新的编译标志，称为`strictBindCallApply`，这使得`bind`、`apply`和`call`方法更安全。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned some fundamental aspects of the TypeScript
    and JavaScript runtime. We have learned that a potential differences lies in the
    execution environments of web browsers and platforms such as Node.js. We have
    also learned the functions are processed and executed by the `event` loop and
    how the value of the `this` operator can change in different contexts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了TypeScript和JavaScript运行时的基本方面。我们了解到，潜在的区别在于网络浏览器和Node.js等平台的执行环境。我们还学习了函数是如何通过`event`循环进行处理和执行的，以及`this`操作符的值在不同上下文中如何变化。
- en: In the next chapter, we will learn more about the runtime, and we will explore
    closures and prototypes. We will then be fully ready to delve into the implementation
    of a wide variety of functional programming techniques.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于运行时的知识，我们将探讨闭包和原型。然后我们将完全准备好深入研究各种函数式编程技术的实现。
