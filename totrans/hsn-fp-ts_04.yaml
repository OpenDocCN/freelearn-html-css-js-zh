- en: The Runtime &#x2013; The Event Loop and the this Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the next two chapters, we are going to learn about some concepts that are
    closely related to the TypeScript runtime. TypeScript is only used at design time;
    the TypeScript code is then compiled into JavaScript and finally executed at runtime.
    The JavaScript runtime oversees the execution of the JavaScript code. It is essential
    to understand that we will never execute TypeScript code and we will always execute
    JavaScript code; for this reason, when we refer to the TypeScript runtime, we
    will, in fact, be talking about the JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the runtime is crucial because it will help us to understand the
    implementation of a number of functional programming techniques that we will explore
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `event` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by learning about the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The runtime environment is one of the first things that we must think about
    before we can start developing a TypeScript application. Once we have compiled
    our TypeScript code into JavaScript, it can be executed in many different environments.
    While most of those environments will be part of a web browser such as Chrome,
    Internet Explorer, or Firefox, we might also want to be able to run our code on
    the server side or, in a desktop application, in environments such as Node.js,
    RingoJS, or Electron.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to keep in mind that there are some variables and objects available
    at runtime that are environment-specific. For example, we could create a library
    and access the `document.layers` variable. While `document` is part of the W3C
    **Document Object Model** (**DOM**) standard, the `layers` property is only available
    in Internet Explorer and is not part of the W3C DOM standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *W3C* defines the DOM as:'
  prefs: []
  type: TYPE_NORMAL
- en: The Document Object Model is a platform- and language-neutral interface that
    will allow programs and scripts to dynamically access and update the content,
    structure, and style of documents. The document can be further processed, and
    the results of that processing can be incorporated back into the presented page.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can also access a set of objects known as the **Browser Object
    Model** (**BOM**) from a web browser runtime environment. The BOM consists of
    the `navigator`, `history`, `screen`, `location`, and `document` objects, which
    are properties of the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep in mind that the DOM is only available in web browsers. If we
    want to run our application in a web browser, we will be able to access the DOM
    and BOM. However, in environments such as Node.js or RingoJS, these APIs will
    not be available since they are standalone JavaScript environments completely
    independent of a web browser. We can also find other objects in the server-side
    environments (such as `process.stdin` in Node.js) that will not be available if
    we attempt to execute our code in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to keep in mind the existence of multiple versions of these JavaScript
    environments. In some cases, we will have to support multiple browsers and various
    versions of Node.js. The recommended practice when dealing with this problem is
    to use conditional statements that check for the availability of features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is executed instead of checking the availability of an environment or
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An excellent library is available that can help us to implement feature detection
    when developing for web browsers. The library is called **Modernizr**, and can
    be downloaded at [http://modernizr.com/](http://modernizr.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript runtime (JavaScript) has a concurrency model based on an `event`
    loop. This model is quite different from the model in other languages, such as
    C or Java. Before focusing on the `event` loop itself, we must first understand
    a number of runtime concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is a visual representation of some critical runtime concepts:
    **HEAP**, **STACK**, **QUEUE**, and **FRAME**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e641809-0c6f-4ed4-92d5-fe712fe54760.png)'
  prefs: []
  type: TYPE_IMG
- en: We will now look at the role of each of these runtime concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **frame** is a sequential unit of work. In the preceding diagram, frames are
    represented by the blocks inside the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a `function` is invoked in JavaScript, the runtime creates a frame in
    the stack. The frame holds that function''s arguments and local variables. When
    the function returns, the frame is removed from the stack. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `foo` and `bar` functions, we invoke the `bar` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the `bar` function is executed, the runtime will create a new frame containing
    the arguments of `bar` and all its local variables (`b` and `localBarValue`).
    The frame (represented as a black square in the preceding diagram) is then added
    to the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the `bar` function invokes the `foo` function. When `foo` is invoked,
    a new frame is created and allocated to the top of the stack. When the execution
    of `foo` is finished (`foo` has returned), the top frame is removed from the stack.
    When the execution of `bar` is also completed, it is removed from the stack as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine what would happen if the `foo` function invoked the `bar`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a never-ending `function call` loop. With
    each function call, a new frame is added to the stack, and eventually there will
    be no more space in the stack and an error will be thrown. Most software engineers
    are familiar with this error, known as a **stack overflow** error.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **stack** contains sequential steps (frames). A stack is a data structure
    that represents a simple **Last-in-first-out** (**LIFO**) collection of objects.
    Therefore, when a frame is added to the stack, it is always added to the top of
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Since the stack is a LIFO collection, the `event` loop processes the frames
    stored in it from top to bottom. The dependencies of a frame are added to the
    top of it in the stack to ensure that all the dependencies of each of the frames
    are met.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **queue** contains a list of waiting to be processed. Each is associated
    with a function. When the stack is empty, a message is taken out of the queue
    and processed. The processing consists of calling the associated function and
    adding the frames to the stack. Message processing ends when the stack becomes
    empty again.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous runtime diagram, the blocks inside the queue represent the messages.
    The messages are usually generated by user or applications events. For example,
    when the user clicks in an element with an event handler, a new message is added
    to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **heap** is a memory container that is not aware of the order of the items
    stored in it. The heap contains all the variables and objects currently in use.
    It may also contain frames that are currently out of scope but have not yet been
    removed from the memory by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency is the ability to execute two or more operations simultaneously.
    The JavaScript runtime execution takes place on a single thread, which means that
    we cannot achieve real concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The **event loop** follows a run-to-completion approach, which means that it
    will process a message from beginning to end before any other message is processed.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 3](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml), *Mastering
    Asynchronous Programming*, we can use the `yield` keyword and generators to pause
    the execution of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a function is invoked, a new message is added to the queue. If the
    stack is empty, the function is processed (the frames are added to the stack).
  prefs: []
  type: TYPE_NORMAL
- en: When all the frames have been added to the stack, the stack is cleared from
    top to bottom. At the end of the process, the stack is empty, and the next message
    is processed.
  prefs: []
  type: TYPE_NORMAL
- en: Web workers can perform background tasks in a different thread. They have their
    queue, heap, and stack.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of the `event` loop is that the execution order is quite
    predictable and easy to follow. A disadvantage of this approach is that, if a
    message takes too long to complete, the application becomes unresponsive. A good
    practice to follow is to make message processing short and, if possible, split
    one message into several messages.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js runtime features a non-blocking I/O model in combination with a
    single-thread event loop model, which means that, when the application is waiting
    for an I/O operation to finish, it can still process other things, such as user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: The this operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, the `this` operator behaves a little differently compared to
    other languages. The value of the `this` operator is often determined by the way
    a function is invoked. Its value cannot be set by assignment during execution,
    and it may be different each time a function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` operator also has some differences when using **strict** and **non-strict**
    modes. ECMAScript 5's strict mode is a way to opt into a restricted variant of
    JavaScript. You can learn more about strict mode at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
  prefs: []
  type: TYPE_NORMAL
- en: The this operator in the global context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the global context, the `this` operator will always point to the global
    object. In a web browser, the `window` object is the global object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using JavaScript. The preceding
    code will fail in TypeScript if the `strict` compilation flag is enabled because
    the `strict` flag enables the `noImplicitThis `flag, which prevents us from using
    the `this` operator in a scope in which its value is not clear, such as a global
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: The this operator in the function context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The value of `this` inside a function depends on how the function is invoked.
    If we invoke a function in non-strict mode, the value of `this` within the function
    will point to the global object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using JavaScript. The preceding
    code will fail in TypeScript when the `strict` compilation flag is enabled because
    it also enables the `noImplicitThis` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we invoke a function in strict mode, the value of `this` within
    the function''s body will be `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the value of the `this` operator inside a function invoked as an instance
    method points to the instance. In other words, the value of the `this` operator
    within a function that is part of a class (a method) points to the class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we have used object literal notation to define an
    object named `person`, but the same applies when declaring objects using classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, classes are implemented (using what are known as prototypes) as
    a prototype chain. Don''t worry if you don''t know much about prototypes because
    we will learn more about them in the next chapter. All we need to know for now
    is that the behavior described in the preceding section takes place when working
    with prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is used as a constructor (with the `new` keyword), the `this`
    operator points to the object being constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be implemented using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The call, apply, and bind methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All functions inherit the `call`, `apply`, and `bind` methods from `Function.prototype`.
    We can use these methods to set the value of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: The `call` and `apply` methods are almost identical; both methods allow us to
    invoke a function and set the value of the `this` operator within the function.
    The main difference between `call` and `apply` is that, while `apply` lets us
    invoke the function with arguments as an array, `call` requires that function
    parameters be listed explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A useful mnemonic is A (apply) for an array and C (call) for a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will start by declaring a class named `Person`.
    This class has two properties (`name` and `surname`) and one method (`greet`).
    The `greet` method uses the `this` operator to access the `name` and `surname`
    instance properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `Person` class, we will create an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke the `greet` method, it will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can invoke the method using the `call` and `apply` functions.
    We have supplied the `person` object as the first parameter of both functions
    because we want the `this` operator (inside the `greet` method) to take `person`
    as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we provide a different value to be used as the value of `this`, we will
    not be able to access the `name` and `surname` properties within the `greet` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The two preceding examples may seem useless because the first one invoked the
    function directly and the second one caused unexpected behavior. The `apply` and
    `call` methods only make sense when we want the `this` operator to take a different
    value when a function is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `bind` method can be used to set the value of the `this` operator (within
    a function), regardless of how it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke a function's `bind` method, it returns a new function with the
    same body and scope as the original function, but the `this` operator (within
    the body function) is permanently bound to the first argument of `bind`, regardless
    of how the function is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will start by creating an instance of the `Person`
    class that we declared in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use `bind` to set the `greet` function as a new function with the
    same scope and body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to invoke the `greet` function using `bind` and `apply`, just like
    we did in the previous example, we will be able to observe that, this time, the
    `this` operator will always point to the object instance, irrespective of how
    the function is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the `apply`, `call`, and `bind` methods is not recommended unless you
    are very familiar with what you are doing, because they can result in other developers
    encountering complex and hard-to-debug runtime issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we bind an object to a function with `bind`, we cannot override it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The use of `bind`, `apply`, and `call` is discouraged in JavaScript because
    it can lead to confusion. Modifying the default behavior of the `this` operator
    can lead to unexpected results. Remember to use these methods only when strictly
    necessary and to document your code correctly to reduce the risk caused by potential
    maintainability issues. However, TypeScript 3.2.0 introduces a new compilation
    flag, known as `strictBindCallApply`, that makes the `bind`, `apply`, and `call` methods
    safer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned some fundamental aspects of the TypeScript
    and JavaScript runtime. We have learned that a potential differences lies in the
    execution environments of web browsers and platforms such as Node.js. We have
    also learned the functions are processed and executed by the `event` loop and
    how the value of the `this` operator can change in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about the runtime, and we will explore
    closures and prototypes. We will then be fully ready to delve into the implementation
    of a wide variety of functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
