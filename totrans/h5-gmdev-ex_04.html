<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Building the Untangle Game with Canvas and the Drawing API</h1></div></div></div><p>
<em>One new highlighted feature in HTML5 is the <code class="literal">canvas</code> element. We can treat it as a dynamic area where we can draw graphics and shapes with scripts.</em>
</p><p>
<em>Images in websites have been static for years. There are animated GIFs, but they cannot interact with visitors. Canvas is dynamic. We draw and modify the context in the Canvas, dynamically through the JavaScript drawing API. We can also add interaction to the Canvas and thus make games.</em>
</p><p>In the previous two chapters, we discussed DOM-based game development with CSS3 and a few HTML5 features. In the coming two chapters, we will focus on using new HTML5 features to create games. In this chapter, we will take a look at a core feature, Canvas, and some basic drawing techniques.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing the HTML5 <code class="literal">canvas</code> element</li><li class="listitem" style="list-style-type: disc">Drawing a circle in Canvas</li><li class="listitem" style="list-style-type: disc">Drawing lines in the <code class="literal">canvas</code> element</li><li class="listitem" style="list-style-type: disc">Interacting with drawn objects in Canvas with mouse events</li><li class="listitem" style="list-style-type: disc">Detecting a line intersection</li><li class="listitem" style="list-style-type: disc">Supporting the drag-n-drop feature in touch devices</li></ul></div><p>The Untangle puzzle game<a id="id280" class="indexterm"/> is a game where players are given circles with some lines connecting them. The lines may intersect the others and the players need to drag the circles so that no line intersects anymore.</p><p>The following screenshot previews the game that we are going to achieve through this chapter:</p><div><img src="img/B04290_04_01.jpg" alt="Building the Untangle Game with Canvas and the Drawing API"/></div><p>You can also try the <a id="id281" class="indexterm"/>game at the following URL:</p><p>
<a class="ulink" href="http://makzan.net/html5-games/untangle-wip-dragging/">http://makzan.net/html5-games/untangle-wip-dragging/</a>
</p><p>So let's start making our Canvas game from scratch.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Introducing the HTML5 canvas element</h1></div></div></div><p>W3C community states that the<a id="id282" class="indexterm"/> <code class="literal">canvas</code> element and the drawing functions are as follows:</p><div><blockquote class="blockquote"><p><em>A resolution-dependent bitmap canvas, which can be used for rendering graphs, game graphics, or other visual images on the fly.</em></p></blockquote></div><p>The <code class="literal">canvas</code> element contains context for drawing and the actual graphics and shapes are drawn by the JavaScript drawing API. There is one key difference between using <code class="literal">canvas</code> and the usual HTML DOM elements. Canvas is an immediate mode while DOM is a retained mode. We describe the DOM tree with elements and attributes, and the browser renders and tracks the objects for us. In Canvas, we have to manage all the attributes and rendering ourselves. The<a id="id283" class="indexterm"/> browser doesn't keep the information of what we draw. It only keeps the drawn pixel data.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Drawing a circle in the Canvas</h1></div></div></div><p>Let's start our drawing in the <a id="id284" class="indexterm"/>Canvas<a id="id285" class="indexterm"/> from the basic shape—circle.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Time for action – drawing color circles in the Canvas</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">First, let's set up the new<a id="id286" class="indexterm"/> environment for the <a id="id287" class="indexterm"/>example. That is, an HTML file that will contain the <code class="literal">canvas</code> element, a jQuery library to help us in JavaScript, a JavaScript file containing the actual drawing logic, and a style sheet:<div><pre class="programlisting">index.html
js/
  js/jquery-2.1.3.js
  js/untangle.js
  js/untangle.drawing.js
  js/untangle.data.js
  js/untangle.input.js
css/
  css/untangle.css
images/</pre></div></li><li class="listitem">Put the following HTML code into the <code class="literal">index.html</code> file. It is a basic HTML document containing the <code class="literal">canvas</code> element:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Drawing Circles in Canvas&lt;/title&gt;
  &lt;link rel="stylesheet" href="css/untangle.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;header&gt;
    &lt;h1&gt;Drawing in Canvas&lt;/h1&gt;
  &lt;/header&gt;  
  
  &lt;canvas id="game" width="768" height="400"&gt;
    This is an interactive game with circles and lines connecting them.
  &lt;/canvas&gt;
  
&lt;script src="img/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
&lt;script src="img/untangle.data.js"&gt;&lt;/script&gt;
&lt;script src="img/untangle.drawing.js"&gt;&lt;/script&gt;
&lt;script src="img/untangle.input.js"&gt;&lt;/script&gt;
&lt;script src="img/untangle.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Use CSS to set the<a id="id288" class="indexterm"/> background color of the Canvas <a id="id289" class="indexterm"/>inside <code class="literal">untangle.css</code>:<div><pre class="programlisting">canvas {
  background: grey;
}</pre></div></li><li class="listitem">In the <code class="literal">untangle.js</code> JavaScript file, we put a jQuery <code class="literal">document</code> <code class="literal">ready</code> function and draw a color circle inside it:<div><pre class="programlisting">$(document).ready(function(){
  var canvas = document.getElementById("game");  
  var ctx = canvas.getContext("2d");
  ctx.fillStyle = "GOLD";
  ctx.beginPath();
  ctx.arc(100, 100, 50, 0, Math.PI*2, true); 
  ctx.closePath();
  ctx.fill();
});</pre></div></li><li class="listitem">Open the <code class="literal">index.html</code> file in a web browser and we will get the following screenshot:<div><img src="img/B04290_04_02.jpg" alt="Time for action – drawing color circles in the Canvas"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec92"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have just created a <a id="id290" class="indexterm"/>simple <strong>Canvas context</strong> with circles on it. There are <a id="id291" class="indexterm"/>not many settings for the <code class="literal">canvas</code> element itself. We set the width and height of the Canvas, the same as we have fixed the dimensions of real drawing paper. Also, we assign an ID attribute to the Canvas for an easier reference in JavaScript:</p><div><pre class="programlisting">&lt;canvas id="game" width="768" height="400"&gt;
  This is an interactive game with circles and lines connecting them.
&lt;/canvas&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec93"/>Putting in fallback content when the web browser does not support the Canvas</h2></div></div></div><p>Not every web browser supports the <code class="literal">canvas</code> element. The <code class="literal">canvas</code> element provides an easy way to provide <strong>fallback content</strong>
<a id="id292" class="indexterm"/> if the <code class="literal">canvas</code> element is not supported. The content also provides meaningful information for any screen reader too. Anything inside the open and close tags of the <code class="literal">canvas</code> element is the fallback content. This content is hidden if the web browser supports the element. Browsers that don't support <code class="literal">canvas</code> will instead display that fallback content. It is good practice to provide useful information in the fallback content. For instance, if the <code class="literal">canvas</code> tag's purpose is a dynamic picture, we may consider placing an <code class="literal">&lt;img&gt;</code> alternative there. Or we may also provide some links to modern web browsers for the visitor to upgrade their browser easily.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec94"/>The Canvas context</h2></div></div></div><p>When we draw in the Canvas, we actually call the drawing API of the <a id="id293" class="indexterm"/>
<strong>canvas rendering context</strong>. You can think of the relationship of the Canvas and context as Canvas being the frame and context the real drawing surface. Currently, we have <code class="literal">2d</code>, <code class="literal">webgl</code>, and <code class="literal">webgl2</code> as the context options. In our example, we'll use the 2D drawing API by calling <code class="literal">getContext("2d")</code>.</p><div><pre class="programlisting">var canvas = document.getElementById("game");  
var ctx = canvas.getContext("2d");</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec95"/>Drawing circles and shapes with the Canvas arc function</h2></div></div></div><p>There is no circle function <a id="id294" class="indexterm"/>to draw a circle. The Canvas drawing API provides <a id="id295" class="indexterm"/>a function to draw <a id="id296" class="indexterm"/>different arcs, including <a id="id297" class="indexterm"/>the circle. The <code class="literal">arc</code> function<a id="id298" class="indexterm"/> accepts the following arguments:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Arguments</p>
</th><th style="text-align: left" valign="bottom">
<p>Discussion</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">X</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The center<a id="id299" class="indexterm"/> point of the arc in the <em>x</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Y</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id300" class="indexterm"/>center point of the arc in the <em>y</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">radius</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The radius is the <a id="id301" class="indexterm"/>distance between the center point and the arc's perimeter. When drawing a circle, a larger radius means a larger circle.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">startAngle</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The starting <a id="id302" class="indexterm"/>point is an angle in radians. It defines where to start drawing the arc on the perimeter.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">endAngle</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The ending point is<a id="id303" class="indexterm"/> an angle in radians. The arc is drawn from the position of the starting angle, to this end angle.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">counter-clockwise</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a Boolean <a id="id304" class="indexterm"/>indicating the arc from <code class="literal">startingAngle</code> to <code class="literal">endingAngle</code> drawn in a clockwise or counter-clockwise direction.</p>
<p>This is an <a id="id305" class="indexterm"/>optional argument with the default value <code class="literal">false</code>.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec96"/>Converting degrees to radians</h2></div></div></div><p>The angle arguments <a id="id306" class="indexterm"/>used in the <code class="literal">arc</code> function are in <strong>radians</strong> instead of <strong>degrees</strong>. If<a id="id307" class="indexterm"/> you are familiar with the degrees angle, you may need to convert the degrees into radians before putting the value into the arc function. We can convert the angle unit using the following formula:</p><div><pre class="programlisting">radians = π/180 x degrees</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec97"/>Executing the path drawing in the Canvas</h2></div></div></div><p>When we are calling<a id="id308" class="indexterm"/> the <code class="literal">arc</code> function or other path drawing functions, we <a id="id309" class="indexterm"/>are not drawing the path immediately in the Canvas. Instead, we are adding it into a list of the paths. These paths will not be drawn until we execute the drawing command.</p><p>There are two drawing executing commands: one command to fill the paths and the other to draw the stroke.</p><p>We fill the paths by calling the <code class="literal">fill</code> function and draw the stroke of the paths by calling the <code class="literal">stroke</code> function, which we will use later when drawing lines:</p><div><pre class="programlisting">ctx.fill();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec98"/>Beginning a path for each style</h2></div></div></div><p>The <code class="literal">fill</code> <a id="id310" class="indexterm"/>and <code class="literal">stroke</code> functions fill and<a id="id311" class="indexterm"/> draw the<a id="id312" class="indexterm"/> paths in the Canvas but do not clear the list of paths. Take <a id="id313" class="indexterm"/>the following code snippet as an example. After filling our circle with the color red, we add other circles and fill them with green. What happens to the code is both the circles are filled with green, instead of only the new circle being filled by green:</p><div><pre class="programlisting">var canvas = document.getElementById('game');  
var ctx = canvas.getContext('2d');
ctx.fillStyle = "red";
ctx.arc(100, 100, 50, 0, Math.PI*2, true); 
ctx.fill();

ctx.arc(210, 100, 50, 0, Math.PI*2, true);
ctx.fillStyle = "green";
ctx.fill();</pre></div><p>This is because, when calling the second <code class="literal">fill</code> command, the list of paths in the Canvas contains both circles. Therefore, the <code class="literal">fill</code> command fills both circles with green and overrides the red color circle.</p><p>In order to fix this issue, we<a id="id314" class="indexterm"/> want to ensure we call <code class="literal">beginPath</code> before drawing a new<a id="id315" class="indexterm"/> shape every time.</p><p>The <code class="literal">beginPath</code> function empties the list of paths, so the next time we call the <code class="literal">fill</code> and <code class="literal">stroke</code> commands, they will only apply to all paths after the last <code class="literal">beginPath</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec99"/>Have a go hero</h2></div></div></div><p>We have just discussed a code snippet where we intended to draw two circles: one in red and the other in green. The code ends up drawing both circles in green. How can we add a <code class="literal">beginPath</code> command to the code so that it draws one red circle and one green circle correctly?</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec100"/>Closing a path</h2></div></div></div><p>The <code class="literal">closePath</code> function<a id="id316" class="indexterm"/> will draw a straight line from the last point <a id="id317" class="indexterm"/>of the latest path to the first point of the path. This is called closing the path. If we are only going to fill the path and are not going to draw the stroke outline, the <code class="literal">closePath</code> function does not affect the result. The following screenshot compares the results on a half circle with one calling <code class="literal">closePath</code> and the other not calling <code class="literal">closePath</code>:</p><div><img src="img/B04290_04_03.jpg" alt="Closing a path"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec101"/>Pop quiz </h2></div></div></div><p>Q1. Do we need to use the <code class="literal">closePath</code> function on the shape we are drawing if we just want to fill the color and not draw the outline stroke?</p><div><ol class="orderedlist arabic"><li class="listitem">Yes, we need to use the <code class="literal">closePath</code> function.</li><li class="listitem">No, it does not matter whether we use the <code class="literal">closePath</code> function.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec102"/>Wrapping the circle drawing in a function</h2></div></div></div><p>Drawing a circle is a common<a id="id318" class="indexterm"/> function that we will use a lot. It is better to<a id="id319" class="indexterm"/> create a function to draw a circle now instead of entering several code lines.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Time for action – putting the circle drawing code into a function</h1></div></div></div><p>Let's make a function to <a id="id320" class="indexterm"/>draw the circle and then draw some <a id="id321" class="indexterm"/>circles in the Canvas. We are going to put code in different files to make the code simpler:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">untangle.drawing.js</code> file in our code editor and put in the following code:<div><pre class="programlisting">if (untangleGame === undefined) {
  var untangleGame = {};
}

untangleGame.drawCircle = function(x, y, radius) {
  var ctx = untangleGame.ctx;
  ctx.fillStyle = "GOLD";
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
};</pre></div></li><li class="listitem">Open the <code class="literal">untangle.data.js</code> file and put the following code into it:<div><pre class="programlisting">if (untangleGame === undefined) {
  var untangleGame = {};
}

untangleGame.createRandomCircles = function(width, height) {
  // randomly draw 5 circles
  var circlesCount = 5;
  var circleRadius = 10;
  for (var i=0;i&lt;circlesCount;i++) {
    var x = Math.random()*width;
    var y = Math.random()*height;
    untangleGame.drawCircle(x, y, circleRadius);
  }
};</pre></div></li><li class="listitem">Then open the <code class="literal">untangle.js</code> file. Replace the original code in the JavaScript file with the following code:<div><pre class="programlisting">if (untangleGame === undefined) {
  var untangleGame = {};
}

// Entry point
$(document).ready(function(){
  var canvas = document.getElementById("game");
  untangleGame.ctx = canvas.getContext("2d");

  var width = canvas.width;
  var height = canvas.height;

  untangleGame.createRandomCircles(width, height);

}); </pre></div></li><li class="listitem">Open the HTML<a id="id322" class="indexterm"/> file in the web browser to see <a id="id323" class="indexterm"/>the result:<div><img src="img/B04290_04_04.jpg" alt="Time for action – putting the circle drawing code into a function"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec103"/>
<em>What just happened?</em>
</h2></div></div></div><p>The code of drawing<a id="id324" class="indexterm"/> circles is executed after the page is <a id="id325" class="indexterm"/>loaded and ready. We used a loop to draw several circles in random places in the Canvas.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec104"/>Dividing code into files</h2></div></div></div><p>We are putting the code into <a id="id326" class="indexterm"/>different files. Currently, there are the <code class="literal">untangle.js</code>, <code class="literal">untangle.drawing.js</code>, and <code class="literal">untangle.data.js</code> files. The <code class="literal">untangle.js</code> is the entry point of <a id="id327" class="indexterm"/>the game. Then we put logic that is related to the context drawing into <code class="literal">untangle.drawing.js</code> and logic that's related to data manipulation into the <code class="literal">untangle.data.js</code> file.</p><p>We use the <code class="literal">untangleGame</code> object as the global object that's being accessed across all the files. At the beginning of each JavaScript file, we have the following code to create this object if it does not exist:</p><div><pre class="programlisting">if (untangleGame === undefined) {
  var untangleGame = {};
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec105"/>Generating random numbers in JavaScript</h2></div></div></div><p>In game development, we often <a id="id328" class="indexterm"/>use <code class="literal">random</code> functions. We may want to randomly <a id="id329" class="indexterm"/>summon a monster for the player to fight, we may want to randomly drop a reward when the player makes progress, and we may want a random number to be the result of rolling a dice. In this code, we place the circles randomly in the Canvas.</p><p>To generate a random number in JavaScript, we use the <code class="literal">Math.random()</code> function. There is no argument in the <code class="literal">random</code> function. It always returns a floating number between 0 and 1. The number is equal or bigger than 0 and smaller than 1. There are two common ways to use the <code class="literal">random</code> function. One way is to generate random numbers within a given range. The other way is generating a true or false value.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Usage</p>
</th><th style="text-align: left" valign="bottom">
<p>Code</p>
</th><th style="text-align: left" valign="bottom">
<p>Discussion</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Getting a random integer between A and B</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Math.floor(Math.random()*B)+A</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Math.floor()</code> function cuts the decimal point of the given number.</p>
<p>Take <code class="literal">Math.floor(Math.random()*10)+5</code> as an example.</p>
<p>
<code class="literal">Math.random()</code> returns a decimal number between 0 to 0.9999….</p>
<p>
<code class="literal">Math.random()*10</code> is a decimal number between 0 to 9.9999….</p>
<p>
<code class="literal">Math.floor(Math.random()*10)</code> is an integer between 0 to 9.</p>
<p>Finally, <code class="literal">Math.floor(Math.random()*10)</code> <code class="literal">+</code> <code class="literal">5</code> is an integer between 5 to 14.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Getting a random Boolean</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(Math.random() &gt; 0.495)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(Math.random()</code> <code class="literal">&gt;</code> <code class="literal">0.495)</code> means 50 percent <code class="literal">false</code> and 50 percent <code class="literal">true</code>.</p>
<p>We can further adjust the true/false ratio. <code class="literal">(Math.random()</code> <code class="literal">&gt;</code> <code class="literal">0.7)</code> means almost 70 percent <code class="literal">false</code> and 30 percent <code class="literal">true</code>.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec106"/>Saving the circle position</h2></div></div></div><p>When we are developing a <a id="id330" class="indexterm"/>DOM-based game, such as the games we built in previous chapters, we often put the game objects into DIV elements and accessed them later in code logic. It is a different story in the Canvas-based game development.</p><p>In order to access our game objects after they are drawn in the Canvas, we need to remember their states ourselves. Let's say now we want to know how many circles are drawn and where they are, and we will need an array to store their position.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Time for action – saving the circle position</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">untangle.data.js</code> file in the text editor.</li><li class="listitem">Add the following <code class="literal">circle</code> object definition code in the JavaScript file:<div><pre class="programlisting">untangleGame.Circle = function(x,y,radius){
  this.x = x;
  this.y = y;
  this.radius = radius;
}</pre></div></li><li class="listitem">Now we need an array to store the circles' positions. Add a new array to the <code class="literal">untangleGame</code> object:<div><pre class="programlisting">untangleGame.circles = [];</pre></div></li><li class="listitem">While drawing every circle in the Canvas, we save the position of the circle in the <code class="literal">circles</code> array. Add the following line before calling the <code class="literal">drawCircle</code> function, inside the <code class="literal">createRandomCircles</code> function:<div><pre class="programlisting">untangleGame.circles.push(new untangleGame.Circle(x,y,circleRadius));</pre></div></li><li class="listitem">After the steps, we <a id="id331" class="indexterm"/>should have the following code in the <code class="literal">untangle.data.js</code> file:<div><pre class="programlisting">if (untangleGame === undefined) {
  var untangleGame = {};
}

untangleGame.circles = [];

untangleGame.Circle = function(x,y,radius){
  this.x = x;
  this.y = y;
  this.radius = radius;
};

untangleGame.createRandomCircles = function(width, height) {
  // randomly draw 5 circles
  var circlesCount = 5;
  var circleRadius = 10;
  for (var i=0;i&lt;circlesCount;i++) {
    var x = Math.random()*width;
    var y = Math.random()*height;
    untangleGame.circles.push(new untangleGame.Circle(x,y,circleRadius));
    untangleGame.drawCircle(x, y, circleRadius);
  }
};</pre></div></li><li class="listitem">Now we can test the code in the web browser. There is no visual difference between this code and the last example when drawing random circles in the Canvas. This is because we are saving the circles but have not changed any code that affects the appearance. We just make sure it looks the same and there are no new errors.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec107"/>
<em>What just happened?</em>
</h2></div></div></div><p>We saved the position and <a id="id332" class="indexterm"/>radius of each circle. This is because Canvas drawing is an immediate mode. We cannot directly access the object drawn in the Canvas because there is no such information. All lines and shapes are drawn on the Canvas as pixels and we cannot access the lines or shapes as individual objects. Imagine that we are drawing on a real canvas. We cannot just move a house in an oil painting, and in the same way we cannot directly manipulate any drawn items in the <code class="literal">canvas</code> element.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec108"/>Defining a basic class definition in JavaScript</h2></div></div></div><p>We can use <strong>object-oriented programming</strong>
<a id="id333" class="indexterm"/> in JavaScript. We can define some <a id="id334" class="indexterm"/>object structures for <a id="id335" class="indexterm"/>our use. The <code class="literal">Circle</code> object provides a data structure for us to easily store a collection of <em>x</em> and <em>y</em> positions and the radii.</p><p>After defining the <code class="literal">Circle</code> object, we can create a new <code class="literal">Circle</code> instance with an <em>x</em>, <em>y</em>, and radius value using the following code:</p><div><pre class="programlisting">var circle1 = new Circle(100, 200, 10);</pre></div><div><div><h3 class="title"><a id="note14"/>Note</h3><p>For more detailed usage on <a id="id336" class="indexterm"/>object-oriented programming in JavaScript, please check out the Mozilla Developer Center at the following link:</p><p>
<a class="ulink" href="https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript">https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript</a>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec109"/>Have a go hero </h2></div></div></div><p>We have drawn several circles randomly on the Canvas. They are in the same style and of the same size. How about we randomly draw the size of the circles? And fill the circles with different colors? Try modifying the code and then play with the drawing API.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Drawing lines in the Canvas</h1></div></div></div><p>Now we have several circles here, so <a id="id337" class="indexterm"/>how about connecting them with lines? Let's draw a <a id="id338" class="indexterm"/>straight line between each circle.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Time for action – drawing straight lines between each circle</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">index.html</code> file we<a id="id339" class="indexterm"/> just used in the circle-drawing<a id="id340" class="indexterm"/> example.</li><li class="listitem">Change the wording in h1 from <strong>drawing circles in Canvas</strong> to <strong>drawing lines in Canvas</strong>.</li><li class="listitem">Open the <code class="literal">untangle.data.js</code> JavaScript file.</li><li class="listitem">We define a <code class="literal">Line</code> class to store the information that we need for each line:<div><pre class="programlisting">untangleGame.Line = function(startPoint, endPoint, thickness) {
  this.startPoint = startPoint;
  this.endPoint = endPoint;
  this.thickness = thickness;
}</pre></div></li><li class="listitem">Save the file and switch to the <code class="literal">untangle.drawing.js</code> file.</li><li class="listitem">We need two more variables. Add the following lines into the JavaScript file:<div><pre class="programlisting">untangleGame.thinLineThickness = 1;
untangleGame.lines = [];</pre></div></li><li class="listitem">We add the following <code class="literal">drawLine</code> function into our code, after the existing <code class="literal">drawCircle</code> function in the <code class="literal">untangle.drawing.js</code> file.<div><pre class="programlisting">untangleGame.drawLine = function(ctx, x1, y1, x2, y2, thickness) {    
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.lineWidth = thickness;
  ctx.strokeStyle = "#cfc";
  ctx.stroke();
}</pre></div></li><li class="listitem">Then we define a new function that iterates the circle list and draws a line between each pair of circles. Append the following code in the JavaScript file:<div><pre class="programlisting">untangleGame.connectCircles = function() {
  // connect the circles to each other with lines
  untangleGame.lines.length = 0;
  for (var i=0;i&lt; untangleGame.circles.length;i++) {
    var startPoint = untangleGame.circles[i];
    for(var j=0;j&lt;i;j++) {
      var endPoint = untangleGame.circles[j];
      untangleGame.drawLine(startPoint.x, startPoint.y, endPoint.x,
      endPoint.y, 1);
      untangleGame.lines.push(new untangleGame.Line(startPoint, endPoint,
      untangleGame.thinLineThickness));
    }
  }
};</pre></div></li><li class="listitem">Finally, we open the <code class="literal">untangle.js</code> file, and add the following code before the end of the jQuery document <code class="literal">ready</code> function, after we have called the <code class="literal">untangleGame.createRandomCircles</code> function:<div><pre class="programlisting">untangleGame.connectCircles();</pre></div></li><li class="listitem">Test the code<a id="id341" class="indexterm"/> in the web browser. We <a id="id342" class="indexterm"/>should see there are lines connected to each randomly placed circle:<div><img src="img/B04290_04_05.jpg" alt="Time for action – drawing straight lines between each circle"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec110"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have enhanced our code with lines connecting each generated circle. You may find a working example at the following URL:</p><p>
<a class="ulink" href="http://makzan.net/html5-games/untangle-wip-connect-lines/">http://makzan.net/html5-games/untangle-wip-connect-lines/</a>
</p><p>Similar to the way we saved the circle position, we have an array to save every line segment we draw. We declare a line class definition to store some essential information of a line segment. That is, we save the start and end point and the thickness of the line.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec111"/>Introducing the line drawing API</h2></div></div></div><p>There are some drawing <a id="id343" class="indexterm"/>APIs for us to draw and style the line stroke:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Line drawing functions</p>
</th><th style="text-align: left" valign="bottom">
<p>Discussion</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">moveTo</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">moveTo</code> function<a id="id344" class="indexterm"/> is like holding a pen in our hand and moving it on top of the paper without touching it with the pen.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lineTo</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This function <a id="id345" class="indexterm"/>is like putting the pen down on the paper and drawing a straight line to the destination point.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lineWidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">lineWidth</code> function sets the<a id="id346" class="indexterm"/> thickness of the strokes we draw afterwards.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">stroke</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">stroke</code> function<a id="id347" class="indexterm"/> is used to execute the drawing. We set up a collection of <code class="literal">moveTo</code>, <code class="literal">lineTo</code>, or styling functions and finally call the <code class="literal">stroke</code> function to execute it on the Canvas.</p>
</td></tr></tbody></table></div><p>We usually draw lines by using the <code class="literal">moveTo</code> and <code class="literal">lineTo</code> pairs. Just like in the real world, we move our pen on top of the paper to the starting point of a line and put down the pen to draw a line. Then, keep on drawing another line or move to the other position before drawing. This is exactly the flow in which we draw lines on the Canvas.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>We just demonstrated how to draw a simple line. We can set different line styles to lines in the Canvas. For more details on line styling, please read the styling guide<a id="id348" class="indexterm"/> in W3C at <a class="ulink" href="http://www.w3.org/TR/2dcontext/#line-styles">http://www.w3.org/TR/2dcontext/#line-styles</a> and the Mozilla Developer Center at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Using mouse events to interact with objects drawn in the Canvas</h1></div></div></div><p>So far, we have shown that we can <a id="id349" class="indexterm"/>draw shapes in the Canvas dynamically based on our logic. There is one part missing in the game development,  that is, the input.</p><p>Now, imagine that we can drag the circles around on the Canvas, and the connected lines will follow the circles. In this section, we will add mouse events to the canvas to make our circles<a id="id350" class="indexterm"/> <strong>draggable</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Time for action – dragging the circles in the Canvas</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's <a id="id351" class="indexterm"/>continue with our<a id="id352" class="indexterm"/> previous code. Open the <code class="literal">html5games.untangle.js</code> file.</li><li class="listitem">We need a function to clear all the drawings in the Canvas. Add the following function to the end of the <code class="literal">untangle.drawing.js</code> file:<div><pre class="programlisting">untangleGame.clear = function() {
  var ctx = untangleGame.ctx;
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
};</pre></div></li><li class="listitem">We also need two more functions that draw all known circles and lines. Append the following code to the <code class="literal">untangle.drawing.js</code> file:<div><pre class="programlisting">untangleGame.drawAllLines = function(){
  // draw all remembered lines
  for(var i=0;i&lt;untangleGame.lines.length;i++) {
    var line = untangleGame.lines[i];
    var startPoint = line.startPoint;
    var endPoint = line.endPoint;
    var thickness = line.thickness;
    untangleGame.drawLine(startPoint.x, startPoint.y, endPoint.x,
    endPoint.y, thickness);
  }
};

untangleGame.drawAllCircles = function() {
  // draw all remembered circles
  for(var i=0;i&lt;untangleGame.circles.length;i++) {
    var circle = untangleGame.circles[i];
    untangleGame.drawCircle(circle.x, circle.y, circle.radius);
  }
};</pre></div></li><li class="listitem">We are done with the <code class="literal">untangle.drawing.js</code> file. Let's switch to the <code class="literal">untangle.js</code> file. Inside the jQuery document-ready function, before the ending of the function, we add the following code, which creates a game loop to keep drawing the circles and lines:<div><pre class="programlisting">// set up an interval to loop the game loop
setInterval(gameloop, 30);

function gameloop() {
  // clear the Canvas before re-drawing.
  untangleGame.clear();
  untangleGame.drawAllLines();
  untangleGame.drawAllCircles();
}</pre></div></li><li class="listitem">Before moving <a id="id353" class="indexterm"/>on to the input handling code implementation, let's<a id="id354" class="indexterm"/> add the following code to the jQuery document ready function in the <code class="literal">untangle.js</code> file, which calls the <code class="literal">handleInput</code> function that we will define:<div><pre class="programlisting">untangleGame.handleInput();</pre></div></li><li class="listitem">It's time to implement our input handling logic. Switch to the <code class="literal">untangle.input.js</code> file and add the following code to the file:<div><pre class="programlisting">if (untangleGame === undefined) {
  var untangleGame = {};
}

untangleGame.handleInput = function(){
  // Add Mouse Event Listener to canvas
  // we find if the mouse down position is on any circle
  // and set that circle as target dragging circle.
  $("#game").bind("mousedown", function(e) {
    var canvasPosition = $(this).offset();
    var mouseX = e.pageX - canvasPosition.left;
    var mouseY = e.pageY - canvasPosition.top;

    for(var i=0;i&lt;untangleGame.circles.length;i++) {
      var circleX = untangleGame.circles[i].x;
      var circleY = untangleGame.circles[i].y;
      var radius = untangleGame.circles[i].radius;
      if (Math.pow(mouseX-circleX,2) + Math.pow(mouseY-circleY,2) &lt; Math.pow(radius,2)) {
        untangleGame.targetCircleIndex = i;
        break;
      }
    }
  });

  // we move the target dragging circle 
  // when the mouse is moving
  $("#game").bind("mousemove", function(e) {
    if (untangleGame.targetCircleIndex !== undefined) {
      var canvasPosition = $(this).offset();
      var mouseX = e.pageX - canvasPosition.left;
      var mouseY = e.pageY - canvasPosition.top;
      var circle = untangleGame.circles[untangleGame.targetCircleIndex];
      circle.x = mouseX;
      circle.y = mouseY;
    }
    untangleGame.connectCircles();
  });

  // We clear the dragging circle data when mouse is up
  $("#game").bind("mouseup", function(e) {
    untangleGame.targetCircleIndex = undefined;
  });
};</pre></div></li><li class="listitem">Open <code class="literal">index.html</code> in a web browser. There should be five circles with lines <a id="id355" class="indexterm"/>connecting<a id="id356" class="indexterm"/> them. Try dragging the circles. The dragged circle will follow the mouse cursor and the connected lines will follow too.<div><img src="img/B04290_04_06.jpg" alt="Time for action – dragging the circles in the Canvas"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec112"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have set up<a id="id357" class="indexterm"/> three mouse event listeners. They are the mouse down, move, and up <a id="id358" class="indexterm"/>events. We also created the game loop, which updates the Canvas drawing based on the new position of the circles. You can view the example's current progress at: <a class="ulink" href="http://makzan.net/html5-games/untangle-wip-dragging-basic/">http://makzan.net/html5-games/untangle-wip-dragging-basic/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec113"/>Detecting mouse events in circles in the Canvas</h2></div></div></div><p>After discussing the difference<a id="id359" class="indexterm"/> between DOM-based development and Canvas-based <a id="id360" class="indexterm"/>development, we cannot directly listen to<a id="id361" class="indexterm"/> the mouse events of any shapes drawn in the Canvas. There is no such thing. We cannot monitor the event in any shapes drawn in the Canvas. We can only get the mouse event of the <code class="literal">canvas</code> element and calculate the relative position of the Canvas. Then we change the states of the game objects according to the mouse's position and finally redraw it on the Canvas.</p><p>
<em>How do we know we are clicking on a circle?</em> We can use the <a id="id362" class="indexterm"/>
<strong>point-in-circle</strong> formula. This is to check the distance between the center point of the circle and the mouse position. The mouse clicks on the circle when the distance is less than the circle's radius. We use this formula to get the distance between two points: <em>Distance = (x2-x1)2 + (y2-y1)2</em>.</p><p>The following graph shows that when the distance between the center point and the mouse cursor is smaller than the radius, the cursor is in the circle:</p><div><img src="img/B04290_04_07.jpg" alt="Detecting mouse events in circles in the Canvas"/></div><p>The following code we used explains how we can apply distance checking to know whether the mouse cursor is inside the circle in the mouse down event handler:</p><div><pre class="programlisting">if (Math.pow(mouseX-circleX,2) + Math.pow(mouseY-circleY,2) &lt; Math.pow(radius,2)) {
  untangleGame.targetCircleIndex = i;
  break;
}</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Please note that <code class="literal">Math.pow</code> is an expensive function that may hurt performance in some scenarios. If performance is a concern, we may use the bounding box collision checking, which we covered in <a class="link" href="ch02.html" title="Chapter 2. Getting Started with DOM-based Game Development">Chapter 2</a>, <em>Getting Started with DOM-based Game Development</em>.</p></div></div><p>When we know that<a id="id363" class="indexterm"/> the mouse cursor is pressing the circle in the<a id="id364" class="indexterm"/> Canvas, we mark it as the targeted circle to <a id="id365" class="indexterm"/>be dragged on the mouse move event. During the mouse move event handler, we update the target dragged circle's position to the latest cursor position. When the mouse is up, we clear the target circle's reference.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec114"/>Pop quiz </h2></div></div></div><p>Q1. Can we directly access an already drawn shape in the Canvas?</p><div><ol class="orderedlist arabic"><li class="listitem">Yes</li><li class="listitem">No</li></ol></div><p>Q2. Which method can we use to check whether a point is inside a circle?</p><div><ol class="orderedlist arabic"><li class="listitem">The coordinate of the point is smaller than the coordinate of the center of the circle.</li><li class="listitem">The distance between the point and the center of the circle is smaller than the circle's radius.</li><li class="listitem">The <em>x</em> coordinate of the point is smaller than the circle's radius.</li><li class="listitem">The distance between the point and the center of the circle is bigger than the circle's radius.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec115"/>Game loop</h2></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Getting Started with DOM-based Game Development">Chapter 2</a>, <em>Getting Started with DOM-based Game Development</em>, we discussed the <strong>game loop</strong>
<a id="id366" class="indexterm"/> approach. In the Ping Pong game, the game loop manipulates the keyboard input and updates the position of the DOM-based game objects.</p><p>Here, the game loop is used to redraw the Canvas to present the later game states. If we do not redraw the Canvas after changing the states, say the position of the circles, we will not see it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec116"/>Clearing the Canvas</h2></div></div></div><p>When we drag <a id="id367" class="indexterm"/>the circle, we redraw the Canvas. The problem is the already drawn shapes on the Canvas won't disappear automatically. We will keep adding new paths to the Canvas and finally mess up everything in the Canvas. The following screenshot is what will happen if we keep dragging the circles without clearing the Canvas on every redraw:</p><div><img src="img/B04290_04_10.jpg" alt="Clearing the Canvas"/></div><p>Since we have saved all game statuses in JavaScript, we can safely clear the entire Canvas and draw the updated lines and circles with the latest game status. To clear the Canvas, we use the <code class="literal">clearRect</code> function provided by Canvas drawing API. The <code class="literal">clearRect</code> function<a id="id368" class="indexterm"/> clears a rectangle area by providing a rectangle clipping region. It accepts the following arguments as the clipping region:</p><div><pre class="programlisting">context.clearRect(x, y, width, height)</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Argument</p>
</th><th style="text-align: left" valign="bottom">
<p>Definition</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">x</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The top <a id="id369" class="indexterm"/>left point of the rectangular clipping region, on the <em>x</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">y</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The top left <a id="id370" class="indexterm"/>point of the rectangular clipping region, on the <em>y</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">width</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The width of <a id="id371" class="indexterm"/>the rectangular region.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">height</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The height<a id="id372" class="indexterm"/> of the rectangular region.</p>
</td></tr></tbody></table></div><p>The <code class="literal">x</code> and <code class="literal">y</code> values set the top left position of the region to be cleared. The <code class="literal">width</code> and <code class="literal">height</code> values define how much area is to be cleared. To clear the entire Canvas, we can provide (0,0) as the top left position and the width and height of the Canvas to the <code class="literal">clearRect</code> function. The following code clears all things drawn on the entire Canvas: </p><div><pre class="programlisting">ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec117"/>Pop quiz </h2></div></div></div><p>Q1. Can we clear a portion of the Canvas by using the clearRect function?</p><div><ol class="orderedlist arabic"><li class="listitem">Yes</li><li class="listitem">No</li></ol></div><p>Q2. Does the following code clear things on the drawn Canvas?</p><div><pre class="programlisting">ctx.clearRect(0, 0, ctx.canvas.width, 0);</pre></div><div><ol class="orderedlist arabic"><li class="listitem">Yes</li><li class="listitem">No</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Detecting line intersection in the Canvas</h1></div></div></div><p>We have draggable <a id="id373" class="indexterm"/>circles and connected lines in the Canvas. Some lines<a id="id374" class="indexterm"/> intersect others and some do not. Now imagine we want to distinguish the intersected lines. We need some mathematics formula to check them and then thicken those intersected lines.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Time for action – distinguishing the intersected lines</h1></div></div></div><p>Let's increase the thickness of those<a id="id375" class="indexterm"/> intersected lines so we can distinguish them in the Canvas</p><div><ol class="orderedlist arabic"><li class="listitem">Open the<code class="literal"> untangle.drawing.js</code> file in the text editor.</li><li class="listitem">We have the <code class="literal">thinLineThickness</code> variable as the default line thickness. We add the following code to define a thickness for bold lines:<div><pre class="programlisting">untangleGame.boldLineThickness = 5;</pre></div></li><li class="listitem">Open the <code class="literal">untangle.data.js</code> file. We create a function to check whether the given two lines intersect. Add the following functions to the end of the JavaScript file:<div><pre class="programlisting">untangleGame.isIntersect = function(line1, line2) {
  // convert line1 to general form of line: Ax+By = C
  var a1 = line1.endPoint.y - line1.startPoint.y;
  var b1 = line1. startPoint.x - line1.endPoint.x;
  var c1 = a1 * line1.startPoint.x + b1 * line1.startPoint.y;
  
  // convert line2 to general form of line: Ax+By = C
  var a2 = line2.endPoint.y - line2.startPoint.y;
  var b2 = line2. startPoint.x - line2.endPoint.x;
  var c2 = a2 * line2.startPoint.x + b2 * line2.startPoint.y;
  
  // calculate the intersection point    
  var d = a1*b2 - a2*b1;
  
  // parallel when d is 0
  if (d === 0) {
    return false;
  }
    
  // solve the interception point at (x, y)
  var x = (b2*c1 - b1*c2) / d;
  var y = (a1*c2 - a2*c1) / d;

  // check if the interception point is on both line segments
  if ((isInBetween(line1.startPoint.x, x, line1.endPoint.x) || isInBetween(line1.startPoint.y, y, line1.endPoint.y)) &amp;&amp;
     (isInBetween(line2.startPoint.x, x, line2.endPoint.x) || isInBetween(line2.startPoint.y, y, line2.endPoint.y))) {
      return true;
    }
    
    // by default the given lines is not intersected.
    return false;
};

// return true if b is between a and c,
// we exclude the result when a==b or b==c
untangleGame.isInBetween = function(a, b, c) {
  // return false if b is almost equal to a or c.
  // this is to eliminate some floating point when
  // two value is equal to each other 
  // but different with 0.00000...0001
  if (Math.abs(a-b) &lt; 0.000001 || Math.abs(b-c) &lt; 0.000001) {
    return false;
  }
  
  // true when b is in between a and c
  return (a &lt; b &amp;&amp; b &lt; c) || (c &lt; b &amp;&amp; b &lt; a);
};</pre></div></li><li class="listitem">Let's continue <a id="id376" class="indexterm"/>on with the <code class="literal">untangle.data.js</code> file. We define the following function to check whether our lines intersect and mark that line in bold. Append the following new function to the end of the file:<div><pre class="programlisting">untangle.updateLineIntersection = function() {
  // checking lines intersection and bold those lines.
  for (var i=0;i&lt;untangleGame.lines.length;i++) {
    for(var j=0;j&lt;i;j++) {
      var line1 = untangleGame.lines[i];
      var line2 = untangleGame.lines[j];
      
      // we check if two lines are intersected, 
      // and bold the line if they are.
      if (isIntersect(line1, line2)) {
        line1.thickness = untangleGame.boldLineThickness;
        line2.thickness = untangleGame.boldLineThickness;
      }              
    }
  }
}</pre></div></li><li class="listitem">Finally, we update the line intersection by adding the following function call in two places. Open the <code class="literal">untangle.js</code> file. Add the following line of code inside the jQuery document-ready function, probably before the game-loop function:<p>
<code class="literal">untangleGame.updateLineIntersection();</code>
</p></li><li class="listitem">Then, open the <code class="literal">untangle.input.js</code> file and add the same code inside the mouse move event handler.</li><li class="listitem">It is time to<a id="id377" class="indexterm"/> test the intersection in the web browser. When viewing the circles and lines in Canvas, the lines with an intersection should be thicker than those without an intersection. Try dragging the circles to change the intersection relationship and the lines will become thin or thick.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec118"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have just <a id="id378" class="indexterm"/>added some code checking for line intersections to our existing circle-dragging example. The line intersection code involves some mathematical formula to get the <strong>intersection point</strong>
<a id="id379" class="indexterm"/> of two lines and checks whether the point is inside the line segment we provide. You can view the example's current progress at: <a class="ulink" href="http://makzan.net/html5-games/untangle-wip-intersected-lines/">http://makzan.net/html5-games/untangle-wip-intersected-lines/</a>.</p><p>Let's look at the mathematics element and see how it works.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec119"/>Determining whether two line segments intersect</h2></div></div></div><p>According to the <a id="id380" class="indexterm"/>intersection equation we learned from geometry, with two given lines in a general form, we can get the intersection point.</p><p>What is a<a id="id381" class="indexterm"/> <strong>general form</strong>? In our code, we have the starting point and ending point of a line in <em>x</em> and <em>y</em> coordinates. This is a <strong>line segment</strong>
<a id="id382" class="indexterm"/> because it is just a segment part of the line in mathematics. A general form of a line is represented by <code class="literal">Ax</code> <code class="literal">+</code> <code class="literal">By</code> <code class="literal">=</code> <code class="literal">C</code>.</p><p>The following graph explains the line segment on a line in a general form:</p><div><img src="img/B04290_04_08.jpg" alt="Determining whether two line segments intersect"/></div><p>We can transform the <a id="id383" class="indexterm"/>line segment with point 1 in <strong>x1</strong>, <strong>y1</strong> and point 2 in <strong>x2</strong>, <strong>y2</strong> into general form by the following equation:</p><div><pre class="programlisting">A = y2-y1
B = x1-x2
C = A * x1 + B * y2</pre></div><p>Now we have a line equation <code class="literal">AX+BY</code> <code class="literal">=</code> <code class="literal">C</code> where <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code> are known and <code class="literal">X</code> and <code class="literal">Y</code> are unknown.</p><p>We are checking two lines intersecting. We can transform both lines into a general form and get two line equations:</p><div><pre class="programlisting">Line 1: A1X+B1Y = C1
Line 2: A2X+B2Y = C2</pre></div><p>By putting the two general form equations together, <code class="literal">X</code> and <code class="literal">Y</code> are two variables that are unknown. We can then solve these two equations and get the intersection point of <em>x</em> and <em>y</em>.</p><p>If <code class="literal">A1</code> <code class="literal">*</code> <code class="literal">B2</code> <code class="literal">-</code> <code class="literal">A2</code> <code class="literal">*</code> <code class="literal">B1</code> is zero, then two lines are parallel and there is no intersection point. Otherwise we get the interception point by using the following equation:</p><div><pre class="programlisting">X = (B2 * C1 – B1 * C2) / (A1 * B2 – A2 * B1)
Y = (A1 * C2 – A2 * C1) / (A1 * B2 – A2 * B1)</pre></div><p>The intersection point of these general forms only provides that the two lines are not parallel to each other and will intersect each other at some point. It does not guarantee that the intersection point is on both line segments.</p><p>The following graphs show two possible results of the intersection point and the given line segments. The intersection point is not in between both line segments in the left graph; in this case, the two line segments are not intersecting with each other. In the right-hand side graph, the point is in between both line segments so these two line segments intersect with each other: </p><div><img src="img/B04290_04_09.jpg" alt="Determining whether two line segments intersect"/></div><p>Therefore, we need<a id="id384" class="indexterm"/> another function named <code class="literal">isInBetween</code> to determine whether a provided value is in between the beginning and ending value. Then we use this function to check whether the intersection point from the equation is in between both line segments that we are checking.</p><p>After getting the result of the lines intersection, we draw the thick line to indicate those intersected lines.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec53"/>Adding touch support for tablets</h1></div></div></div><p>Drag-and-drop is a common <a id="id385" class="indexterm"/>gesture in touch devices in tablets and mobile <a id="id386" class="indexterm"/>devices. Currently, our game doesn't support these touch devices. We want to add touch support for our game in this section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec54"/>Time for action – adding the touch input support</h1></div></div></div><p>Let's allow our tablet users to drag-n-drop our circles with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">By default, there is a selection highlighted in the <code class="literal">canvas</code> element in iOS devices. We want to get rid of this highlighted part to make the dragging interaction smooth. Add the following CSS rules to the <code class="literal">canvas</code> CSS. Please note that we use the <code class="literal">webkit</code> vendor prefix here because this rule is specific for <code class="literal">webkit</code> at the time of writing this book:<div><pre class="programlisting">canvas {
  /* for iOS devices */
  -webkit-tap-highlight-color: transparent;
}</pre></div></li><li class="listitem">Open the <code class="literal">untangle.input.js file</code>. We bind the mouse events on the Canvas in the <a id="id387" class="indexterm"/>previous step. Now we add the support <a id="id388" class="indexterm"/>for touch events. We used <code class="literal">MouseEvent.pageX</code> and <code class="literal">pageY</code> to calculate the mouse position. With touch devices, there can be multiple touches. We modify our code to add the touch support:<div><pre class="programlisting">$("#game").bind("mousedown touchstart", function(e) {
  // disable default drag to scroll behavior
  e.preventDefault();

  // touch or mouse position
  var touch = e.originalEvent.touches &amp;&amp; e.originalEvent.touches[0];
  var pageX = (touch||e).pageX;
  var pageY = (touch||e).pageY;

  var canvasPosition = $(this).offset();
  var mouseX = pageX - canvasPosition.left;
  var mouseY = pageY - canvasPosition.top;

  // existing code goes here.
    
}</pre></div></li><li class="listitem">We modify the <code class="literal">mousemove</code> event similarly. We bind both the <code class="literal">mousemove</code> and <code class="literal">touchmove</code> events and calculate the touch position:<div><pre class="programlisting">$("#game").bind("mousemove touchmove", function(e) {
  // disable default drag to scroll behavior
  e.preventDefault();

  // touch or mouse position
  var touch = e.originalEvent.touches &amp;&amp; e.originalEvent.touches[0];
  var pageX = (touch||e).pageX;
  var pageY = (touch||e).pageY;

  var canvasPosition = $(this).offset();
  var mouseX = pageX - canvasPosition.left;
  var mouseY = pageY - canvasPosition.top;

  // existing code goes here.    
}</pre></div></li><li class="listitem">For the original <code class="literal">mouseup</code> event handler, we add the <code class="literal">touchend</code> handling: <div><pre class="programlisting">$("#game").bind("mouseup touchend", function(e) {
 // existing code goes here.
}</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec120"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just added <a id="id389" class="indexterm"/>touch support to our untangle game. You may <a id="id390" class="indexterm"/>find the code and example at: <a class="ulink" href="http://makzan.net/html5-games/untangle-wip-dragging/">http://makzan.net/html5-games/untangle-wip-dragging/</a>.</p><p>In the CSS, we disable the default tap highlight by setting the <code class="literal">-webkit-tap-highlight-color</code> to transparent. We need the vendor prefix <code class="literal">-webkit-</code> because this is a WebKit-only rule especially designed for their touch devices.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec121"/>Handling touches</h2></div></div></div><p>We get the <code class="literal">touch</code> event <a id="id391" class="indexterm"/>object by using the following code:</p><div><pre class="programlisting">var touch = e.originalEvent.touches &amp;&amp; e.originalEvent.touches[0];</pre></div><p>The touches array holds all the current touches on the screen. Since we are handling the touch events in jQuery, we need to access the <code class="literal">originalEvent</code> to access the touches because these are browser native events, instead of a jQuery event.</p><p>We only care about one touch in this game, that's why we only check the <code class="literal">touches[0]</code> parameter. We also confirm that <code class="literal">originalEvent.touches</code> exists before using the array notation, otherwise, the browser throws errors on non-touch devices.</p><p>Then we access the <code class="literal">pageX</code> property of either the <code class="literal">touch</code> object or the mouse event object. If the <code class="literal">touch</code> object presents, JavaScript uses the <code class="literal">touch.pageX</code>. Otherwise, JavaScript uses the mouse event's <code class="literal">pageX</code> property:</p><div><pre class="programlisting">var pageX = (touch||e).pageX;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec122"/>Mouse move and Touch move</h2></div></div></div><p>We reuse the<a id="id392" class="indexterm"/> same <a id="id393" class="indexterm"/>logic for our <code class="literal">mousedown</code>/<code class="literal">touchstart</code>, <code class="literal">mousemove</code>/<code class="literal">touchmove</code>, and <code class="literal">mouseup</code>/<code class="literal">touchend</code> event. Often <code class="literal">mousedown</code> and <code class="literal">touchstart</code> share very similar logic for dragging starts. The <code class="literal">mouseup</code> and <code class="literal">touchend</code> events also share similar logic for dragging ends. The <code class="literal">mousemove</code> and <code class="literal">touchmove</code> events, however, have a subtle difference. In desktop devices with mouse input, the <code class="literal">mousemove</code> event is always firing whenever the mouse moves, regardless of the pressing of mouse button. That was why we needed to use a variable <code class="literal">targetCircleIndex</code> to determine whether the button was pressed and then selected a certain circle when the mouse moves. The <code class="literal">touchmove</code> event, on the other hand, happens only when a finger is actually down on the screen and dragging. This difference may sometimes affect the different ways we handle the logic.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec55"/>Summary</h1></div></div></div><p>You learned a lot in this chapter about drawing shapes and creating interaction with the new HTML5 <code class="literal">canvas</code> element and the drawing API.</p><p>Specifically, you learned to draw circles and lines in the Canvas. We added mouse events and touch dragging interaction with the paths drawn in the Canvas. We determined line intersection with the help of mathematics formulas. We separated a complex code logic into different files to make the code maintainable. We divided the logic into data, drawing, and inputs.</p><p>Now that you've learned about basic drawing functions in the Canvas and the drawing API, you're ready to learn some advanced drawing techniques in Canvas. In the next chapter, we will create a puzzle solving game by continuing the code example. You will also learn more Canvas drawing techniques, such as drawing text, drawing images, and creating multiple drawing layers.</p></div></body></html>