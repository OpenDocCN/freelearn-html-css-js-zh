<html><head></head><body>
        

                            
                    <h1 class="header-title">Packaging Types and Values Together</h1>
                
            
            
                
<p class="mce-root">ReasonML has fantastic support for the software engineering practice of dividing programs into small, modular components that can be swapped out for each other.<br/></p>
<p class="mce-root">In this chapter, we will cover:</p>
<ul>
<li>Modules and how they can be used to package types and values together</li>
<li>The difference between file modules and syntactic modules</li>
<li>Module signatures (both file and syntactic)</li>
<li>Using signatures to achieve information hiding</li>
<li>Using signatures to achieve type abstraction</li>
<li>Achieving zero-cost abstraction</li>
</ul>
<p><strong>Modules</strong> are groups of types and values accessible under a single name. This can be incredibly useful when you want to associate some types and operations together to make them easier to find and use together. They are kind of like <strong>namespaces</strong> in other languages, but more powerful because they can be composed in various ways.</p>
<p>Let's look at how to make some modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">File modules</h1>
                
            
            
                
<p>It turns out we've already made some modules! Reason treats the <kbd>.re</kbd> source files as modules, so our <kbd>src/Ch01/Ch01_Demo.re</kbd> and <kbd>src/Ch02/Ch02_Demo.re</kbd> files are automatically available as modules, with the names <kbd>Ch01_Demo</kbd> and <kbd>Ch02_Demo</kbd>, respectively. In the Reason world, these are called <strong>implementation files</strong><em>.</em> We will informally refer to them as <strong>file modules</strong><em>.</em></p>
<p>Reason names file modules purely from their file names, ignoring their directory nesting. It makes every module automatically available from every other module, regardless of where they are physically in the project. This is why we were careful to name our modules with chapter prefixes; otherwise, files from different chapters but with the same names would confuse the compiler.</p>
<p>Let's take advantage of Reason's automatic module resolution, by creating a new (file) module that refers to something in an existing module:</p>
<pre>/* src/Ch03/Ch03_Greet.re */<br/>let <em>greet</em>(<em>person</em>: <em>Ch02_Demo</em>.<strong>person</strong>) = /* (1), (2), (3) */<br/>  "Hello, " ++ /* (4), (5) */<br/>  <em>person.name</em> ++<br/>  " with ID " ++<br/>  <em>string_of_int</em>(<em>person.id</em>) ++ /* (6) */<br/>  "!";</pre>
<p>Here we're defining a function that knows how to greet people with a name and an ID. There are a few things happening in this example (marked by the numbered comments):</p>
<ol>
<li>We assign a type to the <kbd>person</kbd> function parameter by appending a colon followed by the type. You can read this as "<em>person has type c h 0 2 demo dot person</em>". We can assign types to any function parameters in Reason; they are almost always optional though, because of type inference. In this case, we wanted to be explicit because of a subtle issue: there are actually two different record types (<kbd>person</kbd> and <kbd>company</kbd>) with the <kbd>name</kbd> and <kbd>id</kbd> fields in the <kbd>Ch02_Demo</kbd> module, and we need to distinguish between them.</li>
<li>Function definitions have a body consisting of a single expression; this can also be a compound expression delimited by brackets (we'll see examples later).</li>
<li>We can have a <kbd>person</kbd> value and a <kbd>person</kbd> type–they don't clash because Reason stores them separately, in the static and dynamic environments.</li>
<li>Reason is whitespace-insensitive; you can lay out your code any way you want, as long as you separate bindings with a semicolon. For most codebases, you would actually just use the Reason formatter tool, <kbd>refmt</kbd>, which would automatically take care of all formatting.</li>
<li>The <kbd>++</kbd> operator in Reason concatenates two strings (and nothing else!) together.</li>
<li><kbd>person.id</kbd> is an <kbd>int</kbd>, so we can't concatenate it with its surrounding strings–unless we convert it to a string with the built-in <kbd>string_of_int</kbd> function. Reason has strict, strong typing, and doesn't implicitly convert between types (not even between <kbd>int</kbd> and <kbd>float</kbd> variables).</li>
</ol>
<p>To understand what Reason is doing for us, let's look at the relevant part of the output JavaScript:</p>
<pre>// src/Ch03/Ch03_Greet.bs.js<br/>function <em>greet</em>(<em>person</em>) {<br/>  return "Hello, "<br/>    + <em>person</em>[1]<br/>    + " with ID "<br/>    + <em>String</em>(<em>person</em>[0])<br/>    + "!";<br/>}</pre>
<p>I've cleaned and rearranged the JavaScript output somewhat, without changing its meaning.</p>
<p>As usual, we see the types are completely erased, and the output is concerned only with values. Based on the types, though, the Reason compiler knew to access the person's name at array index 1 and ID at index 0. Also, it knows to ensure that <kbd>person[0]</kbd> gets converted into a string by using the JavaScript string constructor.</p>
<p>In the JavaScript world, we'd say that such a conversion is unnecessary. But in the statically typed Reason world, the compiler keeps a tally of the types of all values and ensures they interact only according to the rules of their types. Thus we ensure that a number can't accidentally be added to a series of strings.</p>
<p>On a larger scale, notice that the fact that Reason files are modules is not directly visible in the JavaScript output code–except that the Reason files are directly compiled, with a one-to-one relationship, to JavaScript modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Syntactic modules</h1>
                
            
            
                
<p>Let's look at another way of creating modules in Reason: <strong>syntactic modules</strong><em>.</em> These are modules that are defined using Reason's module syntax. Here's an example:</p>
<pre>/* src/Ch03/Ch03_Domain.re */<br/>module <em>Person</em> = {<br/>  type <strong>t</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/>  let <em>make</em>(<em>id</em>, <em>name</em>) = {<em>id</em>, <em>name</em>};<br/>};<br/><br/>module <em>Company</em> = {<br/>  type <strong>t</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>, <em>employees</em>: <strong>list</strong>(<em>Person</em>.<strong>t</strong>)};<br/>};</pre>
<p>Here we define a <kbd>Domain</kbd> file module to contain two <em>nested</em> modules: <kbd>Person</kbd> and <kbd>Company</kbd>. These nested modules actually contain types similar to the ones we defined in <kbd>src/Ch02/Ch02_Demo.re</kbd>, but this time with both types named <kbd>t</kbd>.</p>
<p>Let's digress a little into the type name <kbd>t</kbd>. This is a standard naming convention in the Reason ecosystem to mean the main type in the module. Usually, you refer to a module along with its main type, for example, <kbd>Person.t</kbd> or <kbd>Company.t</kbd>, so it's quite clear exactly which type you mean.</p>
<p>Syntactic modules have the following form: <kbd>module Name = {...bindings...};</kbd> and all the bindings are then available to outside consumers under the module name, for example, <kbd>Name.binding1</kbd>, and so on.</p>
<p>Earlier, we said that modules package types and values together. But in the preceding example, you can see that the <kbd>Ch03_Domain</kbd> file module itself contains two modules, <kbd>Person</kbd> and <kbd>Company</kbd>. I actually oversimplified before. Modules can recursively contain other modules! This is a great code organization and namespacing strategy.</p>
<p>Let's look at the (relevant part of the) JavaScript output to understand what the runtime effect of this domain module is:</p>
<pre>// src/Ch03/Ch03_Domain.bs.js<br/>function <em>make</em>(<em>id</em>, <em>name</em>) { return [<em>id</em>, <em>name</em>]; }<br/><br/>var <em>Person</em> = [<em>make</em>];<br/>var <em>Company</em> = [];<br/><em>exports.Person</em>  = <em>Person</em>;<br/><em>exports.Company</em> = <em>Company</em>;</pre>
<p>The <kbd>Person</kbd> and <kbd>Company</kbd> modules are represented as JavaScript arrays, and their <kbd>t</kbd> types are completely erased, leaving the arrays almost empty. The arrays contain only what file-level module JavaScript output would contain: values. In fact, this is almost exactly how Reason represents modules when compiled to bytecode or native binary form.</p>
<p>It is not, however, how you might expect a <em>nested module</em> to look in idiomatic JavaScript. Indeed, the BuckleScript compiler does not always emit completely idiomatic JavaScript output. Some of those cases can be fixed (indeed, some have already been); others are compromises that the compiler needs to make to efficiently convert Reason code into JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a syntactic module</h1>
                
            
            
                
<p>As you can see, modules are very cheap. They have almost no runtime effect. Let's look at the payoff of arranging our types into their own nested modules. We're going to try greeting a person again:</p>
<pre>/* src/Ch03/Ch03_GreetAgain.re */<br/>let <em>greetAgain</em>(<em>person</em>) = /* (1) */<br/>  "Hello again, " ++<br/>  <em>person.Ch03_Domain.Person.name</em> ++ /* (2) */<br/>  " with ID " ++<br/>  <em>string_of_int</em>(<em>person.id</em>) ++<br/>  "!";</pre>
<p>What's different from <kbd>src/Ch03/Ch03_Greet.re</kbd>?</p>
<ol>
<li>We don't need to explicitly annotate the type of <kbd>person</kbd></li>
<li>We need to tell Reason which module the <kbd>name</kbd> field is coming from, because, in order to prevent name clashes between record types that have the same field names, Reason doesn't automatically open up modules to look for type details</li>
</ol>
<p>You might ask, is this really a payoff? We've just traded one kind of annotation (the explicit type signature) for another (the field name module prefix). While that is true, it's idiomatic for implementation code to have as few type annotations as possible and let the compiler infer as much as possible.</p>
<p>Type annotations do serve another purpose though, which is to document the types. In Reason, we have an explicit place to put type annotations that document our module types and serve some other useful purposes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Module signatures</h1>
                
            
            
                
<p><strong>Module signatures</strong><em>,</em> also known as <strong>interfaces</strong><em>,</em> are an explicit place to put type annotations. But they actually serve several purposes:</p>
<ul>
<li>Export a module's public API</li>
<li>Document the types of a module's public API</li>
<li>Provide a place to put module documentation</li>
<li>Hide non-public elements of a module</li>
<li>Hide implementation details of types</li>
</ul>
<p>Keeping in mind the points mentioned earlier, when would you <em>not</em> want to use a signature for your module? It's not set in stone, but my rule of thumb is to not use a signature when my API is experimental and still evolving (in semantic versioning terms, less than version 1.0.0.), or when the module is purely an application module and is not meant to be published as a library for others to consume (although the line between these is somewhat grainy).</p>
<p>Signatures come in two forms–<strong>interface files</strong> and <strong>syntactic signatures</strong><em>,</em> corresponding to implementations. Interface files are Reason source files that contain signatures and nothing else. Syntactic signatures are signatures that are defined specifically using Reason's syntax support for signatures.</p>
<p>We will explore the previously mentioned points chiefly by using interface files, but also show examples of syntactic signatures as appropriate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exporting and documenting the public API</h1>
                
            
            
                
<p>Let's look at an example of exporting and documenting a module's public API. This is an interface file:</p>
<pre class="mce-root">/** src/Ch03/Ch03_GreetAgain.rei (1), (2)<br/>    Contains a way to greet a person. */<br/><br/>/** Greet someone with a name and ID, again. (3) */<br/>let <em>greetAgain</em>: <em>Ch03_Domain.Person</em>.<strong>t</strong> =&gt; <strong>string</strong>; /* (4) */</pre>
<p>There are a few interesting things going on here:</p>
<ol>
<li>Interface files must have the <kbd>.rei</kbd> (Reason Interface) file extension, with file names corresponding to the implementation file name.</li>
<li>We are using a new kind of comment, called a <strong>documentation comment</strong> (<strong>doc comment</strong>), to write documentation that will be publicly exported along with the API. Doc comments start with <kbd>/**</kbd> and end with <kbd>*/</kbd>. There are tools in the Reason ecosystem that can understand doc comments and format them for readers. Note that we usually don't use doc comments in implementation (<kbd>.re</kbd>) files because it usually doesn't make sense to expose implementation-specific documentation to users.</li>
</ol>
<ol start="3">
<li>Any item in a module can be documented with doc comments.</li>
<li>We use a value declaration to tell Reason to export a value from the module, with the given type. In this case, the type of the value is a function type–this one reads "<em>ch 0 3 domain person t arrow string</em>" meaning <em>take a chapter 3 domain person type as input and return a string as output</em>. We will cover functions in more detail in a future chapter.</li>
</ol>
<p>So, what does this interface file compile to? As it turns out: nothing. Interface files are purely compile-time constructs; they don't exist at all at runtime. In fact, they are erased just like types because they are types. <em>Module interfaces are types.</em> A <kbd>.rei</kbd> file you write as an interface actually specifies the type of its corresponding <kbd>.re</kbd> implementation file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Syntactic module signatures</h1>
                
            
            
                
<p><strong>Module signatures</strong> are also known as <strong>module types</strong><em>.</em> Just like other types, module types specify what you can and can't do with values of their type; in other words, they specify the surface area of a module.</p>
<p>Here's an example of a syntactic module type and its usage:</p>
<pre>/* src/Ch03/Ch03_ModuleType.re */<br/>module type <strong>PersonType</strong> = {<br/>  type <strong>t</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/>  let <em>make</em>: (<strong>int</strong>, <strong>string</strong>) =&gt; <strong>t</strong>; /* (1) */<br/>};<br/><br/>module <em>Person</em>: <strong>PersonType</strong> = { /* (2) */<br/>  type <strong>t</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/><br/>  let <em>massage</em>(<em>name</em>) = <em>String.trim</em>(<em>String.capitalize</em>(<em>name</em>)); /* (3) */<br/>  let <em>make</em>(<em>id</em>, <em>name</em>) = {<em>id</em>, <em>name</em>: <em>massage</em>(<em>name</em>)}; /* (4) */<br/>};</pre>
<p>A syntactic module type has the <kbd>module type Type = {...declarations...};</kbd> form and specifies exactly what will be exported from a module that conforms to the type. Some key points to note in the previous example:</p>
<ol>
<li>We declare a function's (<kbd>make</kbd>) type with the <kbd>let funName: (param1Type, ..., paramNType) =&gt; returnType;</kbd> syntax.</li>
<li>We declare that a module conforms to a module type by appending a colon followed by the module type.</li>
</ol>
<ol start="3">
<li>We define a <kbd>massage</kbd> function to properly case and trim input names, but this function is not declared in the module type, so it's never exported (that is, users of this module won't be able to access <kbd>massage</kbd>).</li>
<li>We give a record field a specific expression as its value by using the <kbd>name: expression</kbd> syntax. We'll cover record type syntax more fully in a later chapter.</li>
</ol>
<p>Let's take a look at the (relevant part of the) JavaScript output:</p>
<pre>// src/Ch03/Ch03_ModuleType.bs.js<br/>var <em>$$String</em> = <em>require</em>("bs-platform/lib/js/string.js"); // (1)<br/>function <em>make</em>(<em>id</em>, <em>name</em>) {<br/>  return [<em>id</em>, <em>$$String</em>.<em>trim</em>(<em>$$String</em>.<em>capitalize</em>(<em>name</em>))]; // (2)<br/>}<br/>var <em>Person</em> = [<em>make</em>];<br/><em>exports</em>.<em>Person</em> = <em>Person</em>;</pre>
<ol>
<li>The Reason <kbd>String</kbd> module name is <strong>damaged slightly</strong> (with a <kbd>$$</kbd> prefix) in the output to avoid a name clash with the existing JavaScript <kbd>String</kbd> constructor.</li>
<li>The returned person array value doesn't call the <kbd>massage</kbd> function. In fact, BuckleScript doesn't even emit a <kbd>massage</kbd> function, having determined that it can be inlined.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Module errors</h1>
                
            
            
                
<p>The fact that modules have types naturally leads to the fact that they can also throw type errors. Let's look at a couple of possible type errors related to modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Signature mismatch</h1>
                
            
            
                
<p>What happens when we try to assign a module signature to a module that doesn't implement that interface properly? Check out the following:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch03/Ch03_ModuleType.re 8:29-11:1<br/>  <br/>   6 │ };<br/>   7 │ <br/>   <strong>8</strong> │ module Person: PersonType = <strong>{</strong><br/>   <strong>9</strong> │   <strong>type t = {id: int, name: string};</strong><br/>  <strong>10</strong> │   <strong>let massage(name) = String.trim(String.capitalize(name));</strong><br/>  <strong>11</strong> │ <strong>}</strong>;<br/>  <br/>  Signature mismatch:<br/>  Modules do not match:<br/>    { type t = { id: int, name: string, }; let massage: (string) =&gt; string; }<br/>  is not included in<br/>    PersonType<br/>  The value `make' is required but not provided<br/>  File "/Users/yawar/src/learning-tydd-reason/src/Ch03/Ch03_ModuleType.re", line 5, characters 3-31:<br/>    Expected declaration</pre>
<p>This message means that we forgot to include the <kbd>make</kbd> function in our implementation. The message is slightly strange, but makes sense if you know how Reason typechecks modules:</p>
<ul>
<li>It infers what it thinks should be the module type by examining the structure of the actual module</li>
<li>It compares the inferred type to the annotated module type, <kbd>PersonType</kbd></li>
<li>It does not care about items that appear in the actual module but aren't declared in <kbd>PersonType</kbd> (it just hides those from the outside world)</li>
<li>It does show errors on items that are declared in <kbd>PersonType</kbd> but are missing from the actual module</li>
</ul>
<p>In short, you can't overpromise and under-deliver. Knowing this, you can interpret the error message: the inferred module type is on top, and the annotated module type is beneath, as shown in the following screenshot:</p>
<div><img src="img/e3bb0114-0483-4496-ad44-7c0ef9bea50c.png" style="width:42.50em;height:11.58em;"/></div>
<p>Module type mismatch error diagram</p>
<p>In Reason, modules are <em>structurally typed</em>: their types are made up of their structure, that is, by combining the types of their contained bindings in a syntactic form similar to the modules themselves. That's why we're able to write <kbd>module type Foo = {...declarations...};</kbd>–the <kbd>{...declarations...}</kbd> structural type is a first-class type by itself; we are just binding it to a name. A concrete result of this is that you can define a module and annotate it with a type directly, for example, <kbd>module Foo: {...declarations...} = {...bindings...};</kbd>. In a later chapter, we will examine structural typing further.</p>
<p>An important thing to understand is that you can't get a signature mismatch by implementing types and values in a different order from that in their signatures. You are still restricted to declaring or defining things before you use them, but the compiler will understand that a module conforms to a signature even if their declarations and definitions don't match up in exact order. To see a small example of this, look at the code sample in the upcoming <em>Type abstraction</em> section. The ordering of the <kbd>getter</kbd> functions is slightly different between the interface and the implementation.</p>
<p>This ordering flexibility can be a benefit if you're trying to arrange a module signature in a way that's easy to understand, that is, one that presents the most important items first. Sometimes, you don't need that level of flexibility, but you can always take advantage of it later if you find you do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Value can't be found</h1>
                
            
            
                
<p>What happens when we try to use something that doesn't exist in a module? Check out the following:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch03/Ch03_ModuleType.re 10:23-40<br/>  <br/>   8 │   type t = {id: int, name: string};<br/>   9 │ <br/>  <strong>10</strong> │   let massage(name) = <strong>Ch03_Greet.process</strong>(name);<br/>  11 │   let make(id, name) = {id, name: massage(name)};<br/>  12 │ };<br/>  <br/>  The value process can't be found in Ch03_Greet</pre>
<p>Reason checks, at compile time, whether the type of the module (<kbd>Ch03_Greet</kbd>) exports the named value (<kbd>process</kbd>), and it fails the build otherwise. There is no way to use a value that does not exist.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Type abstraction</h1>
                
            
            
                
<p>In Reason, you can hide the implementation of a type and reveal exactly what you choose to. This <em>type abstraction</em> is one of the best techniques for <em>preserving invariants</em> (rules that should be obeyed) in your codebase. Type abstraction also allows modules to be decoupled from each other's implementation details, and work only with the information they have from exported interfaces.</p>
<p>For example, look at the <kbd>Ch03_ModuleType.Person</kbd> module. It exports a <kbd>t</kbd> type to represent information about a person, and a <kbd>make</kbd> function to properly create values of the <kbd>t</kbd> type. The <kbd>make</kbd> function ensures that we properly trim and capitalize the names that we're given. We want to enforce the rule that names should have the proper casing and should not have surrounding whitespace.</p>
<p>The problem is we can do something like this:</p>
<pre>let <em>bob</em> = {<em>Ch03_ModuleType.Person.id</em>: 1, <em>name</em>: " bob    "};</pre>
<p>Because the <kbd>Ch03.ModuleType.Person.t</kbd> definition is exported, we can bypass the <kbd>make</kbd> function and directly create <kbd>t</kbd> values, breaking the rules that we want to apply for names.</p>
<p>We can solve this problem by making <kbd>t</kbd> an abstract type (note that we must define both the interface and implementation files, as shown ahead):</p>
<pre>/** src/Ch03/Ch03_AbstractPerson.rei */<br/><br/>type <strong>id</strong> = <strong>int</strong>;<br/>type <strong>name</strong> = <strong>string</strong>;<br/>type <strong>t</strong>; /* (1) */<br/><br/>let <em>make</em>: (<strong>id</strong>, <strong>name</strong>) =&gt; <strong>t</strong>;<br/>let <em>id</em>: <strong>t</strong> =&gt; <strong>id</strong>;<br/>let <em>name</em>: <strong>t</strong> =&gt; <strong>name</strong>;<br/><br/>/* src/Ch03/Ch03_AbstractPerson.re */<br/>type <strong>id</strong> = <strong>int</strong>; /* (2) */<br/>type <strong>name</strong> = <strong>string</strong>;<br/>type <strong>t</strong> = {<em>id</em>, <em>name</em>}; /* (3) */<br/><br/>let <em>id</em>(<em>t</em>) = <em>t.id</em>;<br/>let <em>name</em>(<em>t</em>) = <em>t.name</em>;<br/>let <em>massage</em>(<em>name</em>) = <em>String.trim</em>(<em>String.capitalize</em>(<em>name</em>));<br/>let <em>make</em>(<em>id</em>, <em>name</em>) = {<em>id</em>, <em>name</em>: <em>massage</em>(<em>name</em>)};</pre>
<ol>
<li>Now, <kbd>Ch03_AbstractPerson.t</kbd> is internally a record type just like the others, but it is exported as purely an abstract type with no implementation details <em>except</em> the operations we provide in the interface. These operations allow us to properly create <kbd>t</kbd> values and extract the person's ID and name from the <kbd>t</kbd> values.</li>
<li>We introduce two new types here: <kbd>id</kbd> and <kbd>name</kbd>, using the <kbd>type typeName = otherType;</kbd> syntax. This direct binding of a new type name to an existing type name is called a <em>type alias</em> (sometimes also called a <em>type abbreviation</em>). Type aliases don't have any influence on typechecking, but they are a useful way to document our intentions and sometimes to shorten the names of longer type names.</li>
<li>Because we aliased <kbd>id</kbd> and <kbd>name</kbd>, we can use the shortcut that Reason provides when the field and type names are the same in a record type definition, called <strong>punning</strong>.</li>
</ol>
<p>Since we want to export the type aliases as well as the original types and operations, we need to repeat the same alias bindings in both the interface and the implementation. This bit of duplication allows Reason to double-check its inference against our intentions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Zero-allocation type abstraction</h1>
                
            
            
                
<p>Sometimes we need to enforce rules over types that already exist. For example, in <kbd>Ch03_AbstractPerson</kbd>, we have a <kbd>name</kbd> type that is just a <kbd>string</kbd>, and a <kbd>massage</kbd> function that takes a string and applies some rules to it to turn it into a "well-behaved" name. We put this type and function inside another module in a rather adhoc way, because we were focusing on the concept of "person" and its operations and not so much on "name" and its operations.</p>
<p>However, we don't necessarily want to make a brand-new type for names that will allocate values on top of the already-allocated name strings. We'd like to preserve our naming rules (casing and trimming) while also being cheap with memory use.</p>
<p>Let's extract the <kbd>name</kbd> type alias and its <em>smart constructor</em> (a <kbd>make</kbd> function that applies the rules we want to enforce when it makes values) into a dedicated module (again, note that we must define both the interface and implementation files for the module to be complete):</p>
<pre>/* src/Ch03/Ch03_Person.rei */<br/><br/>module <em>Name</em>: { /* (1) */<br/>  type <strong>t</strong>;<br/>  let <em>make</em>: <strong>string</strong> =&gt; <strong>t</strong>;<br/>  let <em>toString</em>: <strong>t</strong> =&gt; <strong>string</strong>;<br/>};<br/><br/>type <strong>id</strong> = <strong>int</strong>; /* (2) */<br/>type <strong>t</strong> = {<em>id</em>, <em>name</em>: <em>Name</em>.<strong>t</strong>}; /* (3) */<br/><br/>let <em>make</em>: (<strong>id</strong>, <em>Name</em>.<strong>t</strong>) =&gt; <strong>t</strong>; /* (4) */<br/>let <em>id</em>: <strong>t</strong> =&gt; <strong>id</strong>;<br/>let <em>name</em>: <strong>t</strong> =&gt; <em>Name</em>.<strong>t</strong>;<br/><br/>/* src/Ch03/Ch03_Person.re */<br/>module <em>Name</em> = {<br/>  type <strong>t</strong> = <strong>string</strong>; /* (5) */<br/>  let <em>make</em>(<em>string</em>) = <em>String</em>.(<em>capitalize</em>(<em>trim</em>(<em>string</em>))); /* (6) */<br/>  let <em>toString</em>(<em>t</em>) = <em>t</em>; /* (7) */<br/>};<br/><br/>type <strong>id</strong> = <strong>int</strong>;<br/>type <strong>t</strong> = {<em>id</em>, <em>name</em>: <em>Name</em>.<strong>t</strong>};<br/><br/>let <em>make</em>(<em>id</em>, <em>name</em>) = {<em>id</em>, <em>name</em>};<br/>let <em>id</em>(<em>t</em>) = <em>t.id</em>;<br/>let <em>name</em>(<em>t</em>) = <em>t.name</em>;</pre>
<p>What's new here:</p>
<ol>
<li>We declare a nested <kbd>Name</kbd> module with the given module type. We're telling Reason: <em>Ch03_Person contains a module Name that exports these items</em>. Note that the <kbd>Name</kbd> module's <kbd>t</kbd> type is abstract.</li>
<li>We don't make the <kbd>id</kbd> type abstract because we don't have to enforce any rules about how it should be created (we might in future though).</li>
<li>We don't need to make the <kbd>Ch03_Person.t</kbd> type abstract anymore now, because we've moved the name type and creation logic into <kbd>Name</kbd>. There's no way anyone can create the wrong <kbd>Ch03_Person.t</kbd> values because they must still go through <kbd>Name.make</kbd> to get names.</li>
</ol>
<ol start="4">
<li>We make the <kbd>Ch03_Person</kbd> module functions use the <kbd>Name.t</kbd> type now.</li>
<li>The <kbd>Name.t</kbd> type is implemented as just a <kbd>string</kbd>. It will not allocate anything at runtime.</li>
<li>The <kbd>make</kbd> smart constructor will automatically enforce our rules for correct names. Also, we use the <kbd>ModuleName.(expression)</kbd> syntax here to temporarily <em>open</em> the <kbd>String</kbd> module for the scope of this one expression, bringing all its contained values into visibility. Opening modules temporarily in small scopes can be very handy to save some typing–but opening them for larger scopes can be risky because of potential name clashes.</li>
<li>Because <kbd>Name.t</kbd> is already just a <kbd>string</kbd>, <em>converting it back</em> to a <kbd>string</kbd> in <kbd>toString</kbd> entails just returning the input value.</li>
</ol>
<p>This structuring hits a good balance:</p>
<ul>
<li>It exposes the <kbd>person</kbd> record-type definition so that users can examine and use their values easily</li>
<li>It imposes control over a critical piece of <kbd>person</kbd> data: the name</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Preventing type mix-ups</h1>
                
            
            
                
<p>Earlier, I mentioned that we don't need to make the <kbd>id</kbd> type abstract because we don't have any rules for it right now. But there's another good reason to make a simple type abstract: preventing mix-ups between the same <em>physical</em> types (in terms of the implementation) that represent different <em>logical</em> concepts.</p>
<p>For example, suppose you had the following function and usage:</p>
<pre>let <em>payBill</em>(<em>personId</em>, <em>businessId</em>) = ...;<br/><em>payBill</em>(<em>acmeCo.id</em>, <em>bob.id</em>);</pre>
<p>In <kbd>Ch02_Demo</kbd> we made the ID types, for both <kbd>person</kbd> and <kbd>company</kbd>, <kbd>int</kbd>. This can backfire if we accidentally pass function arguments in the wrong order and our system tries to <em>pay a bill</em> from a company to a person.</p>
<p>We can prevent this kind of mix-up using a technique similar to the preceding one: make the person ID and company ID types logically distinct, while still physically representing them internally with just <kbd>int</kbd>. Here's an example:</p>
<pre>/* src/Ch03/Ch03_Id.re */<br/>module type <strong>Id</strong> = { /* (1) */<br/>  type <strong>t</strong>;<br/>  let <em>make</em>: <strong>int</strong> =&gt; <strong>t</strong>;<br/>  let <em>toInt</em>: <strong>t</strong> =&gt; <strong>int</strong>;<br/>};<br/><br/>module <em>IntId</em> = { /* (2) */<br/>  type <strong>t</strong> = <strong>int</strong>;<br/>  let <em>make</em>(<em>int</em>) = <em>int</em>;<br/>  let <em>toInt</em>(<em>t</em>) = <em>t</em>;<br/>};<br/><br/>module <em>PersonId</em>: <strong>Id</strong> = <em>IntId</em>; /* (3) */<br/>module <em>CompanyId</em>: <strong>Id</strong> = <em>IntId</em>;<br/><br/>let <em>bobId</em> = <em>PersonId.make</em>(1); /* (4) */<br/>let <em>acmeCoId</em> = <em>CompanyId.make</em>(1);<br/>/*<br/>let result = bobId == acmeCoId; /* (5) */<br/>*/</pre>
<p>In the preceding code, some very interesting things are happening:</p>
<ol>
<li>We define an <kbd>Id</kbd> module signature, which declares an abstract <kbd>t</kbd> type, and a constructor and extractor function for values of <kbd>t</kbd></li>
<li>We define an <kbd>IntId</kbd> module, with no explicit signature, which exposes a <kbd>t</kbd> type equal to <kbd>int</kbd>, and constructor and extractor functions of the same name as in the <kbd>Id</kbd> signature</li>
<li>We define two module aliases, <kbd>PersonId</kbd> and <kbd>CompanyId</kbd>, to <kbd>IntId</kbd>, and give them the explicit <kbd>Id</kbd> signature</li>
<li>We make <kbd>PersonId.t</kbd> and <kbd>CompanyId.t</kbd> values</li>
<li>If we tried to compare the values, we'd get a type error:</li>
</ol>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch03/Ch03_Id.re 19:23-30<br/>  <br/>  17 │ let bobId = PersonId.make(1);<br/>  18 │ let acmeCoId = CompanyId.make(1);<br/>  <strong>19</strong> │ let result = bobId == <strong>acmeCoId</strong>;<br/>  <br/>  This has type:<br/>    <strong>CompanyId.t</strong><br/>  But somewhere wanted:<br/>    PersonId.t</pre>
<p>So, Reason is able to distinguish between the two types, even though they're physically the same type, backed by the same module (<kbd>IntId</kbd>), just because they were explicitly annotated with a module type (<kbd>Id</kbd>) that prevents Reason from "seeing" the underlying types. Because of the signature and the abstract <kbd>t</kbd> type, Reason can't prove that <kbd>CompanyId.t</kbd> and <kbd>PersonId.t</kbd> are the same, so trying to compare them is a type error.</p>
<p>Note that making these modules, even with explicit signatures, is very cheap allocation-wise:</p>
<pre>// src/Ch03/Ch03_Id.bs.js<br/>function <em>make</em>(<em>$$int</em>) { return <em>$$int</em>; }<br/>function <em>toInt</em>(<em>t</em>) { return <em>t</em>; }<br/><br/>var <em>IntId</em> = [<em>make</em>, <em>toInt</em>];<br/>var <em>PersonId</em> = <em>IntId</em>;<br/>var <em>CompanyId</em> = <em>IntId</em>;<br/><br/>var <em>bobId</em> = 1;<br/>var <em>acmeCoId</em> = 1;</pre>
<p>Reason reuses the same <kbd>IntId</kbd> module and distinguishes between their types purely at compile time. We can thus elegantly separate our concerns:</p>
<ul>
<li>The <kbd>Id</kbd> signature just says that there's a <kbd>t</kbd> type that can be converted to and from <kbd>int</kbd></li>
<li><kbd>IntId</kbd> implements a module that is compatible with the <kbd>Id</kbd> signature but not explicitly annotated with it; thus showing that int-backed ID modules are one possible implementation of the <kbd>Id</kbd> signature</li>
<li>The <kbd>PersonId</kbd> and <kbd>CompanyId</kbd> modules take advantage of the combination of <kbd>Id</kbd> and <kbd>IntId</kbd> to achieve type safety by telling the compiler it can't assume that the ID types are the same (even though we know they are)</li>
</ul>
<p>As you can see, in Reason we have a level of fine-grained power that takes advantage of the compiler to achieve very lightweight code. We will see more techniques like this in future chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered how to package types and values together with modules, how to specify exactly what surface area we want to expose from our modules using signatures, and how to keep tight control over our data types using the combination of modules and signatures–even to the extent of controlling the memory allocation of data in our modules. In Reason, you'll notice this pattern a lot–you design the types to ensure that certain rules are enforced, and in a lot of situations, they will be enforced at no runtime cost.</p>
<p>So, stay tuned—in the next chapter, we will cover some of the most important types that we use on a daily basis in type-driven development: product types that group values together for easy access.</p>


            

            
        
    </body></html>