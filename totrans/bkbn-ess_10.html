<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Keeping the Bugs Out &#x2013; How to Test a Backbone Application" id="aid-2KS221"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Keeping the Bugs Out – How to Test a Backbone Application</h1></div></div></div><p>In this chapter, we'll look at the challenges of testing a Backbone application, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Choosing a unit testing framework</li><li class="listitem">Deciding between the BDD and the TDD testing styles</li><li class="listitem">Mocking out related components in tests</li><li class="listitem">Using Selenium to create acceptance-level tests</li></ul></div><div class="section" title="Testing in JavaScript?"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Testing in JavaScript?</h1></div></div></div><p>For many years, the idea of <a id="id282" class="indexterm"/>testing JavaScript code was laughable. After all, who would write a testing suite for a bunch of form validation scripts? Moreover, even if you <a id="id283" class="indexterm"/>were doing something more interesting that could actually benefit from testing, there were no JavaScript libraries that facilitated testing, so it had to be done from scratch.</p><p>In 2008, all this changed as a wave of new automated JavaScript testing tools emerged. All of these libraries focused on unit testing or testing of a specific part of the code (usually, a single method or small class). Two of the first unit testing libraries, QUnit and Jasmine, offered dueling approaches (TDD versus BDD) for testing in the browser, while a third library, JS Test Driver, offered testing at the command line. Soon after them came a number of other unit testing libraries, including Buster.js and Mocha.js, as well as test support or <code class="literal">mock</code> libraries such as JsMockito, JSMock, and Sinon.JS.</p><p>Today, as JavaScript developers create ever more advanced web applications (particularly, the kind made possible by Backbone), testing has become absolutely essential. Testing can prevent bugs that, because of the code's complexity, would otherwise have been difficult or even impossible to find. Further, perhaps, just as importantly, a proper suite of tests allows developers to safely refactor their code, which is a frequent and necessary task for keeping a code base maintainable.</p><p>At this point, it's no exaggeration to say that if you are a building a serious web application using Backbone, a testing suite isn't just a luxury, it's a necessity.</p></div></div>
<div class="section" title="Which library to use" id="aid-2LQIK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Which library to use</h1></div></div></div><p>Building proper testing capabilities<a id="id284" class="indexterm"/> for a modern web application requires the following three main pieces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A unit-testing framework: a tool to test specific units (usually functions or small classes) of code</li><li class="listitem">A mocking library: a tool that facilitates testing by creating fake versions of objects</li><li class="listitem">An acceptance testing framework: a tool for testing complete user experiences, such as logging in to your site or ordering a product</li></ul></div><p>Depending on which unit-testing library you select, you may also want to download additional tools. For instance, many libraries offer alternate styles of test reports, which must be downloaded and included separately. Moreover, if you use a library that lacks the ability to run tests at the command line, you may wish to add this functionality with a headless web browser such as the very popular PhantomJS, Doing so will make it easier to automate your tests so that they can, for instance, run periodically or in response to code checks-ins. While there are several different mocking libraries to choose from (we'll explain why you want one in a moment), we recommend using the most popular, Sinon.JS. Sinon is both powerful enough and easy enough to use, and thus, it's a great fit for just about any project. Similarly, there is really only one main option for acceptance testing and that is Selenium. We'll discuss Selenium at the end of the chapter, so for now, we will focus on the choice of a unit testing library.</p><p>There are far too many high-quality testing libraries, with far too many differences in features, to possibly cover them all properly in this book. However, we do need to choose a library for the examples in this chapter, and so, we've opted to use Mocha.js. Mocha is one of the newer libraries available as well as one of the most robust and powerful. Mocha can be used either with the traditional xUnit/TDD style used by libraries such as QUnit, or with the BDD style popularized (in JavaScript at least) by Jasmine. Further, while it can be run in the browser, it can also be run (by using PhantomJS) at the command line as well.</p><p>On top of all this, Mocha offers its users the choice of four different assertion libraries. While other major testing libraries include assertions as part of the library itself (which admittedly is more convenient: there is one less file to download), Mocha prefers to give developers a choice. Because there are subtle differences possible in the way assertions are implemented, Mocha lets you select the style so that you can have the style that most appeals to you.</p><p>However, while we will be using <a id="id285" class="indexterm"/>Mocha throughout this chapter, much of what we'll be demonstrating will in fact be similar (if not identical) to how many of the other popular testing libraries work.</p></div>
<div class="section" title="Getting started with Mocha"><div class="titlepage" id="aid-2MP362"><div><div><h1 class="title"><a id="ch10lvl1sec85"/>Getting started with Mocha</h1></div></div></div><p>To use Mocha, you<a id="id286" class="indexterm"/> will first need to download the <code class="literal">mocha.css</code> and <code class="literal">mocha.js</code> files from the project's GitHub page<a id="id287" class="indexterm"/> (which can be found at <a class="ulink" href="https://github.com/mochajs/mocha">https://github.com/mochajs/mocha</a>). You will also need to download an assertion library; for this example, we'll be<a id="id288" class="indexterm"/> using <code class="literal">Expect.js</code> (which you can download from <a class="ulink" href="https://github.com/Automattic/expect.js">https://github.com/Automattic/expect.js</a>).</p><p>Next, you will need to create a new HTML page and add script tags for all of your application's JavaScript files, as well as all library files (for instance, Backbone and jQuery). You'll also need to add a few bits of Mocha boilerplate code. All together you should wind up with an HTML file that looks something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;!-- External Library Files --&gt;
&lt;script src="/underscore.js"&gt;&lt;/script&gt;
&lt;script src="/jQuery.js"&gt;&lt;/script&gt;
&lt;script src="/Backbone.js"&gt;&lt;/script&gt;

&lt;!-- Application-Specific Files --&gt;
&lt;script src="/SomeModel.js"&gt;&lt;/script&gt;
&lt;script src="/SomeView.js"&gt;&lt;/script&gt;
&lt;script src="/SomeOtherNonBackboneCode.js"&gt;&lt;/script&gt;

&lt;!-- Test Library Files --&gt;
&lt;script src="/mocha.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" type="text/css" href="/mocha.css"&gt;&lt;/link&gt;
&lt;script src="/expect.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="mocha"&gt;&lt;/div&gt;
&lt;!-- Test Code --&gt;
&lt;script&gt;
mocha.setup('bdd'); // start Mocha in BDD mode
// *INSERT TESTS HERE*
mocha.run();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><div class="section" title="TDD versus BDD: What's the difference?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec36"/>TDD versus BDD: What's the difference?</h2></div></div></div><p>In the preceding code, we call <code class="literal">mocha.setup</code> (bdd), which starts Mocha in the BDD mode (as opposed to the TDD mode). But what does this even mean?</p><p>
<span class="strong"><strong>Test Driven Development </strong></span>(<span class="strong"><strong>TDD</strong></span>) is a <a id="id289" class="indexterm"/>style of development where the developer begins all his work by writing a (failing) test case. The developer then adds just enough code to his application to make that test pass, but no more than that. As soon as the test passes, the developer writes a new (failing) test and repeats the cycle.</p><p>The advantages of TDD are two-fold. First, by always writing a test first, the developer guarantees that his code will always be completely covered by tests. Second, the TDD style naturally forces developers to write their code in a testable fashion, which means adopting practices like writing several short functions instead of one long one. As we mentioned in the previous chapter, these practices have benefits that go beyond the test environment.</p><p>However, TDD also has its downsides. Perhaps, the most significant one is that it can result in excessive, useless tests, which require significant time to maintain. Also, by its very nature, TDD focuses heavily on <span class="emphasis"><em>how</em></span> the code does instead of what it does, but many programmers would argue that <span class="emphasis"><em>what</em></span> the code does is far more important to test.</p><p>This distinction is particularly important when refactoring. By definition, a refactoring operation is required when you change how the code does what it does without changing what it does. Because TDD-based tests focus so heavily on the how, whenever a refactoring occurs, the tests need to be updated to match the new code.</p><p>
<span class="strong"><strong>Behavior Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>) is<a id="id290" class="indexterm"/> very similar to TDD but attempts to solve the problems related to TDD by focusing on what the code does. This is achieved largely by using a slightly more verbose syntax for organizing tests and test suites. Of course, one doesn't necessarily need a different syntax to write tests that focus on what the code does, but the benefit of the BDD syntax is that it naturally encourages such behavior.</p><p>Consider the following imaginary test of the Backbone set method of <code class="literal">Model</code>, written using Mocha's TDD syntax and the better-assert assertion library. It works by creating <code class="literal">testModel</code>, setting an attribute (<code class="literal">a</code>) with a value (<code class="literal">1</code>), and then confirming that the attribute/value pair has been added to the test attributes of <code class="literal">Model</code>:</p><div class="informalexample"><pre class="programlisting">suite('Model', function() {
    var testModel;
    setUp(function() {
        testModel = new Backbone.Model();
    });
    suite('set', function() {
        test('set adds a value to the model\'s attributes', function() {
            testModel.set('a', 1);
            assert(testModel.attributes.a === 1);
        });
    });
});</pre></div><p>As you can see, in the <a id="id291" class="indexterm"/>TDD code, a test is registered using a <code class="literal">test</code> function and groups of <a id="id292" class="indexterm"/>tests are organized into suites. Also, the test verifies the validity of the code by using an <code class="literal">assert</code> statement. Now, let's look at a similar imaginary test created using the BDD syntax:</p><div class="informalexample"><pre class="programlisting">describe('Model', function() {
    var testModel;
    beforeEach(function() {
        testModel = new Backbone.Model();
    });
    describe('#set', function() {
        it('sets a value that "get" can retrieve', function() {
            testModel.set('a', 1);
            expect(testModel.get('a')).to.be(1);
        });
    });
});</pre></div><p>Notice how similar the two tests are: While the first example uses <span class="emphasis"><em>suite</em></span> and the second uses <span class="emphasis"><em>describe</em></span>, both functions have the same effect of grouping tests. Similarly, in the BDD example, tests are still defined and still contain validity checks, but the tests are defined with an <code class="literal">it</code> function, and instead of assertions, we have expectations (expect calls).</p><p>However, there are two important differences that go beyond just the names of the functions. First, the latter example reads much more like an English sentence, making it easier to read both in the code, and later on, when viewing the test results. Second, and more importantly, the first test emphasizes how <code class="literal">set</code> works, while the second one emphasizes what it should do. While there is nothing inherent in either the TDD or the BDD style that forces either test to be written in a certain way, this example highlights how the syntax can nevertheless influence a test's design. This can become important later on if the Backbone developers ever change Backbone to use a different name instead of <span class="emphasis"><em>attributes</em></span>, as they will then have to rewrite the first test while the second one would continue working without adjustment.</p><p>Ultimately it is <a id="id293" class="indexterm"/>possible to test what your code does with either style of test, and so, it's<a id="id294" class="indexterm"/> really just a question of which style you prefer. However, if you have no opinion one way or the other, the BDD syntax is probably a better starting point, both for its improved readability and for its natural emphasis on describing what the code should do. For these reasons, we'll continue to use the BDD syntax in the rest of this chapter.</p></div><div class="section" title="Describe, beforeEach, and it"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec37"/>Describe, beforeEach, and it</h2></div></div></div><p>If you've used testing libraries in other languages before you might already understand the preceding code, but if not allow me to explain. The test starts with a call to Mocha's <code class="literal">describe</code> function. This function creates a <span class="emphasis"><em>suite</em></span> (or grouping) of tests, and you optionally nest more<a id="id295" class="indexterm"/> <code class="literal">describe</code> functions <a id="id296" class="indexterm"/>to further organize your tests. One benefit of using <code class="literal">describe</code> statements is that when you go to run your tests, you can choose to only run a specific suite defined by <code class="literal">describe</code>, rather than running all of them at once. The <code class="literal">describe</code> function takes two arguments: a string indicating what is being described, and a function that is used to wrap all of the tests within the <code class="literal">describe</code> function.</p><p>Next, we have a <code class="literal">beforeEach</code> call that, as you might imagine, defines code that will run before each test. This can be a <a id="id297" class="indexterm"/>useful place to separate code that is common to all of the <a id="id298" class="indexterm"/>tests in the <code class="literal">describe</code> statement (such as the creation of a new <code class="literal">Backbone.Model</code> class in the preceding example). Mocha also has an equivalent <code class="literal">afterEach</code> function that runs similarly after each test completes and can be used to clean up the side effects of the tests. Mocha also has <code class="literal">before</code> and <code class="literal">after</code> functions, which are similar except that they only run once per <code class="literal">describe</code> statement (that is per suite), rather than once per test.</p><p>After another <code class="literal">describe</code> (this time to group tests related to <code class="literal">set</code>), we get to the <code class="literal">it</code> function, which actually defines a specific test. Like <code class="literal">describe</code>, <code class="literal">it</code> takes two arguments: a string that describes what it (the code being tested) <a id="id299" class="indexterm"/>should do, and a function that tests whether the indicated behavior is actually occurring. If the function passed to the <code class="literal">it</code> function<a id="id300" class="indexterm"/> completes without throwing an error, Mocha will consider this test to have passed, whereas if an error is thrown, it will instead mark that test as failed (and provide the stack trace of the thrown error in the test output so that you can easily debug the relevant code).</p><p>Finally, we have the <code class="literal">expect</code> function (which could just as easily be called <code class="literal">assert</code> or something else had we chosen a different assertion library). The <code class="literal">expect</code> function takes a single argument and then uses jQuery-like chaining to assert something about the first argument. Here are a few examples:</p><div class="informalexample"><pre class="programlisting">expect(1).to.be(1); // asserts that 1 === 1
expect(1).not.to.be(2); // asserts that 1 !== 2
expect(1).to.eql("1") // asserts that 1 == "1"
expect(1).to.be.ok(); // asserts that 1 is "truthy" (evaluates true when used as a boolean)
expect(1).to.be.a('number'); // asserts typeof 1 === 'number'</pre></div><p>The <code class="literal">Expect.js</code> library has several other forms of assertions as well, all of which you can find detailed on their GitHub page.</p></div><div class="section" title="Running our test"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec38"/>Running our test</h2></div></div></div><p>Now that we understand <a id="id301" class="indexterm"/>how everything works, let's try to actually run our test. To do this, simply replace the following line in our HTML file with the <code class="literal">describe</code> code provided earlier:</p><div class="informalexample"><pre class="programlisting">// *INSERT TESTS HERE*</pre></div><p>Alternatively, you can also choose to put the <code class="literal">describe</code> code into a separate file and replace the insert line with a script tag that references this file. Either way, save the file and open it up in your favorite web browser. You should see something like this:</p><div class="mediaobject"><img src="../Images/image00169.jpeg" alt="Running our test"/></div><p style="clear:both; height: 1em;"> </p><p>Our test passes!</p></div></div>
<div class="section" title="Introducing mocks" id="aid-2NNJO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Introducing mocks</h1></div></div></div><p>As long as the code we're testing<a id="id302" class="indexterm"/> remains relatively simple, Mocha and Expect.js are all that we need to test it. However, the code rarely remains simple, and there are two complications in particular that can make us need another tool, known as a <code class="literal">mocking</code> library, to let us create fake versions or mocks of our objects.</p><p>First, let's imagine we want to test the following method of an imaginary <code class="literal">ExampleModel</code> class:</p><div class="informalexample"><pre class="programlisting">foo: function() {
    this.bar += 1;
    this.baz();
}</pre></div><p>Now, we'll want to test whether our <code class="literal">foo</code> method calls the <code class="literal">baz</code> method. However, at the same time, we will (presumably) already have a separate test of the <code class="literal">baz</code> method itself. This leaves us with a dilemma: how can we test that <code class="literal">foo</code> calls <code class="literal">baz</code> without repeating the test code for <code class="literal">baz</code> inside the test code for <code class="literal">foo</code>?</p><p>Alternatively, let's consider another imaginary method that we might want to test:</p><div class="informalexample"><pre class="programlisting">fetchThenDoFoo: function() {
    this.fetch().done(this.foo);
}</pre></div><p>In this case, we want to test whether <code class="literal">foo</code> is called after the <code class="literal">fetch</code> operation completes, but to truly test this, we'd need to actually fetch a <code class="literal">Model</code> class from the server by using AJAX. This, in turn, would make our tests require an active server, making them significantly slower and opening up the possibility of the tests causing side effects on our server.</p><p>The solution to both of these problems is to use a mocking library such as <code class="literal">Sinon.js</code>. To do this, simply download sinon.js <a id="id303" class="indexterm"/>from <a class="ulink" href="http://sinonjs.org/">http://sinonjs.org/</a> and then include this file (via a <code class="literal">script</code> tag) on your test running the HTML page.</p><p>Once Sinon is available, we<a id="id304" class="indexterm"/> can use it to solve our testing problems. First, let's use it to create a special kind of mock called <code class="literal">stub</code> for a test of our <code class="literal">foo</code> method as follows:</p><div class="informalexample"><pre class="programlisting">describe('foo', function() {
    var bazStub,
        example;
    beforeEach(function() {
        example = new ExampleModel();
        // Replace the real "baz" with a fake one that does nothing
        bazStub = sinon.stub(example, 'baz');
    });
    it('calls baz', function() {
        example.foo();
        expect(bazStub.calledOnce).to.be(true); // did foo call baz?
    });
    afterEach(function() {
        // Restore the original baz (in case another test uses it)
        baz.restore();
    });
});</pre></div><p>As you can see in the preceding code, we were able to use Sinon to create <code class="literal">stub</code> that replaced the normal <code class="literal">baz</code> method. While this <code class="literal">stub</code> didn't actually do anything, it did keep track of how many times it was called (as well as which arguments were used, although we didn't test this), which let us write a test that ensured that <code class="literal">foo</code> would call <code class="literal">baz</code> without having to repeat any of the test code for <code class="literal">baz</code>.</p><p>For our second problem, that of testing an AJAX method, we could use an AJAX-specific mock tool such as MockJax. However, Sinon is so powerful that we really don't need to use anything else; consider the <a id="id305" class="indexterm"/>following test:</p><div class="informalexample"><pre class="programlisting">describe('fetchThenDoFoo', function() {

    var fetchStub,
        fooStub,
        example;
    beforeEach(function() {
        example = new ExampleModel();
        // Replace the real "fetch" with a fake one that returns an
        // already-resolved $.Deferred
        var deferred = new $.Deferred().resolve();
        fetchStub = sinon.stub(example, 'fetch').returns(deferred);
        // Since we only want to test whether or not foo was called,
        // we can also use stub for it
        fooStub = sinon.stub(example, 'foo');
    });
    it('calls foo after fetch completes', function() {
        example.fetchThenDoFoo();
        expect(fooStub.calledOnce).to.be(true);
    });
    afterEach(function() {
        // Restore the original versions of our stub functions
        fetchStub.restore();
        fooStub.restore();
    });
});</pre></div><p>In this example, we used two <code class="literal">stub</code> functions. We used the <code class="literal">fooStub</code> function in a manner similar to how we used the <code class="literal">bazstub</code> function in the previous example, to check whether or not <code class="literal">foo</code> got called, but our <code class="literal">fetchStub</code> served a different purpose. By chaining a <code class="literal">returns</code> method call off of our stub's creation, we created a <code class="literal">stub</code> function that (unlike the previous <code class="literal">stub</code> functions) actually did something: it returned our resolved deferred function. Since jQuery treats a resolved deferred function the same way as it treats a completed AJAX call (by invoking any done code for the call), we simulated the return of an AJAX call without involving an actual server.</p><p>Sinon has many other useful methods related to <code class="literal">stub</code>, as well as other types of mocking functions such as <code class="literal">spy</code> and <code class="literal">mock</code>, all of which are very well documented on their website. Sinon also has a feature known as <code class="literal">sandbox</code>, which can allow you to eliminate all of the <code class="literal">baz.restore()</code> code by automatically activating it after every test run (when <code class="literal">sandbox</code> is cleaned up). Again, you can<a id="id306" class="indexterm"/> find all the details of this feature on Sinon's website.</p></div>
<div class="section" title="Selenium" id="aid-2OM4A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Selenium</h1></div></div></div><p>Up to this point, we've been <a id="id307" class="indexterm"/>focusing entirely on unit testing, but it is worth mentioning that there are many other forms of tests that can benefit a Backbone application, such as load tests, smoke tests, and usability tests. However, a detailed discussion of all these tests is outside the scope of this book, and in most workplace environments, these tests won't be the purview of the development team anyway. Instead, they will be managed by the quality assurance (QA) department.</p><p>However, there is one type of testing, acceptance testing, which is worth mentioning. In smaller organizations that lack a QA department, acceptance tests will often be created and maintained by developers, and even in larger organizations, it's not unheard of for developers to assist with the creation and maintenance of these tests.</p><p>Acceptance tests test the functionality of your site, by checking whether or not a user can perform a specific action. A given acceptance test might check whether the user can log in to a site, change his password, or place an order. Unlike unit tests, which test a small piece of the larger functionality (such as a single <code class="literal">placeOrder</code> function), acceptance tests validate all of the disparate functions that are used to complete a particular user interaction.</p><p>On the web, there is a single tool that almost completely dominates acceptance testing: the Selenium web driver<a id="id308" class="indexterm"/> (<a class="ulink" href="http://www.seleniumhq.org/">http://www.seleniumhq.org/</a>). The Selenium web driver allows you to create automated tests that perfectly simulate the actions of a real user on your site. A Selenium test can click a button, fill in a text field, scroll, and do just about anything else that an actual user can do.</p><p>Selenium is available for many different languages, including JavaScript. It can either be used directly via the Selenium web driver (<a class="ulink" href="https://code.google.com/p/selenium/wiki/WebDriverJs">https://code.google.com/p/selenium/wiki/WebDriverJs</a>) or be wrapped with a library that offers an alternate syntax such as Nightwatch.js<a id="id309" class="indexterm"/> (<a class="ulink" href="http://nightwatchjs.org/">http://nightwatchjs.org/</a>). Here's an example from the Nightwatch.js home page that demonstrates a simple acceptance test written with Nightwatch.js:</p><div class="informalexample"><pre class="programlisting">module.exports = {
    'Demo test Google' : function (client) {
        client
          .url('http://www.google.com')
          .waitForElementVisible('body', 1000)
          .assert.title('Google')
          .assert.visible('input[type=text]')
          .setValue('input[type=text]', 'rembrandt van rijn')
          .waitForElementVisible('button[name=btnG]', 1000)
          .click('button[name=btnG]')
          .pause(1000)
          .assert.containsText('ol#rso li:first-child',
            'Rembrandt - Wikipedia')
          .end();
  }
};</pre></div><p>As you can see from the <a id="id310" class="indexterm"/>preceding example, Nightwatch.js (and Selenium itself) uses the same selectors that you already use for CSS and jQuery, along with special methods such as <code class="literal">waitForElementVisibility</code> to control timing and prevent the automation script from moving too quickly through the test. This allows you to simulate any user story you want, no matter how simple or how complex it is, and then, repeat this story over and over to test your site.</p><p>However, Selenium-based tests do have their limits with the biggest being that because Selenium operates on the user level, it has no awareness of what's going on at the code level. If a Selenium test fails, it won't provide a stack trace or point you to a line of failing code; instead, it will simply alert you that a particular operation failed, and it will be up to you to debug it manually, just as you would with a user-submitted bug. Ideally, you should try and catch as many failures as you can in your unit test suite and only rely on Selenium-based acceptance tests to find bugs that "slip through the cracks" in your unit testing.</p></div>
<div class="section" title="Summary" id="aid-2PKKS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Summary</h1></div></div></div><p>In this chapter, we learned how to combine a variety of tools to test your Backbone applications. We learned the difference between TDD and BDD, as well as the differences between major testing libraries such as QUnit and Jasmine. We explored in depth how to use the Mocha framework to create a testing suite and how to use the Sinon library to mock out parts of your code within that suite.</p><p>In the next chapter, we'll look into a variety of other third-party tools that can help you create Backbone applications. We'll look at general-purpose tools, such as the Require.js dependency management system, and Backbone-specific tools, such as BackGrid and BackSupport.</p></div></body></html>