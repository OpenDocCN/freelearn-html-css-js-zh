<html><head></head><body>
		<div><h1 id="_idParaDest-219" class="chapter-number"><a id="_idTextAnchor221"/>12</h1>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor222"/>Building Better Containers – Functional Data Types</h1>
			<p>In <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Design Patterns</em>, we went over how to use functions to achieve different results. In this chapter, we will look at data types from a functional point of view. We’ll be considering how we can implement our own data types, along with several features that can help us compose operations or ensure their purity so that our FP coding will become simpler and shorter.</p>
			<p>We’ll be touching on several topics:</p>
			<ul>
				<li><strong class="bold">Data types</strong> from a functional <a id="_idIndexMarker964"/>point of view. Even though JavaScript is not a typed language, a better understanding of types and functions is needed, to complement our usage of TypeScript.</li>
				<li><strong class="bold">Containers</strong>, including functors and the mystifying monads, to structure a data flow.</li>
				<li><strong class="bold">Functions as structures</strong>, in which we’ll see yet another way of using functions to represent data types, with immutability thrown in as an extra.</li>
			</ul>
			<p>With that, let’s get started!</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor223"/>Specifying data types</h1>
			<p>Even though<a id="_idIndexMarker965"/> JavaScript is a dynamic language, without static or explicit typing declarations and controls, it doesn’t mean you can simply ignore types. Even if the language doesn’t allow you to specify the types of your variables or functions, you still work—even if only in your head—with types. Specifying types has advantages, as follows:</p>
			<ul>
				<li>TypeScript can detect compile-time errors, avoiding many bugs.</li>
				<li>It will help if you move from JavaScript to a <a id="_idIndexMarker966"/>more functional language, such as Elm (see <a href="http://elm-lang.org">elm-lang.org</a>).</li>
				<li>It serves as documentation that lets future developers understand what type of arguments they must pass to the function and what type it will return. All the functions in the Ramda library are documented in this way.</li>
				<li>It will also help us with the<a id="_idIndexMarker967"/> functional data structures we will cover later in this section, where we will examine a way of dealing with structures, similar to what you do in fully functional languages such as Haskell.</li>
			</ul>
			<p>Why are we discussing types again, after using TypeScript throughout the whole book? The reason is that in most FP texts, a different style is used. TypeScript definitions are just, well, TypeScript, but the definitions we’ll see here can be applied to any other language. Let’s forget TypeScript for a minute and start thinking about a new type system. We’ll start with functions, the most relevant type, and then consider other definitions.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor224"/>Signatures for functions</h2>
			<p>The specification of a<a id="_idIndexMarker968"/> function’s arguments and the result are given by a signature. Type signatures are based on a type system called <strong class="bold">Hindley–Milner</strong> (<strong class="bold">HM</strong>), which<a id="_idIndexMarker969"/> influenced several (mostly functional) languages, including Haskell, though the notation has changed from that of the original paper. This system can even deduce types that are not directly given, in the same way that TypeScript or Flow does. Instead of providing a dry, formal explanation about the rules for writing correct signatures, let’s work with examples. We only need to know the following:</p>
			<ul>
				<li>We will be writing the type declaration as a comment</li>
				<li>The function name is written first, and then <code>::</code>, which can be read as <em class="italic">is of type</em> or <em class="italic">has type</em></li>
				<li>Optional constraints may follow, with a double (fat) arrow <code>⇒</code> (or <code>=&gt;</code> in basic ASCII fashion, if you cannot type in the arrow) afterward</li>
				<li>The input type of the function follows, with a <code>→</code> (or <code>-&gt;</code>, depending on your keyboard)</li>
				<li>The result type of<a id="_idIndexMarker970"/> the function comes last</li>
			</ul>
			<p class="callout-heading">Careful with arrows!</p>
			<p class="callout">An advance warning: check out the arrow styles we’ll use; they are not what TypeScript uses! A “thin” arrow will be used instead of <code>=&gt;</code>, and a “fat” arrow will be used to specify a generic constraint; be careful!</p>
			<p>Now, we can begin with some examples. Let’s define the type for a simple function that capitalizes a word, and do the same for the <code>Math.random</code> function:</p>
			<pre class="source-code">
// <strong class="bold">firstToUpper :: String → String</strong>
const firstToUpper = (s: string): string =&gt;
  s[0].toUpperCase() + s.substring(1).toLowerCase();
// <strong class="bold">Math.random :: () → Number</strong></pre>
			<p>These are simple cases—only take the signatures into account here; we are not interested in the actual functions. The arrows denote functions. The first function receives a string as an argument and returns a new string. The second one receives no arguments (as indicated by the empty parentheses) and returns a floating-point number. So, we can read the first signature as <code>firstToUpper()</code> <em class="italic">is a function of the type that receives a string and returns a string</em>. We can speak similarly about the maligned (impurity-wise) <code>Math.random()</code> function, the only difference being that it doesn’t receive arguments.</p>
			<p>Comparing the new type definition with TypeScript, it’s clear that they are very much alike. However, the new style is clearer. You could have also defined <code>firstToUpper()</code> in the following way, without specifying the result type (because TypeScript can work it out), but with HM types, you have to provide all the details, providing more clarity:</p>
			<pre class="source-code">
// <strong class="bold">firstToUpper :: String → String</strong>
const firstToUpper = (s: string) =&gt;
  s[0].toUpperCase() + s.substring(1).toLowerCase();</pre>
			<p>Another detail is that in this new way of specifying types, the type descriptions stand on their own, without being mixed with the details of the programming language—you don’t need to understand JavaScript, TypeScript, or any other language to figure out what types are involved in a function.</p>
			<p>We’ve already<a id="_idIndexMarker971"/> looked at functions with zero or one parameter, but what about functions with more than one? There are two answers to this. If we are working in a strict functional style, we would always be currying (as we saw in <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>), so all the functions would be unary. The other solution is enclosing a list of argument types in parentheses. We can see both of these solutions in the following code:</p>
			<pre class="source-code">
// <strong class="bold">sum3C :: Number → Number → Number → Number</strong>
const sum3C = curry(
  (a: number, b: number, c: number): number =&gt; a + b + c
);
// <strong class="bold">sum3 :: (Number, Number, Number) → Number</strong>
const sum3 = (a: number, b: number, c: number) =&gt; a + b +
  c;</pre>
			<p>Remember that <code>sum3c()</code> is actually <code>(a) =&gt; (b) =&gt; (c) =&gt; a + b + c</code>; this explains the first signature, which can also be read as follows:</p>
			<pre class="source-code">
// <strong class="bold">sum3C :: Number → (Number → (Number → (Number)))</strong>
const sum3C = curry(
  (a: number, b: number, c: number): number =&gt; a + b + c
);</pre>
			<p>After you provide the first argument to the function, you are left with a new function, which also expects an argument and returns a third function, which, when given an argument, will produce the final result. We won’t be using parentheses because we’ll always assume this<a id="_idIndexMarker972"/> grouping from right to left.</p>
			<p>Now, what about higher-order functions, which receive functions as arguments? The <code>map()</code> function poses a problem: it works with arrays of any type. Also, the mapping function can produce any type of result. For these cases, we can specify generic types, identified by lowercase letters. These generic types can stand for any possible type. For arrays themselves, we use brackets. So, we would have the following:</p>
			<pre class="source-code">
// <strong class="bold">map :: [a] → (a → b) → [b]</strong>
const map = curry(&lt;A, B&gt;(arr: A[], fn: (x: A) =&gt; B) =&gt;
  arr.map(fn)
);</pre>
			<p>It’s perfectly valid to have <code>a</code> and <code>b</code> represent the same type, as in a mapping that’s applied to an array of numbers, which produces another array of numbers. The point is that, in principle, <code>a</code> and <code>b</code> may stand for different types, which we described previously. This definition requires using generic types in TypeScript, <code>A</code> and <code>B</code> in our case.</p>
			<p>Note that if we weren’t currying, the signature would have been <code>([a], (a → b)) → [b]</code>, showing a function that receives two arguments (an array of elements of type <code>a</code> and a function that maps from type <code>a</code> to type <code>b</code>) and produces an array of elements of type <code>b</code> as its result.</p>
			<p>We can similarly write the following:</p>
			<pre class="source-code">
// <strong class="bold">filter :: [a] → (a → Boolean) → [a]</strong>
const filter = curry(&lt;A&gt;(arr: A[], fn: (x: A) =&gt; B) =&gt;
  arr.filter(fn)
);</pre>
			<p>And now the big one: what’s the signature for <code>reduce()</code>? Be sure to read it carefully and see whether you can work out why it’s written that way. You may prefer thinking about the second part of the signature as if it were <code>((b, a) → </code><code>b)</code>:</p>
			<pre class="source-code">
// <strong class="bold">reduce :: [a] → (b → a → b) → b → b</strong>
const reduce = curry(
  &lt;A, B&gt;(arr: A[], fn: (a: B, v: A) =&gt; B, acc: B) =&gt;
    arr.reduce(fn, acc)
);</pre>
			<p>Finally, if you are defining a<a id="_idIndexMarker973"/> method instead of a function, you use a squiggly arrow such as <code>~&gt;</code>:</p>
			<pre class="source-code">
// <strong class="bold">String.repeat :: String </strong><strong class="bold">⇝</strong><strong class="bold"> Number → String</strong></pre>
			<p>So far, we have defined data types for functions, but we aren’t done with this subject. Let’s consider some other cases.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Other data type options</h2>
			<p>What else are we missing? Let’s look <a id="_idIndexMarker974"/>at some other options that you might use. <em class="italic">Product types</em> are a sets of values that are always together and are commonly used with objects. For <em class="italic">tuples</em> (that is, arrays with a fixed number of elements of (probably) different types), we can write something like the following:</p>
			<pre class="source-code">
// <strong class="bold">getWeekAndDay :: String → (Number × String)</strong>
const getWeekAndDay = (
  yyyy_mm_dd: string
): [number, string] =&gt; {
  let weekNumber: number;
  let dayOfWeekName: string;
  .
  .
  .
  return [weekNumber, dayOfWeekName];
};</pre>
			<p>For objects, we can go with a definition very similar to what JavaScript already uses. Let’s imagine we <a id="_idIndexMarker975"/>have a <code>getPerson()</code> function that receives an ID and returns an object with data about a person:</p>
			<pre class="source-code">
// <strong class="bold">getPerson :: Number → { id:Number × name:String }</strong>
const getPerson = (
  personId: number
): { id: number; name: string } =&gt; {
  .
  .
  .
  return { id: personId, name: personName };
};</pre>
			<p><em class="italic">Sum types</em> (also known as <em class="italic">union types</em>) are defined as a list of possible values. For example, our <code>getField()</code> function from <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, returns either the value of an attribute or <code>undefined</code>. For this, we can write the following signature:</p>
			<pre class="source-code">
// <strong class="bold">getField :: String → Object → a | undefined</strong>
const getField =
  &lt;A&gt;(attr: string) =&gt;
  (obj: { [key: string]: A }) =&gt;
    obj[attr];</pre>
			<p>We could also define a type (union or otherwise) and use it in further definitions. For instance, the data types that can be directly compared and sorted are numbers, strings, and Booleans, so we could write the following definitions:</p>
			<pre class="source-code">
// <strong class="bold">Sortable :: Number | String | Boolean</strong></pre>
			<p>Afterward, we could specify that a comparison function can be defined in terms of the <code>Sortable</code> type, but be<a id="_idIndexMarker976"/> careful: there’s a hidden problem here!</p>
			<pre class="source-code">
// <strong class="bold">compareFunction :: (Sortable, Sortable) → Number</strong></pre>
			<p>The previous definition would allow us to write a function that received, say, a <code>number</code> and a <code>Boolean</code>. It doesn’t say that both types should be the same. However, there’s a way out. If you have constraints for some data types, you can express them before the actual signature, using a fat arrow, as shown in the following code:</p>
			<pre class="source-code">
// <strong class="bold">compareFunction :: Sortable a </strong><strong class="bold">⇒</strong><strong class="bold"> (a, a) → Number</strong></pre>
			<p>The definition is now correct because all occurrences of the same type (denoted by the same letter, in this case, <code>a</code>) must be exactly the same. An alternative, but one that requires much more typing, would have been to write all three possibilities with a union:</p>
			<pre class="source-code">
// <strong class="bold">compareFunction ::</strong>
//    <strong class="bold">((Number, Number) |</strong>
//    <strong class="bold">(String, String)  |</strong>
//    <strong class="bold">(Boolean, Boolean)) → Number</strong></pre>
			<p>Actually, this definition isn’t very precise because you can compare any type, even if it doesn’t make much sense. However, bear with me for the sake of this example! If you want to refresh your memory about sorting and comparison functions, see <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</a>.</p>
			<p>So far, we have been using the standard type definitions. However, when working with JavaScript, we have to consider other possibilities, such as functions with optional parameters, or even with an undetermined number of parameters. We can use <code>...</code> to stand for any number of arguments and add <code>?</code> to represent an optional type, as follows:</p>
			<pre class="source-code">
// <strong class="bold">unary :: ((b, ...) → a) → (b → a)</strong></pre>
			<p>The <code>unary()</code> higher-order function we defined in the same chapter we cited previously took any function as a parameter and returned a unary function as its result. We can show that<a id="_idIndexMarker977"/> the original function can receive any number of arguments but that the result used only the first. The data type definition for this would be as follows:</p>
			<pre class="source-code">
// <strong class="bold">parseInt :: (String, Number?) → Number</strong></pre>
			<p>The standard <code>parseInt()</code> function provides an example of optional arguments, though it’s highly recommended that you don’t omit the second parameter (the base radix); you can, in fact, skip it.</p>
			<p class="callout-heading">Fantastic definitions?</p>
			<p class="callout">Check out <a href="http://github.com/fantasyland/fantasy-land/">github.com/fantasyland/fantasy-land/</a> and <a href="http://sanctuary.js.org/#types">sanctuary.js.org/#types</a> for a more formal definition and description of types, as applied to JavaScript.</p>
			<p>From now on, throughout this chapter, we’ll not only be using TypeScript, but we will also be adding HM signatures to methods and functions, so you can get used to them. Let’s now change track and cover a highly important topic: <em class="italic">containers</em>.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor226"/>Building containers</h1>
			<p>Back in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, and later, in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>, we saw that the ability to apply a mapping to all the elements of an array—and even better, being able to chain a <a id="_idIndexMarker978"/>sequence of similar operations—was an excellent way to produce better, more understandable code.</p>
			<p>However, there is a problem: the <code>map()</code> method (or the equivalent, demethodized one, which we looked at in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>) is only available for arrays, and we might want to be able to apply mappings and chaining to other data types. So, what can we do?</p>
			<p>Let’s consider different ways of doing this, which will give us several new tools for better functional coding. Basically, there are only two possible ways of solving this: we can either add new methods to existing types (though that will be limited because we can only apply that to basic JavaScript types) or wrap types in some type of container, which will allow mapping and chaining.</p>
			<p>Let’s start by extending<a id="_idIndexMarker979"/> current types before moving on to using wrappers, which will lead us into the deep functional territory with entities such as functors and monads.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor227"/>Extending current data types</h2>
			<p>If we want to add <a id="_idIndexMarker980"/>mapping to basic JavaScript data types, we need to start by considering our options:</p>
			<ul>
				<li>With <code>null</code>, <code>undefined</code>, and <code>Symbol</code>, applying maps doesn’t sound too interesting</li>
				<li>We have some interesting possibilities with <code>Boolean</code>, <code>Number</code>, and <code>String</code> data types, so we can examine some of those</li>
				<li>Applying mapping to an object is trivial: we just have to add a <code>map()</code> method, which must return a new object</li>
				<li>Finally, despite not being basic data types, we could also consider special cases, such as dates or functions, to which we could also add <code>map()</code> methods</li>
			</ul>
			<p>As in the rest of this book, we are sticking to plain JavaScript and TypeScript, but you should look into libraries such as Lodash, Underscore, or Ramda, which already provide functionalities similar to the ones we are developing here.</p>
			<p>A key point to consider in all these mapping operations should be that the returned value is of the same type as the original one. When we use <code>Array.map()</code>, the result is also an array, and similar considerations must apply to any other <code>map()</code> method implementations (you could observe that the resulting array may have different element types to the original one, but it is still an array).</p>
			<p>What could we do with a Boolean? First, let’s accept that Booleans are not containers, so they don’t really behave in the same way as an array. Trivially, a Boolean can only have a Boolean value, while an array may contain any type of element. However, accepting that difference, we can extend <code>Boolean.prototype</code> (though, as I’ve already mentioned, that’s not usually recommended) by adding a new <code>map()</code> method to it and making sure that whatever the mapping function returns is turned into a new Boolean value. For the latter, the solution will be similar to the following:</p>
			<pre class="source-code">
// <strong class="bold">Boolean.map :: Boolean </strong><strong class="bold">⇝</strong><strong class="bold"> (Boolean → a) → Boolean</strong>
Boolean.prototype.map = function (
  this: boolean,
  fn: (x: boolean) =&gt; any
) {
  return !!fn(this);
};</pre>
			<p>We already saw examples of adding a (fake) <code>this</code> parameter to a method, to let TypeScript know what type <code>this</code> will be—in this case, a Boolean. The <code>!!</code> operator forces the result to<a id="_idIndexMarker981"/> be a Boolean. <code>Boolean(fn(this))</code> could also have been used. This kind of solution can also be applied to numbers and strings, as shown in the following code:</p>
			<pre class="source-code">
// <strong class="bold">Number.map :: Number </strong><strong class="bold">⇝</strong><strong class="bold"> (Number → a) → Number</strong>
Number.prototype.map = function (
  this: number,
  fn: (x: number) =&gt; number
) {
  return Number(fn(this));
};
// <strong class="bold">String.map :: String </strong><strong class="bold">⇝</strong><strong class="bold"> (String → a) → String</strong>
String.prototype.map = function (
  this: string,
  fn: (x: string) =&gt; string
) {
  return String(fn(this));
};</pre>
			<p>As with Boolean values, we <a id="_idIndexMarker982"/>are forcing the results of the mapping operations to the correct data types. By the way, TypeScript won’t directly accept any of these new <code>map()</code> definitions; see <em class="italic">Question 12.1</em> to fix this.</p>
			<p>Finally, if we wanted to apply mappings to a function, what would that mean? Mapping a function should produce a function. The logical interpretation for <code>f.map(g)</code> would be applying <code>f()</code>, and then applying <code>g()</code> to the result. So, <code>f.map(g)</code> should be the same as writing <code>x =&gt; g(f(x))</code> or, equivalently, <code>pipe(f,g)</code>. The definition is more complex than it was for the previous examples (but, in my opinion, simpler in HM than with TypeScript), so study it carefully:</p>
			<pre class="source-code">
// <strong class="bold">Function.map :: (a → b) </strong><strong class="bold">⇝</strong><strong class="bold"> (b → c) → (a → c)</strong>
Function.prototype.map = function &lt;A, B, C&gt;(
  this: (x: A) =&gt; B,
  fn: (y: B) =&gt; C
): (x: A) =&gt; C {
  return (x: A) =&gt; fn(this(x));
};</pre>
			<p>Verifying that this works is simple, and the following code is an easy example of how to do this. The <code>times10()</code> mapping function is applied to the result of calculating <code>plus1(3)</code>, so the result is 40:</p>
			<pre class="source-code">
const plus1 = (x) =&gt; x + 1;
const times10 = (y) =&gt; 10 * y;
console.log(plus1.map(by10)(3));
// 40: first add 1 to 3, then multiply by 10</pre>
			<p>With this, we are done talking about what we can achieve with basic JavaScript types, but we need a more general solution if we want to apply this to other data types. We’d like to be able to apply <a id="_idIndexMarker983"/>mapping to any kind of value, and for that, we’ll need to create a container. We’ll do this in the next section.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor228"/>Containers and functors</h2>
			<p>What we did in the previous <a id="_idIndexMarker984"/>section works and can be used without problems. However, we would like to consider a more general solution that we can apply to any<a id="_idIndexMarker985"/> data type. Since not all things in JavaScript provide the desired <code>map()</code> method, we will have to either extend the type (as we did in the previous section) or apply a design pattern that we considered in <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Design Patterns</em>: wrapping our data types with a wrapper that will provide the required <code>map()</code> operations.</p>
			<p>In particular, we will do the following:</p>
			<ul>
				<li>Start by seeing how to build a basic container, wrapping a value</li>
				<li>Convert the container into something more powerful—a functor</li>
				<li>Study how to deal with missing values using a special functor, <code>Maybe</code></li>
			</ul>
			<h3>Wrapping a value – a basic container</h3>
			<p>Let’s pause for a minute and <a id="_idIndexMarker986"/>consider what we need from this wrapper. There are two basic requirements:</p>
			<ul>
				<li>We must have a <code>map()</code> method</li>
				<li>We need a simple way to wrap a value</li>
			</ul>
			<p>To get started, let’s create a basic container. Any object containing just a value would do, but we want some<a id="_idIndexMarker987"/> additions, so our object won’t be that trivial; we’ll explain the differences after the code:</p>
			<pre class="source-code">
// container.ts
class Container&lt;A&gt; {
  protected x: A;
  constructor(x: A) {
    this.x = x;
  }
  map(fn: (_: A) =&gt; any) {
    return fn(this.x);
  }
}</pre>
			<p>Some primary considerations that we need to keep in mind are as follows:</p>
			<ul>
				<li>We want to be able to store some value in a container, so the constructor takes care of that.</li>
				<li>Using a <code>protected</code> attribute avoids “tinkering” from the outside, but allows access to subclasses. (See <em class="italic">Question 12.2</em> for some JavaScript considerations.)</li>
				<li>We need to be able to <code>map()</code>, so a method is provided for that.</li>
			</ul>
			<p>Our barebones container is ready, but we can also add some other methods for convenience, as follows:</p>
			<ul>
				<li>To get the value of a container, we could use <code>map((x) =&gt; x)</code>, but that won’t work with more complex containers, so we’ll add a <code>valueOf()</code> method to get the contained value.</li>
				<li>Being able to list a container can undoubtedly help with debugging. The <code>toString()</code> method will come in handy for this.</li>
				<li>Because we don’t need to write <code>new Container()</code> all the time, we can add a static <code>of()</code> method<a id="_idIndexMarker988"/> to do the same job.</li>
			</ul>
			<p class="callout-heading">A functional sin?</p>
			<p class="callout">Working with classes to represent containers (and later, functors and monads) when living in a FP world may seem like heresy or sin... but remember that we don’t want to be dogmatic, and using classes simplifies our coding. Similarly, it could be argued that you must never take a value out of the container—but using a <code>valueOf()</code> method is sometimes too handy, so we won’t be that restrictive.</p>
			<p>By taking all of this into account, our container is as follows:</p>
			<pre class="source-code">
// continued...
class Container&lt;A&gt; {
  protected x: A;
  constructor(x: A) {
    this.x = x;
  }
  static of&lt;B&gt;(x: B): Container&lt;B&gt; {
    return new Container(x);
  }
  map(fn: (_: A) =&gt; any) {
    return fn(this.x);
  }
  toString() {
    return `${this.constructor.name}(${this.x})`;
  }
  valueOf() {
    return this.x;
  }
}</pre>
			<p>Now, we can use this<a id="_idIndexMarker989"/> container to store a value, and <code>map()</code> to apply any function to that value, but this isn’t very different from what we could do with a variable! Let’s enhance this a bit.</p>
			<h3>Enhancing our container – functors</h3>
			<p>We want to have<a id="_idIndexMarker990"/> wrapped values, so what exactly should <code>map()</code> return? If we want to be able to chain operations, the only logical answer is that it should return a new wrapped object. In true functional style, when we apply a mapping to a wrapped value, the result will be another wrapped value that we can keep working on.</p>
			<p class="callout-heading">A map by any other name</p>
			<p class="callout">Instead of <code>map()</code>, this operation is<a id="_idIndexMarker991"/> sometimes called <code>fmap()</code>, standing for <em class="italic">functorial map</em>. The rationale for the name change was to avoid expanding the meaning of <code>map()</code>. However, since we are working in a language that supports reusing the name, we can keep it.</p>
			<p>We can extend our <code>Container</code> class to implement this change and get ourselves an enhanced container: a <em class="italic">functor</em>. The <code>of()</code> and <code>map()</code> methods will <a id="_idIndexMarker992"/>require a small change. For this, we’ll be creating a new class, as shown in the following code:</p>
			<pre class="source-code">
// functor.ts
class Functor&lt;A&gt; extends Container&lt;A&gt; {
  static of&lt;B&gt;(x: B) {
    return new Functor(x);
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Functor&lt;B&gt; {
    return Functor.of(fn(this.x));
  }
}</pre>
			<p>Here, the <code>of()</code> method <a id="_idIndexMarker993"/>produces a <code>Functor</code> object, and so does the <code>map()</code> method. With these changes, we have just defined what a <em class="italic">functor</em> is in category theory! (Or, if you want to get really technical, a <em class="italic">pointed functor</em> because of the <code>of()</code> method—but let’s keep it simple.) We won’t go into the theoretical details, but roughly speaking, a functor is some container that allows us to apply <code>map()</code> to its contents, producing a new container of the same type. If this sounds familiar, it’s because you already know a functor: arrays! When you apply <code>map()</code> to an array, the result is a new array containing transformed (mapped) values.</p>
			<p class="callout-heading">Extra requirements</p>
			<p class="callout">There are more requirements for functors. First, the contained values may be polymorphic (of any type), just like arrays. Second, a function must exist whose mapping produces the same contained value—<code>(x) =&gt; x</code> does this for us. Finally, applying two consecutive mappings must produce the same result as applying their composition. This means that <code>container.map(f).map(g)</code> must be the same as <code>container.map(compose(g,f))</code>.</p>
			<p>Let’s pause for a moment and consider the signatures for our function and methods:</p>
			<pre class="source-code">
// of :: Functor f ⇒ a → f a
// Functor.toString :: Functor f ⇒ f a ⇝ String
// Functor.valueOf :: Functor f ⇒ f a ⇝ a
// Functor.map :: Functor f ⇒ f a ⇝ (a → b) → f b</pre>
			<p>The first function, <code>of()</code>, is the simplest: given a value of any type, it produces a functor of that type. The following two are also relatively simple to understand: given a functor, <code>toString()</code> always returns a string (no surprise there!), and if the functor-contained value is of a given type, <code>valueOf()</code> produces a result of that same type. The third one, <code>map()</code>, is more interesting. Given a function that takes an argument of type <code>a</code> and produces a result of type <code>b</code>, applying it to a functor that contains a value of type <code>a</code> produces a functor<a id="_idIndexMarker994"/> containing a value of type <code>b</code>. This is precisely what we described previously.</p>
			<p class="callout-heading">Promises and Functors</p>
			<p class="callout">You could compare <a id="_idIndexMarker995"/>functors to promises, at least in one aspect. With functors, instead of acting on its value directly, you have to apply a function with <code>map()</code>. In promises, you do exactly the same, but using <code>then()</code> instead! In fact, there are more analogies, as we’ll be seeing soon.</p>
			<p>As is, functors are not allowed or expected to produce side effects, throw exceptions, or exhibit any other behavior outside of producing a container-ed result. Their main usage is to provide us with a way to manipulate a value, apply operations to it, compose results, and so on, without changing the original value—in this sense, we are once again coming back to immutability.</p>
			<p>However, you could reasonably say that this isn’t enough since, in everyday programming, it’s pretty common to have to deal with exceptions, undefined or null values, and so on. So, let’s start by looking at more examples of functors. After that, we’ll enter the realm of monads to look at even more sophisticated processing. Let’s experiment a bit!</p>
			<h3>Dealing with missing values with Maybe</h3>
			<p>A common problem in programming is dealing with missing values. There are many possible causes for this situation: a web service Ajax call may have returned an empty result, a dataset could be <a id="_idIndexMarker996"/>empty, an optional attribute might be missing from an object, and so on. In a normal imperative fashion, dealing with this kind of situation requires adding <code>if</code> statements or ternary operators everywhere to catch the possible missing value to avoid a certain runtime error. We can do better by implementing a <code>Maybe</code> functor to represent a value that may (or may <em class="italic">not</em>) be present! We will use two classes, <code>Just</code> (as in <em class="italic">just some value</em>) and <code>Nothing</code>, both of which are functors. The <code>Nothing</code> functor is particularly simple, with trivial methods:</p>
			<pre class="source-code">
// maybe.ts
class Nothing extends Maybe&lt;any&gt; {
  constructor() {
    super(null);
  }
  isNothing() {
    return true;
  }
  toString() {
    return "Nothing()";
  }
  map(_fn: FN) {
    return this;
  }
}</pre>
			<p>The <code>isNothing()</code> method returns <code>true</code>, <code>toString()</code> returns constant text, and <code>map()</code> always returns itself, no matter what function it’s given.</p>
			<p>Moving forward, the <code>Just</code> functor is also a basic one, with the added <code>isNothing()</code> method (which always<a id="_idIndexMarker997"/> returns <code>false</code>, since a <code>Just</code> object isn’t <code>Nothing</code>), and a <code>map()</code> method that now returns <code>Maybe</code>:</p>
			<pre class="source-code">
// continued...
class Just&lt;A&gt; extends Maybe&lt;A&gt; {
  static of&lt;B&gt;(x: B): Maybe&lt;B&gt; {
    if (x === null || x === undefined) {
      throw new Error("Just should have a value");
    } else {
      return new Just(x);
    }
  }
  isNothing() {
    return false;
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Just&lt;B&gt; {
    return new Just(fn(this.x));
  }
}</pre>
			<p>Finally, our <code>Maybe</code> class packs the logic needed to construct either <code>Nothing</code> or <code>Just</code>. If it receives an <code>undefined</code> or <code>null</code> value, <code>Nothing</code> will be constructed; in other cases, <code>Just</code> will <a id="_idIndexMarker998"/>be the result. The <code>of()</code> method has exactly the same behavior:</p>
			<pre class="source-code">
// continued...
abstract class Maybe&lt;A&gt; extends Functor&lt;A&gt; {
  static of&lt;B&gt;(x: B): Maybe&lt;B&gt; {
    return x === null || x === undefined
      ? new Nothing()
      : new Just(x);
  }
  isNothing() {
    /* abstract */
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Maybe&lt;B&gt; {
    return Maybe.of(fn(this.x));
  }
}</pre>
			<p>We are using an <code>abstract</code> class because you shouldn’t directly write <code>new Maybe(…)</code>; you should use <code>Maybe.of()</code> or directly build <code>Just</code> or <code>Nothing</code>. (If you are wondering how to do this in JavaScript, see <em class="italic">Question 12.3</em>.) We can quickly verify that this works by trying to apply an operation to either a valid value or a missing one. Let’s look at two examples of this:</p>
			<pre class="source-code">
const plus1 = x =&gt; x + 1;
Maybe.of(2209).map(plus1).map(plus1).toString();
// "Just(2211)"
Maybe.of(null).map(plus1).map(plus1).toString();
// "Nothing()"</pre>
			<p>When we applied <code>plus1()</code> (twice) to <code>Maybe.of(2209)</code>, everything worked fine, and we ended up with a <code>Just(2011)</code> value. On the other hand, when we applied the same sequence of operations to a <code>Maybe.of(null)</code> value, the end result was <code>Nothing</code>, but there were no errors, even if we tried to do math with a <code>null</code> value. A <code>Maybe</code> functor<a id="_idIndexMarker999"/> can deal with mapping a missing value by just skipping the operation and returning a wrapped <code>null</code> value instead. This means that this functor includes an abstracted check, which won’t let an error happen.</p>
			<p>(Later in this chapter, we’ll see that <code>Maybe</code> can actually be a monad instead of a functor, and we’ll also examine more examples of monads.)</p>
			<p>Let’s look at a more realistic example of its usage.</p>
			<h4>Dealing with varying API results</h4>
			<p>Suppose we are <a id="_idIndexMarker1000"/>writing a small server-side service in Node.js to get the weather alerts for a city and produce a not-very-fashionable HTML <code>&lt;table&gt;</code> with them, to be part of some server-side-produced web page. (Yes, I know you should try to avoid tables in your pages, but I want a short example of HTML generation, and the actual results aren’t significant.) If we used the <em class="italic">Dark Sky</em> API (see <a href="http://darksky.net">darksky.net</a> for more on this API and how to register with it) to get the alarms, our code would be something like the following, all quite normal. Note the callback in case of an error; you’ll see why in the following code:</p>
			<pre class="source-code">
import request from "superagent";
const getAlerts = (
  lat: number,
  long: number,
  callback: FN
) =&gt; {
  const SERVER = "https://api.darksky.net/forecast";
  const UNITS = "units=si";
  const EXCLUSIONS = "exclude=minutely,hourly,daily,flags";
  const API_KEY = "you.need.to.get.your.own.api.key";
  request
    .get(
      `${SERVER}/${API_
        KEY}/${lat},${long}?${UNITS}&amp;${EXCLUSIONS}`
    )
    .end(function (err, res) {
      if (err) {
        callback({});
      } else {
        callback(JSON.parse(res.text));
      }
    });
};</pre>
			<p>The (heavily edited <a id="_idIndexMarker1001"/>and reduced in size) output of such a call might be something like this:</p>
			<pre class="console">
{
  latitude: 29.76,
  longitude: -95.37,
  timezone: "America/Chicago",
  offset: -5,
  currently: {
    time: 1503660334,
    summary: "Drizzle",
    icon: "rain",
    temperature: 24.97,
    .
    .
    .
    uvIndex: 0,
  },
  alerts: [
    {
      title: "Tropical Storm Warning",
      regions: ["Harris"],
      severity: "warning",
      time: 1503653400,
      expires: 1503682200,
      description:
        "TROPICAL STORM WARNING REMAINS IN EFFECT... WIND -        LATEST LOCAL FORECAST: Below tropical storm force wind         ... CURRENT THREAT TO LIFE AND PROPERTY: Moderate ...        Locations could realize roofs peeled off buildings,        chimneys toppled, mobile homes pushed off foundations         or overturned ...",
      uri: "https://alerts.weather.gov/cap/wwacapget.php?x=      TX125862DD4F88.TropicalStormWarning.125862DE8808TX.      HGXTCVHGX.73ee697556fc6f3af7649812391a38b3",
    },
    .
    .
    .
    {
      title: "Hurricane Local Statement",
      regions: ["Austin", ... , "Wharton"],
      severity: "advisory",
      time: 1503748800,
      expires: 1503683100,
      description:
        "This product covers Southeast Texas **HURRICANE         HARVEY DANGEROUSLY APPROACHING THE TEXAS COAST** ...        The next local statement will be issued by the National         Weather Service in Houston/Galveston TX around 1030 AM         CDT, or sooner if conditions warrant.\n",
      uri: "https://alerts.weather.gov/...",
    },
  ],
};</pre>
			<p>I got this information for Houston, TX, US, on a day when Hurricane Harvey was approaching the state. If <a id="_idIndexMarker1002"/>you called the API on a normal day, the data would not include the <code>alerts:[...]</code> part. Here, we can use a <code>Maybe</code> functor to <a id="_idIndexMarker1003"/>process the received data without any problems, with or without any alerts:</p>
			<pre class="source-code">
import os from "os";
const produceAlertsTable = (weatherObj: typeof resp) =&gt;
  Maybe.of(weatherObj)
    .map((w: typeof resp) =&gt; w.alerts)
    .map((a) =&gt;
      a.map(
        (x) =&gt;
          `&lt;tr&gt;&lt;td&gt;${x.title}&lt;/td&gt;` +
          `&lt;td&gt;${x.description.substr(0,
            500)}...&lt;/td&gt;&lt;/tr&gt;`
      )
    )
    .map((a) =&gt; a.join(os.EOL))
    .map((s) =&gt; `&lt;table&gt;${s}&lt;/table&gt;`);
getAlerts(29.76, -95.37, (x) =&gt;
  console.log(produceAlertsTable(x).valueOf())
);</pre>
			<p>Of course, you would probably do something more interesting than just logging the value of the contained result of <code>produceAlertsTable()</code>! The most likely option would be to use <code>map()</code> again with a function that would output the table, send it to a client, or do whatever you needed to do. In any case, the resulting output would look something like this:</p>
			<pre class="console">
<strong class="bold">&lt;table&gt;&lt;tr&gt;&lt;td&gt;</strong>Tropical Storm Warning<strong class="bold">&lt;/td&gt;&lt;td&gt;</strong>...TROPICAL STORM WARNING REMAINS IN EFFECT... ...STORM SURGE WATCH REMAINS IN EFFECT... * WIND -
LATEST LOCAL FORECAST: Below tropical storm force wind - Peak Wind Forecast: 25-35 mph with gusts to 45 mph - CURRENT THREAT TO LIFE AND PROPERTY: Moderate - The wind threat has remained nearly steady from the previous assessment. - Emergency plans should include a reasonable threat for strong tropical storm force wind of 58 to 73 mph. - To be safe, earnestly prepare for the potential of significant...<strong class="bold">&lt;/td&gt;&lt;/tr&gt;</strong>
<strong class="bold">&lt;tr&gt;&lt;td&gt;</strong>Flash Flood Watch<strong class="bold">&lt;/td&gt;&lt;td&gt;</strong>...FLASH FLOOD WATCH REMAINS IN EFFECT
THROUGH MONDAY MORNING... The Flash Flood Watch continues for * Portions of Southeast Texas...including the following counties...Austin...Brazoria...Brazos...Burleson...
Chambers...Colorado...Fort Bend...Galveston...Grimes...
Harris...Jackson...Liberty...Matagorda...Montgomery...Waller... Washington and Wharton. * Through Monday morning * Rainfall from Harvey will cause devastating and life threatening flooding as a prolonged heavy rain and flash flood thre...<strong class="bold">&lt;/td&gt;&lt;/tr&gt;</strong>
<strong class="bold">&lt;tr&gt;&lt;td&gt;</strong>Hurricane Local Statement<strong class="bold">&lt;/td&gt;&lt;td&gt;</strong>This product covers Southeast
Texas **PREPARATIONS FOR HARVEY SHOULD BE RUSHED TO COMPLETION THIS MORNING** NEW INFORMATION --------------- * CHANGES TO WATCHES AND
WARNINGS: - None * CURRENT WATCHES AND WARNINGS: - A Tropical Storm Warning and Storm Surge Watch are in effect for Chambers and Harris - A Tropical Storm Warning is in effect for Austin, Colorado, Fort Bend, Liberty, Waller, and Wharton - A Storm Surge Warning and Hurricane Warning are in effect for Jackson and Matagorda - A Storm S...<strong class="bold">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</strong></pre>
			<p>The output of the preceding code can be seen in the following screenshot:</p>
			<div><div><img src="img/Figure_12.1_B9301.jpg" alt="Figure 12.1 – The output table is not much to look at, but the logic that produced it didn’t require a single if statement"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The output table is not much to look at, but the logic that produced it didn’t require a single if statement</p>
			<p>If we had called <code>getAlerts(-34.9, -54.60, ...)</code> with the coordinates for Montevideo, Uruguay, instead, since there were no alerts for that city, the <code>getField("alerts")</code> function would have returned <code>undefined</code>—and since that value is recognized<a id="_idIndexMarker1004"/> by the <code>Maybe</code> functor, and even though all the following <code>map()</code> operations would still be executed, no one would actually do anything, and a <code>null</code> value would be the final result.</p>
			<p>We took advantage of this behavior when we coded the error logic. If an error occurs when calling the service, we would still call the original callback to produce a table but provide an empty object. Even if this result is unexpected, we would be safe because the same guards would avoid causing a runtime error.</p>
			<p>As a final enhancement, we can add an <code>orElse()</code> method to provide a default value when no value is provided. The added method will return the default value if <code>Maybe</code> is <code>Nothing</code>, or the <code>Maybe</code> value itself otherwise:</p>
			<pre class="source-code">
// continued...
class Maybe&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
<strong class="bold">  orElse(v: any) {</strong>
<strong class="bold">    /* abstract */</strong>
<strong class="bold">  }</strong>
}
class Nothing extends Functor&lt;any&gt; {
  .
  .
  .
<strong class="bold">  orElse(v: any) {</strong>
<strong class="bold">    return v;</strong>
<strong class="bold">  }</strong>
}
class Just&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
<strong class="bold">  orElse(v: any) {</strong>
<strong class="bold">    return this.x;</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Using this new method instead of <code>valueOf()</code>, trying to get the alerts for someplace without weather warnings would just return a default result. In the case we mentioned previously, attempting to get the alerts for Montevideo, instead of a <code>null</code> value, we would get the following appropriate result:</p>
			<pre class="source-code">
getAlerts(-34.9, -54.6, (x) =&gt;
  console.log(
    produceAlertsTable(x)<strong class="bold">.orElse(</strong>
<strong class="bold">      "&lt;span&gt;No alerts today.&lt;/span&gt;"</strong>
<strong class="bold">    )</strong>
  )
);</pre>
			<p>With this, we have looked at<a id="_idIndexMarker1005"/> an example of dealing with different situations when working with an API. Let’s quickly revisit another topic from a previous chapter and look at a better implementation of prisms.</p>
			<h4>Implementing prisms</h4>
			<p>The more common<a id="_idIndexMarker1006"/> implementations of prisms (which we first met in the <em class="italic">Prisms</em> section of <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a><em class="italic">, Ensuring Purity</em>), instead of returning either some value or <code>undefined</code> and leaving it up to the caller to check what happened, opt to return <code>Maybe</code>, which already provides us with easy ways to deal with missing values. In our new implementation (which we’ll look at soon), our example from the aforementioned chapter would look like this:</p>
			<pre class="source-code">
const author = {
  user: "fkereki",
  name: {
    first: "Federico",
    middle: "",
    last: "Kereki",
  },
  books: [
    { name: "Google Web Toolkit", year: 2010 },
    { name: "Functional Programming", year: 2017 },
    { name: "Javascript Cookbook", year: 2018 },
  ],
};</pre>
			<p>If we wanted to <a id="_idIndexMarker1007"/>access the <code>author.user</code> attribute, the result would be different:</p>
			<pre class="source-code">
const pUser = prismProp("user");
console.log(review(pUser, author).toString());
/*
<strong class="bold">Just("fkereki")</strong>
*/</pre>
			<p>Similarly, if we asked for a non-existent pseudonym attribute, instead of <code>undefined</code> (as in our previous version of <code>Prism</code>), we would get <code>Nothing</code>:</p>
			<pre class="source-code">
const pPseudonym = prismProp("pseudonym"); console.log(review(pPseudonym, author).toString());
/*
<strong class="bold">Nothing()</strong>
*/</pre>
			<p>So, this new version of <code>Prism</code> is better to work with if you are already used to dealing with <code>Maybe</code> values. What do we need to implement this? We need just a single change; our <code>Constant</code> class now needs to return <code>Maybe</code> instead of a value, so we’ll have a new <code>ConstantP</code> (<code>P</code> for <code>Prism</code>) class:</p>
			<pre class="source-code">
class ConstantP&lt;V&gt; {
  <strong class="bold">private value: Maybe&lt;V&gt;</strong>;
  map: FN;
  constructor(v: V) {
    <strong class="bold">this.value = Maybe.of(v);</strong>
    this.map = () =&gt; this;
  }
}</pre>
			<p>We will have to rewrite <code>preview()</code> to use the new class, and that finishes the change:</p>
			<pre class="source-code">
const preview = curry(
  (prismAttr, obj) =&gt;
    <strong class="bold">prismAttr((x) =&gt; new ConstantP(x))(obj).value</strong>
);</pre>
			<p>So, getting <code>Prism</code> to work with <code>Maybe</code> wasn’t that hard, and now we have a consistent way of dealing with possibly missing attributes. Working in this fashion, we can simplify our coding and avoid many tests for nulls and other similar situations. However, we may want to go beyond this; for<a id="_idIndexMarker1008"/> instance, we may want to know why there were no alerts: was it a service error? Or just a normal situation? Just getting null at the end isn’t enough, and to work with these new requirements, we will need to add some extra functionality to our functors (as we’ll see in the next section) and enter the domain of <em class="italic">monads</em>.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor229"/>Monads</h2>
			<p>Monads have <a id="_idIndexMarker1009"/>weird fame among programmers. Well-known developer Douglas Crockford has famously spoken of a curse, maintaining that “<em class="italic">Once you happen to finally understand monads, you immediately lose the ability to explain them to other people! </em>” On a different note, if you decide to go back to the basics and read <em class="italic">Categories for the Working Mathematician</em> by Saunders Mac Lane (one of the creators of category theory), you may find a somewhat disconcerting explanation—which is not too illuminating!</p>
			<p class="author-quote">A monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
			<p>The difference between monads and functors is that the former adds some extra functionality; we’ll see what functionality they add soon. Let’s start by looking at the new requirements before moving on and considering some common, useful monads. As with functors, we will have a basic monad, which you could consider an <em class="italic">abstract</em> version, and<a id="_idIndexMarker1010"/> specific <em class="italic">monadic types</em>, which are <em class="italic">concrete</em> implementations geared to solve specific cases.</p>
			<p class="callout-heading">All you could want to read</p>
			<p class="callout">To read a precise and careful description of functors, monads, and their family (but leaning heavily to the theoretical side, with plenty of algebraic definitions to go around), try the <em class="italic">Fantasy Land Specification</em> at <a href="http://github.com/fantasyland/fantasy-land/">github.com/fantasyland/fantasy-land/</a>. Please don’t say we didn’t warn you: the alternative name for that page is <em class="italic">Algebraic </em><em class="italic">JavaScript Specification</em>!</p>
			<h3>Adding operations</h3>
			<p>Let’s consider a <a id="_idIndexMarker1011"/>simple problem. Suppose you have the following pair of functions, working with <code>Maybe</code> functors: the first function tries to search for something (say, a client or a product) given its key, and the second attempts to extract some attribute from whatever we found (I’m being purposefully vague because the problem does not have anything to do with whatever objects or things we may be working with). Both functions produce <code>Maybe</code> results to avoid possible errors. We are using a mocked search function just to help us see the problem. For even keys, it returns fake data, and for odd keys, it throws an exception. The code for this search is very simple:</p>
			<pre class="source-code">
const fakeSearchForSomething = (key: number) =&gt; {
  if (key % 2 === 0) {
    return { key, some: "whatever", other: "more data" };
  } else {
    throw new Error("Not found");
  }
};</pre>
			<p>Using this search, our <code>findSomething()</code> function will try to do a search and return <code>Maybe.of()</code> (a <code>Just</code>) for a successful call, or <code>Maybe.of(null)</code> (a <code>Nothing</code>) in case of an error:</p>
			<pre class="source-code">
const findSomething = (key: number) =&gt; {
  try {
    const something = fakeSearchForSomething(key);
    <strong class="bold">return Maybe.of(something)</strong>;
  } catch (e) {
    <strong class="bold">return Maybe.of(null)</strong>;
  }
};</pre>
			<p>With this, we<a id="_idIndexMarker1012"/> could think of writing these two functions to do some searching, but not everything would be fine; can you see the problem here?</p>
			<pre class="source-code">
const getSome = (something: any) =&gt;
  Maybe.of(something.map((x: any) =&gt; x.some));
const getSomeFromSomething = (key: number) =&gt;
  getSome(findSomething(key));</pre>
			<p>The problem in this sequence is that the output from <code>getSome()</code> is a <code>Maybe</code> value, which itself contains a <code>Maybe</code> value, so the result we want is double-wrapped, as we can see by executing a couple of calls, for an even number (which will return <code>"whatever"</code>) and for an odd number (which will be an error), as follows:</p>
			<pre class="source-code">
const xxx = getSomeFromSomething(2222).valueOf().valueOf();
// <strong class="bold">"whatever"</strong>
const yyy = getSomeFromSomething(9999).valueOf().valueOf();
// <strong class="bold">undefined</strong></pre>
			<p>This problem can be easily solved in this toy problem if we avoid using <code>Maybe.of()</code> in <code>getSome()</code>, but this kind of issue can arise in many more complex ways. For instance, you could be building a <code>Maybe</code> out of an object, one of whose attributes happened to be a <code>Maybe</code>, and you’d end up in the same situation when accessing that attribute: you would end up with a double-wrapped value.</p>
			<p>Now, we are going to look into <a id="_idIndexMarker1013"/>monads. A monad should provide the following operations:</p>
			<ul>
				<li>A constructor.</li>
				<li>A function that inserts a value into a monad: our <code>of()</code> method.</li>
				<li>A function that allows us to chain operations: our <code>map()</code> method.</li>
				<li>A function that can remove extra wrappers: we will call it <code>unwrap()</code>. It will solve our preceding multiple wrapper problems. Sometimes, this function is called <code>flatten()</code>.</li>
			</ul>
			<p>To simplify our coding, we will also have a function to chain calls and another function to apply functions, but we’ll get to those later. Let’s see what a monad looks like in actual JavaScript code. Data type specifications are very much like those for functors, so we won’t repeat them here:</p>
			<pre class="source-code">
// monad.ts
class Monad&lt;A&gt; extends Functor&lt;A&gt; {
  static of&lt;B&gt;(x: B): Monad&lt;B&gt; {
    return new Monad(x);
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Monad&lt;B&gt; {
    return new Monad(fn(this.x));
  }
  unwrap(): any {
    const myValue = this.x;
    return myValue instanceof Monad
      ? myValue.unwrap()
      : this;
  }
}</pre>
			<p>We use recursion to<a id="_idIndexMarker1014"/> successively remove wrappers until the wrapped value isn’t a container anymore. Using this method, we could avoid double wrapping easily, and we could rewrite our previous troublesome function like this:</p>
			<pre class="source-code">
const getSomeFromSomething = key =&gt; getSome(findSomething(key)).unwrap();</pre>
			<p>However, this sort of problem could reoccur at different levels. For example, if we were doing a series of <code>map()</code> operations, any intermediate results may end up double-wrapped. You could solve this by remembering to call <code>unwrap()</code> after each <code>map()</code>—note that you could do this even if it is not actually needed since the result of <code>unwrap()</code> would be the very same object (can you see why?). But we can do better! Let’s define a <code>chain()</code> operation (sometimes named <code>flatMap()</code> instead, which is a bit confusing since we already have another meaning for that; see <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, for more on this) that will do both things for us:</p>
			<pre class="source-code">
// continued...
class Monad&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
  chain&lt;B&gt;(fn: (_: A) =&gt; B) {
    return this.map(fn).unwrap();
  }
}</pre>
			<p>There’s only one operation left. Suppose you have a curried function with two parameters—nothing<a id="_idIndexMarker1015"/> outlandish! What would happen if you provided that function to a <code>map()</code> operation?</p>
			<pre class="source-code">
const add = (x: number) =&gt; (y: number) =&gt; x + y;
// or curry((x,y) =&gt; x+y)
const something = Monad.of(2).<strong class="bold">map(add)</strong>;</pre>
			<p>What would <code>something</code> be? Given that we have only provided one argument to add, the result of that application will be a function—not just any function, though, but a wrapped one! (Since functions are first-class objects, there’s no logical obstacle to wrapping a function in a monad, is there?) What would we want to do with such a function? To be able to apply this wrapped function to a value, we’ll need a new method: <code>ap()</code>. What could its value be? In this case, it could either be a plain number or a number wrapped in a monad as a result of other operations. Since we can always map a plain number into a wrapped one with <code>Map.of()</code>, let’s have <code>ap()</code> work with a monad as its parameter; the new method would be as follows:</p>
			<pre class="source-code">
// continued...
class Monad&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
  ap&lt;B, C extends FN&gt;(this: Monad&lt;C&gt;, m: Monad&lt;B&gt;) {
    return m.map(this.x);
  }
}</pre>
			<p>With this, you could then do the following:</p>
			<pre class="source-code">
const monad5 = something.ap(Monad.of(3));
console.log(monad5.toString())
// <strong class="bold">Monad(5)</strong></pre>
			<p>You can use monads to<a id="_idIndexMarker1016"/> hold values or functions and to interact with other monads and chaining operations as you wish. So, as you can see, there’s no big trick to monads, which are just functors with some extra methods. Now, let’s look at how we can apply them to our original problem and handle errors in a better way.</p>
			<h3>Handling alternatives – the Either monad</h3>
			<p>Knowing that a value was <a id="_idIndexMarker1017"/>missing may be enough in some cases, but in others, you’ll want to be able to provide an explanation. We can get such an explanation if we use a different functor, which will take one of two possible values—one associated with a problem, error, or failure, and another associated with normal execution, or success:</p>
			<ul>
				<li>A <em class="italic">left</em> value, which should be null, but if present, then it represents some special value (for example, an error message or a thrown exception) that cannot be mapped over</li>
				<li>A <em class="italic">right</em> value, which represents the normal value of the functor and can be mapped over</li>
			</ul>
			<p>We can construct this monad similarly to what we did for <code>Maybe</code> (actually, the added operations make it better for <code>Maybe</code> to extend <code>Monad</code> as well). The constructor will receive a left and a right value. If the left value is present, it will become the value of the <code>Either</code> monad; otherwise, the right value will be used. Since we have provided <code>of()</code> methods for all our functors, we need one for <code>Either</code> too. The <code>Left</code> monad is very similar to our previous <code>Nothing</code>:</p>
			<pre class="source-code">
// either.ts
class Left extends Monad&lt;any&gt; {
  isLeft() {
    return true;
  }
  map(_: any) {
    return this;
  }
}</pre>
			<p>Similarly, <code>Right</code> resembles <a id="_idIndexMarker1018"/>our previous <code>Just</code>:</p>
			<pre class="source-code">
// continued...
class Right&lt;A&gt; extends Monad&lt;A&gt; {
  isLeft() {
    return false;
  }
  map(fn: (_: A) =&gt; any) {
    return Either.of(null, fn(this.x));
  }
}</pre>
			<p>And with these two monads under our belt, we can write our <code>Either</code> monad. It shouldn’t be surprising that <a id="_idIndexMarker1019"/>this resembles our previous <code>Maybe</code>, should it?</p>
			<pre class="source-code">
// continued...
abstract class Either&lt;A, B&gt; extends Monad&lt;A | B&gt; {
  static of&lt;C, D&gt;(left: C, right?: D): Left | Right&lt;D&gt; {
    return right === undefined || right === null
      ? new Left(left)
      : new Right(right);
  }
  isLeft() {
    /* */
  }
}</pre>
			<p>The <code>map()</code> method is key. If this functor has got a left value, it won’t be processed any further; in other cases, the mapping will be applied to the right value, and the result will be wrapped. Now, how can we enhance our code with this? The key idea is for every involved method to return an <code>Either</code> monad; <code>chain()</code> will be used to execute operations one after another. Getting the alerts would be the first step—we invoke the callback either with an <code>AJAX FAILURE</code> message or with the result from the API call, as follows:</p>
			<pre class="source-code">
const getAlerts2 = (lat, long, callback) =&gt; {
  const SERVER = "https://api.darksky.net/forecast";
  const UNITS = "units=si";
  const EXCLUSIONS = "exclude=minutely,hourly,daily,flags";
  const API_KEY = "you.have.to.get.your.own.key";
  request
    .get(
      `${SERVER}/${API_KEY}/${lat},${long}` +
        `?${UNITS}&amp;${EXCLUSIONS}`
    )
    .end((err, res) =&gt;
      callback(
        err
          ? Either.of("AJAX FAILURE", null)
          : Either.of(null, JSON.parse(res.text))
      )
    );
};</pre>
			<p>Then, the general process would be as follows. We use an <code>Either</code> monad again. If there are no alerts, instead <a id="_idIndexMarker1020"/>of an array, we will return a <code>"NO </code><code>ALERTS"</code> message:</p>
			<pre class="source-code">
const produceAlertsTable2 = (weatherObj: typeof resp) =&gt; {
  return weatherObj
    .chain((obj: typeof resp) =&gt; {
      const alerts = getField("alerts")(obj);
      return alerts
        ? Either.of(null, alerts)
        : Either.of("NO ALERTS", null);
    })
    .chain((a) =&gt;
      a.map(
        (x) =&gt;
          `&lt;tr&gt;&lt;td&gt;${x.title}&lt;/td&gt;` +
          `&lt;td&gt;${x.description.substr(0,
            500)}...&lt;/td&gt;&lt;/tr&gt;`
      )
    )
    .chain((a) =&gt; a.join(os.EOL))
    .chain((s) =&gt; `&lt;table&gt;${s}&lt;/table&gt;`);
};</pre>
			<p>Note how we used <code>chain()</code> so that multiple wrappers would be no problem. Now, we can test multiple situations and get appropriate results—or at least, for the current weather situation <a id="_idIndexMarker1021"/>around the world!</p>
			<ul>
				<li>For Houston, TX, we still get an HTML table</li>
				<li>For Montevideo, UY, we get a text saying there were no alerts</li>
				<li>For a point with wrong coordinates, we learn that the AJAX call failed: nice!</li>
			</ul>
			<pre class="source-code">
// Houston, TX, US:
getAlerts2(29.76, -95.37, (x) =&gt;
  console.log(produceAlertsTable2(x).toString())
);
// Right("...a table with alerts: lots of HTML code...");
// Montevideo, UY
getAlerts2(-34.9, -54.6, (x) =&gt;
  console.log(produceAlertsTable2(x).toString())
);
// Left("NO ALERTS");
// A point with wrong coordinates
getAlerts2(444, 555, (x) =&gt;
  console.log(produceAlertsTable2(x).toString())
);
// Left("AJAX FAILURE");</pre>
			<p>We are not done<a id="_idIndexMarker1022"/> with the <code>Either</code> monad. It’s likely that much of your code will involve calling functions. Let’s look at a better way of achieving this by using a variant of this monad.</p>
			<h3>Calling a function – the Try monad</h3>
			<p>If we are calling<a id="_idIndexMarker1023"/> functions that may throw exceptions and we want to do so in a functional way, we could use the <code>Try</code> monad to encapsulate the function result or the exception. The idea is basically the same as the <code>Either</code> monad. The only difference is in the constructor, which receives a function and calls it:</p>
			<ul>
				<li>If there are no problems, the returned value becomes the <code>right</code> value for the monad</li>
				<li>If there’s an exception, it will become the <code>left</code> value</li>
			</ul>
			<p>This can be seen in the following code:</p>
			<pre class="source-code">
// try.ts
class Try&lt;A&gt; extends Either&lt;A, string&gt; {
  // @ts-expect-error Call to super() not needed
  constructor(fn: () =&gt; A, msg?: string) {
    try {
      return Either.of(null, fn()) as Either&lt;A, string&gt;;
    } catch (e: any) {
      return Either.of(msg || e.message, null) as Either&lt;
        string,
        string
      &gt;;
    }
  }
}</pre>
			<p>Why the <code>@ts-expect-error</code> notation? A constructor should either call <code>super()</code> or return a fully constructed method, but TypeScript always expects the former, so we have to tell it that we know<a id="_idIndexMarker1024"/> what we’re doing here.</p>
			<p>Now, we can invoke any function, catching exceptions in a good way. For example, the <code>getField()</code> function that we have been using would crash if it were called with a <code>null</code> argument:</p>
			<pre class="source-code">
const getField = attr =&gt; obj =&gt; obj[attr];</pre>
			<p>In the <em class="italic">Implementing prisms</em> section of <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, we wrote a <code>getFieldP()</code> function that could deal with <code>null</code> values, but here, we will rewrite it using the <code>Try</code> monad, so, in addition, it will play nice with other composed functions. The alternative implementation of our getter would be as follows:</p>
			<pre class="source-code">
const getField2 = (attr: string) =&gt; (obj: OBJ | null) =&gt;
  new Try(() =&gt; obj![attr], "NULL OBJECT");</pre>
			<p>We can check that this works by trying to apply our new function to a null value:</p>
			<pre class="source-code">
const x = getField2("somefield")(null);
console.log(x.isLeft()); // true
console.log(x.toString()); // Left(NULL OBJECT)</pre>
			<p>There are many more monads, and, of course, you can even define your own, so we couldn’t possibly go over all of them. However, let’s visit just one more—one you have been using already, without <a id="_idIndexMarker1025"/>being aware of its monad-ness!</p>
			<h3>Unexpected monads – promises</h3>
			<p>Let’s finish this section on monads by mentioning yet another one that you may have used, though under a<a id="_idIndexMarker1026"/> different name: promises! Previously, we mentioned that functors (and, remember, monads are functors) had at least something in common with promises: using a method to access the value. However, the similarities are greater than that!</p>
			<ul>
				<li><code>Promise.resolve()</code> corresponds with <code>Monad.of()</code>—if you pass a value to <code>.resolve()</code>, you’ll get a promise resolved to that value, and if you provide a promise, you will get a new promise, the value of which will be that of the original one (see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve</a> for more on this). This is an unwrapping behavior!</li>
				<li><code>Promise.then()</code> stands for <code>Monad.map()</code> as well as <code>Monad.chain()</code>, given the mentioned unwrapping.</li>
			</ul>
			<p>We don’t have a direct match to <code>Monad.ap()</code>, but we could add something like the following code (this will be rejected by TypeScript, but we’ve seen how to solve this):</p>
			<pre class="source-code">
Promise.prototype.ap = function (promise2) {
  return this.then((x) =&gt; promise2.map(x));
};</pre>
			<p class="callout-heading">Promises – never gone</p>
			<p class="callout">Even if you opt for the modern <code>async</code> and <code>await</code> features, internally, they are based on promises. Furthermore, in some situations, you may still need <code>Promise.race()</code> and <code>Promise.all()</code>, so you will likely keep using promises, even if you opt for full ES8 coding.</p>
			<p>This is an appropriate ending for this section. Earlier, you found that ordinary arrays were, in fact, functors. Now, in the same way that Monsieur Jourdain (a character in Molière’s play <em class="italic">Le Bourgeois Gentilhomme</em>, <em class="italic">The Bourgeois Gentleman</em>) discovered that all his life he had been speaking in prose, you now know you had already been using monads without <a id="_idIndexMarker1027"/>even knowing it! So far, we have learned how to build different types of containers. Now, let’s learn how functions can also make do as containers, as well as for all kinds of data structures!</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor230"/>Functions as data structures</h1>
			<p>So far, we have learned <a id="_idIndexMarker1028"/>how to use functions to work with or transform other functions to process data structures or to create data types. Now, we’ll finish this chapter by showing you how a function can implement a data type, becoming a container of its own. In fact, this is a fundamental theoretical point of lambda calculus (if you want to learn more, look up <em class="italic">Church encoding</em> and <em class="italic">Scott encoding</em>), so we may very well say that we have come back to where we began this book, to the origins of FP! We will start with a detour that considers binary trees in a different functional language, Haskell, and then move on to implementing trees as functions, but in JavaScript. This experience will help you work out how to deal with other data structures.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor231"/>Binary trees in Haskell</h2>
			<p>Consider a binary tree. Such a tree <a id="_idIndexMarker1029"/>may either be empty or consist of a node (the tree <em class="italic">root</em>) with two children: a <em class="italic">left</em> binary tree and a <em class="italic">right</em> one. A node that has<a id="_idIndexMarker1030"/> no children is called a <em class="italic">leaf</em>.</p>
			<p class="callout-heading">Of many types of trees</p>
			<p class="callout">In <a href="B19301_09.xhtml#_idTextAnchor172"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Functions</em>, we worked with more general tree structures, such as a filesystem or the browser DOM itself, which allow a node to have any number of children. In the case of the trees in this section, each node always has two children, although each of them may be empty. The difference may seem minor, but allowing for empty subtrees lets you define that all nodes are binary.</p>
			<p>Let’s make a digression with the Haskell language. In it, we might write something like the following; <code>a</code> would be the type of whatever value we hold in the nodes:</p>
			<pre class="source-code">
data Tree a = Nil | Node a (Tree a) (Tree a)</pre>
			<p>In the Haskell language, pattern matching is often used for coding. For example, we could define an empty function as follows:</p>
			<pre class="source-code">
empty :: Tree a -&gt; Bool empty Nil = True
empty (Node root left right) = False</pre>
			<p>What does this mean? Apart <a id="_idIndexMarker1031"/>from the data type definition, the logic is simple: if the tree is <code>Nil</code> (the first possibility in the definition of the type), then the tree is certainly empty; otherwise, the tree isn’t empty. The last line would probably be written as <code>empty _ = False</code>, using <code>_</code> as a placeholder because you don’t actually care about the components of the tree; the mere fact that it’s not <code>Nil</code> suffices.</p>
			<p>Searching for a value in a binary search tree (in which the root is greater than all the values of its left subtree and less than all the values of its right subtree) would be written similarly:</p>
			<pre class="source-code">
contains :: (Ord a) =&gt; (Tree a)
     -&gt; a -&gt; Bool contains Nil _ = False
contains (Node root left right) x
| x == root = True
| x   &lt; root = contains left x
| x   &gt; root = contains right x</pre>
			<p>What patterns are matched here? We have four patterns now, which must be considered in order:</p>
			<ol>
				<li>An empty tree (<code>Nil</code>—it doesn’t matter what we are looking for, so just write <code>_</code>) doesn’t contain the searched value.</li>
				<li>If the tree isn’t empty, and the root matches the searched value (<code>x</code>), we are done.</li>
				<li>If the root doesn’t match and is greater than the searched value, the answer is found while searching in the left subtree.</li>
				<li>Otherwise, the answer is found by searching in the right subtree.</li>
			</ol>
			<p>There’s an important point to remember: for this data type, which is a union of two possible types, we have to provide two conditions, and pattern matching will be used to decide which one will be<a id="_idIndexMarker1032"/> applied. Keep this in mind!</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor232"/>Functions as binary trees</h2>
			<p>Can we do something<a id="_idIndexMarker1033"/> similar with functions? The answer is yes: we will represent a tree (or any other structure) with a function itself—not with a data structure that is processed by a set of functions, nor with an object with some methods, but by just a function. Furthermore, we will get a functional data structure that’s 100% immutable, which, if updated, produces a new copy of itself. We will do all this without using objects; here, closures will provide the desired results.</p>
			<p>How can this work? We shall be applying similar concepts to the ones we looked at earlier in this chapter, so the function will act as a container and produce, as its result, a mapping of its contained values. Let’s walk backward and start by looking at how we’ll use the new data type. Then, we’ll go through the implementation details.</p>
			<p>Creating a tree can be done by using two functions: <code>EmptyTree()</code> and <code>Tree(value, leftTree, rightTree)</code>. For example, let’s say we wish to create a tree similar to the one shown in the following diagram:</p>
			<div><div><img src="img/Figure_12.2_B19301.jpg" alt="Figure 12.2 – A binary search tree﻿"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – A binary search tree</p>
			<p>We can create this using the following code:</p>
			<pre class="source-code">
// functionAsTree.ts
const myTree: TREE = NewTree(
  22,
  NewTree(
    9,
    NewTree(4, EmptyTree(), EmptyTree()),
    NewTree(12, EmptyTree(), EmptyTree())
  ),
  NewTree(
    60,
    NewTree(56, EmptyTree(), EmptyTree()),
    EmptyTree()
  )
);</pre>
			<p>How do you work with this structure? According to the data type description, whenever you work with a tree, you must consider two cases: a non-empty tree and an empty one. In the preceding<a id="_idIndexMarker1034"/> code, <code>myTree()</code> is a function that receives two functions as arguments, one for each of the two data type cases. The first function will be called with the node value and left and right trees as arguments, while the second function will receive none:</p>
			<pre class="source-code">
// continued...
type TREE&lt;A&gt; = (
  _nonEmptyTree: (
    _x: A,
    _left: TREE&lt;A&gt;,
    _right: TREE&lt;A&gt;
  ) =&gt; any,
  _emptyTree: () =&gt; any
) =&gt; any;</pre>
			<p>To get the root of a tree, we could write something similar to the following:</p>
			<pre class="source-code">
const myRoot = myTree(
<strong class="bold">  (value) =&gt; value,</strong>
<strong class="bold">  () =&gt; null</strong>
);</pre>
			<p>If we were dealing with a non-empty tree, we would expect the first function to be called and return the<a id="_idIndexMarker1035"/> value of the root. With an empty tree, the second function should be called, and then a <code>null</code> value would be returned.</p>
			<p>Similarly, if we wanted to count how many nodes there are in a tree, we would write the following:</p>
			<pre class="source-code">
// continued...
const treeCount = &lt;A&gt;(tree: TREE&lt;A&gt;): number =&gt;
  tree(
<strong class="bold">    (value, left, right) =&gt;</strong>
<strong class="bold">      1 + treeCount(left) + treeCount(right),</strong>
<strong class="bold">    () =&gt; 0</strong>
  );
console.log(treeCount(myTree));</pre>
			<p>For non-empty trees, the first function would return <code>1</code> (for the root), plus the node count from both the root’s subtrees. For empty trees, the count is simply <code>0</code>. Get the idea?</p>
			<p>Now, we can show the <code>NewTree()</code> and <code>EmptyTree()</code> functions. They are as follows:</p>
			<pre class="source-code">
// continued...
const NewTree =
  &lt;A&gt;(value: A, left: TREE&lt;A&gt;, right: TREE&lt;A&gt;): TREE&lt;A&gt; =&gt;
  (destructure, _) =&gt;
    destructure(value, left, right);
const EmptyTree =
  &lt;A&gt;(): TREE&lt;A&gt; =&gt;
  (_, destructure) =&gt;
    destructure();</pre>
			<p>The <code>destructure()</code> function is what you will pass as an argument (the name comes from the destructuring statement in JavaScript, which lets you separate an object attribute into distinct variables). You will have to provide two versions of this function. If the tree is non-empty, the first function will be executed; for an empty tree, the second one will be run (this mimics the case selection in the Haskell code, except we are placing the non-empty tree case<a id="_idIndexMarker1036"/> first and the empty tree last). The underscore-named variable is used as a placeholder that stands for an otherwise-ignored argument but shows that two arguments are assumed; an initial underscore is usually meant to imply some parameter isn’t used.</p>
			<p>This can be hard to understand, so let’s look at more examples. If we need to access specific elements of a tree, we have the following three functions:</p>
			<pre class="source-code">
// continued...
const treeRoot = &lt;A&gt;(tree: TREE&lt;A&gt;): A | null =&gt;
  tree(
    (value, _left, _right) =&gt; value,
    () =&gt; null
  );</pre>
			<p>How can we decide whether a tree is empty? See whether you can figure out why the following short line of code works:</p>
			<pre class="source-code">
// continued...
const treeIsEmpty = &lt;A&gt;(tree: TREE&lt;A&gt;): boolean =&gt;
  tree(
    () =&gt; false,
    () =&gt; true
  );</pre>
			<p>Let’s go over a few more <a id="_idIndexMarker1037"/>examples of this. For example, we can build an object out of a tree, which would help with debugging. I added logic to avoid including left or right empty subtrees, so the produced object would be more compact; check out the two <code>if</code> statements in the following code:</p>
			<pre class="source-code">
// continued...
const treeToObject = &lt;A&gt;(tree: TREE&lt;A&gt;): OBJ =&gt;
  tree(
    (value, left, right) =&gt; {
      const leftBranch = treeToObject(left);
      const rightBranch = treeToObject(right);
      const result: OBJ = { value };
      if (leftBranch) {
        result.left = leftBranch;
      }
      if (rightBranch) {
        result.right = rightBranch;
      }
      return result;
    },
    () =&gt; null
  );</pre>
			<p>Note the usage of recursion, as in the <em class="italic">Traversing a tree structure</em> section of <a href="B19301_09.xhtml#_idTextAnchor172"><em class="italic">Chapter 9</em></a>, Designing Functions, to produce the object equivalents of the left and right subtrees. An example of this function is as follows; I edited <a id="_idIndexMarker1038"/>the output to make it clearer:</p>
			<pre class="source-code">
console.log(treeToObject(myTree));
/*
{
  value: 22,
  left: {
    value: 9,
    left: {
      value: 4,
    },
    right: { value: 12 },
  },
  right: {
    value: 60,
    left: {
      value: 56,
    },
  },
};
*/</pre>
			<p>Can we search for a node? Of course, and the logic closely follows the definition we saw in the previous section. (We could have shortened the code a bit, but I wanted to parallel the Haskell version; for <a id="_idIndexMarker1039"/>a leaner version, see <em class="italic">Question 12.6</em>.) Our <code>treeSearch()</code> function could be as follows:</p>
			<pre class="source-code">
// continued...
const treeSearch = &lt;A&gt;(
  findValue: A,
  tree: TREE&lt;A&gt;
): boolean =&gt;
  tree(
    (value, left, right) =&gt;
      findValue === value
        ? true
        : findValue &lt; value
        ? treeSearch(findValue, left)
        : treeSearch(findValue, right),
    () =&gt; false
  );</pre>
			<p>If the value we want is the root, we found it; if it’s smaller than the root, we recursively search the left subtree, and if greater, the right subtree.</p>
			<p>To round off this section, let’s also look at how to add new nodes to a tree. Study the code carefully; you’ll notice how the current tree isn’t modified and that a new one is produced instead. Of course, given that we are using functions to represent our tree data type, it should be <a id="_idIndexMarker1040"/>evident that we wouldn’t have been able to modify the old structure: it’s immutable by default. The tree insertion function would be as follows:</p>
			<pre class="source-code">
// continued...
const treeInsert = &lt;A&gt;(
  newValue: A,
  tree: TREE&lt;A&gt;
): TREE&lt;A&gt; =&gt;
  tree(
    (value, left, right) =&gt;
      newValue &lt;= value
        ? NewTree(value, treeInsert(newValue, left), right)
        : NewTree(value, left, treeInsert(newValue,
          right)),
    () =&gt; NewTree(newValue, EmptyTree(), EmptyTree())
  );</pre>
			<p>When trying to insert a new key, if its value is less than or equal to the root of the tree, we produce a new tree that has the current root as its own root, maintains the old right subtree, but changes its left subtree to incorporate the new value (which will be done recursively). If the key was greater than the root, the changes wouldn’t have been symmetrical; they would have been analogous. If we try to insert a new key and find ourselves with an empty tree, we replace that empty structure with a new tree having the new value at its root, and empty left and right subtrees.</p>
			<p>We can test out this logic easily, but the simplest way is to verify that the binary tree that we showed earlier (<em class="italic">Figure 12</em><em class="italic">.2</em>) is generated by the following sequence of operations:</p>
			<pre class="source-code">
let myTree = EmptyTree();
myTree = treeInsert(22, myTree);
myTree = treeInsert(9, myTree);
myTree = treeInsert(60, myTree);
myTree = treeInsert(12, myTree);
myTree = treeInsert(4, myTree);
myTree = treeInsert(56, myTree);
// The resulting tree is:
{
  value: 22,
  left: {
    value: 9,
    left: { value: 4 },
    right: { value: 12 },
  },
  right: { value: 60, left: { value: 56 } },
}</pre>
			<p>We could make this<a id="_idIndexMarker1041"/> insertion function even more general by providing the comparator function that would be used to compare values. In this fashion, we could easily adapt a binary tree to represent a generic map. The value of a node would actually be an object such as <code>{key:... , data:...}</code> and the provided function would compare <code>newValue.key</code> and <code>value.key</code> to decide where to add the new node. Of course, if the two keys were equal, we would change the root of the current tree. The new tree insertion code would be as follows. Let’s start with types and comparisons:</p>
			<pre class="source-code">
// continued...
type NODE&lt;K, D&gt; = { key: K; data: D };
const compare = &lt;K, D&gt;(
  obj1: NODE&lt;K, D&gt;,
  obj2: NODE&lt;K, D&gt;
) =&gt;
  obj1.key === obj2.key ? 0 : obj1.key &lt; obj2.key ? -1 : 1;</pre>
			<p>The tree insertion <a id="_idIndexMarker1042"/>code is now the following:</p>
			<pre class="source-code">
// continued...
const treeInsert2 = &lt;K, D&gt;(
  comparator: typeof compare&lt;K, D&gt;,
  newValue: NODE&lt;K, D&gt;,
  tree: TREE&lt;NODE&lt;K, D&gt;&gt;
): TREE&lt;NODE&lt;K, D&gt;&gt; =&gt;
  tree(
    (value, left, right) =&gt;
      comparator(newValue, value) === 0
        ? NewTree(newValue, left, right)
        : comparator(newValue, value) &lt; 0
        ? NewTree(
            value,
            treeInsert2(comparator, newValue, left),
            right
          )
        : NewTree(
            value,
            left,
            treeInsert2(comparator, newValue, right)
          ),
    () =&gt; NewTree(newValue, EmptyTree(), EmptyTree())
  );</pre>
			<p>What else do we need? Of<a id="_idIndexMarker1043"/> course, we can program diverse functions: deleting a node, counting nodes, determining a tree’s height, comparing two trees, and so on. However, in order to gain more usability, we should really turn the structure into a functor by implementing a <code>map()</code> function. Fortunately, using recursion, this proves to be easy—we apply the mapping function to the tree root and use <code>map()</code> recursively on the left and right subtrees, as follows:</p>
			<pre class="source-code">
// continued...
const treeMap = &lt;A, B&gt;(
  fn: (_x: A) =&gt; B,
  tree: TREE&lt;A&gt;
): TREE&lt;B&gt; =&gt;
  tree(
    (value, left, right) =&gt;
      NewTree(
        fn(value),
        treeMap(fn, left),
        treeMap(fn, right)
      ),
    () =&gt; EmptyTree()
  );</pre>
			<p>We could go on with more examples, but that wouldn’t change the important conclusions we can derive from this work:</p>
			<ul>
				<li>We are handling a data structure (a recursive one, at that) and representing it with a function</li>
				<li>We aren’t using external variables or objects for the data: closures are used instead</li>
				<li>The data structure satisfies all the requirements we analyzed in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, insofar that it is immutable and all the changes always produce new structures</li>
				<li>The tree is a functor, providing all the corresponding advantages</li>
			</ul>
			<p>In this section, we<a id="_idIndexMarker1044"/> have looked at one more application of FP as well as how a function can actually become a structure by itself, which isn’t what we are usually accustomed to!</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor233"/>Summary</h1>
			<p>In this chapter, we looked at the theory of data types and learned how to use and implement them from a functional point of view. We started with defining function signatures to help us understand the transformations implied by the multiple operations we looked at later, with a syntax independent from TypeScript’s. Then, we went on to define several containers, including functors and monads, and saw how they can be used to enhance function composition. Finally, we learned how functions can be directly used by themselves, with no extra baggage, to implement functional data structures to simplify dealing with errors.</p>
			<p>In this book, we have looked at several features of FP for JavaScript and TypeScript. We started with some definitions, and a practical example, then moved on to important considerations such as pure functions, avoiding side effects, immutability, testability, building new functions out of other ones, and implementing a data flow based upon function connections and data containers. We have looked at a lot of concepts, but I’m confident that you’ll be able to put them to practice and start writing even higher-quality code—give it a try, and thank you very much for reading this book!</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor234"/>Questions</h1>
			<p>12.1 <code>global</code> declaration; can you add that declaration?</p>
			<p>12.2 <code>Symbol</code>!</p>
			<p>12.3 <code>Maybe</code> and <code>Either</code> monads, but those types of classes are only available in TypeScript. Can you figure out an alternative way of working, but in JavaScript?</p>
			<p>12.4 <code>Maybe</code> or <code>Either</code> monad to simplify that code.</p>
			<p>12.5 <strong class="bold">Extending your trees</strong>: To get a more complete implementation of our functional binary search trees, implement the following functions:</p>
			<ul>
				<li>Calculate the tree’s height or, equivalently, the maximum distance from the root to any other node</li>
				<li>List all the tree’s keys, in ascending order</li>
				<li>Delete a key from a tree</li>
			</ul>
			<p>12.6 <code>treeSearch()</code> function could be shortened—can you do that? Yes, this is more of a JavaScript problem than a functional one, and I’m not saying that shorter code is necessarily better, but many programmers act as if it were, so it’s good to be aware of such a style if only because you’re likely to find it.</p>
			<p>12.7 <strong class="bold">Functional lists</strong>: In the same spirit as binary trees, implement functional lists. Since a list is defined to be either empty or a node (<em class="italic">head</em>), followed by another list (<em class="italic">tail</em>), you might want to start with the following, quite similar to our binary search tree:</p>
			<pre class="source-code">
type LIST&lt;A&gt; = (
  _nonEmptyList: (_head: A, _tail: LIST&lt;A&gt;) =&gt; any,
  _emptyList: LIST&lt;A&gt;
) =&gt; any;
const NewList =
  &lt;A&gt;(head: A, tail: LIST&lt;A&gt;): LIST&lt;A&gt; =&gt;
  (f: FN, _g: FN) =&gt;
    f(head, tail);
const EmptyList =
  &lt;A&gt;(): LIST&lt;A&gt; =&gt;
  (f: FN, g: FN) =&gt;
    g();</pre>
			<p>Here are some easy one-line operations to get you started; note they are very similar in style to what we wrote for binary trees:</p>
			<pre class="source-code">
const listHead = &lt;A&gt;(list: LIST&lt;A&gt;): A | null =&gt;
  list(
    (head: A, _tail: LIST&lt;A&gt;) =&gt; head,
    () =&gt; null
  );
const listTail = &lt;A&gt;(list: LIST): LIST&lt;A&gt; | null =&gt;
  list(
    (head: A, tail: LIST&lt;A&gt;) =&gt; tail,
    () =&gt; null
  );
const listIsEmpty = &lt;A&gt;(list: LIST&lt;A&gt;): boolean =&gt;
  list(
    (_head: A, _tail: LIST&lt;A&gt;) =&gt; false,
    () =&gt; true
  );
const listSize = &lt;A&gt;(list: LIST&lt;A&gt;): number =&gt;
  list(
    (head: A, tail: LIST&lt;A&gt;) =&gt; 1 + listSize(tail),
    () =&gt; 0
  );</pre>
			<p>You could consider having these operations:</p>
			<ul>
				<li>Transforming a list into an array and vice versa</li>
				<li>Reversing a list</li>
				<li>Appending one list to the end of another list</li>
				<li>Concatenating two lists</li>
			</ul>
			<p>Don’t forget a <code>listMap()</code> function! Also, the <code>listReduce()</code> and <code>listFilter()</code> functions will come in handy.</p>
			<p>12.8 <code>true</code> and <code>false</code> Boolean values, but we didn’t have any operators such as <code>&amp;&amp;</code>, <code>||</code>, or <code>!</code>. While we could make up for their absence with some (possibly repetitive) coding, we can have functions produce the same results; can you see how? Think along the same lines as for binary trees. We could represent a Boolean value by a function that takes a pair of functions as arguments and applies the first if the Boolean is true, and the second otherwise.</p>
		</div>
	

		<div><h1 id="_idParaDest-233"><a id="_idTextAnchor235"/>Answers to Questions</h1>
			<p>Here are the solutions (partial, or worked out in full) to the questions that were contained within the chapters in this book. In many cases, there are extra questions so that you can do further work if you choose to.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/>Chapter 1, Becoming Functional – Several Questions</h1>
			<p>1.1 <strong class="bold">TypeScript, please!</strong> The following are the fully annotated versions of the code in the chapter. This is the code for the factorial functions:</p>
			<pre class="source-code">
// question_01_typescript_please.ts
function fact(<strong class="bold">n: number</strong>)<strong class="bold">: number</strong> {
  if (n === 0) {
    return 1;
  } else {
    return n * fact(n - 1);
  }
}
const fact2 = (<strong class="bold">n: number</strong>)<strong class="bold">: number</strong> =&gt; {
  if (n === 0) {
    return 1;
  } else {
    return n * fact2(n - 1);
  }
};
const fact3 = (<strong class="bold">n: number</strong>)<strong class="bold">: number</strong> =&gt;
  n === 0 ? 1 : n * fact3(n - 1);</pre>
			<p>This is the code for the spreading examples:</p>
			<pre class="source-code">
// continued...
function sum3(<strong class="bold">a: number, b: number, c: number</strong>)<strong class="bold">: number</strong> {
  return a + b + c;
}
const x<strong class="bold">: [number, number, number]</strong> = [1, 2, 3];
const y = sum3(...x); // equivalent to sum3(1,2,3)
const f = [1, 2, 3];
const g = [4, ...f, 5];
const h = [...f, ...g];
const p = { some: 3, data: 5 };
const q = { more: 8, ...p };
const numbers = [2, 2, 9, 6, 0, 1, 2, 4, 5, 6];
const minA = Math.min(...numbers); // 0
const maxArray = (arr<strong class="bold">: number[]</strong>) =&gt; Math.max(...arr);
const maxA = maxArray(numbers); // 9</pre>
			<p>Why do we need to specify the type of <code>x</code>, but not those of <code>f</code>, <code>g</code>, <code>h</code>, <code>p</code>, and <code>q</code>? The issue is that TypeScript checks the call to <code>sum3()</code>, and for that, it needs to be sure that <code>x</code> is defined to be an array with three numbers.</p>
			<p>TypeScript would be able to deduce that <code>sum3()</code> returns a number, but it’s best if you specify it, to prevent possible future bugs where you would return something that isn’t a number.</p>
			<p>The <code>newCounter()</code> function needs no type definitions; TypeScript is able to work types out. (See <em class="italic">Question 1.7</em> further on.)</p>
			<p>1.2 <code>new</code>. Therefore, it stands to reason that we should be able to pass classes as parameters to other functions. <code>makeSaluteClass()</code> creates a class (that is, a special function) that uses a closure to remember the value of <code>term</code>. We have looked at more examples like this throughout this book.</p>
			<p>The TypeScript code for the class is as follows:</p>
			<pre class="source-code">
// question_01_classes_as_1st_class.ts
const makeSaluteClass = (term: string) =&gt;
  class {
    x: string;
    constructor(x: string) {
      this.x = x;
    }
    salute(y: string) {
      console.log(`${this.x} says "${term}" to ${y}`);
    }
  };
const Spanish = makeSaluteClass("HOLA");
new Spanish("ALFA").salute("BETA");
// ALFA says "HOLA" to BETA
new (makeSaluteClass("HELLO"))("GAMMA").salute("DELTA");
// GAMMA says "HELLO" to DELTA
const fullSalute = (
  c: ReturnType&lt;typeof makeSaluteClass&gt;,
  x: string,
  y: string
) =&gt; new c(x).salute(y);
const French = makeSaluteClass("BON JOUR");
fullSalute(French, "EPSILON", "ZETA");
// EPSILON says "BON JOUR" to ZETA</pre>
			<p>Note the usage of TypeScript’s <code>ReturnType&lt;&gt;</code> utility type to specify that <code>c</code> will be something created by calling <code>makeSaluteClass()</code>.</p>
			<p>1.3 <code>f</code>, and we make it climb from <code>1</code> to <code>n</code>. We must be careful so that <code>factUp(0) === </code><code>1</code>:</p>
			<pre class="source-code">
// question_01_climbing_factorial.ts
const factUp = (n: number, <strong class="bold">f = 1</strong>): number =&gt;
  n &lt;= f ? f : f * factUp(n, <strong class="bold">f + 1</strong>);</pre>
			<p>You don’t need to specify that <code>f</code> is of type <code>number</code>; TypeScript automatically works that out.</p>
			<p>This solution may worry you because nobody prevents calling <code>factUp()</code> with two arguments – but we need the second parameter to be omitted, so it will be initialized to <code>1</code>. We can solve this defect as follows:</p>
			<pre class="source-code">
// continued...
const factUp2 = (n: number): number =&gt; {
  const factAux = (f: number): number =&gt;
    n &lt;= f ? f : f * factAux(f + 1);
  return factAux(1);
};</pre>
			<p>The internal <code>factAux()</code> function is basically our previous <code>factUp()</code> function, except that it doesn’t need the <code>n</code> parameter, because it’s available in its scope. Our new <code>factUp2()</code> function calls <code>factAux()</code>, providing its needed default value of <code>1</code>.</p>
			<p>If you like having a default value, you can go with the following code:</p>
			<pre class="source-code">
// continued...
const factUp3 = (n: number): number =&gt; {
  const factAux = (f = 1): number =&gt;
    n &lt;= f ? f : f * factAux(f + 1);
  return factAux();
};</pre>
			<p>To test these functions, the tests (for correct values) in <em class="italic">Question 1.5</em> will do.</p>
			<p>1.4 <strong class="bold">Factorial errors</strong>: The key to avoiding repeating tests is to write a function that will check the value of the argument to ensure it’s valid, and if so, call an inner function to do the factorial itself, without worrying about erroneous arguments:</p>
			<pre class="source-code">
// question_01_factorial_errors.ts
const carefulFact = (n: number): number | never =&gt; {
  if (
<strong class="bold">    typeof n === "number" &amp;&amp;</strong>
<strong class="bold">    n &gt;= 0 &amp;&amp;</strong>
<strong class="bold">    n === Math.floor(n)</strong>
  ) {
    const innerFact = (n: number): number =&gt;
      n === 0 ? 1 : n * innerFact(n - 1);
    return innerFact(n);
  } else {
    throw new Error("Wrong parameter for carefulFact2");
  }
};</pre>
			<p>In order, we check that <code>n</code> must be a number, not negative, and an integer. When an incorrect argument is recognized, we throw an error. By the way, that’s the reason for the <code>number | never</code> type specification; the user of this function directly recognizes that sometimes (namely, when an exception is thrown) no value will be returned.</p>
			<p>1.5 <strong class="bold">Factorial testing</strong>: The following tests do the trick:</p>
			<pre class="source-code">
// question_01_factorial_testing.test.ts
import { carefulFact } from "./question_1.4";
describe("Correct cases", () =&gt; {
  test("5! = 120", () =&gt; expect(carefulFact(5)).toBe(120));
  test("0! = 1", () =&gt; expect(carefulFact(0)).toBe(1));
});
describe("Errors", () =&gt; {
  test("Should reject 3.1", () =&gt; {
    expect(() =&gt; carefulFact(3.1)).toThrow();
  });
  test("Should reject -4", () =&gt; {
    expect(() =&gt; carefulFact(-3)).toThrow();
  });
  test("Should reject -5.2", () =&gt; {
    expect(() =&gt; carefulFact(-3)).toThrow();
  });
});</pre>
			<p>Running the suite shows we achieved 100% coverage.</p>
			<p>1.6 <code>++</code> operator (for more information, see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment</a>), you can condense <code>newCounter()</code> down to the following:</p>
			<pre class="source-code">
// question_01_code_squeezing.ts
const shorterCounter = () =&gt; {
  let count = 0;
  return () =&gt; ++count;
};</pre>
			<p>Using arrow functions isn’t hard to understand, but be aware that many developers may have questions or doubts about using <code>++</code> as a prefix operator, so this version could prove to be harder to understand.</p>
			<p>ESLint has a <code>no-plusplus</code> rule that disallows both <code>++</code> and <code>--</code>. Since I do approve of using them, I had to disable the rule; see <a href="http://eslint.org/docs/latest/user-guide/configuring/rules">eslint.org/docs/latest/user-guide/configuring/rules</a> for more on this.</p>
			<p>1.7 <code>newCounter()</code> takes no arguments and returns a number, the answer is <code>() =&gt; </code><code>number</code>.</p>
			<p>If you are working with Visual Studio Code, there’s a quicker way of doing this: hovering will provide the answer, as in <em class="italic">Figure 1</em>.</p>
			<div><div><img src="img/Figure_1_B19301.jpg" alt="Figure 1 – Visual Studio Code helps with typing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1 – Visual Studio Code helps with typing</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor237"/>Chapter 2, Thinking Functionally – A First Example</h1>
			<p>2.1 <code>fn</code> variable itself as a flag. After calling <code>fn()</code>, we set the variable to <code>null</code>. Before calling <code>fn()</code>, we check that it’s not <code>null</code> by using the short-circuit <code>&amp;&amp;</code> operator:</p>
			<pre class="source-code">
// question_02_no_extra_variables.ts
const once = &lt;FNType extends (...args: any[]) =&gt; any&gt;(
  fn: FNType | null
) =&gt;
  ((...args: Parameters&lt;FNType&gt;) =&gt; {
    <strong class="bold">fn &amp;&amp;</strong> fn(...args);
    <strong class="bold">fn = null</strong>;
  }) as FNType;</pre>
			<p>We need a small change to let TypeScript know that <code>fn</code> could be <code>null</code>; otherwise, it would object to the <code>fn = </code><code>null</code> assignment.</p>
			<p>2.2 <strong class="bold">Alternating functions</strong>: Like what we did in the previous question, we swap functions, and then we do the call. Here, we use a destructuring assignment to write the swap more compactly. For more information, refer to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables</a>:</p>
			<pre class="source-code">
// question_02_alternating_fns.ts
const alternator = &lt;FNType extends (...args: any[]) =&gt;
  any&gt;(
  fn1: FNType,
  fn2: FNType
) =&gt;
  ((...args: Parameters&lt;FNType&gt;) =&gt; {
<strong class="bold">    [fn1, fn2] = [fn2, fn1];</strong>
    return fn2(...args);
  }) as FNType;</pre>
			<p>We can write a test as follows:</p>
			<pre class="source-code">
// question_02_alternating_fns.test.ts
import { alternator } from "./question_2.2";
describe("alternator", () =&gt; {
  it("calls the two functions alternatively", () =&gt; {
    const funcA = jest.fn().mockReturnValue("A");
    const funcB = jest.fn().mockReturnValue("B");
    const testFn = jest.fn(alternator(funcA, funcB));
    expect(testFn()).toEqual("A");
    expect(testFn()).toEqual("B");
    expect(testFn()).toEqual("A");
    expect(testFn()).toEqual("B");
    expect(testFn()).toEqual("A");
    expect(testFn()).toEqual("B");
    expect(testFn).toHaveBeenCalledTimes(6);
    expect(funcA).toHaveBeenCalledTimes(3);
    expect(funcB).toHaveBeenCalledTimes(3);
  });
});</pre>
			<p>We set up two mock functions, one will return <code>"A"</code> and the other <code>"B"</code>, and then we test that successive calls alternate between those two values.</p>
			<p>2.3 <code>limit</code> is greater than <code>0</code>. If so, we decrement it by 1 and call the original function; otherwise, we do nothing:</p>
			<pre class="source-code">
// question_02_everything_has_a_limit.ts
const thisManyTimes =
  &lt;FNType extends (...args: any[]) =&gt; any&gt;(
    fn: FNType,
    limit: number
  ) =&gt;
  (...args: Parameters&lt;FNType&gt;) =&gt; {
<strong class="bold">    if (limit &gt; 0) {</strong>
<strong class="bold">      limit--;</strong>
<strong class="bold">      return fn(...args);</strong>
<strong class="bold">    }</strong>
  };</pre>
			<p>We can write a test for it as follows:</p>
			<pre class="source-code">
// question_02_everything_has_a_limit.test.ts
import { thisManyTimes } from "./question_2.3";
describe("thisManyTimes", () =&gt; {
  it("calls the function 2 times, nothing after", () =&gt; {
    <strong class="bold">const fn = jest.fn()</strong>;
    <strong class="bold">const testFn = jest.fn(thisManyTimes(fn, 2))</strong>;
    testFn(); // works
    testFn(); // works
    testFn(); // nothing now
    testFn(); // nothing now
    testFn(); // nothing now
    testFn(); // nothing now
    expect(testFn).toHaveBeenCalledTimes(6);
    expect(fn).toHaveBeenCalledTimes(2);
  });
});</pre>
			<p>Our <code>testFn()</code> function is set to call <code>fn()</code> twice, no more; the tests confirm that behavior.</p>
			<p>2.4 <code>once()</code>, so if <code>fn()</code> crashes, we’ll reset <code>done</code> to <code>false</code> to allow a new attempt:</p>
			<pre class="source-code">
// question_02_allow_for_crashing.ts
const onceIfSuccess = &lt;
  FNType extends (...args: any[]) =&gt; any
&gt;(
  fn: FNType
) =&gt; {
  let done = false;
  return ((...args: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
<strong class="bold">      try {</strong>
<strong class="bold">        return fn(...args);</strong>
<strong class="bold">      } catch {</strong>
<strong class="bold">        done = false;</strong>
<strong class="bold">      }</strong>
    }
  }) as FNType;
};</pre>
			<p>We can see this works with a simple example; our <code>crashTwice()</code> function will throw an error twice and work fine afterward:</p>
			<pre class="source-code">
// question_02_allow_for_crashing.manual.ts
import { onceIfSuccess } from "./question_2.4";
let count = 0;
const crashTwice = () =&gt; {
  count++;
  if (count &lt;= 2) {
    console.log("CRASH!");
    throw new Error("Crashing...");
  } else {
    console.log("OK NOW");
  }
};
const doIt = onceIfSuccess(crashTwice);
doIt(); // CRASH!
doIt(); // CRASH!
doIt(); // OK NOW
doIt(); // nothing
doIt(); // nothing
doIt(); // nothing</pre>
			<p>We can write tests as follows:</p>
			<pre class="source-code">
// question_02_allow_for_crashing.test.ts
import { onceIfSuccess } from "./question_2.4";
describe("onceIfSuccess", () =&gt; {
  it("should run once if no errors", () =&gt; {
<strong class="bold">    const myFn = jest.fn();</strong>
<strong class="bold">    const onceFn = jest.fn(onceIfSuccess(myFn));</strong>
    onceFn();
    onceFn();
    onceFn();
    expect(onceFn).toHaveBeenCalledTimes(3);
    expect(myFn).toHaveBeenCalledTimes(1);
  });
  it("should run again if an exception", () =&gt; {
<strong class="bold">    const myFn = jest.fn()</strong>
<strong class="bold">      .mockImplementationOnce(() =&gt; {</strong>
<strong class="bold">        throw new Error("ERROR 1");</strong>
<strong class="bold">      })</strong>
<strong class="bold">      .mockImplementationOnce(() =&gt; {</strong>
<strong class="bold">        throw new Error("ERROR 2");</strong>
<strong class="bold">      })</strong>
<strong class="bold">      .mockReturnValue(22);</strong>
    const onceFn = jest.fn(onceIfSuccess(myFn));
    expect(onceFn).toThrow();
    expect(onceFn).toThrow();
    expect(onceFn()).toBe(22); // OK now (returns 22)
    onceFn(); // nothing
    onceFn(); // nothing
    onceFn(); // nothing
    expect(onceFn).toHaveBeenCalledTimes(6);
    expect(myFn).toHaveBeenCalledTimes(3);
  });
});</pre>
			<p>We need to check two cases: when the called function works normally and when it crashes at least once. The first case is just like the test we wrote for <code>once()</code>, so nothing is new here. For the second case, we set up a mock <code>myFn()</code> function that throws errors twice and returns a regular value afterward; the test verifies the expected behavior.</p>
			<p>2.5 <strong class="bold">Say no to arrows</strong>: The code is essentially the same, but the placement of type information varies:</p>
			<pre class="source-code">
// question_02_say_no_to_arrows.ts
function once<strong class="bold">&lt;FNType extends (...args: any[]) =&gt; any&gt;</strong>(
  fn<strong class="bold">: FNType</strong>
)<strong class="bold">: FNType</strong> {
  let done = false;
  return function (...args<strong class="bold">: Parameters&lt;FNType&gt;</strong>) {
    if (!done) {
      done = true;
      return fn(...args);
    }
  } <strong class="bold">as FNType</strong>;
}</pre>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/>Chapter 3, Starting Out with Functions – A Core Concept</h1>
			<p>3.1 <code>type</code> is considered to be labeling a statement, which doesn’t really do anything: it’s a <code>(t)</code> expression that isn’t used. Due to this, the code is considered valid, and since it doesn’t have an explicit <code>return</code> statement, the implicit returned value is <code>undefined</code>.</p>
			<p>The corrected code is as follows:</p>
			<pre class="source-code">
const simpleAction = (t:string) =&gt; <strong class="bold">(</strong>{
  type: t;
}<strong class="bold">)</strong>;</pre>
			<p>See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label</a> for more on labels, and developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Returning_object_literals for more on returning objects.</p>
			<p>3.2 <code>useArguments2()</code>, but with <code>useArguments()</code>, you would get an error since arguments are not defined for arrow functions:</p>
			<pre class="source-code">
useArguments(22,9,60);
Uncaught ReferenceError: arguments is not defined</pre>
			<p>3.3 <strong class="bold">Three more types</strong>: We have the following:</p>
			<ul>
				<li><code>fn1</code> is <code>(y: number) =&gt; (z: number) =&gt; </code><code>number</code></li>
				<li><code>fn2</code> is <code>(z: number) =&gt; </code><code>number</code></li>
				<li><code>fn3</code> is just <code>number</code></li>
			</ul>
			<p>3.4 <strong class="bold">One-liner</strong>: It works! (Yes, a one-line answer is appropriate in this case!)</p>
			<p>3.5 <code>State</code>, we’d have an object with all the fields needed for your application. For a generic version, we could write the following, but a specific description would be much better:</p>
			<pre class="source-code">
type State = Record&lt;string, unknown&gt;;</pre>
			<p>We would define all the possible action types with something like the following:</p>
			<pre class="source-code">
type ActionType = "CREATE" | "DELETE" | "UPDATE";</pre>
			<p>We’d have an object with <code>type</code> and an optional <code>payload</code> for actions:</p>
			<pre class="source-code">
type Action = {
  type: ActionType;
  payload: Record&lt;string, unknown&gt; | null;
};</pre>
			<p>(It would be much better if you defined in detail what possible payloads you could have, instead of going with a generic definition as in the preceding code.)</p>
			<p>Our <code>doAction()</code> function would be as follows:</p>
			<pre class="source-code">
function doAction(state: State, action: Action) {
  const newState: State = {};
  switch (action?.type) {
    …
  }
}</pre>
			<p>For <code>dispatchTable</code>, we’d have the following:</p>
			<pre class="source-code">
const dispatchTable: Record&lt;
  ActionType,
  (state: State, action: Action) =&gt; State
&gt; = {
  CREATE: (state, action) =&gt; {
    // update state, generating newState,
    // depending on the action data
    // to create a new item
    const NewState: State = {
      /* updated State */
    };
    return NewState;
  },
  …
};</pre>
			<p>Finally, we would write the following:</p>
			<pre class="source-code">
function doAction2(state: State, action: Action) {
  return dispatchTable[action.type]
    ? dispatchTable[action.type](state, action)
    : state;
}</pre>
			<p>3.6 <code>console(...), window.store.set(...)</code>) code, but the bug isn’t there: because of how the comma operator works, JavaScript does the logging first, and then the setting. The real problem is that <code>oldSet()</code> is not bound to the <code>window.store</code> object, so the second line should be as follows instead:</p>
			<pre class="source-code">
const oldSet = window.store.set.bind(window.store);</pre>
			<p>Reread the <em class="italic">Working with methods</em> section for more on this, and see <em class="italic">Question 11.1</em> for another way of doing logging – that is, with decorators.</p>
			<p>3.7 <code>bind()</code> wasn’t available, you could use a closure, the <code>that</code> trick (which we saw in the <em class="italic">Handling the this value</em> section), and the <code>apply()</code> method, as follows:</p>
			<pre class="source-code">
// question_03_bindless_binding.ts
function bind(context) {
  var <strong class="bold">that = this;</strong>
  return function() {
    return <strong class="bold">that.apply</strong>(context, arguments);
  };
}</pre>
			<p>We could do something similar to what we did in the <em class="italic">Adding missing </em><em class="italic">functions</em> section.</p>
			<p>Alternatively, just for variety, we could use a common idiom based on the <code>||</code> operator: if <code>Function.prototype.bind</code> exists, evaluation stops right there, and the existing <code>bind()</code> method is used; otherwise, our new function is applied:</p>
			<pre class="source-code">
Function.prototype.bind =
  <strong class="bold">Function.prototype.bind ||</strong> function(context) {
  var that = this;
  return function() {
    return that.apply(context, arguments);
  };
};</pre>
			<p>3.8 <code>compare(a,b)</code> comparison function must return a positive number if <code>a&gt;b</code>, a negative number if <code>a&lt;b</code>, or <code>0</code> if <code>a</code> equals <code>b</code>. When you subtract <code>ab</code>, you get that result, so it works. (Of course, this assumes that no number is either <code>Infinity</code> or <code>NaN</code>.) For more on this, check <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description</a>.</p>
			<p>3.9 <code>-</code>”, so that’s kind of right, but the numbers themselves are still sorted as strings, so the result is wrong anyway. In the following example, the lowest number is <code>-666</code>, which should have been the first element after sorting:</p>
			<pre class="source-code">
let someNumbers = [3, 20, 100, -44, -5, -666];
someNumbers.sort();  // [-44, -5, -666, 100, 20, 3]</pre>
			<p>3.10 <strong class="bold">Lexicographic sorting</strong>: Let’s suppose we have an array of strings. To sort it lexicographically in an efficient way, a solution would be as follows:</p>
			<ol>
				<li>Transform the array of strings into an array of objects with an added <code>sortBy</code> field.</li>
				<li>For each string, generate the corresponding string to sort by, and put the value in the <code>sortBy</code> field.</li>
				<li>Sort the array by <code>sortBy</code>.</li>
				<li>Drop the added field to convert the sorted array into an array of strings as originally.</li>
			</ol>
			<p>3.11 <code>console.log()</code> method can accept any number of arguments of any type, and won’t return anything, so its type is <code>(...args: </code><code>any[]): void</code>.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/>Chapter 4, Behaving Properly – Pure Functions</h1>
			<p>4.1 <strong class="bold">Must return?</strong> If a pure function doesn’t return anything, it means that the function doesn’t do anything since it can’t modify its inputs and doesn’t have any other side effect.</p>
			<p>4.2 <code>string | undefined</code>, because the <code>.pop()</code> method returns <code>undefined</code> if the input array is empty.</p>
			<p>4.3 <code>fib2()</code> in an IIFE; <code>fibC()</code> is equivalent to <code>fib2()</code> but with an internal <code>cache</code>:</p>
			<pre class="source-code">
// question_04_go_for_a_closure.ts
const fibC = (() =&gt; {
  const cache: number[] = [];
  const fib2 = (n: number): number =&gt; {
    if (cache[n] === undefined) {
      if (n === 0) {
        cache[0] = 0;
      } else if (n === 1) {
        cache[1] = 1;
      } else {
        cache[n] = fib2(n - 2) + fib2(n - 1);
      }
    }
    return cache[n];
  };
  return fib2;
})();</pre>
			<p>4.4 <strong class="bold">Minimalistic function</strong>: It works because fib(0)=0 and fib(1)=1, so it’s true that for <em class="italic">n</em>&lt;2, fib(<em class="italic">n</em>) equals <em class="italic">n</em>.</p>
			<p>4.5 <code>a</code> and <code>b</code> stand for two consecutive Fibonacci numbers. This implementation is quite efficient!</p>
			<p>4.6 <strong class="bold">Rounding type</strong>: The full definition, including the result type, would be as follows:</p>
			<pre class="source-code">
const roundFix2 = (
  accum: number,
  n: number
)<strong class="bold">: {</strong>
<strong class="bold">  accum: number;</strong>
<strong class="bold">  nRounded: number;</strong>
<strong class="bold">}</strong> =&gt; ...</pre>
			<p>4.7 <strong class="bold">Tuples to go</strong>: In this case, we would return an array with two numbers, so we may write the following:</p>
			<pre class="source-code">
// question_04_tuples_to_go.ts
<strong class="bold">type AccumRoundedType = [number, number];</strong>
const roundFix2a = (
  accum: number,
  n: number
)<strong class="bold">: AccumRoundedType</strong> =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) :
    Math.floor(n);
  accum += n - nRounded;
  return [accum, nRounded];
};
const roundFix2b = (<strong class="bold">[</strong>
<strong class="bold">  accum,</strong>
<strong class="bold">  n,</strong>
<strong class="bold">]: AccumRoundedType</strong>)<strong class="bold">: AccumRoundedType</strong> =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) :
    Math.floor(n);
  accum += n - nRounded;
  return [accum, nRounded];
};</pre>
			<p>The tests are very similar to what we already wrote; here, we have abridged versions of our previous code, highlighting the needed changes:</p>
			<pre class="source-code">
// question_04_tuples_to_go.test.ts
describe("roundFix2a", function () {
  it("rounds 3.14159-&gt;3 if differences are 0", () =&gt; {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2a(0.0, 3.14159);
    expect(accum).toBeCloseTo(0.14159);
    expect(nRounded).toBe(3);
  });
  it("rounds 2.71828-&gt;3 if differences are 0.14159", () =&gt;
    {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2a(0.14159, 2.71828);
    expect(accum).toBeCloseTo(-0.14013);
    expect(nRounded).toBe(3);
  });
});
describe("roundFix2b", function () {
  it("rounds 2.71828-&gt;2 if differences are -0.14013", () =&gt;
    {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2b(<strong class="bold">[</strong>
<strong class="bold">      -0.14013, 2.71828,</strong>
<strong class="bold">    ]</strong>);
    expect(accum).toBeCloseTo(0.57815);
    expect(nRounded).toBe(2);
  });
  it("rounds 3.14159-&gt;4 if differences are 0.57815", () =&gt;
    {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2b(<strong class="bold">[</strong>
<strong class="bold">      0.57815, 3.14159,</strong>
<strong class="bold">    ]</strong>);
    expect(accum).toBeCloseTo(-0.28026);
    expect(nRounded).toBe(4);
  });
});</pre>
			<p>4.8 <code>calculateDeb2()</code> would still attempt to call the API. Providing an object with the dependencies makes injection an <em class="italic">all-or-nothing</em> option.</p>
			<p>4.9 <code>"Math failure?"</code> message. The problem has to do with the fact that JavaScript internally uses binary instead of decimal, and floating-point precision is limited. In decimal, 0.1, 0.2, and 0.3 have a fixed, short representation, but in binary, they have infinite representation, much like 1/3=0.33333... has in decimal. If you write out the value of <code>a+b</code> after the test, you’ll get 0.30000000000000004 – and that’s why you must be very careful when testing for equality in JavaScript.</p>
			<p>4.10 <strong class="bold">Breaking laws</strong>: Some of the properties are no longer always valid. To simplify our examples, let’s assume two numbers are close to each other if they differ by no more than 0.1. If this is the case, then we have the following:</p>
			<ul>
				<li>0.5 is close to 0.6, and 0.6 is close to 0.7, but 0.5 is not close to 0.7</li>
				<li>0.5 is close to 0.6, and 0.7 is close to 0.8, but <em class="italic">0.5+0.7=1.2</em> is not close to <em class="italic">0.6+0.8=1.4</em>, and <em class="italic">0.5*0.7=0.35</em> is not close to <em class="italic">0.6*0.8=0.48</em> either</li>
				<li>0.5 is close to 0.4, and 0.2 is close to 0.3, but <em class="italic">0.5-0.2=0.3</em> is not close to <em class="italic">0.4-0.3=0.1</em>, and <em class="italic">0.5/0.2=2.5</em> is not close to <em class="italic">0.4/0.3=1.333</em></li>
			</ul>
			<p>The other cited properties are always valid.</p>
			<p>4.11 <strong class="bold">Shuffling kinds</strong>: This type definition allows our function to work with arrays of any type (strings, numbers, objects, etc.) and says that the type of the output array will be the same as the type of the input array.</p>
			<p>4.12 <code>&lt;T&gt;(arr: T[]) =&gt; void</code>. See www.typescriptlang.org/docs/handbook/2/functions.html for more.</p>
			<p>4.13 <code>JSON.stringify()</code> on it, and save the result. After shuffling, sort a copy of the shuffled array and use <code>JSON.stringify()</code> on it too. Those two JSON strings should be equal. This does away with all the other tests since it ensures that the array doesn’t change its length or elements, and it would also work for arrays with repeated elements:</p>
			<pre class="source-code">
// question_04_a_shuffle_test.test.ts
describe("shuffleTest", function () {
  it("doesn't change the array length or elements", () =&gt; {
    const a = [22, 9, 60, 22, 12, 4, 56, 22, 60];
    const <strong class="bold">oldA = JSON.stringify([...a].sort())</strong>;
    shuffle(a);
    const <strong class="bold">newA = JSON.stringify([...a].sort())</strong>;
    <strong class="bold">expect(oldA).toBe(newA)</strong>;
  });
});</pre>
			<p>4.14 <code>shuffle</code> function works well, an idea is to shuffle a small array many times, and count how many possible outputs come up; the final counts should be similar, though not necessarily (because of the random aspects) equal. In my article at <a href="https://blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/">blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/</a>, I tested the Fisher–Yates algorithm by shuffling a four-letter (A to D) array 24,000 times, and got this:</p>
			<div><div><img src="img/Figure_3_B19301.jpg" alt=""/>
				</div>
			</div>
			<p>All 24 possible orderings were produced (see the <em class="italic">Recursion</em> section in <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Becoming Functional</em>), and the results were all pretty close to 1,000; the difference between the highest and lowest counts is only around 10%. This is not a thorough statistical confirmation – for that, we’d have to apply statistical frequency tests such as χ² (Chi-squared), Kolmogorov–Smirnov, or Anderson–Darling – but at least we get a notion that shuffling is not working very badly.</p>
			<p>When I applied the (supposedly good!) algorithm, the counts were more lopsided:</p>
			<div><div><img src="img/Figure_4_B19301.jpg" alt=""/>
				</div>
			</div>
			<p>The highest count is more than 14 times the lowest; we can definitely conclude that not all arrangements are equally likely, so the popular shuffling algorithm is simply not good enough.</p>
			<p>4.15 <strong class="bold">Shuffling by sorting</strong>: To get a random sequence, we can assign to each array element a random number and sort by that number; the result will be a totally random shuffling:</p>
			<pre class="source-code">
// question_04_shuffling_by_sorting.ts
const sortingShuffle = &lt;T&gt;(arr: T[]): T[] =&gt;
  arr
    .map((v) =&gt; ({ val: v, key: Math.random() }))
    .sort((a, b) =&gt; a.key - b.key)
    .map((o) =&gt; o.val);</pre>
			<p>The first <code>.map()</code> transforms each array element into an object, with the original value at <code>val</code> and a random value at <code>key</code>. We then sort the array by the <code>key</code> value, using the technique shown in <em class="italic">Question 3.8</em>. Finally, we undo the first mapping to get just the original values.</p>
			<p>A final comment: this code is truly functional, and returns a new array instead of modifying the original argument in place.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor240"/>Chapter 5, Programming Declaratively – A Better Style</h1>
			<p>5.1 <code>filter()</code>, <code>map()</code>, and <code>reduce()</code>, but the objective of this question was to make you think about how to manage with only those. Using <code>join()</code> or other extra string functions would make the problem easier. For instance, finding out a way to add the enclosing <code>&lt;div&gt;&lt;ul&gt; ... &lt;/ul&gt;&lt;/div&gt;</code> tags is tricky, so we had to make the first <code>reduce()</code> operation produce an array so that we could keep on working on it:</p>
			<pre class="source-code">
const characters = [
  { name: "Fred", plays: "bowling" },
  { name: "Barney", plays: "chess" },
  { name: "Wilma", plays: "bridge" },
  { name: "Betty", plays: "checkers" },
  { name: "Pebbles", plays: "chess" },
];
const list = characters
  .filter(
    (x) =&gt; x.plays === "chess" || x.plays == "checkers"
  )
  .map((x) =&gt; `&lt;li&gt;${x.name}&lt;/li&gt;`)
  .reduce((a, x) =&gt; [a[0] + x], [""])
  .map((x) =&gt; `&lt;div&gt;&lt;ul&gt;${x}&lt;/ul&gt;&lt;/div&gt;`)
  .reduce((a, x) =&gt; x);
console.log(list);
/* Output is a single line; here output is wrapped
<strong class="bold">&lt;div&gt;&lt;ul&gt;&lt;li&gt;Barney&lt;/li&gt;&lt;li&gt;Betty&lt;/li&gt;&lt;li&gt;Pebbles&lt;/li&gt;</strong>
<strong class="bold">&lt;/ul&gt;&lt;/div&gt;</strong>
*/</pre>
			<p>Accessing the array and index arguments for the <code>map()</code> or <code>reduce()</code> callbacks would also provide solutions:</p>
			<pre class="source-code">
const list2 = characters
  .filter(
    (x) =&gt; x.plays === "chess" || x.plays == "checkers"
  )
  .map(
    (x, i, t) =&gt;
      `${i === 0 ? "&lt;div&gt;&lt;ul&gt;" : ""}` +
      `&lt;li&gt;${x.name}&lt;/li&gt;` +
      `${i == t.length - 1 ? "&lt;/ul&gt;&lt;/div&gt;" : ""}`
  )
  .reduce((a, x) =&gt; a + x, "");
// exact same result</pre>
			<p>We could also do the following:</p>
			<pre class="source-code">
const list3 = characters
  .filter(
    (x) =&gt; x.plays === "chess" || x.plays == "checkers"
  )
  .map((x) =&gt; `&lt;li&gt;${x.name}&lt;/li&gt;`)
  .reduce(
    (a, x, i, t) =&gt;
      a + x + (i === t.length - 1 ? "&lt;/ul&gt;&lt;/div&gt;" : ""),
    "&lt;div&gt;&lt;ul&gt;"
  );
// again, the same result</pre>
			<p>Study the three examples: they will help you gain insight into these higher-order functions and provide you with ideas so that you can do independent work.</p>
			<p>5.2 <code>map()</code> method and the new <code>myMap()</code> function, but instead of using <code>JSON.stringify()</code>, use Jest’s <code>toEqual()</code> method to compare the results. See the answer to <em class="italic">Question 5.5</em> for more.</p>
			<p>5.3 <code>sum()</code> function so TypeScript won’t object. Overloading isn’t available for arrow functions, so we have to change how we define <code>sum()</code>:</p>
			<pre class="source-code">
function sum(x: number, y: number): number;
function sum(x: string, y: string): string;
function sum(x: any, y: any): string | number {
  return x + y;
}</pre>
			<p>Now <code>reverseString2()</code> works and summing an array of numbers also works:</p>
			<pre class="source-code">
const reverseString2 = (str: string): string =&gt;
  str.split("").reduceRight(<strong class="bold">sum</strong>, "");
console.log(reverseString2("MONTEVIDEO"));
// OEDIVETNOM
const myArray = [22, 9, 60, 12, 4, 56];
console.log(myArray.reduce(<strong class="bold">sum</strong>, 0));
// 163</pre>
			<p>If you try to do something as <code>sum(22,"X")</code> or <code>sum(false,{a:1})</code>, TypeScript will reject it because it won’t match the defined overloads:</p>
			<pre class="source-code">
describe("myMap", () =&gt; {
  const myArray = [22, 9, 60, 12, 4, 56];
  it("duplicates values", () =&gt; {
    const dup = (x: number): number =&gt; 2 * x;
    <strong class="bold">expect(myArray.map(dup)).toEqual(myMap(myArray, dup))</strong>;
  });
  it("add dashes", () =&gt; {
    const addDashes = (x: number): string =&gt; `-${x}-`;
<strong class="bold">    expect(myArray.map(addDashes)).toEqual(</strong>
<strong class="bold">      myMap(myArray, addDashes)</strong>
<strong class="bold">    );</strong>
  });
});</pre>
			<p>5.4 <strong class="bold">Reversed reverse?</strong> In this case, it would return the same input string as the output; check it out!</p>
			<p>5.5 <code>1</code> for the former and <code>-1</code> for the latter. We used <code>Math.sign()</code> for this:</p>
			<pre class="source-code">
const range2 = (
  from: number,
  to: number,
  step = Math.sign(to - from)
): number[] =&gt; {
  const arr = [];
  do {
    arr.push(from);
    from += step;
  } while (
    (step &gt; 0 &amp;&amp; to &gt; from) ||
    (step &lt; 0 &amp;&amp; to &lt; from)
  );
  return arr;
};</pre>
			<p>A different implementation starts by calculating how big an array is needed and then filling it using <code>fill()</code> and <code>map()</code>. We must be careful if <code>start</code> and <code>stop</code> are equal to avoid a division by zero:</p>
			<pre class="source-code">
const range2b = (
  start: number,
  stop: number,
  step: number = Math.sign(stop - start)
): number[] =&gt;
  new Array(
    step === 0 ? 1 : Math.ceil((stop - start) / step)
  )
    .fill(0)
    .map((v, i) =&gt; start + i * step);</pre>
			<p>A few examples of calculated ranges show the diversity in terms of the options we have:</p>
			<pre class="source-code">
range2(1, 10);        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
range2(1, 10, 2);     // [1, 3, 5, 7, 9]
range2(1, 10, 3);     // [1, 4, 7]
range2(1, 10, 6);     // [1, 7]
range2(1, 10, 11);    // [1]
range2(21, 10);       // [21, 20, 19, ... 13, 12, 11]
range2(21, 10, -3);   // [21, 18, 15, 12]
range2(21, 10, -4);   // [21, 17, 13]
range2(21, 10, -7);   // [21, 14]
range2(21, 10, -12);  // [21]</pre>
			<p>Writing Jest tests is straightforward; the following code shows just three cases of the preceding code:</p>
			<pre class="source-code">
describe("range2()", () =&gt; {
  it("works from 1 to 10", () =&gt;
    expect(range2(1, 10)).toEqual([
      1, 2, 3, 4, 5, 6, 7, 8, 9,
    ]));
  it("works from 1 to 10 by 2", () =&gt;
    expect(range2(1, 10, 2)).toEqual([1, 3, 5, 7, 9]));
  it("works from 21 down to 10 by -4", () =&gt;
    expect(range2(21, 10, -4)).toEqual([21, 17, 13]));
});</pre>
			<p>Using this new <code>range2()</code> function means you can write a greater variety of loops in a functional way, with no need for <code>for(...)</code> statements.</p>
			<p>5.6 <code>from</code>) and then updates it (by summing the <code>step</code> value) until the resulting value is outside the range:</p>
			<pre class="source-code">
function* range4(
  from: number,
  to: number,
  step: number = Math.sign(to - from)
): Generator&lt;number&gt; {
  do {
<strong class="bold">    yield from;</strong>
<strong class="bold">    from += step;</strong>
  } while (
<strong class="bold">    (step &gt; 0 &amp;&amp; to &gt;= from) ||</strong>
<strong class="bold">    (step &lt; 0 &amp;&amp; to &lt;= from)</strong>
  );
}</pre>
			<p>We can write tests for this function in several different ways: manually calling the generator several times, using the spread operator to get all the values at once, or using the <code>for..of</code> construct:</p>
			<pre class="source-code">
describe("range4", () =&gt; {
  it("generates 2..5", () =&gt; {
    const range = range4(2, 5);
<strong class="bold">    expect(range.next().value).toBe(2);</strong>
<strong class="bold">    expect(range.next().value).toBe(3);</strong>
<strong class="bold">    expect(range.next().value).toBe(4);</strong>
<strong class="bold">    expect(range.next().value).toBe(5);</strong>
<strong class="bold">    expect(range.next().value).toBe(undefined);</strong>
  });
  it("generates 5..2", () =&gt; {
    const range = range4(5, 2);
    <strong class="bold">expect([...range]).toEqual([5, 4, 3, 2]);</strong>
  });
  it("generates 1..10 by 2", () =&gt; {
    const numbers = [];
    for (<strong class="bold">const i of range4(1, 10, 2)</strong>) {
      numbers.push(i);
    }
    expect(numbers).toEqual([1, 3, 5, 7, 9]);
  });
});</pre>
			<p>5.7 <code>String.fromCharCode()</code> is not unary; it may receive any number of arguments. When you write <code>map(String.fromCharCode)</code>, the callback gets called with three parameters (the current value, the index, and the array) and that causes unexpected results. Using <code>unary()</code> from the <em class="italic">Arity changing</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, Producing Functions,</em> would also work. To find out more, go to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode</a>.</p>
			<p>5.8 <strong class="bold">Producing a CSV</strong>: A first solution, along with some auxiliary functions, is as follows; can you understand what each function does?</p>
			<pre class="source-code">
const myData = [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12],
];
const concatNumbers = (a: string, b: number): string =&gt;
  !a ? `${b}` : `${a},${b}`;
const concatLines = (c: string, d: string): string =&gt;
  c + "\n" + d;
const makeCSV = (data: number[][]) =&gt;
  data
<strong class="bold">    .map((x) =&gt; x.reduce(concatNumbers, ""))</strong>
<strong class="bold">    .reduce(concatLines, "");</strong>
console.log(makeCSV(myData));
/*
1,2,3,4
5,6,7,8
9,10,11,12
*/</pre>
			<p>An alternative one-liner is possible, but not as clear – do you agree?</p>
			<pre class="source-code">
const makeCSV2 = (data: number[][]) =&gt;
  data
    .map((x: number[]) =&gt;
      x.reduce(
        (a: string, b: number): string =&gt;
          !a ? `${b}` : `${a},${b}`,
        ""
      )
    )
    .reduce((c: string, d: string) =&gt; c + "\n" + d, "");</pre>
			<p>5.9 <code>flat1()</code> and <code>flat2()</code> depend on <code>flatOne()</code>. If that function (in any of its two provided implementations) finds an empty array position, it doesn’t <code>concat()</code> anything to its output.</p>
			<p>5.10 <strong class="bold">Producing better output</strong>: For this, you’ll have to do some extra mapping, as follows:</p>
			<pre class="source-code">
const better = apiAnswer
  .flatMap((c) =&gt;
    c.states.map((s) =&gt; ({ ...s, country: c.name }))
  )
  .flatMap((s) =&gt;
    s.cities.map((t) =&gt; ({
      ...t,
      state: s.name,
      country: s.country,
    }))
  )
  .map((t) =&gt; `${t.name}, ${t.state}, ${t.country}`);
console.log(better);
/*
[
  'Lincoln, Buenos Aires, Argentine',
  'Lincoln, England, Great Britain',
  'Lincoln, California, United States of America',
  'Lincoln, Rhode Island, United States of America',
  'Lincolnia, Virginia, United States of America',
  'Lincoln Park, Michigan, United States of America',
  'Lincoln, Nebraska, United States of America',
  'Lincoln Park, Illinois, United States of America',
  'Lincoln Square, Illinois, United States of America'
]
*/</pre>
			<p>5.11 <code>join()</code> to build a single long string out of the individual sentences, using <code>split()</code> to separate that string into words, and finally, looking at the length of the resulting array:</p>
			<pre class="source-code">
const words = gettysburg.join(" ").split(" ").length; // 270</pre>
			<p>5.12 <code>Boolean(x)</code> is the same as <code>!!x</code>, turning an expression from <code>truthy</code> or <code>falsy</code> into <code>true</code> or <code>false</code>, respectively. Thus, the <code>filter()</code> operation removes all <code>falsy</code> elements from the array.</p>
			<p>5.13 <code>fact4(0)</code> returns <code>1</code> as expected. The <code>range(1,1)</code> call produces an empty array, so the original value of <code>result</code> (<code>1</code>) is returned without further change.</p>
			<p>5.14 <code>forEach()</code>, <code>map()</code>, and so on, and also develops a class for <code>async</code> arrays that allows chaining.</p>
			<p>5.15 <code>mapAsync()</code> to get the async values and apply the original function to the returned array. An example for <code>some()</code> would be as follows:</p>
			<pre class="source-code">
const someAsync = &lt;T&gt;(
  arr: T[],
  fn: (x: T) =&gt; Promise&lt;boolean&gt;
) =&gt;
  <strong class="bold">mapAsync(arr, fn).then((mapped) =&gt; mapped.some(Boolean))</strong>;</pre>
			<p>We can write tests for this in two different fashions: awaiting the result of a call, or using Jest’s <code>.resolves</code> for shorter code:</p>
			<pre class="source-code">
describe("someAsync", () =&gt; {
  it("succeeds if sometimes OK", async () =&gt; {
    const someEven = <strong class="bold">await someAsync</strong>(
      [1, 2, 3, 4],
      fakeFilter
    );
    <strong class="bold">expect(someEven).toBeTruthy()</strong>;
  });
  it("fails if never OK", () =&gt; {
    expect(
      someAsync([1, 3, 5, 7, 9], fakeFilter)
    )<strong class="bold">.resolves.toBeFalsy()</strong>;
  });
});</pre>
			<p>5.16 <code>workerCall()</code> or when we reset a worker to be not in use. Let’s go with the second solution, to make the call as fast as possible. We will add a <code>MAX_NOT_IN_USE</code> constant with the threshold of number of workers not in use and a <code>notInUse()</code> predicate as a refactor:</p>
			<pre class="source-code">
const notInUse = (p: PoolEntry): boolean =&gt; !p.inUse;
const MAX_NOT_IN_USE = 10;</pre>
			<p>Then, we’ll change the last part of the <code>workerCall()</code> function as follows:</p>
			<pre class="source-code">
  return new Promise((resolve) =&gt; {
    available!.inUse = true;
    available!.worker.on("message", (x) =&gt; {
      resolve(x);
      available!.inUse = false;
<strong class="bold">      while (</strong>
<strong class="bold">        pool.filter(notInUse).length &gt; MAX_NOT_IN_USE</strong>
<strong class="bold">      ) {</strong>
<strong class="bold">        const notUsed = pool.findIndex(notInUse);</strong>
<strong class="bold">        pool[notUsed].worker.terminate();</strong>
<strong class="bold">        pool.splice(notUsed, 1);</strong>
<strong class="bold">      }</strong>
    });
    available!.worker.postMessage(value);
  });</pre>
			<p>While the count of workers not in use is higher than our limit, we find one worker to remove, <code>terminate()</code> it, and remove it from the pool of workers.</p>
			<p>5.17 <strong class="bold">Queueing for the pool</strong>: This question has an interesting way of handling a promise to act as a barrier, initially denying but eventually allowing procedures to go through. The idea is to check that there are not too many running workers before adding a worker to the pool. If so, proceed as before, but if not, add something to the queue (we’ll see what), so we can run the worker later. Whenever a worker responds, we’ll check whether there’s anything in the queue to allow it to run.</p>
			<p>We’ll first add three things:</p>
			<pre class="source-code">
const queue: ((v?: any) =&gt; void)[] = [];
let running = 0;
const MAX_TO_USE = 5;</pre>
			<p>The way we’ll handle waiting is by creating a promise, which we’ll eventually resolve at a later time. That explains the weird <code>queue</code> data type, which contains resolving functions. The <code>running</code> variable will count how many workers are running, and <code>MAX_TO_USE</code> is the maximum possible value for <code>running</code>.</p>
			<p>To work with the queue, we’ll have two functions:</p>
			<pre class="source-code">
const enqueue = (resolve2: (v?: any) =&gt; void) =&gt; {
  if (running &lt; MAX_TO_USE) {
    running++;
    resolve2();
  } else {
    queue.push(resolve2);
  }
};
const dequeue = () =&gt; {
  const resolve2 = queue.shift();
  resolve2 &amp;&amp; resolve2();
};</pre>
			<p>The <code>enqueue()</code> function checks how many workers are running; if there are less than <code>MAX_TO_USE</code>, it increments <code>running</code> (because a worker will run) and then calls <code>resolve2()</code> to allow the corresponding request to go forward. If there are too many running workers, the function to call is instead pushed into the queue. The <code>dequeue()</code> function just tries to get the front element from the queue, and if there’s something, it calls the dequeued value to allow a queued request to proceed.</p>
			<p>The modified <code>workerCall()</code> function is now as follows:</p>
			<pre class="source-code">
export const workerCall = (
  filename: string,
  value: any
): Promise&lt;any&gt; =&gt; {
  return new Promise((resolve) =&gt; {
 <strong class="bold">   new Promise((resolve2) =&gt; enqueue(resolve2)).then(</strong>
      () =&gt; {
        let available = pool
          .filter(notInUse)
          .find((x) =&gt; x.filename === filename);
        if (available === undefined) {
          available = {
            worker: new Worker(filename),
            filename,
            value,
            inUse: true,
          } as PoolEntry;
          pool.push(available);
        }
        available!.inUse = true;
        available!.worker.on("message", (x) =&gt; {
          resolve(x);
          available!.inUse = false;
<strong class="bold">          dequeue();</strong>
        });
        available!.worker.postMessage(value);
      }
    );
  });
};</pre>
			<p>The <code>new Promise((resolve2) =&gt; …)</code> line is the barrier we mentioned; it will allow work to go on (at <code>then()</code>) only when its <code>resolve2()</code> function is called – which will be done either by <code>enqueue()</code> (if there were few running workers) or <code>dequeue()</code> (when some previously running worker ends).</p>
			<p>5.18 <strong class="bold">Showing results</strong>: Basically, given a string, it returns a logging function that expects a single parameter and lists both the string and the argument. We’ll see other ways of achieving similar results in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>.</p>
			<p>5.19 <code>filter()</code> goes through all the workers, and then <code>find()</code> goes through the filtered ones. This could be achieved in a single pass as follows:</p>
			<pre class="source-code">
  let available = pool
    .find(<strong class="bold">(v) =&gt; !v.inUse &amp;&amp; v.filename === filename</strong>);</pre>
			<p>5.20 <code>"error"</code> event, which fires if an error occurs in the worker. In this case, the worker should be marked as not in use (because it has ended its job) and the promise should be rejected. The final part of the <code>workerCall()</code> function should look something like this:</p>
			<pre class="source-code">
  return new Promise((resolve, reject) =&gt; {
    available!.inUse = true;
    available!.worker.on("message", (x) =&gt; {
      resolve(x);
      available!.inUse = false;
    });
<strong class="bold">    available!.worker.on("error", (x) =&gt; {</strong>
<strong class="bold">      reject(x);</strong>
<strong class="bold">      available!.inUse = false;</strong>
<strong class="bold">    });</strong>
    available!.worker.postMessage(value);
  });</pre>
			<p>For an “industrial-strength” level library, you should deal with all possible events; check developer.mozilla.org/en-US/docs/Web/API/Worker#events and nodejs.org/api/worker_threads.html#class-worker for more on this.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor241"/>Chapter 6, Producing Functions – Higher-Order Functions</h1>
			<p>6.1 <strong class="bold">Go with arrows</strong>: Just minor changes are needed:</p>
			<pre class="source-code">
const addLogging <strong class="bold">= &lt;T extends (...args: any[]) =&gt; any&gt;</strong>(
  fn: T
): <strong class="bold">((...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; </strong>{
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    console.log(`entering ${fn.name}(${args})`);
    const valueToReturn = fn(...args);
    console.log(`exiting  ${fn.name}=&gt;${valueToReturn}`);
    return valueToReturn;
  };
};</pre>
			<p>6.2 <code>memoize4()</code>. Instead of using an object for <code>cache</code>, we create a map. We check whether the map has the searched <code>strX</code> key, we set new values after calling the original function, and we get the return value from the cache. The <code>as</code> part in <code>return</code> is to let TypeScript know that <code>get()</code> will succeed because the search won’t fail:</p>
			<pre class="source-code">
const memoize4 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  <strong class="bold">const cache = new Map() as Map&lt;string, ReturnType&lt;T&gt;&gt;;</strong>
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    <strong class="bold">if (!cache.has(strX)) {</strong>
<strong class="bold">      cache.set(strX, fn(...args));</strong>
<strong class="bold">    }</strong>
<strong class="bold">    return cache.get(strX) as ReturnType&lt;T&gt;;</strong>
  };
};</pre>
			<p>6.3 <code>calc(n)</code> the number of calls needed to evaluate <code>fib(n)</code>. Analyzing the tree that shows all the needed calculations, we get the following:</p>
			<ul>
				<li>calc(0)=1</li>
				<li>calc(1)=1</li>
				<li>For <em class="italic">n</em>&gt;1, calc(<em class="italic">n</em>)=1 + calc(<em class="italic">n</em>-1) + calc(<em class="italic">n</em>-2)</li>
			</ul>
			<p>The last line follows from the fact that when we call <code>fib(n)</code>, we have one call, plus calls to <code>fib(n-1)</code>
and <code>fib(n-2)</code>. A spreadsheet shows that <code>calc(50)</code> is 40,730,022,147 – rather high!</p>
			<p>If you care for some algebra, it can be shown that calc(<em class="italic">n</em>)=5fib(<em class="italic">n</em>-1)+fib(<em class="italic">n</em>-4)-1, or that as <em class="italic">n</em> grows, calc(<em class="italic">n</em>) becomes approximately (1+√5)=3.236 times the value of fib(<em class="italic">n</em>) – but since this is not a math book, I won’t even mention those results!</p>
			<p>6.4 <code>shuffle()</code> function from <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>,<em class="italic"> Behaving Properly</em>, we can write the following code. We remove the first function from the list before shuffling the rest, and we add it back at the end of the array to avoid repeating any calls:</p>
			<pre class="source-code">
const randomizer =
  &lt;T extends (...x: any[]) =&gt; any&gt;(...fns: T[]) =&gt;
  (
    ...args: Parameters&lt;T&gt;
  ): ((...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
<strong class="bold">    const first: T = fns.shift() as T;</strong>
<strong class="bold">    fns = shuffle(fns);</strong>
<strong class="bold">    fns.push(first);</strong>
<strong class="bold">    return fns[0](...args);</strong>
  };</pre>
			<p>We need to add <code>as T</code> when assigning a value to <code>first</code>; otherwise, TypeScript will object because <code>fns.shift()</code> returns <code>undefined</code> if <code>fns</code> is empty. It wouldn’t be a bad idea to check that <code>fns</code> is not empty; can you add it?</p>
			<p>A quick verification shows it fulfills all our requirements:</p>
			<pre class="source-code">
const say1 = () =&gt; console.log(1);
const say22 = () =&gt; console.log(22);
const say333 = () =&gt; console.log(333);
const say4444 = () =&gt; console.log(4444);
const rrr = randomizer(say1, say22, say333, say4444);
rrr(); // 333
rrr(); // 4444
rrr(); // 333
rrr(); // 22
rrr(); // 333
rrr(); // 22
rrr(); // 333
rrr(); // 4444
rrr(); // 1
rrr(); // 4444</pre>
			<p>A minor consideration: the first function in the list can never be called the first time around because of the way <code>randomizer()</code> is written. Can you provide a better version that won’t have this slight defect so that all the functions in the list have the same chance of being called the first time?</p>
			<p>6.5 <strong class="bold">Not in TypeScript</strong>: The following code does the job. The only difference between the functions is that one works with Boolean-returning functions and the other with number-returning ones:</p>
			<pre class="source-code">
const not =
  <strong class="bold">&lt;T extends (...args: any[]) =&gt; boolean&gt;(fn: T)</strong> =&gt;
  <strong class="bold">(...args: Parameters&lt;T&gt;): boolean</strong> =&gt;
    !fn(...args);
const invert =
<strong class="bold">  &lt;T extends (...args: any[]) =&gt; number&gt;(fn: T) =&gt;</strong>
<strong class="bold">  (...args: Parameters&lt;T&gt;): number =&gt;</strong>
    -fn(...args);</pre>
			<p>6.6 <code>typeof</code> to check whether the returned value is numeric or Boolean before deciding what to return. We must declare that the input function is either a Boolean-returning or a number-returning function:</p>
			<pre class="source-code">
const opposite =
  &lt;T extends (...args: any[]) =&gt; number | boolean&gt;(fn: T)
    =&gt;
  (…args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    const result = fn(...args);</strong>
<strong class="bold">    return (</strong>
<strong class="bold">      typeof result === "boolean" ? !result : -result</strong>
    ) as any;
  };</pre>
			<p>6.7 <strong class="bold">Invert tests</strong>: We can quickly transform the example shown in the text into a real test; we’ll leave it up to you to write more tests:</p>
			<pre class="source-code">
import { invert } from "../invert";
describe("invert", () =&gt; {
  it("can be used to sort Spanish words", () =&gt; {
    const spanishComparison = (
      a: string,
      b: string
    ): number =&gt; a.localeCompare(b, "es");
    const palabras = [
   "  "ñandú",
   "  "oasis",
   "  "mano",
   "  "natural",
   "  "mítico",
   "  "musical",
    ];
    expect(
 <strong class="bold">     palabras.sort(invert(spanishComparison))</strong>
    ).toEqual([
   "  "oasis",
   "  "ñandú",
   "  "natural",
   "  "musical",
   "  "mítico",
   "  "mano",
    ]);
  });
});</pre>
			<p>6.8 <code>filter()</code> expects to receive a function with three parameters (the <code>A</code>, <code>number</code>, and <code>A[]</code> types), and the type of <code>not(fn)</code> doesn’t match that.</p>
			<p>6.9 <code>eval()</code> – which, in general, isn’t such a good idea! If you persist and insist, though, we can write a <code>function.length</code> preserving version of <code>arity()</code> as follows; let’scall it <code>arityL()</code>:</p>
			<pre class="source-code">
import { range } from "../../chapter 05/range";
function arityL&lt;T extends (...args: any[]) =&gt; any&gt;(
  n: number,
  fn: T
): (...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  const args1n = range(0, n)
    .map((i) =&gt; `x${i}`)
    .join(",");
  return <strong class="bold">eval(`(${args1n}) =&gt; ${fn.name}(${args1n})`)</strong>;
}</pre>
			<p>If you were to apply <code>arityL()</code> to <code>Number.parseInt</code>, the results would be as follows. The produced functions have the right <code>length</code> property, and their actual implementation is given in the comments:</p>
			<pre class="source-code">
const parseInt1 = arityL(parseInt, 1);
// <strong class="bold">(x0) =&gt; parseInt(x0,x1)</strong> parseInt1.length === 1
const parseInt2 = arity(Number.parseInt,2)
// <strong class="bold">(x0,x1) =&gt; parseInt(x0,x1)</strong> parseInt2.length === 2</pre>
			<p>Do note, however, that TypeScript cannot determine the type of the resulting functions because that will be known at runtime.</p>
			<p>6.10 <strong class="bold">Many arities!</strong> If we were working just with JavaScript, the following would do:</p>
			<pre class="source-code">
const binary = (fn) =&gt; (...a) =&gt; fn(a[0], a[1]);
const ternary = (fn) =&gt; (...a) =&gt; fn(a[0], a[1], a[2]);</pre>
			<p>Adding data types, we get the following:</p>
			<pre class="source-code">
const binary =
  &lt;T extends (...x: any[]) =&gt; any&gt;(
    fn: T
  ): ((
    arg0: Parameters&lt;T&gt;[0],
    arg1: Parameters&lt;T&gt;[1]
  ) =&gt; ReturnType&lt;T&gt;) =&gt;
  (x, y) =&gt;
    fn(x, y);
const ternary =
  &lt;T extends (...x: any[]) =&gt; any&gt;(
    fn: T
  ): ((
    arg0: Parameters&lt;T&gt;[0],
    arg1: Parameters&lt;T&gt;[1],
    arg2: Parameters&lt;T&gt;[2]
  ) =&gt; ReturnType&lt;T&gt;) =&gt;
  (x, y, z) =&gt;
    fn(x, y, z);</pre>
			<p>6.11 <strong class="bold">Throttling promises</strong>: Every time we actually do a call, we’ll set up a timer that will, in time, remove the promise from the cache. By default, let’s have a delay of 5 minutes. We’ll have a pool of timers, one per promise. In case of an error when calling the API, we’ll remove both the rejected promise and its corresponding timer:</p>
			<pre class="source-code">
const promiseThrottle = &lt;
  A,
  T extends (...x: any[]) =&gt; Promise&lt;A&gt;
&gt;(
  fn: T,
<strong class="bold">  delay = 300_000  /* 5 minutes */</strong>
): ((...x: Parameters&lt;T&gt;) =&gt; Promise&lt;A&gt;) =&gt; {
  const cache = {} as Record&lt;string, Promise&lt;A&gt;&gt;;
<strong class="bold">  const timers = {} as Record&lt;</strong>
<strong class="bold">    string,</strong>
<strong class="bold">    ReturnType&lt;typeof setTimeout&gt;</strong>
<strong class="bold">  &gt;;</strong>
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    if (!(strX in timers)) {
      <strong class="bold">timers[strX] = setTimeout(() =&gt; {</strong>
<strong class="bold">        delete cache[strX];</strong>
<strong class="bold">        delete timers[strX];</strong>
<strong class="bold">      }, delay);</strong>
<strong class="bold">    }</strong>
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args).catch((x) =&gt; {
          delete cache[strX];
      <strong class="bold">    delete timers[strX];</strong>
          return x;
        }));
  };
};</pre>
			<p>6.12 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, and <code>%</code>), all bitwise operators (<code>&amp;</code>, <code>|</code>, and <code>^</code>), all logical operators (<code>&amp;&amp;</code> and <code>||</code>), all shift operators (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>), all comparisons (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>===</code>, <code>!=</code>, and <code>!==</code>), and the new nullish coalescing operator (<code>??</code>). The comma operator could be included as well. Check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators</a> for more on this topic.</p>
			<p>6.13 <strong class="bold">Missing companion</strong>: A simple one-line version could be as follows. Here, we use spreading to get a shallow copy of the original object and then set the specified attribute to its new value by using a computed property name. See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer</a> for more details:</p>
			<pre class="source-code">
const setField = &lt;D&gt;(
  attr: keyof D,
  value: any,
  obj: D
) =&gt; ({
  ...obj,
  [attr]: value,
});</pre>
			<p>In <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, we wrote <code>deepCopy()</code>, which would be better than spreading when it comes to creating a totally new object instead of a shallow copy. By using this, we would have the following:</p>
			<pre class="source-code">
const setField2 = &lt;D&gt;(
  attr: keyof D,
  value: any,
  obj: D
) =&gt; (<strong class="bold">{</strong>
<strong class="bold">  ...deepCopy(obj),</strong>
<strong class="bold">  [attr]: value,</strong>
<strong class="bold">}</strong>);</pre>
			<p>Finally, you could also look into modifying the <code>updateObject()</code> function, also from <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, by removing the freezing code; I’ll leave it up to you.</p>
			<p>6.14 <code>null</code> object would throw an error:</p>
			<pre class="source-code">
const getField = attr =&gt; obj =&gt; obj[attr];
getField("someField")(null);
// <strong class="bold">Uncaught TypeError: Cannot read property 'a' of null</strong></pre>
			<p>With TypeScript, the code won’t compile because first, <code>"someField"</code> isn’t the name of an attribute, and second, <code>null</code> is not a valid object:</p>
			<pre class="source-code">
const getField =
  &lt;D&gt;(f: keyof D) =&gt;
  (obj: D) =&gt;
    obj[f];</pre>
			<p>However, it’s still possible to do things “behind TypeScript’s back” and get the code accepted and the exception thrown. Having functions throw exceptions is not usually good in FP. You may opt to produce <code>undefined</code> instead, or work with monads, just like in <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>. A safer version of <code>getField()</code> would add a safeguard and return <code>obj &amp;&amp; </code><code>obj[f]</code> instead.</p>
			<p>6.15 <strong class="bold">Typed demethodizing</strong>: The three full definitions are as follows:</p>
			<pre class="source-code">
const demethodize1 =
  &lt;T extends (arg0: any, ...args: any[]) =&gt; any&gt;(fn: T) =&gt;
  (arg0: any, ...args: Parameters&lt;T&gt;) =&gt;
    fn.apply(arg0, args);
const demethodize2 =
  &lt;T extends (arg0: any, ...args: any[]) =&gt; any&gt;(fn: T) =&gt;
  (arg0: any, ...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt;
    fn.call(arg0, ...args);
const demethodize3 =
  &lt;T extends (arg0: any, ...args: any[]) =&gt; any&gt;(fn: T) =&gt;
  (arg0: any, ...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt;
    fn.bind(arg0, ...args)();</pre>
			<p>6.16 <code>Math.max()</code> and <code>Math.min()</code> as follows:</p>
			<pre class="source-code">
const findMaximum2 = findOptimum2((x, y) =&gt; <strong class="bold">Math.max(x,</strong>
<strong class="bold">  y)</strong>);
const findMinimum2 = findOptimum2((x, y) =&gt; <strong class="bold">Math.min(x,</strong>
<strong class="bold">  y)</strong>);</pre>
			<p>Another way of writing this could be achieved by defining the following first:</p>
			<pre class="source-code">
const max = (...arr: number[]): number =&gt; Math.max(...arr);
const min = (...arr: number[]): number =&gt; Math.min(...arr);</pre>
			<p>Then, we could write in a pointfree style:</p>
			<pre class="source-code">
const findMaximum3 = findOptimum2(max);
const findMinimum3 = findOptimum2(min);</pre>
			<p>6.17 <strong class="bold">Comparing heroes</strong>: The first suggested change wouldn’t allow for ties in some features, where no hero beats the other. And, in fact, this points out a problem in our logic; if the first hero doesn’t beat the second one, we assume that the latter beat the former, not allowing for ties between heroes.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor242"/>Chapter 7, Transforming Functions – Currying and Partial Application</h1>
			<p>7.1 <code>sum(3)</code> returns a function with <code>3</code> already bound; <code>sum(3)()</code> returns the same, and <code>sum(3)()(5)</code> produces the result.</p>
			<p>7.2 <code>sumMany()</code> function does the job:</p>
			<pre class="source-code">
const sumMany = <strong class="bold">(total: number) =&gt; (value?: number) =&gt;</strong>
<strong class="bold">  value === undefined ? total : sumMany(total + value);</strong>
sumMany(2)(2)(9)(6)(0)(-3)(); // 16</pre>
			<p>In JavaScript, the function poses no problem; with TypeScript, we’ll get an objection because it cannot determine that <code>sumMany(2)</code> is a function, not a number.</p>
			<p>A small detail: can you fix the function so <code>sumMany()</code> will return <code>0</code>?</p>
			<p>7.3 <strong class="bold">Curry with eval?</strong> Let’s see this in JavaScript first:</p>
			<pre class="source-code">
// curryByEval.js
function curryByEval(fn) {
  return eval(`${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join("=&gt;")} =&gt; ${fn.name}(${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join(",")})`);
}</pre>
			<p>This is quite a chunk of code to digest, and, in fact, it should instead be coded in several separate lines to make it more understandable. Let’s see how this works when applied to the <code>make3()</code> function as input:</p>
			<ol>
				<li value="1">The <code>range()</code> function produces an array with the <code>[</code><code>0,1,2]</code> values.</li>
				<li>We use <code>map()</code> to generate a new array with the <code>["</code><code>x0","x1","x2"]</code> values.</li>
				<li>We use <code>join()</code>on the values in that array to produce <code>x0=&gt;x1=&gt;x2</code>, which will be the beginning of the code that we will evaluate.</li>
				<li>We then add an arrow, the function’s name, and an opening parenthesis, to make the middle part of our newly generated code: <code>=&gt; </code><code>make3(</code>.</li>
				<li>We use <code>range()</code>, <code>map()</code>, and <code>join()</code> again, but this time, to generate a list of arguments: <code>x0,x1,x2</code>.</li>
				<li>We finally add a closing parenthesis, and after applying <code>eval()</code>, we get the curried version of <code>make3()</code>.</li>
			</ol>
			<p>After following all these steps, in our case, the resulting function would be as follows:</p>
			<pre class="source-code">
curryByEval(make3); // <strong class="bold">x0=&gt;x1=&gt;x2 =&gt; make3(x0,x1,x2)</strong></pre>
			<p>Typing is essentially the same as for our <code>curry()</code> function since we are getting the same parameter and producing the same output. Note, however, that we’re definitely “lying” to TypeScript because it wouldn’t be able to deduce what <code>eval()</code> was returning; it’s really up to us not to mess up! Without further ado, we can write the following:</p>
			<pre class="source-code">
<strong class="bold">function curryByEval&lt;A extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...args: A) =&gt; R</strong>
<strong class="bold">): Curry&lt;A, R&gt;;</strong>
<strong class="bold">function curryByEval(fn: (...args: any) =&gt; any) </strong>{
  const pp = `${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join("=&gt;")} =&gt; ${fn.name}(${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join(",")})`;
}</pre>
			<p>We see we can do currying by using <code>eval()</code> – but there’s one remaining problem: if the original function didn’t have a name, the transformation wouldn’t work. We can work around the function name problem by including the actual code of the function to be curried:</p>
			<pre class="source-code">
function curryByEval2&lt;A extends any[], R&gt;(
  fn: (...args: A) =&gt; R
): Curry&lt;A, R&gt;;
function curryByEval2(fn: (...args: any) =&gt; any) {
  return eval(`${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join("=&gt;")} =&gt;
<strong class="bold">    (${fn.toString()})</strong>
<strong class="bold">    (${range(0, fn.length)</strong>
<strong class="bold">      .map((i) =&gt; `x${i}`)</strong>
<strong class="bold">      .join(",")})`)</strong>;
}</pre>
			<p>The only change is that instead of including the original function name, we substitute its actual code:</p>
			<pre class="source-code">
curryByEval2(make3);
// x0=&gt;x1=&gt;x2=&gt; <strong class="bold">((a, b, c) =&gt; `${a}:${b}:${c}`)</strong>(x0,x1,x2)</pre>
			<p>7.4 <strong class="bold">Uncurrying the curried</strong>: We can work similarly to what we did in the previous question:</p>
			<pre class="source-code">
const uncurry = (fn, len) =&gt;
  eval(
    `(${range(0, len)
      .map((i) =&gt; `x${i}`)
      .join(",")}) =&gt; ${fn.name}${range(0, len)
      .map((i) =&gt; `(x${i})`)
      .join("")}`
  );</pre>
			<p>Earlier, when currying, given an <code>fn()</code> function with an arity of <code>3</code>, we would have generated the following:</p>
			<pre class="source-code">
x0=&gt;x1=&gt;x2=&gt; make3(x0,x1,x2)</pre>
			<p>Now, to uncurry a function (say, <code>curriedFn()</code>), we want to do something very similar: the only difference is the placement of the parentheses:</p>
			<pre class="source-code">
(x0,x1,x2) =&gt; curriedFn(x0)(x1)(x2)</pre>
			<p>The expected behavior is as follows – and let’s use the last result from the previous question:</p>
			<pre class="source-code">
const curriedMake3 = (x0) =&gt; (x1) =&gt; (x2) =&gt;
  ((a, b, c) =&gt; `${a}:${b}:${c}`)(x0, x1, x2);
console.log(uncurry(curriedMake3, 3).toString());
// <strong class="bold">(x0,x1,x2) =&gt; curriedMake3(x0)(x1)(x2)</strong></pre>
			<p>If you want to consider a case in which the function to “uncurry” has no name, you can apply the same change we did in the previous question and include <code>fn.toString()</code> in the output.</p>
			<p>7.5 <strong class="bold">Let me count the ways</strong>: If the function has <em class="italic">n</em> parameters, there are 2n-1 ways of calling it. This means that our three-parameter function could be called in 22=4 ways (correct!), a function with two parameters would allow 21=2 ways, and a function with just one parameter would allow only 20=1 way.</p>
			<p>7.6 <code>curry()</code> version so that it uses this:</p>
			<pre class="source-code">
Function.prototype.curry = function () {
  return this.length === 0
    ? this()
    : (p) =&gt; this.bind(this, p).curry();
};</pre>
			<p>7.7 <strong class="bold">Shorter typing</strong>: The suggested earlier test shortens the code. We are essentially saying “<em class="italic">if there’s at least one argument, return a curried function; otherwise, return </em><em class="italic">a value</em>”:</p>
			<pre class="source-code">
type Curry2&lt;P, R&gt; = P extends [infer H, ...infer T]
  ? (arg: H) =&gt; Curry2&lt;[...T], R&gt;
  : R;</pre>
			<p>7.8 <code>P</code> has a single type by checking <code>P["length"]</code> as follows – and to access that single type, we’ll have to write <code>P[0]</code>:</p>
			<pre class="source-code">
type Curry&lt;P extends any[], R&gt; = <strong class="bold">1 extends P["length"]</strong>
  ? (<strong class="bold">arg: P[0]</strong>) =&gt; R // only 1 arg
  : P extends [infer H, ...infer T] // 2 or more args
  ? (arg: H) =&gt; Curry&lt;[...T], R&gt;
  : never;</pre>
			<p>7.9 <code>applyStyle()</code> or by using our <code>curry()</code> function – let’s see both ways:</p>
			<pre class="source-code">
const applyStyle =
  (style: string) =&gt;
  (text: string): string =&gt;
    `&lt;${style}&gt;${text}&lt;/${style}&gt;`;
const makeBold = <strong class="bold">applyStyle("b")</strong>;
console.log(makeBold("Montevideo"));
// <strong class="bold">&lt;b&gt;Montevideo&lt;/b&gt;</strong>
const applyStyle2 = (style: string, text: string): string
  =&gt;
  `&lt;${style}&gt;${text}&lt;/${style}&gt;`;
const makeUnderline = <strong class="bold">curry(applyStyle2)("u")</strong>;
console.log(makeUnderline("Uruguay"));
// <strong class="bold">&lt;u&gt;Uruguay&lt;/u&gt;</strong></pre>
			<p>7.10 <code>what()</code> function is as follows:</p>
			<pre class="source-code">
const partial =
  (fn) =&gt;
  (...params) =&gt;
    fn.length &lt;= params.length
      ? fn(...params)
      : (...otherParams) =&gt;
          partial(fn)(...params, ...otherParams);</pre>
			<p>7.11 <code>this</code>.</p>
			<p>7.12 <code>curryN()</code> function is an alternative version of our <code>partialCurry()</code>. The only difference is that if you provide all the arguments to a function, this new <code>curryN()</code> function directly calls the curried function, while <code>partialCurry()</code> would first bind the function to all its arguments and then recursively call it to return the final result – but the result would be precisely the same.</p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor243"/>Chapter 8, Connecting Functions – Pipelining, Composition, and More</h1>
			<p>8.1 <code>split()</code>, <code>map()</code>, and <code>join()</code>. Using <code>demethodize()</code> from <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, and <code>flipTwo()</code> from <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>, would have also been possible:</p>
			<pre class="source-code">
const split = (str: string) =&gt; (text: string) =&gt;
  text.split(str);
const map =
  (fn: (x: string) =&gt; string) =&gt; (arr: string[]) =&gt;
    arr.map(fn);
const firstToUpper = (word: string): string =&gt;
  word[0].toUpperCase() + word.substring(1).toLowerCase();
const join = (str: string) =&gt; (arr: string[]) =&gt;
  arr.join(str);
const headline = <strong class="bold">pipeline(</strong>
<strong class="bold">  split(" "),</strong>
<strong class="bold">  map(firstToUpper),</strong>
<strong class="bold">  join(" ")</strong>
<strong class="bold">)</strong>;</pre>
			<p>The pipeline works as expected: we split the string into words, we map each word to make its first letter uppercase, and we join the array elements to form a string again. We could have used <code>reduce()</code> for the last step, but <code>join()</code> already does what we need, so why reinvent the wheel?</p>
			<pre class="source-code">
console.log(headline("Alice's ADVENTURES in WoNdErLaNd"));
// Alice's Adventures In Wonderland</pre>
			<p>8.2 <strong class="bold">Pending tasks</strong>: The following pipeline does the job:</p>
			<pre class="source-code">
const getField = attr =&gt; obj =&gt; obj[attr]; const filter =
  fn =&gt; arr =&gt; arr.filter(fn); const map = fn =&gt; arr =&gt;
  arr.map(fn);
const reduce = (fn, init) =&gt; arr =&gt; arr.reduce(fn, init);
const pending = (listOfTasks, name) =&gt; pipeline(
getField("byPerson"),
filter(t =&gt; t.responsible === name), map(t =&gt; t.tasks),
reduce((y, x) =&gt; x, []), filter(t =&gt; t &amp;&amp; !t.done),
  map(getField("id"))
)(allTasks || {byPerson: []}); //</pre>
			<p>The <code>reduce()</code> call may be mystifying. By that time, we are handling an array with a single element – an object – and we want the object in the pipeline, not the array. This code works even if the responsible person doesn’t exist, or if all the tasks have been completed; can you see why? Also, note that if <code>allTasks</code> is <code>null</code>, an object must be provided with the <code>byPerson</code> property so that future functions won’t crash! For an even better solution, I think monads are better: see <em class="italic">Question 12.1</em> for more.</p>
			<p>8.3 <strong class="bold">Thinking in abstract terms</strong>: The simple solution implies composing. I preferred it to pipelining in order to keep the list of functions in the same order:</p>
			<pre class="source-code">
const getSomeResults2 = compose(sort, group, filter, select);</pre>
			<p>8.4 <strong class="bold">Reversing types</strong>: We can apply recursion to reverse a list of types:</p>
			<pre class="source-code">
type Reverse&lt;FNS extends FN[]&gt; = 1 extends FNS["length"]
  ? [FNS[0]]
  : FNS extends [
      infer FN1st extends FN,
      ...infer FNRest extends FN[]
    ]
  ? [...Reverse&lt;FNRest&gt;, FN1st]
  : never;</pre>
			<p>With this, we can define <code>Compose&lt;&gt;</code> in terms of <code>Pipeline&lt;&gt;</code>:</p>
			<pre class="source-code">
type Compose&lt;FNS extends FN[]&gt; = <strong class="bold">Pipeline&lt;Reverse&lt;FNS&gt;&gt;</strong>;
function compose1&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): Compose&lt;FNS&gt; {
  <strong class="bold">return pipeline(...fns.reverse()) as Compose&lt;FNS&gt;</strong>;
}</pre>
			<p>Instead of an overload, we’re using a cast here to let TypeScript know what types we are working with.</p>
			<p>8.5 <code>pipeline()</code> function we wrote accesses <code>fns[0]</code> without checking whether the <code>fns</code> array is empty, so it won’t work. The <code>pipeline1()</code> and <code>pipeline2()</code> functions use <code>reduce()</code> without an initial value, so they will also fail. We must add an initial test, so if no functions are provided (<code>fns.length===0</code>), we’ll simply return the input value as the result.</p>
			<p>8.6 <strong class="bold">Undetected impurity?</strong> Yes, the function is impure, but using it as-is would fall squarely under the <strong class="bold">Sorta Functional Programming</strong> (<strong class="bold">SFP</strong>) style we mentioned back in the <em class="italic">Theory versus practice</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Becoming Functional</em>. The version we used is not pure, but in the way we use it, the final results are pure: we modify an array in place, but it’s a new array that we are creating. The alternate implementation is pure and also works, but will be slower since it creates a completely new array every time we call it. So, accepting this bit of impurity helps us get a function that performs better; we can accept that!</p>
			<p>8.7 <code>map()</code> operations, you could apply a single <code>map()</code> by pipelining all the mapping functions into a single one. For <code>filter()</code> operations, it becomes a bit harder, but here’s a tip: use <code>reduce()</code> to apply all the filters in sequence with a carefully thought-out accumulating function.</p>
			<p>8.8 <code>chainify()</code>, the type of <code>myCity2</code> is <code>Chainify&lt;City&gt;</code>. Attributes have the same types as before, but the <code>void</code>-returning methods now return an object of the same <code>Chainify&lt;City&gt;</code> type:</p>
			<pre class="source-code">
{
    name: string;
    lat: number;
    long: number;
    extra: boolean;
    getName: () =&gt; string;
<strong class="bold">    setName: (newName: string) =&gt; Chainify&lt;City&gt;;</strong>
<strong class="bold">    setLat: (newLat: number) =&gt; Chainify&lt;City&gt;;</strong>
<strong class="bold">    setLong: (newLong: number) =&gt; Chainify&lt;City&gt;;</strong>
    getCoords: () =&gt; number[];
}</pre>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor244"/>Chapter 9, Designing Functions – Recursion</h1>
			<p>9.1 <code>reverse("MONTEVIDEO")</code> can be found by doing <code>reverse("ONTEVIDEO")+"M"</code>. In the same way, <code>reverse("ONTEVIDEO")</code> would be equal to <code>reverse("NTEVIDEO")+"O"</code>, and so on:</p>
			<pre class="source-code">
const reverse = (str: string): string =&gt;
  str.length === 0 ? "" : <strong class="bold">reverse(str.slice(1)) + str[0]</strong>;</pre>
			<p>9.2 <strong class="bold">Climbing steps</strong>: To climb a ladder with <em class="italic">n</em> steps, we can act in two ways:</p>
			<ul>
				<li>Climb one single step and then climb an (<em class="italic">n</em>-1) steps ladder</li>
				<li>Climb two steps at once and then climb an (<em class="italic">n</em>-2) steps ladder</li>
			</ul>
			<p>So, if we call ladder(<em class="italic">n</em>) the number of ways to climb a steps ladder, we know that ladder(n)= ladder(<em class="italic">n</em>-1) + ladder(<em class="italic">n</em>-2). Adding the fact that ladder(0)=1 (there’s only one way to climb a ladder with no steps: do nothing) and ladder(1)=1, the solution is that ladder(<em class="italic">n</em>) equals the (<em class="italic">n</em>-1)th Fibonacci number! Check it out: ladder(2)=2, ladder(3)=3, ladder(4)=5, and so on.</p>
			<p>9.3 <code>max</code>), create a new copy of the array but without that element, sort the copy, and then return the sorted copy with <code>max</code> added at the end. Take a look at how we dealt with the mutator functions to avoid modifying the original array and note that this sorting code only works with numbers because of the way we find <code>max</code>:</p>
			<pre class="source-code">
const selectionSort = (arr: number[]): number[] =&gt; {
  if (arr.length === 0) {
    <strong class="bold">return []</strong>;
  } else {
    const max = Math.max(...arr);
    const rest = [...arr];
    rest.splice(arr.indexOf(max), 1);
   <strong class="bold"> return [...selectionSort(rest), max]</strong>;
  }
};
selectionSort([2, 2, 0, 9, 1, 9, 6, 0]);
// <strong class="bold">[0, 0, 1, 2, 2, 6, 9, 9]</strong></pre>
			<p>9.4 <code>smaller</code> would be an empty array, and <code>greaterEqual</code> would be equal to the whole array to sort, so the logic would enter an infinite loop.</p>
			<p>The original code can never enter a loop because every pass removes one element (the pivot) so you’re guaranteed to reach a state with nothing left to sort.</p>
			<p>9.5 <strong class="bold">More efficiency</strong>: The following code does the work for us. Here, we use a ternary operator to decide where to push the new item:</p>
			<pre class="source-code">
const partition = &lt;A&gt;(
  arr: A[],
  fn: (x: A) =&gt; boolean
): [A[], A[]] =&gt;
  arr.reduce(
    (result: [A[], A[]], elem: A) =&gt; {
      result[fn(elem) ? 0 : 1].push(elem);
      return result;
    },
    [[], []]
  );</pre>
			<p>9.6 <code>mapR()</code>, so I’ll skip repeating explanations – the only difference is in the <code>return</code> value, which is now a value from the array (<code>arr[0]</code> in <code>findLoop()</code>) instead of a mapped whole array as in <code>mapR()</code>:</p>
			<pre class="source-code">
type Opt&lt;X&gt; = X | undefined;
const findR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): Opt&lt;A&gt; =&gt; {
  const findLoop = (arr: Opt&lt;A&gt;[], i: number): Opt&lt;A&gt; =&gt;
    arr.length === 0
      ? undefined
      : !(0 in arr) || arr[0] === undefined
      ? findLoop(arr.slice(1), I + 1)
      : cb(arr[0], i, orig)
      ? arr[0]
      : findLoop(arr.slice(1), i + 1);
  return findLoop(orig, 0);
};</pre>
			<p>9.7 <code>mapR()</code> example, so I won’t comment on the looping, types, and so on. When programming <code>everyR()</code>, we must be careful what to do with empty arrays or missing places; the standard <code>every()</code> method considers them to return <code>true</code>, so we’ll do the same:</p>
			<pre class="source-code">
type Opt&lt;X&gt; = X | undefined;
const everyR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): boolean =&gt; {
  const everyLoop = (arr: Opt&lt;A&gt;[], i: number): boolean =&gt;
    arr.length === 0
      ? true
      : !(0 in arr) || arr[0] === undefined
      ? true
      : !cb(arr[0], i, orig)
      ? false
      : everyLoop(arr.slice(1), i + 1);
  return everyLoop(orig, 0);
};</pre>
			<p>When programming <code>someR()</code>, an empty array means a false result, but empty places are skipped:</p>
			<pre class="source-code">
type Opt&lt;X&gt; = X | undefined;
const someR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): boolean =&gt; {
  const someLoop = (arr: Opt&lt;A&gt;[], i: number): boolean =&gt;
    arr.length === 0
      ? false
      : !(0 in arr) || arr[0] === undefined
      ? someLoop(arr.slice(1), i + 1)
      : cb(arr[0], i, orig)
      ? true
      : someLoop(arr.slice(1), i + 1);
  return someLoop(orig, 0);
};</pre>
			<p>9.8 <strong class="bold">Symmetrical queens</strong>: The key to finding only symmetric solutions is as follows. After the first four queens have been (tentatively) placed on the first half of the board, we don’t have to try all the possible positions for the other queens; they are automatically determined with regard to the first ones:</p>
			<pre class="source-code">
const SIZE = 8;
const places = Array(SIZE);
const checkPlace = (column: number, row: number): boolean
  =&gt;
  places
    .slice(0, column)
    .every(
      (v, i) =&gt;
        v !== row &amp;&amp; Math.abs(v - row) !== column - i
    );
const symmetricFinder = (column = 0): void =&gt; {
  if (column === SIZE) {
    console.log(JSON.stringify(places.map((x) =&gt; x + 1)));
  } else if (column &lt;= SIZE / 2) {
    // first half of the board?
    const testRowsInColumn = (j: number): void =&gt; {
      if (j &lt; SIZE) {
        if (checkPlace(column, j)) {
          places[column] = j;
          symmetricFinder(column + 1);
        }
        testRowsInColumn(j + 1);
      }
    };
    testRowsInColumn(0);
  } else {
    <strong class="bold">// second half of the board</strong>
<strong class="bold">    const symmetric = SIZE - 1 - places[SIZE - 1 - column];</strong>
<strong class="bold">    if (checkPlace(column, symmetric)) {</strong>
<strong class="bold">      places[column] = symmetric;</strong>
<strong class="bold">      symmetricFinder(column + 1);</strong>
<strong class="bold">    }</strong>
  }
};</pre>
			<p>Calling <code>symmetricFinder()</code> produces four solutions, which are essentially the same. Make drawings and check them to make sure the solution is correct!</p>
			<pre class="console">
[3,5,2,8,1,7,4,6]
[4,6,8,2,7,1,3,5]
[5,3,1,7,2,8,6,4]
[6,4,7,1,8,2,5,3]</pre>
			<p>9.9 <code>a</code> and <code>b</code>, can be found with recursion as follows:</p>
			<ul>
				<li>If the length of <code>a</code> is zero, or if the length of <code>b</code> is zero, return zero</li>
				<li>If the first characters of <code>a</code> and <code>b</code> match, the answer is 1 plus the LCS of <code>a</code> and <code>b</code>, both minus their initial characters</li>
				<li>If the first characters of <code>a</code> and <code>b</code> do not match, the answer is the largest of the following two results:<ul><li>The LCS of <code>a</code> minus its initial character, and <code>b</code></li><li>The LCS of <code>a</code>, and <code>b</code> minus its initial character</li></ul></li>
			</ul>
			<p>We can implement this as follows. We do memoization “by hand” to avoid repeating calculations; we could have also used our memoization function:</p>
			<pre class="source-code">
const LCS = (strA: string, strB: string): number =&gt; {
  // memoization "by hand"
  const cache: { [k: string]: number } = {};
  const innerLCS = (strA: string, strB: string): number =&gt;
    {
    const key = strA + "/" + strB;
    let ret: number;
    if (!(key in cache)) {
      if (strA.length === 0 || strB.length === 0) {
        ret = 0;
      } else if (strA[0] === strB[0]) {
        ret = 1 + innerLCS(strA.substr(1), strB.substr(1));
      } else {
        ret = Math.max(
          innerLCS(strA, strB.substr(1)),
          innerLCS(strA.substr(1), strB)
        );
      }
      cache[key] = ret;
    }
    return cache[key];
  };
  return innerLCS(strA, strB);
};
console.log(LCS("INTERNATIONAL", "CONTRACTOR"));
// 6, as in the text</pre>
			<p>As an extra exercise, you could produce not only the length of the LCS but also the characters that are involved.</p>
			<p>9.10 <code>2</code> and check whether the remainder is <code>1</code>:</p>
			<pre class="source-code">
function isOdd1(n: number): boolean {
  return n % 2 === 1;
}</pre>
			<p>You could have another solution by doing <code>return Boolean(n % </code><code>2)</code> instead:</p>
			<pre class="source-code">
function isOdd2(n: number): boolean {
  return Boolean(n % 2);  // or !!(n % 2) instead
}</pre>
			<p>Another way is to divide the number by 2 and check whether it has a fractional part:</p>
			<pre class="source-code">
function isOdd3(n: number): boolean {
  return Math.floor(n / 2) !== n / 2;
}</pre>
			<p>If a number is odd, dividing it by 2 and dividing its predecessor by 2, both results have the same integer part (for instance, 9/2 and 8/2 both have integer part 4):</p>
			<pre class="source-code">
function isOdd4(n: number): boolean {
  return Math.floor(n / 2) === Math.floor((n - 1) / 2);
}</pre>
			<p>Using bit operations is fast; an odd number will have its least significant bit set to <code>1</code>:</p>
			<pre class="source-code">
function isOdd5(n: number): boolean {
  return (n &amp; 1) === 1;
}</pre>
			<p>As in <code>isOdd1()</code>, you get another variation by doing <code>return Boolean(n &amp; </code><code>1)</code> instead:</p>
			<pre class="source-code">
function isOdd6(n: number): boolean {
  return Boolean(n &amp; 1); // or !!(n &amp; 1) instead
}</pre>
			<p>Shifting in binary also works; if we shift the number one bit to the right (dropping its least significant bit) and then shift the number back one bit to the left, for an odd number, we don’t get the same result:</p>
			<pre class="source-code">
function isOdd7(n: number): boolean {
  return (n &gt;&gt; 1) &lt;&lt; 1 !== n;
}</pre>
			<p>Shifting to the right is the same as dividing by 2 and keeping the integer part, so this solution is basically the same as the third one:</p>
			<pre class="source-code">
function isOdd8(n: number): boolean {
  return n &gt;&gt; 1 === (n - 1) &gt;&gt; 1;
}</pre>
			<p>Odd numbers end in 1, 3, 5, 7, or 9, so we can also look at the string representation of the number and check its value:</p>
			<pre class="source-code">
function isOdd9(n: number): boolean {
  return "13579".includes(String(n).at(-1)!);
}</pre>
			<p>We could work with the string by using <code>find()</code> or <code>indexOf()</code>; I’ll leave these versions to you.</p>
			<p>9.11 <code>trampoline()</code>:</p>
			<pre class="source-code">
function isEven(n: number, cont: FN): () =&gt; boolean {
  if (n === 0) {
    return <strong class="bold">trampoline(() =&gt; cont(true))</strong>;
  } else {
    return <strong class="bold">trampoline(() =&gt; isOdd(n - 1, (v) =&gt; cont(v)))</strong>;
  }
}
function isOdd(n: number, cont: FN): () =&gt; boolean {
  return <strong class="bold">trampoline(() =&gt; isEven(n, (v) =&gt; cont(!v)))</strong>;
}</pre>
			<p>For instance, the first <code>return</code> in <code>isEven()</code> used to be <code>return true</code>; now we trampoline a thunk that will call a continuation with <code>true</code>. We can now finish the job by providing an appropriate continuation that just returns the calculated value:</p>
			<pre class="source-code">
function isEvenT(n: number): boolean {
  return <strong class="bold">trampoline(isEven(n, (x) =&gt; x))</strong>;
}
function isOddT(n: number): boolean {
  return <strong class="bold">trampoline(isOdd(n, (x) =&gt; x))</strong>;
}
console.log("22.. isEven?", isEvenT(22));  // true
console.log("9... isOdd?", isOddT(5));     // true
console.log("63... isEven?", isEvenT(63)); // false
console.log("60... isOdd?", isOddT(60));   // false</pre>
			<p>9.12 <code>isEven(1)</code> or <code>isOdd(2)</code>, you get an infinite loop; can you see why? (The same will happen if you replace <code>1</code> and <code>2</code> with any odd or even number, respectively.) A hint: the problem is with the base cases for recursion.</p>
			<p>9.13 <code>while()</code> with a <code>for(;;)</code> loop and breaking out with a <code>return</code>.</p>
			<p>9.14 <code>power()</code> function, sitting between <code>term()</code> and <code>factor()</code>, so its priority will be correctly placed.</p>
			<div><div><img src="img/Figure_2_B19301.jpg" alt="Figure 2 – Power represents a sequence of exponentiations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2 – Power represents a sequence of exponentiations</p>
			<p>We’ll change <code>term()</code> to call <code>power()</code> instead of <code>factor()</code>:</p>
			<pre class="source-code">
function term(): number {
  let accum = power();
  while (
    tokens[curr] === TIMES ||
    tokens[curr] === DIVIDES ||
    tokens[curr] === MODULUS
  ) {
    if (tokens[curr] === TIMES) {
      curr++;
      <strong class="bold">accum *= power()</strong>;
    } else if (tokens[curr] === DIVIDES) {
      curr++;
      <strong class="bold">accum /= power()</strong>;
    } else if (tokens[curr] === MODULUS) {
      curr++;
      <strong class="bold">accum %= power()</strong>;
    }
  }
  return accum;
}</pre>
			<p>To properly calculate “towers” such as 2^3^4, we’ll store <code>2</code>, <code>3</code>, and <code>4</code> in an array, and then reduce it from right to left: we’ll first calculate 3^4, and then 2^(the calculated result for 3^4):</p>
			<pre class="source-code">
function power(): number {
  const tower = [factor()];
  while (tokens[curr] === POWER) {
    curr++;
    tower.push(factor());
  }
  while (tower.length &gt; 1) {
    tower[tower.length - 2] **= tower[tower.length - 1];
    tower.pop();
  }
  return tower[0];
}</pre>
			<p>9.15 <strong class="bold">Error-prone evaluation</strong>: Here are some ideas:</p>
			<ul>
				<li>When skipping a token, check if it’s correct anyway; for instance, <code>factor()</code> skips the second parenthesis without actually checking whether it is, so it would evaluate “(1+2]” as 3, even though it’s wrong.</li>
				<li>Add a special end-of-string (EOS) token, to check whether the evaluation finishes at that token.</li>
				<li>Check you do not go beyond the end of the <code>tokens</code> array whenever you advance to the next token.</li>
			</ul>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor245"/>Chapter 10, Ensuring Purity – Immutability</h1>
			<p>10.1 <code>jsonCopy()</code> in the following example, but don’t assume there aren’t any more problems:</p>
			<pre class="source-code">
const agent = {
  error: new Error("It's stirred; I ordered it shaken"),
  map: new Map([["James", "Bond"]]),
  set: new Set([0, 0, 7]),
  regex: /007/,
  useLicense() {
    console.log("Bang! Bang!");
  },
};
console.log(jsonCopy(agent));
/*
{ <strong class="bold">error: {}, map: {}, set: {}, regex: {} </strong>}
*/</pre>
			<p>Four of the properties got transformed into an empty object, and the function was ignored.</p>
			<p>10.2 <code>deepCopy()</code> function does marginally better; with the same agent object as in the previous question, copying produces the following:</p>
			<pre class="source-code">
/*
{
  error: Error: It's stirred; I ordered it shaken
    ...many lines snipped out
  map: Map(0) {},
  set: Set(0) {},
  regex: /(?:)/,
  useLicense: [Function: useLicense]
}
*/</pre>
			<p>The error and the function got converted OK. The map and the set were converted into the right types, but they are empty; this could be fixed by adding logic that would scan the original objects and insert copies of them into the new ones. (<em class="italic">Question 10.10</em> may help.) Finally, cloning a regular expression is a tad harder, but google “<em class="italic">clone regexp in JavaScript</em>” and you’ll find several implementations for this.</p>
			<p>10.3 <code>deepCopy2()</code> function is as follows:</p>
			<pre class="source-code">
const deepCopy2 = &lt;O extends OBJ&gt;(obj: O): O =&gt; {
  <strong class="bold">const mapped = new Map&lt;O, O&gt;();</strong>
  const deepCopy = (obj: O): O =&gt; {
    let aux: O = obj;
    if (obj &amp;&amp; typeof obj === "object") {
<strong class="bold">      if (mapped.has(obj)) {</strong>
<strong class="bold">        return mapped.get(obj) as O;</strong>
<strong class="bold">      }</strong>
      aux = new (obj as any).constructor();
<strong class="bold">      mapped.set(obj, aux);</strong>
      Object.getOwnPropertyNames(obj).forEach((prop) =&gt; {
        (aux as any)[prop as keyof O] =
          deepCopy(obj[prop]);
      });
    }
    return aux;
  };
  return deepCopy(obj);
};</pre>
			<p>We’ll use the <code>mapped</code> variable for our map. When we find that we have to clone an <code>obj</code> object, we first check (<code>mapped.has(obj)</code>) whether we have already done that, and if so, we return the value from the map. If this was a new, not yet copied object, we add it and its <code>aux</code> copy to the map (<code>mapped.set(obj,aux)</code>) for future reference.</p>
			<p>We can verify how this work with a simple example:</p>
			<pre class="source-code">
const circular = {
  a: 1,
  b: { c: 3, d: { e: 5, f: null } }
};
circular.b.d.f = circular.b as any;
console.log(deepCopy2(circular));
/*
{
  a: 1,
  b: <strong class="bold">&lt;ref *1&gt;</strong> { c: 3, d: { e: 5, f: <strong class="bold">[Circular *1]</strong> } }
}
*/</pre>
			<p>If we use <code>deepCopy()</code> on <code>circular</code>, we’ll get a <code>RangeError: Maximum call stack size exceeded</code> exception. However, with our new <code>deepCopy2()</code> function, the circular reference is tackled with no problem.</p>
			<p>10.4 <strong class="bold">Freezing by proxying</strong>: As requested, a proxy allows you to intercept changes on an object. (See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a> for more on this.) We use recursion to apply the proxy all the way down in case some attributes are objects themselves:</p>
			<pre class="source-code">
const proxySetAll = (obj: OBJ): OBJ =&gt; {
  Object.keys(obj).forEach((v) =&gt; {
    if (typeof obj[v] === "object") {
      obj[v] = proxySetAll(obj[v]);
    }
  });
  return new Proxy(obj, {
    set() {
      throw new Error("DON'T MODIFY ANYTHING IN ME");
    },
    deleteProperty() {
      throw new Error("DON'T DELETE ANYTHING IN ME");
    },
  }) as OBJ;
};</pre>
			<p>The following is the output of the preceding code. For real-life implementations, you’d probably require something other than a <code>DON'T MODIFY ANYTHING IN ME</code> message, of course!</p>
			<pre class="console">
const myObj = <strong class="bold">proxySetAll</strong>({
  a: 5,
  b: 6,
  c: { d: 7, e: 8 },
});
myObj.a = 777;
// Uncaught Error: DON'T MODIFY ANYTHING IN ME
myObj.f = 888;
// Uncaught Error: DON'T MODIFY ANYTHING IN ME
delete myObj.b;
// Uncaught Error: DON'T DELETE ANYTHING IN ME</pre>
			<p>10.5 <strong class="bold">Inserting into a list, persistently</strong>: Using recursion helps out as follows:</p>
			<ul>
				<li>If the list is empty, we cannot insert the new key.</li>
				<li>If we are at a node whose key is <code>oldKey</code>, we create a clone of that node that points at a list that starts with a new node with <code>newKey</code> as its value and a pointer to the rest of the original node’s list.</li>
				<li>If we are at a node whose key isn’t <code>oldKey</code>, we create a clone of the node and (recursively) insert the new key somewhere in the rest of the original node’s list:</li>
			</ul>
			<pre class="source-code">
type NODE_PTR = Node | null;
const insertAfter = (
  list: NODE_PTR,
  newKey: string,
  oldKey: string
): NODE_PTR =&gt; {
  if (list === null) {
    return null;
  } else if (list.key === oldKey) {
    return new Node(list.key, new Node(newKey, list.next));
  } else {
    return new Node(
      list.key,
      insertAfter(list.next, newKey, oldKey)
    );
  }
};</pre>
			<p>In the following code, we can see this working. The new list is similar to the one shown in <em class="italic">Figure 10</em><em class="italic">.2</em>. However, printing out the lists (<code>c3</code> and <code>newList</code>) wouldn’t be enough; you wouldn’t be able to distinguish new or old nodes, so I’ve included several comparisons:</p>
			<pre class="source-code">
const c3 =
  new Node("G",
    new Node("B",
      new Node("F",
        new Node("A",
          new Node("C",
            new Node("E", null))))));
const newList = insertAfter(c3, "D", "B");
console.log(c3 === newList);
// false
console.log(c3!.key === newList!.key);
// true (both are "G")
console.log(c3!.next === newList!.next);
// false
console.log(c3!.next!.key === newList!.next!.key);
// true (both are "B")
console.log(c3!.next!.next === newList!.next!.next);
// false
console.log(c3!.next!.next!.key === "F");
// true
console.log(newList!.next!.next!.key === "D");
// true
console.log(
  c3!.next!.next!.next === newList!.next!.next!.next!.next
);
// true – after F, the list is the old one</pre>
			<p>A lot of <code>!</code> non-null assertions were needed to inform TypeScript that no <code>null</code> values were around.</p>
			<p>A new question: In the preceding logic, nothing is inserted if <code>oldKey</code> isn’t found. Can you change the logic so, in that case, the new node is added at the end of the list?</p>
			<p>10.6 <code>reduce()</code>. Let’s write the <code>composeManyLenses()</code> function and apply it to the same example that was shown in the text:</p>
			<pre class="source-code">
const composeManyLenses = &lt;O extends OBJ&gt;(
  ...lenses: LENS&lt;O&gt;[]
) =&gt;
  lenses.reduce((acc, lens) =&gt; composeTwoLenses(acc,
    lens));</pre>
			<p>With the <code>deepObject</code> example seen earlier, plus all the lenses to get <code>c</code>, <code>e</code>, <code>g</code>, and so on, we get the following:</p>
			<pre class="source-code">
const deepObject = {
  a: 1,
  b: 2,
  c: {
    d: 3,
    e: {
      f: 6,
      g: { i: 9, j: { <strong class="bold">k: 11</strong> } },
      h: 8,
    },
  },
};
console.log(
  view(composeManyLenses(lC, lE, lG, lJ, lK), deepObject)
);
// <strong class="bold">11, same as earlier</strong></pre>
			<p>10.7 <code>getField()</code> to <code>getByPath()</code>.</p>
			<p>10.8 <code>fullName</code> attribute:</p>
			<pre class="source-code">
const lastNameLens = composeTwoLenses(
  lensProp("name"),
  lensProp("last")
);
const firstNameLens = composeTwoLenses(
  lensProp("name"),
  lensProp("first")
);
const fullNameGetter = &lt;O extends OBJ&gt;(obj: O): string =&gt;
  `${view(lastNameLens)(obj)},
    ${view(firstNameLens)(obj)}`;</pre>
			<p>Being able to set several attributes based on a single value isn’t always possible, but if we assume the incoming name is in the <code>LAST,FIRST</code> format, we can split it by the comma and assign the two parts to the first and last names, respectively:</p>
			<pre class="source-code">
const fullNameSetter =
  &lt;O extends OBJ&gt;(fullName: string) =&gt;
  (obj: O): O =&gt; {
<strong class="bold">    const parts = fullName.split(",");</strong>
<strong class="bold">    return set(firstNameLens)(parts[1])(</strong>
<strong class="bold">      set(lastNameLens)(parts[0])(obj)</strong>
<strong class="bold">    ) as O;</strong>
  };
const fullNameLens = lens(fullNameGetter, fullNameSetter);</pre>
			<p>10.9 <code>view()</code> function would work well, but <code>set()</code> and <code>over()</code> wouldn’t work in a pure way since <code>setArray()</code> doesn’t return a new array; instead, it modifies the current one in place. Take a look at the following question for a related problem.</p>
			<p>10.10 <strong class="bold">Lenses into maps</strong>: Getting a value from the map poses no problem, but for setting, we need to clone the map:</p>
			<pre class="source-code">
const getMap =
  &lt;K, V&gt;(key: K) =&gt;
  (map: Map&lt;K, V&gt;) =&gt;
    <strong class="bold">map.get(key)</strong>;
const setMap =
  &lt;K, V&gt;(key: K) =&gt;
  (value: V) =&gt;
  (map: Map&lt;K, V&gt;) =&gt;
    <strong class="bold">new Map(map).set(key, value)</strong>;
const lensMap = &lt;K, V&gt;(key: K) =&gt;
  lens(getMap&lt;K, V&gt;(key), setMap&lt;K, V&gt;(key));</pre>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor246"/>Chapter 11, Implementing Design Patterns – The Functional Way</h1>
			<p>11.1 <strong class="bold">Decorating methods, the future way</strong>: As we’ve already mentioned, decorators aren’t a fixed, definitive feature at the moment. However, by following <a href="http://tc39.github.io/proposal-decorators/">tc39.github.io/proposal-decorators/</a>, we can write the following:</p>
			<pre class="source-code">
const logging = (target, name, descriptor) =&gt; {
  const savedMethod = descriptor.value;
  descriptor.value = function (...args) {
    console.log(`entering ${name}: ${args}`);
    try {
      const valueToReturn =
        savedMethod.bind(this)(...args);
      console.log(`exiting ${name}: ${valueToReturn}`);
      return valueToReturn;
    } catch (thrownError) {
      console.log(`exiting ${name}: threw ${thrownError}`);
      throw thrownError;
    }
  };
  return descriptor;
};</pre>
			<p>We want to add a <code>@logging</code> decoration to a method. We save the original method in <code>savedMethod</code> and substitute a new method that will log the received arguments, call the original method to save its return value, log that, and finally return it. If the original method throws an exception, we catch it, report it, and throw it again so that it can be processed as expected. A simple example of this is as follows:</p>
			<pre class="source-code">
class SumThree {
  constructor(z) {
    this.z = z;
  }
<strong class="bold">  @logging</strong>
  sum(x, y) {
    return x + y + this.z;
  }
}
new SumThree(100).sum(20, 8);
// entering sum: 20,8
// exiting sum: 128</pre>
			<p>11.2 <code>addBar()</code> function that receives a <code>Base</code> class and extends it. In this case, I decided to add a new attribute and a new method. The constructor for the extended class calls the original constructor and creates the <code>barValue</code> attribute. The new class has both the original’s <code>doSomething()</code> method and the new <code>somethingElse()</code> method:</p>
			<pre class="source-code">
const addBar = (Base) =&gt;
  class extends Base {
    constructor(fooValue, barValue) {
      super(fooValue);
      this.barValue = barValue;
    }
    somethingElse() {
      console.log(
        "something added: bar... ",
        this.barValue
      );
    }
  };</pre>
			<p>11.3 <code>event.detail</code>; you can find out more at <a href="http://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail">developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail</a>.</p>
			<p>11.4 <code>flags</code> array with Boolean values, you don’t need any special comparison function; <code>flags.sort()</code> works “out of the box” and will place <code>false</code> values first and <code>true</code> values last. This is because the standard sort works by converting values into strings, and then comparing them; when you do this, Boolean values become <code>"false"</code> and <code>"true"</code>, and as <code>"false" &lt; "true"</code>, everything turns out well!</p>
			<p>11.5 <code>RouteFinder</code> class with several subclasses, such as <code>ByFootRouteFinder</code>, <code>BicycleRouteFinder</code>, and so on, each implementing a <code>findRouteAlgorithm()</code> method in a different way, and a factory that chooses what subclass to instantiate.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor247"/>Chapter 12, Building Better Containers – Functional Data Types</h1>
			<p>12.1 <code>map()</code> method to Booleans, numbers, and strings:</p>
			<pre class="source-code">
declare global {
  interface Boolean {
    map(_f: (_x: boolean) =&gt; boolean): boolean;
  }
}
declare global {
  interface Number {
    map(_f: (_x: number) =&gt; number): number;
  }
}
declare global {
  interface String {
    map(_f: (_x: string) =&gt; string): string;
  }
}</pre>
			<p>Some examples are as follows:</p>
			<pre class="source-code">
Boolean.prototype.map = function (
  this: boolean,
  fn: (_x: boolean) =&gt; any
) {
  return !!fn(this);
};
const t = true;
const f = false;
const negate = (x: boolean) =&gt; !x;
console.log(t.map(negate), f.map(negate));
// false true
Number.prototype.map = function (
  this: number,
  fn: (_x: number) =&gt; number
) {
  return Number(fn(this));
};
const n = 22;
const add1 = (n: number) =&gt; n + 1;
console.log(n.map(add1));
// 23
String.prototype.map = function (
  this: string,
  fn: (_x: string) =&gt; string
) {
  return String(fn(this));
};
const s = "Montevideo";
const addBangs = (s: string): string =&gt; s + "!!!";
console.log(s.map(addBangs));
// Montevideo!!!</pre>
			<p>12.2 <code>Symbol</code>, whose value was defined inside a module and not exported, so nobody could access the corresponding attribute:</p>
			<pre class="source-code">
<strong class="bold">const VALUE = Symbol("Value");</strong>
class Container {
  constructor(x) {
    <strong class="bold">this[VALUE] = x;</strong>
  }
  map(fn) {
    return <strong class="bold">fn(this[VALUE])</strong>;
  }
  .
  . other methods
  .
}</pre>
			<p>Using a <code>Symbol</code> helps hide the field: the property key won’t show up in <code>Object.keys()</code> or in <code>for...in</code> or <code>for...of</code> loops, making them more meddle-proof. (If you haven’t worked with JavaScript symbols, possibly the least known of its primitive data types, you might want to check out <a href="http://developer.mozilla.org/en-US/docs/Glossary/symbol">developer.mozilla.org/en-US/docs/Glossary/symbol</a>.)</p>
			<p>The <code>map()</code> method could access the “protected” attribute because it had access to the <code>VALUE</code> symbol, but without that, you cannot get at the attribute.</p>
			<p>12.3 <code>XXX</code> class to be abstract, it should start like this:</p>
			<pre class="source-code">
class XXX {
  constructor(...) {
<strong class="bold">    if (this.constructor === XXX) {</strong>
<strong class="bold">      throw new Error("Cannot initialize XXX class")</strong>
<strong class="bold">    }</strong>
    .
    . rest of the constructor
    .
  }
  .
  . other methods
  .
}</pre>
			<p>12.4 <strong class="bold">Maybe tasks?</strong> The following code shows a simpler solution than the one we looked at earlier:</p>
			<pre class="source-code">
const pending = Maybe.of(listOfTasks)
  .map(getField("byPerson"))
  .map(filter((t) =&gt; t.responsible === name))
  .map((t) =&gt; tasks)
  .map((t) =&gt; t[0])
  .map(filter((t) =&gt; !t.done))
  .map(getField("id"))
  .valueOf();</pre>
			<p>Here, we apply one function after the other, secure in the knowledge that if any of these functions produces an empty result (or even if the original <code>listOfTasks</code> is null), the sequence of calls will go on. In the end, you will either get an array of task IDs or a <code>null</code> value.</p>
			<p>12.5 <strong class="bold">Extending your trees</strong>: Calculating the tree’s height is simple if you do this in a recursive fashion. The height of an empty tree is zero, while the height of a non-empty tree is one (for the root) plus the maximum height of its left and right subtrees:</p>
			<pre class="source-code">
const treeHeight = &lt;A&gt;(tree: TREE&lt;A&gt;): number =&gt;
  tree(
    (val, left, right) =&gt;
      1 + Math.max(treeHeight(left), treeHeight(right)),
    () =&gt; 0
  );</pre>
			<p>Listing the keys in order is a well-known requirement. Because of the way that the tree is built, you list the left subtree’s keys first, then the root, and finally the right subtree’s keys, all in a recursive fashion:</p>
			<pre class="source-code">
const treeList = &lt;A&gt;(tree: TREE&lt;A&gt;): void =&gt;
  tree(
    (value, left, right) =&gt; {
      treeList(left);
      console.log(value);
      treeList(right);
    },
    () =&gt; {
      // nothing
    }
  );</pre>
			<p>Finally, deleting a key from a binary search tree is a bit more complex. First, you must locate the node that is going to be removed, and then there are several cases:</p>
			<ul>
				<li>If the node has no subtrees, deletion is simple.</li>
				<li>If the node has only one subtree, you just replace the node with its subtree</li>
				<li>If the node has two subtrees, then you have to do the following:<ul><li>Find the minimum key in the tree with a greater key</li><li>Place it in the node’s place</li></ul></li>
			</ul>
			<p>Since this algorithm is well covered in all computer science textbooks, I won’t go into more detail about this here:</p>
			<pre class="source-code">
const treeRemove = &lt;A&gt;(
  toRemove: A,
  tree: TREE&lt;A&gt;
): TREE&lt;A&gt; =&gt;
  tree(
    (val, left, right) =&gt; {
      const findMinimumAndRemove = (
        tree: TREE&lt;A&gt; /* never empty */
      ): { min: A; tree: TREE&lt;A&gt; } =&gt;
        tree(
          (value, left, right) =&gt; {
            if (treeIsEmpty(left)) {
              return { min: value, tree: right };
            } else {
              const result = findMinimumAndRemove(left);
              return {
                min: result.min,
                tree: Tree(value, result.tree, right),
              };
            }
          },
          () =&gt; {
            /* not needed */
          }
        );
      if (toRemove &lt; val) {
        return Tree(val, treeRemove(toRemove, left),
          right);
      } else if (toRemove &gt; val) {
        return Tree(val, left, treeRemove(toRemove,
          right));
      } else if (treeIsEmpty(left) &amp;&amp; treeIsEmpty(right)) {
        return EmptyTree();
      } else if (treeIsEmpty(left) !== treeIsEmpty(right))
        {
        return tree(
          (val, left, right) =&gt;
            left(
              () =&gt; left,
              () =&gt; right
            ),
          () =&gt; {
            /* not needed */
          }
        );
      } else {
        const result = findMinimumAndRemove(right);
        return Tree(result.min, left, result.tree);
      }
    },
    () =&gt; tree
  );</pre>
			<p>12.6 <code>||</code> operator:</p>
			<pre class="source-code">
const treeSearch2 = &lt;A&gt;(
  findValue: A,
  tree: TREE&lt;A&gt;
): boolean =&gt;
  tree(
    (value, left, right) =&gt;
      findValue === value ||
      (findValue &lt; value
        ? treeSearch2(findValue, left)
        : treeSearch2(findValue, right)),
    () =&gt; false
  );</pre>
			<p>Also, seeing that both alternatives in the second ternary operator are very similar, you could also do some shortening there:</p>
			<pre class="source-code">
const treeSearch3 = &lt;A&gt;(
  findValue: A,
  tree: TREE&lt;A&gt;
): boolean =&gt;
  tree(
    (value, left, right) =&gt;
      findValue === value ||
      treeSearch3(
        findValue,
        findValue &lt; value ? left : right
      ),
    () =&gt; false
  );</pre>
			<p>Remember: shorter doesn’t imply better! However, I’ve found many examples of this kind of code tightening, and it’s better if you have been exposed to it, too.</p>
			<p>12.7 <strong class="bold">Functional lists</strong>: Let’s add to the samples that have already been provided. We can simplify working with lists if we can transform a list into an array, and vice versa:</p>
			<pre class="source-code">
const listToArray = &lt;A&gt;(list: LIST&lt;A&gt;): A[] =&gt;
  list(
    (head, tail) =&gt; [head, ...listToArray(tail)],
    () =&gt; []
  );
const listFromArray = &lt;A&gt;(arr: A[]): LIST&lt;A&gt; =&gt;
  arr.length
    ? NewList(arr[0], listFromArray(arr.slice(1)))
    : EmptyList();</pre>
			<p>Concatenating two lists together and appending a value to a list have simple recursive implementations. We can also reverse a list by using the appending function:</p>
			<pre class="source-code">
const listConcat = &lt;A&gt;(list1: LIST&lt;A&gt;, list2: LIST&lt;A&gt;) =&gt;
  list1(
    (head, tail) =&gt; NewList(head, listConcat(tail, list2)),
    () =&gt; list2
  );
const listAppend = &lt;A&gt;(list: LIST&lt;A&gt;, value: A): LIST&lt;A&gt; =&gt;
  list(
    (head, tail) =&gt; NewList(head, listAppend(tail, value)),
    () =&gt; NewList(value, EmptyList())
  );
const listReverse = &lt;A&gt;(list: LIST&lt;A&gt;): LIST&lt;A&gt; =&gt;
  list(
    (head, tail) =&gt; listAppend(listReverse(tail), head),
    () =&gt; EmptyList()
  );</pre>
			<p>Finally, the basic <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> operations are good to have:</p>
			<pre class="source-code">
const listMap = &lt;A, B&gt;(
  list: LIST&lt;A&gt;,
  fn: (_x: A) =&gt; B
): LIST&lt;B&gt; =&gt;
  list(
    (head, tail) =&gt; NewList(fn(head), listMap(tail, fn)),
    EmptyList
  );
const listFilter = &lt;A&gt;(
  list: LIST&lt;A&gt;,
  fn: (_x: A) =&gt; boolean
): LIST&lt;A&gt; =&gt;
  list(
    (head, tail) =&gt;
      fn(head)
        ? NewList(head, listFilter(tail, fn))
        : listFilter(tail, fn),
    EmptyList
  );
const listReduce = &lt;A, B&gt;(
  list: LIST&lt;A&gt;,
  fn: (_acc: B, _val: A) =&gt; B,
  accum: B
): B =&gt;
  list(
    (head, tail) =&gt; listReduce(tail, fn, fn(accum, head)),
    () =&gt; accum
  );</pre>
			<p>The following are some exercises that have been left for you to tackle. Generate a printable version of a list:</p>
			<ul>
				<li>Compare two lists to see whether they have the same values, in the same order</li>
				<li>Search a list for a value</li>
				<li>Get, update, or remove the value at the <em class="italic">n</em>th position of a list</li>
			</ul>
			<p>12.8 <code>BOOLEAN</code> type and two special functions, <code>TRUE</code> and <code>FALSE</code>, which will stand for the usual <code>true</code> and <code>false</code> values:</p>
			<pre class="source-code">
type BOOLEAN = (_true: any, _false: any) =&gt; any;
const TRUE: BOOLEAN = (trueValue: any, __: any) =&gt;
  trueValue;
const FALSE: BOOLEAN = (__: any, falseValue: any) =&gt;
  falseValue;</pre>
			<p>The <code>BOOLEAN</code> type receives two values and returns one of those. A <code>TRUE</code> Boolean returns the first of those two values; a <code>FALSE</code> Boolean returns the second. We can construct and check variables like this:</p>
			<pre class="source-code">
const MakeBool = (value: boolean) =&gt; (value ? TRUE :
  FALSE);
const valueOf = (boolValue: BOOLEAN): boolean =&gt;
  boolValue(true, false);
console.log("LOG T  ", valueOf(TRUE));
console.log("LOG F  ", valueOf(FALSE));
// true false
console.log("VAL T  ", valueOf(MakeBool(true)));
console.log("VAL F  ", valueOf(MakeBool(false)));
// true false</pre>
			<p>We can now define operators:</p>
			<pre class="source-code">
const NOT = (boolValue: BOOLEAN): BOOLEAN =&gt;
  boolValue(FALSE, TRUE);
const AND = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(boolRight, FALSE);
const OR = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(TRUE, boolRight);
const XOR = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(NOT(boolRight), boolRight);
const EQU = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(boolRight, NOT(boolRight));
const IMP = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(boolRight, TRUE);</pre>
			<p>These are not the only possibilities, but I’ll leave you to discover alternatives. Finally, we could have an <code>ifElse()</code> function to work with these <code>BOOLEAN</code>  values and thunks:</p>
			<pre class="source-code">
const ifElse = (
  boolValue: BOOLEAN,
  fnTRUE: FN,
  fnFALSE: FN
) =&gt; boolValue(fnTRUE, fnFALSE)();
ifElse(
  TRUE,
  () =&gt; console.log("I'm true"),
  () =&gt; console.log("I'm false")
);
// true
ifElse(
  FALSE,
  () =&gt; console.log("I'm true"),
  () =&gt; console.log("I'm false")
);
// false</pre>
			<p>A final comment: this code goes to show more things that you <em class="italic">could</em> do with functions, but it doesn’t mean you <em class="italic">should</em> do them this way! You can read the following at <a href="http://www.usrsb.in/Building-Data-Structures-from-Functions.html">www.usrsb.in/Building-Data-Structures-from-Functions.html</a>:</p>
			<p class="author-quote">In the end, this might strike you as nothing more than a useless programming trick. In a sense that’s right. I’d never use this in my own code. What makes this technique so valuable is that it actually fits into the broader context of lambda calculus, which is a mathematical abstraction of computation.</p>
			<p>Couldn’t say it better myself!</p>
		</div>
	

		<div><h1 id="_idParaDest-246"><a id="_idTextAnchor248"/>Bibliography</h1>
			<p>The following texts are freely available online:</p>
			<ul>
				<li><em class="italic">ECMA-262: ECMAScript 2022 Language Specification</em>, latest edition (currently the 13th) at <a href="http://www.ecma-international.org/ecma-262/">www.ecma-international.org/ecma-262/</a>. This provides the official standard for the current version of JavaScript.</li>
				<li><em class="italic">Eloquent JavaScript</em>, Second Edition, by <em class="italic">Marijn Haverbeke</em>, at <a href="http://eloquentjavascript.net/">eloquentjavascript.net/</a></li>
				<li><em class="italic">JavaScript for Impatient Programmers (ES2022 edition)</em>, by <em class="italic">Dr. Axel </em><em class="italic">Rauschmayer</em>, at
<a href="http://exploringjs.com/impatient-js/">exploringjs.com/impatient-js/</a></li>
				<li><em class="italic">Functional-Light JavaScript</em>, by <em class="italic">Kyle Simpson</em>, at <a href="http://github.com/getify/Functional-Light-JS">github.com/getify/Functional-Light-JS</a></li>
				<li><em class="italic">JavaScript Allongé (the “six” edition)</em>, by <em class="italic">Reginald Braithwaite</em>, at <a href="http://leanpub.com/javascriptallongesix/read">leanpub.com/javascriptallongesix/read</a></li>
				<li><em class="italic">Professor Frisby’s Mostly Adequate Guide to Functional Programming</em>, by <em class="italic">Dr. Boolean</em> (<em class="italic">Brian Lonsdorf</em>), at <a href="http://github.com/MostlyAdequate/mostly-adequate-guide">github.com/MostlyAdequate/mostly-adequate-guide</a></li>
			</ul>
			<p>If you prefer printed books, you can go with this list:</p>
			<ul>
				<li><em class="italic">Beginning Functional JavaScript</em>, by <em class="italic">Anto Aravinth</em>, <em class="italic">Apress</em>, 2017</li>
				<li><em class="italic">Discover Functional JavaScript</em>, by <em class="italic">Cristian Salcescu</em>, (independently published), 2019</li>
				<li><em class="italic">Functional JavaScript</em>, by <em class="italic">Michael Fogus</em>, <em class="italic">O’Reilly </em><em class="italic">Media</em>, 2013</li>
				<li><em class="italic">Functional Programming in JavaScript</em>, by <em class="italic">Dan Mantyla</em>, <em class="italic">Packt </em><em class="italic">Publishing</em>, 2015</li>
				<li><em class="italic">Functional Programming in JavaScript</em>, by <em class="italic">Luis Atencio</em>, <em class="italic">Manning </em><em class="italic">Publications</em>, 2016</li>
				<li><em class="italic">Grokking Simplicity – Taming complex software with functional thinking</em>, by <em class="italic">Eric Normand</em>, <em class="italic">Manning </em><em class="italic">Publications</em>, 2021</li>
				<li><em class="italic">Hands-on Functional Programming with TypeScript</em>, by <em class="italic">Remo Jansen</em>, <em class="italic">Packt </em><em class="italic">Publishing</em>, 2019</li>
				<li><em class="italic">Introduction to Functional Programming</em>, by <em class="italic">Richard Bird and Philip Wadler</em>, <em class="italic">Prentice Hall International</em>, 1988. A more theoretical point of view, not dealing specifically with JavaScript</li>
				<li><em class="italic">Pro JavaScript Design Patterns</em>, by <em class="italic">Ross Harmes and Dustin Díaz</em>, <em class="italic">Apress</em>, 2008</li>
				<li><em class="italic">Secrets of the JavaScript Ninja</em>, by John Resig and Bear Bibeault, <em class="italic">Manning </em><em class="italic">Publications</em>, 2012</li>
				<li><em class="italic">TypeScript 4 Design Patterns and Best Practices</em>, by <em class="italic">Theo Despoudis</em>, <em class="italic">Packt </em><em class="italic">Publishing</em>, 2021</li>
			</ul>
			<p>Also interesting, though with a lesser focus on functional programming, are the following:</p>
			<ul>
				<li><em class="italic">High-Performance JavaScript</em>, by <em class="italic">Nicholas Zakas</em>, <em class="italic">O’Reilly </em><em class="italic">Media</em>, 2010</li>
				<li><em class="italic">JavaScript Patterns</em>, by <em class="italic">Stoyan Stefanov</em>, <em class="italic">O’Reilly </em><em class="italic">Media</em>, 2010</li>
				<li><em class="italic">JavaScript: The Good Parts</em>, by <em class="italic">Douglas Crockford</em>, <em class="italic">O’Reilly </em><em class="italic">Media</em>, 2008</li>
				<li><em class="italic">JavaScript with Promises</em>, by <em class="italic">Daniel Parker</em>, <em class="italic">O’Reilly </em><em class="italic">Media</em>, 2015</li>
				<li><em class="italic">Learning JavaScript Design Patterns</em>, by <em class="italic">Addy Osmani</em>, <em class="italic">O’Reilly </em><em class="italic">Media</em>, 2012</li>
				<li><em class="italic">Mastering JavaScript Design Patterns</em>, <em class="italic">Second Edition</em>, by <em class="italic">Simon Timms</em>, <em class="italic">Packt </em><em class="italic">Publishing</em>, 2016</li>
				<li><em class="italic">Mastering JavaScript High Performance</em>, by <em class="italic">Chad Adams</em>, <em class="italic">Packt </em><em class="italic">Publishing</em>, 2015</li>
				<li><em class="italic">Pro JavaScript Performance</em>, by <em class="italic">Tom Barker</em>, <em class="italic">Apress</em>, 2012</li>
			</ul>
			<p>These titles are on the subject of reactive functional programming:</p>
			<ul>
				<li><em class="italic">Mastering Reactive JavaScript</em>, by <em class="italic">Erich de Souza Oliveira</em>, <em class="italic">Packt </em><em class="italic">Publishing</em>, 2017</li>
				<li><em class="italic">Reactive Programming with Node.js</em>, by <em class="italic">Fernando Doglio</em>, <em class="italic">Apress</em>, 2016</li>
				<li><em class="italic">Reactive Programming with RxJS</em>, by <em class="italic">Sergi Mansilla</em>, <em class="italic">The Pragmatic </em><em class="italic">Programmers</em>, 2015</li>
			</ul>
		</div>
	</body></html>