<html><head></head><body>
		<div id="_idContainer073">
			<h1 id="_idParaDest-219" class="chapter-number"><a id="_idTextAnchor221"/>12</h1>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor222"/>Building Better Containers – Functional Data Types</h1>
			<p>In <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Implementing Design Patterns</em>, we went over how to use functions to achieve different results. In this chapter, we will look at data types from a functional point of view. We’ll be considering how we can implement our own data types, along with several features that can help us compose operations or ensure their purity so that our FP coding will become simpler <span class="No-Break">and shorter.</span></p>
			<p>We’ll be touching on <span class="No-Break">several topics:</span></p>
			<ul>
				<li><strong class="bold">Data types</strong> from a functional <a id="_idIndexMarker964"/>point of view. Even though JavaScript is not a typed language, a better understanding of types and functions is needed, to complement our usage <span class="No-Break">of TypeScript.</span></li>
				<li><strong class="bold">Containers</strong>, including functors and the mystifying monads, to structure a <span class="No-Break">data flow.</span></li>
				<li><strong class="bold">Functions as structures</strong>, in which we’ll see yet another way of using functions to represent data types, with immutability thrown in as <span class="No-Break">an extra.</span></li>
			</ul>
			<p>With that, let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor223"/>Specifying data types</h1>
			<p>Even though<a id="_idIndexMarker965"/> JavaScript is a dynamic language, without static or explicit typing declarations and controls, it doesn’t mean you can simply ignore types. Even if the language doesn’t allow you to specify the types of your variables or functions, you still work—even if only in your head—with types. Specifying types has advantages, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>TypeScript can detect compile-time errors, avoiding <span class="No-Break">many bugs.</span></li>
				<li>It will help if you move from JavaScript to a <a id="_idIndexMarker966"/>more functional language, such as Elm (<span class="No-Break">see </span><a href="http://elm-lang.org"><span class="No-Break">elm-lang.org</span></a><span class="No-Break">).</span></li>
				<li>It serves as documentation that lets future developers understand what type of arguments they must pass to the function and what type it will return. All the functions in the Ramda library are documented in <span class="No-Break">this way.</span></li>
				<li>It will also help us with the<a id="_idIndexMarker967"/> functional data structures we will cover later in this section, where we will examine a way of dealing with structures, similar to what you do in fully functional languages such <span class="No-Break">as Haskell.</span></li>
			</ul>
			<p>Why are we discussing types again, after using TypeScript throughout the whole book? The reason is that in most FP texts, a different style is used. TypeScript definitions are just, well, TypeScript, but the definitions we’ll see here can be applied to any other language. Let’s forget TypeScript for a minute and start thinking about a new type system. We’ll start with functions, the most relevant type, and then consider <span class="No-Break">other definitions.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor224"/>Signatures for functions</h2>
			<p>The specification of a<a id="_idIndexMarker968"/> function’s arguments and the result are given by a signature. Type signatures are based on a type system called <strong class="bold">Hindley–Milner</strong> (<strong class="bold">HM</strong>), which<a id="_idIndexMarker969"/> influenced several (mostly functional) languages, including Haskell, though the notation has changed from that of the original paper. This system can even deduce types that are not directly given, in the same way that TypeScript or Flow does. Instead of providing a dry, formal explanation about the rules for writing correct signatures, let’s work with examples. We only need to know <span class="No-Break">the following:</span></p>
			<ul>
				<li>We will be writing the type declaration as <span class="No-Break">a comment</span></li>
				<li>The function name is written first, and then <strong class="source-inline">::</strong>, which can be read as <em class="italic">is of type</em> or <span class="No-Break"><em class="italic">has type</em></span></li>
				<li>Optional constraints may follow, with a double (fat) arrow <strong class="source-inline">⇒</strong> (or <strong class="source-inline">=&gt;</strong> in basic ASCII fashion, if you cannot type in the <span class="No-Break">arrow) afterward</span></li>
				<li>The input type of the function follows, with a <strong class="source-inline">→</strong> (or <strong class="source-inline">-&gt;</strong>, depending on <span class="No-Break">your keyboard)</span></li>
				<li>The result type of<a id="_idIndexMarker970"/> the function <span class="No-Break">comes last</span></li>
			</ul>
			<p class="callout-heading">Careful with arrows!</p>
			<p class="callout">An advance warning: check out the arrow styles we’ll use; they are not what TypeScript uses! A “thin” arrow will be used instead of <strong class="source-inline">=&gt;</strong>, and a “fat” arrow will be used to specify a generic constraint; <span class="No-Break">be careful!</span></p>
			<p>Now, we can begin with some examples. Let’s define the type for a simple function that capitalizes a word, and do the same for the <span class="No-Break"><strong class="source-inline">Math.random</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
// <strong class="bold">firstToUpper :: String → String</strong>
const firstToUpper = (s: string): string =&gt;
  s[0].toUpperCase() + s.substring(1).toLowerCase();
// <strong class="bold">Math.random :: () → Number</strong></pre>
			<p>These are simple cases—only take the signatures into account here; we are not interested in the actual functions. The arrows denote functions. The first function receives a string as an argument and returns a new string. The second one receives no arguments (as indicated by the empty parentheses) and returns a floating-point number. So, we can read the first signature as <strong class="source-inline">firstToUpper()</strong> <em class="italic">is a function of the type that receives a string and returns a string</em>. We can speak similarly about the maligned (impurity-wise) <strong class="source-inline">Math.random()</strong> function, the only difference being that it doesn’t <span class="No-Break">receive arguments.</span></p>
			<p>Comparing the new type definition with TypeScript, it’s clear that they are very much alike. However, the new style is clearer. You could have also defined <strong class="source-inline">firstToUpper()</strong> in the following way, without specifying the result type (because TypeScript can work it out), but with HM types, you have to provide all the details, providing <span class="No-Break">more clarity:</span></p>
			<pre class="source-code">
// <strong class="bold">firstToUpper :: String → String</strong>
const firstToUpper = (s: string) =&gt;
  s[0].toUpperCase() + s.substring(1).toLowerCase();</pre>
			<p>Another detail is that in this new way of specifying types, the type descriptions stand on their own, without being mixed with the details of the programming language—you don’t need to understand JavaScript, TypeScript, or any other language to figure out what types are involved in <span class="No-Break">a function.</span></p>
			<p>We’ve already<a id="_idIndexMarker971"/> looked at functions with zero or one parameter, but what about functions with more than one? There are two answers to this. If we are working in a strict functional style, we would always be currying (as we saw in <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>), so all the functions would be unary. The other solution is enclosing a list of argument types in parentheses. We can see both of these solutions in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// <strong class="bold">sum3C :: Number → Number → Number → Number</strong>
const sum3C = curry(
  (a: number, b: number, c: number): number =&gt; a + b + c
);
// <strong class="bold">sum3 :: (Number, Number, Number) → Number</strong>
const sum3 = (a: number, b: number, c: number) =&gt; a + b +
  c;</pre>
			<p>Remember that <strong class="source-inline">sum3c()</strong> is actually <strong class="source-inline">(a) =&gt; (b) =&gt; (c) =&gt; a + b + c</strong>; this explains the first signature, which can also be read <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// <strong class="bold">sum3C :: Number → (Number → (Number → (Number)))</strong>
const sum3C = curry(
  (a: number, b: number, c: number): number =&gt; a + b + c
);</pre>
			<p>After you provide the first argument to the function, you are left with a new function, which also expects an argument and returns a third function, which, when given an argument, will produce the final result. We won’t be using parentheses because we’ll always assume this<a id="_idIndexMarker972"/> grouping from right <span class="No-Break">to left.</span></p>
			<p>Now, what about higher-order functions, which receive functions as arguments? The <strong class="source-inline">map()</strong> function poses a problem: it works with arrays of any type. Also, the mapping function can produce any type of result. For these cases, we can specify generic types, identified by lowercase letters. These generic types can stand for any possible type. For arrays themselves, we use brackets. So, we would have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// <strong class="bold">map :: [a] → (a → b) → [b]</strong>
const map = curry(&lt;A, B&gt;(arr: A[], fn: (x: A) =&gt; B) =&gt;
  arr.map(fn)
);</pre>
			<p>It’s perfectly valid to have <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> represent the same type, as in a mapping that’s applied to an array of numbers, which produces another array of numbers. The point is that, in principle, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> may stand for different types, which we described previously. This definition requires using generic types in TypeScript, <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> in <span class="No-Break">our case.</span></p>
			<p>Note that if we weren’t currying, the signature would have been <strong class="source-inline">([a], (a → b)) → [b]</strong>, showing a function that receives two arguments (an array of elements of type <strong class="source-inline">a</strong> and a function that maps from type <strong class="source-inline">a</strong> to type <strong class="source-inline">b</strong>) and produces an array of elements of type <strong class="source-inline">b</strong> as <span class="No-Break">its result.</span></p>
			<p>We can similarly write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// <strong class="bold">filter :: [a] → (a → Boolean) → [a]</strong>
const filter = curry(&lt;A&gt;(arr: A[], fn: (x: A) =&gt; B) =&gt;
  arr.filter(fn)
);</pre>
			<p>And now the big one: what’s the signature for <strong class="source-inline">reduce()</strong>? Be sure to read it carefully and see whether you can work out why it’s written that way. You may prefer thinking about the second part of the signature as if it were <strong class="source-inline">((b, a) → </strong><span class="No-Break"><strong class="source-inline">b)</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// <strong class="bold">reduce :: [a] → (b → a → b) → b → b</strong>
const reduce = curry(
  &lt;A, B&gt;(arr: A[], fn: (a: B, v: A) =&gt; B, acc: B) =&gt;
    arr.reduce(fn, acc)
);</pre>
			<p>Finally, if you are defining a<a id="_idIndexMarker973"/> method instead of a function, you use a squiggly arrow such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">~&gt;</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// <strong class="bold">String.repeat :: String </strong><strong class="bold">⇝</strong><strong class="bold"> Number → String</strong></pre>
			<p>So far, we have defined data types for functions, but we aren’t done with this subject. Let’s consider some <span class="No-Break">other cases.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Other data type options</h2>
			<p>What else are we missing? Let’s look <a id="_idIndexMarker974"/>at some other options that you might use. <em class="italic">Product types</em> are a sets of values that are always together and are commonly used with objects. For <em class="italic">tuples</em> (that is, arrays with a fixed number of elements of (probably) different types), we can write something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// <strong class="bold">getWeekAndDay :: String → (Number × String)</strong>
const getWeekAndDay = (
  yyyy_mm_dd: string
): [number, string] =&gt; {
  let weekNumber: number;
  let dayOfWeekName: string;
  .
  .
  .
  return [weekNumber, dayOfWeekName];
};</pre>
			<p>For objects, we can go with a definition very similar to what JavaScript already uses. Let’s imagine we <a id="_idIndexMarker975"/>have a <strong class="source-inline">getPerson()</strong> function that receives an ID and returns an object with data about <span class="No-Break">a person:</span></p>
			<pre class="source-code">
// <strong class="bold">getPerson :: Number → { id:Number × name:String }</strong>
const getPerson = (
  personId: number
): { id: number; name: string } =&gt; {
  .
  .
  .
  return { id: personId, name: personName };
};</pre>
			<p><em class="italic">Sum types</em> (also known as <em class="italic">union types</em>) are defined as a list of possible values. For example, our <strong class="source-inline">getField()</strong> function from <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, returns either the value of an attribute or <strong class="source-inline">undefined</strong>. For this, we can write the <span class="No-Break">following signature:</span></p>
			<pre class="source-code">
// <strong class="bold">getField :: String → Object → a | undefined</strong>
const getField =
  &lt;A&gt;(attr: string) =&gt;
  (obj: { [key: string]: A }) =&gt;
    obj[attr];</pre>
			<p>We could also define a type (union or otherwise) and use it in further definitions. For instance, the data types that can be directly compared and sorted are numbers, strings, and Booleans, so we could write the <span class="No-Break">following definitions:</span></p>
			<pre class="source-code">
// <strong class="bold">Sortable :: Number | String | Boolean</strong></pre>
			<p>Afterward, we could specify that a comparison function can be defined in terms of the <strong class="source-inline">Sortable</strong> type, but be<a id="_idIndexMarker976"/> careful: there’s a hidden <span class="No-Break">problem here!</span></p>
			<pre class="source-code">
// <strong class="bold">compareFunction :: (Sortable, Sortable) → Number</strong></pre>
			<p>The previous definition would allow us to write a function that received, say, a <strong class="source-inline">number</strong> and a <strong class="source-inline">Boolean</strong>. It doesn’t say that both types should be the same. However, there’s a way out. If you have constraints for some data types, you can express them before the actual signature, using a fat arrow, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// <strong class="bold">compareFunction :: Sortable a </strong><strong class="bold">⇒</strong><strong class="bold"> (a, a) → Number</strong></pre>
			<p>The definition is now correct because all occurrences of the same type (denoted by the same letter, in this case, <strong class="source-inline">a</strong>) must be exactly the same. An alternative, but one that requires much more typing, would have been to write all three possibilities with <span class="No-Break">a union:</span></p>
			<pre class="source-code">
// <strong class="bold">compareFunction ::</strong>
//    <strong class="bold">((Number, Number) |</strong>
//    <strong class="bold">(String, String)  |</strong>
//    <strong class="bold">(Boolean, Boolean)) → Number</strong></pre>
			<p>Actually, this definition isn’t very precise because you can compare any type, even if it doesn’t make much sense. However, bear with me for the sake of this example! If you want to refresh your memory about sorting and comparison functions, <span class="No-Break">see </span><a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"><span class="No-Break">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</span></a><span class="No-Break">.</span></p>
			<p>So far, we have been using the standard type definitions. However, when working with JavaScript, we have to consider other possibilities, such as functions with optional parameters, or even with an undetermined number of parameters. We can use <strong class="source-inline">...</strong> to stand for any number of arguments and add <strong class="source-inline">?</strong> to represent an optional type, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// <strong class="bold">unary :: ((b, ...) → a) → (b → a)</strong></pre>
			<p>The <strong class="source-inline">unary()</strong> higher-order function we defined in the same chapter we cited previously took any function as a parameter and returned a unary function as its result. We can show that<a id="_idIndexMarker977"/> the original function can receive any number of arguments but that the result used only the first. The data type definition for this would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// <strong class="bold">parseInt :: (String, Number?) → Number</strong></pre>
			<p>The standard <strong class="source-inline">parseInt()</strong> function provides an example of optional arguments, though it’s highly recommended that you don’t omit the second parameter (the base radix); you can, in fact, <span class="No-Break">skip it.</span></p>
			<p class="callout-heading">Fantastic definitions?</p>
			<p class="callout">Check out <a href="http://github.com/fantasyland/fantasy-land/">github.com/fantasyland/fantasy-land/</a> and <a href="http://sanctuary.js.org/#types">sanctuary.js.org/#types</a> for a more formal definition and description of types, as applied <span class="No-Break">to JavaScript.</span></p>
			<p>From now on, throughout this chapter, we’ll not only be using TypeScript, but we will also be adding HM signatures to methods and functions, so you can get used to them. Let’s now change track and cover a highly important <span class="No-Break">topic: </span><span class="No-Break"><em class="italic">containers</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor226"/>Building containers</h1>
			<p>Back in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, and later, in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>, we saw that the ability to apply a mapping to all the elements of an array—and even better, being able to chain a <a id="_idIndexMarker978"/>sequence of similar operations—was an excellent way to produce better, more <span class="No-Break">understandable code.</span></p>
			<p>However, there is a problem: the <strong class="source-inline">map()</strong> method (or the equivalent, demethodized one, which we looked at in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>) is only available for arrays, and we might want to be able to apply mappings and chaining to other data types. So, what can <span class="No-Break">we do?</span></p>
			<p>Let’s consider different ways of doing this, which will give us several new tools for better functional coding. Basically, there are only two possible ways of solving this: we can either add new methods to existing types (though that will be limited because we can only apply that to basic JavaScript types) or wrap types in some type of container, which will allow mapping <span class="No-Break">and chaining.</span></p>
			<p>Let’s start by extending<a id="_idIndexMarker979"/> current types before moving on to using wrappers, which will lead us into the deep functional territory with entities such as functors <span class="No-Break">and monads.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor227"/>Extending current data types</h2>
			<p>If we want to add <a id="_idIndexMarker980"/>mapping to basic JavaScript data types, we need to start by considering <span class="No-Break">our options:</span></p>
			<ul>
				<li>With <strong class="source-inline">null</strong>, <strong class="source-inline">undefined</strong>, and <strong class="source-inline">Symbol</strong>, applying maps doesn’t sound <span class="No-Break">too interesting</span></li>
				<li>We have some interesting possibilities with <strong class="source-inline">Boolean</strong>, <strong class="source-inline">Number</strong>, and <strong class="source-inline">String</strong> data types, so we can examine some <span class="No-Break">of those</span></li>
				<li>Applying mapping to an object is trivial: we just have to add a <strong class="source-inline">map()</strong> method, which must return a <span class="No-Break">new object</span></li>
				<li>Finally, despite not being basic data types, we could also consider special cases, such as dates or functions, to which we could also add <span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break"> methods</span></li>
			</ul>
			<p>As in the rest of this book, we are sticking to plain JavaScript and TypeScript, but you should look into libraries such as Lodash, Underscore, or Ramda, which already provide functionalities similar to the ones we are <span class="No-Break">developing here.</span></p>
			<p>A key point to consider in all these mapping operations should be that the returned value is of the same type as the original one. When we use <strong class="source-inline">Array.map()</strong>, the result is also an array, and similar considerations must apply to any other <strong class="source-inline">map()</strong> method implementations (you could observe that the resulting array may have different element types to the original one, but it is still <span class="No-Break">an array).</span></p>
			<p>What could we do with a Boolean? First, let’s accept that Booleans are not containers, so they don’t really behave in the same way as an array. Trivially, a Boolean can only have a Boolean value, while an array may contain any type of element. However, accepting that difference, we can extend <strong class="source-inline">Boolean.prototype</strong> (though, as I’ve already mentioned, that’s not usually recommended) by adding a new <strong class="source-inline">map()</strong> method to it and making sure that whatever the mapping function returns is turned into a new Boolean value. For the latter, the solution will be similar to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// <strong class="bold">Boolean.map :: Boolean </strong><strong class="bold">⇝</strong><strong class="bold"> (Boolean → a) → Boolean</strong>
Boolean.prototype.map = function (
  this: boolean,
  fn: (x: boolean) =&gt; any
) {
  return !!fn(this);
};</pre>
			<p>We already saw examples of adding a (fake) <strong class="source-inline">this</strong> parameter to a method, to let TypeScript know what type <strong class="source-inline">this</strong> will be—in this case, a Boolean. The <strong class="source-inline">!!</strong> operator forces the result to<a id="_idIndexMarker981"/> be a Boolean. <strong class="source-inline">Boolean(fn(this))</strong> could also have been used. This kind of solution can also be applied to numbers and strings, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// <strong class="bold">Number.map :: Number </strong><strong class="bold">⇝</strong><strong class="bold"> (Number → a) → Number</strong>
Number.prototype.map = function (
  this: number,
  fn: (x: number) =&gt; number
) {
  return Number(fn(this));
};
// <strong class="bold">String.map :: String </strong><strong class="bold">⇝</strong><strong class="bold"> (String → a) → String</strong>
String.prototype.map = function (
  this: string,
  fn: (x: string) =&gt; string
) {
  return String(fn(this));
};</pre>
			<p>As with Boolean values, we <a id="_idIndexMarker982"/>are forcing the results of the mapping operations to the correct data types. By the way, TypeScript won’t directly accept any of these new <strong class="source-inline">map()</strong> definitions; see <em class="italic">Question 12.1</em> to <span class="No-Break">fix this.</span></p>
			<p>Finally, if we wanted to apply mappings to a function, what would that mean? Mapping a function should produce a function. The logical interpretation for <strong class="source-inline">f.map(g)</strong> would be applying <strong class="source-inline">f()</strong>, and then applying <strong class="source-inline">g()</strong> to the result. So, <strong class="source-inline">f.map(g)</strong> should be the same as writing <strong class="source-inline">x =&gt; g(f(x))</strong> or, equivalently, <strong class="source-inline">pipe(f,g)</strong>. The definition is more complex than it was for the previous examples (but, in my opinion, simpler in HM than with TypeScript), so study <span class="No-Break">it carefully:</span></p>
			<pre class="source-code">
// <strong class="bold">Function.map :: (a → b) </strong><strong class="bold">⇝</strong><strong class="bold"> (b → c) → (a → c)</strong>
Function.prototype.map = function &lt;A, B, C&gt;(
  this: (x: A) =&gt; B,
  fn: (y: B) =&gt; C
): (x: A) =&gt; C {
  return (x: A) =&gt; fn(this(x));
};</pre>
			<p>Verifying that this works is simple, and the following code is an easy example of how to do this. The <strong class="source-inline">times10()</strong> mapping function is applied to the result of calculating <strong class="source-inline">plus1(3)</strong>, so the result <span class="No-Break">is 40:</span></p>
			<pre class="source-code">
const plus1 = (x) =&gt; x + 1;
const times10 = (y) =&gt; 10 * y;
console.log(plus1.map(by10)(3));
// 40: first add 1 to 3, then multiply by 10</pre>
			<p>With this, we are done talking about what we can achieve with basic JavaScript types, but we need a more general solution if we want to apply this to other data types. We’d like to be able to apply <a id="_idIndexMarker983"/>mapping to any kind of value, and for that, we’ll need to create a container. We’ll do this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor228"/>Containers and functors</h2>
			<p>What we did in the previous <a id="_idIndexMarker984"/>section works and can be used without problems. However, we would like to consider a more general solution that we can apply to any<a id="_idIndexMarker985"/> data type. Since not all things in JavaScript provide the desired <strong class="source-inline">map()</strong> method, we will have to either extend the type (as we did in the previous section) or apply a design pattern that we considered in <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Implementing Design Patterns</em>: wrapping our data types with a wrapper that will provide the required <span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break"> operations.</span></p>
			<p>In particular, we will do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Start by seeing how to build a basic container, wrapping <span class="No-Break">a value</span></li>
				<li>Convert the container into something more <span class="No-Break">powerful—a functor</span></li>
				<li>Study how to deal with missing values using a special <span class="No-Break">functor, </span><span class="No-Break"><strong class="source-inline">Maybe</strong></span></li>
			</ul>
			<h3>Wrapping a value – a basic container</h3>
			<p>Let’s pause for a minute and <a id="_idIndexMarker986"/>consider what we need from this wrapper. There are two <span class="No-Break">basic requirements:</span></p>
			<ul>
				<li>We must have a <span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break"> method</span></li>
				<li>We need a simple way to wrap <span class="No-Break">a value</span></li>
			</ul>
			<p>To get started, let’s create a basic container. Any object containing just a value would do, but we want some<a id="_idIndexMarker987"/> additions, so our object won’t be that trivial; we’ll explain the differences after <span class="No-Break">the code:</span></p>
			<pre class="source-code">
// container.ts
class Container&lt;A&gt; {
  protected x: A;
  constructor(x: A) {
    this.x = x;
  }
  map(fn: (_: A) =&gt; any) {
    return fn(this.x);
  }
}</pre>
			<p>Some primary considerations that we need to keep in mind are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>We want to be able to store some value in a container, so the constructor takes care <span class="No-Break">of that.</span></li>
				<li>Using a <strong class="source-inline">protected</strong> attribute avoids “tinkering” from the outside, but allows access to subclasses. (See <em class="italic">Question 12.2</em> for some <span class="No-Break">JavaScript considerations.)</span></li>
				<li>We need to be able to <strong class="source-inline">map()</strong>, so a method is provided <span class="No-Break">for that.</span></li>
			</ul>
			<p>Our barebones container is ready, but we can also add some other methods for convenience, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>To get the value of a container, we could use <strong class="source-inline">map((x) =&gt; x)</strong>, but that won’t work with more complex containers, so we’ll add a <strong class="source-inline">valueOf()</strong> method to get the <span class="No-Break">contained value.</span></li>
				<li>Being able to list a container can undoubtedly help with debugging. The <strong class="source-inline">toString()</strong> method will come in handy <span class="No-Break">for this.</span></li>
				<li>Because we don’t need to write <strong class="source-inline">new Container()</strong> all the time, we can add a static <strong class="source-inline">of()</strong> method<a id="_idIndexMarker988"/> to do the <span class="No-Break">same job.</span></li>
			</ul>
			<p class="callout-heading">A functional sin?</p>
			<p class="callout">Working with classes to represent containers (and later, functors and monads) when living in a FP world may seem like heresy or sin... but remember that we don’t want to be dogmatic, and using classes simplifies our coding. Similarly, it could be argued that you must never take a value out of the container—but using a <strong class="source-inline">valueOf()</strong> method is sometimes too handy, so we won’t be <span class="No-Break">that restrictive.</span></p>
			<p>By taking all of this into account, our container is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
class Container&lt;A&gt; {
  protected x: A;
  constructor(x: A) {
    this.x = x;
  }
  static of&lt;B&gt;(x: B): Container&lt;B&gt; {
    return new Container(x);
  }
  map(fn: (_: A) =&gt; any) {
    return fn(this.x);
  }
  toString() {
    return `${this.constructor.name}(${this.x})`;
  }
  valueOf() {
    return this.x;
  }
}</pre>
			<p>Now, we can use this<a id="_idIndexMarker989"/> container to store a value, and <strong class="source-inline">map()</strong> to apply any function to that value, but this isn’t very different from what we could do with a variable! Let’s enhance this <span class="No-Break">a bit.</span></p>
			<h3>Enhancing our container – functors</h3>
			<p>We want to have<a id="_idIndexMarker990"/> wrapped values, so what exactly should <strong class="source-inline">map()</strong> return? If we want to be able to chain operations, the only logical answer is that it should return a new wrapped object. In true functional style, when we apply a mapping to a wrapped value, the result will be another wrapped value that we can keep <span class="No-Break">working on.</span></p>
			<p class="callout-heading">A map by any other name</p>
			<p class="callout">Instead of <strong class="source-inline">map()</strong>, this operation is<a id="_idIndexMarker991"/> sometimes called <strong class="source-inline">fmap()</strong>, standing for <em class="italic">functorial map</em>. The rationale for the name change was to avoid expanding the meaning of <strong class="source-inline">map()</strong>. However, since we are working in a language that supports reusing the name, we can <span class="No-Break">keep it.</span></p>
			<p>We can extend our <strong class="source-inline">Container</strong> class to implement this change and get ourselves an enhanced container: a <em class="italic">functor</em>. The <strong class="source-inline">of()</strong> and <strong class="source-inline">map()</strong> methods will <a id="_idIndexMarker992"/>require a small change. For this, we’ll be creating a new class, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// functor.ts
class Functor&lt;A&gt; extends Container&lt;A&gt; {
  static of&lt;B&gt;(x: B) {
    return new Functor(x);
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Functor&lt;B&gt; {
    return Functor.of(fn(this.x));
  }
}</pre>
			<p>Here, the <strong class="source-inline">of()</strong> method <a id="_idIndexMarker993"/>produces a <strong class="source-inline">Functor</strong> object, and so does the <strong class="source-inline">map()</strong> method. With these changes, we have just defined what a <em class="italic">functor</em> is in category theory! (Or, if you want to get really technical, a <em class="italic">pointed functor</em> because of the <strong class="source-inline">of()</strong> method—but let’s keep it simple.) We won’t go into the theoretical details, but roughly speaking, a functor is some container that allows us to apply <strong class="source-inline">map()</strong> to its contents, producing a new container of the same type. If this sounds familiar, it’s because you already know a functor: arrays! When you apply <strong class="source-inline">map()</strong> to an array, the result is a new array containing transformed (<span class="No-Break">mapped) values.</span></p>
			<p class="callout-heading">Extra requirements</p>
			<p class="callout">There are more requirements for functors. First, the contained values may be polymorphic (of any type), just like arrays. Second, a function must exist whose mapping produces the same contained value—<strong class="source-inline">(x) =&gt; x</strong> does this for us. Finally, applying two consecutive mappings must produce the same result as applying their composition. This means that <strong class="source-inline">container.map(f).map(g)</strong> must be the same <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">container.map(compose(g,f))</strong></span><span class="No-Break">.</span></p>
			<p>Let’s pause for a moment and consider the signatures for our function <span class="No-Break">and methods:</span></p>
			<pre class="source-code">
// of :: Functor f ⇒ a → f a
// Functor.toString :: Functor f ⇒ f a ⇝ String
// Functor.valueOf :: Functor f ⇒ f a ⇝ a
// Functor.map :: Functor f ⇒ f a ⇝ (a → b) → f b</pre>
			<p>The first function, <strong class="source-inline">of()</strong>, is the simplest: given a value of any type, it produces a functor of that type. The following two are also relatively simple to understand: given a functor, <strong class="source-inline">toString()</strong> always returns a string (no surprise there!), and if the functor-contained value is of a given type, <strong class="source-inline">valueOf()</strong> produces a result of that same type. The third one, <strong class="source-inline">map()</strong>, is more interesting. Given a function that takes an argument of type <strong class="source-inline">a</strong> and produces a result of type <strong class="source-inline">b</strong>, applying it to a functor that contains a value of type <strong class="source-inline">a</strong> produces a functor<a id="_idIndexMarker994"/> containing a value of type <strong class="source-inline">b</strong>. This is precisely what we <span class="No-Break">described previously.</span></p>
			<p class="callout-heading">Promises and Functors</p>
			<p class="callout">You could compare <a id="_idIndexMarker995"/>functors to promises, at least in one aspect. With functors, instead of acting on its value directly, you have to apply a function with <strong class="source-inline">map()</strong>. In promises, you do exactly the same, but using <strong class="source-inline">then()</strong> instead! In fact, there are more analogies, as we’ll be <span class="No-Break">seeing soon.</span></p>
			<p>As is, functors are not allowed or expected to produce side effects, throw exceptions, or exhibit any other behavior outside of producing a container-ed result. Their main usage is to provide us with a way to manipulate a value, apply operations to it, compose results, and so on, without changing the original value—in this sense, we are once again coming back <span class="No-Break">to immutability.</span></p>
			<p>However, you could reasonably say that this isn’t enough since, in everyday programming, it’s pretty common to have to deal with exceptions, undefined or null values, and so on. So, let’s start by looking at more examples of functors. After that, we’ll enter the realm of monads to look at even more sophisticated processing. Let’s experiment <span class="No-Break">a bit!</span></p>
			<h3>Dealing with missing values with Maybe</h3>
			<p>A common problem in programming is dealing with missing values. There are many possible causes for this situation: a web service Ajax call may have returned an empty result, a dataset could be <a id="_idIndexMarker996"/>empty, an optional attribute might be missing from an object, and so on. In a normal imperative fashion, dealing with this kind of situation requires adding <strong class="source-inline">if</strong> statements or ternary operators everywhere to catch the possible missing value to avoid a certain runtime error. We can do better by implementing a <strong class="source-inline">Maybe</strong> functor to represent a value that may (or may <em class="italic">not</em>) be present! We will use two classes, <strong class="source-inline">Just</strong> (as in <em class="italic">just some value</em>) and <strong class="source-inline">Nothing</strong>, both of which are functors. The <strong class="source-inline">Nothing</strong> functor is particularly simple, with <span class="No-Break">trivial methods:</span></p>
			<pre class="source-code">
// maybe.ts
class Nothing extends Maybe&lt;any&gt; {
  constructor() {
    super(null);
  }
  isNothing() {
    return true;
  }
  toString() {
    return "Nothing()";
  }
  map(_fn: FN) {
    return this;
  }
}</pre>
			<p>The <strong class="source-inline">isNothing()</strong> method returns <strong class="source-inline">true</strong>, <strong class="source-inline">toString()</strong> returns constant text, and <strong class="source-inline">map()</strong> always returns itself, no matter what function <span class="No-Break">it’s given.</span></p>
			<p>Moving forward, the <strong class="source-inline">Just</strong> functor is also a basic one, with the added <strong class="source-inline">isNothing()</strong> method (which always<a id="_idIndexMarker997"/> returns <strong class="source-inline">false</strong>, since a <strong class="source-inline">Just</strong> object isn’t <strong class="source-inline">Nothing</strong>), and a <strong class="source-inline">map()</strong> method that now <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">Maybe</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
class Just&lt;A&gt; extends Maybe&lt;A&gt; {
  static of&lt;B&gt;(x: B): Maybe&lt;B&gt; {
    if (x === null || x === undefined) {
      throw new Error("Just should have a value");
    } else {
      return new Just(x);
    }
  }
  isNothing() {
    return false;
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Just&lt;B&gt; {
    return new Just(fn(this.x));
  }
}</pre>
			<p>Finally, our <strong class="source-inline">Maybe</strong> class packs the logic needed to construct either <strong class="source-inline">Nothing</strong> or <strong class="source-inline">Just</strong>. If it receives an <strong class="source-inline">undefined</strong> or <strong class="source-inline">null</strong> value, <strong class="source-inline">Nothing</strong> will be constructed; in other cases, <strong class="source-inline">Just</strong> will <a id="_idIndexMarker998"/>be the result. The <strong class="source-inline">of()</strong> method has exactly the <span class="No-Break">same behavior:</span></p>
			<pre class="source-code">
// continued...
abstract class Maybe&lt;A&gt; extends Functor&lt;A&gt; {
  static of&lt;B&gt;(x: B): Maybe&lt;B&gt; {
    return x === null || x === undefined
      ? new Nothing()
      : new Just(x);
  }
  isNothing() {
    /* abstract */
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Maybe&lt;B&gt; {
    return Maybe.of(fn(this.x));
  }
}</pre>
			<p>We are using an <strong class="source-inline">abstract</strong> class because you shouldn’t directly write <strong class="source-inline">new Maybe(…)</strong>; you should use <strong class="source-inline">Maybe.of()</strong> or directly build <strong class="source-inline">Just</strong> or <strong class="source-inline">Nothing</strong>. (If you are wondering how to do this in JavaScript, see <em class="italic">Question 12.3</em>.) We can quickly verify that this works by trying to apply an operation to either a valid value or a missing one. Let’s look at two examples <span class="No-Break">of this:</span></p>
			<pre class="source-code">
const plus1 = x =&gt; x + 1;
Maybe.of(2209).map(plus1).map(plus1).toString();
// "Just(2211)"
Maybe.of(null).map(plus1).map(plus1).toString();
// "Nothing()"</pre>
			<p>When we applied <strong class="source-inline">plus1()</strong> (twice) to <strong class="source-inline">Maybe.of(2209)</strong>, everything worked fine, and we ended up with a <strong class="source-inline">Just(2011)</strong> value. On the other hand, when we applied the same sequence of operations to a <strong class="source-inline">Maybe.of(null)</strong> value, the end result was <strong class="source-inline">Nothing</strong>, but there were no errors, even if we tried to do math with a <strong class="source-inline">null</strong> value. A <strong class="source-inline">Maybe</strong> functor<a id="_idIndexMarker999"/> can deal with mapping a missing value by just skipping the operation and returning a wrapped <strong class="source-inline">null</strong> value instead. This means that this functor includes an abstracted check, which won’t let an <span class="No-Break">error happen.</span></p>
			<p>(Later in this chapter, we’ll see that <strong class="source-inline">Maybe</strong> can actually be a monad instead of a functor, and we’ll also examine more examples <span class="No-Break">of monads.)</span></p>
			<p>Let’s look at a more realistic example of <span class="No-Break">its usage.</span></p>
			<h4>Dealing with varying API results</h4>
			<p>Suppose we are <a id="_idIndexMarker1000"/>writing a small server-side service in Node.js to get the weather alerts for a city and produce a not-very-fashionable HTML <strong class="source-inline">&lt;table&gt;</strong> with them, to be part of some server-side-produced web page. (Yes, I know you should try to avoid tables in your pages, but I want a short example of HTML generation, and the actual results aren’t significant.) If we used the <em class="italic">Dark Sky</em> API (see <a href="http://darksky.net">darksky.net</a> for more on this API and how to register with it) to get the alarms, our code would be something like the following, all quite normal. Note the callback in case of an error; you’ll see why in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import request from "superagent";
const getAlerts = (
  lat: number,
  long: number,
  callback: FN
) =&gt; {
  const SERVER = "https://api.darksky.net/forecast";
  const UNITS = "units=si";
  const EXCLUSIONS = "exclude=minutely,hourly,daily,flags";
  const API_KEY = "you.need.to.get.your.own.api.key";
  request
    .get(
      `${SERVER}/${API_
        KEY}/${lat},${long}?${UNITS}&amp;${EXCLUSIONS}`
    )
    .end(function (err, res) {
      if (err) {
        callback({});
      } else {
        callback(JSON.parse(res.text));
      }
    });
};</pre>
			<p>The (heavily edited <a id="_idIndexMarker1001"/>and reduced in size) output of such a call might be something <span class="No-Break">like this:</span></p>
			<pre class="console">
{
  latitude: 29.76,
  longitude: -95.37,
  timezone: "America/Chicago",
  offset: -5,
  currently: {
    time: 1503660334,
    summary: "Drizzle",
    icon: "rain",
    temperature: 24.97,
    .
    .
    .
    uvIndex: 0,
  },
  alerts: [
    {
      title: "Tropical Storm Warning",
      regions: ["Harris"],
      severity: "warning",
      time: 1503653400,
      expires: 1503682200,
      description:
        "TROPICAL STORM WARNING REMAINS IN EFFECT... WIND -        LATEST LOCAL FORECAST: Below tropical storm force wind         ... CURRENT THREAT TO LIFE AND PROPERTY: Moderate ...        Locations could realize roofs peeled off buildings,        chimneys toppled, mobile homes pushed off foundations         or overturned ...",
      uri: "https://alerts.weather.gov/cap/wwacapget.php?x=      TX125862DD4F88.TropicalStormWarning.125862DE8808TX.      HGXTCVHGX.73ee697556fc6f3af7649812391a38b3",
    },
    .
    .
    .
    {
      title: "Hurricane Local Statement",
      regions: ["Austin", ... , "Wharton"],
      severity: "advisory",
      time: 1503748800,
      expires: 1503683100,
      description:
        "This product covers Southeast Texas **HURRICANE         HARVEY DANGEROUSLY APPROACHING THE TEXAS COAST** ...        The next local statement will be issued by the National         Weather Service in Houston/Galveston TX around 1030 AM         CDT, or sooner if conditions warrant.\n",
      uri: "https://alerts.weather.gov/...",
    },
  ],
};</pre>
			<p>I got this information for Houston, TX, US, on a day when Hurricane Harvey was approaching the state. If <a id="_idIndexMarker1002"/>you called the API on a normal day, the data would not include the <strong class="source-inline">alerts:[...]</strong> part. Here, we can use a <strong class="source-inline">Maybe</strong> functor to <a id="_idIndexMarker1003"/>process the received data without any problems, with or without <span class="No-Break">any alerts:</span></p>
			<pre class="source-code">
import os from "os";
const produceAlertsTable = (weatherObj: typeof resp) =&gt;
  Maybe.of(weatherObj)
    .map((w: typeof resp) =&gt; w.alerts)
    .map((a) =&gt;
      a.map(
        (x) =&gt;
          `&lt;tr&gt;&lt;td&gt;${x.title}&lt;/td&gt;` +
          `&lt;td&gt;${x.description.substr(0,
            500)}...&lt;/td&gt;&lt;/tr&gt;`
      )
    )
    .map((a) =&gt; a.join(os.EOL))
    .map((s) =&gt; `&lt;table&gt;${s}&lt;/table&gt;`);
getAlerts(29.76, -95.37, (x) =&gt;
  console.log(produceAlertsTable(x).valueOf())
);</pre>
			<p>Of course, you would probably do something more interesting than just logging the value of the contained result of <strong class="source-inline">produceAlertsTable()</strong>! The most likely option would be to use <strong class="source-inline">map()</strong> again with a function that would output the table, send it to a client, or do whatever you needed to do. In any case, the resulting output would look something <span class="No-Break">like this:</span></p>
			<pre class="console">
<strong class="bold">&lt;table&gt;&lt;tr&gt;&lt;td&gt;</strong>Tropical Storm Warning<strong class="bold">&lt;/td&gt;&lt;td&gt;</strong>...TROPICAL STORM WARNING REMAINS IN EFFECT... ...STORM SURGE WATCH REMAINS IN EFFECT... * WIND -
LATEST LOCAL FORECAST: Below tropical storm force wind - Peak Wind Forecast: 25-35 mph with gusts to 45 mph - CURRENT THREAT TO LIFE AND PROPERTY: Moderate - The wind threat has remained nearly steady from the previous assessment. - Emergency plans should include a reasonable threat for strong tropical storm force wind of 58 to 73 mph. - To be safe, earnestly prepare for the potential of significant...<strong class="bold">&lt;/td&gt;&lt;/tr&gt;</strong>
<strong class="bold">&lt;tr&gt;&lt;td&gt;</strong>Flash Flood Watch<strong class="bold">&lt;/td&gt;&lt;td&gt;</strong>...FLASH FLOOD WATCH REMAINS IN EFFECT
THROUGH MONDAY MORNING... The Flash Flood Watch continues for * Portions of Southeast Texas...including the following counties...Austin...Brazoria...Brazos...Burleson...
Chambers...Colorado...Fort Bend...Galveston...Grimes...
Harris...Jackson...Liberty...Matagorda...Montgomery...Waller... Washington and Wharton. * Through Monday morning * Rainfall from Harvey will cause devastating and life threatening flooding as a prolonged heavy rain and flash flood thre...<strong class="bold">&lt;/td&gt;&lt;/tr&gt;</strong>
<strong class="bold">&lt;tr&gt;&lt;td&gt;</strong>Hurricane Local Statement<strong class="bold">&lt;/td&gt;&lt;td&gt;</strong>This product covers Southeast
Texas **PREPARATIONS FOR HARVEY SHOULD BE RUSHED TO COMPLETION THIS MORNING** NEW INFORMATION --------------- * CHANGES TO WATCHES AND
WARNINGS: - None * CURRENT WATCHES AND WARNINGS: - A Tropical Storm Warning and Storm Surge Watch are in effect for Chambers and Harris - A Tropical Storm Warning is in effect for Austin, Colorado, Fort Bend, Liberty, Waller, and Wharton - A Storm Surge Warning and Hurricane Warning are in effect for Jackson and Matagorda - A Storm S...<strong class="bold">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</strong></pre>
			<p>The output of the preceding code can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_12.1_B9301.jpg" alt="Figure 12.1 – The output table is not much to look at, but the logic that produced it didn’t require a single if statement"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The output table is not much to look at, but the logic that produced it didn’t require a single if statement</p>
			<p>If we had called <strong class="source-inline">getAlerts(-34.9, -54.60, ...)</strong> with the coordinates for Montevideo, Uruguay, instead, since there were no alerts for that city, the <strong class="source-inline">getField("alerts")</strong> function would have returned <strong class="source-inline">undefined</strong>—and since that value is recognized<a id="_idIndexMarker1004"/> by the <strong class="source-inline">Maybe</strong> functor, and even though all the following <strong class="source-inline">map()</strong> operations would still be executed, no one would actually do anything, and a <strong class="source-inline">null</strong> value would be the <span class="No-Break">final result.</span></p>
			<p>We took advantage of this behavior when we coded the error logic. If an error occurs when calling the service, we would still call the original callback to produce a table but provide an empty object. Even if this result is unexpected, we would be safe because the same guards would avoid causing a <span class="No-Break">runtime error.</span></p>
			<p>As a final enhancement, we can add an <strong class="source-inline">orElse()</strong> method to provide a default value when no value is provided. The added method will return the default value if <strong class="source-inline">Maybe</strong> is <strong class="source-inline">Nothing</strong>, or the <strong class="source-inline">Maybe</strong> value <span class="No-Break">itself otherwise:</span></p>
			<pre class="source-code">
// continued...
class Maybe&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
<strong class="bold">  orElse(v: any) {</strong>
<strong class="bold">    /* abstract */</strong>
<strong class="bold">  }</strong>
}
class Nothing extends Functor&lt;any&gt; {
  .
  .
  .
<strong class="bold">  orElse(v: any) {</strong>
<strong class="bold">    return v;</strong>
<strong class="bold">  }</strong>
}
class Just&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
<strong class="bold">  orElse(v: any) {</strong>
<strong class="bold">    return this.x;</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Using this new method instead of <strong class="source-inline">valueOf()</strong>, trying to get the alerts for someplace without weather warnings would just return a default result. In the case we mentioned previously, attempting to get the alerts for Montevideo, instead of a <strong class="source-inline">null</strong> value, we would get the following <span class="No-Break">appropriate result:</span></p>
			<pre class="source-code">
getAlerts(-34.9, -54.6, (x) =&gt;
  console.log(
    produceAlertsTable(x)<strong class="bold">.orElse(</strong>
<strong class="bold">      "&lt;span&gt;No alerts today.&lt;/span&gt;"</strong>
<strong class="bold">    )</strong>
  )
);</pre>
			<p>With this, we have looked at<a id="_idIndexMarker1005"/> an example of dealing with different situations when working with an API. Let’s quickly revisit another topic from a previous chapter and look at a better implementation <span class="No-Break">of prisms.</span></p>
			<h4>Implementing prisms</h4>
			<p>The more common<a id="_idIndexMarker1006"/> implementations of prisms (which we first met in the <em class="italic">Prisms</em> section of <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><em class="italic">, Ensuring Purity</em>), instead of returning either some value or <strong class="source-inline">undefined</strong> and leaving it up to the caller to check what happened, opt to return <strong class="source-inline">Maybe</strong>, which already provides us with easy ways to deal with missing values. In our new implementation (which we’ll look at soon), our example from the aforementioned chapter would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const author = {
  user: "fkereki",
  name: {
    first: "Federico",
    middle: "",
    last: "Kereki",
  },
  books: [
    { name: "Google Web Toolkit", year: 2010 },
    { name: "Functional Programming", year: 2017 },
    { name: "Javascript Cookbook", year: 2018 },
  ],
};</pre>
			<p>If we wanted to <a id="_idIndexMarker1007"/>access the <strong class="source-inline">author.user</strong> attribute, the result would <span class="No-Break">be different:</span></p>
			<pre class="source-code">
const pUser = prismProp("user");
console.log(review(pUser, author).toString());
/*
<strong class="bold">Just("fkereki")</strong>
*/</pre>
			<p>Similarly, if we asked for a non-existent pseudonym attribute, instead of <strong class="source-inline">undefined</strong> (as in our previous version of <strong class="source-inline">Prism</strong>), we would <span class="No-Break">get </span><span class="No-Break"><strong class="source-inline">Nothing</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const pPseudonym = prismProp("pseudonym"); console.log(review(pPseudonym, author).toString());
/*
<strong class="bold">Nothing()</strong>
*/</pre>
			<p>So, this new version of <strong class="source-inline">Prism</strong> is better to work with if you are already used to dealing with <strong class="source-inline">Maybe</strong> values. What do we need to implement this? We need just a single change; our <strong class="source-inline">Constant</strong> class now needs to return <strong class="source-inline">Maybe</strong> instead of a value, so we’ll have a new <strong class="source-inline">ConstantP</strong> (<strong class="source-inline">P</strong> for <span class="No-Break"><strong class="source-inline">Prism</strong></span><span class="No-Break">) class:</span></p>
			<pre class="source-code">
class ConstantP&lt;V&gt; {
  <strong class="bold">private value: Maybe&lt;V&gt;</strong>;
  map: FN;
  constructor(v: V) {
    <strong class="bold">this.value = Maybe.of(v);</strong>
    this.map = () =&gt; this;
  }
}</pre>
			<p>We will have to rewrite <strong class="source-inline">preview()</strong> to use the new class, and that finishes <span class="No-Break">the change:</span></p>
			<pre class="source-code">
const preview = curry(
  (prismAttr, obj) =&gt;
    <strong class="bold">prismAttr((x) =&gt; new ConstantP(x))(obj).value</strong>
);</pre>
			<p>So, getting <strong class="source-inline">Prism</strong> to work with <strong class="source-inline">Maybe</strong> wasn’t that hard, and now we have a consistent way of dealing with possibly missing attributes. Working in this fashion, we can simplify our coding and avoid many tests for nulls and other similar situations. However, we may want to go beyond this; for<a id="_idIndexMarker1008"/> instance, we may want to know why there were no alerts: was it a service error? Or just a normal situation? Just getting null at the end isn’t enough, and to work with these new requirements, we will need to add some extra functionality to our functors (as we’ll see in the next section) and enter the domain <span class="No-Break">of </span><span class="No-Break"><em class="italic">monads</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor229"/>Monads</h2>
			<p>Monads have <a id="_idIndexMarker1009"/>weird fame among programmers. Well-known developer Douglas Crockford has famously spoken of a curse, maintaining that “<em class="italic">Once you happen to finally understand monads, you immediately lose the ability to explain them to other people! </em>” On a different note, if you decide to go back to the basics and read <em class="italic">Categories for the Working Mathematician</em> by Saunders Mac Lane (one of the creators of category theory), you may find a somewhat disconcerting explanation—which is not <span class="No-Break">too illuminating!</span></p>
			<p class="author-quote">A monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
			<p>The difference between monads and functors is that the former adds some extra functionality; we’ll see what functionality they add soon. Let’s start by looking at the new requirements before moving on and considering some common, useful monads. As with functors, we will have a basic monad, which you could consider an <em class="italic">abstract</em> version, and<a id="_idIndexMarker1010"/> specific <em class="italic">monadic types</em>, which are <em class="italic">concrete</em> implementations geared to solve <span class="No-Break">specific cases.</span></p>
			<p class="callout-heading">All you could want to read</p>
			<p class="callout">To read a precise and careful description of functors, monads, and their family (but leaning heavily to the theoretical side, with plenty of algebraic definitions to go around), try the <em class="italic">Fantasy Land Specification</em> at <a href="http://github.com/fantasyland/fantasy-land/">github.com/fantasyland/fantasy-land/</a>. Please don’t say we didn’t warn you: the alternative name for that page is <em class="italic">Algebraic </em><span class="No-Break"><em class="italic">JavaScript Specification</em></span><span class="No-Break">!</span></p>
			<h3>Adding operations</h3>
			<p>Let’s consider a <a id="_idIndexMarker1011"/>simple problem. Suppose you have the following pair of functions, working with <strong class="source-inline">Maybe</strong> functors: the first function tries to search for something (say, a client or a product) given its key, and the second attempts to extract some attribute from whatever we found (I’m being purposefully vague because the problem does not have anything to do with whatever objects or things we may be working with). Both functions produce <strong class="source-inline">Maybe</strong> results to avoid possible errors. We are using a mocked search function just to help us see the problem. For even keys, it returns fake data, and for odd keys, it throws an exception. The code for this search is <span class="No-Break">very simple:</span></p>
			<pre class="source-code">
const fakeSearchForSomething = (key: number) =&gt; {
  if (key % 2 === 0) {
    return { key, some: "whatever", other: "more data" };
  } else {
    throw new Error("Not found");
  }
};</pre>
			<p>Using this search, our <strong class="source-inline">findSomething()</strong> function will try to do a search and return <strong class="source-inline">Maybe.of()</strong> (a <strong class="source-inline">Just</strong>) for a successful call, or <strong class="source-inline">Maybe.of(null)</strong> (a <strong class="source-inline">Nothing</strong>) in case of <span class="No-Break">an error:</span></p>
			<pre class="source-code">
const findSomething = (key: number) =&gt; {
  try {
    const something = fakeSearchForSomething(key);
    <strong class="bold">return Maybe.of(something)</strong>;
  } catch (e) {
    <strong class="bold">return Maybe.of(null)</strong>;
  }
};</pre>
			<p>With this, we<a id="_idIndexMarker1012"/> could think of writing these two functions to do some searching, but not everything would be fine; can you see the <span class="No-Break">problem here?</span></p>
			<pre class="source-code">
const getSome = (something: any) =&gt;
  Maybe.of(something.map((x: any) =&gt; x.some));
const getSomeFromSomething = (key: number) =&gt;
  getSome(findSomething(key));</pre>
			<p>The problem in this sequence is that the output from <strong class="source-inline">getSome()</strong> is a <strong class="source-inline">Maybe</strong> value, which itself contains a <strong class="source-inline">Maybe</strong> value, so the result we want is double-wrapped, as we can see by executing a couple of calls, for an even number (which will return <strong class="source-inline">"whatever"</strong>) and for an odd number (which will be an error), <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const xxx = getSomeFromSomething(2222).valueOf().valueOf();
// <strong class="bold">"whatever"</strong>
const yyy = getSomeFromSomething(9999).valueOf().valueOf();
// <strong class="bold">undefined</strong></pre>
			<p>This problem can be easily solved in this toy problem if we avoid using <strong class="source-inline">Maybe.of()</strong> in <strong class="source-inline">getSome()</strong>, but this kind of issue can arise in many more complex ways. For instance, you could be building a <strong class="source-inline">Maybe</strong> out of an object, one of whose attributes happened to be a <strong class="source-inline">Maybe</strong>, and you’d end up in the same situation when accessing that attribute: you would end up with a <span class="No-Break">double-wrapped value.</span></p>
			<p>Now, we are going to look into <a id="_idIndexMarker1013"/>monads. A monad should provide the <span class="No-Break">following operations:</span></p>
			<ul>
				<li><span class="No-Break">A constructor.</span></li>
				<li>A function that inserts a value into a monad: our <span class="No-Break"><strong class="source-inline">of()</strong></span><span class="No-Break"> method.</span></li>
				<li>A function that allows us to chain operations: our <span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break"> method.</span></li>
				<li>A function that can remove extra wrappers: we will call it <strong class="source-inline">unwrap()</strong>. It will solve our preceding multiple wrapper problems. Sometimes, this function is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">flatten()</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>To simplify our coding, we will also have a function to chain calls and another function to apply functions, but we’ll get to those later. Let’s see what a monad looks like in actual JavaScript code. Data type specifications are very much like those for functors, so we won’t repeat <span class="No-Break">them here:</span></p>
			<pre class="source-code">
// monad.ts
class Monad&lt;A&gt; extends Functor&lt;A&gt; {
  static of&lt;B&gt;(x: B): Monad&lt;B&gt; {
    return new Monad(x);
  }
  map&lt;B&gt;(fn: (_: A) =&gt; B): Monad&lt;B&gt; {
    return new Monad(fn(this.x));
  }
  unwrap(): any {
    const myValue = this.x;
    return myValue instanceof Monad
      ? myValue.unwrap()
      : this;
  }
}</pre>
			<p>We use recursion to<a id="_idIndexMarker1014"/> successively remove wrappers until the wrapped value isn’t a container anymore. Using this method, we could avoid double wrapping easily, and we could rewrite our previous troublesome function <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const getSomeFromSomething = key =&gt; getSome(findSomething(key)).unwrap();</pre>
			<p>However, this sort of problem could reoccur at different levels. For example, if we were doing a series of <strong class="source-inline">map()</strong> operations, any intermediate results may end up double-wrapped. You could solve this by remembering to call <strong class="source-inline">unwrap()</strong> after each <strong class="source-inline">map()</strong>—note that you could do this even if it is not actually needed since the result of <strong class="source-inline">unwrap()</strong> would be the very same object (can you see why?). But we can do better! Let’s define a <strong class="source-inline">chain()</strong> operation (sometimes named <strong class="source-inline">flatMap()</strong> instead, which is a bit confusing since we already have another meaning for that; see <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, for more on this) that will do both things <span class="No-Break">for us:</span></p>
			<pre class="source-code">
// continued...
class Monad&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
  chain&lt;B&gt;(fn: (_: A) =&gt; B) {
    return this.map(fn).unwrap();
  }
}</pre>
			<p>There’s only one operation left. Suppose you have a curried function with two parameters—nothing<a id="_idIndexMarker1015"/> outlandish! What would happen if you provided that function to a <span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break"> operation?</span></p>
			<pre class="source-code">
const add = (x: number) =&gt; (y: number) =&gt; x + y;
// or curry((x,y) =&gt; x+y)
const something = Monad.of(2).<strong class="bold">map(add)</strong>;</pre>
			<p>What would <strong class="source-inline">something</strong> be? Given that we have only provided one argument to add, the result of that application will be a function—not just any function, though, but a wrapped one! (Since functions are first-class objects, there’s no logical obstacle to wrapping a function in a monad, is there?) What would we want to do with such a function? To be able to apply this wrapped function to a value, we’ll need a new method: <strong class="source-inline">ap()</strong>. What could its value be? In this case, it could either be a plain number or a number wrapped in a monad as a result of other operations. Since we can always map a plain number into a wrapped one with <strong class="source-inline">Map.of()</strong>, let’s have <strong class="source-inline">ap()</strong> work with a monad as its parameter; the new method would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
class Monad&lt;A&gt; extends Functor&lt;A&gt; {
  .
  .
  .
  ap&lt;B, C extends FN&gt;(this: Monad&lt;C&gt;, m: Monad&lt;B&gt;) {
    return m.map(this.x);
  }
}</pre>
			<p>With this, you could then do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const monad5 = something.ap(Monad.of(3));
console.log(monad5.toString())
// <strong class="bold">Monad(5)</strong></pre>
			<p>You can use monads to<a id="_idIndexMarker1016"/> hold values or functions and to interact with other monads and chaining operations as you wish. So, as you can see, there’s no big trick to monads, which are just functors with some extra methods. Now, let’s look at how we can apply them to our original problem and handle errors in a <span class="No-Break">better way.</span></p>
			<h3>Handling alternatives – the Either monad</h3>
			<p>Knowing that a value was <a id="_idIndexMarker1017"/>missing may be enough in some cases, but in others, you’ll want to be able to provide an explanation. We can get such an explanation if we use a different functor, which will take one of two possible values—one associated with a problem, error, or failure, and another associated with normal execution, <span class="No-Break">or success:</span></p>
			<ul>
				<li>A <em class="italic">left</em> value, which should be null, but if present, then it represents some special value (for example, an error message or a thrown exception) that cannot be <span class="No-Break">mapped over</span></li>
				<li>A <em class="italic">right</em> value, which represents the normal value of the functor and can be <span class="No-Break">mapped over</span></li>
			</ul>
			<p>We can construct this monad similarly to what we did for <strong class="source-inline">Maybe</strong> (actually, the added operations make it better for <strong class="source-inline">Maybe</strong> to extend <strong class="source-inline">Monad</strong> as well). The constructor will receive a left and a right value. If the left value is present, it will become the value of the <strong class="source-inline">Either</strong> monad; otherwise, the right value will be used. Since we have provided <strong class="source-inline">of()</strong> methods for all our functors, we need one for <strong class="source-inline">Either</strong> too. The <strong class="source-inline">Left</strong> monad is very similar to our <span class="No-Break">previous </span><span class="No-Break"><strong class="source-inline">Nothing</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// either.ts
class Left extends Monad&lt;any&gt; {
  isLeft() {
    return true;
  }
  map(_: any) {
    return this;
  }
}</pre>
			<p>Similarly, <strong class="source-inline">Right</strong> resembles <a id="_idIndexMarker1018"/>our <span class="No-Break">previous </span><span class="No-Break"><strong class="source-inline">Just</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
class Right&lt;A&gt; extends Monad&lt;A&gt; {
  isLeft() {
    return false;
  }
  map(fn: (_: A) =&gt; any) {
    return Either.of(null, fn(this.x));
  }
}</pre>
			<p>And with these two monads under our belt, we can write our <strong class="source-inline">Either</strong> monad. It shouldn’t be surprising that <a id="_idIndexMarker1019"/>this resembles our previous <strong class="source-inline">Maybe</strong>, <span class="No-Break">should it?</span></p>
			<pre class="source-code">
// continued...
abstract class Either&lt;A, B&gt; extends Monad&lt;A | B&gt; {
  static of&lt;C, D&gt;(left: C, right?: D): Left | Right&lt;D&gt; {
    return right === undefined || right === null
      ? new Left(left)
      : new Right(right);
  }
  isLeft() {
    /* */
  }
}</pre>
			<p>The <strong class="source-inline">map()</strong> method is key. If this functor has got a left value, it won’t be processed any further; in other cases, the mapping will be applied to the right value, and the result will be wrapped. Now, how can we enhance our code with this? The key idea is for every involved method to return an <strong class="source-inline">Either</strong> monad; <strong class="source-inline">chain()</strong> will be used to execute operations one after another. Getting the alerts would be the first step—we invoke the callback either with an <strong class="source-inline">AJAX FAILURE</strong> message or with the result from the API call, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const getAlerts2 = (lat, long, callback) =&gt; {
  const SERVER = "https://api.darksky.net/forecast";
  const UNITS = "units=si";
  const EXCLUSIONS = "exclude=minutely,hourly,daily,flags";
  const API_KEY = "you.have.to.get.your.own.key";
  request
    .get(
      `${SERVER}/${API_KEY}/${lat},${long}` +
        `?${UNITS}&amp;${EXCLUSIONS}`
    )
    .end((err, res) =&gt;
      callback(
        err
          ? Either.of("AJAX FAILURE", null)
          : Either.of(null, JSON.parse(res.text))
      )
    );
};</pre>
			<p>Then, the general process would be as follows. We use an <strong class="source-inline">Either</strong> monad again. If there are no alerts, instead <a id="_idIndexMarker1020"/>of an array, we will return a <strong class="source-inline">"NO </strong><span class="No-Break"><strong class="source-inline">ALERTS"</strong></span><span class="No-Break"> message:</span></p>
			<pre class="source-code">
const produceAlertsTable2 = (weatherObj: typeof resp) =&gt; {
  return weatherObj
    .chain((obj: typeof resp) =&gt; {
      const alerts = getField("alerts")(obj);
      return alerts
        ? Either.of(null, alerts)
        : Either.of("NO ALERTS", null);
    })
    .chain((a) =&gt;
      a.map(
        (x) =&gt;
          `&lt;tr&gt;&lt;td&gt;${x.title}&lt;/td&gt;` +
          `&lt;td&gt;${x.description.substr(0,
            500)}...&lt;/td&gt;&lt;/tr&gt;`
      )
    )
    .chain((a) =&gt; a.join(os.EOL))
    .chain((s) =&gt; `&lt;table&gt;${s}&lt;/table&gt;`);
};</pre>
			<p>Note how we used <strong class="source-inline">chain()</strong> so that multiple wrappers would be no problem. Now, we can test multiple situations and get appropriate results—or at least, for the current weather situation <a id="_idIndexMarker1021"/>around <span class="No-Break">the world!</span></p>
			<ul>
				<li>For Houston, TX, we still get an <span class="No-Break">HTML table</span></li>
				<li>For Montevideo, UY, we get a text saying there were <span class="No-Break">no alerts</span></li>
				<li>For a point with wrong coordinates, we learn that the AJAX call <span class="No-Break">failed: nice!</span></li>
			</ul>
			<pre class="source-code">
// Houston, TX, US:
getAlerts2(29.76, -95.37, (x) =&gt;
  console.log(produceAlertsTable2(x).toString())
);
// Right("...a table with alerts: lots of HTML code...");
// Montevideo, UY
getAlerts2(-34.9, -54.6, (x) =&gt;
  console.log(produceAlertsTable2(x).toString())
);
// Left("NO ALERTS");
// A point with wrong coordinates
getAlerts2(444, 555, (x) =&gt;
  console.log(produceAlertsTable2(x).toString())
);
// Left("AJAX FAILURE");</pre>
			<p>We are not done<a id="_idIndexMarker1022"/> with the <strong class="source-inline">Either</strong> monad. It’s likely that much of your code will involve calling functions. Let’s look at a better way of achieving this by using a variant of <span class="No-Break">this monad.</span></p>
			<h3>Calling a function – the Try monad</h3>
			<p>If we are calling<a id="_idIndexMarker1023"/> functions that may throw exceptions and we want to do so in a functional way, we could use the <strong class="source-inline">Try</strong> monad to encapsulate the function result or the exception. The idea is basically the same as the <strong class="source-inline">Either</strong> monad. The only difference is in the constructor, which receives a function and <span class="No-Break">calls it:</span></p>
			<ul>
				<li>If there are no problems, the returned value becomes the <strong class="source-inline">right</strong> value for <span class="No-Break">the monad</span></li>
				<li>If there’s an exception, it will become the <span class="No-Break"><strong class="source-inline">left</strong></span><span class="No-Break"> value</span></li>
			</ul>
			<p>This can be seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// try.ts
class Try&lt;A&gt; extends Either&lt;A, string&gt; {
  // @ts-expect-error Call to super() not needed
  constructor(fn: () =&gt; A, msg?: string) {
    try {
      return Either.of(null, fn()) as Either&lt;A, string&gt;;
    } catch (e: any) {
      return Either.of(msg || e.message, null) as Either&lt;
        string,
        string
      &gt;;
    }
  }
}</pre>
			<p>Why the <strong class="source-inline">@ts-expect-error</strong> notation? A constructor should either call <strong class="source-inline">super()</strong> or return a fully constructed method, but TypeScript always expects the former, so we have to tell it that we know<a id="_idIndexMarker1024"/> what we’re <span class="No-Break">doing here.</span></p>
			<p>Now, we can invoke any function, catching exceptions in a good way. For example, the <strong class="source-inline">getField()</strong> function that we have been using would crash if it were called with a <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> argument:</span></p>
			<pre class="source-code">
const getField = attr =&gt; obj =&gt; obj[attr];</pre>
			<p>In the <em class="italic">Implementing prisms</em> section of <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, we wrote a <strong class="source-inline">getFieldP()</strong> function that could deal with <strong class="source-inline">null</strong> values, but here, we will rewrite it using the <strong class="source-inline">Try</strong> monad, so, in addition, it will play nice with other composed functions. The alternative implementation of our getter would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const getField2 = (attr: string) =&gt; (obj: OBJ | null) =&gt;
  new Try(() =&gt; obj![attr], "NULL OBJECT");</pre>
			<p>We can check that this works by trying to apply our new function to a <span class="No-Break">null value:</span></p>
			<pre class="source-code">
const x = getField2("somefield")(null);
console.log(x.isLeft()); // true
console.log(x.toString()); // Left(NULL OBJECT)</pre>
			<p>There are many more monads, and, of course, you can even define your own, so we couldn’t possibly go over all of them. However, let’s visit just one more—one you have been using already, without <a id="_idIndexMarker1025"/>being aware of <span class="No-Break">its monad-ness!</span></p>
			<h3>Unexpected monads – promises</h3>
			<p>Let’s finish this section on monads by mentioning yet another one that you may have used, though under a<a id="_idIndexMarker1026"/> different name: promises! Previously, we mentioned that functors (and, remember, monads are functors) had at least something in common with promises: using a method to access the value. However, the similarities are greater <span class="No-Break">than that!</span></p>
			<ul>
				<li><strong class="source-inline">Promise.resolve()</strong> corresponds with <strong class="source-inline">Monad.of()</strong>—if you pass a value to <strong class="source-inline">.resolve()</strong>, you’ll get a promise resolved to that value, and if you provide a promise, you will get a new promise, the value of which will be that of the original one (see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve</a> for more on this). This is an <span class="No-Break">unwrapping behavior!</span></li>
				<li><strong class="source-inline">Promise.then()</strong> stands for <strong class="source-inline">Monad.map()</strong> as well as <strong class="source-inline">Monad.chain()</strong>, given the <span class="No-Break">mentioned unwrapping.</span></li>
			</ul>
			<p>We don’t have a direct match to <strong class="source-inline">Monad.ap()</strong>, but we could add something like the following code (this will be rejected by TypeScript, but we’ve seen how to <span class="No-Break">solve this):</span></p>
			<pre class="source-code">
Promise.prototype.ap = function (promise2) {
  return this.then((x) =&gt; promise2.map(x));
};</pre>
			<p class="callout-heading">Promises – never gone</p>
			<p class="callout">Even if you opt for the modern <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> features, internally, they are based on promises. Furthermore, in some situations, you may still need <strong class="source-inline">Promise.race()</strong> and <strong class="source-inline">Promise.all()</strong>, so you will likely keep using promises, even if you opt for full <span class="No-Break">ES8 coding.</span></p>
			<p>This is an appropriate ending for this section. Earlier, you found that ordinary arrays were, in fact, functors. Now, in the same way that Monsieur Jourdain (a character in Molière’s play <em class="italic">Le Bourgeois Gentilhomme</em>, <em class="italic">The Bourgeois Gentleman</em>) discovered that all his life he had been speaking in prose, you now know you had already been using monads without <a id="_idIndexMarker1027"/>even knowing it! So far, we have learned how to build different types of containers. Now, let’s learn how functions can also make do as containers, as well as for all kinds of <span class="No-Break">data structures!</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor230"/>Functions as data structures</h1>
			<p>So far, we have learned <a id="_idIndexMarker1028"/>how to use functions to work with or transform other functions to process data structures or to create data types. Now, we’ll finish this chapter by showing you how a function can implement a data type, becoming a container of its own. In fact, this is a fundamental theoretical point of lambda calculus (if you want to learn more, look up <em class="italic">Church encoding</em> and <em class="italic">Scott encoding</em>), so we may very well say that we have come back to where we began this book, to the origins of FP! We will start with a detour that considers binary trees in a different functional language, Haskell, and then move on to implementing trees as functions, but in JavaScript. This experience will help you work out how to deal with other <span class="No-Break">data structures.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor231"/>Binary trees in Haskell</h2>
			<p>Consider a binary tree. Such a tree <a id="_idIndexMarker1029"/>may either be empty or consist of a node (the tree <em class="italic">root</em>) with two children: a <em class="italic">left</em> binary tree and a <em class="italic">right</em> one. A node that has<a id="_idIndexMarker1030"/> no children is called <span class="No-Break">a </span><span class="No-Break"><em class="italic">leaf</em></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Of many types of trees</p>
			<p class="callout">In <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Designing Functions</em>, we worked with more general tree structures, such as a filesystem or the browser DOM itself, which allow a node to have any number of children. In the case of the trees in this section, each node always has two children, although each of them may be empty. The difference may seem minor, but allowing for empty subtrees lets you define that all nodes <span class="No-Break">are binary.</span></p>
			<p>Let’s make a digression with the Haskell language. In it, we might write something like the following; <strong class="source-inline">a</strong> would be the type of whatever value we hold in <span class="No-Break">the nodes:</span></p>
			<pre class="source-code">
data Tree a = Nil | Node a (Tree a) (Tree a)</pre>
			<p>In the Haskell language, pattern matching is often used for coding. For example, we could define an empty function <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
empty :: Tree a -&gt; Bool empty Nil = True
empty (Node root left right) = False</pre>
			<p>What does this mean? Apart <a id="_idIndexMarker1031"/>from the data type definition, the logic is simple: if the tree is <strong class="source-inline">Nil</strong> (the first possibility in the definition of the type), then the tree is certainly empty; otherwise, the tree isn’t empty. The last line would probably be written as <strong class="source-inline">empty _ = False</strong>, using <strong class="source-inline">_</strong> as a placeholder because you don’t actually care about the components of the tree; the mere fact that it’s not <span class="No-Break"><strong class="source-inline">Nil</strong></span><span class="No-Break"> suffices.</span></p>
			<p>Searching for a value in a binary search tree (in which the root is greater than all the values of its left subtree and less than all the values of its right subtree) would be <span class="No-Break">written similarly:</span></p>
			<pre class="source-code">
contains :: (Ord a) =&gt; (Tree a)
     -&gt; a -&gt; Bool contains Nil _ = False
contains (Node root left right) x
| x == root = True
| x   &lt; root = contains left x
| x   &gt; root = contains right x</pre>
			<p>What patterns are matched here? We have four patterns now, which must be considered <span class="No-Break">in order:</span></p>
			<ol>
				<li>An empty tree (<strong class="source-inline">Nil</strong>—it doesn’t matter what we are looking for, so just write <strong class="source-inline">_</strong>) doesn’t contain the <span class="No-Break">searched value.</span></li>
				<li>If the tree isn’t empty, and the root matches the searched value (<strong class="source-inline">x</strong>), we <span class="No-Break">are done.</span></li>
				<li>If the root doesn’t match and is greater than the searched value, the answer is found while searching in the <span class="No-Break">left subtree.</span></li>
				<li>Otherwise, the answer is found by searching in the <span class="No-Break">right subtree.</span></li>
			</ol>
			<p>There’s an important point to remember: for this data type, which is a union of two possible types, we have to provide two conditions, and pattern matching will be used to decide which one will be<a id="_idIndexMarker1032"/> applied. Keep this <span class="No-Break">in mind!</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor232"/>Functions as binary trees</h2>
			<p>Can we do something<a id="_idIndexMarker1033"/> similar with functions? The answer is yes: we will represent a tree (or any other structure) with a function itself—not with a data structure that is processed by a set of functions, nor with an object with some methods, but by just a function. Furthermore, we will get a functional data structure that’s 100% immutable, which, if updated, produces a new copy of itself. We will do all this without using objects; here, closures will provide the <span class="No-Break">desired results.</span></p>
			<p>How can this work? We shall be applying similar concepts to the ones we looked at earlier in this chapter, so the function will act as a container and produce, as its result, a mapping of its contained values. Let’s walk backward and start by looking at how we’ll use the new data type. Then, we’ll go through the <span class="No-Break">implementation details.</span></p>
			<p>Creating a tree can be done by using two functions: <strong class="source-inline">EmptyTree()</strong> and <strong class="source-inline">Tree(value, leftTree, rightTree)</strong>. For example, let’s say we wish to create a tree similar to the one shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_12.2_B19301.jpg" alt="Figure 12.2 – A binary search tree﻿"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – A binary search tree</p>
			<p>We can create this using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// functionAsTree.ts
const myTree: TREE = NewTree(
  22,
  NewTree(
    9,
    NewTree(4, EmptyTree(), EmptyTree()),
    NewTree(12, EmptyTree(), EmptyTree())
  ),
  NewTree(
    60,
    NewTree(56, EmptyTree(), EmptyTree()),
    EmptyTree()
  )
);</pre>
			<p>How do you work with this structure? According to the data type description, whenever you work with a tree, you must consider two cases: a non-empty tree and an empty one. In the preceding<a id="_idIndexMarker1034"/> code, <strong class="source-inline">myTree()</strong> is a function that receives two functions as arguments, one for each of the two data type cases. The first function will be called with the node value and left and right trees as arguments, while the second function will <span class="No-Break">receive none:</span></p>
			<pre class="source-code">
// continued...
type TREE&lt;A&gt; = (
  _nonEmptyTree: (
    _x: A,
    _left: TREE&lt;A&gt;,
    _right: TREE&lt;A&gt;
  ) =&gt; any,
  _emptyTree: () =&gt; any
) =&gt; any;</pre>
			<p>To get the root of a tree, we could write something similar to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const myRoot = myTree(
<strong class="bold">  (value) =&gt; value,</strong>
<strong class="bold">  () =&gt; null</strong>
);</pre>
			<p>If we were dealing with a non-empty tree, we would expect the first function to be called and return the<a id="_idIndexMarker1035"/> value of the root. With an empty tree, the second function should be called, and then a <strong class="source-inline">null</strong> value would <span class="No-Break">be returned.</span></p>
			<p>Similarly, if we wanted to count how many nodes there are in a tree, we would write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const treeCount = &lt;A&gt;(tree: TREE&lt;A&gt;): number =&gt;
  tree(
<strong class="bold">    (value, left, right) =&gt;</strong>
<strong class="bold">      1 + treeCount(left) + treeCount(right),</strong>
<strong class="bold">    () =&gt; 0</strong>
  );
console.log(treeCount(myTree));</pre>
			<p>For non-empty trees, the first function would return <strong class="source-inline">1</strong> (for the root), plus the node count from both the root’s subtrees. For empty trees, the count is simply <strong class="source-inline">0</strong>. Get <span class="No-Break">the idea?</span></p>
			<p>Now, we can show the <strong class="source-inline">NewTree()</strong> and <strong class="source-inline">EmptyTree()</strong> functions. They are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const NewTree =
  &lt;A&gt;(value: A, left: TREE&lt;A&gt;, right: TREE&lt;A&gt;): TREE&lt;A&gt; =&gt;
  (destructure, _) =&gt;
    destructure(value, left, right);
const EmptyTree =
  &lt;A&gt;(): TREE&lt;A&gt; =&gt;
  (_, destructure) =&gt;
    destructure();</pre>
			<p>The <strong class="source-inline">destructure()</strong> function is what you will pass as an argument (the name comes from the destructuring statement in JavaScript, which lets you separate an object attribute into distinct variables). You will have to provide two versions of this function. If the tree is non-empty, the first function will be executed; for an empty tree, the second one will be run (this mimics the case selection in the Haskell code, except we are placing the non-empty tree case<a id="_idIndexMarker1036"/> first and the empty tree last). The underscore-named variable is used as a placeholder that stands for an otherwise-ignored argument but shows that two arguments are assumed; an initial underscore is usually meant to imply some parameter <span class="No-Break">isn’t used.</span></p>
			<p>This can be hard to understand, so let’s look at more examples. If we need to access specific elements of a tree, we have the following <span class="No-Break">three functions:</span></p>
			<pre class="source-code">
// continued...
const treeRoot = &lt;A&gt;(tree: TREE&lt;A&gt;): A | null =&gt;
  tree(
    (value, _left, _right) =&gt; value,
    () =&gt; null
  );</pre>
			<p>How can we decide whether a tree is empty? See whether you can figure out why the following short line of <span class="No-Break">code works:</span></p>
			<pre class="source-code">
// continued...
const treeIsEmpty = &lt;A&gt;(tree: TREE&lt;A&gt;): boolean =&gt;
  tree(
    () =&gt; false,
    () =&gt; true
  );</pre>
			<p>Let’s go over a few more <a id="_idIndexMarker1037"/>examples of this. For example, we can build an object out of a tree, which would help with debugging. I added logic to avoid including left or right empty subtrees, so the produced object would be more compact; check out the two <strong class="source-inline">if</strong> statements in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const treeToObject = &lt;A&gt;(tree: TREE&lt;A&gt;): OBJ =&gt;
  tree(
    (value, left, right) =&gt; {
      const leftBranch = treeToObject(left);
      const rightBranch = treeToObject(right);
      const result: OBJ = { value };
      if (leftBranch) {
        result.left = leftBranch;
      }
      if (rightBranch) {
        result.right = rightBranch;
      }
      return result;
    },
    () =&gt; null
  );</pre>
			<p>Note the usage of recursion, as in the <em class="italic">Traversing a tree structure</em> section of <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, Designing Functions, to produce the object equivalents of the left and right subtrees. An example of this function is as follows; I edited <a id="_idIndexMarker1038"/>the output to make <span class="No-Break">it clearer:</span></p>
			<pre class="source-code">
console.log(treeToObject(myTree));
/*
{
  value: 22,
  left: {
    value: 9,
    left: {
      value: 4,
    },
    right: { value: 12 },
  },
  right: {
    value: 60,
    left: {
      value: 56,
    },
  },
};
*/</pre>
			<p>Can we search for a node? Of course, and the logic closely follows the definition we saw in the previous section. (We could have shortened the code a bit, but I wanted to parallel the Haskell version; for <a id="_idIndexMarker1039"/>a leaner version, see <em class="italic">Question 12.6</em>.) Our <strong class="source-inline">treeSearch()</strong> function could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const treeSearch = &lt;A&gt;(
  findValue: A,
  tree: TREE&lt;A&gt;
): boolean =&gt;
  tree(
    (value, left, right) =&gt;
      findValue === value
        ? true
        : findValue &lt; value
        ? treeSearch(findValue, left)
        : treeSearch(findValue, right),
    () =&gt; false
  );</pre>
			<p>If the value we want is the root, we found it; if it’s smaller than the root, we recursively search the left subtree, and if greater, the <span class="No-Break">right subtree.</span></p>
			<p>To round off this section, let’s also look at how to add new nodes to a tree. Study the code carefully; you’ll notice how the current tree isn’t modified and that a new one is produced instead. Of course, given that we are using functions to represent our tree data type, it should be <a id="_idIndexMarker1040"/>evident that we wouldn’t have been able to modify the old structure: it’s immutable by default. The tree insertion function would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const treeInsert = &lt;A&gt;(
  newValue: A,
  tree: TREE&lt;A&gt;
): TREE&lt;A&gt; =&gt;
  tree(
    (value, left, right) =&gt;
      newValue &lt;= value
        ? NewTree(value, treeInsert(newValue, left), right)
        : NewTree(value, left, treeInsert(newValue,
          right)),
    () =&gt; NewTree(newValue, EmptyTree(), EmptyTree())
  );</pre>
			<p>When trying to insert a new key, if its value is less than or equal to the root of the tree, we produce a new tree that has the current root as its own root, maintains the old right subtree, but changes its left subtree to incorporate the new value (which will be done recursively). If the key was greater than the root, the changes wouldn’t have been symmetrical; they would have been analogous. If we try to insert a new key and find ourselves with an empty tree, we replace that empty structure with a new tree having the new value at its root, and empty left and <span class="No-Break">right subtrees.</span></p>
			<p>We can test out this logic easily, but the simplest way is to verify that the binary tree that we showed earlier (<span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em>) is generated by the following sequence <span class="No-Break">of operations:</span></p>
			<pre class="source-code">
let myTree = EmptyTree();
myTree = treeInsert(22, myTree);
myTree = treeInsert(9, myTree);
myTree = treeInsert(60, myTree);
myTree = treeInsert(12, myTree);
myTree = treeInsert(4, myTree);
myTree = treeInsert(56, myTree);
// The resulting tree is:
{
  value: 22,
  left: {
    value: 9,
    left: { value: 4 },
    right: { value: 12 },
  },
  right: { value: 60, left: { value: 56 } },
}</pre>
			<p>We could make this<a id="_idIndexMarker1041"/> insertion function even more general by providing the comparator function that would be used to compare values. In this fashion, we could easily adapt a binary tree to represent a generic map. The value of a node would actually be an object such as <strong class="source-inline">{key:... , data:...}</strong> and the provided function would compare <strong class="source-inline">newValue.key</strong> and <strong class="source-inline">value.key</strong> to decide where to add the new node. Of course, if the two keys were equal, we would change the root of the current tree. The new tree insertion code would be as follows. Let’s start with types <span class="No-Break">and comparisons:</span></p>
			<pre class="source-code">
// continued...
type NODE&lt;K, D&gt; = { key: K; data: D };
const compare = &lt;K, D&gt;(
  obj1: NODE&lt;K, D&gt;,
  obj2: NODE&lt;K, D&gt;
) =&gt;
  obj1.key === obj2.key ? 0 : obj1.key &lt; obj2.key ? -1 : 1;</pre>
			<p>The tree insertion <a id="_idIndexMarker1042"/>code is now <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const treeInsert2 = &lt;K, D&gt;(
  comparator: typeof compare&lt;K, D&gt;,
  newValue: NODE&lt;K, D&gt;,
  tree: TREE&lt;NODE&lt;K, D&gt;&gt;
): TREE&lt;NODE&lt;K, D&gt;&gt; =&gt;
  tree(
    (value, left, right) =&gt;
      comparator(newValue, value) === 0
        ? NewTree(newValue, left, right)
        : comparator(newValue, value) &lt; 0
        ? NewTree(
            value,
            treeInsert2(comparator, newValue, left),
            right
          )
        : NewTree(
            value,
            left,
            treeInsert2(comparator, newValue, right)
          ),
    () =&gt; NewTree(newValue, EmptyTree(), EmptyTree())
  );</pre>
			<p>What else do we need? Of<a id="_idIndexMarker1043"/> course, we can program diverse functions: deleting a node, counting nodes, determining a tree’s height, comparing two trees, and so on. However, in order to gain more usability, we should really turn the structure into a functor by implementing a <strong class="source-inline">map()</strong> function. Fortunately, using recursion, this proves to be easy—we apply the mapping function to the tree root and use <strong class="source-inline">map()</strong> recursively on the left and right subtrees, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const treeMap = &lt;A, B&gt;(
  fn: (_x: A) =&gt; B,
  tree: TREE&lt;A&gt;
): TREE&lt;B&gt; =&gt;
  tree(
    (value, left, right) =&gt;
      NewTree(
        fn(value),
        treeMap(fn, left),
        treeMap(fn, right)
      ),
    () =&gt; EmptyTree()
  );</pre>
			<p>We could go on with more examples, but that wouldn’t change the important conclusions we can derive from <span class="No-Break">this work:</span></p>
			<ul>
				<li>We are handling a data structure (a recursive one, at that) and representing it with <span class="No-Break">a function</span></li>
				<li>We aren’t using external variables or objects for the data: closures are <span class="No-Break">used instead</span></li>
				<li>The data structure satisfies all the requirements we analyzed in <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, insofar that it is immutable and all the changes always produce <span class="No-Break">new structures</span></li>
				<li>The tree is a functor, providing all the <span class="No-Break">corresponding advantages</span></li>
			</ul>
			<p>In this section, we<a id="_idIndexMarker1044"/> have looked at one more application of FP as well as how a function can actually become a structure by itself, which isn’t what we are usually <span class="No-Break">accustomed to!</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor233"/>Summary</h1>
			<p>In this chapter, we looked at the theory of data types and learned how to use and implement them from a functional point of view. We started with defining function signatures to help us understand the transformations implied by the multiple operations we looked at later, with a syntax independent from TypeScript’s. Then, we went on to define several containers, including functors and monads, and saw how they can be used to enhance function composition. Finally, we learned how functions can be directly used by themselves, with no extra baggage, to implement functional data structures to simplify dealing <span class="No-Break">with errors.</span></p>
			<p>In this book, we have looked at several features of FP for JavaScript and TypeScript. We started with some definitions, and a practical example, then moved on to important considerations such as pure functions, avoiding side effects, immutability, testability, building new functions out of other ones, and implementing a data flow based upon function connections and data containers. We have looked at a lot of concepts, but I’m confident that you’ll be able to put them to practice and start writing even higher-quality code—give it a try, and thank you very much for reading <span class="No-Break">this book!</span></p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor234"/>Questions</h1>
			<p>12.1 <strong class="bold">Extending prototypes</strong>: Whenever we added to a prototype, TypeScript would object because of a missing <strong class="source-inline">global</strong> declaration; can you add <span class="No-Break">that declaration?</span></p>
			<p>12.2 <strong class="bold">No protection?</strong> For all our containers, we use classes with a (TypeScript-only) protected attribute that didn’t allow accessing it from the “outside.” However, in the previous editions, we worked with plain JavaScript; how could we manage hiding the attribute from outsiders? A hint may help: think of <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Symbol</strong></span><span class="No-Break">!</span></p>
			<p>12.3 <strong class="bold">No abstract classes?</strong> We used abstract classes for the <strong class="source-inline">Maybe</strong> and <strong class="source-inline">Either</strong> monads, but those types of classes are only available in TypeScript. Can you figure out an alternative way of working, but <span class="No-Break">in JavaScript?</span></p>
			<p>12.4 <strong class="bold">Maybe tasks?</strong> In the <em class="italic">Questions</em> section of <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>, a question (<em class="italic">Question 8.2</em>) had to do with getting the pending tasks for a person while taking errors or border situations into account, such as the possibility that the selected person might not even exist. Redo that exercise but using a <strong class="source-inline">Maybe</strong> or <strong class="source-inline">Either</strong> monad to simplify <span class="No-Break">that code.</span></p>
			<p>12.5 <strong class="bold">Extending your trees</strong>: To get a more complete implementation of our functional binary search trees, implement the <span class="No-Break">following functions:</span></p>
			<ul>
				<li>Calculate the tree’s height or, equivalently, the maximum distance from the root to any <span class="No-Break">other node</span></li>
				<li>List all the tree’s keys, in <span class="No-Break">ascending order</span></li>
				<li>Delete a key from <span class="No-Break">a tree</span></li>
			</ul>
			<p>12.6 <strong class="bold">Code shortening</strong>: We mentioned that the <strong class="source-inline">treeSearch()</strong> function could be shortened—can you do that? Yes, this is more of a JavaScript problem than a functional one, and I’m not saying that shorter code is necessarily better, but many programmers act as if it were, so it’s good to be aware of such a style if only because you’re likely to <span class="No-Break">find it.</span></p>
			<p>12.7 <strong class="bold">Functional lists</strong>: In the same spirit as binary trees, implement functional lists. Since a list is defined to be either empty or a node (<em class="italic">head</em>), followed by another list (<em class="italic">tail</em>), you might want to start with the following, quite similar to our binary <span class="No-Break">search tree:</span></p>
			<pre class="source-code">
type LIST&lt;A&gt; = (
  _nonEmptyList: (_head: A, _tail: LIST&lt;A&gt;) =&gt; any,
  _emptyList: LIST&lt;A&gt;
) =&gt; any;
const NewList =
  &lt;A&gt;(head: A, tail: LIST&lt;A&gt;): LIST&lt;A&gt; =&gt;
  (f: FN, _g: FN) =&gt;
    f(head, tail);
const EmptyList =
  &lt;A&gt;(): LIST&lt;A&gt; =&gt;
  (f: FN, g: FN) =&gt;
    g();</pre>
			<p>Here are some easy one-line operations to get you started; note they are very similar in style to what we wrote for <span class="No-Break">binary trees:</span></p>
			<pre class="source-code">
const listHead = &lt;A&gt;(list: LIST&lt;A&gt;): A | null =&gt;
  list(
    (head: A, _tail: LIST&lt;A&gt;) =&gt; head,
    () =&gt; null
  );
const listTail = &lt;A&gt;(list: LIST): LIST&lt;A&gt; | null =&gt;
  list(
    (head: A, tail: LIST&lt;A&gt;) =&gt; tail,
    () =&gt; null
  );
const listIsEmpty = &lt;A&gt;(list: LIST&lt;A&gt;): boolean =&gt;
  list(
    (_head: A, _tail: LIST&lt;A&gt;) =&gt; false,
    () =&gt; true
  );
const listSize = &lt;A&gt;(list: LIST&lt;A&gt;): number =&gt;
  list(
    (head: A, tail: LIST&lt;A&gt;) =&gt; 1 + listSize(tail),
    () =&gt; 0
  );</pre>
			<p>You could consider having <span class="No-Break">these operations:</span></p>
			<ul>
				<li>Transforming a list into an array and <span class="No-Break">vice versa</span></li>
				<li>Reversing <span class="No-Break">a list</span></li>
				<li>Appending one list to the end of <span class="No-Break">another list</span></li>
				<li>Concatenating <span class="No-Break">two lists</span></li>
			</ul>
			<p>Don’t forget a <strong class="source-inline">listMap()</strong> function! Also, the <strong class="source-inline">listReduce()</strong> and <strong class="source-inline">listFilter()</strong> functions will come <span class="No-Break">in handy.</span></p>
			<p>12.8 <strong class="bold">No Boolean operators?</strong> Imagine we had the <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong> Boolean values, but we didn’t have any operators such as <strong class="source-inline">&amp;&amp;</strong>, <strong class="source-inline">||</strong>, or <strong class="source-inline">!</strong>. While we could make up for their absence with some (possibly repetitive) coding, we can have functions produce the same results; can you see how? Think along the same lines as for binary trees. We could represent a Boolean value by a function that takes a pair of functions as arguments and applies the first if the Boolean is true, and the <span class="No-Break">second otherwise.</span></p>
		</div>
	

		<div id="_idContainer078">
			<h1 id="_idParaDest-233"><a id="_idTextAnchor235"/>Answers to Questions</h1>
			<p>Here are the solutions (partial, or worked out in full) to the questions that were contained within the chapters in this book. In many cases, there are extra questions so that you can do further work if you <span class="No-Break">choose to.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/>Chapter 1, Becoming Functional – Several Questions</h1>
			<p>1.1 <strong class="bold">TypeScript, please!</strong> The following are the fully annotated versions of the code in the chapter. This is the code for the <span class="No-Break">factorial functions:</span></p>
			<pre class="source-code">
// question_01_typescript_please.ts
function fact(<strong class="bold">n: number</strong>)<strong class="bold">: number</strong> {
  if (n === 0) {
    return 1;
  } else {
    return n * fact(n - 1);
  }
}
const fact2 = (<strong class="bold">n: number</strong>)<strong class="bold">: number</strong> =&gt; {
  if (n === 0) {
    return 1;
  } else {
    return n * fact2(n - 1);
  }
};
const fact3 = (<strong class="bold">n: number</strong>)<strong class="bold">: number</strong> =&gt;
  n === 0 ? 1 : n * fact3(n - 1);</pre>
			<p>This is the code for the <span class="No-Break">spreading examples:</span></p>
			<pre class="source-code">
// continued...
function sum3(<strong class="bold">a: number, b: number, c: number</strong>)<strong class="bold">: number</strong> {
  return a + b + c;
}
const x<strong class="bold">: [number, number, number]</strong> = [1, 2, 3];
const y = sum3(...x); // equivalent to sum3(1,2,3)
const f = [1, 2, 3];
const g = [4, ...f, 5];
const h = [...f, ...g];
const p = { some: 3, data: 5 };
const q = { more: 8, ...p };
const numbers = [2, 2, 9, 6, 0, 1, 2, 4, 5, 6];
const minA = Math.min(...numbers); // 0
const maxArray = (arr<strong class="bold">: number[]</strong>) =&gt; Math.max(...arr);
const maxA = maxArray(numbers); // 9</pre>
			<p>Why do we need to specify the type of <strong class="source-inline">x</strong>, but not those of <strong class="source-inline">f</strong>, <strong class="source-inline">g</strong>, <strong class="source-inline">h</strong>, <strong class="source-inline">p</strong>, and <strong class="source-inline">q</strong>? The issue is that TypeScript checks the call to <strong class="source-inline">sum3()</strong>, and for that, it needs to be sure that <strong class="source-inline">x</strong> is defined to be an array with <span class="No-Break">three numbers.</span></p>
			<p>TypeScript would be able to deduce that <strong class="source-inline">sum3()</strong> returns a number, but it’s best if you specify it, to prevent possible future bugs where you would return something that isn’t <span class="No-Break">a number.</span></p>
			<p>The <strong class="source-inline">newCounter()</strong> function needs no type definitions; TypeScript is able to work types out. (See <em class="italic">Question 1.7</em> <span class="No-Break">further on.)</span></p>
			<p>1.2 <strong class="bold">Classes as first-class objects</strong>: As you may recall, a class is basically a function that can be used with <strong class="source-inline">new</strong>. Therefore, it stands to reason that we should be able to pass classes as parameters to other functions. <strong class="source-inline">makeSaluteClass()</strong> creates a class (that is, a special function) that uses a closure to remember the value of <strong class="source-inline">term</strong>. We have looked at more examples like this throughout <span class="No-Break">this book.</span></p>
			<p>The TypeScript code for the class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// question_01_classes_as_1st_class.ts
const makeSaluteClass = (term: string) =&gt;
  class {
    x: string;
    constructor(x: string) {
      this.x = x;
    }
    salute(y: string) {
      console.log(`${this.x} says "${term}" to ${y}`);
    }
  };
const Spanish = makeSaluteClass("HOLA");
new Spanish("ALFA").salute("BETA");
// ALFA says "HOLA" to BETA
new (makeSaluteClass("HELLO"))("GAMMA").salute("DELTA");
// GAMMA says "HELLO" to DELTA
const fullSalute = (
  c: ReturnType&lt;typeof makeSaluteClass&gt;,
  x: string,
  y: string
) =&gt; new c(x).salute(y);
const French = makeSaluteClass("BON JOUR");
fullSalute(French, "EPSILON", "ZETA");
// EPSILON says "BON JOUR" to ZETA</pre>
			<p>Note the usage of TypeScript’s <strong class="source-inline">ReturnType&lt;&gt;</strong> utility type to specify that <strong class="source-inline">c</strong> will be something created by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">makeSaluteClass()</strong></span><span class="No-Break">.</span></p>
			<p>1.3 <strong class="bold">Climbing factorial</strong>: The following code does the trick. We add an auxiliary variable, <strong class="source-inline">f</strong>, and we make it climb from <strong class="source-inline">1</strong> to <strong class="source-inline">n</strong>. We must be careful so that <strong class="source-inline">factUp(0) === </strong><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// question_01_climbing_factorial.ts
const factUp = (n: number, <strong class="bold">f = 1</strong>): number =&gt;
  n &lt;= f ? f : f * factUp(n, <strong class="bold">f + 1</strong>);</pre>
			<p>You don’t need to specify that <strong class="source-inline">f</strong> is of type <strong class="source-inline">number</strong>; TypeScript automatically works <span class="No-Break">that out.</span></p>
			<p>This solution may worry you because nobody prevents calling <strong class="source-inline">factUp()</strong> with two arguments – but we need the second parameter to be omitted, so it will be initialized to <strong class="source-inline">1</strong>. We can solve this defect <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const factUp2 = (n: number): number =&gt; {
  const factAux = (f: number): number =&gt;
    n &lt;= f ? f : f * factAux(f + 1);
  return factAux(1);
};</pre>
			<p>The internal <strong class="source-inline">factAux()</strong> function is basically our previous <strong class="source-inline">factUp()</strong> function, except that it doesn’t need the <strong class="source-inline">n</strong> parameter, because it’s available in its scope. Our new <strong class="source-inline">factUp2()</strong> function calls <strong class="source-inline">factAux()</strong>, providing its needed default value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<p>If you like having a default value, you can go with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const factUp3 = (n: number): number =&gt; {
  const factAux = (f = 1): number =&gt;
    n &lt;= f ? f : f * factAux(f + 1);
  return factAux();
};</pre>
			<p>To test these functions, the tests (for correct values) in <em class="italic">Question 1.5</em> <span class="No-Break">will do.</span></p>
			<p>1.4 <strong class="bold">Factorial errors</strong>: The key to avoiding repeating tests is to write a function that will check the value of the argument to ensure it’s valid, and if so, call an inner function to do the factorial itself, without worrying about <span class="No-Break">erroneous arguments:</span></p>
			<pre class="source-code">
// question_01_factorial_errors.ts
const carefulFact = (n: number): number | never =&gt; {
  if (
<strong class="bold">    typeof n === "number" &amp;&amp;</strong>
<strong class="bold">    n &gt;= 0 &amp;&amp;</strong>
<strong class="bold">    n === Math.floor(n)</strong>
  ) {
    const innerFact = (n: number): number =&gt;
      n === 0 ? 1 : n * innerFact(n - 1);
    return innerFact(n);
  } else {
    throw new Error("Wrong parameter for carefulFact2");
  }
};</pre>
			<p>In order, we check that <strong class="source-inline">n</strong> must be a number, not negative, and an integer. When an incorrect argument is recognized, we throw an error. By the way, that’s the reason for the <strong class="source-inline">number | never</strong> type specification; the user of this function directly recognizes that sometimes (namely, when an exception is thrown) no value will <span class="No-Break">be returned.</span></p>
			<p>1.5 <strong class="bold">Factorial testing</strong>: The following tests do <span class="No-Break">the trick:</span></p>
			<pre class="source-code">
// question_01_factorial_testing.test.ts
import { carefulFact } from "./question_1.4";
describe("Correct cases", () =&gt; {
  test("5! = 120", () =&gt; expect(carefulFact(5)).toBe(120));
  test("0! = 1", () =&gt; expect(carefulFact(0)).toBe(1));
});
describe("Errors", () =&gt; {
  test("Should reject 3.1", () =&gt; {
    expect(() =&gt; carefulFact(3.1)).toThrow();
  });
  test("Should reject -4", () =&gt; {
    expect(() =&gt; carefulFact(-3)).toThrow();
  });
  test("Should reject -5.2", () =&gt; {
    expect(() =&gt; carefulFact(-3)).toThrow();
  });
});</pre>
			<p>Running the suite shows we achieved <span class="No-Break">100% coverage.</span></p>
			<p>1.6 <strong class="bold">Code squeezing</strong>: Using arrow functions, as suggested, as well as the prefix <strong class="source-inline">++</strong> operator (for more information, see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment</a>), you can condense <strong class="source-inline">newCounter()</strong> down to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// question_01_code_squeezing.ts
const shorterCounter = () =&gt; {
  let count = 0;
  return () =&gt; ++count;
};</pre>
			<p>Using arrow functions isn’t hard to understand, but be aware that many developers may have questions or doubts about using <strong class="source-inline">++</strong> as a prefix operator, so this version could prove to be harder <span class="No-Break">to understand.</span></p>
			<p>ESLint has a <strong class="source-inline">no-plusplus</strong> rule that disallows both <strong class="source-inline">++</strong> and <strong class="source-inline">--</strong>. Since I do approve of using them, I had to disable the rule; see <a href="http://eslint.org/docs/latest/user-guide/configuring/rules">eslint.org/docs/latest/user-guide/configuring/rules</a> for more <span class="No-Break">on this.</span></p>
			<p>1.7 <strong class="bold">What type is it?</strong> As <strong class="source-inline">newCounter()</strong> takes no arguments and returns a number, the answer is <strong class="source-inline">() =&gt; </strong><span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break">.</span></p>
			<p>If you are working with Visual Studio Code, there’s a quicker way of doing this: hovering will provide the answer, as in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_1_B19301.jpg" alt="Figure 1 – Visual Studio Code helps with typing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1 – Visual Studio Code helps with typing</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor237"/>Chapter 2, Thinking Functionally – A First Example</h1>
			<p>2.1 <strong class="bold">No extra variables</strong>: We can make do by using the <strong class="source-inline">fn</strong> variable itself as a flag. After calling <strong class="source-inline">fn()</strong>, we set the variable to <strong class="source-inline">null</strong>. Before calling <strong class="source-inline">fn()</strong>, we check that it’s not <strong class="source-inline">null</strong> by using the short-circuit <strong class="source-inline">&amp;&amp;</strong> <span class="No-Break">operator:</span></p>
			<pre class="source-code">
// question_02_no_extra_variables.ts
const once = &lt;FNType extends (...args: any[]) =&gt; any&gt;(
  fn: FNType | null
) =&gt;
  ((...args: Parameters&lt;FNType&gt;) =&gt; {
    <strong class="bold">fn &amp;&amp;</strong> fn(...args);
    <strong class="bold">fn = null</strong>;
  }) as FNType;</pre>
			<p>We need a small change to let TypeScript know that <strong class="source-inline">fn</strong> could be <strong class="source-inline">null</strong>; otherwise, it would object to the <strong class="source-inline">fn = </strong><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> assignment.</span></p>
			<p>2.2 <strong class="bold">Alternating functions</strong>: Like what we did in the previous question, we swap functions, and then we do the call. Here, we use a destructuring assignment to write the swap more compactly. For more information, refer <span class="No-Break">to </span><a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables</span></a><span class="No-Break">:</span></p>
			<pre class="source-code">
// question_02_alternating_fns.ts
const alternator = &lt;FNType extends (...args: any[]) =&gt;
  any&gt;(
  fn1: FNType,
  fn2: FNType
) =&gt;
  ((...args: Parameters&lt;FNType&gt;) =&gt; {
<strong class="bold">    [fn1, fn2] = [fn2, fn1];</strong>
    return fn2(...args);
  }) as FNType;</pre>
			<p>We can write a test <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// question_02_alternating_fns.test.ts
import { alternator } from "./question_2.2";
describe("alternator", () =&gt; {
  it("calls the two functions alternatively", () =&gt; {
    const funcA = jest.fn().mockReturnValue("A");
    const funcB = jest.fn().mockReturnValue("B");
    const testFn = jest.fn(alternator(funcA, funcB));
    expect(testFn()).toEqual("A");
    expect(testFn()).toEqual("B");
    expect(testFn()).toEqual("A");
    expect(testFn()).toEqual("B");
    expect(testFn()).toEqual("A");
    expect(testFn()).toEqual("B");
    expect(testFn).toHaveBeenCalledTimes(6);
    expect(funcA).toHaveBeenCalledTimes(3);
    expect(funcB).toHaveBeenCalledTimes(3);
  });
});</pre>
			<p>We set up two mock functions, one will return <strong class="source-inline">"A"</strong> and the other <strong class="source-inline">"B"</strong>, and then we test that successive calls alternate between those <span class="No-Break">two values.</span></p>
			<p>2.3 <strong class="bold">Everything has a limit!</strong> We simply check whether <strong class="source-inline">limit</strong> is greater than <strong class="source-inline">0</strong>. If so, we decrement it by 1 and call the original function; otherwise, we <span class="No-Break">do nothing:</span></p>
			<pre class="source-code">
// question_02_everything_has_a_limit.ts
const thisManyTimes =
  &lt;FNType extends (...args: any[]) =&gt; any&gt;(
    fn: FNType,
    limit: number
  ) =&gt;
  (...args: Parameters&lt;FNType&gt;) =&gt; {
<strong class="bold">    if (limit &gt; 0) {</strong>
<strong class="bold">      limit--;</strong>
<strong class="bold">      return fn(...args);</strong>
<strong class="bold">    }</strong>
  };</pre>
			<p>We can write a test for it <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// question_02_everything_has_a_limit.test.ts
import { thisManyTimes } from "./question_2.3";
describe("thisManyTimes", () =&gt; {
  it("calls the function 2 times, nothing after", () =&gt; {
    <strong class="bold">const fn = jest.fn()</strong>;
    <strong class="bold">const testFn = jest.fn(thisManyTimes(fn, 2))</strong>;
    testFn(); // works
    testFn(); // works
    testFn(); // nothing now
    testFn(); // nothing now
    testFn(); // nothing now
    testFn(); // nothing now
    expect(testFn).toHaveBeenCalledTimes(6);
    expect(fn).toHaveBeenCalledTimes(2);
  });
});</pre>
			<p>Our <strong class="source-inline">testFn()</strong> function is set to call <strong class="source-inline">fn()</strong> twice, no more; the tests confirm <span class="No-Break">that behavior.</span></p>
			<p>2.4 <strong class="bold">Allow for crashing</strong>: We just have to modify <strong class="source-inline">once()</strong>, so if <strong class="source-inline">fn()</strong> crashes, we’ll reset <strong class="source-inline">done</strong> to <strong class="source-inline">false</strong> to allow a <span class="No-Break">new attempt:</span></p>
			<pre class="source-code">
// question_02_allow_for_crashing.ts
const onceIfSuccess = &lt;
  FNType extends (...args: any[]) =&gt; any
&gt;(
  fn: FNType
) =&gt; {
  let done = false;
  return ((...args: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
<strong class="bold">      try {</strong>
<strong class="bold">        return fn(...args);</strong>
<strong class="bold">      } catch {</strong>
<strong class="bold">        done = false;</strong>
<strong class="bold">      }</strong>
    }
  }) as FNType;
};</pre>
			<p>We can see this works with a simple example; our <strong class="source-inline">crashTwice()</strong> function will throw an error twice and work <span class="No-Break">fine afterward:</span></p>
			<pre class="source-code">
// question_02_allow_for_crashing.manual.ts
import { onceIfSuccess } from "./question_2.4";
let count = 0;
const crashTwice = () =&gt; {
  count++;
  if (count &lt;= 2) {
    console.log("CRASH!");
    throw new Error("Crashing...");
  } else {
    console.log("OK NOW");
  }
};
const doIt = onceIfSuccess(crashTwice);
doIt(); // CRASH!
doIt(); // CRASH!
doIt(); // OK NOW
doIt(); // nothing
doIt(); // nothing
doIt(); // nothing</pre>
			<p>We can write tests <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// question_02_allow_for_crashing.test.ts
import { onceIfSuccess } from "./question_2.4";
describe("onceIfSuccess", () =&gt; {
  it("should run once if no errors", () =&gt; {
<strong class="bold">    const myFn = jest.fn();</strong>
<strong class="bold">    const onceFn = jest.fn(onceIfSuccess(myFn));</strong>
    onceFn();
    onceFn();
    onceFn();
    expect(onceFn).toHaveBeenCalledTimes(3);
    expect(myFn).toHaveBeenCalledTimes(1);
  });
  it("should run again if an exception", () =&gt; {
<strong class="bold">    const myFn = jest.fn()</strong>
<strong class="bold">      .mockImplementationOnce(() =&gt; {</strong>
<strong class="bold">        throw new Error("ERROR 1");</strong>
<strong class="bold">      })</strong>
<strong class="bold">      .mockImplementationOnce(() =&gt; {</strong>
<strong class="bold">        throw new Error("ERROR 2");</strong>
<strong class="bold">      })</strong>
<strong class="bold">      .mockReturnValue(22);</strong>
    const onceFn = jest.fn(onceIfSuccess(myFn));
    expect(onceFn).toThrow();
    expect(onceFn).toThrow();
    expect(onceFn()).toBe(22); // OK now (returns 22)
    onceFn(); // nothing
    onceFn(); // nothing
    onceFn(); // nothing
    expect(onceFn).toHaveBeenCalledTimes(6);
    expect(myFn).toHaveBeenCalledTimes(3);
  });
});</pre>
			<p>We need to check two cases: when the called function works normally and when it crashes at least once. The first case is just like the test we wrote for <strong class="source-inline">once()</strong>, so nothing is new here. For the second case, we set up a mock <strong class="source-inline">myFn()</strong> function that throws errors twice and returns a regular value afterward; the test verifies the <span class="No-Break">expected behavior.</span></p>
			<p>2.5 <strong class="bold">Say no to arrows</strong>: The code is essentially the same, but the placement of type <span class="No-Break">information varies:</span></p>
			<pre class="source-code">
// question_02_say_no_to_arrows.ts
function once<strong class="bold">&lt;FNType extends (...args: any[]) =&gt; any&gt;</strong>(
  fn<strong class="bold">: FNType</strong>
)<strong class="bold">: FNType</strong> {
  let done = false;
  return function (...args<strong class="bold">: Parameters&lt;FNType&gt;</strong>) {
    if (!done) {
      done = true;
      return fn(...args);
    }
  } <strong class="bold">as FNType</strong>;
}</pre>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/>Chapter 3, Starting Out with Functions – A Core Concept</h1>
			<p>3.1 <strong class="bold">Uninitialized object?</strong> The key is that we didn’t wrap the returned object in parentheses, so JavaScript thinks the braces enclose the code to be executed. In this case, <strong class="source-inline">type</strong> is considered to be labeling a statement, which doesn’t really do anything: it’s a <strong class="source-inline">(t)</strong> expression that isn’t used. Due to this, the code is considered valid, and since it doesn’t have an explicit <strong class="source-inline">return</strong> statement, the implicit returned value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">undefined</strong></span><span class="No-Break">.</span></p>
			<p>The corrected code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const simpleAction = (t:string) =&gt; <strong class="bold">(</strong>{
  type: t;
}<strong class="bold">)</strong>;</pre>
			<p>See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label</a> for more on labels, and developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Returning_object_literals for more on <span class="No-Break">returning objects.</span></p>
			<p>3.2 <strong class="bold">Are arrows allowed?</strong> There would be no problems with <strong class="source-inline">useArguments2()</strong>, but with <strong class="source-inline">useArguments()</strong>, you would get an error since arguments are not defined for <span class="No-Break">arrow functions:</span></p>
			<pre class="source-code">
useArguments(22,9,60);
Uncaught ReferenceError: arguments is not defined</pre>
			<p>3.3 <strong class="bold">Three more types</strong>: We have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">fn1</strong> is <strong class="source-inline">(y: number) =&gt; (z: number) =&gt; </strong><span class="No-Break"><strong class="source-inline">number</strong></span></li>
				<li><strong class="source-inline">fn2</strong> is <strong class="source-inline">(z: number) =&gt; </strong><span class="No-Break"><strong class="source-inline">number</strong></span></li>
				<li><strong class="source-inline">fn3</strong> is <span class="No-Break">just </span><span class="No-Break"><strong class="source-inline">number</strong></span></li>
			</ul>
			<p>3.4 <strong class="bold">One-liner</strong>: It works! (Yes, a one-line answer is appropriate in <span class="No-Break">this case!)</span></p>
			<p>3.5 <strong class="bold">Reducing types</strong>: Let’s see all the types that we’ll need. For <strong class="source-inline">State</strong>, we’d have an object with all the fields needed for your application. For a generic version, we could write the following, but a specific description would be <span class="No-Break">much better:</span></p>
			<pre class="source-code">
type State = Record&lt;string, unknown&gt;;</pre>
			<p>We would define all the possible action types with something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
type ActionType = "CREATE" | "DELETE" | "UPDATE";</pre>
			<p>We’d have an object with <strong class="source-inline">type</strong> and an optional <strong class="source-inline">payload</strong> <span class="No-Break">for actions:</span></p>
			<pre class="source-code">
type Action = {
  type: ActionType;
  payload: Record&lt;string, unknown&gt; | null;
};</pre>
			<p>(It would be much better if you defined in detail what possible payloads you could have, instead of going with a generic definition as in the <span class="No-Break">preceding code.)</span></p>
			<p>Our <strong class="source-inline">doAction()</strong> function would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
function doAction(state: State, action: Action) {
  const newState: State = {};
  switch (action?.type) {
    …
  }
}</pre>
			<p>For <strong class="source-inline">dispatchTable</strong>, we’d have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const dispatchTable: Record&lt;
  ActionType,
  (state: State, action: Action) =&gt; State
&gt; = {
  CREATE: (state, action) =&gt; {
    // update state, generating newState,
    // depending on the action data
    // to create a new item
    const NewState: State = {
      /* updated State */
    };
    return NewState;
  },
  …
};</pre>
			<p>Finally, we would write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
function doAction2(state: State, action: Action) {
  return dispatchTable[action.type]
    ? dispatchTable[action.type](state, action)
    : state;
}</pre>
			<p>3.6 <strong class="bold">Spot the bug!</strong> Initially, many people look at the weird (<strong class="source-inline">console(...), window.store.set(...)</strong>) code, but the bug isn’t there: because of how the comma operator works, JavaScript does the logging first, and then the setting. The real problem is that <strong class="source-inline">oldSet()</strong> is not bound to the <strong class="source-inline">window.store</strong> object, so the second line should be as <span class="No-Break">follows instead:</span></p>
			<pre class="source-code">
const oldSet = window.store.set.bind(window.store);</pre>
			<p>Reread the <em class="italic">Working with methods</em> section for more on this, and see <em class="italic">Question 11.1</em> for another way of doing logging – that is, <span class="No-Break">with decorators.</span></p>
			<p>3.7 <strong class="bold">Bindless binding</strong>: If <strong class="source-inline">bind()</strong> wasn’t available, you could use a closure, the <strong class="source-inline">that</strong> trick (which we saw in the <em class="italic">Handling the this value</em> section), and the <strong class="source-inline">apply()</strong> method, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// question_03_bindless_binding.ts
function bind(context) {
  var <strong class="bold">that = this;</strong>
  return function() {
    return <strong class="bold">that.apply</strong>(context, arguments);
  };
}</pre>
			<p>We could do something similar to what we did in the <em class="italic">Adding missing </em><span class="No-Break"><em class="italic">functions</em></span><span class="No-Break"> section.</span></p>
			<p>Alternatively, just for variety, we could use a common idiom based on the <strong class="source-inline">||</strong> operator: if <strong class="source-inline">Function.prototype.bind</strong> exists, evaluation stops right there, and the existing <strong class="source-inline">bind()</strong> method is used; otherwise, our new function <span class="No-Break">is applied:</span></p>
			<pre class="source-code">
Function.prototype.bind =
  <strong class="bold">Function.prototype.bind ||</strong> function(context) {
  var that = this;
  return function() {
    return that.apply(context, arguments);
  };
};</pre>
			<p>3.8 <strong class="bold">Mystery sort</strong>: The <strong class="source-inline">compare(a,b)</strong> comparison function must return a positive number if <strong class="source-inline">a&gt;b</strong>, a negative number if <strong class="source-inline">a&lt;b</strong>, or <strong class="source-inline">0</strong> if <strong class="source-inline">a</strong> equals <strong class="source-inline">b</strong>. When you subtract <strong class="source-inline">ab</strong>, you get that result, so it works. (Of course, this assumes that no number is either <strong class="source-inline">Infinity</strong> or <strong class="source-inline">NaN</strong>.) For more on this, <span class="No-Break">check </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description</span></a><span class="No-Break">.</span></p>
			<p>3.9 <strong class="bold">Negative sort</strong>: All negative numbers get sorted first because of the initial “<strong class="source-inline">-</strong>”, so that’s kind of right, but the numbers themselves are still sorted as strings, so the result is wrong anyway. In the following example, the lowest number is <strong class="source-inline">-666</strong>, which should have been the first element <span class="No-Break">after sorting:</span></p>
			<pre class="source-code">
let someNumbers = [3, 20, 100, -44, -5, -666];
someNumbers.sort();  // [-44, -5, -666, 100, 20, 3]</pre>
			<p>3.10 <strong class="bold">Lexicographic sorting</strong>: Let’s suppose we have an array of strings. To sort it lexicographically in an efficient way, a solution would be <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Transform the array of strings into an array of objects with an added <span class="No-Break"><strong class="source-inline">sortBy</strong></span><span class="No-Break"> field.</span></li>
				<li>For each string, generate the corresponding string to sort by, and put the value in the <span class="No-Break"><strong class="source-inline">sortBy</strong></span><span class="No-Break"> field.</span></li>
				<li>Sort the array <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">sortBy</strong></span><span class="No-Break">.</span></li>
				<li>Drop the added field to convert the sorted array into an array of strings <span class="No-Break">as originally.</span></li>
			</ol>
			<p>3.11 <strong class="bold">Stubbed logging</strong>: The <strong class="source-inline">console.log()</strong> method can accept any number of arguments of any type, and won’t return anything, so its type is <strong class="source-inline">(...args: </strong><span class="No-Break"><strong class="source-inline">any[]): void</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/>Chapter 4, Behaving Properly – Pure Functions</h1>
			<p>4.1 <strong class="bold">Must return?</strong> If a pure function doesn’t return anything, it means that the function doesn’t do anything since it can’t modify its inputs and doesn’t have any other <span class="No-Break">side effect.</span></p>
			<p>4.2 <strong class="bold">Well-specified return</strong>: TypeScript would have objected because the result of the function would be <strong class="source-inline">string | undefined</strong>, because the <strong class="source-inline">.pop()</strong> method returns <strong class="source-inline">undefined</strong> if the input array <span class="No-Break">is empty.</span></p>
			<p>4.3 <strong class="bold">Go for a closure</strong>: We just have to wrap the definition of <strong class="source-inline">fib2()</strong> in an IIFE; <strong class="source-inline">fibC()</strong> is equivalent to <strong class="source-inline">fib2()</strong> but with an <span class="No-Break">internal </span><span class="No-Break"><strong class="source-inline">cache</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// question_04_go_for_a_closure.ts
const fibC = (() =&gt; {
  const cache: number[] = [];
  const fib2 = (n: number): number =&gt; {
    if (cache[n] === undefined) {
      if (n === 0) {
        cache[0] = 0;
      } else if (n === 1) {
        cache[1] = 1;
      } else {
        cache[n] = fib2(n - 2) + fib2(n - 1);
      }
    }
    return cache[n];
  };
  return fib2;
})();</pre>
			<p>4.4 <strong class="bold">Minimalistic function</strong>: It works because fib(0)=0 and fib(1)=1, so it’s true that for <em class="italic">n</em>&lt;2, fib(<em class="italic">n</em>) <span class="No-Break">equals </span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">.</span></p>
			<p>4.5 <strong class="bold">A cheap way</strong>: This algorithm works the same way as you’d calculate a Fibonacci number by hand. You’d start by writing down fib(0)=0 and fib(1)=1, adding them to get fib(2)=1, adding the last two to get fib(3)=2, and so on. In this version of the algorithm, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> stand for two consecutive Fibonacci numbers. This implementation is <span class="No-Break">quite efficient!</span></p>
			<p>4.6 <strong class="bold">Rounding type</strong>: The full definition, including the result type, would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const roundFix2 = (
  accum: number,
  n: number
)<strong class="bold">: {</strong>
<strong class="bold">  accum: number;</strong>
<strong class="bold">  nRounded: number;</strong>
<strong class="bold">}</strong> =&gt; ...</pre>
			<p>4.7 <strong class="bold">Tuples to go</strong>: In this case, we would return an array with two numbers, so we may write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// question_04_tuples_to_go.ts
<strong class="bold">type AccumRoundedType = [number, number];</strong>
const roundFix2a = (
  accum: number,
  n: number
)<strong class="bold">: AccumRoundedType</strong> =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) :
    Math.floor(n);
  accum += n - nRounded;
  return [accum, nRounded];
};
const roundFix2b = (<strong class="bold">[</strong>
<strong class="bold">  accum,</strong>
<strong class="bold">  n,</strong>
<strong class="bold">]: AccumRoundedType</strong>)<strong class="bold">: AccumRoundedType</strong> =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) :
    Math.floor(n);
  accum += n - nRounded;
  return [accum, nRounded];
};</pre>
			<p>The tests are very similar to what we already wrote; here, we have abridged versions of our previous code, highlighting the <span class="No-Break">needed changes:</span></p>
			<pre class="source-code">
// question_04_tuples_to_go.test.ts
describe("roundFix2a", function () {
  it("rounds 3.14159-&gt;3 if differences are 0", () =&gt; {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2a(0.0, 3.14159);
    expect(accum).toBeCloseTo(0.14159);
    expect(nRounded).toBe(3);
  });
  it("rounds 2.71828-&gt;3 if differences are 0.14159", () =&gt;
    {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2a(0.14159, 2.71828);
    expect(accum).toBeCloseTo(-0.14013);
    expect(nRounded).toBe(3);
  });
});
describe("roundFix2b", function () {
  it("rounds 2.71828-&gt;2 if differences are -0.14013", () =&gt;
    {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2b(<strong class="bold">[</strong>
<strong class="bold">      -0.14013, 2.71828,</strong>
<strong class="bold">    ]</strong>);
    expect(accum).toBeCloseTo(0.57815);
    expect(nRounded).toBe(2);
  });
  it("rounds 3.14159-&gt;4 if differences are 0.57815", () =&gt;
    {
    const <strong class="bold">[accum, nRounded]</strong> = roundFix2b(<strong class="bold">[</strong>
<strong class="bold">      0.57815, 3.14159,</strong>
<strong class="bold">    ]</strong>);
    expect(accum).toBeCloseTo(-0.28026);
    expect(nRounded).toBe(4);
  });
});</pre>
			<p>4.8 <strong class="bold">One injection or two?</strong> Having two optional injected functions would allow specifying one but omitting the other, and then <strong class="source-inline">calculateDeb2()</strong> would still attempt to call the API. Providing an object with the dependencies makes injection an <span class="No-Break"><em class="italic">all-or-nothing</em></span><span class="No-Break"> option.</span></p>
			<p>4.9 <strong class="bold">JavaScript does math?</strong> If you run the code, you’ll (unexpectedly) get the <strong class="source-inline">"Math failure?"</strong> message. The problem has to do with the fact that JavaScript internally uses binary instead of decimal, and floating-point precision is limited. In decimal, 0.1, 0.2, and 0.3 have a fixed, short representation, but in binary, they have infinite representation, much like 1/3=0.33333... has in decimal. If you write out the value of <strong class="source-inline">a+b</strong> after the test, you’ll get 0.30000000000000004 – and that’s why you must be very careful when testing for equality <span class="No-Break">in JavaScript.</span></p>
			<p>4.10 <strong class="bold">Breaking laws</strong>: Some of the properties are no longer always valid. To simplify our examples, let’s assume two numbers are close to each other if they differ by no more than 0.1. If this is the case, then we have <span class="No-Break">the following:</span></p>
			<ul>
				<li>0.5 is close to 0.6, and 0.6 is close to 0.7, but 0.5 is not close <span class="No-Break">to 0.7</span></li>
				<li>0.5 is close to 0.6, and 0.7 is close to 0.8, but <em class="italic">0.5+0.7=1.2</em> is not close to <em class="italic">0.6+0.8=1.4</em>, and <em class="italic">0.5*0.7=0.35</em> is not close to <span class="No-Break"><em class="italic">0.6*0.8=0.48</em></span><span class="No-Break"> either</span></li>
				<li>0.5 is close to 0.4, and 0.2 is close to 0.3, but <em class="italic">0.5-0.2=0.3</em> is not close to <em class="italic">0.4-0.3=0.1</em>, and <em class="italic">0.5/0.2=2.5</em> is not close <span class="No-Break">to </span><span class="No-Break"><em class="italic">0.4/0.3=1.333</em></span></li>
			</ul>
			<p>The other cited properties are <span class="No-Break">always valid.</span></p>
			<p>4.11 <strong class="bold">Shuffling kinds</strong>: This type definition allows our function to work with arrays of any type (strings, numbers, objects, etc.) and says that the type of the output array will be the same as the type of the <span class="No-Break">input array.</span></p>
			<p>4.12 <strong class="bold">No return needed</strong>: If no data is returned, we then write <strong class="source-inline">&lt;T&gt;(arr: T[]) =&gt; void</strong>. See www.typescriptlang.org/docs/handbook/2/functions.html <span class="No-Break">for more.</span></p>
			<p>4.13 <strong class="bold">A shuffle test</strong>: Before shuffling the array, sort a copy of it, use <strong class="source-inline">JSON.stringify()</strong> on it, and save the result. After shuffling, sort a copy of the shuffled array and use <strong class="source-inline">JSON.stringify()</strong> on it too. Those two JSON strings should be equal. This does away with all the other tests since it ensures that the array doesn’t change its length or elements, and it would also work for arrays with <span class="No-Break">repeated elements:</span></p>
			<pre class="source-code">
// question_04_a_shuffle_test.test.ts
describe("shuffleTest", function () {
  it("doesn't change the array length or elements", () =&gt; {
    const a = [22, 9, 60, 22, 12, 4, 56, 22, 60];
    const <strong class="bold">oldA = JSON.stringify([...a].sort())</strong>;
    shuffle(a);
    const <strong class="bold">newA = JSON.stringify([...a].sort())</strong>;
    <strong class="bold">expect(oldA).toBe(newA)</strong>;
  });
});</pre>
			<p>4.14 <strong class="bold">Popular, but wrong!</strong> To test that a <strong class="source-inline">shuffle</strong> function works well, an idea is to shuffle a small array many times, and count how many possible outputs come up; the final counts should be similar, though not necessarily (because of the random aspects) equal. In my article at <a href="https://blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/">blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/</a>, I tested the Fisher–Yates algorithm by shuffling a four-letter (A to D) array 24,000 times, and <span class="No-Break">got this:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_3_B19301.jpg" alt=""/>
				</div>
			</div>
			<p>All 24 possible orderings were produced (see the <em class="italic">Recursion</em> section in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Becoming Functional</em>), and the results were all pretty close to 1,000; the difference between the highest and lowest counts is only around 10%. This is not a thorough statistical confirmation – for that, we’d have to apply statistical frequency tests such as χ² (Chi-squared), Kolmogorov–Smirnov, or Anderson–Darling – but at least we get a notion that shuffling is not working <span class="No-Break">very badly.</span></p>
			<p>When I applied the (supposedly good!) algorithm, the counts were <span class="No-Break">more lopsided:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_4_B19301.jpg" alt=""/>
				</div>
			</div>
			<p>The highest count is more than 14 times the lowest; we can definitely conclude that not all arrangements are equally likely, so the popular shuffling algorithm is simply not <span class="No-Break">good enough.</span></p>
			<p>4.15 <strong class="bold">Shuffling by sorting</strong>: To get a random sequence, we can assign to each array element a random number and sort by that number; the result will be a totally <span class="No-Break">random shuffling:</span></p>
			<pre class="source-code">
// question_04_shuffling_by_sorting.ts
const sortingShuffle = &lt;T&gt;(arr: T[]): T[] =&gt;
  arr
    .map((v) =&gt; ({ val: v, key: Math.random() }))
    .sort((a, b) =&gt; a.key - b.key)
    .map((o) =&gt; o.val);</pre>
			<p>The first <strong class="source-inline">.map()</strong> transforms each array element into an object, with the original value at <strong class="source-inline">val</strong> and a random value at <strong class="source-inline">key</strong>. We then sort the array by the <strong class="source-inline">key</strong> value, using the technique shown in <em class="italic">Question 3.8</em>. Finally, we undo the first mapping to get just the <span class="No-Break">original values.</span></p>
			<p>A final comment: this code is truly functional, and returns a new array instead of modifying the original argument <span class="No-Break">in place.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor240"/>Chapter 5, Programming Declaratively – A Better Style</h1>
			<p>5.1 <strong class="bold">Generating HTML code, with restrictions</strong>: In real life, you wouldn’t limit yourself to using only <strong class="source-inline">filter()</strong>, <strong class="source-inline">map()</strong>, and <strong class="source-inline">reduce()</strong>, but the objective of this question was to make you think about how to manage with only those. Using <strong class="source-inline">join()</strong> or other extra string functions would make the problem easier. For instance, finding out a way to add the enclosing <strong class="source-inline">&lt;div&gt;&lt;ul&gt; ... &lt;/ul&gt;&lt;/div&gt;</strong> tags is tricky, so we had to make the first <strong class="source-inline">reduce()</strong> operation produce an array so that we could keep on working <span class="No-Break">on it:</span></p>
			<pre class="source-code">
const characters = [
  { name: "Fred", plays: "bowling" },
  { name: "Barney", plays: "chess" },
  { name: "Wilma", plays: "bridge" },
  { name: "Betty", plays: "checkers" },
  { name: "Pebbles", plays: "chess" },
];
const list = characters
  .filter(
    (x) =&gt; x.plays === "chess" || x.plays == "checkers"
  )
  .map((x) =&gt; `&lt;li&gt;${x.name}&lt;/li&gt;`)
  .reduce((a, x) =&gt; [a[0] + x], [""])
  .map((x) =&gt; `&lt;div&gt;&lt;ul&gt;${x}&lt;/ul&gt;&lt;/div&gt;`)
  .reduce((a, x) =&gt; x);
console.log(list);
/* Output is a single line; here output is wrapped
<strong class="bold">&lt;div&gt;&lt;ul&gt;&lt;li&gt;Barney&lt;/li&gt;&lt;li&gt;Betty&lt;/li&gt;&lt;li&gt;Pebbles&lt;/li&gt;</strong>
<strong class="bold">&lt;/ul&gt;&lt;/div&gt;</strong>
*/</pre>
			<p>Accessing the array and index arguments for the <strong class="source-inline">map()</strong> or <strong class="source-inline">reduce()</strong> callbacks would also <span class="No-Break">provide solutions:</span></p>
			<pre class="source-code">
const list2 = characters
  .filter(
    (x) =&gt; x.plays === "chess" || x.plays == "checkers"
  )
  .map(
    (x, i, t) =&gt;
      `${i === 0 ? "&lt;div&gt;&lt;ul&gt;" : ""}` +
      `&lt;li&gt;${x.name}&lt;/li&gt;` +
      `${i == t.length - 1 ? "&lt;/ul&gt;&lt;/div&gt;" : ""}`
  )
  .reduce((a, x) =&gt; a + x, "");
// exact same result</pre>
			<p>We could also do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const list3 = characters
  .filter(
    (x) =&gt; x.plays === "chess" || x.plays == "checkers"
  )
  .map((x) =&gt; `&lt;li&gt;${x.name}&lt;/li&gt;`)
  .reduce(
    (a, x, i, t) =&gt;
      a + x + (i === t.length - 1 ? "&lt;/ul&gt;&lt;/div&gt;" : ""),
    "&lt;div&gt;&lt;ul&gt;"
  );
// again, the same result</pre>
			<p>Study the three examples: they will help you gain insight into these higher-order functions and provide you with ideas so that you can do <span class="No-Break">independent work.</span></p>
			<p>5.2 <strong class="bold">More formal testing</strong>: Use an idea from <em class="italic">Question 4.13</em>; select an array and a function, find the result of mapping using both the standard <strong class="source-inline">map()</strong> method and the new <strong class="source-inline">myMap()</strong> function, but instead of using <strong class="source-inline">JSON.stringify()</strong>, use Jest’s <strong class="source-inline">toEqual()</strong> method to compare the results. See the answer to <em class="italic">Question 5.5</em> <span class="No-Break">for more.</span></p>
			<p>5.3 <strong class="bold">Reverse by summing</strong>: This works, but we need to define an overloaded <strong class="source-inline">sum()</strong> function so TypeScript won’t object. Overloading isn’t available for arrow functions, so we have to change how we <span class="No-Break">define </span><span class="No-Break"><strong class="source-inline">sum()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function sum(x: number, y: number): number;
function sum(x: string, y: string): string;
function sum(x: any, y: any): string | number {
  return x + y;
}</pre>
			<p>Now <strong class="source-inline">reverseString2()</strong> works and summing an array of numbers <span class="No-Break">also works:</span></p>
			<pre class="source-code">
const reverseString2 = (str: string): string =&gt;
  str.split("").reduceRight(<strong class="bold">sum</strong>, "");
console.log(reverseString2("MONTEVIDEO"));
// OEDIVETNOM
const myArray = [22, 9, 60, 12, 4, 56];
console.log(myArray.reduce(<strong class="bold">sum</strong>, 0));
// 163</pre>
			<p>If you try to do something as <strong class="source-inline">sum(22,"X")</strong> or <strong class="source-inline">sum(false,{a:1})</strong>, TypeScript will reject it because it won’t match the <span class="No-Break">defined overloads:</span></p>
			<pre class="source-code">
describe("myMap", () =&gt; {
  const myArray = [22, 9, 60, 12, 4, 56];
  it("duplicates values", () =&gt; {
    const dup = (x: number): number =&gt; 2 * x;
    <strong class="bold">expect(myArray.map(dup)).toEqual(myMap(myArray, dup))</strong>;
  });
  it("add dashes", () =&gt; {
    const addDashes = (x: number): string =&gt; `-${x}-`;
<strong class="bold">    expect(myArray.map(addDashes)).toEqual(</strong>
<strong class="bold">      myMap(myArray, addDashes)</strong>
<strong class="bold">    );</strong>
  });
});</pre>
			<p>5.4 <strong class="bold">Reversed reverse?</strong> In this case, it would return the same input string as the output; check <span class="No-Break">it out!</span></p>
			<p>5.5 <strong class="bold">Ranging far and wide</strong>: This requires a bit of careful arithmetic, but shouldn’t be much trouble. Here, we need to distinguish two cases: upward and downward ranges. The default step is <strong class="source-inline">1</strong> for the former and <strong class="source-inline">-1</strong> for the latter. We used <strong class="source-inline">Math.sign()</strong> <span class="No-Break">for this:</span></p>
			<pre class="source-code">
const range2 = (
  from: number,
  to: number,
  step = Math.sign(to - from)
): number[] =&gt; {
  const arr = [];
  do {
    arr.push(from);
    from += step;
  } while (
    (step &gt; 0 &amp;&amp; to &gt; from) ||
    (step &lt; 0 &amp;&amp; to &lt; from)
  );
  return arr;
};</pre>
			<p>A different implementation starts by calculating how big an array is needed and then filling it using <strong class="source-inline">fill()</strong> and <strong class="source-inline">map()</strong>. We must be careful if <strong class="source-inline">start</strong> and <strong class="source-inline">stop</strong> are equal to avoid a division <span class="No-Break">by zero:</span></p>
			<pre class="source-code">
const range2b = (
  start: number,
  stop: number,
  step: number = Math.sign(stop - start)
): number[] =&gt;
  new Array(
    step === 0 ? 1 : Math.ceil((stop - start) / step)
  )
    .fill(0)
    .map((v, i) =&gt; start + i * step);</pre>
			<p>A few examples of calculated ranges show the diversity in terms of the options <span class="No-Break">we have:</span></p>
			<pre class="source-code">
range2(1, 10);        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
range2(1, 10, 2);     // [1, 3, 5, 7, 9]
range2(1, 10, 3);     // [1, 4, 7]
range2(1, 10, 6);     // [1, 7]
range2(1, 10, 11);    // [1]
range2(21, 10);       // [21, 20, 19, ... 13, 12, 11]
range2(21, 10, -3);   // [21, 18, 15, 12]
range2(21, 10, -4);   // [21, 17, 13]
range2(21, 10, -7);   // [21, 14]
range2(21, 10, -12);  // [21]</pre>
			<p>Writing Jest tests is straightforward; the following code shows just three cases of the <span class="No-Break">preceding code:</span></p>
			<pre class="source-code">
describe("range2()", () =&gt; {
  it("works from 1 to 10", () =&gt;
    expect(range2(1, 10)).toEqual([
      1, 2, 3, 4, 5, 6, 7, 8, 9,
    ]));
  it("works from 1 to 10 by 2", () =&gt;
    expect(range2(1, 10, 2)).toEqual([1, 3, 5, 7, 9]));
  it("works from 21 down to 10 by -4", () =&gt;
    expect(range2(21, 10, -4)).toEqual([21, 17, 13]));
});</pre>
			<p>Using this new <strong class="source-inline">range2()</strong> function means you can write a greater variety of loops in a functional way, with no need for <span class="No-Break"><strong class="source-inline">for(...)</strong></span><span class="No-Break"> statements.</span></p>
			<p>5.6 <strong class="bold">Range generators</strong>: The following does the job and works for all sorts of ranges, ascending or descending. The first time it is called, it returns the initial value (<strong class="source-inline">from</strong>) and then updates it (by summing the <strong class="source-inline">step</strong> value) until the resulting value is outside <span class="No-Break">the range:</span></p>
			<pre class="source-code">
function* range4(
  from: number,
  to: number,
  step: number = Math.sign(to - from)
): Generator&lt;number&gt; {
  do {
<strong class="bold">    yield from;</strong>
<strong class="bold">    from += step;</strong>
  } while (
<strong class="bold">    (step &gt; 0 &amp;&amp; to &gt;= from) ||</strong>
<strong class="bold">    (step &lt; 0 &amp;&amp; to &lt;= from)</strong>
  );
}</pre>
			<p>We can write tests for this function in several different ways: manually calling the generator several times, using the spread operator to get all the values at once, or using the <span class="No-Break"><strong class="source-inline">for..of</strong></span><span class="No-Break"> construct:</span></p>
			<pre class="source-code">
describe("range4", () =&gt; {
  it("generates 2..5", () =&gt; {
    const range = range4(2, 5);
<strong class="bold">    expect(range.next().value).toBe(2);</strong>
<strong class="bold">    expect(range.next().value).toBe(3);</strong>
<strong class="bold">    expect(range.next().value).toBe(4);</strong>
<strong class="bold">    expect(range.next().value).toBe(5);</strong>
<strong class="bold">    expect(range.next().value).toBe(undefined);</strong>
  });
  it("generates 5..2", () =&gt; {
    const range = range4(5, 2);
    <strong class="bold">expect([...range]).toEqual([5, 4, 3, 2]);</strong>
  });
  it("generates 1..10 by 2", () =&gt; {
    const numbers = [];
    for (<strong class="bold">const i of range4(1, 10, 2)</strong>) {
      numbers.push(i);
    }
    expect(numbers).toEqual([1, 3, 5, 7, 9]);
  });
});</pre>
			<p>5.7 <strong class="bold">Doing the alphabet</strong>: The problem is that <strong class="source-inline">String.fromCharCode()</strong> is not unary; it may receive any number of arguments. When you write <strong class="source-inline">map(String.fromCharCode)</strong>, the callback gets called with three parameters (the current value, the index, and the array) and that causes unexpected results. Using <strong class="source-inline">unary()</strong> from the <em class="italic">Arity changing</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Producing Functions,</em> would also work. To find out more, go <span class="No-Break">to </span><a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode</span></a><span class="No-Break">.</span></p>
			<p>5.8 <strong class="bold">Producing a CSV</strong>: A first solution, along with some auxiliary functions, is as follows; can you understand what each <span class="No-Break">function does?</span></p>
			<pre class="source-code">
const myData = [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12],
];
const concatNumbers = (a: string, b: number): string =&gt;
  !a ? `${b}` : `${a},${b}`;
const concatLines = (c: string, d: string): string =&gt;
  c + "\n" + d;
const makeCSV = (data: number[][]) =&gt;
  data
<strong class="bold">    .map((x) =&gt; x.reduce(concatNumbers, ""))</strong>
<strong class="bold">    .reduce(concatLines, "");</strong>
console.log(makeCSV(myData));
/*
1,2,3,4
5,6,7,8
9,10,11,12
*/</pre>
			<p>An alternative one-liner is possible, but not as clear – do <span class="No-Break">you agree?</span></p>
			<pre class="source-code">
const makeCSV2 = (data: number[][]) =&gt;
  data
    .map((x: number[]) =&gt;
      x.reduce(
        (a: string, b: number): string =&gt;
          !a ? `${b}` : `${a},${b}`,
        ""
      )
    )
    .reduce((c: string, d: string) =&gt; c + "\n" + d, "");</pre>
			<p>5.9 <strong class="bold">An empty question?</strong> Both <strong class="source-inline">flat1()</strong> and <strong class="source-inline">flat2()</strong> depend on <strong class="source-inline">flatOne()</strong>. If that function (in any of its two provided implementations) finds an empty array position, it doesn’t <strong class="source-inline">concat()</strong> anything to <span class="No-Break">its output.</span></p>
			<p>5.10 <strong class="bold">Producing better output</strong>: For this, you’ll have to do some extra mapping, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const better = apiAnswer
  .flatMap((c) =&gt;
    c.states.map((s) =&gt; ({ ...s, country: c.name }))
  )
  .flatMap((s) =&gt;
    s.cities.map((t) =&gt; ({
      ...t,
      state: s.name,
      country: s.country,
    }))
  )
  .map((t) =&gt; `${t.name}, ${t.state}, ${t.country}`);
console.log(better);
/*
[
  'Lincoln, Buenos Aires, Argentine',
  'Lincoln, England, Great Britain',
  'Lincoln, California, United States of America',
  'Lincoln, Rhode Island, United States of America',
  'Lincolnia, Virginia, United States of America',
  'Lincoln Park, Michigan, United States of America',
  'Lincoln, Nebraska, United States of America',
  'Lincoln Park, Illinois, United States of America',
  'Lincoln Square, Illinois, United States of America'
]
*/</pre>
			<p>5.11 <strong class="bold">Old-style code only!</strong> One way of doing this is by using <strong class="source-inline">join()</strong> to build a single long string out of the individual sentences, using <strong class="source-inline">split()</strong> to separate that string into words, and finally, looking at the length of the <span class="No-Break">resulting array:</span></p>
			<pre class="source-code">
const words = gettysburg.join(" ").split(" ").length; // 270</pre>
			<p>5.12 <strong class="bold">Filtering…but what?</strong> <strong class="source-inline">Boolean(x)</strong> is the same as <strong class="source-inline">!!x</strong>, turning an expression from <strong class="source-inline">truthy</strong> or <strong class="source-inline">falsy</strong> into <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, respectively. Thus, the <strong class="source-inline">filter()</strong> operation removes all <strong class="source-inline">falsy</strong> elements from <span class="No-Break">the array.</span></p>
			<p>5.13 <strong class="bold">Yet another factorial question</strong>: Yes, it works, and <strong class="source-inline">fact4(0)</strong> returns <strong class="source-inline">1</strong> as expected. The <strong class="source-inline">range(1,1)</strong> call produces an empty array, so the original value of <strong class="source-inline">result</strong> (<strong class="source-inline">1</strong>) is returned without <span class="No-Break">further change.</span></p>
			<p>5.14 <strong class="bold">Async chaining</strong>: An article by Valeri Karpov, which can be found at <a href="http://thecodebarbarian.com/basic-functional-programming-with-async-await.html">thecodebarbarian.com/basic-functional-programming-with-async-await.html</a>, provides polyfills for methods such as <strong class="source-inline">forEach()</strong>, <strong class="source-inline">map()</strong>, and so on, and also develops a class for <strong class="source-inline">async</strong> arrays that <span class="No-Break">allows chaining.</span></p>
			<p>5.15 <strong class="bold">Missing equivalents</strong>: Start by using <strong class="source-inline">mapAsync()</strong> to get the async values and apply the original function to the returned array. An example for <strong class="source-inline">some()</strong> would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const someAsync = &lt;T&gt;(
  arr: T[],
  fn: (x: T) =&gt; Promise&lt;boolean&gt;
) =&gt;
  <strong class="bold">mapAsync(arr, fn).then((mapped) =&gt; mapped.some(Boolean))</strong>;</pre>
			<p>We can write tests for this in two different fashions: awaiting the result of a call, or using Jest’s <strong class="source-inline">.resolves</strong> for <span class="No-Break">shorter code:</span></p>
			<pre class="source-code">
describe("someAsync", () =&gt; {
  it("succeeds if sometimes OK", async () =&gt; {
    const someEven = <strong class="bold">await someAsync</strong>(
      [1, 2, 3, 4],
      fakeFilter
    );
    <strong class="bold">expect(someEven).toBeTruthy()</strong>;
  });
  it("fails if never OK", () =&gt; {
    expect(
      someAsync([1, 3, 5, 7, 9], fakeFilter)
    )<strong class="bold">.resolves.toBeFalsy()</strong>;
  });
});</pre>
			<p>5.16 <strong class="bold">Emptying the pool</strong>: The provided suggestion is good: we could do the check either at the top of <strong class="source-inline">workerCall()</strong> or when we reset a worker to be not in use. Let’s go with the second solution, to make the call as fast as possible. We will add a <strong class="source-inline">MAX_NOT_IN_USE</strong> constant with the threshold of number of workers not in use and a <strong class="source-inline">notInUse()</strong> predicate as <span class="No-Break">a refactor:</span></p>
			<pre class="source-code">
const notInUse = (p: PoolEntry): boolean =&gt; !p.inUse;
const MAX_NOT_IN_USE = 10;</pre>
			<p>Then, we’ll change the last part of the <strong class="source-inline">workerCall()</strong> function <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  return new Promise((resolve) =&gt; {
    available!.inUse = true;
    available!.worker.on("message", (x) =&gt; {
      resolve(x);
      available!.inUse = false;
<strong class="bold">      while (</strong>
<strong class="bold">        pool.filter(notInUse).length &gt; MAX_NOT_IN_USE</strong>
<strong class="bold">      ) {</strong>
<strong class="bold">        const notUsed = pool.findIndex(notInUse);</strong>
<strong class="bold">        pool[notUsed].worker.terminate();</strong>
<strong class="bold">        pool.splice(notUsed, 1);</strong>
<strong class="bold">      }</strong>
    });
    available!.worker.postMessage(value);
  });</pre>
			<p>While the count of workers not in use is higher than our limit, we find one worker to remove, <strong class="source-inline">terminate()</strong> it, and remove it from the pool <span class="No-Break">of workers.</span></p>
			<p>5.17 <strong class="bold">Queueing for the pool</strong>: This question has an interesting way of handling a promise to act as a barrier, initially denying but eventually allowing procedures to go through. The idea is to check that there are not too many running workers before adding a worker to the pool. If so, proceed as before, but if not, add something to the queue (we’ll see what), so we can run the worker later. Whenever a worker responds, we’ll check whether there’s anything in the queue to allow it <span class="No-Break">to run.</span></p>
			<p>We’ll first add <span class="No-Break">three things:</span></p>
			<pre class="source-code">
const queue: ((v?: any) =&gt; void)[] = [];
let running = 0;
const MAX_TO_USE = 5;</pre>
			<p>The way we’ll handle waiting is by creating a promise, which we’ll eventually resolve at a later time. That explains the weird <strong class="source-inline">queue</strong> data type, which contains resolving functions. The <strong class="source-inline">running</strong> variable will count how many workers are running, and <strong class="source-inline">MAX_TO_USE</strong> is the maximum possible value <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">running</strong></span><span class="No-Break">.</span></p>
			<p>To work with the queue, we’ll have <span class="No-Break">two functions:</span></p>
			<pre class="source-code">
const enqueue = (resolve2: (v?: any) =&gt; void) =&gt; {
  if (running &lt; MAX_TO_USE) {
    running++;
    resolve2();
  } else {
    queue.push(resolve2);
  }
};
const dequeue = () =&gt; {
  const resolve2 = queue.shift();
  resolve2 &amp;&amp; resolve2();
};</pre>
			<p>The <strong class="source-inline">enqueue()</strong> function checks how many workers are running; if there are less than <strong class="source-inline">MAX_TO_USE</strong>, it increments <strong class="source-inline">running</strong> (because a worker will run) and then calls <strong class="source-inline">resolve2()</strong> to allow the corresponding request to go forward. If there are too many running workers, the function to call is instead pushed into the queue. The <strong class="source-inline">dequeue()</strong> function just tries to get the front element from the queue, and if there’s something, it calls the dequeued value to allow a queued request <span class="No-Break">to proceed.</span></p>
			<p>The modified <strong class="source-inline">workerCall()</strong> function is now <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
export const workerCall = (
  filename: string,
  value: any
): Promise&lt;any&gt; =&gt; {
  return new Promise((resolve) =&gt; {
 <strong class="bold">   new Promise((resolve2) =&gt; enqueue(resolve2)).then(</strong>
      () =&gt; {
        let available = pool
          .filter(notInUse)
          .find((x) =&gt; x.filename === filename);
        if (available === undefined) {
          available = {
            worker: new Worker(filename),
            filename,
            value,
            inUse: true,
          } as PoolEntry;
          pool.push(available);
        }
        available!.inUse = true;
        available!.worker.on("message", (x) =&gt; {
          resolve(x);
          available!.inUse = false;
<strong class="bold">          dequeue();</strong>
        });
        available!.worker.postMessage(value);
      }
    );
  });
};</pre>
			<p>The <strong class="source-inline">new Promise((resolve2) =&gt; …)</strong> line is the barrier we mentioned; it will allow work to go on (at <strong class="source-inline">then()</strong>) only when its <strong class="source-inline">resolve2()</strong> function is called – which will be done either by <strong class="source-inline">enqueue()</strong> (if there were few running workers) or <strong class="source-inline">dequeue()</strong> (when some previously running <span class="No-Break">worker ends).</span></p>
			<p>5.18 <strong class="bold">Showing results</strong>: Basically, given a string, it returns a logging function that expects a single parameter and lists both the string and the argument. We’ll see other ways of achieving similar results in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <span class="No-Break"><em class="italic">Producing Functions</em></span><span class="No-Break">.</span></p>
			<p>5.19 <strong class="bold">Double filtering?</strong> This is not optimal; <strong class="source-inline">filter()</strong> goes through all the workers, and then <strong class="source-inline">find()</strong> goes through the filtered ones. This could be achieved in a single pass <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  let available = pool
    .find(<strong class="bold">(v) =&gt; !v.inUse &amp;&amp; v.filename === filename</strong>);</pre>
			<p>5.20 <strong class="bold">Wishful thinking</strong>: At the very least, you should listen to the <strong class="source-inline">"error"</strong> event, which fires if an error occurs in the worker. In this case, the worker should be marked as not in use (because it has ended its job) and the promise should be rejected. The final part of the <strong class="source-inline">workerCall()</strong> function should look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
  return new Promise((resolve, reject) =&gt; {
    available!.inUse = true;
    available!.worker.on("message", (x) =&gt; {
      resolve(x);
      available!.inUse = false;
    });
<strong class="bold">    available!.worker.on("error", (x) =&gt; {</strong>
<strong class="bold">      reject(x);</strong>
<strong class="bold">      available!.inUse = false;</strong>
<strong class="bold">    });</strong>
    available!.worker.postMessage(value);
  });</pre>
			<p>For an “industrial-strength” level library, you should deal with all possible events; check developer.mozilla.org/en-US/docs/Web/API/Worker#events and nodejs.org/api/worker_threads.html#class-worker for more <span class="No-Break">on this.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor241"/>Chapter 6, Producing Functions – Higher-Order Functions</h1>
			<p>6.1 <strong class="bold">Go with arrows</strong>: Just minor changes <span class="No-Break">are needed:</span></p>
			<pre class="source-code">
const addLogging <strong class="bold">= &lt;T extends (...args: any[]) =&gt; any&gt;</strong>(
  fn: T
): <strong class="bold">((...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; </strong>{
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    console.log(`entering ${fn.name}(${args})`);
    const valueToReturn = fn(...args);
    console.log(`exiting  ${fn.name}=&gt;${valueToReturn}`);
    return valueToReturn;
  };
};</pre>
			<p>6.2 <strong class="bold">Mapping for memory</strong>: Let’s do this for the most complete memoizing function we wrote, <strong class="source-inline">memoize4()</strong>. Instead of using an object for <strong class="source-inline">cache</strong>, we create a map. We check whether the map has the searched <strong class="source-inline">strX</strong> key, we set new values after calling the original function, and we get the return value from the cache. The <strong class="source-inline">as</strong> part in <strong class="source-inline">return</strong> is to let TypeScript know that <strong class="source-inline">get()</strong> will succeed because the search <span class="No-Break">won’t fail:</span></p>
			<pre class="source-code">
const memoize4 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  <strong class="bold">const cache = new Map() as Map&lt;string, ReturnType&lt;T&gt;&gt;;</strong>
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    <strong class="bold">if (!cache.has(strX)) {</strong>
<strong class="bold">      cache.set(strX, fn(...args));</strong>
<strong class="bold">    }</strong>
<strong class="bold">    return cache.get(strX) as ReturnType&lt;T&gt;;</strong>
  };
};</pre>
			<p>6.3 <strong class="bold">How many?</strong> Let’s call <strong class="source-inline">calc(n)</strong> the number of calls needed to evaluate <strong class="source-inline">fib(n)</strong>. Analyzing the tree that shows all the needed calculations, we get <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">calc(0)=1</span></li>
				<li><span class="No-Break">calc(1)=1</span></li>
				<li>For <em class="italic">n</em>&gt;1, calc(<em class="italic">n</em>)=1 + calc(<em class="italic">n</em>-1) + <span class="No-Break">calc(</span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">-2)</span></li>
			</ul>
			<p>The last line follows from the fact that when we call <strong class="source-inline">fib(n)</strong>, we have one call, plus calls <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">fib(n-1)</strong></span>
and <strong class="source-inline">fib(n-2)</strong>. A spreadsheet shows that <strong class="source-inline">calc(50)</strong> is 40,730,022,147 – <span class="No-Break">rather high!</span></p>
			<p>If you care for some algebra, it can be shown that calc(<em class="italic">n</em>)=5fib(<em class="italic">n</em>-1)+fib(<em class="italic">n</em>-4)-1, or that as <em class="italic">n</em> grows, calc(<em class="italic">n</em>) becomes approximately (1+√5)=3.236 times the value of fib(<em class="italic">n</em>) – but since this is not a math book, I won’t even mention <span class="No-Break">those results!</span></p>
			<p>6.4 <strong class="bold">A randomizing balancer</strong>: Using our <strong class="source-inline">shuffle()</strong> function from <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>,<em class="italic"> Behaving Properly</em>, we can write the following code. We remove the first function from the list before shuffling the rest, and we add it back at the end of the array to avoid repeating <span class="No-Break">any calls:</span></p>
			<pre class="source-code">
const randomizer =
  &lt;T extends (...x: any[]) =&gt; any&gt;(...fns: T[]) =&gt;
  (
    ...args: Parameters&lt;T&gt;
  ): ((...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
<strong class="bold">    const first: T = fns.shift() as T;</strong>
<strong class="bold">    fns = shuffle(fns);</strong>
<strong class="bold">    fns.push(first);</strong>
<strong class="bold">    return fns[0](...args);</strong>
  };</pre>
			<p>We need to add <strong class="source-inline">as T</strong> when assigning a value to <strong class="source-inline">first</strong>; otherwise, TypeScript will object because <strong class="source-inline">fns.shift()</strong> returns <strong class="source-inline">undefined</strong> if <strong class="source-inline">fns</strong> is empty. It wouldn’t be a bad idea to check that <strong class="source-inline">fns</strong> is not empty; can you <span class="No-Break">add it?</span></p>
			<p>A quick verification shows it fulfills all <span class="No-Break">our requirements:</span></p>
			<pre class="source-code">
const say1 = () =&gt; console.log(1);
const say22 = () =&gt; console.log(22);
const say333 = () =&gt; console.log(333);
const say4444 = () =&gt; console.log(4444);
const rrr = randomizer(say1, say22, say333, say4444);
rrr(); // 333
rrr(); // 4444
rrr(); // 333
rrr(); // 22
rrr(); // 333
rrr(); // 22
rrr(); // 333
rrr(); // 4444
rrr(); // 1
rrr(); // 4444</pre>
			<p>A minor consideration: the first function in the list can never be called the first time around because of the way <strong class="source-inline">randomizer()</strong> is written. Can you provide a better version that won’t have this slight defect so that all the functions in the list have the same chance of being called the <span class="No-Break">first time?</span></p>
			<p>6.5 <strong class="bold">Not in TypeScript</strong>: The following code does the job. The only difference between the functions is that one works with Boolean-returning functions and the other with <span class="No-Break">number-returning ones:</span></p>
			<pre class="source-code">
const not =
  <strong class="bold">&lt;T extends (...args: any[]) =&gt; boolean&gt;(fn: T)</strong> =&gt;
  <strong class="bold">(...args: Parameters&lt;T&gt;): boolean</strong> =&gt;
    !fn(...args);
const invert =
<strong class="bold">  &lt;T extends (...args: any[]) =&gt; number&gt;(fn: T) =&gt;</strong>
<strong class="bold">  (...args: Parameters&lt;T&gt;): number =&gt;</strong>
    -fn(...args);</pre>
			<p>6.6 <strong class="bold">Just say no!</strong> Call the original function and then use <strong class="source-inline">typeof</strong> to check whether the returned value is numeric or Boolean before deciding what to return. We must declare that the input function is either a Boolean-returning or a <span class="No-Break">number-returning function:</span></p>
			<pre class="source-code">
const opposite =
  &lt;T extends (...args: any[]) =&gt; number | boolean&gt;(fn: T)
    =&gt;
  (…args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    const result = fn(...args);</strong>
<strong class="bold">    return (</strong>
<strong class="bold">      typeof result === "boolean" ? !result : -result</strong>
    ) as any;
  };</pre>
			<p>6.7 <strong class="bold">Invert tests</strong>: We can quickly transform the example shown in the text into a real test; we’ll leave it up to you to write <span class="No-Break">more tests:</span></p>
			<pre class="source-code">
import { invert } from "../invert";
describe("invert", () =&gt; {
  it("can be used to sort Spanish words", () =&gt; {
    const spanishComparison = (
      a: string,
      b: string
    ): number =&gt; a.localeCompare(b, "es");
    const palabras = [
   "  "ñandú",
   "  "oasis",
   "  "mano",
   "  "natural",
   "  "mítico",
   "  "musical",
    ];
    expect(
 <strong class="bold">     palabras.sort(invert(spanishComparison))</strong>
    ).toEqual([
   "  "oasis",
   "  "ñandú",
   "  "natural",
   "  "musical",
   "  "mítico",
   "  "mano",
    ]);
  });
});</pre>
			<p>6.8 <strong class="bold">Why not shorter?</strong> The reason is that <strong class="source-inline">filter()</strong> expects to receive a function with three parameters (the <strong class="source-inline">A</strong>, <strong class="source-inline">number</strong>, and <strong class="source-inline">A[]</strong> types), and the type of <strong class="source-inline">not(fn)</strong> doesn’t <span class="No-Break">match that.</span></p>
			<p>6.9 <strong class="bold">Wrong function length</strong>: We can solve this problem by using <strong class="source-inline">eval()</strong> – which, in general, isn’t such a good idea! If you persist and insist, though, we can write a <strong class="source-inline">function.length</strong> preserving version of <strong class="source-inline">arity()</strong> as follows; let’scall <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">arityL()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { range } from "../../chapter 05/range";
function arityL&lt;T extends (...args: any[]) =&gt; any&gt;(
  n: number,
  fn: T
): (...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  const args1n = range(0, n)
    .map((i) =&gt; `x${i}`)
    .join(",");
  return <strong class="bold">eval(`(${args1n}) =&gt; ${fn.name}(${args1n})`)</strong>;
}</pre>
			<p>If you were to apply <strong class="source-inline">arityL()</strong> to <strong class="source-inline">Number.parseInt</strong>, the results would be as follows. The produced functions have the right <strong class="source-inline">length</strong> property, and their actual implementation is given in <span class="No-Break">the comments:</span></p>
			<pre class="source-code">
const parseInt1 = arityL(parseInt, 1);
// <strong class="bold">(x0) =&gt; parseInt(x0,x1)</strong> parseInt1.length === 1
const parseInt2 = arity(Number.parseInt,2)
// <strong class="bold">(x0,x1) =&gt; parseInt(x0,x1)</strong> parseInt2.length === 2</pre>
			<p>Do note, however, that TypeScript cannot determine the type of the resulting functions because that will be known <span class="No-Break">at runtime.</span></p>
			<p>6.10 <strong class="bold">Many arities!</strong> If we were working just with JavaScript, the following <span class="No-Break">would do:</span></p>
			<pre class="source-code">
const binary = (fn) =&gt; (...a) =&gt; fn(a[0], a[1]);
const ternary = (fn) =&gt; (...a) =&gt; fn(a[0], a[1], a[2]);</pre>
			<p>Adding data types, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const binary =
  &lt;T extends (...x: any[]) =&gt; any&gt;(
    fn: T
  ): ((
    arg0: Parameters&lt;T&gt;[0],
    arg1: Parameters&lt;T&gt;[1]
  ) =&gt; ReturnType&lt;T&gt;) =&gt;
  (x, y) =&gt;
    fn(x, y);
const ternary =
  &lt;T extends (...x: any[]) =&gt; any&gt;(
    fn: T
  ): ((
    arg0: Parameters&lt;T&gt;[0],
    arg1: Parameters&lt;T&gt;[1],
    arg2: Parameters&lt;T&gt;[2]
  ) =&gt; ReturnType&lt;T&gt;) =&gt;
  (x, y, z) =&gt;
    fn(x, y, z);</pre>
			<p>6.11 <strong class="bold">Throttling promises</strong>: Every time we actually do a call, we’ll set up a timer that will, in time, remove the promise from the cache. By default, let’s have a delay of 5 minutes. We’ll have a pool of timers, one per promise. In case of an error when calling the API, we’ll remove both the rejected promise and its <span class="No-Break">corresponding timer:</span></p>
			<pre class="source-code">
const promiseThrottle = &lt;
  A,
  T extends (...x: any[]) =&gt; Promise&lt;A&gt;
&gt;(
  fn: T,
<strong class="bold">  delay = 300_000  /* 5 minutes */</strong>
): ((...x: Parameters&lt;T&gt;) =&gt; Promise&lt;A&gt;) =&gt; {
  const cache = {} as Record&lt;string, Promise&lt;A&gt;&gt;;
<strong class="bold">  const timers = {} as Record&lt;</strong>
<strong class="bold">    string,</strong>
<strong class="bold">    ReturnType&lt;typeof setTimeout&gt;</strong>
<strong class="bold">  &gt;;</strong>
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    if (!(strX in timers)) {
      <strong class="bold">timers[strX] = setTimeout(() =&gt; {</strong>
<strong class="bold">        delete cache[strX];</strong>
<strong class="bold">        delete timers[strX];</strong>
<strong class="bold">      }, delay);</strong>
<strong class="bold">    }</strong>
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args).catch((x) =&gt; {
          delete cache[strX];
      <strong class="bold">    delete timers[strX];</strong>
          return x;
        }));
  };
};</pre>
			<p>6.12 <strong class="bold">All operators called</strong>: You would have all math operators (<strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, <strong class="source-inline">**</strong>, and <strong class="source-inline">%</strong>), all bitwise operators (<strong class="source-inline">&amp;</strong>, <strong class="source-inline">|</strong>, and <strong class="source-inline">^</strong>), all logical operators (<strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong>), all shift operators (<strong class="source-inline">&lt;&lt;</strong>, <strong class="source-inline">&gt;&gt;</strong>, and <strong class="source-inline">&gt;&gt;&gt;</strong>), all comparisons (<strong class="source-inline">&gt;</strong>, <strong class="source-inline">&gt;=</strong>, <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&lt;=</strong>, <strong class="source-inline">==</strong>, <strong class="source-inline">===</strong>, <strong class="source-inline">!=</strong>, and <strong class="source-inline">!==</strong>), and the new nullish coalescing operator (<strong class="source-inline">??</strong>). The comma operator could be included as well. Check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators</a> for more on <span class="No-Break">this topic.</span></p>
			<p>6.13 <strong class="bold">Missing companion</strong>: A simple one-line version could be as follows. Here, we use spreading to get a shallow copy of the original object and then set the specified attribute to its new value by using a computed property name. See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer</a> for <span class="No-Break">more details:</span></p>
			<pre class="source-code">
const setField = &lt;D&gt;(
  attr: keyof D,
  value: any,
  obj: D
) =&gt; ({
  ...obj,
  [attr]: value,
});</pre>
			<p>In <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, we wrote <strong class="source-inline">deepCopy()</strong>, which would be better than spreading when it comes to creating a totally new object instead of a shallow copy. By using this, we would have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const setField2 = &lt;D&gt;(
  attr: keyof D,
  value: any,
  obj: D
) =&gt; (<strong class="bold">{</strong>
<strong class="bold">  ...deepCopy(obj),</strong>
<strong class="bold">  [attr]: value,</strong>
<strong class="bold">}</strong>);</pre>
			<p>Finally, you could also look into modifying the <strong class="source-inline">updateObject()</strong> function, also from <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, by removing the freezing code; I’ll leave it up <span class="No-Break">to you.</span></p>
			<p>6.14 <strong class="bold">A border case</strong>: With plain JavaScript, applying the function to a <strong class="source-inline">null</strong> object would throw <span class="No-Break">an error:</span></p>
			<pre class="source-code">
const getField = attr =&gt; obj =&gt; obj[attr];
getField("someField")(null);
// <strong class="bold">Uncaught TypeError: Cannot read property 'a' of null</strong></pre>
			<p>With TypeScript, the code won’t compile because first, <strong class="source-inline">"someField"</strong> isn’t the name of an attribute, and second, <strong class="source-inline">null</strong> is not a <span class="No-Break">valid object:</span></p>
			<pre class="source-code">
const getField =
  &lt;D&gt;(f: keyof D) =&gt;
  (obj: D) =&gt;
    obj[f];</pre>
			<p>However, it’s still possible to do things “behind TypeScript’s back” and get the code accepted and the exception thrown. Having functions throw exceptions is not usually good in FP. You may opt to produce <strong class="source-inline">undefined</strong> instead, or work with monads, just like in <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>. A safer version of <strong class="source-inline">getField()</strong> would add a safeguard and return <strong class="source-inline">obj &amp;&amp; </strong><span class="No-Break"><strong class="source-inline">obj[f]</strong></span><span class="No-Break"> instead.</span></p>
			<p>6.15 <strong class="bold">Typed demethodizing</strong>: The three full definitions are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const demethodize1 =
  &lt;T extends (arg0: any, ...args: any[]) =&gt; any&gt;(fn: T) =&gt;
  (arg0: any, ...args: Parameters&lt;T&gt;) =&gt;
    fn.apply(arg0, args);
const demethodize2 =
  &lt;T extends (arg0: any, ...args: any[]) =&gt; any&gt;(fn: T) =&gt;
  (arg0: any, ...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt;
    fn.call(arg0, ...args);
const demethodize3 =
  &lt;T extends (arg0: any, ...args: any[]) =&gt; any&gt;(fn: T) =&gt;
  (arg0: any, ...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt;
    fn.bind(arg0, ...args)();</pre>
			<p>6.16 <strong class="bold">Not reinventing the wheel</strong>: We can use <strong class="source-inline">Math.max()</strong> and <strong class="source-inline">Math.min()</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const findMaximum2 = findOptimum2((x, y) =&gt; <strong class="bold">Math.max(x,</strong>
<strong class="bold">  y)</strong>);
const findMinimum2 = findOptimum2((x, y) =&gt; <strong class="bold">Math.min(x,</strong>
<strong class="bold">  y)</strong>);</pre>
			<p>Another way of writing this could be achieved by defining the <span class="No-Break">following first:</span></p>
			<pre class="source-code">
const max = (...arr: number[]): number =&gt; Math.max(...arr);
const min = (...arr: number[]): number =&gt; Math.min(...arr);</pre>
			<p>Then, we could write in a <span class="No-Break">pointfree style:</span></p>
			<pre class="source-code">
const findMaximum3 = findOptimum2(max);
const findMinimum3 = findOptimum2(min);</pre>
			<p>6.17 <strong class="bold">Comparing heroes</strong>: The first suggested change wouldn’t allow for ties in some features, where no hero beats the other. And, in fact, this points out a problem in our logic; if the first hero doesn’t beat the second one, we assume that the latter beat the former, not allowing for ties <span class="No-Break">between heroes.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor242"/>Chapter 7, Transforming Functions – Currying and Partial Application</h1>
			<p>7.1 <strong class="bold">Hard by hand</strong>: It would work; <strong class="source-inline">sum(3)</strong> returns a function with <strong class="source-inline">3</strong> already bound; <strong class="source-inline">sum(3)()</strong> returns the same, and <strong class="source-inline">sum(3)()(5)</strong> produces <span class="No-Break">the result.</span></p>
			<p>7.2 <strong class="bold">Sum as you will</strong>: The following <strong class="source-inline">sumMany()</strong> function does <span class="No-Break">the job:</span></p>
			<pre class="source-code">
const sumMany = <strong class="bold">(total: number) =&gt; (value?: number) =&gt;</strong>
<strong class="bold">  value === undefined ? total : sumMany(total + value);</strong>
sumMany(2)(2)(9)(6)(0)(-3)(); // 16</pre>
			<p>In JavaScript, the function poses no problem; with TypeScript, we’ll get an objection because it cannot determine that <strong class="source-inline">sumMany(2)</strong> is a function, not <span class="No-Break">a number.</span></p>
			<p>A small detail: can you fix the function so <strong class="source-inline">sumMany()</strong> will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">?</span></p>
			<p>7.3 <strong class="bold">Curry with eval?</strong> Let’s see this in <span class="No-Break">JavaScript first:</span></p>
			<pre class="source-code">
// curryByEval.js
function curryByEval(fn) {
  return eval(`${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join("=&gt;")} =&gt; ${fn.name}(${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join(",")})`);
}</pre>
			<p>This is quite a chunk of code to digest, and, in fact, it should instead be coded in several separate lines to make it more understandable. Let’s see how this works when applied to the <strong class="source-inline">make3()</strong> function <span class="No-Break">as input:</span></p>
			<ol>
				<li value="1">The <strong class="source-inline">range()</strong> function produces an array with the <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">0,1,2]</strong></span><span class="No-Break"> values.</span></li>
				<li>We use <strong class="source-inline">map()</strong> to generate a new array with the <strong class="source-inline">["</strong><span class="No-Break"><strong class="source-inline">x0","x1","x2"]</strong></span><span class="No-Break"> values.</span></li>
				<li>We use <strong class="source-inline">join()</strong>on the values in that array to produce <strong class="source-inline">x0=&gt;x1=&gt;x2</strong>, which will be the beginning of the code that we <span class="No-Break">will evaluate.</span></li>
				<li>We then add an arrow, the function’s name, and an opening parenthesis, to make the middle part of our newly generated code: <strong class="source-inline">=&gt; </strong><span class="No-Break"><strong class="source-inline">make3(</strong></span><span class="No-Break">.</span></li>
				<li>We use <strong class="source-inline">range()</strong>, <strong class="source-inline">map()</strong>, and <strong class="source-inline">join()</strong> again, but this time, to generate a list of <span class="No-Break">arguments: </span><span class="No-Break"><strong class="source-inline">x0,x1,x2</strong></span><span class="No-Break">.</span></li>
				<li>We finally add a closing parenthesis, and after applying <strong class="source-inline">eval()</strong>, we get the curried version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">make3()</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>After following all these steps, in our case, the resulting function would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
curryByEval(make3); // <strong class="bold">x0=&gt;x1=&gt;x2 =&gt; make3(x0,x1,x2)</strong></pre>
			<p>Typing is essentially the same as for our <strong class="source-inline">curry()</strong> function since we are getting the same parameter and producing the same output. Note, however, that we’re definitely “lying” to TypeScript because it wouldn’t be able to deduce what <strong class="source-inline">eval()</strong> was returning; it’s really up to us not to mess up! Without further ado, we can write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">function curryByEval&lt;A extends any[], R&gt;(</strong>
<strong class="bold">  fn: (...args: A) =&gt; R</strong>
<strong class="bold">): Curry&lt;A, R&gt;;</strong>
<strong class="bold">function curryByEval(fn: (...args: any) =&gt; any) </strong>{
  const pp = `${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join("=&gt;")} =&gt; ${fn.name}(${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join(",")})`;
}</pre>
			<p>We see we can do currying by using <strong class="source-inline">eval()</strong> – but there’s one remaining problem: if the original function didn’t have a name, the transformation wouldn’t work. We can work around the function name problem by including the actual code of the function to <span class="No-Break">be curried:</span></p>
			<pre class="source-code">
function curryByEval2&lt;A extends any[], R&gt;(
  fn: (...args: A) =&gt; R
): Curry&lt;A, R&gt;;
function curryByEval2(fn: (...args: any) =&gt; any) {
  return eval(`${range(0, fn.length)
    .map((i) =&gt; `x${i}`)
    .join("=&gt;")} =&gt;
<strong class="bold">    (${fn.toString()})</strong>
<strong class="bold">    (${range(0, fn.length)</strong>
<strong class="bold">      .map((i) =&gt; `x${i}`)</strong>
<strong class="bold">      .join(",")})`)</strong>;
}</pre>
			<p>The only change is that instead of including the original function name, we substitute its <span class="No-Break">actual code:</span></p>
			<pre class="source-code">
curryByEval2(make3);
// x0=&gt;x1=&gt;x2=&gt; <strong class="bold">((a, b, c) =&gt; `${a}:${b}:${c}`)</strong>(x0,x1,x2)</pre>
			<p>7.4 <strong class="bold">Uncurrying the curried</strong>: We can work similarly to what we did in the <span class="No-Break">previous question:</span></p>
			<pre class="source-code">
const uncurry = (fn, len) =&gt;
  eval(
    `(${range(0, len)
      .map((i) =&gt; `x${i}`)
      .join(",")}) =&gt; ${fn.name}${range(0, len)
      .map((i) =&gt; `(x${i})`)
      .join("")}`
  );</pre>
			<p>Earlier, when currying, given an <strong class="source-inline">fn()</strong> function with an arity of <strong class="source-inline">3</strong>, we would have generated <span class="No-Break">the following:</span></p>
			<pre class="source-code">
x0=&gt;x1=&gt;x2=&gt; make3(x0,x1,x2)</pre>
			<p>Now, to uncurry a function (say, <strong class="source-inline">curriedFn()</strong>), we want to do something very similar: the only difference is the placement of <span class="No-Break">the parentheses:</span></p>
			<pre class="source-code">
(x0,x1,x2) =&gt; curriedFn(x0)(x1)(x2)</pre>
			<p>The expected behavior is as follows – and let’s use the last result from the <span class="No-Break">previous question:</span></p>
			<pre class="source-code">
const curriedMake3 = (x0) =&gt; (x1) =&gt; (x2) =&gt;
  ((a, b, c) =&gt; `${a}:${b}:${c}`)(x0, x1, x2);
console.log(uncurry(curriedMake3, 3).toString());
// <strong class="bold">(x0,x1,x2) =&gt; curriedMake3(x0)(x1)(x2)</strong></pre>
			<p>If you want to consider a case in which the function to “uncurry” has no name, you can apply the same change we did in the previous question and include <strong class="source-inline">fn.toString()</strong> in <span class="No-Break">the output.</span></p>
			<p>7.5 <strong class="bold">Let me count the ways</strong>: If the function has <em class="italic">n</em> parameters, there are 2<span class="superscript">n-1</span> ways of calling it. This means that our three-parameter function could be called in 2<span class="superscript">2</span>=4 ways (correct!), a function with two parameters would allow 2<span class="superscript">1</span>=2 ways, and a function with just one parameter would allow only <span class="No-Break">2</span><span class="No-Break"><span class="superscript">0</span></span><span class="No-Break">=1 way.</span></p>
			<p>7.6 <strong class="bold">Currying by prototype</strong>: Basically, we are just transforming the <strong class="source-inline">curry()</strong> version so that it <span class="No-Break">uses this:</span></p>
			<pre class="source-code">
Function.prototype.curry = function () {
  return this.length === 0
    ? this()
    : (p) =&gt; this.bind(this, p).curry();
};</pre>
			<p>7.7 <strong class="bold">Shorter typing</strong>: The suggested earlier test shortens the code. We are essentially saying “<em class="italic">if there’s at least one argument, return a curried function; otherwise, return </em><span class="No-Break"><em class="italic">a value</em></span><span class="No-Break">”:</span></p>
			<pre class="source-code">
type Curry2&lt;P, R&gt; = P extends [infer H, ...infer T]
  ? (arg: H) =&gt; Curry2&lt;[...T], R&gt;
  : R;</pre>
			<p>7.8 <strong class="bold">Counting arguments</strong>: We can check whether <strong class="source-inline">P</strong> has a single type by checking <strong class="source-inline">P["length"]</strong> as follows – and to access that single type, we’ll have to <span class="No-Break">write </span><span class="No-Break"><strong class="source-inline">P[0]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Curry&lt;P extends any[], R&gt; = <strong class="bold">1 extends P["length"]</strong>
  ? (<strong class="bold">arg: P[0]</strong>) =&gt; R // only 1 arg
  : P extends [infer H, ...infer T] // 2 or more args
  ? (arg: H) =&gt; Curry&lt;[...T], R&gt;
  : never;</pre>
			<p>7.9 <strong class="bold">Working stylishly</strong>: We can do currying by hand for <strong class="source-inline">applyStyle()</strong> or by using our <strong class="source-inline">curry()</strong> function – let’s see <span class="No-Break">both ways:</span></p>
			<pre class="source-code">
const applyStyle =
  (style: string) =&gt;
  (text: string): string =&gt;
    `&lt;${style}&gt;${text}&lt;/${style}&gt;`;
const makeBold = <strong class="bold">applyStyle("b")</strong>;
console.log(makeBold("Montevideo"));
// <strong class="bold">&lt;b&gt;Montevideo&lt;/b&gt;</strong>
const applyStyle2 = (style: string, text: string): string
  =&gt;
  `&lt;${style}&gt;${text}&lt;/${style}&gt;`;
const makeUnderline = <strong class="bold">curry(applyStyle2)("u")</strong>;
console.log(makeUnderline("Uruguay"));
// <strong class="bold">&lt;u&gt;Uruguay&lt;/u&gt;</strong></pre>
			<p>7.10 <strong class="bold">Mystery questions function</strong>: It implements partial currying; a more understandable and better-named version of the <strong class="source-inline">what()</strong> function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const partial =
  (fn) =&gt;
  (...params) =&gt;
    fn.length &lt;= params.length
      ? fn(...params)
      : (...otherParams) =&gt;
          partial(fn)(...params, ...otherParams);</pre>
			<p>7.11 <strong class="bold">Partial transformations</strong>: Just apply the same transformation as in <em class="italic">Question 7.6</em> – take the original code we wrote, and replace all references to the function with references <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break">.</span></p>
			<p>7.12 <strong class="bold">Yet more curry!</strong> The <strong class="source-inline">curryN()</strong> function is an alternative version of our <strong class="source-inline">partialCurry()</strong>. The only difference is that if you provide all the arguments to a function, this new <strong class="source-inline">curryN()</strong> function directly calls the curried function, while <strong class="source-inline">partialCurry()</strong> would first bind the function to all its arguments and then recursively call it to return the final result – but the result would be precisely <span class="No-Break">the same.</span></p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor243"/>Chapter 8, Connecting Functions – Pipelining, Composition, and More</h1>
			<p>8.1 <strong class="bold">Headline capitalization</strong>: We can make use of several functional equivalents of different methods, such as <strong class="source-inline">split()</strong>, <strong class="source-inline">map()</strong>, and <strong class="source-inline">join()</strong>. Using <strong class="source-inline">demethodize()</strong> from <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, and <strong class="source-inline">flipTwo()</strong> from <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>, would have also <span class="No-Break">been possible:</span></p>
			<pre class="source-code">
const split = (str: string) =&gt; (text: string) =&gt;
  text.split(str);
const map =
  (fn: (x: string) =&gt; string) =&gt; (arr: string[]) =&gt;
    arr.map(fn);
const firstToUpper = (word: string): string =&gt;
  word[0].toUpperCase() + word.substring(1).toLowerCase();
const join = (str: string) =&gt; (arr: string[]) =&gt;
  arr.join(str);
const headline = <strong class="bold">pipeline(</strong>
<strong class="bold">  split(" "),</strong>
<strong class="bold">  map(firstToUpper),</strong>
<strong class="bold">  join(" ")</strong>
<strong class="bold">)</strong>;</pre>
			<p>The pipeline works as expected: we split the string into words, we map each word to make its first letter uppercase, and we join the array elements to form a string again. We could have used <strong class="source-inline">reduce()</strong> for the last step, but <strong class="source-inline">join()</strong> already does what we need, so why reinvent <span class="No-Break">the wheel?</span></p>
			<pre class="source-code">
console.log(headline("Alice's ADVENTURES in WoNdErLaNd"));
// Alice's Adventures In Wonderland</pre>
			<p>8.2 <strong class="bold">Pending tasks</strong>: The following pipeline does <span class="No-Break">the job:</span></p>
			<pre class="source-code">
const getField = attr =&gt; obj =&gt; obj[attr]; const filter =
  fn =&gt; arr =&gt; arr.filter(fn); const map = fn =&gt; arr =&gt;
  arr.map(fn);
const reduce = (fn, init) =&gt; arr =&gt; arr.reduce(fn, init);
const pending = (listOfTasks, name) =&gt; pipeline(
getField("byPerson"),
filter(t =&gt; t.responsible === name), map(t =&gt; t.tasks),
reduce((y, x) =&gt; x, []), filter(t =&gt; t &amp;&amp; !t.done),
  map(getField("id"))
)(allTasks || {byPerson: []}); //</pre>
			<p>The <strong class="source-inline">reduce()</strong> call may be mystifying. By that time, we are handling an array with a single element – an object – and we want the object in the pipeline, not the array. This code works even if the responsible person doesn’t exist, or if all the tasks have been completed; can you see why? Also, note that if <strong class="source-inline">allTasks</strong> is <strong class="source-inline">null</strong>, an object must be provided with the <strong class="source-inline">byPerson</strong> property so that future functions won’t crash! For an even better solution, I think monads are better: see <em class="italic">Question 12.1</em> <span class="No-Break">for more.</span></p>
			<p>8.3 <strong class="bold">Thinking in abstract terms</strong>: The simple solution implies composing. I preferred it to pipelining in order to keep the list of functions in the <span class="No-Break">same order:</span></p>
			<pre class="source-code">
const getSomeResults2 = compose(sort, group, filter, select);</pre>
			<p>8.4 <strong class="bold">Reversing types</strong>: We can apply recursion to reverse a list <span class="No-Break">of types:</span></p>
			<pre class="source-code">
type Reverse&lt;FNS extends FN[]&gt; = 1 extends FNS["length"]
  ? [FNS[0]]
  : FNS extends [
      infer FN1st extends FN,
      ...infer FNRest extends FN[]
    ]
  ? [...Reverse&lt;FNRest&gt;, FN1st]
  : never;</pre>
			<p>With this, we can define <strong class="source-inline">Compose&lt;&gt;</strong> in terms <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Pipeline&lt;&gt;</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Compose&lt;FNS extends FN[]&gt; = <strong class="bold">Pipeline&lt;Reverse&lt;FNS&gt;&gt;</strong>;
function compose1&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): Compose&lt;FNS&gt; {
  <strong class="bold">return pipeline(...fns.reverse()) as Compose&lt;FNS&gt;</strong>;
}</pre>
			<p>Instead of an overload, we’re using a cast here to let TypeScript know what types we are <span class="No-Break">working with.</span></p>
			<p>8.5 <strong class="bold">Empty pipeline?</strong> The <strong class="source-inline">pipeline()</strong> function we wrote accesses <strong class="source-inline">fns[0]</strong> without checking whether the <strong class="source-inline">fns</strong> array is empty, so it won’t work. The <strong class="source-inline">pipeline1()</strong> and <strong class="source-inline">pipeline2()</strong> functions use <strong class="source-inline">reduce()</strong> without an initial value, so they will also fail. We must add an initial test, so if no functions are provided (<strong class="source-inline">fns.length===0</strong>), we’ll simply return the input value as <span class="No-Break">the result.</span></p>
			<p>8.6 <strong class="bold">Undetected impurity?</strong> Yes, the function is impure, but using it as-is would fall squarely under the <strong class="bold">Sorta Functional Programming</strong> (<strong class="bold">SFP</strong>) style we mentioned back in the <em class="italic">Theory versus practice</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Becoming Functional</em>. The version we used is not pure, but in the way we use it, the final results are pure: we modify an array in place, but it’s a new array that we are creating. The alternate implementation is pure and also works, but will be slower since it creates a completely new array every time we call it. So, accepting this bit of impurity helps us get a function that performs better; we can <span class="No-Break">accept that!</span></p>
			<p>8.7 <strong class="bold">Needless transducing?</strong> If you only had a sequence of <strong class="source-inline">map()</strong> operations, you could apply a single <strong class="source-inline">map()</strong> by pipelining all the mapping functions into a single one. For <strong class="source-inline">filter()</strong> operations, it becomes a bit harder, but here’s a tip: use <strong class="source-inline">reduce()</strong> to apply all the filters in sequence with a carefully thought-out <span class="No-Break">accumulating function.</span></p>
			<p>8.8 <strong class="bold">What type?</strong> According to the definition of <strong class="source-inline">chainify()</strong>, the type of <strong class="source-inline">myCity2</strong> is <strong class="source-inline">Chainify&lt;City&gt;</strong>. Attributes have the same types as before, but the <strong class="source-inline">void</strong>-returning methods now return an object of the same <span class="No-Break"><strong class="source-inline">Chainify&lt;City&gt;</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
{
    name: string;
    lat: number;
    long: number;
    extra: boolean;
    getName: () =&gt; string;
<strong class="bold">    setName: (newName: string) =&gt; Chainify&lt;City&gt;;</strong>
<strong class="bold">    setLat: (newLat: number) =&gt; Chainify&lt;City&gt;;</strong>
<strong class="bold">    setLong: (newLong: number) =&gt; Chainify&lt;City&gt;;</strong>
    getCoords: () =&gt; number[];
}</pre>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor244"/>Chapter 9, Designing Functions – Recursion</h1>
			<p>9.1 <strong class="bold">Into reverse</strong>: An empty string is reversed by simply doing nothing. To reverse a non-empty string, remove its first character, reverse the rest, and append the removed character at the end. For example, <strong class="source-inline">reverse("MONTEVIDEO")</strong> can be found by doing <strong class="source-inline">reverse("ONTEVIDEO")+"M"</strong>. In the same way, <strong class="source-inline">reverse("ONTEVIDEO")</strong> would be equal to <strong class="source-inline">reverse("NTEVIDEO")+"O"</strong>, and <span class="No-Break">so on:</span></p>
			<pre class="source-code">
const reverse = (str: string): string =&gt;
  str.length === 0 ? "" : <strong class="bold">reverse(str.slice(1)) + str[0]</strong>;</pre>
			<p>9.2 <strong class="bold">Climbing steps</strong>: To climb a ladder with <em class="italic">n</em> steps, we can act in <span class="No-Break">two ways:</span></p>
			<ul>
				<li>Climb one single step and then climb an (<em class="italic">n</em>-1) <span class="No-Break">steps ladder</span></li>
				<li>Climb two steps at once and then climb an (<em class="italic">n</em>-2) <span class="No-Break">steps ladder</span></li>
			</ul>
			<p>So, if we call ladder(<em class="italic">n</em>) the number of ways to climb a steps ladder, we know that ladder(n)= ladder(<em class="italic">n</em>-1) + ladder(<em class="italic">n</em>-2). Adding the fact that ladder(0)=1 (there’s only one way to climb a ladder with no steps: do nothing) and ladder(1)=1, the solution is that ladder(<em class="italic">n</em>) equals the (<em class="italic">n</em>-1)<span class="superscript">th</span> Fibonacci number! Check it out: ladder(2)=2, ladder(3)=3, ladder(4)=5, and <span class="No-Break">so on.</span></p>
			<p>9.3 <strong class="bold">Sorting recursively</strong>: Let’s look at the first of these algorithms; many of the techniques here will help you write the other sorts. If the array is empty, sorting it produces a (new) empty array. Otherwise, we find the maximum value of the array (<strong class="source-inline">max</strong>), create a new copy of the array but without that element, sort the copy, and then return the sorted copy with <strong class="source-inline">max</strong> added at the end. Take a look at how we dealt with the mutator functions to avoid modifying the original array and note that this sorting code only works with numbers because of the way we <span class="No-Break">find </span><span class="No-Break"><strong class="source-inline">max</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const selectionSort = (arr: number[]): number[] =&gt; {
  if (arr.length === 0) {
    <strong class="bold">return []</strong>;
  } else {
    const max = Math.max(...arr);
    const rest = [...arr];
    rest.splice(arr.indexOf(max), 1);
   <strong class="bold"> return [...selectionSort(rest), max]</strong>;
  }
};
selectionSort([2, 2, 0, 9, 1, 9, 6, 0]);
// <strong class="bold">[0, 0, 1, 2, 2, 6, 9, 9]</strong></pre>
			<p>9.4 <strong class="bold">What could go wrong?</strong> This would fail if, at any time, the array (or subarray) to be sorted consisted of all equal values. In that case, <strong class="source-inline">smaller</strong> would be an empty array, and <strong class="source-inline">greaterEqual</strong> would be equal to the whole array to sort, so the logic would enter an <span class="No-Break">infinite loop.</span></p>
			<p>The original code can never enter a loop because every pass removes one element (the pivot) so you’re guaranteed to reach a state with nothing left <span class="No-Break">to sort.</span></p>
			<p>9.5 <strong class="bold">More efficiency</strong>: The following code does the work for us. Here, we use a ternary operator to decide where to push the <span class="No-Break">new item:</span></p>
			<pre class="source-code">
const partition = &lt;A&gt;(
  arr: A[],
  fn: (x: A) =&gt; boolean
): [A[], A[]] =&gt;
  arr.reduce(
    (result: [A[], A[]], elem: A) =&gt; {
      result[fn(elem) ? 0 : 1].push(elem);
      return result;
    },
    [[], []]
  );</pre>
			<p>9.6 <strong class="bold">Completing callbacks</strong>: Code is very much along the same lines as <strong class="source-inline">mapR()</strong>, so I’ll skip repeating explanations – the only difference is in the <strong class="source-inline">return</strong> value, which is now a value from the array (<strong class="source-inline">arr[0]</strong> in <strong class="source-inline">findLoop()</strong>) instead of a mapped whole array as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">mapR()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Opt&lt;X&gt; = X | undefined;
const findR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): Opt&lt;A&gt; =&gt; {
  const findLoop = (arr: Opt&lt;A&gt;[], i: number): Opt&lt;A&gt; =&gt;
    arr.length === 0
      ? undefined
      : !(0 in arr) || arr[0] === undefined
      ? findLoop(arr.slice(1), I + 1)
      : cb(arr[0], i, orig)
      ? arr[0]
      : findLoop(arr.slice(1), i + 1);
  return findLoop(orig, 0);
};</pre>
			<p>9.7 <strong class="bold">Recursive logic</strong>: Again, we can take inspiration from our <strong class="source-inline">mapR()</strong> example, so I won’t comment on the looping, types, and so on. When programming <strong class="source-inline">everyR()</strong>, we must be careful what to do with empty arrays or missing places; the standard <strong class="source-inline">every()</strong> method considers them to return <strong class="source-inline">true</strong>, so we’ll do <span class="No-Break">the same:</span></p>
			<pre class="source-code">
type Opt&lt;X&gt; = X | undefined;
const everyR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): boolean =&gt; {
  const everyLoop = (arr: Opt&lt;A&gt;[], i: number): boolean =&gt;
    arr.length === 0
      ? true
      : !(0 in arr) || arr[0] === undefined
      ? true
      : !cb(arr[0], i, orig)
      ? false
      : everyLoop(arr.slice(1), i + 1);
  return everyLoop(orig, 0);
};</pre>
			<p>When programming <strong class="source-inline">someR()</strong>, an empty array means a false result, but empty places <span class="No-Break">are skipped:</span></p>
			<pre class="source-code">
type Opt&lt;X&gt; = X | undefined;
const someR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): boolean =&gt; {
  const someLoop = (arr: Opt&lt;A&gt;[], i: number): boolean =&gt;
    arr.length === 0
      ? false
      : !(0 in arr) || arr[0] === undefined
      ? someLoop(arr.slice(1), i + 1)
      : cb(arr[0], i, orig)
      ? true
      : someLoop(arr.slice(1), i + 1);
  return someLoop(orig, 0);
};</pre>
			<p>9.8 <strong class="bold">Symmetrical queens</strong>: The key to finding only symmetric solutions is as follows. After the first four queens have been (tentatively) placed on the first half of the board, we don’t have to try all the possible positions for the other queens; they are automatically determined with regard to the <span class="No-Break">first ones:</span></p>
			<pre class="source-code">
const SIZE = 8;
const places = Array(SIZE);
const checkPlace = (column: number, row: number): boolean
  =&gt;
  places
    .slice(0, column)
    .every(
      (v, i) =&gt;
        v !== row &amp;&amp; Math.abs(v - row) !== column - i
    );
const symmetricFinder = (column = 0): void =&gt; {
  if (column === SIZE) {
    console.log(JSON.stringify(places.map((x) =&gt; x + 1)));
  } else if (column &lt;= SIZE / 2) {
    // first half of the board?
    const testRowsInColumn = (j: number): void =&gt; {
      if (j &lt; SIZE) {
        if (checkPlace(column, j)) {
          places[column] = j;
          symmetricFinder(column + 1);
        }
        testRowsInColumn(j + 1);
      }
    };
    testRowsInColumn(0);
  } else {
    <strong class="bold">// second half of the board</strong>
<strong class="bold">    const symmetric = SIZE - 1 - places[SIZE - 1 - column];</strong>
<strong class="bold">    if (checkPlace(column, symmetric)) {</strong>
<strong class="bold">      places[column] = symmetric;</strong>
<strong class="bold">      symmetricFinder(column + 1);</strong>
<strong class="bold">    }</strong>
  }
};</pre>
			<p>Calling <strong class="source-inline">symmetricFinder()</strong> produces four solutions, which are essentially the same. Make drawings and check them to make sure the solution <span class="No-Break">is correct!</span></p>
			<pre class="console">
[3,5,2,8,1,7,4,6]
[4,6,8,2,7,1,3,5]
[5,3,1,7,2,8,6,4]
[6,4,7,1,8,2,5,3]</pre>
			<p>9.9 <strong class="bold">Longest common subsequence</strong>: The length of the <strong class="bold">longest common sequence</strong> (<strong class="bold">LCS</strong>) of two strings, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, can be found with recursion <span class="No-Break">as follows:</span></p>
			<ul>
				<li>If the length of <strong class="source-inline">a</strong> is zero, or if the length of <strong class="source-inline">b</strong> is zero, <span class="No-Break">return zero</span></li>
				<li>If the first characters of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> match, the answer is 1 plus the LCS of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, both minus their <span class="No-Break">initial characters</span></li>
				<li>If the first characters of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> do not match, the answer is the largest of the following <span class="No-Break">two results:</span><ul><li>The LCS of <strong class="source-inline">a</strong> minus its initial character, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">b</strong></span></li><li>The LCS of <strong class="source-inline">a</strong>, and <strong class="source-inline">b</strong> minus its <span class="No-Break">initial character</span></li></ul></li>
			</ul>
			<p>We can implement this as follows. We do memoization “by hand” to avoid repeating calculations; we could have also used our <span class="No-Break">memoization function:</span></p>
			<pre class="source-code">
const LCS = (strA: string, strB: string): number =&gt; {
  // memoization "by hand"
  const cache: { [k: string]: number } = {};
  const innerLCS = (strA: string, strB: string): number =&gt;
    {
    const key = strA + "/" + strB;
    let ret: number;
    if (!(key in cache)) {
      if (strA.length === 0 || strB.length === 0) {
        ret = 0;
      } else if (strA[0] === strB[0]) {
        ret = 1 + innerLCS(strA.substr(1), strB.substr(1));
      } else {
        ret = Math.max(
          innerLCS(strA, strB.substr(1)),
          innerLCS(strA.substr(1), strB)
        );
      }
      cache[key] = ret;
    }
    return cache[key];
  };
  return innerLCS(strA, strB);
};
console.log(LCS("INTERNATIONAL", "CONTRACTOR"));
// 6, as in the text</pre>
			<p>As an extra exercise, you could produce not only the length of the LCS but also the characters that <span class="No-Break">are involved.</span></p>
			<p>9.10 <strong class="bold">At odds with JavaScript</strong>: I’ll show over a dozen solutions, but I’m certain there are even more. The first solution is the obvious one: divide by <strong class="source-inline">2</strong> and check whether the remainder <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function isOdd1(n: number): boolean {
  return n % 2 === 1;
}</pre>
			<p>You could have another solution by doing <strong class="source-inline">return Boolean(n % </strong><span class="No-Break"><strong class="source-inline">2)</strong></span><span class="No-Break"> instead:</span></p>
			<pre class="source-code">
function isOdd2(n: number): boolean {
  return Boolean(n % 2);  // or !!(n % 2) instead
}</pre>
			<p>Another way is to divide the number by 2 and check whether it has a <span class="No-Break">fractional part:</span></p>
			<pre class="source-code">
function isOdd3(n: number): boolean {
  return Math.floor(n / 2) !== n / 2;
}</pre>
			<p>If a number is odd, dividing it by 2 and dividing its predecessor by 2, both results have the same integer part (for instance, 9/2 and 8/2 both have integer <span class="No-Break">part 4):</span></p>
			<pre class="source-code">
function isOdd4(n: number): boolean {
  return Math.floor(n / 2) === Math.floor((n - 1) / 2);
}</pre>
			<p>Using bit operations is fast; an odd number will have its least significant bit set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function isOdd5(n: number): boolean {
  return (n &amp; 1) === 1;
}</pre>
			<p>As in <strong class="source-inline">isOdd1()</strong>, you get another variation by doing <strong class="source-inline">return Boolean(n &amp; </strong><span class="No-Break"><strong class="source-inline">1)</strong></span><span class="No-Break"> instead:</span></p>
			<pre class="source-code">
function isOdd6(n: number): boolean {
  return Boolean(n &amp; 1); // or !!(n &amp; 1) instead
}</pre>
			<p>Shifting in binary also works; if we shift the number one bit to the right (dropping its least significant bit) and then shift the number back one bit to the left, for an odd number, we don’t get the <span class="No-Break">same result:</span></p>
			<pre class="source-code">
function isOdd7(n: number): boolean {
  return (n &gt;&gt; 1) &lt;&lt; 1 !== n;
}</pre>
			<p>Shifting to the right is the same as dividing by 2 and keeping the integer part, so this solution is basically the same as the <span class="No-Break">third one:</span></p>
			<pre class="source-code">
function isOdd8(n: number): boolean {
  return n &gt;&gt; 1 === (n - 1) &gt;&gt; 1;
}</pre>
			<p>Odd numbers end in 1, 3, 5, 7, or 9, so we can also look at the string representation of the number and check <span class="No-Break">its value:</span></p>
			<pre class="source-code">
function isOdd9(n: number): boolean {
  return "13579".includes(String(n).at(-1)!);
}</pre>
			<p>We could work with the string by using <strong class="source-inline">find()</strong> or <strong class="source-inline">indexOf()</strong>; I’ll leave these versions <span class="No-Break">to you.</span></p>
			<p>9.11 <strong class="bold">Odds and evens trampolining</strong>: We must first change our mutually recursive functions to work with continuations, and return calls <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">trampoline()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function isEven(n: number, cont: FN): () =&gt; boolean {
  if (n === 0) {
    return <strong class="bold">trampoline(() =&gt; cont(true))</strong>;
  } else {
    return <strong class="bold">trampoline(() =&gt; isOdd(n - 1, (v) =&gt; cont(v)))</strong>;
  }
}
function isOdd(n: number, cont: FN): () =&gt; boolean {
  return <strong class="bold">trampoline(() =&gt; isEven(n, (v) =&gt; cont(!v)))</strong>;
}</pre>
			<p>For instance, the first <strong class="source-inline">return</strong> in <strong class="source-inline">isEven()</strong> used to be <strong class="source-inline">return true</strong>; now we trampoline a thunk that will call a continuation with <strong class="source-inline">true</strong>. We can now finish the job by providing an appropriate continuation that just returns the <span class="No-Break">calculated value:</span></p>
			<pre class="source-code">
function isEvenT(n: number): boolean {
  return <strong class="bold">trampoline(isEven(n, (x) =&gt; x))</strong>;
}
function isOddT(n: number): boolean {
  return <strong class="bold">trampoline(isOdd(n, (x) =&gt; x))</strong>;
}
console.log("22.. isEven?", isEvenT(22));  // true
console.log("9... isOdd?", isOddT(5));     // true
console.log("63... isEven?", isEvenT(63)); // false
console.log("60... isOdd?", isOddT(60));   // false</pre>
			<p>9.12 <strong class="bold">Mutual problem?</strong> If you do <strong class="source-inline">isEven(1)</strong> or <strong class="source-inline">isOdd(2)</strong>, you get an infinite loop; can you see why? (The same will happen if you replace <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong> with any odd or even number, respectively.) A hint: the problem is with the base cases <span class="No-Break">for recursion.</span></p>
			<p>9.13 <strong class="bold">Say no to whiles?</strong> Yes, the code is equivalent. We are replacing <strong class="source-inline">while()</strong> with a <strong class="source-inline">for(;;)</strong> loop and breaking out with <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">return</strong></span><span class="No-Break">.</span></p>
			<p>9.14 <strong class="bold">Power, more power!</strong> We’ll need to add a new <strong class="source-inline">power()</strong> function, sitting between <strong class="source-inline">term()</strong> and <strong class="source-inline">factor()</strong>, so its priority will be <span class="No-Break">correctly placed.</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_2_B19301.jpg" alt="Figure 2 – Power represents a sequence of exponentiations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2 – Power represents a sequence of exponentiations</p>
			<p>We’ll change <strong class="source-inline">term()</strong> to call <strong class="source-inline">power()</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">factor()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function term(): number {
  let accum = power();
  while (
    tokens[curr] === TIMES ||
    tokens[curr] === DIVIDES ||
    tokens[curr] === MODULUS
  ) {
    if (tokens[curr] === TIMES) {
      curr++;
      <strong class="bold">accum *= power()</strong>;
    } else if (tokens[curr] === DIVIDES) {
      curr++;
      <strong class="bold">accum /= power()</strong>;
    } else if (tokens[curr] === MODULUS) {
      curr++;
      <strong class="bold">accum %= power()</strong>;
    }
  }
  return accum;
}</pre>
			<p>To properly calculate “towers” such as 2^3^4, we’ll store <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and <strong class="source-inline">4</strong> in an array, and then reduce it from right to left: we’ll first calculate 3^4, and then 2^(the calculated result <span class="No-Break">for 3^4):</span></p>
			<pre class="source-code">
function power(): number {
  const tower = [factor()];
  while (tokens[curr] === POWER) {
    curr++;
    tower.push(factor());
  }
  while (tower.length &gt; 1) {
    tower[tower.length - 2] **= tower[tower.length - 1];
    tower.pop();
  }
  return tower[0];
}</pre>
			<p>9.15 <strong class="bold">Error-prone evaluation</strong>: Here are <span class="No-Break">some ideas:</span></p>
			<ul>
				<li>When skipping a token, check if it’s correct anyway; for instance, <strong class="source-inline">factor()</strong> skips the second parenthesis without actually checking whether it is, so it would evaluate “(1+2]” as 3, even though <span class="No-Break">it’s wrong.</span></li>
				<li>Add a special end-of-string (EOS) token, to check whether the evaluation finishes at <span class="No-Break">that token.</span></li>
				<li>Check you do not go beyond the end of the <strong class="source-inline">tokens</strong> array whenever you advance to the <span class="No-Break">next token.</span></li>
			</ul>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor245"/>Chapter 10, Ensuring Purity – Immutability</h1>
			<p>10.1 <strong class="bold">Not just date problems</strong>: We can see more limitations of <strong class="source-inline">jsonCopy()</strong> in the following example, but don’t assume there aren’t any <span class="No-Break">more problems:</span></p>
			<pre class="source-code">
const agent = {
  error: new Error("It's stirred; I ordered it shaken"),
  map: new Map([["James", "Bond"]]),
  set: new Set([0, 0, 7]),
  regex: /007/,
  useLicense() {
    console.log("Bang! Bang!");
  },
};
console.log(jsonCopy(agent));
/*
{ <strong class="bold">error: {}, map: {}, set: {}, regex: {} </strong>}
*/</pre>
			<p>Four of the properties got transformed into an empty object, and the function <span class="No-Break">was ignored.</span></p>
			<p>10.2 <strong class="bold">The mote in jsonCopy’s eye…</strong> Our <strong class="source-inline">deepCopy()</strong> function does marginally better; with the same agent object as in the previous question, copying produces <span class="No-Break">the following:</span></p>
			<pre class="source-code">
/*
{
  error: Error: It's stirred; I ordered it shaken
    ...many lines snipped out
  map: Map(0) {},
  set: Set(0) {},
  regex: /(?:)/,
  useLicense: [Function: useLicense]
}
*/</pre>
			<p>The error and the function got converted OK. The map and the set were converted into the right types, but they are empty; this could be fixed by adding logic that would scan the original objects and insert copies of them into the new ones. (<em class="italic">Question 10.10</em> may help.) Finally, cloning a regular expression is a tad harder, but google “<em class="italic">clone regexp in JavaScript</em>” and you’ll find several implementations <span class="No-Break">for this.</span></p>
			<p>10.3 <strong class="bold">Going in circles</strong>: We may fix this by using a memoizing-style solution, as in <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, Behaving Properly</em>. After we copy an object, we’ll store a reference in a map. Before we try to copy any object, we’ll first see whether we copied it earlier (by looking for it in the map) and if so, we won’t do any new copying and will just use what we found in the map. Our new <strong class="source-inline">deepCopy2()</strong> function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const deepCopy2 = &lt;O extends OBJ&gt;(obj: O): O =&gt; {
  <strong class="bold">const mapped = new Map&lt;O, O&gt;();</strong>
  const deepCopy = (obj: O): O =&gt; {
    let aux: O = obj;
    if (obj &amp;&amp; typeof obj === "object") {
<strong class="bold">      if (mapped.has(obj)) {</strong>
<strong class="bold">        return mapped.get(obj) as O;</strong>
<strong class="bold">      }</strong>
      aux = new (obj as any).constructor();
<strong class="bold">      mapped.set(obj, aux);</strong>
      Object.getOwnPropertyNames(obj).forEach((prop) =&gt; {
        (aux as any)[prop as keyof O] =
          deepCopy(obj[prop]);
      });
    }
    return aux;
  };
  return deepCopy(obj);
};</pre>
			<p>We’ll use the <strong class="source-inline">mapped</strong> variable for our map. When we find that we have to clone an <strong class="source-inline">obj</strong> object, we first check (<strong class="source-inline">mapped.has(obj)</strong>) whether we have already done that, and if so, we return the value from the map. If this was a new, not yet copied object, we add it and its <strong class="source-inline">aux</strong> copy to the map (<strong class="source-inline">mapped.set(obj,aux)</strong>) for <span class="No-Break">future reference.</span></p>
			<p>We can verify how this work with a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
const circular = {
  a: 1,
  b: { c: 3, d: { e: 5, f: null } }
};
circular.b.d.f = circular.b as any;
console.log(deepCopy2(circular));
/*
{
  a: 1,
  b: <strong class="bold">&lt;ref *1&gt;</strong> { c: 3, d: { e: 5, f: <strong class="bold">[Circular *1]</strong> } }
}
*/</pre>
			<p>If we use <strong class="source-inline">deepCopy()</strong> on <strong class="source-inline">circular</strong>, we’ll get a <strong class="source-inline">RangeError: Maximum call stack size exceeded</strong> exception. However, with our new <strong class="source-inline">deepCopy2()</strong> function, the circular reference is tackled with <span class="No-Break">no problem.</span></p>
			<p>10.4 <strong class="bold">Freezing by proxying</strong>: As requested, a proxy allows you to intercept changes on an object. (See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a> for more on this.) We use recursion to apply the proxy all the way down in case some attributes are <span class="No-Break">objects themselves:</span></p>
			<pre class="source-code">
const proxySetAll = (obj: OBJ): OBJ =&gt; {
  Object.keys(obj).forEach((v) =&gt; {
    if (typeof obj[v] === "object") {
      obj[v] = proxySetAll(obj[v]);
    }
  });
  return new Proxy(obj, {
    set() {
      throw new Error("DON'T MODIFY ANYTHING IN ME");
    },
    deleteProperty() {
      throw new Error("DON'T DELETE ANYTHING IN ME");
    },
  }) as OBJ;
};</pre>
			<p>The following is the output of the preceding code. For real-life implementations, you’d probably require something other than a <strong class="source-inline">DON'T MODIFY ANYTHING IN ME</strong> message, <span class="No-Break">of course!</span></p>
			<pre class="console">
const myObj = <strong class="bold">proxySetAll</strong>({
  a: 5,
  b: 6,
  c: { d: 7, e: 8 },
});
myObj.a = 777;
// Uncaught Error: DON'T MODIFY ANYTHING IN ME
myObj.f = 888;
// Uncaught Error: DON'T MODIFY ANYTHING IN ME
delete myObj.b;
// Uncaught Error: DON'T DELETE ANYTHING IN ME</pre>
			<p>10.5 <strong class="bold">Inserting into a list, persistently</strong>: Using recursion helps out <span class="No-Break">as follows:</span></p>
			<ul>
				<li>If the list is empty, we cannot insert the <span class="No-Break">new key.</span></li>
				<li>If we are at a node whose key is <strong class="source-inline">oldKey</strong>, we create a clone of that node that points at a list that starts with a new node with <strong class="source-inline">newKey</strong> as its value and a pointer to the rest of the original <span class="No-Break">node’s list.</span></li>
				<li>If we are at a node whose key isn’t <strong class="source-inline">oldKey</strong>, we create a clone of the node and (recursively) insert the new key somewhere in the rest of the original <span class="No-Break">node’s list:</span></li>
			</ul>
			<pre class="source-code">
type NODE_PTR = Node | null;
const insertAfter = (
  list: NODE_PTR,
  newKey: string,
  oldKey: string
): NODE_PTR =&gt; {
  if (list === null) {
    return null;
  } else if (list.key === oldKey) {
    return new Node(list.key, new Node(newKey, list.next));
  } else {
    return new Node(
      list.key,
      insertAfter(list.next, newKey, oldKey)
    );
  }
};</pre>
			<p>In the following code, we can see this working. The new list is similar to the one shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em>. However, printing out the lists (<strong class="source-inline">c3</strong> and <strong class="source-inline">newList</strong>) wouldn’t be enough; you wouldn’t be able to distinguish new or old nodes, so I’ve included <span class="No-Break">several comparisons:</span></p>
			<pre class="source-code">
const c3 =
  new Node("G",
    new Node("B",
      new Node("F",
        new Node("A",
          new Node("C",
            new Node("E", null))))));
const newList = insertAfter(c3, "D", "B");
console.log(c3 === newList);
// false
console.log(c3!.key === newList!.key);
// true (both are "G")
console.log(c3!.next === newList!.next);
// false
console.log(c3!.next!.key === newList!.next!.key);
// true (both are "B")
console.log(c3!.next!.next === newList!.next!.next);
// false
console.log(c3!.next!.next!.key === "F");
// true
console.log(newList!.next!.next!.key === "D");
// true
console.log(
  c3!.next!.next!.next === newList!.next!.next!.next!.next
);
// true – after F, the list is the old one</pre>
			<p>A lot of <strong class="source-inline">!</strong> non-null assertions were needed to inform TypeScript that no <strong class="source-inline">null</strong> values <span class="No-Break">were around.</span></p>
			<p>A new question: In the preceding logic, nothing is inserted if <strong class="source-inline">oldKey</strong> isn’t found. Can you change the logic so, in that case, the new node is added at the end of <span class="No-Break">the list?</span></p>
			<p>10.6 <strong class="bold">Composing many lenses</strong>: We want to compose lenses from left to right so we can directly use <strong class="source-inline">reduce()</strong>. Let’s write the <strong class="source-inline">composeManyLenses()</strong> function and apply it to the same example that was shown in <span class="No-Break">the text:</span></p>
			<pre class="source-code">
const composeManyLenses = &lt;O extends OBJ&gt;(
  ...lenses: LENS&lt;O&gt;[]
) =&gt;
  lenses.reduce((acc, lens) =&gt; composeTwoLenses(acc,
    lens));</pre>
			<p>With the <strong class="source-inline">deepObject</strong> example seen earlier, plus all the lenses to get <strong class="source-inline">c</strong>, <strong class="source-inline">e</strong>, <strong class="source-inline">g</strong>, and so on, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const deepObject = {
  a: 1,
  b: 2,
  c: {
    d: 3,
    e: {
      f: 6,
      g: { i: 9, j: { <strong class="bold">k: 11</strong> } },
      h: 8,
    },
  },
};
console.log(
  view(composeManyLenses(lC, lE, lG, lJ, lK), deepObject)
);
// <strong class="bold">11, same as earlier</strong></pre>
			<p>10.7 <strong class="bold">Lenses by path</strong>: Hint – the needed changes would be similar to what we did when we went from <strong class="source-inline">getField()</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">getByPath()</strong></span><span class="No-Break">.</span></p>
			<p>10.8 <strong class="bold">Accessing virtual attributes</strong>: Using a getter is always viable, and for this question, you’d write something like the following, and you’d have a getter for the virtual <span class="No-Break"><strong class="source-inline">fullName</strong></span><span class="No-Break"> attribute:</span></p>
			<pre class="source-code">
const lastNameLens = composeTwoLenses(
  lensProp("name"),
  lensProp("last")
);
const firstNameLens = composeTwoLenses(
  lensProp("name"),
  lensProp("first")
);
const fullNameGetter = &lt;O extends OBJ&gt;(obj: O): string =&gt;
  `${view(lastNameLens)(obj)},
    ${view(firstNameLens)(obj)}`;</pre>
			<p>Being able to set several attributes based on a single value isn’t always possible, but if we assume the incoming name is in the <strong class="source-inline">LAST,FIRST</strong> format, we can split it by the comma and assign the two parts to the first and last <span class="No-Break">names, respectively:</span></p>
			<pre class="source-code">
const fullNameSetter =
  &lt;O extends OBJ&gt;(fullName: string) =&gt;
  (obj: O): O =&gt; {
<strong class="bold">    const parts = fullName.split(",");</strong>
<strong class="bold">    return set(firstNameLens)(parts[1])(</strong>
<strong class="bold">      set(lastNameLens)(parts[0])(obj)</strong>
<strong class="bold">    ) as O;</strong>
  };
const fullNameLens = lens(fullNameGetter, fullNameSetter);</pre>
			<p>10.9 <strong class="bold">Lenses for arrays?</strong> The <strong class="source-inline">view()</strong> function would work well, but <strong class="source-inline">set()</strong> and <strong class="source-inline">over()</strong> wouldn’t work in a pure way since <strong class="source-inline">setArray()</strong> doesn’t return a new array; instead, it modifies the current one in place. Take a look at the following question for a <span class="No-Break">related problem.</span></p>
			<p>10.10 <strong class="bold">Lenses into maps</strong>: Getting a value from the map poses no problem, but for setting, we need to clone <span class="No-Break">the map:</span></p>
			<pre class="source-code">
const getMap =
  &lt;K, V&gt;(key: K) =&gt;
  (map: Map&lt;K, V&gt;) =&gt;
    <strong class="bold">map.get(key)</strong>;
const setMap =
  &lt;K, V&gt;(key: K) =&gt;
  (value: V) =&gt;
  (map: Map&lt;K, V&gt;) =&gt;
    <strong class="bold">new Map(map).set(key, value)</strong>;
const lensMap = &lt;K, V&gt;(key: K) =&gt;
  lens(getMap&lt;K, V&gt;(key), setMap&lt;K, V&gt;(key));</pre>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor246"/>Chapter 11, Implementing Design Patterns – The Functional Way</h1>
			<p>11.1 <strong class="bold">Decorating methods, the future way</strong>: As we’ve already mentioned, decorators aren’t a fixed, definitive feature at the moment. However, by following <a href="http://tc39.github.io/proposal-decorators/">tc39.github.io/proposal-decorators/</a>, we can write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const logging = (target, name, descriptor) =&gt; {
  const savedMethod = descriptor.value;
  descriptor.value = function (...args) {
    console.log(`entering ${name}: ${args}`);
    try {
      const valueToReturn =
        savedMethod.bind(this)(...args);
      console.log(`exiting ${name}: ${valueToReturn}`);
      return valueToReturn;
    } catch (thrownError) {
      console.log(`exiting ${name}: threw ${thrownError}`);
      throw thrownError;
    }
  };
  return descriptor;
};</pre>
			<p>We want to add a <strong class="source-inline">@logging</strong> decoration to a method. We save the original method in <strong class="source-inline">savedMethod</strong> and substitute a new method that will log the received arguments, call the original method to save its return value, log that, and finally return it. If the original method throws an exception, we catch it, report it, and throw it again so that it can be processed as expected. A simple example of this is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class SumThree {
  constructor(z) {
    this.z = z;
  }
<strong class="bold">  @logging</strong>
  sum(x, y) {
    return x + y + this.z;
  }
}
new SumThree(100).sum(20, 8);
// entering sum: 20,8
// exiting sum: 128</pre>
			<p>11.2 <strong class="bold">Decorator with mixins</strong>: We write an <strong class="source-inline">addBar()</strong> function that receives a <strong class="source-inline">Base</strong> class and extends it. In this case, I decided to add a new attribute and a new method. The constructor for the extended class calls the original constructor and creates the <strong class="source-inline">barValue</strong> attribute. The new class has both the original’s <strong class="source-inline">doSomething()</strong> method and the new <span class="No-Break"><strong class="source-inline">somethingElse()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
const addBar = (Base) =&gt;
  class extends Base {
    constructor(fooValue, barValue) {
      super(fooValue);
      this.barValue = barValue;
    }
    somethingElse() {
      console.log(
        "something added: bar... ",
        this.barValue
      );
    }
  };</pre>
			<p>11.3 <strong class="bold">Multi-clicking by hand</strong>: There are various ways to achieve this with timers and counting, but make sure that you don’t interfere with single- or double-click detection! You can also use a common listener and look at <strong class="source-inline">event.detail</strong>; you can find out more <span class="No-Break">at </span><a href="http://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail</span></a><span class="No-Break">.</span></p>
			<p>11.4 <strong class="bold">Sorting logically</strong>: If you have, say, a <strong class="source-inline">flags</strong> array with Boolean values, you don’t need any special comparison function; <strong class="source-inline">flags.sort()</strong> works “out of the box” and will place <strong class="source-inline">false</strong> values first and <strong class="source-inline">true</strong> values last. This is because the standard sort works by converting values into strings, and then comparing them; when you do this, Boolean values become <strong class="source-inline">"false"</strong> and <strong class="source-inline">"true"</strong>, and as <strong class="source-inline">"false" &lt; "true"</strong>, everything turns <span class="No-Break">out well!</span></p>
			<p>11.5 <strong class="bold">Finding routes, objectively</strong>: The standard solution would be to have an abstract <strong class="source-inline">RouteFinder</strong> class with several subclasses, such as <strong class="source-inline">ByFootRouteFinder</strong>, <strong class="source-inline">BicycleRouteFinder</strong>, and so on, each implementing a <strong class="source-inline">findRouteAlgorithm()</strong> method in a different way, and a factory that chooses what subclass <span class="No-Break">to instantiate.</span></p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor247"/>Chapter 12, Building Better Containers – Functional Data Types</h1>
			<p>12.1 <strong class="bold">Extending prototypes</strong>: Here are the needed definitions to add a <strong class="source-inline">map()</strong> method to Booleans, numbers, <span class="No-Break">and strings:</span></p>
			<pre class="source-code">
declare global {
  interface Boolean {
    map(_f: (_x: boolean) =&gt; boolean): boolean;
  }
}
declare global {
  interface Number {
    map(_f: (_x: number) =&gt; number): number;
  }
}
declare global {
  interface String {
    map(_f: (_x: string) =&gt; string): string;
  }
}</pre>
			<p>Some examples are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Boolean.prototype.map = function (
  this: boolean,
  fn: (_x: boolean) =&gt; any
) {
  return !!fn(this);
};
const t = true;
const f = false;
const negate = (x: boolean) =&gt; !x;
console.log(t.map(negate), f.map(negate));
// false true
Number.prototype.map = function (
  this: number,
  fn: (_x: number) =&gt; number
) {
  return Number(fn(this));
};
const n = 22;
const add1 = (n: number) =&gt; n + 1;
console.log(n.map(add1));
// 23
String.prototype.map = function (
  this: string,
  fn: (_x: string) =&gt; string
) {
  return String(fn(this));
};
const s = "Montevideo";
const addBangs = (s: string): string =&gt; s + "!!!";
console.log(s.map(addBangs));
// Montevideo!!!</pre>
			<p>12.2 <strong class="bold">No protection?</strong> In previous editions of the book, I used a <strong class="source-inline">Symbol</strong>, whose value was defined inside a module and not exported, so nobody could access the <span class="No-Break">corresponding attribute:</span></p>
			<pre class="source-code">
<strong class="bold">const VALUE = Symbol("Value");</strong>
class Container {
  constructor(x) {
    <strong class="bold">this[VALUE] = x;</strong>
  }
  map(fn) {
    return <strong class="bold">fn(this[VALUE])</strong>;
  }
  .
  . other methods
  .
}</pre>
			<p>Using a <strong class="source-inline">Symbol</strong> helps hide the field: the property key won’t show up in <strong class="source-inline">Object.keys()</strong> or in <strong class="source-inline">for...in</strong> or <strong class="source-inline">for...of</strong> loops, making them more meddle-proof. (If you haven’t worked with JavaScript symbols, possibly the least known of its primitive data types, you might want to check <span class="No-Break">out </span><a href="http://developer.mozilla.org/en-US/docs/Glossary/symbol"><span class="No-Break">developer.mozilla.org/en-US/docs/Glossary/symbol</span></a><span class="No-Break">.)</span></p>
			<p>The <strong class="source-inline">map()</strong> method could access the “protected” attribute because it had access to the <strong class="source-inline">VALUE</strong> symbol, but without that, you cannot get at <span class="No-Break">the attribute.</span></p>
			<p>12.3 <strong class="bold">No abstract classes?</strong> You have to add a check at the constructor. If you want the <strong class="source-inline">XXX</strong> class to be abstract, it should start <span class="No-Break">like this:</span></p>
			<pre class="source-code">
class XXX {
  constructor(...) {
<strong class="bold">    if (this.constructor === XXX) {</strong>
<strong class="bold">      throw new Error("Cannot initialize XXX class")</strong>
<strong class="bold">    }</strong>
    .
    . rest of the constructor
    .
  }
  .
  . other methods
  .
}</pre>
			<p>12.4 <strong class="bold">Maybe tasks?</strong> The following code shows a simpler solution than the one we looked <span class="No-Break">at earlier:</span></p>
			<pre class="source-code">
const pending = Maybe.of(listOfTasks)
  .map(getField("byPerson"))
  .map(filter((t) =&gt; t.responsible === name))
  .map((t) =&gt; tasks)
  .map((t) =&gt; t[0])
  .map(filter((t) =&gt; !t.done))
  .map(getField("id"))
  .valueOf();</pre>
			<p>Here, we apply one function after the other, secure in the knowledge that if any of these functions produces an empty result (or even if the original <strong class="source-inline">listOfTasks</strong> is null), the sequence of calls will go on. In the end, you will either get an array of task IDs or a <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> value.</span></p>
			<p>12.5 <strong class="bold">Extending your trees</strong>: Calculating the tree’s height is simple if you do this in a recursive fashion. The height of an empty tree is zero, while the height of a non-empty tree is one (for the root) plus the maximum height of its left and <span class="No-Break">right subtrees:</span></p>
			<pre class="source-code">
const treeHeight = &lt;A&gt;(tree: TREE&lt;A&gt;): number =&gt;
  tree(
    (val, left, right) =&gt;
      1 + Math.max(treeHeight(left), treeHeight(right)),
    () =&gt; 0
  );</pre>
			<p>Listing the keys in order is a well-known requirement. Because of the way that the tree is built, you list the left subtree’s keys first, then the root, and finally the right subtree’s keys, all in a <span class="No-Break">recursive fashion:</span></p>
			<pre class="source-code">
const treeList = &lt;A&gt;(tree: TREE&lt;A&gt;): void =&gt;
  tree(
    (value, left, right) =&gt; {
      treeList(left);
      console.log(value);
      treeList(right);
    },
    () =&gt; {
      // nothing
    }
  );</pre>
			<p>Finally, deleting a key from a binary search tree is a bit more complex. First, you must locate the node that is going to be removed, and then there are <span class="No-Break">several cases:</span></p>
			<ul>
				<li>If the node has no subtrees, deletion <span class="No-Break">is simple.</span></li>
				<li>If the node has only one subtree, you just replace the node with <span class="No-Break">its subtree</span></li>
				<li>If the node has two subtrees, then you have to do <span class="No-Break">the following:</span><ul><li>Find the minimum key in the tree with a <span class="No-Break">greater key</span></li><li>Place it in the <span class="No-Break">node’s place</span></li></ul></li>
			</ul>
			<p>Since this algorithm is well covered in all computer science textbooks, I won’t go into more detail about <span class="No-Break">this here:</span></p>
			<pre class="source-code">
const treeRemove = &lt;A&gt;(
  toRemove: A,
  tree: TREE&lt;A&gt;
): TREE&lt;A&gt; =&gt;
  tree(
    (val, left, right) =&gt; {
      const findMinimumAndRemove = (
        tree: TREE&lt;A&gt; /* never empty */
      ): { min: A; tree: TREE&lt;A&gt; } =&gt;
        tree(
          (value, left, right) =&gt; {
            if (treeIsEmpty(left)) {
              return { min: value, tree: right };
            } else {
              const result = findMinimumAndRemove(left);
              return {
                min: result.min,
                tree: Tree(value, result.tree, right),
              };
            }
          },
          () =&gt; {
            /* not needed */
          }
        );
      if (toRemove &lt; val) {
        return Tree(val, treeRemove(toRemove, left),
          right);
      } else if (toRemove &gt; val) {
        return Tree(val, left, treeRemove(toRemove,
          right));
      } else if (treeIsEmpty(left) &amp;&amp; treeIsEmpty(right)) {
        return EmptyTree();
      } else if (treeIsEmpty(left) !== treeIsEmpty(right))
        {
        return tree(
          (val, left, right) =&gt;
            left(
              () =&gt; left,
              () =&gt; right
            ),
          () =&gt; {
            /* not needed */
          }
        );
      } else {
        const result = findMinimumAndRemove(right);
        return Tree(result.min, left, result.tree);
      }
    },
    () =&gt; tree
  );</pre>
			<p>12.6 <strong class="bold">Code shortening</strong>: The first thing you would do is get rid of the first ternary operator by taking advantage of the short-circuit evaluation of the <strong class="source-inline">||</strong> <span class="No-Break">operator:</span></p>
			<pre class="source-code">
const treeSearch2 = &lt;A&gt;(
  findValue: A,
  tree: TREE&lt;A&gt;
): boolean =&gt;
  tree(
    (value, left, right) =&gt;
      findValue === value ||
      (findValue &lt; value
        ? treeSearch2(findValue, left)
        : treeSearch2(findValue, right)),
    () =&gt; false
  );</pre>
			<p>Also, seeing that both alternatives in the second ternary operator are very similar, you could also do some <span class="No-Break">shortening there:</span></p>
			<pre class="source-code">
const treeSearch3 = &lt;A&gt;(
  findValue: A,
  tree: TREE&lt;A&gt;
): boolean =&gt;
  tree(
    (value, left, right) =&gt;
      findValue === value ||
      treeSearch3(
        findValue,
        findValue &lt; value ? left : right
      ),
    () =&gt; false
  );</pre>
			<p>Remember: shorter doesn’t imply better! However, I’ve found many examples of this kind of code tightening, and it’s better if you have been exposed to <span class="No-Break">it, too.</span></p>
			<p>12.7 <strong class="bold">Functional lists</strong>: Let’s add to the samples that have already been provided. We can simplify working with lists if we can transform a list into an array, and <span class="No-Break">vice versa:</span></p>
			<pre class="source-code">
const listToArray = &lt;A&gt;(list: LIST&lt;A&gt;): A[] =&gt;
  list(
    (head, tail) =&gt; [head, ...listToArray(tail)],
    () =&gt; []
  );
const listFromArray = &lt;A&gt;(arr: A[]): LIST&lt;A&gt; =&gt;
  arr.length
    ? NewList(arr[0], listFromArray(arr.slice(1)))
    : EmptyList();</pre>
			<p>Concatenating two lists together and appending a value to a list have simple recursive implementations. We can also reverse a list by using the <span class="No-Break">appending function:</span></p>
			<pre class="source-code">
const listConcat = &lt;A&gt;(list1: LIST&lt;A&gt;, list2: LIST&lt;A&gt;) =&gt;
  list1(
    (head, tail) =&gt; NewList(head, listConcat(tail, list2)),
    () =&gt; list2
  );
const listAppend = &lt;A&gt;(list: LIST&lt;A&gt;, value: A): LIST&lt;A&gt; =&gt;
  list(
    (head, tail) =&gt; NewList(head, listAppend(tail, value)),
    () =&gt; NewList(value, EmptyList())
  );
const listReverse = &lt;A&gt;(list: LIST&lt;A&gt;): LIST&lt;A&gt; =&gt;
  list(
    (head, tail) =&gt; listAppend(listReverse(tail), head),
    () =&gt; EmptyList()
  );</pre>
			<p>Finally, the basic <strong class="source-inline">map()</strong>, <strong class="source-inline">filter()</strong>, and <strong class="source-inline">reduce()</strong> operations are good <span class="No-Break">to have:</span></p>
			<pre class="source-code">
const listMap = &lt;A, B&gt;(
  list: LIST&lt;A&gt;,
  fn: (_x: A) =&gt; B
): LIST&lt;B&gt; =&gt;
  list(
    (head, tail) =&gt; NewList(fn(head), listMap(tail, fn)),
    EmptyList
  );
const listFilter = &lt;A&gt;(
  list: LIST&lt;A&gt;,
  fn: (_x: A) =&gt; boolean
): LIST&lt;A&gt; =&gt;
  list(
    (head, tail) =&gt;
      fn(head)
        ? NewList(head, listFilter(tail, fn))
        : listFilter(tail, fn),
    EmptyList
  );
const listReduce = &lt;A, B&gt;(
  list: LIST&lt;A&gt;,
  fn: (_acc: B, _val: A) =&gt; B,
  accum: B
): B =&gt;
  list(
    (head, tail) =&gt; listReduce(tail, fn, fn(accum, head)),
    () =&gt; accum
  );</pre>
			<p>The following are some exercises that have been left for you to tackle. Generate a printable version of <span class="No-Break">a list:</span></p>
			<ul>
				<li>Compare two lists to see whether they have the same values, in the <span class="No-Break">same order</span></li>
				<li>Search a list for <span class="No-Break">a value</span></li>
				<li>Get, update, or remove the value at the <em class="italic">n</em>th position of <span class="No-Break">a list</span></li>
			</ul>
			<p>12.8 <strong class="bold">No Boolean operators?</strong> Let’s start by defining a <strong class="source-inline">BOOLEAN</strong> type and two special functions, <strong class="source-inline">TRUE</strong> and <strong class="source-inline">FALSE</strong>, which will stand for the usual <strong class="source-inline">true</strong> and <span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break"> values:</span></p>
			<pre class="source-code">
type BOOLEAN = (_true: any, _false: any) =&gt; any;
const TRUE: BOOLEAN = (trueValue: any, __: any) =&gt;
  trueValue;
const FALSE: BOOLEAN = (__: any, falseValue: any) =&gt;
  falseValue;</pre>
			<p>The <strong class="source-inline">BOOLEAN</strong> type receives two values and returns one of those. A <strong class="source-inline">TRUE</strong> Boolean returns the first of those two values; a <strong class="source-inline">FALSE</strong> Boolean returns the second. We can construct and check variables <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const MakeBool = (value: boolean) =&gt; (value ? TRUE :
  FALSE);
const valueOf = (boolValue: BOOLEAN): boolean =&gt;
  boolValue(true, false);
console.log("LOG T  ", valueOf(TRUE));
console.log("LOG F  ", valueOf(FALSE));
// true false
console.log("VAL T  ", valueOf(MakeBool(true)));
console.log("VAL F  ", valueOf(MakeBool(false)));
// true false</pre>
			<p>We can now <span class="No-Break">define operators:</span></p>
			<pre class="source-code">
const NOT = (boolValue: BOOLEAN): BOOLEAN =&gt;
  boolValue(FALSE, TRUE);
const AND = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(boolRight, FALSE);
const OR = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(TRUE, boolRight);
const XOR = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(NOT(boolRight), boolRight);
const EQU = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(boolRight, NOT(boolRight));
const IMP = (
  boolLeft: BOOLEAN,
  boolRight: BOOLEAN
): BOOLEAN =&gt; boolLeft(boolRight, TRUE);</pre>
			<p>These are not the only possibilities, but I’ll leave you to discover alternatives. Finally, we could have an <strong class="source-inline">ifElse()</strong> function to work with these <strong class="source-inline">BOOLEAN</strong>  values <span class="No-Break">and thunks:</span></p>
			<pre class="source-code">
const ifElse = (
  boolValue: BOOLEAN,
  fnTRUE: FN,
  fnFALSE: FN
) =&gt; boolValue(fnTRUE, fnFALSE)();
ifElse(
  TRUE,
  () =&gt; console.log("I'm true"),
  () =&gt; console.log("I'm false")
);
// true
ifElse(
  FALSE,
  () =&gt; console.log("I'm true"),
  () =&gt; console.log("I'm false")
);
// false</pre>
			<p>A final comment: this code goes to show more things that you <em class="italic">could</em> do with functions, but it doesn’t mean you <em class="italic">should</em> do them this way! You can read the following <span class="No-Break">at </span><a href="http://www.usrsb.in/Building-Data-Structures-from-Functions.html"><span class="No-Break">www.usrsb.in/Building-Data-Structures-from-Functions.html</span></a><span class="No-Break">:</span></p>
			<p class="author-quote">In the end, this might strike you as nothing more than a useless programming trick. In a sense that’s right. I’d never use this in my own code. What makes this technique so valuable is that it actually fits into the broader context of lambda calculus, which is a mathematical abstraction of computation.</p>
			<p>Couldn’t say it <span class="No-Break">better myself!</span></p>
		</div>
	

		<div id="_idContainer079">
			<h1 id="_idParaDest-246"><a id="_idTextAnchor248"/>Bibliography</h1>
			<p>The following texts are freely <span class="No-Break">available online:</span></p>
			<ul>
				<li><em class="italic">ECMA-262: ECMAScript 2022 Language Specification</em>, latest edition (currently the 13<span class="superscript">th</span>) at <a href="http://www.ecma-international.org/ecma-262/">www.ecma-international.org/ecma-262/</a>. This provides the official standard for the current version <span class="No-Break">of JavaScript.</span></li>
				<li><em class="italic">Eloquent JavaScript</em>, Second Edition, by <em class="italic">Marijn Haverbeke</em>, <span class="No-Break">at </span><a href="http://eloquentjavascript.net/"><span class="No-Break">eloquentjavascript.net/</span></a></li>
				<li><em class="italic">JavaScript for Impatient Programmers (ES2022 edition)</em>, by <em class="italic">Dr. Axel </em><span class="No-Break"><em class="italic">Rauschmayer</em></span><span class="No-Break">, at</span>
<a href="http://exploringjs.com/impatient-js/"><span class="No-Break">exploringjs.com/impatient-js/</span></a></li>
				<li><em class="italic">Functional-Light JavaScript</em>, by <em class="italic">Kyle Simpson</em>, <span class="No-Break">at </span><a href="http://github.com/getify/Functional-Light-JS"><span class="No-Break">github.com/getify/Functional-Light-JS</span></a></li>
				<li><em class="italic">JavaScript Allongé (the “six” edition)</em>, by <em class="italic">Reginald Braithwaite</em>, <span class="No-Break">at </span><a href="http://leanpub.com/javascriptallongesix/read"><span class="No-Break">leanpub.com/javascriptallongesix/read</span></a></li>
				<li><em class="italic">Professor Frisby’s Mostly Adequate Guide to Functional Programming</em>, by <em class="italic">Dr. Boolean</em> (<em class="italic">Brian Lonsdorf</em>), <span class="No-Break">at </span><a href="http://github.com/MostlyAdequate/mostly-adequate-guide"><span class="No-Break">github.com/MostlyAdequate/mostly-adequate-guide</span></a></li>
			</ul>
			<p>If you prefer printed books, you can go with <span class="No-Break">this list:</span></p>
			<ul>
				<li><em class="italic">Beginning Functional JavaScript</em>, by <em class="italic">Anto Aravinth</em>, <span class="No-Break"><em class="italic">Apress</em></span><span class="No-Break">, 2017</span></li>
				<li><em class="italic">Discover Functional JavaScript</em>, by <em class="italic">Cristian Salcescu</em>, (independently <span class="No-Break">published), 2019</span></li>
				<li><em class="italic">Functional JavaScript</em>, by <em class="italic">Michael Fogus</em>, <em class="italic">O’Reilly </em><span class="No-Break"><em class="italic">Media</em></span><span class="No-Break">, 2013</span></li>
				<li><em class="italic">Functional Programming in JavaScript</em>, by <em class="italic">Dan Mantyla</em>, <em class="italic">Packt </em><span class="No-Break"><em class="italic">Publishing</em></span><span class="No-Break">, 2015</span></li>
				<li><em class="italic">Functional Programming in JavaScript</em>, by <em class="italic">Luis Atencio</em>, <em class="italic">Manning </em><span class="No-Break"><em class="italic">Publications</em></span><span class="No-Break">, 2016</span></li>
				<li><em class="italic">Grokking Simplicity – Taming complex software with functional thinking</em>, by <em class="italic">Eric Normand</em>, <em class="italic">Manning </em><span class="No-Break"><em class="italic">Publications</em></span><span class="No-Break">, 2021</span></li>
				<li><em class="italic">Hands-on Functional Programming with TypeScript</em>, by <em class="italic">Remo Jansen</em>, <em class="italic">Packt </em><span class="No-Break"><em class="italic">Publishing</em></span><span class="No-Break">, 2019</span></li>
				<li><em class="italic">Introduction to Functional Programming</em>, by <em class="italic">Richard Bird and Philip Wadler</em>, <em class="italic">Prentice Hall International</em>, 1988. A more theoretical point of view, not dealing specifically <span class="No-Break">with JavaScript</span></li>
				<li><em class="italic">Pro JavaScript Design Patterns</em>, by <em class="italic">Ross Harmes and Dustin Díaz</em>, <span class="No-Break"><em class="italic">Apress</em></span><span class="No-Break">, 2008</span></li>
				<li><em class="italic">Secrets of the JavaScript Ninja</em>, by John Resig and Bear Bibeault, <em class="italic">Manning </em><span class="No-Break"><em class="italic">Publications</em></span><span class="No-Break">, 2012</span></li>
				<li><em class="italic">TypeScript 4 Design Patterns and Best Practices</em>, by <em class="italic">Theo Despoudis</em>, <em class="italic">Packt </em><span class="No-Break"><em class="italic">Publishing</em></span><span class="No-Break">, 2021</span></li>
			</ul>
			<p>Also interesting, though with a lesser focus on functional programming, are <span class="No-Break">the following:</span></p>
			<ul>
				<li><em class="italic">High-Performance JavaScript</em>, by <em class="italic">Nicholas Zakas</em>, <em class="italic">O’Reilly </em><span class="No-Break"><em class="italic">Media</em></span><span class="No-Break">, 2010</span></li>
				<li><em class="italic">JavaScript Patterns</em>, by <em class="italic">Stoyan Stefanov</em>, <em class="italic">O’Reilly </em><span class="No-Break"><em class="italic">Media</em></span><span class="No-Break">, 2010</span></li>
				<li><em class="italic">JavaScript: The Good Parts</em>, by <em class="italic">Douglas Crockford</em>, <em class="italic">O’Reilly </em><span class="No-Break"><em class="italic">Media</em></span><span class="No-Break">, 2008</span></li>
				<li><em class="italic">JavaScript with Promises</em>, by <em class="italic">Daniel Parker</em>, <em class="italic">O’Reilly </em><span class="No-Break"><em class="italic">Media</em></span><span class="No-Break">, 2015</span></li>
				<li><em class="italic">Learning JavaScript Design Patterns</em>, by <em class="italic">Addy Osmani</em>, <em class="italic">O’Reilly </em><span class="No-Break"><em class="italic">Media</em></span><span class="No-Break">, 2012</span></li>
				<li><em class="italic">Mastering JavaScript Design Patterns</em>, <em class="italic">Second Edition</em>, by <em class="italic">Simon Timms</em>, <em class="italic">Packt </em><span class="No-Break"><em class="italic">Publishing</em></span><span class="No-Break">, 2016</span></li>
				<li><em class="italic">Mastering JavaScript High Performance</em>, by <em class="italic">Chad Adams</em>, <em class="italic">Packt </em><span class="No-Break"><em class="italic">Publishing</em></span><span class="No-Break">, 2015</span></li>
				<li><em class="italic">Pro JavaScript Performance</em>, by <em class="italic">Tom Barker</em>, <span class="No-Break"><em class="italic">Apress</em></span><span class="No-Break">, 2012</span></li>
			</ul>
			<p>These titles are on the subject of reactive <span class="No-Break">functional programming:</span></p>
			<ul>
				<li><em class="italic">Mastering Reactive JavaScript</em>, by <em class="italic">Erich de Souza Oliveira</em>, <em class="italic">Packt </em><span class="No-Break"><em class="italic">Publishing</em></span><span class="No-Break">, 2017</span></li>
				<li><em class="italic">Reactive Programming with Node.js</em>, by <em class="italic">Fernando Doglio</em>, <span class="No-Break"><em class="italic">Apress</em></span><span class="No-Break">, 2016</span></li>
				<li><em class="italic">Reactive Programming with RxJS</em>, by <em class="italic">Sergi Mansilla</em>, <em class="italic">The Pragmatic </em><span class="No-Break"><em class="italic">Programmers</em></span><span class="No-Break">, 2015</span></li>
			</ul>
		</div>
	</body></html>