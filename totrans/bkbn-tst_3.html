<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Test Assertions, Specs, and Suites"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Test Assertions, Specs, and Suites</h1></div></div></div><p>With a Backbone.js application integrated into our budding test infrastructure and a rough test plan underway, we will now begin expanding our application's test coverage. In this chapter, we will introduce some fundamental testing tools and test more parts of the Backbone.js application in the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Surveying the Mocha and Chai test library interfaces and styles</li><li class="listitem" style="list-style-type: disc">Introducing the Chai assertion library API</li><li class="listitem" style="list-style-type: disc">Configuring the Mocha runner and the Backbone.js application for tests</li><li class="listitem" style="list-style-type: disc">Aggregating Mocha specifications into test suites and preparing test state</li><li class="listitem" style="list-style-type: disc">Writing test specifications in Mocha, beginning with Backbone.js collection specs</li><li class="listitem" style="list-style-type: disc">Testing asynchronous application code</li><li class="listitem" style="list-style-type: disc">Writing specs and HTML test fixtures for Backbone.js views</li><li class="listitem" style="list-style-type: disc">Dealing with software/test development pitfalls and learning how to write testable code</li></ul></div><div class="section" title="Choosing a test style that fits"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Choosing a test style that fits</h1></div></div></div><p>Mocha and Chai both provide <a id="id134" class="indexterm"/>different library interfaces for writing tests. This conveniently allows developers to choose an appropriate test paradigm or style for different projects while still leveraging the same underlying functionality.</p><div class="section" title="Mocha test interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Mocha test interfaces</h2></div></div></div><p>Mocha currently offers four interfaces for test suites and specifications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id135" class="indexterm"/><span class="strong"><strong>Behavior-Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>)<a id="id136" class="indexterm"/> interface: This <a id="id137" class="indexterm"/>interface uses test constructs<a id="id138" class="indexterm"/> similar to those popularized by the Ruby RSpec framework (<a class="ulink" href="http://rspec.info/">http://rspec.info/</a>).</li><li class="listitem" style="list-style-type: disc">The<a id="id139" class="indexterm"/> <span class="strong"><strong>Test-Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>)<a id="id140" class="indexterm"/> interface: This interface uses<a id="id141" class="indexterm"/> more traditional unit test keywords such as <code class="literal">suite</code> and <code class="literal">test</code>.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>exports</strong></span><a id="id142" class="indexterm"/> interface: This interface utilizes a modular format<a id="id143" class="indexterm"/> familiar to<a id="id144" class="indexterm"/> Node.js/CommonJS developers, implementing the test functionality as properties of a <code class="literal">module.exports</code> object.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>QUnit</strong></span>-styled<a id="id145" class="indexterm"/> interface: This <a id="id146" class="indexterm"/>interface uses a flat declaration paradigm taken from the popular QUnit test framework<a id="id147" class="indexterm"/> (<a class="ulink" href="http://qunitjs.com/">http://qunitjs.com/</a>). A <a id="id148" class="indexterm"/>suite in this style is declared before and at the <span class="emphasis"><em>same level</em></span> as a test instead of <span class="emphasis"><em>containing</em></span> tests like the other interfaces just discussed.</li></ul></div></div><div class="section" title="Chai assertion styles"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Chai assertion styles</h2></div></div></div><p>Chai provides two<a id="id149" class="indexterm"/> assertion styles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id150" class="indexterm"/> <span class="strong"><strong>BDD</strong></span> style: This<a id="id151" class="indexterm"/> style enables dot-notation chains of<a id="id152" class="indexterm"/> assertions such as <code class="literal">expect("foo").to.be.a("string").and.equal("foo")</code> using either the <code class="literal">expect</code> function or the <code class="literal">should</code> object prototype extension</li><li class="listitem" style="list-style-type: disc">The <a id="id153" class="indexterm"/><span class="strong"><strong>assert </strong></span>style: This style <a id="id154" class="indexterm"/>uses single function assertions attached to<a id="id155" class="indexterm"/> the <code class="literal">assert</code> object, such as:<div class="informalexample"><pre class="programlisting">assert.isString("foo");
assert.strictEqual("foo", "foo");</pre></div></li></ul></div><p>Although <code class="literal">expect</code> and <code class="literal">assert</code> are functionally equivalent, there are some important differences between the BDD constructs <code class="literal">expect</code> and <code class="literal">should</code>. Essentially, because <code class="literal">should</code> patches the object prototype, it will not work for certain types of actual values (such as <code class="literal">null</code> and <code class="literal">undefined</code>) and is incompatible with Internet Explorer 9. For these reasons, our Chai BDD examples will use <code class="literal">expect</code> over <code class="literal">should</code>.</p></div></div></div>
<div class="section" title="Trying out some different styles"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Trying out some different styles</h1></div></div></div><p>Let's look at examples of the two most common interfaces for Mocha and Chai—BDD and TDD.</p><div class="section" title="Mocha and Chai BDD interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Mocha and Chai BDD interfaces</h2></div></div></div><p>The Mocha <a id="id156" class="indexterm"/>BDD interface<a id="id157" class="indexterm"/> provides four main functional units:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">before()</code>: This is a <a id="id158" class="indexterm"/>setup that <a id="id159" class="indexterm"/>occurs <span class="emphasis"><em>once</em></span> before all the tests within a suite are run. Mocha<a id="id160" class="indexterm"/> also provides a <code class="literal">beforeEach()</code> function<a id="id161" class="indexterm"/> that runs before <span class="emphasis"><em>each</em></span> test in a suite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">after()</code>: This is a setup that<a id="id162" class="indexterm"/> occurs<a id="id163" class="indexterm"/> <span class="emphasis"><em>once</em></span> after all tests in a suite are run, with the <code class="literal">afterEach()</code> alternative that runs before <span class="emphasis"><em>each</em></span> test.</li><li class="listitem" style="list-style-type: disc"><code class="literal">describe()</code>: This specifies a<a id="id164" class="indexterm"/> test suite and can be nested within other <code class="literal">describe()</code> <a id="id165" class="indexterm"/>functions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it()</code>: This <a id="id166" class="indexterm"/>defines a single<a id="id167" class="indexterm"/> test function containing one or more assertions.</li></ul></div><p>Chai's BDD style <a id="id168" class="indexterm"/>uses <code class="literal">expect</code> or <code class="literal">should</code> to make dot-notation <a id="id169" class="indexterm"/>assertion chains.</p><p>We can create a basic test file <code class="literal">chapters/03/test/js/spec/bdd.spec.js</code>, which uses all of these components. We name the suite with <code class="literal">describe()</code>, add/remove a function with <code class="literal">before()</code>/<code class="literal">after()</code>, and test it with an <code class="literal">it()</code> specification declaration. We chain together two Chai assertions with an <code class="literal">and</code> helper, producing a composite assertion that reads naturally as "expect the result of <code class="literal">hello()</code> to be a string and equal to text 'hello world'":</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>describe</strong></span>("BDD example", function () {
  // Runs once before all tests start.
  <span class="strong"><strong>before</strong></span>(function () {
    this.hello = function () {
      return "Hello world!";
    };
  });

  // Runs once when all tests finish.
  <span class="strong"><strong>after</strong></span>(function () {
    this.hello = null;
  });

  <span class="strong"><strong>it</strong></span>("should return expected string result", function () {
    <span class="strong"><strong>expect(this.hello()).to</strong></span>
      <span class="strong"><strong>.be.a("string").and</strong></span>
      <span class="strong"><strong>.equal("Hello world!")</strong></span>;
  });
});</pre></div><p>Our test driver <a id="id170" class="indexterm"/>web <a id="id171" class="indexterm"/>page (<code class="literal">chapters/03/test/test-bdd.html</code> in the examples) adds the Chai <code class="literal">expect</code> function into the global namespace for convenience and configures Mocha to use the BDD style. The relevant configuration snippet is:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  <span class="strong"><strong>var expect = chai.expect</strong></span>;
  <span class="strong"><strong>mocha.setup("bdd")</strong></span>;

  window.onload = function () {
    mocha.run();
  };
&lt;/script&gt;

&lt;script src="js/spec/bdd.spec.js"&gt;&lt;/script&gt;</pre></div></div><div class="section" title="Mocha TDD and Chai assert styles"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Mocha TDD and Chai assert styles</h2></div></div></div><p>The Mocha <a id="id172" class="indexterm"/>TDD interface<a id="id173" class="indexterm"/> uses different names for the same basic units:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">suiteSetup()</code> <a id="id174" class="indexterm"/>and <code class="literal">setup()</code>: These<a id="id175" class="indexterm"/> are <a id="id176" class="indexterm"/>aliases<a id="id177" class="indexterm"/> for <code class="literal">before()</code> and <code class="literal">beforeEach()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">suiteTeardown()</code> <a id="id178" class="indexterm"/>and <code class="literal">teardown()</code>: These<a id="id179" class="indexterm"/> are <a id="id180" class="indexterm"/>aliases for<a id="id181" class="indexterm"/> <code class="literal">after()</code> and <code class="literal">afterEach()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">suite()</code>: This specifies a<a id="id182" class="indexterm"/> test<a id="id183" class="indexterm"/> suite (<code class="literal">describe()</code> in BDD)</li><li class="listitem" style="list-style-type: disc"><code class="literal">test()</code>: This defines a <a id="id184" class="indexterm"/>single<a id="id185" class="indexterm"/> test function (<code class="literal">test()</code> in BDD)</li></ul></div><p>The Chai assert style<a id="id186" class="indexterm"/> is usually associated with TDD-style tests and provides an assert object with single function assertions.</p><p>Our TDD test file <code class="literal">chapters/03/test/js/test/tdd.js</code> provides the same test setup and assertion series as the BDD version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>suite</strong></span>("TDD example", function () {
  // Runs once before all tests start.
  <span class="strong"><strong>suiteSetup</strong></span>(function () {
    this.hello = function () {
      return "Hello world!";
    };
  });

  // Runs once when all tests finish.
  <span class="strong"><strong>suiteTeardown</strong></span>(function () {
    this.hello = null;
  });

  <span class="strong"><strong>test</strong></span>("expected string result", function () {
    <span class="strong"><strong>assert</strong></span>.<span class="strong"><strong>isString</strong></span>(this.hello());
    <span class="strong"><strong>assert</strong></span>.<span class="strong"><strong>strictEqual</strong></span>(this.hello(), "Hello world!");
  });
});</pre></div><p>The driver<a id="id187" class="indexterm"/> web page only differs in two configuration lines:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  <span class="strong"><strong>var assert = chai.assert</strong></span>;
  <span class="strong"><strong>mocha.setup("tdd")</strong></span>;

  window.onload = function () {
    mocha.run();
  };
&lt;/script&gt;

&lt;script src="js/test/tdd.js"&gt;&lt;/script&gt;</pre></div><p>Opening up <code class="literal">chapters/03/test/test-tdd.html</code> in a browser should show exactly the same test results as the previous BDD example.</p></div><div class="section" title="Deciding on the project style"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Deciding on the project style</h2></div></div></div><p>The style options in Mocha<a id="id188" class="indexterm"/> and Chai offer developers a lot of flexibility in choosing test paradigms while still leveraging the same underlying test infrastructure. In this book we prefer the BDD style for both Mocha and Chai for a few reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Chai <code class="literal">expect</code> assertion<a id="id189" class="indexterm"/> chains read in a natural language format that often obviates the need for separate test comments</li><li class="listitem" style="list-style-type: disc">The Mocha BDD interface components facilitate narrative descriptions of behaviors such as "this describes a number calculator" and "it should sum two numbers"</li><li class="listitem" style="list-style-type: disc">The BDD interface is quite popular in the modern JavaScript testing ecosystem and encourages developers to describe the <span class="emphasis"><em>behavior</em></span> of the code under test rather than to just identify the internal details</li></ul></div><p>Nonetheless, if you prefer any of the other styles, please use whatever feels most natural. All of the test code examples in this book can be translated between the various Mocha and Chai interfaces.</p></div></div>
<div class="section" title="A tour of the Chai assertion library"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>A tour of the Chai assertion library</h1></div></div></div><p>The Chai test library provides a<a id="id190" class="indexterm"/> robust set of assertions and<a id="id191" class="indexterm"/> helpers to aid the legibility and organization of tests.</p><p>Chai's own unit tests for <code class="literal">expect</code> (at <a class="ulink" href="https://github.com/chaijs/chai/blob/master/test/expect.js">https://github.com/chaijs/chai/blob/master/test/expect.js</a>) provide a great starting point from which the API can be explored. Chai conveniently uses Mocha for its test framework (configured with the TDD interface). So the entire test suite should feel very familiar.</p><p>In this section, we will use a series of assertions to introduce most of the Chai BDD APIs. The assertion examples are accumulated into a single driver file for this chapter—<code class="literal">chapters/03/test/test-chai.html</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Chai provides aliases for many of the assertions that we will discuss in this section. For example, the deep equality assertion <code class="literal">eql</code> is also available as <code class="literal">eqls</code> and <code class="literal">deep.equal</code>. See the Chai API documentation for a full listing of aliases.</p></div></div><div class="section" title="Chaining objects and assertions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Chaining objects and assertions</h2></div></div></div><p>Chai's BDD interface <a id="id192" class="indexterm"/>exposes objects that can be chained together to make test <a id="id193" class="indexterm"/>assertions more comprehensible. We will walk through some basic examples available in the file <code class="literal">chapters/03/test/js/spec/chai-chains.spec.js</code>.</p><p>As an introductory<a id="id194" class="indexterm"/> example, the assertion <code class="literal">expect("foo").to.be.a("string")</code> uses the chain objects <code class="literal">to</code> and <code class="literal">be</code>, which simply proxy through <a id="id195" class="indexterm"/>the eventual assertion. In this manner, Chai allows us to add any of the chain objects <code class="literal">to</code>, <code class="literal">be</code>, <code class="literal">been</code>, <code class="literal">is</code>, <code class="literal">that</code>, <code class="literal">and</code>, <code class="literal">have</code>, <code class="literal">with</code>, <code class="literal">at</code>, and <code class="literal">of</code> to form more naturally readable assertion statements. The statements <code class="literal">a</code> and <code class="literal">an</code> are available as both assertion chains and comparison functions.</p><p>We can use these statements to create language chain assertions such as:</p><div class="informalexample"><pre class="programlisting">expect("foo").a("string");
expect("foo").<span class="strong"><strong>to.be</strong></span>.a("string");
expect("foo").<span class="strong"><strong>to.have.been</strong></span>.a("string");
expect("foo").<span class="strong"><strong>that.is</strong></span>.a("string");

// Chains can be repeated (or be nonsensical).
expect("foo").<span class="strong"><strong>to.to.to.to</strong></span>.a("string");
expect("foo").<span class="strong"><strong>and.with.at.of</strong></span>.a("string");</pre></div><p>As all of the statements are equivalent, the highlighted language chains in the previous code demonstrate the many different ways of stating the same assertion.</p><p>Chai also provides language chain objects<a id="id196" class="indexterm"/> that <span class="emphasis"><em>do</em></span> modify the<a id="id197" class="indexterm"/> ultimate assertion:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">not</code>: This <a id="id198" class="indexterm"/>negates any following assertions. For example:<div class="informalexample"><pre class="programlisting">expect("foo").to.not.equal("bar");

// Let's get literary.
expect("Hamlet").to.be.not.to.be.an("object");</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">deep</code>: This <a id="id199" class="indexterm"/>sets the deep flag for equality checks. A raw equality check performs an identity test, which asserts that the two variables are the <span class="emphasis"><em>same</em></span> object in the process memory. With the deep flag, Chai instead asserts that the two variables have the same property values, even if they are <span class="emphasis"><em>different</em></span> underlying objects. For example, <code class="literal">expect({foo: "bar"}).to.equal({foo: "bar"})</code> fails an object identity test while <code class="literal">expect({foo: "bar"}).to.deep.equal({foo: "bar"})</code> succeeds.</li></ul></div><p>Finally, most other Chai BDD assertion statements are chainable. The following example groups several assertion chains together with the <code class="literal">and</code> helper:</p><div class="informalexample"><pre class="programlisting">expect("foo")
  .to.be.a("string").<span class="strong"><strong>and</strong></span>
  .to.equal("foo").<span class="strong"><strong>and</strong></span>
  .to.have.length(3).<span class="strong"><strong>and</strong></span>
  .to.match(/f[o]{2}/);</pre></div><p>With these basic language chains and helpers, we have a foundation for writing readable assertion statements.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>It is a good practice to chain assertions together when it makes sense for the purpose of developer comprehension and writing concise and terse test code. At the same time, separate <code class="literal">expect()</code> statements can often be more appropriate.</p></div></div></div><div class="section" title="Basic value assertions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Basic value assertions</h2></div></div></div><p>Chai provides various <a id="id200" class="indexterm"/>assertion properties<a id="id201" class="indexterm"/> to check input values (see <code class="literal">chapters/03/test/js/spec/chai-values.spec.js</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ok</code>: Value is truthy (for a quick introduction to JavaScript's permissive notion of conditional truth and equality, see <a class="ulink" href="http://www.sitepoint.com/javascript-truthy-falsy/">http://www.sitepoint.com/javascript-truthy-falsy/</a>)<div class="informalexample"><pre class="programlisting">expect("foo").to.be.ok;
expect(true).to.be.ok;
expect(false).to.not.be.ok;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">exist</code>: Value is neither <code class="literal">null</code> nor <code class="literal">undefined</code><div class="informalexample"><pre class="programlisting">expect(false).to.exist;
expect(null).to.not.exist;
expect(undefined).to.not.exist;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">true</code>: Value is exactly <code class="literal">true</code><div class="informalexample"><pre class="programlisting">expect("foo").to.not.be.true;
expect(true).to.be.true;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">false</code>: Value is exactly <code class="literal">false</code><div class="informalexample"><pre class="programlisting">expect("").to.not.be.false;
expect(false).to.be.false;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">null</code>: Value is exactly <code class="literal">null</code>.<div class="informalexample"><pre class="programlisting">expect(null).to.be.null;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">undefined</code>: Value is exactly <code class="literal">undefined</code><div class="informalexample"><pre class="programlisting">expect(undefined).to.be.undefined;
expect(null).to.not.be.undefined;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">arguments</code>: Value is the special JavaScript <code class="literal">arguments</code> object, which contains a list of <a id="id202" class="indexterm"/>parameters for the current <a id="id203" class="indexterm"/>function<div class="informalexample"><pre class="programlisting">expect(arguments).to.be.arguments;
expect([]).to.not.be.arguments;</pre></div></li></ul></div></div><div class="section" title="Comparing values"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Comparing values</h2></div></div></div><p>Chai has a diverse array of comparison functions<a id="id204" class="indexterm"/> to assess input values (see <code class="literal">chapters/03/test/js/spec/chai-comparisons.spec.js</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">equal</code>: Strict<a id="id205" class="indexterm"/> (<code class="literal">===</code>) equality<div class="informalexample"><pre class="programlisting">expect("foo").to.equal("foo");
expect({foo: "bar"}).to.not.equal({foo: "bar"});</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">eql</code>: Deep <a id="id206" class="indexterm"/>equality—equivalent to <code class="literal">deep.equal</code><div class="informalexample"><pre class="programlisting">expect("foo").to.eql("foo");
expect({foo: "bar"}).to.eql({foo: "bar"});</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">above</code>: The<a id="id207" class="indexterm"/> actual value is greater than the expected value<div class="informalexample"><pre class="programlisting">expect(1).to.not.be.above(1);
expect(5).to.be.above(2);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">least</code>: The actual<a id="id208" class="indexterm"/> value is greater than or equal to the expected value<div class="informalexample"><pre class="programlisting">expect(1).to.be.at.least(1);
expect(5).to.be.at.least(2);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">below</code>: The actual <a id="id209" class="indexterm"/>value is less than the expected value<div class="informalexample"><pre class="programlisting">expect(1).to.not.be.below(1);
expect(1).to.be.below(2);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">most</code>: The actual<a id="id210" class="indexterm"/> value is less than or equal to the expected value<div class="informalexample"><pre class="programlisting">expect(1).to.be.at.most(1);
expect(1).to.be.at.most(2);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">within</code>: The actual value is within<a id="id211" class="indexterm"/> the range of the expected values<div class="informalexample"><pre class="programlisting">expect(1).to.be.within(0, 2);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">closeTo</code>: The actual value is within<a id="id212" class="indexterm"/> the delta of the expected value<div class="informalexample"><pre class="programlisting">expect(1.2).to.be.closeTo(1, 0.2);
expect(1.2).to.not.be.closeTo(1, 0.0);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">match</code>: The actual string value is<a id="id213" class="indexterm"/> matched by the expected regular expression<div class="informalexample"><pre class="programlisting">expect("foo").to.match(/^f[o]+/);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">string</code>: The <a id="id214" class="indexterm"/>actual string value contains the expected substring<div class="informalexample"><pre class="programlisting">expect("foo bar").to.have.string("foo");</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">satisfy</code>: The <a id="id215" class="indexterm"/>evaluator function takes the actual value as a parameter and returns <code class="literal">true</code> if the assertion should pass<div class="informalexample"><pre class="programlisting">expect(42).to.satisfy(function (value) {
  return value === 6 * 7;
});</pre></div></li></ul></div></div><div class="section" title="Object and array validation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Object and array validation</h2></div></div></div><p>Chai provides some useful <a id="id216" class="indexterm"/>assertions<a id="id217" class="indexterm"/> tailored to objects and <a id="id218" class="indexterm"/>arrays (see <code class="literal">chapters/03/test/js/spec/chai-objects.spec.js</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">a</code>: When called as a function, this checks the object type building on JavaScript's native <code class="literal">typeof</code> test, with additional support for correctly inferring objects and arrays. Note that when <code class="literal">a</code> (or <code class="literal">an</code>) is used as an object property, it acts as a language chain instead.<div class="informalexample"><pre class="programlisting">expect("foo").is.a("string");
expect("foo").is.not.a("number");
expect({foo: "bar"}).is.an("object");</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">instanceof</code>: Checks whether the object is an instance of an expected constructor.<div class="informalexample"><pre class="programlisting">var Foo = function () {},
  Bar = function () {};

expect(new Foo()).is.an.instanceof(Foo);
expect(new Bar()).is.not.an.instanceof(Foo);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">property</code>: Checks if an expected property exists in an object and, optionally, if the property's value matches an expected value. When used in conjunction with the <code class="literal">deep</code> language chain, an object structure can be navigated via the dot or array notation.<div class="informalexample"><pre class="programlisting">expect({foo: "bar"}).to.have.property("foo", "bar");

// Deep checking - object, and array.
expect({foo: {bar: "baz"}})
  .to.have.deep.property("foo.bar", "baz");
expect({foo: ["bar", "baz"]})
  .to.have.deep.property("foo[1]", "baz");</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ownProperty</code>: Checks for the presence of a direct property on an object using the JavaScript <code class="literal">hasOwnProperty</code> test, without looking up the object's prototype chain for an inherited property.<div class="informalexample"><pre class="programlisting">expect({foo: "bar"}).to.have.ownProperty("foo");</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">length</code>: Checks the <code class="literal">length</code> property of an array or object (such as a string).<div class="informalexample"><pre class="programlisting">expect(["bar", "baz"]).to.have.length(2);
expect("foo").to.have.length(3);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">contain</code>: Checks<a id="id219" class="indexterm"/> for the presence of an object in an array or a <a id="id220" class="indexterm"/>substring within a string. Note<a id="id221" class="indexterm"/> that <code class="literal">contain</code> (and <code class="literal">include</code>) can alternatively be used as a language chain with <code class="literal">keys</code>.<div class="informalexample"><pre class="programlisting">expect(["bar", "baz"]).to.contain("bar");
expect("foo").to.contain("f");</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">keys</code>: Checks that an object includes all of the expected property names. The assertion verifies only a subset of expected property names when combined with the <code class="literal">include</code> or <code class="literal">contain</code> language chains.<div class="informalexample"><pre class="programlisting">// Exact matching of all keys.
expect({foo: 1, bar: 2}).to.have.keys(["foo", "bar"]);

// Exclusion of any keys.
expect({foo: 1, bar: 2}).to.not.have.keys(["baz"]);

// Inclusion of some keys.
expect({foo: 1, bar: 2}).to.include.keys(["foo"]);
expect({foo: 1, bar: 2}).to.contain.keys(["bar"]);</pre></div></li></ul></div></div><div class="section" title="Errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Errors</h2></div></div></div><p>Chai can also check<a id="id222" class="indexterm"/> abnormal code functionality, notably trapping and verifying program exceptions.</p><p>The <code class="literal">throw</code> assertion<a id="id223" class="indexterm"/> takes a function as an input that is expected to throw an exception when called. The resulting error is then matched against a constructor class (for example, <code class="literal">Error</code>) or a message string/regular expression (for example, <code class="literal">/message/</code>). Note<a id="id224" class="indexterm"/> that a function reference (for example, <code class="literal">bad</code>) is passed to the assertion rather than a called function (for example, <code class="literal">bad()</code>). This enables Chai to call the function internally, trap any exceptions, and verify the results:</p><div class="informalexample"><pre class="programlisting">var bad = function () {
  throw new Error("My error message");
};

expect(bad)
  .to.throw(Error).and
  .to.throw(/message/).and
  .not.to.throw("no message match");</pre></div></div></div>
<div class="section" title="Getting the application and tests ready to run"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Getting the application and tests ready to run</h1></div></div></div><p>Now that we have the Chai assertion library API under our belts, it is time to write and <a id="id225" class="indexterm"/>organize the tests. While we have incidentally covered much of this material already, the concise core of a Mocha test infrastructure includes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test runner</strong></span>: Configures the overall test run and report</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test suites</strong></span>: One or more organization units grouping many specifications/tests</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Setup</strong></span>/<span class="strong"><strong>Teardown</strong></span>: Setting up a state for each test or suite run</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Specifications</strong></span>: Writing the test functions</li></ul></div><p>Starting at the highest level, we look at our test driver web page. As previously discussed, this is where our core application libraries, test libraries, and test specifications are set up and included. All of the Backbone.js application tests in the rest of this chapter are incorporated into the <code class="literal">chapters/03/test/test.html</code> driver page.</p><div class="section" title="The Mocha test runner"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>The Mocha test runner</h2></div></div></div><p>The <a id="id226" class="indexterm"/>Mocha <code class="literal">setup()</code> function<a id="id227" class="indexterm"/> controls the overall parameters and environment for all test suite and specification executions. The function should be called once before execution starts (for example, <code class="literal">mocha.run()</code>) in the test driver web page:</p><div class="informalexample"><pre class="programlisting">mocha.setup("bdd");

window.onload = function () {
  mocha.run();
};</pre></div><p>The default settings are quite usable for Backbone.js testing and we use the previous code for nearly all of the tests in this book. However, there are many more options available, which are <a id="id228" class="indexterm"/>described at <a class="ulink" href="http://visionmedia.github.io/mocha/">http://visionmedia.github.io/mocha/</a>. Here is an arbitrary sampling:</p><div class="informalexample"><pre class="programlisting">mocha.setup({
  ui: "bdd",          // BDD UI.
  reporter: "html",   // HTML reporter.
  timeout: 4000,      // 4s test timeout.
  slow: 1000          // A "slow" test is &gt; 1s
});</pre></div></div><div class="section" title="Reconfiguring the application for testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Reconfiguring the application for testing</h2></div></div></div><p>Backbone.js applications <a id="id229" class="indexterm"/>often need specific test-friendly <a id="id230" class="indexterm"/>configurations in order to make the test environment predictable and to avoid stomping on real data. Backend information (for example, host addresses and ports) is often different in the development and testing phases. Thus, it is a good practice to abstract all of this information into a common file so that we can easily switch values from one central location to another.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>An alternative and complementary approach for creating a workable test environment is to fake out configuration details and dependencies with a library such as Sinon.JS. The two Sinon.JS abstractions that can help us here are stubs and mocks, both of which can replace object method behaviors during tests. (We will introduce and discuss these concepts in detail in <a class="link" href="ch05.html" title="Chapter 5. Test Stubs and Mocks">Chapter 5</a>, <span class="emphasis"><em>Test Stubs and Mocks</em></span>.)</p><p>In the following datastore configuration examples, we could use a Sinon.JS stub to replace the entire datastore with test-specific simulation code. The stub would allow us to use normal application configurations while ensuring that we do not modify the real datastore. As an added benefit to this approach, stubbing and mocking external dependencies can often make tests run faster, particularly if the fake replaces a relatively slow application behavior (for example, network communication).</p></div></div><p>In the Notes application, we require a unique <code class="literal">localStorage</code> name for the collection, which we specify in the configuration file <code class="literal">notes/app/js/app/config.js</code>:</p><div class="informalexample"><pre class="programlisting">App.Config = _.extend(App.Config, {
  // Local Storage Name
  storeName: "notes"
});</pre></div><p>This code populates the <code class="literal">App.Config</code> namespace with <code class="literal">App.Config.storeName</code>, which we then use for the <code class="literal">App.Collections.Notes</code> collection in <code class="literal">notes/app/js/app/collections/notes.js</code>:</p><div class="informalexample"><pre class="programlisting">App.Collections.Notes = Backbone.Collection.extend({
  model: App.Models.Note,

  // Sets the localStorage key for data storage.
  localStorage: new Backbone.LocalStorage(App.Config.storeName)
});</pre></div><p>With this<a id="id231" class="indexterm"/> setup, the live application will save data to the <code class="literal">notes</code> <a id="id232" class="indexterm"/>store in <code class="literal">localStorage</code>. However, in our tests we will want to add, remove, and mutate the note data without overwriting our development-friendly datastore. So, by adding an extra configuration directive in our application's test driver page, we can set the test-only store name to <code class="literal">notes-test</code> using the Underscore.js <code class="literal">extend()</code> function:</p><div class="informalexample"><pre class="programlisting">&lt;script src="../app/js/app/namespace.js"&gt;&lt;/script&gt;
&lt;script src="../app/js/app/config.js"&gt;&lt;/script&gt;
&lt;script&gt;
  // Test overrides (before any app components).
  App.Config = _.extend(App.Config, {
    storeName: "notes-test" // localStorage for tests.
  });
&lt;/script&gt;
&lt;script src="../app/js/app/models/note.js"&gt;&lt;/script&gt;
&lt;script src="../app/js/app/collections/notes.js"&gt;&lt;/script&gt;</pre></div><p>By including <code class="literal">config.js</code> first and then overriding the specific values, we make the <span class="emphasis"><em>other</em></span> unmodified configuration values available during the tests. With this scheme, we now have a completely separate Backbone.js test datastore, which we can change without affecting our development environment.</p></div><div class="section" title="Organizing topics and specifications into test suites"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Organizing topics and specifications into test suites</h2></div></div></div><p>Organizing test code<a id="id233" class="indexterm"/> into topics and application components is an<a id="id234" class="indexterm"/> important step in developing an<a id="id235" class="indexterm"/> overall test architecture. To this end, <a id="id236" class="indexterm"/>Mocha provides the <code class="literal">describe()</code> test suite function to group logical collections of test specifications.</p><p>For example, in <code class="literal">App.Collections.Notes</code> we might start with two subgroups of tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tests that create empty collections and verify the initial default state</li><li class="listitem" style="list-style-type: disc">Tests that modify the collection with new <code class="literal">App.Models.Note</code> objects</li></ul></div><p>Transforming<a id="id237" class="indexterm"/> this list into a<a id="id238" class="indexterm"/> set of nested Mocha <a id="id239" class="indexterm"/>test <a id="id240" class="indexterm"/>suites would give us:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>describe</strong></span>("App.Collections.Notes", function () {

  <span class="strong"><strong>describe</strong></span>("creation", function () {
    // Tests.
  });

  <span class="strong"><strong>describe</strong></span>("modification", function () {
    // Tests.
  });
});</pre></div><p>We have two levels of <code class="literal">describe()</code> statements here, although Mocha allows a much deeper nesting of suites.</p></div><div class="section" title="Starting up and winding down tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Starting up and winding down tests</h2></div></div></div><p>Although we try to<a id="id241" class="indexterm"/> isolate behavior for our test specifications as a general practice, tests<a id="id242" class="indexterm"/> often have common setup and teardown needs. For example, if a group of specs all test the same object, it may make the most sense to create the object once and share it with all of the specs.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<span class="strong"><strong>Context/member variables in Mocha</strong></span>
</p><p>Mocha allows test code to attach values to the <code class="literal">this</code> context object for use in other sections of the test run. This allows us to share variables across tests without having to declare and manage global or higher-level scoped variables. A common use of this feature is to add a variable such as <code class="literal">this.myCollection</code> in a <code class="literal">before()</code> setup statement for a group of tests and then remove it in the <code class="literal">after()</code> statement for the group.</p></div></div><p>Mocha provides the functions <code class="literal">before()</code>, <code class="literal">beforeEach()</code>, <code class="literal">after()</code>, and <code class="literal">afterEach()</code> to help us with test state management. As mentioned previously, the <code class="literal">before()</code>/<code class="literal">after()</code> functions run <span class="emphasis"><em>once</em></span> before and <span class="emphasis"><em>once</em></span> after all the tests within a suite. The <code class="literal">beforeEach()</code>/<code class="literal">afterEach()</code> functions run before and after <span class="emphasis"><em>each</em></span> test within a suite.</p><p>With these four constructs, we can create nuanced state management for our Mocha tests. The setup/teardown functions operate at the level of each test suite. This means that nested test suites can provide their own additional setup/teardown functions. For example, Mocha will faithfully run each <code class="literal">before()</code> statement as it traverses deeper into the <code class="literal">describe()</code> statements before executing the first test.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Another good reason to use the setup/teardown functions is that they <span class="emphasis"><em>always</em></span> run—even when the test specs fail or throw exceptions. This prevents a single test failure from affecting the data state of other tests in the run and causing spurious test failures.</p></div></div><p>Backbone.js<a id="id243" class="indexterm"/> collection tests often benefit from using setup and teardown helpers to create<a id="id244" class="indexterm"/> an initial data state. Usually, this means adding some starting records (called data fixtures when loaded from a separate data file) and restoring the datastore to a pristine state after the tests have modified the collection.</p><p>In the test driver page, we have already configured the <code class="literal">App.Collections.Notes</code> class to use a test-only datastore. The <code class="literal">Backbone.localStorage</code> adapter has an internal method <code class="literal">_clear()</code> that clears the underlying browser storage associated with the collection, which we will use to reset our data state in the tests. The resulting data sandbox is ready for the following test scenario:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wipe any existing collection data on suite setup, add a context variable for a single collection, and remove the collection on teardown</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">modification</code> suite, add an initial <code class="literal">App.Models.Note</code> object to the collection and wipe the collection after each test</li></ul></div><p>The implementation of the setup and teardown functions for the test suite looks like the following:</p><div class="informalexample"><pre class="programlisting">describe("App.Collections.Notes", function () {

  <span class="strong"><strong>before(function () {</strong></span>
    <span class="strong"><strong>// Create a reference for all internal suites/specs.</strong></span>
    <span class="strong"><strong>this.notes = new App.Collections.Notes();</strong></span>

    <span class="strong"><strong>// Use internal method to clear out existing data.</strong></span>
    <span class="strong"><strong>this.notes.localStorage._clear();</strong></span>
  <span class="strong"><strong>})</strong></span>;

  <span class="strong"><strong>after(function () {</strong></span>
    <span class="strong"><strong>// Remove the reference.</strong></span>
    <span class="strong"><strong>this.notes = null;</strong></span>
  <span class="strong"><strong>})</strong></span>;

  describe("creation", function () {
    // Tests.
  });

  describe("modification", function () {

    <span class="strong"><strong>beforeEach(function () {</strong></span>
      <span class="strong"><strong>// Load a pre-existing note.</strong></span>
      <span class="strong"><strong>this.notes.create({</strong></span>
        <span class="strong"><strong>title: "Test note #1",</strong></span>
        <span class="strong"><strong>text: "A pre-existing note from beforeEach."</strong></span>
      <span class="strong"><strong>})</strong></span>;
    <span class="strong"><strong>})</strong></span>;

    <span class="strong"><strong>afterEach(function () {</strong></span>
      <span class="strong"><strong>// Wipe internal data and reset collection.</strong></span>
      <span class="strong"><strong>this.notes.localStorage._clear();</strong></span>
      <span class="strong"><strong>this.notes.reset();</strong></span>
    <span class="strong"><strong>})</strong></span>;

    // Tests.

  });
});</pre></div><p>The highlighted<a id="id245" class="indexterm"/> lines<a id="id246" class="indexterm"/> in the previous code snippet illustrate the <code class="literal">before()</code>/<code class="literal">after()</code> calls for all tests in the overall test suite and the <code class="literal">beforeEach()</code>/<code class="literal">afterEach()</code> calls for only the subsuite <code class="literal">modification</code>.</p></div></div>
<div class="section" title="Writing Mocha test specifications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Writing Mocha test specifications</h1></div></div></div><p>With practically <a id="id247" class="indexterm"/>everything else in place, we finally turn to writing test specifications. Mocha BDD specifications are declared using the <code class="literal">it()</code> function with the following function signature:</p><div class="informalexample"><pre class="programlisting">it(description, callback);</pre></div><p>The description string, by convention, is a statement of the expected behavior under test, and the callback function executes the tests. For example, assuming we have an empty <code class="literal">this.notes</code> collection variable, a test of the default values in <code class="literal">App.Collections.Notes</code> can be as simple as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>it("has default values", function () {</strong></span>
  expect(this.notes).to.be.ok;
  expect(this.notes).to.have.length(0);
<span class="strong"><strong>})</strong></span>;</pre></div><div class="section" title="Asynchronous behavior in tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Asynchronous behavior in tests</h2></div></div></div><p>Although basic test <a id="id248" class="indexterm"/>specifications are quite simple, flow control complications <a id="id249" class="indexterm"/>arise when testing asynchronous application code. Given that the Backbone.js application's behavior is quite often asynchronous/event-driven, we need to have a solid and straightforward test approach.</p><p>Fortunately, Mocha provides an asynchronous test function parameter that is used to signal that the test is asynchronous. If a parameter is provided in a test callback (it is named <code class="literal">done</code> by convention), Mocha will delay the test completion until either <code class="literal">done</code> is called or the test times out.</p><p>One asynchronous behavior that we can test in a Backbone.js collection is that the <code class="literal">reset</code> event fires after a <code class="literal">fetch()</code> method<a id="id250" class="indexterm"/> call on the collection. Here we create an empty <code class="literal">App.Collections.Notes</code> object, fetch its backend data, and confirm that the event has fired. After all of this is verified, we add a call to <code class="literal">done()</code> to signal that the test has completed successfully. If the <code class="literal">reset</code> event never fires, then <code class="literal">done()</code> won't be called and the test will time out:</p><div class="informalexample"><pre class="programlisting">it("should be empty on fetch", function (done) {
  var notes = new App.Collections.Notes();

  // "reset" event fires on successful fetch().
  notes.once("reset", function () {
    expect(notes).to.have.length(0);

    // Async code has completed. Signal test is done.
    <span class="strong"><strong>done()</strong></span>;
  });

  notes.fetch({ reset: true });
});</pre></div><p>With the extra <code class="literal">done</code> parameter, we can now run a series of asynchronous assertions within a single specification before the test completes.</p></div><div class="section" title="Some Backbone.js collection tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Some Backbone.js collection tests</h2></div></div></div><p>Now that we can <a id="id251" class="indexterm"/>write asynchronous specifications, we will finish off <a id="id252" class="indexterm"/>our test suite for the Notes collection. Keeping in mind our test goals for Backbone.js collections from <a class="link" href="ch02.html" title="Chapter 2. Creating a Backbone.js Application Test Plan">Chapter 2</a>, <span class="emphasis"><em>Creating a Backbone.js Application Test Plan</em></span> (that is, modifying models, firing events, and synchronizing data), we will create the following specs for <code class="literal">App.Collections.Notes</code> (shown in an outline form here):</p><div class="informalexample"><pre class="programlisting">describe("App.Collections.Notes", function () {

  describe("creation", function () {
    it("<span class="strong"><strong>has default values</strong></span>");
    it("<span class="strong"><strong>should be empty on fetch</strong></span>");
  });

  describe("modification", function () {
    it("<span class="strong"><strong>has a single note</strong></span>");
    it("<span class="strong"><strong>can delete a note</strong></span>");
    it("<span class="strong"><strong>can create a second note</strong></span>");
  });
});</pre></div><p>Creating an empty test outline such as the previous code is a good exercise and practice during application development. For example, as part of a test-first development process, we can first write the <code class="literal">describe</code> and <code class="literal">it</code> declarations without callbacks to specify the world of program behavior for the relevant application component. Once we are satisfied that the outline <a id="id253" class="indexterm"/>approximates the expected use cases of the component, we<a id="id254" class="indexterm"/> can move on to filling out tests and writing the application code.</p><p>Helpfully, Mocha will treat spec declarations without functions (as shown in the previous code snippet) as pending tests. Pending specs are visually distinguished from the ordinary tests with different colors in a Mocha HTML test report. With pending tests, a developer can scan a test report more easily for unfinished specs and then implement the necessary test and application code.</p><p>With this in mind, let's implement the specifications to complete the test file <code class="literal">chapters/03/test/js/spec/collections/notes.spec.js</code>:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>We have omitted some of the spec functions from the following code (and elsewhere in this book) for brevity and readability. The full spec implementations for <code class="literal">App.Collections.Notes</code> and other Notes test suites are available in the companion code samples for this book.</p></div></div><div class="informalexample"><pre class="programlisting">describe("App.Collections.Notes", function () {

  before(function () {
    // Create a reference for all internal suites/specs.
    this.notes = new App.Collections.Notes();

    // Use internal method to clear out existing data.
    this.notes.localStorage._clear();
  });

  after(function () {
    // Remove the reference.
    this.notes = null;
  });

  describe("creation", function () {

    it("<span class="strong"><strong>has default values</strong></span>", function () {
      expect(this.notes).to.be.ok;
      expect(this.notes).to.have.length(0);
    });

    it("<span class="strong"><strong>should be empty on fetch</strong></span>", function (done) {
      // ... implemented in previous example ...
    });

  });

  describe("modification", function () {

    beforeEach(function () {
      // Load a pre-existing note.
      this.notes.create({
        title: "Test note #1",
        text: "A pre-existing note from beforeEach."
      });
    });

    afterEach(function () {
      // Wipe internal data and reset collection.
      this.notes.localStorage._clear();
      this.notes.reset();
    });

    it("<span class="strong"><strong>has a single note</strong></span>", function (done) {
      var notes = this.notes, note;

      // After fetch.
      notes.once("reset", function () {
        expect(notes).to.have.length(1);

        // Check model attributes.
        note = notes.at(0);
        expect(note).to.be.ok;
        expect(note.get("title")).to.contain("#1");
        expect(note.get("text")).to.contain("pre-existing");

        done();
      });

      notes.fetch({ reset: true });
    });

    it("<span class="strong"><strong>can delete a note</strong></span>", function (done) {
      var notes = this.notes, note;

      // After shift.
      notes.once("remove", function () {
        expect(notes).to.have.length(0);
        done();
      });

      // Remove and return first model.
      note = notes.shift();
      expect(note).to.be.ok;
    });

    it("<span class="strong"><strong>can create a second note</strong></span>", function (done) {
      // ... omitted ...
    });

  });
});</pre></div><p>This final test<a id="id255" class="indexterm"/> file provides a reasonable skeleton using all of the different <a id="id256" class="indexterm"/>Mocha and Chai parts we have discussed in this chapter. We can see our tests in action by opening a browser to the driver page <code class="literal">chapters/03/test/test.html</code>.</p></div></div>
<div class="section" title="Testing and supporting Backbone.js views"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Testing and supporting Backbone.js views</h1></div></div></div><p>Having now <a id="id257" class="indexterm"/>created test suites for Backbone.js models and collections, we turn to expanding our test coverage to a Backbone.js view.</p><div class="section" title="The Notes application single note view"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>The Notes application single note view</h2></div></div></div><p>The first Backbone.js view <a id="id258" class="indexterm"/>we will examine is <code class="literal">App.Views.NoteView</code>. This view is responsible for rendering <code class="literal">App.Models.Note</code> Markdown data into full HTML as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5248OS_03_01.jpg" alt="The Notes application single note view"/><div class="caption"><p>View rendered Markdown</p></div></div><p>The underlying <a id="id259" class="indexterm"/>model data for the figure includes the following attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">title</code>:<div class="informalexample"><pre class="programlisting">My Title</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">text</code>:<div class="informalexample"><pre class="programlisting">## My Heading
* List item 1
* List item 2</pre></div></li></ul></div><p>The <code class="literal">text</code> attribute data transforms to HTML as:</p><div class="informalexample"><pre class="programlisting">&lt;h2 id="myheading"&gt;My Heading&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;List item 1&lt;/li&gt;
  &lt;li&gt;List item 2&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>
<code class="literal">App.Views.NoteView</code> is responsible for performing this conversion. The <code class="literal">notes/app/js/app/views/note-view.js</code> file first provides an <code class="literal">initialize</code> function, which sets model listeners to re-render or clean up the view and then kicks off <code class="literal">render()</code>. The <code class="literal">render</code> function uses the Showdown library to convert the model <code class="literal">text</code> Markdown data into HTML and then passes the finished data to the view template:</p><div class="informalexample"><pre class="programlisting">App.Views.NoteView = Backbone.View.extend({

  template: _.template(App.Templates["template-note-view"]),

  converter: new Showdown.converter(),

  initialize: function () {
    this.listenTo(this.model, "change", this.render);
    this.listenTo(this.model, "destroy", this.remove);
    this.render();
  },

  // Convert note data into Markdown.
  render: function () {
    this.$el.html(this.template({
      title: this.model.get("title"),
      text: this.converter.makeHtml(this.model.get("text"))
    }));
    return this;
  }
});</pre></div><p>This view includes <a id="id260" class="indexterm"/>an Underscore.js template (<code class="literal">App.Templates["template-note-view"]</code> in <code class="literal">notes/app/js/app/templates/templates.js</code>), which inserts the <code class="literal">title</code> and <code class="literal">text</code> data into HTML:</p><div class="informalexample"><pre class="programlisting">App.Templates["template-note-view"] =
  "&lt;div class=\"well well-small\"&gt;" +
  "  &lt;h2 id=\"pane-title\"&gt;<span class="strong"><strong>&lt;%= title %&gt;</strong></span>&lt;/h2&gt;" +
  "&lt;/div&gt;" +
  "&lt;div id=\"pane-text\"&gt;<span class="strong"><strong>&lt;%= text %&gt;</strong></span>&lt;/div&gt;";</pre></div><p>Rendering the model data into an HTML form with <code class="literal">App.Views.NoteView.render()</code> gives us the following resulting HTML:</p><div class="informalexample"><pre class="programlisting">&lt;div class="well well-small"&gt;
  &lt;h2 id="pane-title"&gt;<span class="strong"><strong>My Title</strong></span>&lt;/h2&gt;
&lt;/div&gt;
&lt;div id="pane-text"&gt;
  <span class="strong"><strong>&lt;h2 id="myheading"&gt;My Heading&lt;/h2&gt;</strong></span>
  <span class="strong"><strong>&lt;ul&gt;</strong></span>
    <span class="strong"><strong>&lt;li&gt;List item 1&lt;/li&gt;</strong></span>
    <span class="strong"><strong>&lt;li&gt;List item 2&lt;/li&gt;</strong></span>
  <span class="strong"><strong>&lt;/ul&gt;</strong></span>
&lt;/div&gt;</pre></div><p>Now that we have<a id="id261" class="indexterm"/> introduced a simple view to work with, we will examine how to test its behavior.</p></div><div class="section" title="Creating HTML fixtures for view tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Creating HTML fixtures for view tests</h2></div></div></div><p>The Backbone.js <a id="id262" class="indexterm"/>application tests that we have written up to this<a id="id263" class="indexterm"/> point don't interface with the DOM or HTML of a web page. This simplifies our test environment because the application's web page (for example, <code class="literal">index.html</code>) is very different from our test driver page (for example, <code class="literal">test.html</code>). However, Backbone.js views nearly always involve a healthy amount of DOM interaction.</p><p>To this end, we need an HTML test fixture—one or more DOM elements in the test driver page that we can interact with and modify during tests. At the same time, we don't want the fixture HTML causing havoc in the test code of the driver page. Accordingly, we create a single, hidden <code class="literal">div</code> element in the <code class="literal">chapters/03/test/test.html</code> driver page for our application view tests:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
  &lt;div id="mocha"&gt;&lt;/div&gt;

  <span class="strong"><strong>&lt;!-- Test Fixtures. --&gt;</strong></span>
  <span class="strong"><strong>&lt;div id="fixtures"style="display: none; visibility: hidden;"&gt;&lt;/div&gt;</strong></span>
</pre></div><p>Now, our tests can reference <code class="literal">$("#fixtures")</code> in jQuery and get access to the fixture container. The tests can then add elements as needed to exercise any desired view/DOM interaction.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>
<span class="strong"><strong>Advanced HTML fixtures</strong></span>
</p><p>We have scratched <a id="id264" class="indexterm"/>only the surface of HTML fixtures in this chapter. More sophisticated fixture schemes and libraries exist, with features such as sandboxing application HTML code within an iframe to avoid test code cross-pollination and loading HTML fixture code from external application files. Two promising management libraries that are compatible with Mocha are jsFixtures (<a class="ulink" href="https://github.com/kevindente/jsFixtures">https://github.com/kevindente/jsFixtures</a>) and js-fixtures (<a class="ulink" href="https://github.com/badunk/js-fixtures">https://github.com/badunk/js-fixtures</a>).</p></div></div></div><div class="section" title="Walking through the view test suite"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Walking through the view test suite</h2></div></div></div><p>Let's make our way through<a id="id265" class="indexterm"/> the code in <code class="literal">chapters/03/test/js/spec/views/note-view.spec.js</code>, which is the test suite for <code class="literal">App.Views.NoteView</code>. Recalling the Backbone.js view testing goals in <a class="link" href="ch02.html" title="Chapter 2. Creating a Backbone.js Application Test Plan">Chapter 2</a>, <span class="emphasis"><em>Creating a Backbone.js Application Test Plan</em></span>, we will check if the view renders appropriate HTML using a model and template, binds HTML results to the expected DOM location, and interacts correctly with the application events.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>
<span class="strong"><strong>Writing tests on your own for the examples</strong></span>
</p><p>To make the narrative in this book flow better, we will follow a general scheme of presenting a Backbone.js application component and then walking through tests that illustrate a particular lesson, technique, or tool. Unfortunately, this is the reverse of the recommended Test-Driven Development process, which writes tests describing application behavior first, then writes the implementation, and iterates until the overall behavior is correct.</p><p>For your work with this book, we strongly encourage you to take a moment, before the book presents test examples to design and implement your own tests for the sample application components. After writing your own tests, you can move on to the book's examples to check your work and identify additional testing ideas and techniques.</p></div></div><p>The suite begins with a <code class="literal">describe</code> declaration and a setup/teardown code. At the commencement of the suite execution, a view fixture (<code class="literal">$("&lt;div id='note-view-fixture'&gt;&lt;/div&gt;")</code>) is created and stored in <code class="literal">this.$fixture</code>. Our setup for each test (<code class="literal">beforeEach()</code>/<code class="literal">afterEach()</code>) binds the new <code class="literal">this.$fixture</code> fixture to the HTML fixture holder <code class="literal">$("#fixtures")</code> and creates an <code class="literal">App.Views.NoteView</code> object with an <code class="literal">App.Models.Note</code> model. After all tests in the suite are done, the fixtures holder <code class="literal">$("#fixtures")</code> is emptied:</p><div class="informalexample"><pre class="programlisting">describe("App.Views.NoteView", function () {

  before(function () {
    // Create test fixture.
    this.$fixture = $("&lt;div id='note-view-fixture'&gt;&lt;/div&gt;");
  });

  beforeEach(function () {
    // Empty out and rebind the fixture for each run.
    this.$fixture.empty().appendTo($("#fixtures"));

    // New default model and view for each test.
    //
    // Creation calls `render()`, so in tests we have an
    // *already rendered* view.
    this.view = new App.Views.NoteView({
      el: this.$fixture,
      model: new App.Models.Note()
    });
  });

  afterEach(function () {
    // Destroying the model also destroys the view.
    this.view.model.destroy();
  });

  after(function () {
    // Remove all subfixtures after test suite finishes.
    $("#fixtures").empty();
  });</pre></div><p>With these <a id="id266" class="indexterm"/>variables and DOM elements available, we can test whether a default model renders the expected HTML, using jQuery. Note that because its <code class="literal">initialize</code> function calls <code class="literal">render</code>, instantiating an <code class="literal">App.Views.NoteView</code> object adds the rendered HTML to our DOM fixture:</p><div class="informalexample"><pre class="programlisting">  it("can render an empty note", function () {
    var $title = $("#pane-title"),
      $text = $("#pane-text");

    // Default to empty title in `h2` tag.
    expect($title.text()).to.equal("");
    expect($title.prop("tagName").toLowerCase()).to.equal("h2");

    // Have simple default message.
    expect($text.text()).to.equal("Edit your note!");
    expect($text.html()).to.contain("&lt;p&gt;&lt;em&gt;Edit your note!&lt;/em&gt;&lt;/p&gt;");
  });</pre></div><p>The second spec changes the model attributes <code class="literal">title</code> and <code class="literal">text</code> to render more complex HTML.</p><p>The tricky part is waiting until <span class="emphasis"><em>after</em></span> the model listeners call <code class="literal">render()</code> and update the DOM to inspect the new HTML values. Our technique here is to observe that <code class="literal">render()</code> already listens to the model event <code class="literal">change</code> and add an additional one-time <code class="literal">once()</code> listener on this event to check the HTML.</p><p>However, note that this is a brittle way to handle the asynchronous nature of the test behavior. The rendering code could take more time to finish than our assertions, thereby breaking the test. A better solution is to wait on the <code class="literal">render()</code> function call to finish and then run the test <a id="id267" class="indexterm"/>code—a technique that we can more readily perform with Sinon.JS spies, stubs, and mocks, which are discussed in detail in the subsequent chapters:</p><div class="informalexample"><pre class="programlisting">  it("can render more complicated markdown", function (done) {
    this.view.model.once("change", function () {
      var $title = $("#pane-title"),
        $text = $("#pane-text");

      // Our new (changed) title.
      expect($title.text()).to.equal("My Title");

      // Rendered Markdown with headings, list.
      expect($text.html())
        .to.contain("My Heading&lt;/h2&gt;").and
        .to.contain("&lt;ul&gt;").and
        .to.contain("&lt;li&gt;List item 2&lt;/li&gt;");

      done();
    });

    // Make our note a little more complex.
    this.view.model.set({
      title: "My Title",
      text: "## My Heading\n" +
            "* List item 1\n" +
            "* List item 2"
    });
  });
});</pre></div></div></div>
<div class="section" title="Aggregating and running the application tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Aggregating and running the application tests</h1></div></div></div><p>Finishing up the<a id="id268" class="indexterm"/> test driver page for both the collection and view tests, we<a id="id269" class="indexterm"/> integrate the necessary script includes and HTML test fixtures in <code class="literal">chapters/03/test/test.html</code> (shown in the relevant part in the following code snippet):</p><div class="informalexample"><pre class="programlisting">&lt;head&gt;
  &lt;!-- ... snipped ... --&gt;

  &lt;!-- Test libraries. --&gt;
  &lt;script src="js/lib/mocha.js"&gt;&lt;/script&gt;
  &lt;script src="js/lib/chai.js"&gt;&lt;/script&gt;
  &lt;script src="js/lib/sinon.js"&gt;&lt;/script&gt;

  &lt;!-- JavaScript Core Libraries --&gt;
  &lt;script src="../app/js/lib/underscore.js"&gt;&lt;/script&gt;
  &lt;!-- ... snipped ... --&gt;

  &lt;!-- JavaScript Application Libraries --&gt;
  &lt;script src="../app/js/app/namespace.js"&gt;&lt;/script&gt;
  &lt;script src="../app/js/app/config.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // Test overrides (before any app components).
    App.Config = _.extend(App.Config, {
      storeName: "notes-test" // localStorage for tests.
    });
  &lt;/script&gt;
  &lt;script src="../app/js/app/models/note.js"&gt;&lt;/script&gt;
  &lt;script src="../app/js/app/collections/notes.js"&gt;&lt;/script&gt;
  &lt;script src="../app/js/app/templates/templates.js"&gt;&lt;/script&gt;
  &lt;script src="../app/js/app/views/note-view.js"&gt;&lt;/script&gt;

  &lt;!-- Test Setup --&gt;
  &lt;script&gt;
    var expect = chai.expect;
    mocha.setup("bdd");

    window.onload = function () {
      mocha.run();
    };
  &lt;/script&gt;

  &lt;!-- Tests. --&gt;
  &lt;script src="js/spec/collections/notes.spec.js"&gt;&lt;/script&gt;
  &lt;script src="js/spec/views/note-view.spec.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="mocha"&gt;&lt;/div&gt;

  &lt;!-- Test Fixtures. --&gt;
  &lt;div id="fixtures"
       style="display: none; visibility: hidden;"&gt;&lt;/div&gt;
&lt;/body&gt;</pre></div><p>Opening a web browser to <code class="literal">chapters/03/test/test.html</code>, we can see the full test report for the <a id="id270" class="indexterm"/>collection <a id="id271" class="indexterm"/>and view:</p><div class="mediaobject"><img src="graphics/5248OS_03_02.jpg" alt="Aggregating and running the application tests"/><div class="caption"><p>Test report</p></div></div></div>
<div class="section" title="Test development tips, tricks, and hints"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Test development tips, tricks, and hints</h1></div></div></div><p>While we continue to <a id="id272" class="indexterm"/>explore the theory and practice of testing Backbone.js<a id="id273" class="indexterm"/> applications, it remains true that creating test architectures<a id="id274" class="indexterm"/> and writing good test specifications are more of an art than an exact science. Many lessons can only be learned through experience, particularly as your applications encounter bugs and development mishaps. In the meantime, we can start you off with some techniques and suggestions.</p><div class="section" title="Isolating and excluding tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Isolating and excluding tests</h2></div></div></div><p>Application development is a journey guaranteed to include inexplicable errors, sudden application crashes, and complex test failures. When these pitfalls happen, it is important to have some directions on how to debug the problems and move things forward.</p><p>A common scenario during software development is when application changes break one or more existing unit tests. In this case, a good practice is to run the test suite one test at a time, fix the test, and then move on to the rest. Mocha provides two avenues to help in this regard:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Grep</strong></span>: As we have discussed in <a class="link" href="ch01.html" title="Chapter 1. Setting Up a Test Infrastructure">Chapter 1</a>, <span class="emphasis"><em>Setting Up a Test Infrastructure</em></span>, you can click on a single test in the test reporter HTML page or directly navigate to a test page URL with a grep query parameter appended, such as <code class="literal">test.html?grep=PATTERN</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Only</strong></span>: Another alternative is to temporarily modify your Mocha test specifications to run only a single test using the <code class="literal">only</code> helper, skipping all other tests and suites. Let's look at an example:<div class="informalexample"><pre class="programlisting">it("doesn't run this test", function () {
  expect(true).to.be.true;
});

it.<span class="strong"><strong>only</strong></span>("runs this test", function () {
  expect(false).to.be.false;
});</pre></div></li></ul></div><p>On the other <a id="id275" class="indexterm"/>side of<a id="id276" class="indexterm"/> this scenario, sometimes we want <a id="id277" class="indexterm"/>to ignore a few failing tests while still using the rest of the test infrastructure. In this case, we look towards <code class="literal">skip</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Skip</strong></span>: The <code class="literal">skip</code> modifier omits a single specification from the test run and can be applied to multiple specifications. Skipped tests are also considered pending and can be visually distinguished in a Mocha HTML test report:<div class="informalexample"><pre class="programlisting">it.<span class="strong"><strong>skip</strong></span>("doesn't run this test", function () {
  expect(true).to.be.true;
});

it("runs this test", function () {
  expect(false).to.be.false;
});</pre></div></li></ul></div></div><div class="section" title="Writing testable application code"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Writing testable application code</h2></div></div></div><p>Beyond the <a id="id278" class="indexterm"/>practical aspects of writing tests, an equally important component of developing a test infrastructure is writing testable application code. The topic of testable JavaScript code is quite large—we will only introduce the issue here and start you off with a general goal of developing application code that works in harmony with the tests that support it.</p><p>A comprehensive treatment of the subject is available in the book <span class="emphasis"><em>Testable JavaScript</em></span> by <span class="emphasis"><em>Mark Ethan Trostler</em></span> (<a class="ulink" href="http://shop.oreilly.com/product/0636920024699.do">http://shop.oreilly.com/product/0636920024699.do</a>), which covers topics such as application code complexity, event-based architectures, and debugging. Also consider general JavaScript application guides such as <span class="emphasis"><em>Maintainable JavaScript</em></span> by <span class="emphasis"><em>Nicholas Zakas</em></span> (<a class="ulink" href="http://shop.oreilly.com/product/0636920025245.do">http://shop.oreilly.com/product/0636920025245.do</a>) and the seminal <span class="emphasis"><em>JavaScript: The Good Parts</em></span> by <span class="emphasis"><em>Douglas Crockford</em></span> (<a class="ulink" href="http://shop.oreilly.com/product/9780596517748.do">http://shop.oreilly.com/product/9780596517748.do</a>).</p><p>Some Backbone.js application <a id="id279" class="indexterm"/>development hints and good practices for testable code include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Decouple components and limit dependencies</strong></span>: Many Backbone.js components have optional dependencies on other components. For example, a Backbone.js view can optionally have a model declared in the view class (for example, <code class="literal">model: Foo</code>) or a model object can be passed to a view on instantiation (for example, <code class="literal">new View({model: foo})</code>). The latter technique often opens up more opportunities for injecting mocks or test-friendly models into the view code. The same logic also applies to the <code class="literal">el</code> property in Backbone.js views—it is often more test-friendly to provide values via a view object instance than in the view class definition.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Isolate configuration information</strong></span>: Any pure configuration data should get its own application file and facilitate the overriding of specific configurations. Canonical examples include the backend server host and port information, logging levels, and in the case of the Notes application, the name of the <code class="literal">localStorage</code> datastore. The previous examples that override <code class="literal">notes/app/js/app/config.js</code> provide a good introduction on how to both create a configuration file and supersede values for testing purposes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Decompose large functions</strong></span>: Monolithic functions that try to do everything are often difficult to test. Break up large functions into smaller ones, test them, and then aggregate the smaller functions into your application.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Avoid hidden state</strong></span>: Using techniques such as closures and anonymous functions, JavaScript permits classes and code to have a state that is unchangeable and inaccessible to other parts of the application and tests. For example, if a class has an internal counter, make it a member variable and not a closure-wrapped variable. While this is something of a debated topic, it is generally preferred to expose some amount of internal state for test (and application) use. At the same time, our tests should focus on the application <span class="emphasis"><em>behavior</em></span> and avoid deliberately using a internal state that is not part of the overall expected functioning of the application.</li></ul></div><p>Please note that these tips are heuristics and not hard and fast rules. Many development situations will favor doing exactly the opposite of one or more of these suggestions. Hopefully, some of these guidelines will help make your early application decisions easier to live with as your application and test code bases grow over time.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we dug into the Chai and Mocha test frameworks, starting with a tour of testing interfaces. We explored the many assertion statements available in Chai, then examined the creation of full Mocha test suites with setup/teardown, application configuration, and test specifications for Backbone.js components. Finally, we reviewed debugging tips and guidelines for a more test-friendly software development lifecycle.</p><p>At this point, our application has starting test coverage for some Backbone.js models, collections, and views. We will continue covering different parts of our Backbone.js application while introducing new topics in the subsequent chapters and work up to a final application test collection that aggregates all of our work.</p><p>In the next chapter, we will get more familiar with the Sinon.JS library. We will use test spies to verify program behavior and introspect how functions are called and respond within a Backbone.js application.</p></div></body></html>