- en: Chapter 13. Creating JavaScript Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have built up a web application, making use of various npm packages
    along the way. These packages include libraries such as Express and command-line
    tools such as Gulp. Now we'll look at how to go about creating packages of our
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the different module systems available for JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our own JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write JavaScript that can run on both the client and server-side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a command-line tool in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release a new npm package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Node.js modules in the browser environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code examples in this chapter are independent of everything we've done so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: Writing universal modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already written many of our own modules as part of our application.
    We can also write library modules for use in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code for use by others, it's worth considering in what contexts
    it will be useful. Some libraries are only useful in specific environments. For
    example, Express is server-specific and jQuery is browser-specific. But many modules
    provide functionality that would be useful in any environment, for example, utility
    modules such as the `uuid` module we've used elsewhere in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at writing a module to work in multiple environments. We'll need
    to support more than just Node.js-style modules. We'll also need to support client-side
    module systems such as RequireJS. Recall from [Chapter 4](part0025.xhtml#aid-NQU21
    "Chapter 4. Introducing Node.js Modules"), *Introducing Node.js Modules*, that
    Node.js and RequireJS implement two different module standards (CommonJS and **Asynchronous**
    **Module Definition** (**AMD**), respectively). Our package may also be used client-side
    in a website with no module system in place.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's create a module providing a simple `flatMap` method. This
    will work like `SelectMany` in .NET's LINQ. It will take an array and a function
    that returns a new array for each element. It will return a single array of the
    combined results.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a Node.js/CommonJS module, we could implement this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Comparing Node.js and RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js
    Modules"), *Introducing Node.js Modules*, that each module system provides the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A way of declaring a module with a name and its own scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of defining functionality provided by the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of importing a module into another script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js implements the CommonJS module standard. Module names correspond to
    file paths and each file has its own scope. Modules define the functionality they
    provide using the `exports` alias. Modules are imported using the `require` function.
  prefs: []
  type: TYPE_NORMAL
- en: RequireJS is designed for the browser environment. In the browser there is no
    new scope per file (all script files execute in the same scope and can see the
    same variables). Also, modules must be loaded by network requests rather than
    from the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'RequireJS implements the AMD standard. AMD specifies two functions, which RequireJS
    adds to the top-level window object in the browser environment:'
  prefs: []
  type: TYPE_NORMAL
- en: The `define` function allows new modules to be created by providing a name and
    a factory function for the module. The scope of the module will be the scope of
    its factory function. The functionality of the module is defined by the return
    value of the factory function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `require` function allows modules to be imported. Although this has the
    same name as the module import function in Node.js, it works very differently.
    Multiple module names can be specified for import (as an array). The require function
    is asynchronous and takes a callback to be executed when all the dependencies
    are loaded. This allows RequireJS to load modules efficiently in the browser environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting the browser environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our module to work in the browser environment, we need to support the AMD
    standard so RequireJS can work. We also need to accommodate sites not using any
    module loader. We can achieve this by extending our module definition as follows,
    in `scripts/flatMap.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the use of an anonymous function that is invoked straight away, called
    an **Immediately-Invoked** **Function Expression** (**IIFE**). This is a common
    way of creating an isolated scope in JavaScript environments without built-in
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: First, we check for the existence of an AMD-style `define` function (the existence
    of a `define.amd` property is also specified by the AMD standard). Note that the
    asynchronous nature of the `define` function means that we need to use a factory
    function to create our module. We provide a list of dependencies (empty in this
    case) and our factory function to the `define` function to create our module.
  prefs: []
  type: TYPE_NORMAL
- en: If no AMD module system is present, we check for the CommonJS-style `module.exports`
    used by Node.js. Finally, if neither module system is present, we provide our
    module as a property on the `root` parameter. Our argument for this parameter
    is the `this` keyword evaluated in the global scope. In a browser, this will be
    the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: Using AMD modules with RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a simple web page to check that our module works correctly with
    RequireJS. We'll also show how to use RequireJS with an external library, jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we define an HTML file for the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the only script tag on the page is for RequireJS itself. This script
    tag also has a data attribute indicating the entry point of our application. The
    path `scripts/main` tells RequireJS to load `scripts/main.js`, which contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This script first configures RequireJS. The only `config` property specified
    here is the `path` property. The path for jQuery under the key `'jquery'` tells
    RequireJS how to resolve the `'jquery'` dependency. We don't need to specify a
    path for `flatMap.js` because we have saved it under the same directory as `main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we use the `require` function to load flatMap and jQuery and pass them
    into our main application function. In larger applications using RequireJS, this
    is usually a very short bootstrap function. The `main.js` file is also often the
    only place that you'll see a `require` call. Most of the application code is in
    modules declared with `define`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is just a test of our library with RequireJS, we''ll put the rest of
    our application code inside our main application function. We use our flatMap
    module and jQuery to calculate and display word counts across all the text inputs.
    You can see this working by opening `index.html` in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using AMD modules with RequireJS](img/image00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Isomorphic JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `flatMap.js` example above is an implementation of the Universal Module
    Definition pattern. See [https://github.com/umdjs/umd](https://github.com/umdjs/umd)
    for annotated templates for this pattern. These templates also show how to declare
    dependencies between modules that follow this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, writing code that achieves the same result both on the server
    and in the browser is referred to as **Isomorphic JavaScript**. See [http://isomorphic.net/](http://isomorphic.net/)
    for more explanation and examples of this principle.
  prefs: []
  type: TYPE_NORMAL
- en: Writing npm packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you create some code that would be useful to others, you can distribute it
    as an npm package. To demonstrate this, we'll implement some slightly more complex
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the example code for this section at [https://github.com/NodeJsForDevelopers/autotoc](https://github.com/NodeJsForDevelopers/autotoc).
    Note that, unlike previous chapters, there is not one per commit per heading.
    The listings in the rest of this section match the final version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to implement a tool for generating a **table of contents** (**ToC**)
    by crawling a website. To help with this, we''ll make use of a few other npm packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**request** provides an API for making HTTP requests, which is higher-level
    and much simpler to use than the build in the Node.js http module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cheerio** provides jQuery-like HTML traversal outside of the browser environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**denodeify**, mentioned in [Chapter 8](part0048.xhtml#aid-1DOR02 "Chapter 8. Mastering
    Asynchronicity"), *Mastering Asynchronicity*, allows us to use the request library
    with promises instead of callbacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's common for `npm` packages to depend on other packages in this way. But
    it is worth minimizing your package's dependencies if you want it to be appealing
    to other developers. Packages with many transitive dependencies can add a lot
    of bloat to applications, and make it harder for developers to be confident that
    they understand everything they are pulling into their application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for our module follows, as given in `autotoc.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not important to understand every single line as we''re more interested
    in how it will be packaged. The important points are:'
  prefs: []
  type: TYPE_NORMAL
- en: We load the starting page then follow links through to other pages and process
    these recursively to build up the entire ToC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We only follow links to more specific URLs than the current page (that is, subpaths),
    so we don't get into infinite loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At each level, we load all child pages in parallel and use `Promise.all` to
    combine the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll also add a simple module to print a ToC to the console, as given in
    `consolePrinter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Defining an npm package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define an npm package, we must add a file to act as the entry point to our
    package. This will just expose the inner modules appropriately, as given in `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add an npm `package.json` file to define our package''s metadata.
    To create this file, you can run `npm init` in the command line and follow the
    prompts. In our case, the resulting file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've used `package.json` files before to specify dependencies for `npm install`.
    The other fields become much more important when publishing a package to `npm`.
    Note that we use the `main` property to specify our package's entry point. Actually,
    `index.js` is the default value, but specifying it explicitly makes this clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a package to npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have defined our package''s metadata, publishing it to npm is very
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not already have an npm account, create one by running `npm adduser`
    and specifying a username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in using `npm login`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `root` folder of the package, run `npm publish`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s all we need to do! Our package will now appear in the global npm repository.
    We can make use of it by (in a new folder) running `npm install autotoc` and writing
    the following simple demo script as given in `demo.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `node demo.js` at the command line produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing a package to npm](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running automated clients on the web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's fine to run tools like this against your own website. There are many use
    cases for this kind of technique. For example, a script that spiders through an
    entire site and checks every page can be a useful integration/smoke test.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases that involve crawling sites that you don't own require more care.
    Any public-facing site that you could visit in a browser, you could also access
    with an automated client like this. But issuing a large number of automated requests
    against the same host is undesirable. It could be considered poor etiquette at
    best or a **Denial of Service** (**DoS**) attack at worst.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clients should set an appropriate `User-Agent` HTTP header. Some servers might
    reject requests from clients that don''t specify a `User-Agent` or don''t appear
    to be a browser. By convention, crawlers should send a `User-Agent` including
    the word *bot* in the name and ideally a URL to find out more about the bot. The
    request library makes it easy to specify headers by passing in an options object.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Crawlers should also check for a `robots.txt` file for each website and respect
    any rules it contains. See [http://www.robotstxt.org/robotstxt.html](http://www.robotstxt.org/robotstxt.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, legitimate crawlers of third-party websites should also rate-limit
    their requests to avoid overwhelming the server.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing a standalone tool to npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the `npm` packages we''ve used so far in this book have been command-line
    tools rather than libraries, for example Gulp. Creating a command-line tool package
    is very straightforward. First, we need to define the script that we want people
    to be able to invoke from the command line, as given in `cli.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks much like our demo script from before, with a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The line at the beginning of the script (called a **shebang line**, starting
    with `#!`) indicates to the OS that this script should be executed using Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL to crawl is taken from a command-line argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we just need to specify this script in our `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To publish our updated package, we first need to update our version number.
    You can update this in the package directly or use the `npm` version command,
    for example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This automatically updates the version number to the next major/minor/patch
    version (as specified) and makes a new git commit with this change.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are already logged into npm, we can now publish the new version of
    our package by running `npm publish` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now make use of our CLI tool as follows (in a new command prompt window):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using Node.js modules in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we discussed creating universal modules that
    can run under Node.js or in the browser. There is another way that we can allow
    our code to run in both environments.
  prefs: []
  type: TYPE_NORMAL
- en: Browserify ([http://browserify.org/](http://browserify.org/)) allows you to
    make use of Node.js modules in the browser. It bundles up your code together with
    its dependencies. It also provides browser-compatible shims to emulate Node.js
    built-in modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Browserify via npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Browserify is typically used to package applications. For example, if we wanted
    to package our demo usage of autotoc from the previous section, we could run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Browserify will create a single JavaScript file containing the code from `demo.js`,
    along with its dependencies and transitive dependencies. If we include this in
    an HTML page, we can now see it working in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Node.js modules in the browser](img/image00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use Browserify to generate browser-compatible files for individual
    modules, following the Universal Module Definition pattern discussed earlier in
    this chapter. For example, to create a UMD version of our `autotoc.js` module
    from the previous section, we could run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We could now make use of this via RequireJS. Let''s create a simple application
    that uses autotoc together with jQuery to generate an HTML ToC. First we''ll need
    an HTML file to contain our application and include RequireJS, as given in `browser/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement our application itself, as given in `browser/scripts/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Node.js modules in the browser](img/image00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Controlling Browserify's output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that, by default, Browserify generates a bundle of your code and all of
    its dependencies. Including transitive dependencies, this can result in a very
    large file. The autotoc module is only 42 lines long, but the generated bundle
    is over 80,000 lines! Our application above includes both jQuery (via RequireJS)
    and a version of Cheerio (via Browserify). This is particularly wasteful, since
    much of Cheerio is a re-implementation of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: You can instruct Browserify to exclude specific modules and to exclude all external
    modules. This is particularly useful for third-party modules that follow the UMD
    pattern. These do not need to be *browserified* and can be excluded from the generated
    bundle. You can then load them separately in the browser, via an additional script
    tag or using RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Browserify's usage options, see the official documentation
    at [https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage).
  prefs: []
  type: TYPE_NORMAL
- en: Browserify provides a lot of flexibility for bundling modules in different ways.
    It is particularly useful when working on a single codebase with both server-side
    and client-side functionality. It allows you to write all of your code using Node.js-style
    modules and to easily share modules between the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have written a multi-environment module following the universal
    module definition pattern, created an npm package for a library and a command-line
    tool, and packaged Node.js code for the browser using Browserify.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates the flexibility of Node.js and the range of use cases for
    JavaScript and npm beyond just server-side code. In the final chapter, we'll look
    at the broader context around Node.js. We'll see some of the newer languages and
    upcoming language features for the platform and how Node.js interacts with other
    platforms like .NET.
  prefs: []
  type: TYPE_NORMAL
