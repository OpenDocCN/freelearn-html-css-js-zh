- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Component Mocks to Clarify Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding chapter introduced the concept of a test double and showed how
    `vi.fn` can be used to swap out unwanted behavior within your Vitest test suites.
    The same technique can be used for Svelte components, but it’s a little more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re writing unit tests for a component named `Parent`, and that component
    itself renders another developer-defined component, named `Child`. By default,
    when your tests render `Parent`, `Child` is rendered too. But using a component
    mock can stop that from happening. It swaps out the real `Child` for a test double.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various reasons why you’d want to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Child` component already has its own unit test suite, and you don’t want
    to repeat yourself (a form of overtesting, described in detail in the *Avoiding
    component* *mocks* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Child` component has behavior on mount, such as fetching data via the Fetch
    API, that you’d rather avoid running within your test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Child` component comes from a third-party library and it’s more important
    that you verify the props it is rendered with, rather than verifying the behavior
    of the third-party component itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downside of using component mocks is that they’re complex, and if you’re
    not careful, they can become a burden.
  prefs: []
  type: TYPE_NORMAL
- en: Staying safe with test doubles
  prefs: []
  type: TYPE_NORMAL
- en: The number-one rule when using component mocks, and test doubles in general,
    is to avoid building any control logic (`if` statements and loops) into them.
    Instead, when you use `mockReturnValue` or `mockResolvedValue` to specify the
    value that is returned, always prefer to return fixed values.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to ensure that happens is to ensure that each unit test gets its
    own test double instance. In other words, avoid setting up a test double in a
    `beforeEach` block and reusing it across all tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re struggling to keep test doubles simple, that can be a sign that the
    application code design is too complex. Try reconfiguring the object under test,
    perhaps by splitting it out into a number of separate objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding component mocks when possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using hand-rolled component stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a component mock library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be confident with using component mocking
    techniques and know when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start).
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding component mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers how to build your application without using component mocks.
    Of course, the application we’ve built up to this point hasn’t used any, so you
    already know it’s possible.
  prefs: []
  type: TYPE_NORMAL
- en: The SvelteKit application we’ve built has a page route component that renders
    a list of `Birthday` components and a `BirthdayForm` component. Both of these
    components are covered by their own test suites, so they are certainly candidates
    for using component mocks. The page route component would simply check that it
    renders `Birthday` and `BirthdayForm` in the right way, and avoid testing any
    of the birthdays themselves.
  prefs: []
  type: TYPE_NORMAL
- en: But there’s not much point in doing this. Neither of these components has any
    behavior on mount, so there’s no trouble in letting them render.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest risk you have in not using component mocks is that of `Birthday`
    component test suite and repeating them in the page route test suite.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.1* shows how the test suites for a `Parent` and `Child` component
    can be developed without overtesting. The `Parent` test suite only needs to test
    a single flow to `Child` to prove the connection. If there are any interesting
    return flows of data back from `Child` into `Parent` (such as component event
    bindings), then they should be tested too.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Overtesting caused by repeated tests at two levels in a component
    hierarchy](img/Figure_12.1_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Overtesting caused by repeated tests at two levels in a component
    hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, TDD has a couple of rules that avoid the problem of overtesting.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding overtesting using TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine first that you’re building your application using a bottom-up approach,
    which is the approach this book has followed. That means that you write the `Child`
    component and its test suite before writing the `Parent` component and its test
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: When you begin test-driving `Parent`, you write a test that will bring in the
    `Child` component. (The test description might be something such as *displays
    the birthday information*.) Recall the TDD rule of *make the simplest change that
    could possibly work*. Since you’ve already written the `Child` component at your
    disposal, then the simplest change is to simply bring in the `Child` component.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the rule of the *Red* test comes into play, and this is the crucial one
    that avoids overtesting. You can’t work on a test unless you see it fail. But
    if your first test brought in the `Child` component, you suddenly get all the
    behavior of `Child` for free. So, if you’re following TDD, it’s impossible to
    write a *Red* test for all the behavior of `Child`, because it will already pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that you started by building the `Parent` component and at some
    point felt the urge to extract a `Child` component (you might think of this as
    a top-down approach). How do you go about extracting `Child`? If you’re being
    strict, you might start by rewriting the tests for `Child`, as we did in [*Chapter
    9*](B19611_09.xhtml#_idTextAnchor111), *Extracting Logic Out of the Framework*,
    when we extracted the birthday repository. But generally, you wouldn’t stop there:
    you’d want to go back and delete those extra tests from `Parent`.'
  prefs: []
  type: TYPE_NORMAL
- en: You could view this as part of the *Refactor* step of the TDD cycle. In fact,
    we did this in the preceding chapter when we ended up deleting a bunch of tests
    as we changed out the system functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To repeat the message of this section: you don’t always need to use mocks.
    If you have a single test to prove the connection between `Parent` and `Child`,
    that’s often enough. Moreover, using TDD can naturally lead to you using this
    approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Using hand-rolled component stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at a simple but effective way of mocking components,
    by building hand-rolled component stubs. This isn’t as clever as using a component
    mock library, but it’s simpler and easier to understand. Often, the simplest approach
    is the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap what we’re trying to do: we have a child component that we want to
    avoid rendering, perhaps because it has mount behavior or it’s a complex third-party
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: Hand-rolled component stubs rely on Vitest’s `vi.mock` function combined with
    a special `__mocks__` directory. You create a stub component with the same name
    as your component, but inside a `__mocks__` directory at the same level as the
    component itself. Then, you instruct Vitest to use the mock using the `vi.mock`
    statement placed at the top of your test file. This will mean the entire test
    suite uses the mock.
  prefs: []
  type: TYPE_NORMAL
- en: We can demonstrate this using the page route component test suite, building
    mocks for the `Birthday` and `BirthdayForm` components. These components don’t
    have any side effects on mount, and they aren’t third party, but they do have
    their own test suites. So, even though it doesn’t feel necessary to make this
    change, it’s not unsafe to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Since this work isn’t necessary, we’ll build an example test suite in a test
    file named `page.mocks.test.js`. Although this isn’t how I’d do this in the real
    world, it does highlight how you can have both mocked and non-mocked unit tests
    within the same code base.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a look at how to verify props using a stub component. Then,
    we’ll look at checking the ordering of instances, followed by dealing with complex
    prop verification, and finishing with a look at how to dispatch component events.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering all props within a component stub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding chapter, you saw that it’s important to verify the props that
    are passed into a test double. Component stubs are no different. The way we do
    this is to ensure that the component stub renders all the props and then use standard
    DOM matchers to verify their presence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating a hand-rolled component stub for the `Birthday` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `src/routes/birthdays/__mocks__`. The special name
    is picked up automatically by Vitest as a location for your mocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `src/routes/birthdays/__mocks__/Birthday.svelte` with
    the following content. It does nothing but render out all the props that are passed
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a new test file named `src/routes/birthdays/page.mock.test.js` and
    start with the usual `import` statements. Notice how `vi` is included; we’ll use
    that in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, just below the `import` statements, add a call to `vi.mock`. The path
    given must match the path to the *actual* `Birthday` component. Vitest will pick
    up the mock and load that instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start a new `describe` block, together with a sample `birthdays` array.
    All our tests will use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Time for the first test. This is going to check that given the two birthdays
    defined previously, each of the correct bits of information is displayed on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing lists of components
  prefs: []
  type: TYPE_NORMAL
- en: 'This test checks *two* birthdays, not one: since we’re interested in the listing
    behavior – one `Birthday` component per entry – it’s important to test that a
    list of birthdays does in fact give a list of `Birthday` components. A single
    birthday isn’t enough to prove a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Because our implementation already exists, this test should already pass. But
    it’s important to prove the test works, and this time we want to also verify that
    the mock has been picked up. So, first delete the contents of the *actual* `Birthday`
    component (not the mock). The test should *still* pass. (Make sure you use the
    `v src/routes/birthdays/page.mocks.test.js` command to run your tests, otherwise
    you’ll see all the failures from other test suites.) This should convince you
    that the mock is being picked up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Undo your changes to the `Birthday` component, and now let’s make a change
    to make the test fail. In the page route component at `src/routes/birthday/+page.svelte`,
    comment out the rendering of the `Birthday` component, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests with `v src/routes/birthdays/page.mocks.test.js` and verify the
    test now fails. Then, undo your change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ve now learned about the basic usage of component stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the ordering of component instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, when we are dealing with lists of components, we want to check the
    ordering of instances. We can check that using the `data-testid` attribute to
    get hold of each specific instance.
  prefs: []
  type: TYPE_NORMAL
- en: There is a general piece of advice to avoid using `data-testid` in tests. This
    is good advice, but your component stubs are a part of your test suite, not the
    application code, so it’s safe to use them here.
  prefs: []
  type: TYPE_NORMAL
- en: When to use list ordering tests
  prefs: []
  type: TYPE_NORMAL
- en: The test in this section isn’t very TDD-like; it proves what I’d consider the
    *default* ordering of lists. If you already have a test that checks that data
    is listed, like the one in *step 6* of the preceding section, then the simplest
    way to make that pass is to implement the default ordering. So, writing a test
    like the one in *writing a test like the one your'e about to see* will likely
    pass by default, and is therefore an invalid test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the component stub to add a `data-testid` attribute, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, write a test that proves the ordering. It uses `queryAllByTestId` to return
    a list of elements that match a specific `data-testid` attribute value, in the
    order they are listed in the document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will pass, but make sure you verify it doesn’t pass by using the same commenting-out
    trick from previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s also worth pointing out that there is another way to write an ordering
    test that doesn’t involve using the `data-testid` attribute. You could instead
    get hold of the `ol` element on the page, then map each of the `li` elements to
    their text content and check that it is an array in the order that you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with complex props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the props to your component are objects or arrays, and if you were
    to render them all out within the component stub, you’d end up with a whole bunch
    of code in the stub. There’s a shorter way of outputting prop values, which is
    to use the `JSON.stringify` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that now for the `BirthdayForm` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `src/routes/birthdays/__mocks__/BirthdayForm.svelte`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your test suite, add a new call to `vi.mock` that pulls in this component,
    next to the previous call to `vi.mock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following helper function at the top of the test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the next test, as shown; it also calls `JSON.stringify`. This should
    pass, but make sure to verify it before finishing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will note the coupling between the component stub and the test suite. This
    component stub is quite awkward. What I find is that this technique of utilising
    `JSON.stringify` is generally fine as long as it’s the single pattern you use
    to check complex props and is used consistently between developers.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching component events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final component stub technique we will look at is the mechanism to dispatch
    component events. As in the last section, this is awkward, because it’s impossible
    to raise a component event on a hand-rolled stub without having a dispatcher object
    defined within the stub itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to deal with this is to just stick a button into the stub and use that
    to dispatch the event:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example doesn’t make a huge amount of sense in the context of
    our application: the actual `BirthdayForm` component doesn’t have this *cancel*
    behavior, and if this feature *did* exist, it would probably make more sense to
    have the **Cancel** button within the page route, avoiding the need for a component
    event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `BirthdayForm` component stub to include a `button` element that
    dispatches a `cancel` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can add a test that checks what happens when the `cancel` event is
    dispatched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, update the `page` component to respond to the `cancel` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember, the *real* `BirthdayForm` component doesn’t have this behavior, and
    this exposes a big problem with mocking components: it’s challenging to keep the
    mock aligned with real implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding hand-rolled mocks and using a library is one way to deal with this
    problem, as we’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a component mock library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you saw how you can use `vi.fn` to spy on functions. The
    `svelte-component-double` npm package can be used in a similar fashion, achieving
    the same effect as the hand-rolled mocks you’ve just learned about.
  prefs: []
  type: TYPE_NORMAL
- en: The package includes matchers such as `toBeRendered` and `toBeRenderedWithProps`
    to check that the component is indeed rendered in the way you wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s split this into a couple of parts: installing the library and writing
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The library requires a bit of setup to get the relevant matchers into place:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new file named `src/vitest/registerSvelteComponentDouble.js`
    with the following content. It registers the matchers and also gives us global
    access to the `componentDouble` function, which is not required but makes mock
    setup easier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update your `vite.config.js` file to include the new setup file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’re now ready to use the library in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests using the componentDouble function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will rewrite the mock test suite to use the library rather than hand-rolled
    component stubs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by redefining the two calls to `vi.mock` with the following definitions.
    Each call to `componentDouble` gets a string identifier. This appears in your
    DOM output and is used in expectation failures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll also need to add two `import` statements at the top of the file so that
    you can access the mock object. Although it looks like you’re importing the actual
    components, you’ll actually get the component doubles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s also important to reset the component doubles between each test. That’s
    because `vi.mock` will only generate a double once per test suite. Add the following
    two calls to `beforeEach` at the top of the `describe` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll also need to update the `import` statement to pull in the `beforeEach`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now for the first test. The makes use of the matcher `toBeRendered`, which
    checks that the component appears somewhere in the document. Update the first
    test to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run this test, mark it as `it.only` and then run Vitest on this test suite.
    You should see it passing; you can verify it in the usual way, by commenting out
    the `Birthday` component instance in the page route component. This time, you’ll
    see a failure printed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Undo that change so the test is passing again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We know that not just one `Birthday` is displayed, but two. We can use the
    `toBeRenderedWithProps` matcher to check for individual instances of the component.
    Update the same test to use that matcher, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the calls to `toBeRenderedWithProps` do not need to specify the full
    set of props. If the given subset matches, the expectation passes. That means
    we can avoid checking the `id` field, which is unnecessary detail for the purposes
    of this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you comment out the rendering of `Birthday` in the component, you’ll see
    what a failure for this matcher looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second test in this test suite checks the ordering of components. We can
    do that with the library by using the `propsOfAllInstances` function that exists
    on the double. Update the test to read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first test for `BirthdayForm` no longer needs any `JSON.stringify` magic.
    We can just test the object prop directly. Update the test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the last test can make use of the `dispatch` double function to
    dispatch an event to the parent component. Note how much simpler this is than
    the hand-rolled mock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These last two tests show how much simpler it can be to use a component mock
    library over hand-rolled mocks. That completes this section. You’ve now discovered
    all there is to using the `svelte-component-double` library to simplify your test
    suites.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has taken a very detailed look at component mocks. We started by
    looking at how it’s often possible to avoid using component mocks in the majority
    of cases, which is important because component mocks are a big cause of complexity
    in test suites.
  prefs: []
  type: TYPE_NORMAL
- en: You then saw how to use hand-rolled mocks that take advantage of Vitest’s `vi.mock`
    function together with component stubs in the specially named `__mocks__` directory.
    You also saw how they can quickly become complex.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at using the `svelte-component-double` library to avoid using
    hand-rolled mocks. This provides a couple of simple matchers together with some
    helper functions to assist you in writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes all the unit testing topics within this book. The next chapter
    adds one more testing technique: using Cucumber.js to write **Behavior-Driven
    Development** (**BDD**) style tests for your team.'
  prefs: []
  type: TYPE_NORMAL
