- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Using Component Mocks to Clarify Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件模拟来澄清测试
- en: The preceding chapter introduced the concept of a test double and showed how
    `vi.fn` can be used to swap out unwanted behavior within your Vitest test suites.
    The same technique can be used for Svelte components, but it’s a little more complicated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章介绍了测试替身（test double）的概念，并展示了如何使用`vi.fn`在Vitest测试套件中替换掉不希望的行为。同样的技术也可以用于Svelte组件，但稍微复杂一些。
- en: Imagine you’re writing unit tests for a component named `Parent`, and that component
    itself renders another developer-defined component, named `Child`. By default,
    when your tests render `Parent`, `Child` is rendered too. But using a component
    mock can stop that from happening. It swaps out the real `Child` for a test double.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为一个名为`Parent`的组件编写单元测试，而这个组件本身渲染了另一个开发者定义的组件，名为`Child`。默认情况下，当你的测试渲染`Parent`时，`Child`也会被渲染。但使用组件模拟可以阻止这种情况发生。它会用测试替身替换掉真实的`Child`。
- en: 'There are various reasons why you’d want to do this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要这样做的原因有很多：
- en: The `Child` component already has its own unit test suite, and you don’t want
    to repeat yourself (a form of overtesting, described in detail in the *Avoiding
    component* *mocks* section)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child`组件已经有了自己的单元测试套件，你不想重复测试（这是过度测试的一种形式，在*避免组件模拟*部分有详细描述）'
- en: The `Child` component has behavior on mount, such as fetching data via the Fetch
    API, that you’d rather avoid running within your test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child`组件在挂载时有一些行为，例如通过Fetch API获取数据，你更希望避免在测试中运行这些行为'
- en: The `Child` component comes from a third-party library and it’s more important
    that you verify the props it is rendered with, rather than verifying the behavior
    of the third-party component itself
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child`组件来自第三方库，验证它渲染的属性比验证第三方组件本身的行为更重要'
- en: The downside of using component mocks is that they’re complex, and if you’re
    not careful, they can become a burden.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件模拟的缺点是它们很复杂，如果你不小心，它们可能会成为负担。
- en: Staying safe with test doubles
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试替身保持安全
- en: The number-one rule when using component mocks, and test doubles in general,
    is to avoid building any control logic (`if` statements and loops) into them.
    Instead, when you use `mockReturnValue` or `mockResolvedValue` to specify the
    value that is returned, always prefer to return fixed values.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件模拟以及测试替身的一般规则是避免在它们中构建任何控制逻辑（`if`语句和循环）。相反，当你使用`mockReturnValue`或`mockResolvedValue`来指定返回的值时，始终优先返回固定值。
- en: An easy way to ensure that happens is to ensure that each unit test gets its
    own test double instance. In other words, avoid setting up a test double in a
    `beforeEach` block and reusing it across all tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这一点的一个简单方法是为每个单元测试获取其自己的测试替身实例。换句话说，避免在`beforeEach`块中设置测试替身并在所有测试中重复使用它。
- en: If you’re struggling to keep test doubles simple, that can be a sign that the
    application code design is too complex. Try reconfiguring the object under test,
    perhaps by splitting it out into a number of separate objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现难以保持测试替身简单，这可能意味着应用程序代码设计过于复杂。尝试重新配置待测试的对象，例如将其拆分为多个单独的对象。
- en: 'This chapter covers the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Avoiding component mocks when possible
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下避免使用组件模拟
- en: Using hand-rolled component stubs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手工制作的组件存根
- en: Using a component mock library
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件模拟库
- en: By the end of the chapter, you will be confident with using component mocking
    techniques and know when to use them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够自信地使用组件模拟技术，并知道何时使用它们。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为[https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start)。
- en: Avoiding component mocks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用组件模拟
- en: This section covers how to build your application without using component mocks.
    Of course, the application we’ve built up to this point hasn’t used any, so you
    already know it’s possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在不需要使用组件模拟的情况下构建应用程序。当然，我们到目前为止构建的应用程序没有使用任何组件模拟，所以你已经知道这是可能的。
- en: The SvelteKit application we’ve built has a page route component that renders
    a list of `Birthday` components and a `BirthdayForm` component. Both of these
    components are covered by their own test suites, so they are certainly candidates
    for using component mocks. The page route component would simply check that it
    renders `Birthday` and `BirthdayForm` in the right way, and avoid testing any
    of the birthdays themselves.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: But there’s not much point in doing this. Neither of these components has any
    behavior on mount, so there’s no trouble in letting them render.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The biggest risk you have in not using component mocks is that of `Birthday`
    component test suite and repeating them in the page route test suite.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.1* shows how the test suites for a `Parent` and `Child` component
    can be developed without overtesting. The `Parent` test suite only needs to test
    a single flow to `Child` to prove the connection. If there are any interesting
    return flows of data back from `Child` into `Parent` (such as component event
    bindings), then they should be tested too.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Overtesting caused by repeated tests at two levels in a component
    hierarchy](img/Figure_12.1_B19611.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Overtesting caused by repeated tests at two levels in a component
    hierarchy
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, TDD has a couple of rules that avoid the problem of overtesting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding overtesting using TDD
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine first that you’re building your application using a bottom-up approach,
    which is the approach this book has followed. That means that you write the `Child`
    component and its test suite before writing the `Parent` component and its test
    suite.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When you begin test-driving `Parent`, you write a test that will bring in the
    `Child` component. (The test description might be something such as *displays
    the birthday information*.) Recall the TDD rule of *make the simplest change that
    could possibly work*. Since you’ve already written the `Child` component at your
    disposal, then the simplest change is to simply bring in the `Child` component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Then, the rule of the *Red* test comes into play, and this is the crucial one
    that avoids overtesting. You can’t work on a test unless you see it fail. But
    if your first test brought in the `Child` component, you suddenly get all the
    behavior of `Child` for free. So, if you’re following TDD, it’s impossible to
    write a *Red* test for all the behavior of `Child`, because it will already pass.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that you started by building the `Parent` component and at some
    point felt the urge to extract a `Child` component (you might think of this as
    a top-down approach). How do you go about extracting `Child`? If you’re being
    strict, you might start by rewriting the tests for `Child`, as we did in [*Chapter
    9*](B19611_09.xhtml#_idTextAnchor111), *Extracting Logic Out of the Framework*,
    when we extracted the birthday repository. But generally, you wouldn’t stop there:
    you’d want to go back and delete those extra tests from `Parent`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: You could view this as part of the *Refactor* step of the TDD cycle. In fact,
    we did this in the preceding chapter when we ended up deleting a bunch of tests
    as we changed out the system functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'To repeat the message of this section: you don’t always need to use mocks.
    If you have a single test to prove the connection between `Parent` and `Child`,
    that’s often enough. Moreover, using TDD can naturally lead to you using this
    approach.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Using hand-rolled component stubs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at a simple but effective way of mocking components,
    by building hand-rolled component stubs. This isn’t as clever as using a component
    mock library, but it’s simpler and easier to understand. Often, the simplest approach
    is the best choice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap what we’re trying to do: we have a child component that we want to
    avoid rendering, perhaps because it has mount behavior or it’s a complex third-party
    component.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Hand-rolled component stubs rely on Vitest’s `vi.mock` function combined with
    a special `__mocks__` directory. You create a stub component with the same name
    as your component, but inside a `__mocks__` directory at the same level as the
    component itself. Then, you instruct Vitest to use the mock using the `vi.mock`
    statement placed at the top of your test file. This will mean the entire test
    suite uses the mock.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: We can demonstrate this using the page route component test suite, building
    mocks for the `Birthday` and `BirthdayForm` components. These components don’t
    have any side effects on mount, and they aren’t third party, but they do have
    their own test suites. So, even though it doesn’t feel necessary to make this
    change, it’s not unsafe to do so.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Since this work isn’t necessary, we’ll build an example test suite in a test
    file named `page.mocks.test.js`. Although this isn’t how I’d do this in the real
    world, it does highlight how you can have both mocked and non-mocked unit tests
    within the same code base.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a look at how to verify props using a stub component. Then,
    we’ll look at checking the ordering of instances, followed by dealing with complex
    prop verification, and finishing with a look at how to dispatch component events.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Rendering all props within a component stub
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding chapter, you saw that it’s important to verify the props that
    are passed into a test double. Component stubs are no different. The way we do
    this is to ensure that the component stub renders all the props and then use standard
    DOM matchers to verify their presence.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating a hand-rolled component stub for the `Birthday` component:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `src/routes/birthdays/__mocks__`. The special name
    is picked up automatically by Vitest as a location for your mocks.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `src/routes/birthdays/__mocks__/Birthday.svelte` with
    the following content. It does nothing but render out all the props that are passed
    in:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now create a new test file named `src/routes/birthdays/page.mock.test.js` and
    start with the usual `import` statements. Notice how `vi` is included; we’ll use
    that in the next step:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为`src/routes/birthdays/page.mock.test.js`的新测试文件，并从常用的`import`语句开始。注意`vi`是如何被包含在内的；我们将在下一步中使用它：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, just below the `import` statements, add a call to `vi.mock`. The path
    given must match the path to the *actual* `Birthday` component. Vitest will pick
    up the mock and load that instead:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`import`语句下方，添加对`vi.mock`的调用。提供的路径必须与`实际`的`Birthday`组件路径匹配。Vitest将拾取模拟并加载该组件：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, start a new `describe` block, together with a sample `birthdays` array.
    All our tests will use this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始一个新的`describe`块，以及一个示例`birthdays`数组。我们所有的测试都将使用这个：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Time for the first test. This is going to check that given the two birthdays
    defined previously, each of the correct bits of information is displayed on screen:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行第一次测试的时间。这将检查给定之前定义的两个生日，每个正确的信息片段都显示在屏幕上：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing lists of components
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试组件列表
- en: 'This test checks *two* birthdays, not one: since we’re interested in the listing
    behavior – one `Birthday` component per entry – it’s important to test that a
    list of birthdays does in fact give a list of `Birthday` components. A single
    birthday isn’t enough to prove a list.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试检查**两个**生日，而不是一个：因为我们感兴趣的是列表行为——每个条目一个`Birthday`组件——所以测试确实给出了生日列表的`Birthday`组件列表很重要。单个生日不足以证明列表。
- en: Because our implementation already exists, this test should already pass. But
    it’s important to prove the test works, and this time we want to also verify that
    the mock has been picked up. So, first delete the contents of the *actual* `Birthday`
    component (not the mock). The test should *still* pass. (Make sure you use the
    `v src/routes/birthdays/page.mocks.test.js` command to run your tests, otherwise
    you’ll see all the failures from other test suites.) This should convince you
    that the mock is being picked up.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的实现已经存在，此测试应该已经通过。但证明测试有效很重要，这次我们还想验证模拟已被拾取。所以，首先删除*实际*的`Birthday`组件的内容（不是模拟）。测试应该*仍然*通过。（确保您使用`v
    src/routes/birthdays/page.mocks.test.js`命令运行测试，否则您将看到来自其他测试套件的全部失败。）这应该让您相信模拟已被拾取。
- en: 'Undo your changes to the `Birthday` component, and now let’s make a change
    to make the test fail. In the page route component at `src/routes/birthday/+page.svelte`,
    comment out the rendering of the `Birthday` component, like this:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销对`Birthday`组件的更改，现在让我们进行一个更改以使测试失败。在页面路由组件`src/routes/birthday/+page.svelte`中，注释掉`Birthday`组件的渲染，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the tests with `v src/routes/birthdays/page.mocks.test.js` and verify the
    test now fails. Then, undo your change.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`v src/routes/birthdays/page.mocks.test.js`运行测试，并验证测试现在失败。然后，撤销您的更改。
- en: You’ve now learned about the basic usage of component stubs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了组件存根的基本用法。
- en: Checking the ordering of component instances
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查组件实例的排序
- en: Sometimes, when we are dealing with lists of components, we want to check the
    ordering of instances. We can check that using the `data-testid` attribute to
    get hold of each specific instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们处理组件列表时，我们想检查实例的排序。我们可以使用`data-testid`属性来获取每个特定实例以进行检查。
- en: There is a general piece of advice to avoid using `data-testid` in tests. This
    is good advice, but your component stubs are a part of your test suite, not the
    application code, so it’s safe to use them here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个普遍的建议是避免在测试中使用`data-testid`。这是一个好建议，但您的组件存根是测试套件的一部分，而不是应用程序代码，所以在这里使用它们是安全的。
- en: When to use list ordering tests
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用列表排序测试
- en: The test in this section isn’t very TDD-like; it proves what I’d consider the
    *default* ordering of lists. If you already have a test that checks that data
    is listed, like the one in *step 6* of the preceding section, then the simplest
    way to make that pass is to implement the default ordering. So, writing a test
    like the one in *writing a test like the one your'e about to see* will likely
    pass by default, and is therefore an invalid test.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的测试并不非常符合TDD（测试驱动开发）的风格；它证明了我认为的*默认*列表排序。如果您已经有了一个检查数据是否列出的测试，就像前一个节中的*步骤6*中的那样，那么使那个测试通过的最简单方法就是实现默认排序。所以，编写一个像您即将看到的测试一样，可能会默认通过，因此是一个无效的测试。
- en: 'Let’s start:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Update the component stub to add a `data-testid` attribute, like this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新组件存根以添加一个`data-testid`属性，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, write a test that proves the ordering. It uses `queryAllByTestId` to return
    a list of elements that match a specific `data-testid` attribute value, in the
    order they are listed in the document:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will pass, but make sure you verify it doesn’t pass by using the same commenting-out
    trick from previously.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s also worth pointing out that there is another way to write an ordering
    test that doesn’t involve using the `data-testid` attribute. You could instead
    get hold of the `ol` element on the page, then map each of the `li` elements to
    their text content and check that it is an array in the order that you expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with complex props
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the props to your component are objects or arrays, and if you were
    to render them all out within the component stub, you’d end up with a whole bunch
    of code in the stub. There’s a shorter way of outputting prop values, which is
    to use the `JSON.stringify` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that now for the `BirthdayForm` component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `src/routes/birthdays/__mocks__/BirthdayForm.svelte`
    with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In your test suite, add a new call to `vi.mock` that pulls in this component,
    next to the previous call to `vi.mock`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add the following helper function at the top of the test suite:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, add the next test, as shown; it also calls `JSON.stringify`. This should
    pass, but make sure to verify it before finishing:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will note the coupling between the component stub and the test suite. This
    component stub is quite awkward. What I find is that this technique of utilising
    `JSON.stringify` is generally fine as long as it’s the single pattern you use
    to check complex props and is used consistently between developers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching component events
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final component stub technique we will look at is the mechanism to dispatch
    component events. As in the last section, this is awkward, because it’s impossible
    to raise a component event on a hand-rolled stub without having a dispatcher object
    defined within the stub itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to deal with this is to just stick a button into the stub and use that
    to dispatch the event:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example doesn’t make a huge amount of sense in the context of
    our application: the actual `BirthdayForm` component doesn’t have this *cancel*
    behavior, and if this feature *did* exist, it would probably make more sense to
    have the **Cancel** button within the page route, avoiding the need for a component
    event.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `BirthdayForm` component stub to include a `button` element that
    dispatches a `cancel` event:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, you can add a test that checks what happens when the `cancel` event is
    dispatched:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make this pass, update the `page` component to respond to the `cancel` event:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remember, the *real* `BirthdayForm` component doesn’t have this behavior, and
    this exposes a big problem with mocking components: it’s challenging to keep the
    mock aligned with real implementations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding hand-rolled mocks and using a library is one way to deal with this
    problem, as we’ll see in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Using a component mock library
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you saw how you can use `vi.fn` to spy on functions. The
    `svelte-component-double` npm package can be used in a similar fashion, achieving
    the same effect as the hand-rolled mocks you’ve just learned about.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The package includes matchers such as `toBeRendered` and `toBeRenderedWithProps`
    to check that the component is indeed rendered in the way you wanted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s split this into a couple of parts: installing the library and writing
    tests.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The library requires a bit of setup to get the relevant matchers into place:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the package:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, create a new file named `src/vitest/registerSvelteComponentDouble.js`
    with the following content. It registers the matchers and also gives us global
    access to the `componentDouble` function, which is not required but makes mock
    setup easier:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, update your `vite.config.js` file to include the new setup file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You’re now ready to use the library in your tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests using the componentDouble function
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will rewrite the mock test suite to use the library rather than hand-rolled
    component stubs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by redefining the two calls to `vi.mock` with the following definitions.
    Each call to `componentDouble` gets a string identifier. This appears in your
    DOM output and is used in expectation failures:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You’ll also need to add two `import` statements at the top of the file so that
    you can access the mock object. Although it looks like you’re importing the actual
    components, you’ll actually get the component doubles:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s also important to reset the component doubles between each test. That’s
    because `vi.mock` will only generate a double once per test suite. Add the following
    two calls to `beforeEach` at the top of the `describe` block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You’ll also need to update the `import` statement to pull in the `beforeEach`
    function:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now for the first test. The makes use of the matcher `toBeRendered`, which
    checks that the component appears somewhere in the document. Update the first
    test to look like the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run this test, mark it as `it.only` and then run Vitest on this test suite.
    You should see it passing; you can verify it in the usual way, by commenting out
    the `Birthday` component instance in the page route component. This time, you’ll
    see a failure printed as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Undo that change so the test is passing again.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We know that not just one `Birthday` is displayed, but two. We can use the
    `toBeRenderedWithProps` matcher to check for individual instances of the component.
    Update the same test to use that matcher, like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how the calls to `toBeRenderedWithProps` do not need to specify the full
    set of props. If the given subset matches, the expectation passes. That means
    we can avoid checking the `id` field, which is unnecessary detail for the purposes
    of this test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'If you comment out the rendering of `Birthday` in the component, you’ll see
    what a failure for this matcher looks like:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注释掉组件中`Birthday`的渲染，你会看到这个匹配器失败的样子：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second test in this test suite checks the ordering of components. We can
    do that with the library by using the `propsOfAllInstances` function that exists
    on the double. Update the test to read as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本测试套件的第二个测试检查组件的顺序。我们可以通过使用存在于双实例上的`propsOfAllInstances`函数来实现这一点。更新测试如下：
- en: '[PRE26]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first test for `BirthdayForm` no longer needs any `JSON.stringify` magic.
    We can just test the object prop directly. Update the test as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`BirthdayForm`的第一个测试不再需要任何`JSON.stringify`魔法。我们只需直接测试对象属性即可。更新测试如下：
- en: '[PRE27]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And finally, the last test can make use of the `dispatch` double function to
    dispatch an event to the parent component. Note how much simpler this is than
    the hand-rolled mock:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最后一个测试可以利用`dispatch`双函数将事件分发给父组件。注意这比手动编写的模拟要简单得多：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These last two tests show how much simpler it can be to use a component mock
    library over hand-rolled mocks. That completes this section. You’ve now discovered
    all there is to using the `svelte-component-double` library to simplify your test
    suites.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这两个测试展示了使用组件模拟库而不是手动编写的模拟可以多么简单。这完成了本节的内容。你现在已经发现了使用`svelte-component-double`库简化测试套件的全部内容。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has taken a very detailed look at component mocks. We started by
    looking at how it’s often possible to avoid using component mocks in the majority
    of cases, which is important because component mocks are a big cause of complexity
    in test suites.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细探讨了组件模拟。我们首先探讨了在大多数情况下通常可以避免使用组件模拟，这很重要，因为组件模拟是测试套件复杂性的主要原因之一。
- en: You then saw how to use hand-rolled mocks that take advantage of Vitest’s `vi.mock`
    function together with component stubs in the specially named `__mocks__` directory.
    You also saw how they can quickly become complex.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你看到了如何使用利用Vitest的`vi.mock`函数和特别命名的`__mocks__`目录中的组件存根的手动编写的模拟。你也看到了它们如何迅速变得复杂。
- en: Finally, we looked at using the `svelte-component-double` library to avoid using
    hand-rolled mocks. This provides a couple of simple matchers together with some
    helper functions to assist you in writing tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用`svelte-component-double`库来避免使用手动编写的模拟。这提供了一些简单的匹配器和一些辅助函数，以帮助你编写测试。
- en: 'That completes all the unit testing topics within this book. The next chapter
    adds one more testing technique: using Cucumber.js to write **Behavior-Driven
    Development** (**BDD**) style tests for your team.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本书中所有单元测试主题。下一章将增加一种测试技术：使用Cucumber.js为团队编写**行为驱动开发**（**BDD**）风格的测试。
